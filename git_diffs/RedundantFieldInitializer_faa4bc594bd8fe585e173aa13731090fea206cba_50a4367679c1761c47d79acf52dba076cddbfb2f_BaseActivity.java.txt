diff --git a/qDict/src/main/java/com/annie/dictionary/BaseActivity.java b/qDict/src/main/java/com/annie/dictionary/BaseActivity.java
index 2b8b9eb..adc67c3 100644
--- a/qDict/src/main/java/com/annie/dictionary/BaseActivity.java
+++ b/qDict/src/main/java/com/annie/dictionary/BaseActivity.java
@@ -1,17 +1,5 @@
-
 package com.annie.dictionary;
 
-import java.util.Locale;
-
-import com.annie.dictionary.frags.ListDictFragment;
-import com.annie.dictionary.frags.NavigatorFragment;
-import com.annie.dictionary.utils.Utils;
-import com.annie.dictionary.utils.Utils.Def;
-import com.mmt.app.SlidingFragmentActivity;
-import com.mmt.app.SystemBarTintManager;
-import com.mmt.widget.slidemenu.SlidingMenu;
-import com.mmt.widget.slidemenu.SlidingMenu.OnClosedListener;
-
 import android.Manifest;
 import android.annotation.TargetApi;
 import android.content.Context;
@@ -21,6 +9,7 @@ import android.content.res.Configuration;
 import android.net.Uri;
 import android.os.Bundle;
 import android.provider.Settings;
+import android.support.annotation.NonNull;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentTransaction;
 import android.text.TextUtils;
@@ -29,28 +18,38 @@ import android.view.View;
 import android.view.Window;
 import android.view.WindowManager;
 
-public abstract class BaseActivity extends SlidingFragmentActivity {
-
-    protected Fragment mFrag;
-
-    protected SharedPreferences mSharedPreferences;
+import com.annie.dictionary.frags.ListDictFragment;
+import com.annie.dictionary.frags.NavigatorFragment;
+import com.annie.dictionary.utils.Utils;
+import com.annie.dictionary.utils.Utils.Def;
+import com.mmt.app.SlidingFragmentActivity;
+import com.mmt.app.SystemBarTintManager;
+import com.mmt.widget.slidemenu.SlidingMenu;
+import com.mmt.widget.slidemenu.SlidingMenu.OnClosedListener;
 
-    protected int mThemeIndex;
+import java.util.Locale;
 
-    String mCurrentLanguage;
+public abstract class BaseActivity extends SlidingFragmentActivity {
 
+    public final static int REQUEST_STORAGE_CODE = 1001;
+    public final static int REQUEST_ALERT_WINDOW_CODE = 1003;
     /**
      * Read and write permission for storage listed here.
      */
-    public static String STORAGE_PERMISSIONS[] = new String[] {
+    public static String STORAGE_PERMISSIONS[] = new String[]{
             Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_EXTERNAL_STORAGE
     };
+    protected Fragment mFrag;
+    protected SharedPreferences mSharedPreferences;
+    protected int mThemeIndex;
+    String mCurrentLanguage;
+    OnClosedListener mOnClosedListener = new OnClosedListener() {
 
-    public final static int REQUEST_STORAGE_CODE = 1001;
-
-    public final static int REQUEST_ALERT_WINDOW_CODE = 1003;
-
-    public static boolean isActive = false;
+        @Override
+        public void onClosed() {
+            onMenuClose();
+        }
+    };
 
     public void checkPermission(int requestCode) {
         switch (requestCode) {
@@ -81,7 +80,7 @@ public abstract class BaseActivity extends SlidingFragmentActivity {
     public abstract void onRequestPermissionResult(int requestCode, boolean isSucess);
 
     @Override
-    public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
+    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
         switch (requestCode) {
             case REQUEST_STORAGE_CODE:
             case REQUEST_ALERT_WINDOW_CODE:
@@ -107,7 +106,7 @@ public abstract class BaseActivity extends SlidingFragmentActivity {
         mSharedPreferences = getSharedPreferences(Def.APP_NAME, Context.MODE_PRIVATE);
         setLanguage();
         mThemeIndex = mSharedPreferences.getInt("prefs_key_theme", 0);
-        Utils.onActivityCreateSetTheme(this, mThemeIndex, true);
+        Utils.onActivityCreateSetTheme(this, mThemeIndex, Utils.ThemeActivity.HOME);
         super.onCreate(savedInstanceState);
         setTitle(R.string.app_name);
         if (Utils.hasKk()) {
@@ -119,7 +118,12 @@ public abstract class BaseActivity extends SlidingFragmentActivity {
         // set the Behind View
         setBehindContentView(R.layout.menu_frame);
         // float density = getResources().getDisplayMetrics().density;
-        boolean headerShow = getResources().getBoolean(R.bool.header_menu_visiable);
+        boolean headerShow;
+        try {
+            headerShow = getResources().getBoolean(R.bool.header_menu_visiable);
+        }catch (Exception e){
+            headerShow = false;
+        }
         findViewById(R.id.img_header).setVisibility(headerShow ? View.VISIBLE : View.GONE);
         if (savedInstanceState == null) {
             FragmentTransaction t = this.getSupportFragmentManager().beginTransaction();
@@ -127,7 +131,7 @@ public abstract class BaseActivity extends SlidingFragmentActivity {
             t.replace(R.id.menu_frame, mFrag);
             t.commit();
         } else {
-            mFrag = (Fragment)this.getSupportFragmentManager().findFragmentById(R.id.menu_frame);
+            mFrag = this.getSupportFragmentManager().findFragmentById(R.id.menu_frame);
         }
         // customize the SlidingMenu
         SlidingMenu sm = getSlidingMenu();
@@ -139,14 +143,6 @@ public abstract class BaseActivity extends SlidingFragmentActivity {
         sm.setOnClosedListener(mOnClosedListener);
     }
 
-    OnClosedListener mOnClosedListener = new OnClosedListener() {
-
-        @Override
-        public void onClosed() {
-            onMenuClose();
-        }
-    };
-
     public abstract void onMenuClose();
 
     private void setLanguage() {
@@ -196,7 +192,7 @@ public abstract class BaseActivity extends SlidingFragmentActivity {
     @Override
     protected void onSaveInstanceState(Bundle outState) {
         super.onSaveInstanceState(outState);
-    };
+    }
 
     public void backMainMenuFragment() {
         FragmentTransaction t = this.getSupportFragmentManager().beginTransaction();
diff --git a/qDict/src/main/java/com/annie/dictionary/DictSpeechEng.java b/qDict/src/main/java/com/annie/dictionary/DictSpeechEng.java
index ecca173..ffc7263 100644
--- a/qDict/src/main/java/com/annie/dictionary/DictSpeechEng.java
+++ b/qDict/src/main/java/com/annie/dictionary/DictSpeechEng.java
@@ -1,18 +1,19 @@
-
 package com.annie.dictionary;
 
-import java.util.Locale;
-
 import android.content.Context;
 import android.speech.tts.TextToSpeech;
 import android.text.TextUtils;
 
+import java.util.Locale;
+
 public class DictSpeechEng {
+    private static DictSpeechEng mSpeechEng;
     private TextToSpeech mTts = null;
-
     private boolean mCanSpeak = false;
 
-    private static DictSpeechEng mSpeechEng;
+    private DictSpeechEng(Context context) {
+        mTts = new TextToSpeech(context.getApplicationContext(), new TtsInitListener());
+    }
 
     public static DictSpeechEng getInstance(Context context) {
         if (mSpeechEng == null) {
@@ -21,10 +22,6 @@ public class DictSpeechEng {
         return mSpeechEng;
     }
 
-    private DictSpeechEng(Context context) {
-        mTts = new TextToSpeech(context.getApplicationContext(), new TtsInitListener());
-    }
-
     public void destroy() {
         if (mTts != null) {
             mTts.stop();
@@ -48,7 +45,7 @@ public class DictSpeechEng {
 
     @SuppressWarnings("deprecation")
     public int speak(String text) {
-        if (null != text && true == mCanSpeak && mTts != null) {
+        if (null != text && mCanSpeak && mTts != null) {
             mTts.speak(text, TextToSpeech.QUEUE_FLUSH, null);
             return text.length();
         }
@@ -65,13 +62,8 @@ public class DictSpeechEng {
             new Thread(new Runnable() {
                 @Override
                 public void run() {
-                    if (status == TextToSpeech.SUCCESS) {
-                        int result = mTts.setLanguage(Locale.US);
-                        if (result == TextToSpeech.Engine.CHECK_VOICE_DATA_PASS) {
-                            mCanSpeak = true;
-                        } else {
-                            mCanSpeak = false;
-                        }
+                    if (status == TextToSpeech.SUCCESS && mTts.setLanguage(Locale.US) == TextToSpeech.Engine.CHECK_VOICE_DATA_PASS) {
+                        mCanSpeak = true;
                     } else {
                         // Initialization failed.
                         mCanSpeak = false;
diff --git a/qDict/src/main/java/com/annie/dictionary/DictWebViewClient.java b/qDict/src/main/java/com/annie/dictionary/DictWebViewClient.java
index a3336c7..c7b0099 100644
--- a/qDict/src/main/java/com/annie/dictionary/DictWebViewClient.java
+++ b/qDict/src/main/java/com/annie/dictionary/DictWebViewClient.java
@@ -1,10 +1,5 @@
-
 package com.annie.dictionary;
 
-import com.annie.dictionary.utils.Utils.Def;
-import com.annie.dictionary.utils.WebViewClientCallback;
-import com.mmt.widget.M2tToast;
-
 import android.content.ActivityNotFoundException;
 import android.content.Context;
 import android.content.Intent;
@@ -12,6 +7,10 @@ import android.net.Uri;
 import android.webkit.WebView;
 import android.webkit.WebViewClient;
 
+import com.annie.dictionary.utils.Utils.Def;
+import com.annie.dictionary.utils.WebViewClientCallback;
+import com.mmt.widget.M2tToast;
+
 public class DictWebViewClient extends WebViewClient {
 
     private WebViewClientCallback mCallback = null;
@@ -36,7 +35,7 @@ public class DictWebViewClient extends WebViewClient {
                 myIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                 mContext.startActivity(myIntent);
             } catch (ActivityNotFoundException e) {
-                M2tToast.makeText(mContext, "No application can handle this request. Please install a webbrowser",
+                M2tToast.makeText(mContext, "No application can handle this request. Please install a web browser",
                         M2tToast.LENGTH_LONG).show();
             }
         }
diff --git a/qDict/src/main/java/com/annie/dictionary/MainActivity.java b/qDict/src/main/java/com/annie/dictionary/MainActivity.java
index 1c56958..ef84379 100644
--- a/qDict/src/main/java/com/annie/dictionary/MainActivity.java
+++ b/qDict/src/main/java/com/annie/dictionary/MainActivity.java
@@ -1,26 +1,6 @@
-
 package com.annie.dictionary;
 
-import java.util.ArrayList;
-import java.util.Locale;
-
-import com.annie.dictionary.frags.ListDictFragment;
-import com.annie.dictionary.frags.NavigatorFragment.NavigationCallbacks;
-import com.annie.dictionary.frags.RecentFragment;
-import com.annie.dictionary.frags.SearchFragment;
-import com.annie.dictionary.service.QDictService;
-import com.annie.dictionary.standout.StandOutWindow;
-import com.annie.dictionary.utils.Utils;
-import com.annie.dictionary.utils.Utils.DIALOG;
-import com.annie.dictionary.utils.Utils.Def;
-import com.annie.dictionary.utils.Utils.NAVIG;
-import com.annie.dictionary.utils.Utils.RECV_UI;
-import com.mmt.widget.DropDownListView;
-import com.mmt.widget.SlidingUpPanelLayout;
-import com.mmt.widget.SlidingUpPanelLayout.PanelState;
-import com.mmt.widget.slidemenu.SlidingMenu;
-import com.mmt.widget.slidemenu.SlidingMenu.CanvasTransformer;
-
+import android.annotation.TargetApi;
 import android.app.Activity;
 import android.app.Dialog;
 import android.app.ProgressDialog;
@@ -42,11 +22,11 @@ import android.os.SystemClock;
 import android.speech.RecognizerIntent;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentManager;
-import android.support.v4.app.FragmentTransaction;
 import android.support.v7.widget.Toolbar;
 import android.text.Editable;
 import android.text.Selection;
 import android.text.TextUtils;
+import android.util.Log;
 import android.view.Gravity;
 import android.view.KeyEvent;
 import android.view.MotionEvent;
@@ -63,92 +43,118 @@ import android.widget.LinearLayout.LayoutParams;
 import android.widget.TextView;
 import android.widget.Toast;
 
+import com.annie.dictionary.frags.ListDictFragment;
+import com.annie.dictionary.frags.NavigatorFragment.NavigationCallbacks;
+import com.annie.dictionary.frags.RecentFragment;
+import com.annie.dictionary.frags.SearchFragment;
+import com.annie.dictionary.service.QDictService;
+import com.annie.dictionary.standout.StandOutWindow;
+import com.annie.dictionary.utils.Utils;
+import com.annie.dictionary.utils.Utils.DIALOG;
+import com.annie.dictionary.utils.Utils.Def;
+import com.annie.dictionary.utils.Utils.NAVIG;
+import com.annie.dictionary.utils.Utils.RECV_UI;
+import com.mmt.widget.DropDownListView;
+import com.mmt.widget.SlidingUpPanelLayout;
+import com.mmt.widget.SlidingUpPanelLayout.PanelState;
+import com.mmt.widget.slidemenu.SlidingMenu;
+import com.mmt.widget.slidemenu.SlidingMenu.CanvasTransformer;
+
+import java.util.ArrayList;
+import java.util.Locale;
+
 public class MainActivity extends BaseActivity implements NavigationCallbacks, OnClickListener {
 
     public static final String ACTION_UPDATE_UI = "com.annie.dictionary.ACTION_UPDATE_UI";
 
     public static final String ACTION_UPDATE_KEY = "receiver_update_ui";
-
-    private CanvasTransformer mTransformer = new CanvasTransformer() {
-
-        @Override
-        public void transformCanvas(Canvas canvas, float percentOpen) {
-            canvas.scale(percentOpen, 1, 0, 0);
-        }
-    };
-
     // const
     public static final int REQUEST_CODE = 101;
-
     public static final int POPUPWORDSLIST_TIMER = 200;
-
     public static final int LIST_WORDS_NORMAL = 0;
-
     public static final int LIST_WORDS_FUZZY = 1;
-
     public static final int LIST_WORDS_PATTERN = 2;
-
     public static final int LIST_WORDS_FULLTEXT = 3;
-
-    // UI
-    private SlidingUpPanelLayout mLayout;
-
+    public static boolean hasStoragePermission = false;
+    //
+    public static boolean active = false;
+    private static Handler mProgressCBHandler = null;
     FragmentManager mFragmentManager;
-
-    FragmentTransaction mTransaction;
-
     Toolbar mToolbar;
+    // UX
+    DictSpeechEng mSpeechEng;
+    QDictions mDictions;
+    int mCurrentNavPosition = -1;
+    String tempKeyword;
+    int tempPos;
+    boolean onNavig = false;
+    private CanvasTransformer mTransformer = new CanvasTransformer() {
 
-    public static boolean hasStoragePermission = false;
-
+        @Override
+        public void transformCanvas(Canvas canvas, float percentOpen) {
+            canvas.scale(percentOpen, 1, 0, 0);
+        }
+    };
+    // UI
+    private SlidingUpPanelLayout mLayout;
     // dict
     private DictEditTextView mDictKeywordView = null;
-
     private TextView mInfoSearch;
-
-    private LinearLayout mInputLayout;
-
     private DropDownListView mDictKeywordsPopupList = null;
-
-    private ImageButton mActionMenu, mActionVoice, mActionWordsList;
-
+    private ImageButton mActionMenu, mActionWordsList;
     private ProgressDialog mProgressDialog = null;
-
-    // UX
-    DictSpeechEng mSpeechEng;
-
-    QDictions mDictions;
-
-    private ListWordsTask mListWordsTask = null;
-
     private Handler mPopupWordsListHandler = null;
-
-    private static Handler mProgressCBHandler = null;
-
     // keyboard handler
     private Handler mShowKeyboardHander = null;
-
     private Runnable mShowKeyboarRunable = null;
-
-    //
-    public static boolean active = false;
-
     private Runnable mPopupWordsListRunnable = null;
-
     private boolean mReplaceKeyword = false;
-
     private boolean mIsTaskRunning = false;
+    private ClipboardManager mClipboardManager = null;
+    private String mClipboardText = "";
 
-    int mCurrentNavPosition = -1;
+    private OnPrimaryClipChangedListener mClipboardListener = null;
 
-    private ClipboardManager mClipboardManager = null;
+    BroadcastReceiver mUIReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            int id = intent.getIntExtra(ACTION_UPDATE_KEY, -1);
+            if (id == RECV_UI.SELECT_DICT) {
+                backMainMenuFragment();
+            } else if (id == RECV_UI.CHANGE_THEME || id == RECV_UI.CHANGE_FONT) {
+                stopService();
+                Utils.changeToTheme(MainActivity.this);
+            } else if (id == RECV_UI.SEARCH_WORD) {
+                String keyword = intent.getStringExtra("receiver_keyword");
+                if (!TextUtils.isEmpty(keyword)) {
+                    mDictKeywordView.setText(keyword);
+                    showSearchContent();
+                }
+            } else if (id == RECV_UI.RELOAD_DICT) {
+                mDictions.initDicts();
+            } else if (id == RECV_UI.RUN_SERVICE) {
+                startService();
+            } else if (id == RECV_UI.CHANGE_FRAG) {
+                int pos = intent.getIntExtra("receiver_frag_position", NAVIG.RECENT);
+                if (mCurrentNavPosition == NAVIG.SEARCH) {
+                    setFragment("", pos);
+                }
+                mCurrentNavPosition = pos;
+            }
+        }
+    };
 
-    private String mClipboardText = "";
+    public static void lookupProgressCB(int progress) {
+        Message m = Message.obtain();
+        m.arg1 = progress;
+        m.setTarget(mProgressCBHandler);
+        m.sendToTarget();
+    }
 
     public void initClipboard() {
         if (Utils.hasHcAbove()) {
             if (mClipboardManager == null) {
-                mClipboardManager = (ClipboardManager)getSystemService(Context.CLIPBOARD_SERVICE);
+                mClipboardManager = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);
                 mClipboardManager.addPrimaryClipChangedListener(mClipboardListener);
             }
         }
@@ -163,14 +169,8 @@ public class MainActivity extends BaseActivity implements NavigationCallbacks, O
         }
     }
 
-    private OnPrimaryClipChangedListener mClipboardListener = new OnPrimaryClipChangedListener() {
-        public void onPrimaryClipChanged() {
-            clipboardCheck();
-        }
-    };
-
     private void clipboardCheck() {
-        String clipboardText = "";
+        String clipboardText;
         CharSequence s = null;
         if (mClipboardManager != null && mClipboardManager.hasPrimaryClip()) {
             s = mClipboardManager.getPrimaryClip().getItemAt(0).getText();
@@ -199,12 +199,12 @@ public class MainActivity extends BaseActivity implements NavigationCallbacks, O
         checkPermission(REQUEST_STORAGE_CODE);
         // UI: set the Above View
         setContentView(R.layout.content_frame);
-        mToolbar = (Toolbar)findViewById(R.id.main_toolbar);
+        mToolbar = (Toolbar) findViewById(R.id.main_toolbar);
         mToolbar.setTitle(null);
         setSupportActionBar(mToolbar);
         getSupportActionBar().setDefaultDisplayHomeAsUpEnabled(true);
         getSupportActionBar().setHomeButtonEnabled(true);
-        mLayout = (SlidingUpPanelLayout)findViewById(R.id.sliding_layout);
+        mLayout = (SlidingUpPanelLayout) findViewById(R.id.sliding_layout);
         mLayout.setPanelState(PanelState.HIDDEN);
         mLayout.setTouchEnabled(false);
         mFragmentManager = getSupportFragmentManager();
@@ -214,16 +214,17 @@ public class MainActivity extends BaseActivity implements NavigationCallbacks, O
         sm.setBehindScrollScale(0.0f);
         sm.setBehindCanvasTransformer(mTransformer);
         // layout_drag
-        mActionMenu = (ImageButton)findViewById(R.id.action_menu);
-        mActionVoice = (ImageButton)findViewById(R.id.action_voice);
-        mActionWordsList = (ImageButton)findViewById(R.id.action_wordslist);
+        mActionMenu = (ImageButton) findViewById(R.id.action_menu);
+        ImageButton mActionVoice = (ImageButton) findViewById(R.id.action_voice);
+        mActionWordsList = (ImageButton) findViewById(R.id.action_wordslist);
         mActionMenu.setOnClickListener(this);
         mActionVoice.setOnClickListener(this);
         mActionWordsList.setOnClickListener(this);
-        mInputLayout = (LinearLayout)findViewById(R.id.layout_input);
-        mInfoSearch = (TextView)findViewById(R.id.tv_info_search);
+        LinearLayout inputLayout;
+        inputLayout = (LinearLayout) findViewById(R.id.layout_input);
+        mInfoSearch = (TextView) findViewById(R.id.tv_info_search);
         mDictKeywordView = new DictEditTextView(this);
-        mInputLayout.addView(mDictKeywordView, 0,
+        inputLayout.addView(mDictKeywordView, 0,
                 new LayoutParams(0, android.view.ViewGroup.LayoutParams.MATCH_PARENT, 1));
         initDropList();
 
@@ -261,6 +262,14 @@ public class MainActivity extends BaseActivity implements NavigationCallbacks, O
                         SystemClock.uptimeMillis(), MotionEvent.ACTION_UP, 0, 0, 0));
             }
         };
+        if (Utils.hasHcAbove()){
+            mClipboardListener = new OnPrimaryClipChangedListener() {
+                public void onPrimaryClipChanged() {
+                    clipboardCheck();
+                }
+            };
+
+        }
         startService();
         registerReceiver(mUIReceiver, new IntentFilter(ACTION_UPDATE_UI));
     }
@@ -299,7 +308,7 @@ public class MainActivity extends BaseActivity implements NavigationCallbacks, O
         if (mCurrentNavPosition == NAVIG.SEARCH) {
             Fragment fragment = this.getSupportFragmentManager().findFragmentById(R.id.content_frame);
             if (fragment instanceof SearchFragment) {
-                SearchFragment fg = ((SearchFragment)fragment);
+                SearchFragment fg = ((SearchFragment) fragment);
                 if (fg.isSearch()) {
                     outState.putString("search_fragment_keyword", fg.getKeyword());
                 }
@@ -312,7 +321,7 @@ public class MainActivity extends BaseActivity implements NavigationCallbacks, O
     }
 
     private void initDropList() {
-        mDictKeywordsPopupList = (DropDownListView)findViewById(R.id.drop_list);
+        mDictKeywordsPopupList = (DropDownListView) findViewById(R.id.drop_list);
         mDictKeywordsPopupList.setFocusable(true);
         mDictKeywordsPopupList.setFocusableInTouchMode(true);
         mDictKeywordsPopupList.setListSelectionHidden(false);
@@ -321,12 +330,12 @@ public class MainActivity extends BaseActivity implements NavigationCallbacks, O
             @Override
             public void onItemClick(AdapterView<?> parent, View v, int position, long id) {
 
-                TextView textView = (TextView)v;
+                TextView textView = (TextView) v;
                 String keyword = textView.getText().toString();
 
                 mReplaceKeyword = true; // Don't response the
-                                        // onTextChanged event this
-                                        // time.
+                // onTextChanged event this
+                // time.
 
                 mDictKeywordView.setText(keyword);
                 mInfoSearch.setVisibility(View.GONE);
@@ -385,7 +394,7 @@ public class MainActivity extends BaseActivity implements NavigationCallbacks, O
     protected void onStop() {
         active = false;
         super.onStop();
-    };
+    }
 
     private void showProgressDialog() {
         mProgressDialog = new ProgressDialog(this);
@@ -403,13 +412,6 @@ public class MainActivity extends BaseActivity implements NavigationCallbacks, O
         mProgressDialog.show();
     }
 
-    public static void lookupProgressCB(int progress) {
-        Message m = Message.obtain();
-        m.arg1 = progress;
-        m.setTarget(mProgressCBHandler);
-        m.sendToTarget();
-    }
-
     private void startKeywordsList() {
         int listType = LIST_WORDS_NORMAL;
         String keyword = mDictKeywordView.getText().toString().trim();
@@ -432,22 +434,16 @@ public class MainActivity extends BaseActivity implements NavigationCallbacks, O
             }
         }
 
-        if (true == mIsTaskRunning) // One task is running.
+        if (!mIsTaskRunning) // One task is running.
         {
-            return;
-        } else {
             mIsTaskRunning = true;
             if (LIST_WORDS_NORMAL != listType)
                 showProgressDialog();
-            mListWordsTask = new ListWordsTask(listType);
+            ListWordsTask mListWordsTask = new ListWordsTask(listType);
             if (Build.VERSION.SDK_INT > 10)
-                mListWordsTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, new String[] {
-                        keyword
-                });
+                mListWordsTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, keyword);
             else {
-                mListWordsTask.execute(new String[] {
-                        keyword
-                });
+                mListWordsTask.execute(keyword);
             }
         }
     }
@@ -492,37 +488,8 @@ public class MainActivity extends BaseActivity implements NavigationCallbacks, O
         startActivityForResult(intent, REQUEST_CODE);
     }
 
-    BroadcastReceiver mUIReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            int id = intent.getIntExtra(ACTION_UPDATE_KEY, -1);
-            if (id == RECV_UI.SELECT_DICT) {
-                backMainMenuFragment();
-            } else if (id == RECV_UI.CHANGE_THEME || id == RECV_UI.CHANGE_FONT) {
-                stopService();
-                Utils.changeToTheme(MainActivity.this);
-            } else if (id == RECV_UI.SEARCH_WORD) {
-                String keyword = intent.getStringExtra("receiver_keyword");
-                if (!TextUtils.isEmpty(keyword)) {
-                    mDictKeywordView.setText(keyword);
-                    showSearchContent();
-                }
-            } else if (id == RECV_UI.RELOAD_DICT) {
-                mDictions.initDicts();
-            } else if (id == RECV_UI.RUN_SERVICE) {
-                startService();
-            } else if (id == RECV_UI.CHANGE_FRAG) {
-                int pos = intent.getIntExtra("receiver_frag_position", NAVIG.RECENT);
-                if (mCurrentNavPosition == NAVIG.SEARCH) {
-                    setFragment("", pos);
-                }
-                mCurrentNavPosition = pos;
-            }
-        }
-    };
-
     private void hideKeyboard() {
-        InputMethodManager inputManager = (InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE);
+        InputMethodManager inputManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
         // check if no view has focus:
         View view = getCurrentFocus();
         if (view != null) {
@@ -534,18 +501,18 @@ public class MainActivity extends BaseActivity implements NavigationCallbacks, O
         String keyword = mDictKeywordView.getText().toString().trim();
         Fragment fragment = this.getSupportFragmentManager().findFragmentById(R.id.content_frame);
         if (fragment instanceof SearchFragment) {
-            SearchFragment sFrag = (SearchFragment)fragment;
+            SearchFragment sFrag = (SearchFragment) fragment;
             sFrag.setDictions(mDictions);
             sFrag.setSpeechEng(mSpeechEng);
             sFrag.setKeyword(keyword);
             mCurrentNavPosition = NAVIG.SEARCH;
         } else {
             try {
-                mTransaction = mFragmentManager.beginTransaction();
                 Fragment searchFrag = SearchFragment.newInstance(mSpeechEng, mDictions, keyword, true);
-                mTransaction.replace(R.id.content_frame, searchFrag).commit();
+                mFragmentManager.beginTransaction().replace(R.id.content_frame, searchFrag).commit();
                 mCurrentNavPosition = NAVIG.SEARCH;
             } catch (IllegalStateException ex) {
+                Log.e("MainActivity", ex.toString());
             }
         }
 
@@ -567,6 +534,7 @@ public class MainActivity extends BaseActivity implements NavigationCallbacks, O
         }
     }
 
+    // call from layout xml
     public void onActionButtonClick(View v) {
         if (mLayout != null) {
             mLayout.setPanelState(PanelState.EXPANDED);
@@ -613,15 +581,8 @@ public class MainActivity extends BaseActivity implements NavigationCallbacks, O
         }
     }
 
-    String tempKeyword;
-
-    int tempPos;
-
-    boolean onNavig = false;
-
     public void setFragment(String keyword, int position) {
-        mTransaction = mFragmentManager.beginTransaction();
-        Fragment fragment = null;
+        Fragment fragment;
         switch (position) {
             case NAVIG.HOME:
             case NAVIG.SEARCH:
@@ -632,7 +593,7 @@ public class MainActivity extends BaseActivity implements NavigationCallbacks, O
                 fragment = this.getSupportFragmentManager().findFragmentById(R.id.content_frame);
                 boolean favorite = (position == NAVIG.FAVORITE);
                 if (fragment instanceof RecentFragment) {
-                    ((RecentFragment)fragment).setFavorite(favorite);
+                    ((RecentFragment) fragment).setFavorite(favorite);
                 } else {
                     fragment = new RecentFragment();
                     Bundle b = new Bundle();
@@ -645,11 +606,76 @@ public class MainActivity extends BaseActivity implements NavigationCallbacks, O
                 break;
         }
         if (fragment != null) {
-            mTransaction.replace(R.id.content_frame, fragment).commit();
+            mFragmentManager.beginTransaction().replace(R.id.content_frame, fragment).commit();
             mCurrentNavPosition = position;
         }
     }
 
+    private void showKeywordsList(String[] strWordsList) {
+        MyArrayAdapter keywordsAdapter = new MyArrayAdapter(this, strWordsList);
+        mDictKeywordsPopupList.setAdapter(keywordsAdapter);
+    }
+
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        if (requestCode == REQUEST_CODE) {
+            if (resultCode == Activity.RESULT_OK) {
+                ArrayList<String> results = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);
+                String keyword = results.get(0);
+                if (!TextUtils.isEmpty(keyword)) {
+                    mDictKeywordView.setText(keyword);
+                    runOnUiThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            showSearchContent();
+                        }
+                    });
+
+                }
+            }
+        }
+        super.onActivityResult(requestCode, resultCode, data);
+    }
+
+    @SuppressWarnings("deprecation")
+    @Override
+    public void onClick(View v) {
+        switch (v.getId()) {
+            case R.id.action_menu:
+                toggle();
+                break;
+            case R.id.action_voice:
+                startVoiceRecognition();
+                break;
+            case R.id.action_wordslist:
+                startKeywordsList();
+                break;
+            case R.id.action_share:
+                startActivity(Utils.getIntentShareData(MainActivity.class));
+                break;
+            case R.id.action_about:
+                showDialog(DIALOG.ABOUT);
+                break;
+            default:
+                break;
+        }
+    }
+
+    // / for menu
+    @SuppressWarnings("deprecation")
+    @Override
+    protected Dialog onCreateDialog(int id) {
+        switch (id) {
+            case DIALOG.ABOUT:
+                return Utils.createAboutDialog(this);
+            case DIALOG.CHANGE_LOG:
+                return Utils.createWhatsNewDialog(this);
+            default:
+                break;
+        }
+        return super.onCreateDialog(id);
+    }
+
     // Extend classes.
     private class DictEditTextView extends EditText {
 
@@ -704,8 +730,7 @@ public class MainActivity extends BaseActivity implements NavigationCallbacks, O
                     mDictKeywordsPopupList.setListSelectionHidden(false);
                     return true;
             }
-            if (KeyEvent.KEYCODE_SEARCH == keyCode || KeyEvent.KEYCODE_ENTER == keyCode
-                    || KeyEvent.KEYCODE_DPAD_CENTER == keyCode) {
+            if (KeyEvent.KEYCODE_ENTER == keyCode) {
                 if (type == LIST_WORDS_NORMAL) {
                     showSearchContent();
                 } else {
@@ -721,7 +746,7 @@ public class MainActivity extends BaseActivity implements NavigationCallbacks, O
             if (mPopupWordsListHandler != null)
                 mPopupWordsListHandler.removeCallbacks(mPopupWordsListRunnable);
 
-            if (mReplaceKeyword == true) {
+            if (mReplaceKeyword) {
                 mReplaceKeyword = false;
             } else {
                 String keyword = text.toString();
@@ -796,69 +821,4 @@ public class MainActivity extends BaseActivity implements NavigationCallbacks, O
         }
     }
 
-    private void showKeywordsList(String[] strWordsList) {
-        MyArrayAdapter keywordsAdapter = new MyArrayAdapter(this, strWordsList);
-        mDictKeywordsPopupList.setAdapter(keywordsAdapter);
-    }
-
-    @Override
-    public void onActivityResult(int requestCode, int resultCode, Intent data) {
-        if (requestCode == REQUEST_CODE) {
-            if (resultCode == Activity.RESULT_OK) {
-                ArrayList<String> results = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);
-                String keyword = results.get(0);
-                if (!TextUtils.isEmpty(keyword)) {
-                    mDictKeywordView.setText(keyword);
-                    runOnUiThread(new Runnable() {
-                        @Override
-                        public void run() {
-                            showSearchContent();
-                        }
-                    });
-
-                }
-            }
-        }
-        super.onActivityResult(requestCode, resultCode, data);
-    }
-
-    @SuppressWarnings("deprecation")
-    @Override
-    public void onClick(View v) {
-        switch (v.getId()) {
-            case R.id.action_menu:
-                toggle();
-                break;
-            case R.id.action_voice:
-                startVoiceRecognition();
-                break;
-            case R.id.action_wordslist:
-                startKeywordsList();
-                break;
-            case R.id.action_share:
-                startActivity(Utils.getIntentShareData(MainActivity.class));
-                break;
-            case R.id.action_about:
-                showDialog(DIALOG.ABOUT);
-                break;
-            default:
-                break;
-        }
-    }
-
-    // / for menu
-    @SuppressWarnings("deprecation")
-    @Override
-    protected Dialog onCreateDialog(int id) {
-        switch (id) {
-            case DIALOG.ABOUT:
-                return Utils.createAboutDialog(this);
-            case DIALOG.CHANGE_LOG:
-                return Utils.createWhatsNewDialog(this);
-            default:
-                break;
-        }
-        return super.onCreateDialog(id);
-    }
-
 }
diff --git a/qDict/src/main/java/com/annie/dictionary/MyArrayAdapter.java b/qDict/src/main/java/com/annie/dictionary/MyArrayAdapter.java
index 21c810c..18b8232 100644
--- a/qDict/src/main/java/com/annie/dictionary/MyArrayAdapter.java
+++ b/qDict/src/main/java/com/annie/dictionary/MyArrayAdapter.java
@@ -1,9 +1,5 @@
-
 package com.annie.dictionary;
 
-import com.annie.dictionary.utils.Utils;
-import com.annie.dictionary.utils.Utils.Def;
-
 import android.content.Context;
 import android.content.SharedPreferences;
 import android.graphics.Typeface;
@@ -13,21 +9,22 @@ import android.view.ViewGroup;
 import android.widget.ArrayAdapter;
 import android.widget.TextView;
 
+import com.annie.dictionary.utils.Utils;
+import com.annie.dictionary.utils.Utils.Def;
+
 /**
  * navigation adapter
- * 
+ *
  * @author madman
  */
 public class MyArrayAdapter extends ArrayAdapter<String> {
+    LayoutInflater inflater;
     private String[] mObjects;
-
     private Typeface mFont;
 
-    LayoutInflater inflater;
-
     public MyArrayAdapter(Context context, String[] objects) {
         super(context, R.layout.simple_dropdown_item_1line_left, android.R.id.text1, objects);
-        inflater = (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+        inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
         mObjects = objects;
         SharedPreferences share = context.getSharedPreferences(Def.APP_NAME, Context.MODE_PRIVATE);
         mFont = Utils.getFont(context, share.getString(Def.PREF_KEY_FONT, Def.DEFAULT_FONT));
@@ -39,9 +36,9 @@ public class MyArrayAdapter extends ArrayAdapter<String> {
 
     @Override
     public View getView(int position, View convertView, ViewGroup parent) {
-        TextView view = (TextView)convertView;
+        TextView view = (TextView) convertView;
         if (view == null) {
-            view = (TextView)inflater.inflate(R.layout.simple_dropdown_item_1line_left, parent, false);
+            view = (TextView) inflater.inflate(R.layout.simple_dropdown_item_1line_left, parent, false);
             view.setTypeface(mFont);
         }
         view.setText(mObjects[position]);
diff --git a/qDict/src/main/java/com/annie/dictionary/PathSelectActivity.java b/qDict/src/main/java/com/annie/dictionary/PathSelectActivity.java
new file mode 100644
index 0000000..c4a1c38
--- /dev/null
+++ b/qDict/src/main/java/com/annie/dictionary/PathSelectActivity.java
@@ -0,0 +1,226 @@
+package com.annie.dictionary;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.graphics.drawable.Drawable;
+import android.os.Bundle;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.ViewGroup;
+import android.widget.AdapterView;
+import android.widget.AdapterView.OnItemClickListener;
+import android.widget.BaseAdapter;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import com.annie.dictionary.frags.SettingFragment;
+import com.annie.dictionary.utils.Utils;
+import com.mmt.app.ActionBarListActivity;
+import com.mmt.widget.QButton;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+
+public class PathSelectActivity extends ActionBarListActivity implements OnItemClickListener {
+    public static final int SELECT_TYPE_FOLDER = 0x000;
+    public static final int SELECT_TYPE_FILE = 0x001;
+    public static final String DEFAULT_PATH = "DEFAULT_PATH";
+    public static final String SELECT_TYPE = "SELECT_TYPE";
+    private final String TAG = "PathSelectActivity";
+    public String dictDefaultPath;
+
+    private String rootPath = Utils.getSDCardPath();
+    private String curPath = null;
+
+    private TextView mDictPath = null;
+    private String mFilePath = null;
+    private List<String> paths = null;
+
+    private int mSelectType = 0;
+
+    @Override
+    protected void onCreate(Bundle icicle) {
+        super.onCreate(icicle);
+        SharedPreferences share = getSharedPreferences(Utils.Def.APP_NAME, Context.MODE_PRIVATE);
+        int mThemeIndex = share.getInt("prefs_key_theme", 0);
+        Utils.onActivityCreateSetTheme(this, mThemeIndex, Utils.ThemeActivity.DIALOG);
+        if (getSupportActionBar() != null)
+            getSupportActionBar().hide();
+        setContentView(R.layout.file_select);
+
+        dictDefaultPath = Utils.getRootDictFolder(share);
+        Intent intent = this.getIntent();
+        Bundle bundle = intent.getExtras();
+
+        if (null != bundle) {
+            curPath = bundle.getString(DEFAULT_PATH);
+            mSelectType = bundle.getInt(SELECT_TYPE);
+        }
+
+        if (null == curPath) {
+            curPath = rootPath;
+        }
+        if (0 == mSelectType) {
+            mSelectType = SELECT_TYPE_FOLDER;
+        }
+
+        mDictPath = (TextView) findViewById(R.id.dictPath);
+        QButton buttonConfirm = (QButton) findViewById(R.id.buttonConfirm);
+        getListView().setOnItemClickListener(this);
+        buttonConfirm.setOnClickListener(new OnClickListener() {
+            public void onClick(View v) {
+                String filePath;
+                if (SELECT_TYPE_FILE == mSelectType) {
+                    if (null == mFilePath) {
+                        finish();
+                        return;
+                    }
+                    filePath = mFilePath;
+                } else {
+                    filePath = curPath;
+                }
+
+                Intent intent = new Intent(SettingFragment.DATA_SOURCE_INTENT);
+                Bundle bundle = new Bundle();
+                bundle.putString("filePath", filePath);
+                intent.putExtras(bundle);
+                sendBroadcast(intent);
+                finish();
+            }
+        });
+
+        QButton buttonCancle = (QButton) findViewById(R.id.buttonCancle);
+        buttonCancle.setOnClickListener(new OnClickListener() {
+
+            public void onClick(View v) {
+                finish();
+            }
+        });
+
+        getFileDir(curPath);
+    }
+
+    private void getFileDir(String filePath) {
+        File f = new File(filePath);
+
+        if (!f.exists()) {
+            f = new File(dictDefaultPath);
+        }
+
+        if (!f.canRead())
+            return;
+
+        mDictPath.setText(filePath);
+        List<String> items = new ArrayList<>();
+        paths = new ArrayList<>();
+
+        File[] files = f.listFiles();
+
+        if (!rootPath.startsWith(filePath)) {
+            items.add("b1");
+            paths.add(rootPath);
+
+            if (null != f.getParent()) {
+                items.add("b2");
+                paths.add(f.getParent());
+            }
+        }
+
+        if (f.exists()) {
+            for (File file : files) {
+                if (file.canRead()) {
+                    items.add(file.getName());
+                    paths.add(file.getPath());
+                }
+            }
+        }
+
+        setListAdapter(new FileManagerAdapter(this, items, paths));
+    }
+
+    @Override
+    public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
+        String filePath = paths.get(position);
+        File file = new File(filePath);
+        if (file.isDirectory()) {
+            curPath = paths.get(position);
+            getFileDir(curPath);
+            mFilePath = null;
+        } else if (SELECT_TYPE_FILE == mSelectType) {
+            mDictPath.setText(filePath);
+            mFilePath = filePath;
+        }
+    }
+
+    // Adapter
+    private class FileManagerAdapter extends BaseAdapter {
+        private LayoutInflater mInflater;
+        private Drawable mIcon1;
+        private Drawable mIcon2;
+        private Drawable mIcon3;
+        private List<String> items;
+        private List<String> filePaths;
+
+        public FileManagerAdapter(Context context, List<String> it,
+                                  List<String> pa) {
+            mInflater = LayoutInflater.from(context);
+            items = it;
+            filePaths = pa;
+            mIcon1 = Utils.getDrawable(PathSelectActivity.this, R.attr.icon_folder_back);
+            mIcon2 = Utils.getDrawable(PathSelectActivity.this, R.attr.icon_folder);
+            mIcon3 = Utils.getDrawable(PathSelectActivity.this, R.attr.icon_file);
+        }
+
+        public int getCount() {
+            return items.size();
+        }
+
+        public Object getItem(int position) {
+            return items.get(position);
+        }
+
+        public long getItemId(int position) {
+            return position;
+        }
+
+        public View getView(int position, View convertView, ViewGroup parent) {
+            ViewHolder holder;
+
+            if (convertView == null) {
+                convertView = mInflater.inflate(R.layout.file_row, null);
+                holder = new ViewHolder();
+                holder.text = (TextView) convertView.findViewById(R.id.text);
+                holder.icon = (ImageView) convertView.findViewById(R.id.icon);
+                convertView.setTag(holder);
+            } else {
+                holder = (ViewHolder) convertView.getTag();
+            }
+
+            File f = new File(filePaths.get(position));
+
+            if (items.get(position).equals("b1")) {
+                holder.text.setText("  /");
+                holder.icon.setImageDrawable(mIcon1);
+            } else if (items.get(position).equals("b2")) {
+                holder.text.setText("  ..");
+                holder.icon.setImageDrawable(mIcon1);
+            } else {
+                holder.text.setText(String.format("  %s", f.getName()));
+                if (f.isDirectory()) {
+                    holder.icon.setImageDrawable(mIcon2);
+                } else {
+                    holder.icon.setImageDrawable(mIcon3);
+                }
+            }
+            return convertView;
+        }
+
+        private class ViewHolder {
+            TextView text;
+            ImageView icon;
+        }
+    }
+}
\ No newline at end of file
diff --git a/qDict/src/main/java/com/annie/dictionary/QDictEng.java b/qDict/src/main/java/com/annie/dictionary/QDictEng.java
index 49a50d0..a5fe5fe 100644
--- a/qDict/src/main/java/com/annie/dictionary/QDictEng.java
+++ b/qDict/src/main/java/com/annie/dictionary/QDictEng.java
@@ -1,8 +1,6 @@
-
 package com.annie.dictionary;
 
 public class QDictEng {
-    private final String TAG = "QDictEng";
 
     public static String[] sDictPaths = null;
 
@@ -14,6 +12,10 @@ public class QDictEng {
 
     private static QDictEng mQDictEng = null;
 
+    static {
+        System.loadLibrary("qdicteng");
+    }
+
     public QDictEng() {
     }
 
@@ -24,6 +26,13 @@ public class QDictEng {
         return mQDictEng;
     }
 
+    // This function is called in JNI C code, it must be 'static' function.
+    private static void lookupProgressCB(int progress) {
+        MainActivity.lookupProgressCB(progress);
+    }
+
+    // -----------------------------------------------------------------------------------------------------//
+
     public void releaseQDictEng() {
         mReferenct--;
         if (0 == mReferenct) {
@@ -32,46 +41,33 @@ public class QDictEng {
         }
     }
 
-    // This function is called in JNI C code, it must be 'static' function.
-    private static void lookupProgressCB(int progress) {
-        MainActivity.lookupProgressCB(progress);
-    }
-
-    // -----------------------------------------------------------------------------------------------------//
-
     // Native function in QDictEng.c
     public native void CancelLookup();
+    // DICT_TYPE_INDEX,
+    // DICT_TYPE_CAPTURE
+    // and
+    // DICT_TYPE_MEMORIZE.
 
     public native String[] Lookup(String word, int type); // This function for
-                                                          // DICT_TYPE_INDEX,
-                                                          // DICT_TYPE_CAPTURE
-                                                          // and
-                                                          // DICT_TYPE_MEMORIZE.
+    // the type DICT_TYPE_INDEX.
 
     public native String[] ListWords(String word); // This function is only for
-                                                   // the type DICT_TYPE_INDEX.
+    // for the type
+    // DICT_TYPE_INDEX.
 
     public native String[] FuzzyListWords(String word); // This function is only
-                                                        // for the type
-                                                        // DICT_TYPE_INDEX.
+    // only for the type
+    // DICT_TYPE_INDEX.
 
     public native String[] PatternListWords(String word); // This function is
-                                                          // only for the type
-                                                          // DICT_TYPE_INDEX.
+    // only for the type
+    // DICT_TYPE_INDEX.
 
     public native String[] FullTextListWords(String word); // This function is
-                                                           // only for the type
-                                                           // DICT_TYPE_INDEX.
 
     public native String GetBookName(String ifoPath);
 
-    public native String[] GetInfo(String ifoPath);
-
     public native boolean LoadDicts(String[] paths, String[] names, int[] types);
 
     public native void UnloadDicts();
-
-    static {
-        System.loadLibrary("qdicteng");
-    }
 }
diff --git a/qDict/src/main/java/com/annie/dictionary/QDictions.java b/qDict/src/main/java/com/annie/dictionary/QDictions.java
index 30ac375..57327da 100644
--- a/qDict/src/main/java/com/annie/dictionary/QDictions.java
+++ b/qDict/src/main/java/com/annie/dictionary/QDictions.java
@@ -1,24 +1,21 @@
-
 package com.annie.dictionary;
 
-import java.io.File;
-import java.lang.ref.WeakReference;
-import java.util.Locale;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import com.annie.dictionary.utils.Utils;
-import com.annie.dictionary.utils.Utils.Def;
-
 import android.content.Context;
 import android.content.SharedPreferences;
 import android.content.SharedPreferences.Editor;
 import android.text.TextUtils;
-import android.util.DisplayMetrics;
 import android.util.Log;
-import android.view.WindowManager;
 import android.webkit.WebView;
 
+import com.annie.dictionary.utils.Utils;
+import com.annie.dictionary.utils.Utils.Def;
+
+import java.io.File;
+import java.lang.ref.WeakReference;
+import java.util.Locale;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
 public class QDictions {
     // private final String FILTER_SYMBOLS =
     // "\"\\^\\$\\*\\+\\{\\}\\[\\]\\?\\(\\)\\|\\\\,.:;/=_!@#%&<>`~0123456789";
@@ -33,11 +30,51 @@ public class QDictions {
     private SharedPreferences mSharedPrefs;
 
     public QDictions(Context context) {
-        mContext = new WeakReference<Context>(context);
+        mContext = new WeakReference<>(context);
         mSharedPrefs = mContext.get().getSharedPreferences(Def.APP_NAME, Context.MODE_PRIVATE);
         mQDictEng = QDictEng.createQDictEng();
     }
 
+    public static String getTextHtmlColor() {
+        return "#" + Def.DEFAULT_TEXT_COLOR.substring(3);
+    }
+
+    public static String getWordHtmlColor() {
+        return "#" + Def.DEFAULT_WORD_COLOR.substring(3);
+    }
+
+    public static String getReadmeHtml(Context context, SharedPreferences shares) {
+        // CharSequence content = Utils.getTextFromAssets(mContext, "help.txt");
+        String content = context.getResources().getString(R.string.readme_text);
+        String textColor = getTextHtmlColor();
+        String wordColor = getWordHtmlColor();
+        String font = shares.getString(Def.PREF_KEY_FONT, Def.DEFAULT_FONT);
+        String head = "<head><style>@font-face {font-family:'Unicode';src:url('file:///android_asset/fonts/" + font
+                + "');}";
+        head += "@font-face {font-family:'KPhonetic';src:url('file:///android_asset/fonts/KPhonetic.ttf');}";
+        head += " body,font{font-family:'Unicode';} i,b{font-family: sans-serif;}</style></head>";
+
+        String html = "<html>" + head + "<body style='color:" + textColor + "'>" + content + "</body></html>";
+
+        html = html.replace("color:#TOBEREPLACE;", "color:" + wordColor + ";");
+        return html;
+
+    }
+
+    public static void showHtmlContent(String content, WebView webView) {
+        if (webView != null) {
+            if (!content.contains("<body style='color:")) {
+                content = "<body style='color:" + getTextHtmlColor() + "'>" + content + "</body>";
+            }
+            try {
+                webView.loadDataWithBaseURL(null, content, Def.MIME_TYPE, Def.HTML_ENCODING, null);
+            } catch (Exception ex) {
+                Log.e("QDictions", ex.toString());
+            }
+            webView.scrollTo(0, 0);
+        }
+    }
+
     public void initDicts() {
         mQDictEng.UnloadDicts();
         loadDictsFromFolder();
@@ -45,19 +82,18 @@ public class QDictions {
     }
 
     private String[] lookupWord(String word) {
-        String strWordsArray[] = null;
-        String keyword = word;
-        String keyword2 = "";
-        if (keyword.length() <= 0)
+        String strWordsArray[];
+        String keyword;
+        if (word.length() <= 0)
             return null;
-        strWordsArray = mQDictEng.Lookup(keyword, DICT_TYPE_INDEX);
+        strWordsArray = mQDictEng.Lookup(word, DICT_TYPE_INDEX);
         if (null != strWordsArray && strWordsArray.length > 0)
             return strWordsArray;
         // step 2: to lowercase.
-        keyword2 = keyword.toLowerCase(Locale.US);
-        if (keyword2.equals(keyword))
+        keyword = word.toLowerCase(Locale.US);
+        if (keyword.equals(word))
             return null;
-        strWordsArray = mQDictEng.Lookup(keyword2, DICT_TYPE_INDEX);
+        strWordsArray = mQDictEng.Lookup(keyword, DICT_TYPE_INDEX);
         return strWordsArray;
     }
 
@@ -69,16 +105,14 @@ public class QDictions {
             for (String dictIndex : dictIndexArray) {
                 boolean bFound = false;
                 for (int i = 0; i < k; i++) {
-                    if (dictFolders[i] == null)
-                        continue;
-                    else if (dictFolders[i].equals(dictIndex)) {
+                    if (!TextUtils.isEmpty(dictFolders[i]) && dictFolders[i].equals(dictIndex)) {
                         bFound = true;
                         break;
                     }
                 }
                 // Not found this dictionary, it has been
                 // removed from the SD card.
-                if (false == bFound) { // Remove it from the configuration file.
+                if (!bFound) { // Remove it from the configuration file.
                     removeDictInArrays(Def.PREF_INDEX_CHECKED, dictIndex);
                     removeDictInArrays(Def.PREF_INDEX_ALL, dictIndex);
                 }
@@ -88,14 +122,12 @@ public class QDictions {
         for (int i = 0; i < k; i++) {
             boolean bFound = false;
             for (String dictIndex : dictIndexArray) {
-                if (dictFolders[i] == null)
-                    continue;
-                else if (dictFolders[i].equals(dictIndex)) {
+                if (!TextUtils.isEmpty(dictFolders[i]) && dictFolders[i].equals(dictIndex)) {
                     bFound = true;
                     break;
                 }
             }
-            if (false == bFound) {
+            if (!bFound) {
                 addDictInArrays(Def.PREF_INDEX_ALL, dictFolders[i]);
             }
         }
@@ -115,11 +147,11 @@ public class QDictions {
                 lDictPaths[i] = dictsPath + "/" + dictIndex + "/";
                 for (int k = 0; k < dictFolders.length; k++) {
                     try {
-                        if (dictFolders[k] == null)
-                            continue;
-                        else if (dictFolders[k].equals(dictIndex))
+                        if (!TextUtils.isEmpty(dictFolders[k]) && dictFolders[k].equals(dictIndex)) {
                             lDictNames[i] = dictNames[k];
+                        }
                     } catch (NullPointerException e) {
+                        Log.e("QDictions", e.toString());
                     }
                 }
                 lDictTypes[i] = DICT_TYPE_INDEX;
@@ -146,11 +178,12 @@ public class QDictions {
     }
 
     private void loadDictsFromFolder() {
-        String dictsPath = Utils.getRootFolder() + Def.DICT_FOLDER;
+        String dictsPath = Utils.getRootDictFolder(mSharedPrefs) + Def.DICT_FOLDER;
         File f = new File(dictsPath);
 
         if (!f.exists()) {
-            f.mkdirs();
+            if (!f.mkdirs())
+                return;
         }
         if (!f.exists() || !f.isDirectory()) {
             Log.d("QDictions", "file is not exists ");
@@ -163,16 +196,14 @@ public class QDictions {
 
         int k = 0;
         File[] files = f.listFiles();
-        String dictPaths[] = new String[files.length];
         String dictFolders[] = new String[files.length];
         String dictNames[] = new String[files.length];
 
-        for (int i = 0; i < files.length; i++) {
-            if (files[i].isDirectory()) {
-                String dictName = Utils.getFileInfoName(files[i].getPath());
+        for (File file : files) {
+            if (file.isDirectory()) {
+                String dictName = Utils.getFileInfoName(file.getPath());
                 if (null != dictName) {
-                    dictPaths[k] = files[i].getPath();
-                    dictFolders[k] = files[i].getName();
+                    dictFolders[k] = file.getName();
                     dictNames[k] = dictName;
                     k++;
                 }
@@ -188,7 +219,7 @@ public class QDictions {
             String mDictIndexAll = mSharedPrefs.getString(Def.PREF_INDEX_ALL, mEmptyList);
             if (mDictIndexAll.equals("")) {
                 for (int m = 0; m < k; m++) {
-                    mDictIndexAll = addDictInArrays(Def.PREF_INDEX_ALL, dictFolders[m]);
+                    addDictInArrays(Def.PREF_INDEX_ALL, dictFolders[m]);
                 }
             }
         }
@@ -221,12 +252,12 @@ public class QDictions {
 
     /**
      * Replace label attribute content.
-     * 
-     * @param str : the string to be replaced
+     *
+     * @param str       : the string to be replaced
      * @param beforeTag : the label to be replaced
      * @param tagAttrib : the lable's attribute to be replaced
-     * @param startTag : the begin of the new label
-     * @param endTag : the end of the new label
+     * @param startTag  : the begin of the new label
+     * @param endTag    : the end of the new label
      */
     private String replaceHtmlTag(String str, String beforeTag, String tagAttrib, String startTag, String endTag) {
         String regxpForTag = "<\\s*" + beforeTag + "\\s+([^>]*)>";
@@ -263,25 +294,10 @@ public class QDictions {
         return sb.toString();
     }
 
-    public static String getTextHtmlColor() {
-        return "#" + Def.DEFAULT_TEXT_COLOR.substring(3);
-    }
-
-    public static String getWordHtmlColor() {
-        return "#" + Def.DEFAULT_WORD_COLOR.substring(3);
-    }
-
-    public int getDensityDpi() {
-        DisplayMetrics displayMetrics = new DisplayMetrics();
-        ((WindowManager)(mContext.get().getSystemService(Context.WINDOW_SERVICE))).getDefaultDisplay()
-                .getMetrics(displayMetrics);
-        return displayMetrics.densityDpi;
-    }
-
     public String generateHtmlContent(String word) {
-        String html = "";
+        String html;
         String dictHtmlData = "";
-        String dictCheckeds = mEmptyList;
+        String dictCheckeds;
 
         String strWordsArray[] = lookupWord(word);
         if (null == strWordsArray)
@@ -292,8 +308,8 @@ public class QDictions {
         String[] dictCheckedArrays = dictCheckeds.split(";");
         // This is for dictionary order.
         String dictContentArray[] = new String[dictCheckedArrays.length];
-        for (int i = 0; i < strWordsArray.length;) {
-            String dictContent = "";
+        for (int i = 0; i < strWordsArray.length; ) {
+            String dictContent;
             if (null != strWordsArray[i] && null != strWordsArray[i + 1] && null != strWordsArray[i + 2]) {
                 int dictID = Integer.parseInt(strWordsArray[i]);
                 String strResPath = "file://" + QDictEng.sDictPaths[dictID] + "res/";
@@ -328,7 +344,7 @@ public class QDictions {
                 // This is for dictionary order.
                 int k = 0;
                 for (String dictChecked : dictCheckedArrays) {
-                    if (QDictEng.sDictPaths[dictID].indexOf(dictChecked) >= 0) {
+                    if (QDictEng.sDictPaths[dictID].contains(dictChecked)) {
                         dictContentArray[k] = dictContent;
                         break;
                     }
@@ -338,9 +354,9 @@ public class QDictions {
                 i += 3; // Ignore this dictionary.
             }
         }
-        for (int k = 0; k < dictContentArray.length; k++) {
-            if (null != dictContentArray[k])
-                dictHtmlData += dictContentArray[k];
+        for (String dictContent : dictContentArray) {
+            if (null != dictContent)
+                dictHtmlData += dictContent;
         }
         if (TextUtils.isEmpty(dictHtmlData)) {
             return mContext.get().getResources().getString(R.string.keywords_null);
@@ -358,60 +374,6 @@ public class QDictions {
         return html;
     }
 
-    public static String getReadmeHtml(Context context, SharedPreferences shares) {
-        // CharSequence content = Utils.getTextFromAssets(mContext, "help.txt");
-        String content = context.getResources().getString(R.string.readme_text);
-        String textColor = getTextHtmlColor();
-        String wordColor = getWordHtmlColor();
-        String font = shares.getString(Def.PREF_KEY_FONT, Def.DEFAULT_FONT);
-        String head = "<head><style>@font-face {font-family:'Unicode';src:url('file:///android_asset/fonts/" + font
-                + "');}";
-        head += "@font-face {font-family:'KPhonetic';src:url('file:///android_asset/fonts/KPhonetic.ttf');}";
-        head += " body,font{font-family:'Unicode';} i,b{font-family: sans-serif;}</style></head>";
-
-        String html = "<html>" + head + "<body style='color:" + textColor + "'>" + content + "</body></html>";
-
-        html = html.replace("color:#TOBEREPLACE;", "color:" + wordColor + ";");
-        return html;
-
-    }
-
-    public String getReadmeHtml() {
-        // CharSequence content = Utils.getTextFromAssets(mContext, "help.txt");
-        String content = mContext.get().getResources().getString(R.string.readme_text);
-        String textColor = getTextHtmlColor();
-        String wordColor = getWordHtmlColor();
-        String font = mSharedPrefs.getString(Def.PREF_KEY_FONT, Def.DEFAULT_FONT);
-        String head = "<head><style>@font-face {font-family:'Unicode';src:url('file:///android_asset/fonts/" + font
-                + "');}";
-        head += "@font-face {font-family:'KPhonetic';src:url('file:///android_asset/fonts/KPhonetic.ttf');}";
-        head += " body,font{font-family:'Unicode';} i,b{font-family: sans-serif;}</style></head>";
-
-        String html = "<html>" + head + "<body style='color:" + textColor + "'>" + content + "</body></html>";
-
-        html = html.replace("color:#TOBEREPLACE;", "color:" + wordColor + ";");
-
-        return html;
-    }
-
-    public void showHtmlByResId(int resId, WebView webView) {
-        showHtmlContent(mContext.get().getResources().getString(resId), webView);
-    }
-
-    public static void showHtmlContent(String content, WebView webView) {
-        if (webView != null) {
-            if (content.indexOf("<body style='color:") < 0) {
-                content = "<body style='color:" + getTextHtmlColor() + "'>" + content + "</body>";
-            }
-            try {
-                webView.loadDataWithBaseURL(null, content, Def.MIME_TYPE, Def.HTML_ENCODING, null);
-            } catch (Exception ex) {
-                Log.e("QDictions", ex.toString());
-            }
-            webView.scrollTo(0, 0);
-        }
-    }
-
     public String[] listWords(String word) {
         return mQDictEng.ListWords(word);
     }
@@ -432,10 +394,6 @@ public class QDictions {
         return mQDictEng.GetBookName(ifoPath);
     }
 
-    public String[] getDictInfo(String ifoPath) {
-        return mQDictEng.GetInfo(ifoPath);
-    }
-
     public void cancelLookup() {
         mQDictEng.CancelLookup();
     }
diff --git a/qDict/src/main/java/com/annie/dictionary/SettingsActivity.java b/qDict/src/main/java/com/annie/dictionary/SettingsActivity.java
index d18448b..62f333b 100644
--- a/qDict/src/main/java/com/annie/dictionary/SettingsActivity.java
+++ b/qDict/src/main/java/com/annie/dictionary/SettingsActivity.java
@@ -1,11 +1,5 @@
-
 package com.annie.dictionary;
 
-import com.annie.dictionary.frags.SettingFragment;
-import com.annie.dictionary.utils.Utils;
-import com.annie.dictionary.utils.Utils.Def;
-import com.mmt.app.SystemBarTintManager;
-
 import android.annotation.TargetApi;
 import android.content.Context;
 import android.content.SharedPreferences;
@@ -17,6 +11,11 @@ import android.view.MenuItem;
 import android.view.Window;
 import android.view.WindowManager;
 
+import com.annie.dictionary.frags.SettingFragment;
+import com.annie.dictionary.utils.Utils;
+import com.annie.dictionary.utils.Utils.Def;
+import com.mmt.app.SystemBarTintManager;
+
 public class SettingsActivity extends ActionBarActivity {
 
     protected Fragment mFrag;
@@ -27,7 +26,7 @@ public class SettingsActivity extends ActionBarActivity {
     protected void onCreate(Bundle savedInstanceState) {
         mSharedPreferences = getSharedPreferences(Def.APP_NAME, Context.MODE_PRIVATE);
         int themeIndex = mSharedPreferences.getInt("prefs_key_theme", 0);
-        Utils.onActivityCreateSetTheme(this, themeIndex, false);
+        Utils.onActivityCreateSetTheme(this, themeIndex, Utils.ThemeActivity.SETTING);
         super.onCreate(savedInstanceState);
         setContentView(R.layout.layout_settings);
         setTitle(R.string.settings_lable);
@@ -47,7 +46,7 @@ public class SettingsActivity extends ActionBarActivity {
         } else {
             mFrag = this.getSupportFragmentManager().findFragmentById(R.id.setting_frame);
             if (mFrag instanceof SettingFragment) {
-                ((SettingFragment)mFrag).SetSpeechEng(DictSpeechEng.getInstance(getApplicationContext()));
+                ((SettingFragment) mFrag).SetSpeechEng(DictSpeechEng.getInstance(getApplicationContext()));
             }
         }
     }
diff --git a/qDict/src/main/java/com/annie/dictionary/frags/BaseListFragment.java b/qDict/src/main/java/com/annie/dictionary/frags/BaseListFragment.java
index 1d62322..1f6582a 100644
--- a/qDict/src/main/java/com/annie/dictionary/frags/BaseListFragment.java
+++ b/qDict/src/main/java/com/annie/dictionary/frags/BaseListFragment.java
@@ -1,4 +1,3 @@
-
 package com.annie.dictionary.frags;
 
 import android.os.Bundle;
@@ -26,7 +25,7 @@ public abstract class BaseListFragment extends ListFragment {
             // same.
             // So we must remove rootView from the existing parent view group
             // (it will be added back).
-            ((ViewGroup)rootView.getParent()).removeView(rootView);
+            ((ViewGroup) rootView.getParent()).removeView(rootView);
             Log.e("NAMND", "No Create new View");
         }
 
diff --git a/qDict/src/main/java/com/annie/dictionary/frags/ListDictFragment.java b/qDict/src/main/java/com/annie/dictionary/frags/ListDictFragment.java
index f675ae3..18ad012 100644
--- a/qDict/src/main/java/com/annie/dictionary/frags/ListDictFragment.java
+++ b/qDict/src/main/java/com/annie/dictionary/frags/ListDictFragment.java
@@ -1,19 +1,5 @@
-
 package com.annie.dictionary.frags;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-import com.annie.dictionary.MainActivity;
-import com.annie.dictionary.QDictions;
-import com.annie.dictionary.R;
-import com.annie.dictionary.utils.Utils;
-import com.annie.dictionary.utils.Utils.Def;
-import com.annie.dictionary.utils.Utils.RECV_UI;
-import com.mmt.widget.DragSortListView;
-import com.mmt.widget.draglistview.DragSortController;
-
 import android.content.ActivityNotFoundException;
 import android.content.Context;
 import android.content.Intent;
@@ -34,31 +20,84 @@ import android.widget.ImageButton;
 import android.widget.RelativeLayout;
 import android.widget.TextView;
 
+import com.annie.dictionary.MainActivity;
+import com.annie.dictionary.QDictions;
+import com.annie.dictionary.R;
+import com.annie.dictionary.utils.Utils;
+import com.annie.dictionary.utils.Utils.Def;
+import com.annie.dictionary.utils.Utils.RECV_UI;
+import com.mmt.widget.DragSortListView;
+import com.mmt.widget.draglistview.DragSortController;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
 public class ListDictFragment extends ListFragment implements Def, OnItemClickListener {
 
+    String mDictsPath;
+    private ArrayList<String> mAllValueArrays;
+    private List<String> mCheckValues;
+    private QDictions mDictions;
+    private SharedPreferences mSharedPreferences;
+    private ArrayAdapter<String> mAdapter;
+    private DragSortListView mList;
+    private DragSortListView.DropListener onDrop = new DragSortListView.DropListener() {
+        @Override
+        public void drop(int from, int to) {
+            if (from != to) {
+                String item = mAdapter.getItem(from);
+                String itemValue = mAllValueArrays.get(from);
+                mAdapter.remove(item);
+                mAdapter.insert(item, to);
+                mAllValueArrays.remove(itemValue);
+                mAllValueArrays.add(to, itemValue);
+                mList.moveCheckState(from, to);
+                String valueSets = "";
+                for (String string : mAllValueArrays) {
+                    valueSets += string + ";";
+                }
+                mSharedPreferences.edit().putString(Def.PREF_INDEX_ALL, valueSets).apply();
+                String checkValues = "";
+                if (mCheckValues.contains(itemValue)) {
+                    int count = mAdapter.getCount();
+                    for (int i = 0; i < count; i++) {
+                        if (mList.isItemChecked(i)) {
+                            checkValues += mAllValueArrays.get(i) + ";";
+                        }
+                    }
+                    mSharedPreferences.edit().putString(Def.PREF_INDEX_CHECKED, checkValues).apply();
+                    String[] checks = checkValues.split(";");
+                    mCheckValues = Arrays.asList(checks);
+                }
+            }
+        }
+    };
+    private CheckBox mCheckBox;
+    private TextView mEmptyDictTv, mDictCountTv;
+    private RelativeLayout mEmptyDictLayout;
+
     public ListDictFragment() {
 
     }
-    public static final ListDictFragment newInstance(QDictions dictions){
+
+    public static ListDictFragment newInstance(QDictions dictions) {
         ListDictFragment f = new ListDictFragment();
         f.mDictions = dictions;
         return f;
     }
 
-    public void setDictions(QDictions dictions) {
-        mDictions = dictions;
-    }
-
     @Override
     public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
         View root = inflater.inflate(R.layout.layout_list_dict, container, false);
-        mDictsPath = Utils.getRootFolder() + Def.DICT_FOLDER;
-        mCheckBox = (CheckBox)root.findViewById(R.id.check_all);
-        mEmptyDictLayout = (RelativeLayout)root.findViewById(R.id.layout_empty);
-        mEmptyDictTv = (TextView)root.findViewById(R.id.tv_empty);
-        mDictCountTv = (TextView)root.findViewById(R.id.tv_dict_count);
-        mGotoFTPServer = (Button)root.findViewById(R.id.goto_ftp_server);
-        mGotoFTPServer.setOnClickListener(new View.OnClickListener() {
+        SharedPreferences shares = getActivity().getSharedPreferences(Def.APP_NAME, Context.MODE_PRIVATE);
+        mDictsPath = Utils.getRootDictFolder(shares) + Def.DICT_FOLDER;
+        mCheckBox = (CheckBox) root.findViewById(R.id.check_all);
+        mEmptyDictLayout = (RelativeLayout) root.findViewById(R.id.layout_empty);
+        mEmptyDictTv = (TextView) root.findViewById(R.id.tv_empty);
+        mDictCountTv = (TextView) root.findViewById(R.id.tv_dict_count);
+        Button gotoFTPServer = (Button) root.findViewById(R.id.goto_ftp_server);
+        gotoFTPServer.setOnClickListener(new View.OnClickListener() {
 
             @Override
             public void onClick(View v) {
@@ -88,8 +127,8 @@ public class ListDictFragment extends ListFragment implements Def, OnItemClickLi
                 isCurrentCheckAll();
             }
         });
-        mBackBtn = (ImageButton)root.findViewById(R.id.action_back);
-        mBackBtn.setOnClickListener(new View.OnClickListener() {
+        ImageButton backBtn = (ImageButton) root.findViewById(R.id.action_back);
+        backBtn.setOnClickListener(new View.OnClickListener() {
 
             @Override
             public void onClick(View v) {
@@ -111,7 +150,7 @@ public class ListDictFragment extends ListFragment implements Def, OnItemClickLi
         mDictions.initDicts();
         getDictInfo();
         DragSortListView list = getListView();
-        mController = new MyDSController(list);
+        DragSortController mController = new MyDSController(list);
         list.setFloatViewManager(mController);
         list.setDragEnabled(true);
         list.setDropListener(onDrop);
@@ -119,48 +158,16 @@ public class ListDictFragment extends ListFragment implements Def, OnItemClickLi
         mCheckBox.setChecked(isCurrentCheckAll());
     }
 
-    private DragSortListView.DropListener onDrop = new DragSortListView.DropListener() {
-        @Override
-        public void drop(int from, int to) {
-            if (from != to) {
-                String item = mAdapter.getItem(from);
-                String itemValue = mAllValueArrays.get(from);
-                mAdapter.remove(item);
-                mAdapter.insert(item, to);
-                mAllValueArrays.remove(itemValue);
-                mAllValueArrays.add(to, itemValue);
-                mList.moveCheckState(from, to);
-                String valueSets = "";
-                for (String string : mAllValueArrays) {
-                    valueSets += string + ";";
-                }
-                mSharedPreferences.edit().putString(Def.PREF_INDEX_ALL, valueSets).apply();
-                String checkValues = "";
-                if (mCheckValues.contains(itemValue)) {
-                    int count = mAdapter.getCount();
-                    for (int i = 0; i < count; i++) {
-                        if (mList.isItemChecked(i)) {
-                            checkValues += mAllValueArrays.get(i) + ";";
-                        }
-                    }
-                    mSharedPreferences.edit().putString(Def.PREF_INDEX_CHECKED, checkValues).apply();
-                    String[] checks = checkValues.split(";");
-                    mCheckValues = Arrays.asList(checks);
-                }
-            }
-        }
-    };
-
     @Override
     public DragSortListView getListView() {
-        return (DragSortListView)super.getListView();
+        return (DragSortListView) super.getListView();
     }
 
     private void getDictInfo() {
-        String dictAlls = "";
-        String selections = "";
+        String dictAlls;
+        String selections;
         String emptySet = "";
-        mAllInfoArrays = new ArrayList<String>();
+        ArrayList<String> mAllInfoArrays = new ArrayList<>();
         selections = mSharedPreferences.getString(Def.PREF_INDEX_CHECKED, emptySet);
         dictAlls = mSharedPreferences.getString(Def.PREF_INDEX_ALL, emptySet);
         if (dictAlls.equals("")) {
@@ -175,17 +182,14 @@ public class ListDictFragment extends ListFragment implements Def, OnItemClickLi
             String dictName = Utils.getFileInfoName(dictPath);
             if (null == dictName)
                 continue;
-            if (null != dictName) {
-                String bookIfoPath = "";
-                bookIfoPath = dictPath + "/" + dictName + ".ifo";
-                String bookName = mDictions.getBookName(bookIfoPath);
-                mAllInfoArrays.add(bookName);
-            }
+            String bookIfoPath = dictPath + "/" + dictName + ".ifo";
+            String bookName = mDictions.getBookName(bookIfoPath);
+            mAllInfoArrays.add(bookName);
         }
         List<String> abcs = Arrays.asList(dictAllArrays);
-        mAllValueArrays = new ArrayList<String>(abcs);
+        mAllValueArrays = new ArrayList<>(abcs);
         setEmptyDict(mAllInfoArrays.isEmpty(), mDictsPath);
-        mAdapter = new ArrayAdapter<String>(getActivity(), R.layout.listitem_check, R.id.text, mAllInfoArrays);
+        mAdapter = new ArrayAdapter<>(getActivity(), R.layout.listitem_check, R.id.text, mAllInfoArrays);
         setListAdapter(mAdapter);
         mList = getListView();
         for (String dictIndex : dictAllArrays) {
@@ -249,19 +253,15 @@ public class ListDictFragment extends ListFragment implements Def, OnItemClickLi
             mSharedPreferences.edit().putString(Def.PREF_INDEX_CHECKED, checkValues).apply();
             String[] checks = checkValues.split(";");
             mCheckValues = Arrays.asList(checks);
-            mAdapter.notifyDataSetChanged();
-            reloadDict();
-            return;
         } else {
             for (int i = 0; i < count; i++) {
                 mList.setItemChecked(i, false);
             }
             mSharedPreferences.edit().putString(Def.PREF_INDEX_CHECKED, checkValues).apply();
-            mCheckValues = new ArrayList<String>();
-            mAdapter.notifyDataSetChanged();
-            reloadDict();
-            return;
+            mCheckValues = new ArrayList<>();
         }
+        mAdapter.notifyDataSetChanged();
+        reloadDict();
     }
 
     private boolean isCurrentCheckAll() {
@@ -304,37 +304,11 @@ public class ListDictFragment extends ListFragment implements Def, OnItemClickLi
             int res = super.dragHandleHitPosition(ev);
             int width = mDslv.getWidth();
 
-            if ((int)ev.getX() < width / 3) {
+            if ((int) ev.getX() < width / 3) {
                 return res;
             } else {
                 return DragSortController.MISS;
             }
         }
     }
-
-    String mDictsPath;
-
-    private DragSortController mController;
-
-    private ArrayList<String> mAllInfoArrays, mAllValueArrays;
-
-    private List<String> mCheckValues;
-
-    private QDictions mDictions;
-
-    private SharedPreferences mSharedPreferences;
-
-    private ArrayAdapter<String> mAdapter;
-
-    private DragSortListView mList;
-
-    private ImageButton mBackBtn;
-
-    private CheckBox mCheckBox;
-
-    private TextView mEmptyDictTv, mDictCountTv;
-
-    private RelativeLayout mEmptyDictLayout;
-
-    private Button mGotoFTPServer;
 }
diff --git a/qDict/src/main/java/com/annie/dictionary/frags/NavigatorFragment.java b/qDict/src/main/java/com/annie/dictionary/frags/NavigatorFragment.java
index 1e5adeb..27a75c2 100644
--- a/qDict/src/main/java/com/annie/dictionary/frags/NavigatorFragment.java
+++ b/qDict/src/main/java/com/annie/dictionary/frags/NavigatorFragment.java
@@ -1,9 +1,5 @@
-
 package com.annie.dictionary.frags;
 
-import com.annie.dictionary.R;
-import com.mmt.widget.M2tListView;
-
 import android.app.Activity;
 import android.content.Context;
 import android.os.Bundle;
@@ -17,29 +13,28 @@ import android.widget.ArrayAdapter;
 import android.widget.ImageView;
 import android.widget.TextView;
 
+import com.annie.dictionary.R;
+import com.mmt.widget.M2tListView;
+
 public class NavigatorFragment extends Fragment implements OnItemClickListener {
 
+    NavigatorAdapter mAdapter1, mAdapter2;
+    String[] mFunctionLables;
+    String[] mSystemLables;
     private M2tListView mListView1, mListView2;
-
     /**
      * A pointer to the current callbacks instance (the Activity).
      */
     private NavigationCallbacks mCallbacks;
 
-    NavigatorAdapter mAdapter1, mAdapter2;
-
-    String[] mFunctionLables;
-
-    String[] mSystemLables;
-
     public NavigatorFragment() {
         // default constructor
     }
 
     public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
         View root = inflater.inflate(R.layout.layout_navigatior, container, false);
-        mListView1 = (M2tListView)root.findViewById(R.id.list1);
-        mListView2 = (M2tListView)root.findViewById(R.id.list2);
+        mListView1 = (M2tListView) root.findViewById(R.id.list1);
+        mListView2 = (M2tListView) root.findViewById(R.id.list2);
         mListView1.setExpanded(true);
         mListView2.setExpanded(true);
         return root;
@@ -76,7 +71,7 @@ public class NavigatorFragment extends Fragment implements OnItemClickListener {
     public void onAttach(Activity activity) {
         super.onAttach(activity);
         try {
-            mCallbacks = (NavigationCallbacks)activity;
+            mCallbacks = (NavigationCallbacks) activity;
         } catch (ClassCastException e) {
             throw new ClassCastException("Activity must implement NavigationCallbacks.");
         }
@@ -88,15 +83,15 @@ public class NavigatorFragment extends Fragment implements OnItemClickListener {
         mCallbacks = null;
     }
 
-    private class NavigatorItem {
-        public String tag;
-
-        public int iconRes;
-
-        public NavigatorItem(String tag, int iconRes) {
-            this.tag = tag;
-            this.iconRes = iconRes;
-        }
+    /**
+     * Callbacks interface that all activities using this fragment must
+     * implement.
+     */
+    public interface NavigationCallbacks {
+        /**
+         * Called when an item in the navigation drawer is selected.
+         */
+        void onNavigationItemSelected(String title, int position);
     }
 
     public static class NavigatorAdapter extends ArrayAdapter<NavigatorItem> {
@@ -109,23 +104,23 @@ public class NavigatorFragment extends Fragment implements OnItemClickListener {
             if (convertView == null) {
                 convertView = LayoutInflater.from(getContext()).inflate(R.layout.navi_row, parent, false);
             }
-            ImageView icon = (ImageView)convertView.findViewById(R.id.row_icon);
+            ImageView icon = (ImageView) convertView.findViewById(R.id.row_icon);
             icon.setImageResource(getItem(position).iconRes);
-            TextView title = (TextView)convertView.findViewById(R.id.row_title);
+            TextView title = (TextView) convertView.findViewById(R.id.row_title);
             title.setText(getItem(position).tag);
             return convertView;
         }
 
     }
 
-    /**
-     * Callbacks interface that all activities using this fragment must
-     * implement.
-     */
-    public static interface NavigationCallbacks {
-        /**
-         * Called when an item in the navigation drawer is selected.
-         */
-        void onNavigationItemSelected(String title, int position);
+    private class NavigatorItem {
+        public String tag;
+
+        public int iconRes;
+
+        public NavigatorItem(String tag, int iconRes) {
+            this.tag = tag;
+            this.iconRes = iconRes;
+        }
     }
 }
diff --git a/qDict/src/main/java/com/annie/dictionary/frags/PreferenceFragment.java b/qDict/src/main/java/com/annie/dictionary/frags/PreferenceFragment.java
index c96c33d..4eded18 100644
--- a/qDict/src/main/java/com/annie/dictionary/frags/PreferenceFragment.java
+++ b/qDict/src/main/java/com/annie/dictionary/frags/PreferenceFragment.java
@@ -1,9 +1,5 @@
-
 package com.annie.dictionary.frags;
 
-import com.annie.dictionary.R;
-import com.annie.dictionary.utils.Utils;
-
 import android.content.Intent;
 import android.os.Bundle;
 import android.os.Handler;
@@ -21,28 +17,44 @@ import android.view.View.OnKeyListener;
 import android.view.ViewGroup;
 import android.widget.ListView;
 
+import com.annie.dictionary.R;
+import com.annie.dictionary.utils.Utils;
+
 public abstract class PreferenceFragment extends Fragment
         implements PreferenceManagerCompat.OnPreferenceTreeClickListener {
 
     private static final String PREFERENCES_TAG = "android:preferences";
-
-    private PreferenceManager mPreferenceManager;
-
-    private ListView mList;
-
-    private boolean mHavePrefs;
-
-    private boolean mInitDone;
-
-    private View rootView;
-
     /**
      * The starting request code given out to preference framework.
      */
     private static final int FIRST_REQUEST_CODE = 100;
-
     private static final int MSG_BIND_PREFERENCES = 1;
+    private PreferenceManager mPreferenceManager;
+    private ListView mList;
+    final private Runnable mRequestFocus = new Runnable() {
+        @Override
+        public void run() {
+            mList.focusableViewAvailable(mList);
+        }
+    };
+    private boolean mHavePrefs;
+    private boolean mInitDone;
+    private OnKeyListener mListOnKeyListener = new OnKeyListener() {
+
+        @Override
+        public boolean onKey(View v, int keyCode, KeyEvent event) {
+            Object selectedItem = mList.getSelectedItem();
+            if (selectedItem instanceof Preference) {
+                @SuppressWarnings("unused")
+                View selectedView = mList.getSelectedView();
+                // return ((Preference)selectedItem).onKey(
+                // selectedView, keyCode, event);
+                return false;
+            }
+            return false;
+        }
 
+    };
     private Handler mHandler = new Handler() {
         @Override
         public void handleMessage(Message msg) {
@@ -55,27 +67,6 @@ public abstract class PreferenceFragment extends Fragment
         }
     };
 
-    final private Runnable mRequestFocus = new Runnable() {
-        @Override
-        public void run() {
-            mList.focusableViewAvailable(mList);
-        }
-    };
-
-    /**
-     * Interface that PreferenceFragment's containing activity should implement
-     * to be able to process preference items that wish to switch to a new
-     * fragment.
-     */
-    public interface OnPreferenceStartFragmentCallback {
-        /**
-         * Called when the user has clicked on a Preference that has a fragment
-         * class name associated with it. The implementation to should
-         * instantiate and switch to an instance of the given fragment.
-         */
-        boolean onPreferenceStartFragment(PreferenceFragment caller, Preference pref);
-    }
-
     @Override
     public void onCreate(Bundle paramBundle) {
         super.onCreate(paramBundle);
@@ -85,9 +76,9 @@ public abstract class PreferenceFragment extends Fragment
 
     @Override
     public View onCreateView(LayoutInflater paramLayoutInflater, ViewGroup paramViewGroup, Bundle paramBundle) {
-        rootView = paramLayoutInflater.inflate(R.layout.preference_list_fragment, paramViewGroup, false);
+        View rootView = paramLayoutInflater.inflate(R.layout.preference_list_fragment, paramViewGroup, false);
         if (Utils.hasKk())
-            rootView.setPadding(0, (int)(1.8 * Utils.getDimens(getActivity(), android.R.attr.actionBarSize)), 0, 0);
+            rootView.setPadding(0, (int) (1.8 * Utils.getDimens(getActivity(), android.R.attr.actionBarSize)), 0, 0);
         return rootView;
     }
 
@@ -164,18 +155,28 @@ public abstract class PreferenceFragment extends Fragment
 
     /**
      * Returns the {@link PreferenceManager} used by this fragment.
-     * 
+     *
      * @return The {@link PreferenceManager}.
      */
     public PreferenceManager getPreferenceManager() {
         return mPreferenceManager;
     }
 
+    /**
+     * Gets the root of the preference hierarchy that this fragment is showing.
+     *
+     * @return The {@link PreferenceScreen} that is the root of the preference
+     * hierarchy.
+     */
+    public PreferenceScreen getPreferenceScreen() {
+        return PreferenceManagerCompat.getPreferenceScreen(mPreferenceManager);
+    }
+
     /**
      * Sets the root of the preference hierarchy that this fragment is showing.
-     * 
+     *
      * @param preferenceScreen The root {@link PreferenceScreen} of the
-     *            preference hierarchy.
+     *                         preference hierarchy.
      */
     public void setPreferenceScreen(PreferenceScreen preferenceScreen) {
         if (PreferenceManagerCompat.setPreferences(mPreferenceManager, preferenceScreen) && preferenceScreen != null) {
@@ -186,19 +187,9 @@ public abstract class PreferenceFragment extends Fragment
         }
     }
 
-    /**
-     * Gets the root of the preference hierarchy that this fragment is showing.
-     * 
-     * @return The {@link PreferenceScreen} that is the root of the preference
-     *         hierarchy.
-     */
-    public PreferenceScreen getPreferenceScreen() {
-        return PreferenceManagerCompat.getPreferenceScreen(mPreferenceManager);
-    }
-
     /**
      * Adds preferences from activities that match the given {@link Intent}.
-     * 
+     *
      * @param intent The {@link Intent} to query activities.
      */
     public void addPreferencesFromIntent(Intent intent) {
@@ -211,7 +202,7 @@ public abstract class PreferenceFragment extends Fragment
     /**
      * Inflates the given XML resource and adds the preference hierarchy to the
      * current preference hierarchy.
-     * 
+     *
      * @param preferencesResId The XML resource ID to inflate.
      */
     public void addPreferencesFromResource(int preferencesResId) {
@@ -226,16 +217,12 @@ public abstract class PreferenceFragment extends Fragment
      */
     @Override
     public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference preference) {
-        // if (preference.getFragment() != null &&
-        if (getActivity() instanceof OnPreferenceStartFragmentCallback) {
-            return ((OnPreferenceStartFragmentCallback)getActivity()).onPreferenceStartFragment(this, preference);
-        }
-        return false;
+        return (getActivity() instanceof OnPreferenceStartFragmentCallback && ((OnPreferenceStartFragmentCallback) getActivity()).onPreferenceStartFragment(this, preference));
     }
 
     /**
      * Finds a {@link Preference} based on its key.
-     * 
+     *
      * @param key The key of the preference to retrieve.
      * @return The {@link Preference} with the key, or null.
      * @see PreferenceGroup#findPreference(CharSequence)
@@ -284,11 +271,7 @@ public abstract class PreferenceFragment extends Fragment
             throw new RuntimeException(
                     "Content has view with id attribute 'android.R.id.list' " + "that is not a ListView class");
         }
-        mList = (ListView)rawListView;
-        if (mList == null) {
-            throw new RuntimeException(
-                    "Your content must have a ListView whose id attribute is " + "'android.R.id.list'");
-        }
+        mList = (ListView) rawListView;
         int count = mList.getChildCount();
         for (int i = 0; i < count; i++) {
             View v = mList.getChildAt(i);
@@ -298,21 +281,18 @@ public abstract class PreferenceFragment extends Fragment
         mHandler.post(mRequestFocus);
     }
 
-    private OnKeyListener mListOnKeyListener = new OnKeyListener() {
-
-        @Override
-        public boolean onKey(View v, int keyCode, KeyEvent event) {
-            Object selectedItem = mList.getSelectedItem();
-            if (selectedItem instanceof Preference) {
-                @SuppressWarnings("unused")
-                View selectedView = mList.getSelectedView();
-                // return ((Preference)selectedItem).onKey(
-                // selectedView, keyCode, event);
-                return false;
-            }
-            return false;
-        }
-
-    };
+    /**
+     * Interface that PreferenceFragment's containing activity should implement
+     * to be able to process preference items that wish to switch to a new
+     * fragment.
+     */
+    public interface OnPreferenceStartFragmentCallback {
+        /**
+         * Called when the user has clicked on a Preference that has a fragment
+         * class name associated with it. The implementation to should
+         * instantiate and switch to an instance of the given fragment.
+         */
+        boolean onPreferenceStartFragment(PreferenceFragment caller, Preference pref);
+    }
 
 }
diff --git a/qDict/src/main/java/com/annie/dictionary/frags/PreferenceManagerCompat.java b/qDict/src/main/java/com/annie/dictionary/frags/PreferenceManagerCompat.java
index 9d4dc2d..d6f9812 100644
--- a/qDict/src/main/java/com/annie/dictionary/frags/PreferenceManagerCompat.java
+++ b/qDict/src/main/java/com/annie/dictionary/frags/PreferenceManagerCompat.java
@@ -1,12 +1,5 @@
-
 package com.annie.dictionary.frags;
 
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.Method;
-import java.lang.reflect.Proxy;
-
 import android.app.Activity;
 import android.content.Context;
 import android.content.Intent;
@@ -15,28 +8,16 @@ import android.preference.PreferenceManager;
 import android.preference.PreferenceScreen;
 import android.util.Log;
 
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+
 public class PreferenceManagerCompat {
 
     private static final String TAG = PreferenceManagerCompat.class.getSimpleName();
 
-    /**
-     * Interface definition for a callback to be invoked when a
-     * {@link Preference} in the hierarchy rooted at this
-     * {@link PreferenceScreen} is clicked.
-     */
-    interface OnPreferenceTreeClickListener {
-        /**
-         * Called when a preference in the tree rooted at this
-         * {@link PreferenceScreen} has been clicked.
-         * 
-         * @param preferenceScreen The {@link PreferenceScreen} that the
-         *            preference is located in.
-         * @param preference The preference that was clicked.
-         * @return Whether the click was handled.
-         */
-        boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference preference);
-    }
-
     static PreferenceManager newInstance(Activity activity, int firstRequestCode) {
         try {
             Constructor<PreferenceManager> c = PreferenceManager.class.getDeclaredConstructor(Activity.class,
@@ -59,30 +40,30 @@ public class PreferenceManagerCompat {
     /**
      * Sets the callback to be invoked when a {@link Preference} in the
      * hierarchy rooted at this {@link PreferenceManager} is clicked.
-     * 
+     *
      * @param listener The callback to be invoked.
      */
     static void setOnPreferenceTreeClickListener(PreferenceManager manager,
-            final OnPreferenceTreeClickListener listener) {
+                                                 final OnPreferenceTreeClickListener listener) {
         try {
             Field onPreferenceTreeClickListener = PreferenceManager.class
                     .getDeclaredField("mOnPreferenceTreeClickListener");
             onPreferenceTreeClickListener.setAccessible(true);
             if (listener != null) {
                 Object proxy = Proxy.newProxyInstance(onPreferenceTreeClickListener.getType().getClassLoader(),
-                        new Class[] {
+                        new Class[]{
                                 onPreferenceTreeClickListener.getType()
-                }, new InvocationHandler() {
-                    @Override
-                    public Object invoke(Object proxy, Method method, Object[] args) {
-                        if (method.getName().equals("onPreferenceTreeClick")) {
-                            return Boolean.valueOf(
-                                    listener.onPreferenceTreeClick((PreferenceScreen)args[0], (Preference)args[1]));
-                        } else {
-                            return null;
-                        }
-                    }
-                });
+                        }, new InvocationHandler() {
+                            @Override
+                            public Object invoke(Object proxy, Method method, Object[] args) {
+                                if (method.getName().equals("onPreferenceTreeClick")) {
+                                    return Boolean.valueOf(
+                                            listener.onPreferenceTreeClick((PreferenceScreen) args[0], (Preference) args[1]));
+                                } else {
+                                    return null;
+                                }
+                            }
+                        });
                 onPreferenceTreeClickListener.set(manager, proxy);
             } else {
                 onPreferenceTreeClickListener.set(manager, null);
@@ -97,22 +78,22 @@ public class PreferenceManagerCompat {
      * {@link Activity Activities} that match the given {@link Intent}. An
      * {@link Activity} defines its preference hierarchy with meta-data using
      * the {@link #METADATA_KEY_PREFERENCES} key.
-     * <p>
+     * <p/>
      * If a preference hierarchy is given, the new preference hierarchies will
      * be merged in.
-     * 
-     * @param queryIntent The intent to match activities.
+     *
+     * @param queryIntent     The intent to match activities.
      * @param rootPreferences Optional existing hierarchy to merge the new
-     *            hierarchies into.
+     *                        hierarchies into.
      * @return The root hierarchy (if one was not provided, the new hierarchy's
-     *         root).
+     * root).
      */
     static PreferenceScreen inflateFromIntent(PreferenceManager manager, Intent intent, PreferenceScreen screen) {
         try {
             Method m = PreferenceManager.class.getDeclaredMethod("inflateFromIntent", Intent.class,
                     PreferenceScreen.class);
             m.setAccessible(true);
-            PreferenceScreen prefScreen = (PreferenceScreen)m.invoke(manager, intent, screen);
+            PreferenceScreen prefScreen = (PreferenceScreen) m.invoke(manager, intent, screen);
             return prefScreen;
         } catch (Exception e) {
             Log.w(TAG, "Couldn't call PreferenceManager.inflateFromIntent by reflection", e);
@@ -123,22 +104,22 @@ public class PreferenceManagerCompat {
     /**
      * Inflates a preference hierarchy from XML. If a preference hierarchy is
      * given, the new preference hierarchies will be merged in.
-     * 
-     * @param context The context of the resource.
-     * @param resId The resource ID of the XML to inflate.
+     *
+     * @param context         The context of the resource.
+     * @param resId           The resource ID of the XML to inflate.
      * @param rootPreferences Optional existing hierarchy to merge the new
-     *            hierarchies into.
+     *                        hierarchies into.
      * @return The root hierarchy (if one was not provided, the new hierarchy's
-     *         root).
+     * root).
      * @hide
      */
     static PreferenceScreen inflateFromResource(PreferenceManager manager, Activity activity, int resId,
-            PreferenceScreen screen) {
+                                                PreferenceScreen screen) {
         try {
             Method m = PreferenceManager.class.getDeclaredMethod("inflateFromResource", Context.class, int.class,
                     PreferenceScreen.class);
             m.setAccessible(true);
-            PreferenceScreen prefScreen = (PreferenceScreen)m.invoke(manager, activity, resId, screen);
+            PreferenceScreen prefScreen = (PreferenceScreen) m.invoke(manager, activity, resId, screen);
             return prefScreen;
         } catch (Exception e) {
             Log.w(TAG, "Couldn't call PreferenceManager.inflateFromResource by reflection", e);
@@ -148,15 +129,15 @@ public class PreferenceManagerCompat {
 
     /**
      * Returns the root of the preference hierarchy managed by this class.
-     * 
+     *
      * @return The {@link PreferenceScreen} object that is at the root of the
-     *         hierarchy.
+     * hierarchy.
      */
     static PreferenceScreen getPreferenceScreen(PreferenceManager manager) {
         try {
             Method m = PreferenceManager.class.getDeclaredMethod("getPreferenceScreen");
             m.setAccessible(true);
-            return (PreferenceScreen)m.invoke(manager);
+            return (PreferenceScreen) m.invoke(manager);
         } catch (Exception e) {
             Log.w(TAG, "Couldn't call PreferenceManager.getPreferenceScreen by reflection", e);
         }
@@ -207,21 +188,39 @@ public class PreferenceManagerCompat {
 
     /**
      * Sets the root of the preference hierarchy.
-     * 
+     *
      * @param preferenceScreen The root {@link PreferenceScreen} of the
-     *            preference hierarchy.
+     *                         preference hierarchy.
      * @return Whether the {@link PreferenceScreen} given is different than the
-     *         previous.
+     * previous.
      */
     static boolean setPreferences(PreferenceManager manager, PreferenceScreen screen) {
         try {
             Method m = PreferenceManager.class.getDeclaredMethod("setPreferences", PreferenceScreen.class);
             m.setAccessible(true);
-            return ((Boolean)m.invoke(manager, screen));
+            return ((Boolean) m.invoke(manager, screen));
         } catch (Exception e) {
             Log.w(TAG, "Couldn't call PreferenceManager.setPreferences by reflection", e);
         }
         return false;
     }
 
+    /**
+     * Interface definition for a callback to be invoked when a
+     * {@link Preference} in the hierarchy rooted at this
+     * {@link PreferenceScreen} is clicked.
+     */
+    interface OnPreferenceTreeClickListener {
+        /**
+         * Called when a preference in the tree rooted at this
+         * {@link PreferenceScreen} has been clicked.
+         *
+         * @param preferenceScreen The {@link PreferenceScreen} that the
+         *                         preference is located in.
+         * @param preference       The preference that was clicked.
+         * @return Whether the click was handled.
+         */
+        boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference preference);
+    }
+
 }
diff --git a/qDict/src/main/java/com/annie/dictionary/frags/RecentFragment.java b/qDict/src/main/java/com/annie/dictionary/frags/RecentFragment.java
index cae2ee0..37d8d9d 100644
--- a/qDict/src/main/java/com/annie/dictionary/frags/RecentFragment.java
+++ b/qDict/src/main/java/com/annie/dictionary/frags/RecentFragment.java
@@ -1,20 +1,5 @@
-
 package com.annie.dictionary.frags;
 
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Set;
-
-import com.annie.dictionary.MainActivity;
-import com.annie.dictionary.R;
-import com.annie.dictionary.utils.Utils;
-import com.annie.dictionary.utils.Utils.Def;
-import com.annie.dictionary.utils.Utils.NAVIG;
-import com.annie.dictionary.utils.Utils.RECV_UI;
-import com.annie.dictionary.utils.WordsFileUtils;
-import com.mmt.widget.M2tToast;
-
 import android.app.Activity;
 import android.app.AlertDialog;
 import android.content.Context;
@@ -38,8 +23,34 @@ import android.widget.ArrayAdapter;
 import android.widget.ListView;
 import android.widget.TextView;
 
+import com.annie.dictionary.MainActivity;
+import com.annie.dictionary.R;
+import com.annie.dictionary.utils.Utils;
+import com.annie.dictionary.utils.Utils.Def;
+import com.annie.dictionary.utils.Utils.NAVIG;
+import com.annie.dictionary.utils.Utils.RECV_UI;
+import com.annie.dictionary.utils.WordsFileUtils;
+import com.mmt.widget.M2tToast;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Set;
+
 public class RecentFragment extends BaseListFragment {
 
+    ActionMode mActionMode;
+    int mCheckedColor;
+    private HashMap<Integer, Boolean> mSelection = new HashMap<>();
+    private SharedPreferences mShares;
+    private WordsFileUtils mHistoryFileUtils;
+    private ActionBarActivity activity;
+    private WordsListAdapter mAdapter;
+    private TextView mEmpty, mTvRecentTitle, mTvCount;
+    private boolean mIsFavorite = false;
+    private List<String> mWordsArrayList = null;
+    private ActionMode.Callback mActionModeCallback = null;
+
     public RecentFragment() {
         // default constructor
     }
@@ -52,7 +63,47 @@ public class RecentFragment extends BaseListFragment {
 
     @Override
     public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container,
-            @Nullable Bundle savedInstanceState) {
+                             @Nullable Bundle savedInstanceState) {
+        if(Utils.hasHcAbove()) {
+            mActionModeCallback = new ActionMode.Callback() {
+
+                @Override
+                public boolean onCreateActionMode(ActionMode mode, Menu menu) {
+                    // Inflate a menu resource providing context menu items
+                    MenuInflater inflater = mode.getMenuInflater();
+                    inflater.inflate(R.menu.cabselection_menu, menu);
+                    return true;
+                }
+
+                // Called each time the action mode is shown. Always called after
+                // onCreateActionMode, but
+                // may be called multiple times if the mode is invalidated.
+                @Override
+                public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
+                    return false; // Return false if nothing is done
+                }
+
+                // Called when the user selects a contextual menu item
+                @Override
+                public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
+                    switch (item.getItemId()) {
+                        case R.id.action_delete:
+                            questionDeleteDlg(mode, mIsFavorite);
+                            return true;
+                        default:
+                            return false;
+                    }
+                }
+
+                // Called when the user exits the action mode
+                @Override
+                public void onDestroyActionMode(ActionMode mode) {
+                    mAdapter.clearSelection();
+                    mActionMode = null;
+                }
+
+            };
+        }
         return getPersistentView(inflater, container, savedInstanceState, R.layout.fragment_recent);
     }
 
@@ -62,10 +113,10 @@ public class RecentFragment extends BaseListFragment {
         Bundle b = getArguments();
         if (b != null)
             mIsFavorite = b.getBoolean("qdict_is_favorite", false);
-        activity = (ActionBarActivity)getActivity();
-        mTvRecentTitle = (TextView)rootView.findViewById(R.id.tv_title);
-        mTvCount = (TextView)rootView.findViewById(R.id.tv_count);
-        mEmpty = (TextView)rootView.findViewById(R.id.tv_empty);
+        activity = (ActionBarActivity) getActivity();
+        mTvRecentTitle = (TextView) rootView.findViewById(R.id.tv_title);
+        mTvCount = (TextView) rootView.findViewById(R.id.tv_count);
+        mEmpty = (TextView) rootView.findViewById(R.id.tv_empty);
         mShares = activity.getSharedPreferences(Def.APP_NAME, Context.MODE_PRIVATE);
         mCheckedColor = getResources().getColor(R.color.mmt_grey_500);
     }
@@ -106,7 +157,7 @@ public class RecentFragment extends BaseListFragment {
         if (mWordsArrayList == null || mWordsArrayList.isEmpty()) {
             menu.removeItem(R.id.action_delete);
         }
-    };
+    }
 
     public boolean onOptionsItemSelected(MenuItem item) {
         int id = item.getItemId();
@@ -122,10 +173,10 @@ public class RecentFragment extends BaseListFragment {
         }
         return true;
 
-    };
+    }
 
     private void questionDeleteAllDlg(final boolean favorite) {
-        AlertDialog.Builder alertDialogBuilder = null;
+        AlertDialog.Builder alertDialogBuilder;
         if (Utils.hasHcAbove()) {
             alertDialogBuilder = new AlertDialog.Builder(activity, R.style.QDialog);
         } else {
@@ -157,8 +208,6 @@ public class RecentFragment extends BaseListFragment {
         alertDialogBuilder.show();
     }
 
-    ActionMode mActionMode;
-
     private void questionDeleteDlg(final ActionMode mode, final boolean favorite) {
         AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(activity);
         alertDialogBuilder.setMessage(favorite ? R.string.delete_favorite_summary : R.string.delete_recent_summary);
@@ -173,11 +222,11 @@ public class RecentFragment extends BaseListFragment {
             public void onClick(DialogInterface dialog, int which) {
                 StringBuilder sb = new StringBuilder();
                 Set<Integer> set = mAdapter.getCurrentCheckedPosition();
-                List<String> keywords = new ArrayList<String>();
+                List<String> keywords = new ArrayList<>();
                 for (Integer pos : set) {
-                    String keyword = mAdapter.getItem(pos.intValue());
+                    String keyword = mAdapter.getItem(pos);
                     if (!TextUtils.isEmpty(keyword)) {
-                        sb.append(keyword + "\n ");
+                        sb.append(keyword).append("\n ");
                         keywords.add(keyword);
                     }
                 }
@@ -203,21 +252,23 @@ public class RecentFragment extends BaseListFragment {
         mWordsArrayList = mHistoryFileUtils.getArrayList();
         mAdapter = new WordsListAdapter(mWordsArrayList);
         setListAdapter(mAdapter);
-        getListView().setOnItemLongClickListener(new AdapterView.OnItemLongClickListener() {
-            @Override
-            public boolean onItemLongClick(AdapterView<?> listview, View item, int position, long id) {
-                getListView().setItemChecked(position, true);
-                if (mActionMode != null) {
-                    return false;
+        if (Utils.hasHcAbove()) {
+            getListView().setOnItemLongClickListener(new AdapterView.OnItemLongClickListener() {
+                @Override
+                public boolean onItemLongClick(AdapterView<?> listview, View item, int position, long id) {
+                    getListView().setItemChecked(position, true);
+                    if (mActionMode != null) {
+                        return false;
+                    }
+                    mAdapter.setNewSelection(position, true);
+                    mActionMode = ((MainActivity) activity).getToolbar().startActionMode(mActionModeCallback);
+                    int count = mAdapter.getCheckCount();
+                    mActionMode.setTitle(getResources().getQuantityString(R.plurals.items_count, count, count));
+                    return true;
                 }
-                mAdapter.setNewSelection(position, true);
-                mActionMode = ((MainActivity)activity).getToolbar().startActionMode(mActionModeCallback);
-                int count = mAdapter.getCheckCount();
-                mActionMode.setTitle(getResources().getQuantityString(R.plurals.items_count, count, count));
-                return true;
-            }
 
-        });
+            });
+        }
         checkUIInfor();
     }
 
@@ -233,63 +284,19 @@ public class RecentFragment extends BaseListFragment {
             activity.invalidateOptionsMenu();
     }
 
-    private ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
-
-        @Override
-        public boolean onCreateActionMode(ActionMode mode, Menu menu) {
-            // Inflate a menu resource providing context menu items
-            MenuInflater inflater = mode.getMenuInflater();
-            inflater.inflate(R.menu.cabselection_menu, menu);
-            return true;
-        }
-
-        // Called each time the action mode is shown. Always called after
-        // onCreateActionMode, but
-        // may be called multiple times if the mode is invalidated.
-        @Override
-        public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
-            return false; // Return
-                          // false
-                          // if
-                          // nothing
-                          // is
-                          // done
-        }
-
-        // Called when the user selects a contextual menu item
-        @Override
-        public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
-            switch (item.getItemId()) {
-                case R.id.action_delete:
-                    questionDeleteDlg(mode, mIsFavorite);
-                    return true;
-                default:
-                    return false;
-            }
-        }
-
-        // Called when the user exits the action mode
-        @Override
-        public void onDestroyActionMode(ActionMode mode) {
-            mAdapter.clearSelection();
-            mActionMode = null;
-        }
-
-    };
-
     @Override
     public void onListItemClick(ListView l, View v, int position, long id) {
-        if (mActionMode != null) {
+        if (Utils.hasHcAbove() && mActionMode != null) {
             boolean check = !mAdapter.isPositionChecked(position);
             if (check)
-                mAdapter.setNewSelection(position, check);
+                mAdapter.setNewSelection(position, true);
             else
                 mAdapter.removeSelection(position);
             int count = mAdapter.getCheckCount();
             mActionMode.setTitle(getResources().getQuantityString(R.plurals.items_count, count, count));
             return;
         }
-        String word = mAdapter.getItem(position).toString();
+        String word = mAdapter.getItem(position);
         Intent intent = new Intent(MainActivity.ACTION_UPDATE_UI);
         intent.putExtra(MainActivity.ACTION_UPDATE_KEY, RECV_UI.SEARCH_WORD);
         intent.putExtra("receiver_keyword", word);
@@ -330,7 +337,7 @@ public class RecentFragment extends BaseListFragment {
 
         public boolean isPositionChecked(int position) {
             Boolean result = mSelection.get(position);
-            return (result == null) ? false : result.booleanValue();
+            return result != null && result;
         }
 
         public Set<Integer> getCurrentCheckedPosition() {
@@ -347,16 +354,16 @@ public class RecentFragment extends BaseListFragment {
         }
 
         public void clearSelection() {
-            mSelection = new HashMap<Integer, Boolean>();
+            mSelection = new HashMap<>();
             notifyDataSetChanged();
         }
 
         @Override
         public View getView(int position, View convertView, ViewGroup parent) {
-            TextView text = (TextView)convertView;
+            TextView text = (TextView) convertView;
 
             if (text == null) {
-                text = (TextView)inflater.inflate(R.layout.simple_list_item_1, null);
+                text = (TextView) inflater.inflate(R.layout.simple_list_item_1, null);
             }
             if (mWordsArrayList == null || mWordsArrayList.size() == 0)
                 return null;
@@ -371,26 +378,4 @@ public class RecentFragment extends BaseListFragment {
         }
     }
 
-    private HashMap<Integer, Boolean> mSelection = new HashMap<Integer, Boolean>();
-
-    int mCheckedColor;
-
-    private SharedPreferences mShares;
-
-    private WordsFileUtils mHistoryFileUtils;
-
-    private ActionBarActivity activity;
-
-    public static final int WORDS_RESULT_CODE = 1;
-
-    public static final String WORDS_TYPE = "wordsType";
-
-    private WordsListAdapter mAdapter;
-
-    private TextView mEmpty, mTvRecentTitle, mTvCount;
-
-    private boolean mIsFavorite = false;
-
-    private List<String> mWordsArrayList = null;
-
 }
diff --git a/qDict/src/main/java/com/annie/dictionary/frags/SearchFragment.java b/qDict/src/main/java/com/annie/dictionary/frags/SearchFragment.java
index 0bf6f5a..d3c1342 100644
--- a/qDict/src/main/java/com/annie/dictionary/frags/SearchFragment.java
+++ b/qDict/src/main/java/com/annie/dictionary/frags/SearchFragment.java
@@ -1,18 +1,5 @@
-
 package com.annie.dictionary.frags;
 
-import com.annie.dictionary.DictSpeechEng;
-import com.annie.dictionary.DictWebViewClient;
-import com.annie.dictionary.MainActivity;
-import com.annie.dictionary.QDictions;
-import com.annie.dictionary.R;
-import com.annie.dictionary.utils.Utils;
-import com.annie.dictionary.utils.Utils.Def;
-import com.annie.dictionary.utils.Utils.NAVIG;
-import com.annie.dictionary.utils.Utils.RECV_UI;
-import com.annie.dictionary.utils.WebViewClientCallback;
-import com.annie.dictionary.utils.WordsFileUtils;
-
 import android.content.Context;
 import android.content.Intent;
 import android.content.SharedPreferences;
@@ -32,6 +19,18 @@ import android.webkit.WebView;
 import android.widget.ImageButton;
 import android.widget.TextView;
 
+import com.annie.dictionary.DictSpeechEng;
+import com.annie.dictionary.DictWebViewClient;
+import com.annie.dictionary.MainActivity;
+import com.annie.dictionary.QDictions;
+import com.annie.dictionary.R;
+import com.annie.dictionary.utils.Utils;
+import com.annie.dictionary.utils.Utils.Def;
+import com.annie.dictionary.utils.Utils.NAVIG;
+import com.annie.dictionary.utils.Utils.RECV_UI;
+import com.annie.dictionary.utils.WebViewClientCallback;
+import com.annie.dictionary.utils.WordsFileUtils;
+
 public class SearchFragment extends Fragment {
 
     // UX
@@ -47,8 +46,6 @@ public class SearchFragment extends Fragment {
 
     private boolean mIsSearch, mBackClick = false, mTts;
 
-    private SharedPreferences mSharedPreferences;
-
     private int mCurrentHisIndex = 0;
 
     // UI
@@ -66,7 +63,7 @@ public class SearchFragment extends Fragment {
         // default constructor
     }
 
-    public static final SearchFragment newInstance(DictSpeechEng dictSpeechEng, QDictions dictions, String keyword, boolean search) {
+    public static SearchFragment newInstance(DictSpeechEng dictSpeechEng, QDictions dictions, String keyword, boolean search) {
         SearchFragment s = new SearchFragment();
         s.mDictions = dictions;
         s.mSpeechEng = dictSpeechEng;
@@ -109,16 +106,6 @@ public class SearchFragment extends Fragment {
         setKeyword(keyword, true);
     }
 
-    public class MyWebViewClientCallback extends WebViewClientCallback {
-        public MyWebViewClientCallback() {
-        }
-
-        @Override
-        public void shouldOverrideUrlLoading(String word) {
-            makeDictContent(word);
-        }
-    }
-
     private void makeDictContent(String word) {
         mTvKeyword.setText(word);
         mSpeakBtn.setVisibility(mTts ? View.VISIBLE : View.GONE);
@@ -155,12 +142,12 @@ public class SearchFragment extends Fragment {
 
     @Override
     public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container,
-            @Nullable Bundle savedInstanceState) {
+                             @Nullable Bundle savedInstanceState) {
         View root = inflater.inflate(R.layout.layout_search, container, false);
-        mDictBackBtn = (ImageButton)root.findViewById(R.id.back_word);
-        mTvKeyword = (TextView)root.findViewById(R.id.tv_title);
-        mSpeakBtn = (ImageButton)root.findViewById(R.id.action_speak);
-        mDictContentView = (WebView)root.findViewById(R.id.dictContentView);
+        mDictBackBtn = (ImageButton) root.findViewById(R.id.back_word);
+        mTvKeyword = (TextView) root.findViewById(R.id.tv_title);
+        mSpeakBtn = (ImageButton) root.findViewById(R.id.action_speak);
+        mDictContentView = (WebView) root.findViewById(R.id.dictContentView);
         DictWebViewClient webclient = new DictWebViewClient(getActivity().getApplicationContext(),
                 new MyWebViewClientCallback());
         mDictContentView.setWebViewClient(webclient);
@@ -197,7 +184,7 @@ public class SearchFragment extends Fragment {
 
             @Override
             public void onClick(View v) {
-                mSpeechEng.speak(mKeyword.toString().trim());
+                mSpeechEng.speak(mKeyword.trim());
             }
         });
         return root;
@@ -206,7 +193,7 @@ public class SearchFragment extends Fragment {
     @Override
     public void onActivityCreated(@Nullable Bundle savedInstanceState) {
         super.onActivityCreated(savedInstanceState);
-        mSharedPreferences = getActivity().getSharedPreferences(Def.APP_NAME, Context.MODE_PRIVATE);
+        SharedPreferences mSharedPreferences = getActivity().getSharedPreferences(Def.APP_NAME, Context.MODE_PRIVATE);
 
         if (mDictions == null && MainActivity.hasStoragePermission) {
             mDictions = new QDictions(getActivity());
@@ -292,4 +279,14 @@ public class SearchFragment extends Fragment {
         mWordsFileUtilsHis = null;
         super.onDestroyView();
     }
+
+    public class MyWebViewClientCallback extends WebViewClientCallback {
+        public MyWebViewClientCallback() {
+        }
+
+        @Override
+        public void shouldOverrideUrlLoading(String word) {
+            makeDictContent(word);
+        }
+    }
 }
diff --git a/qDict/src/main/java/com/annie/dictionary/frags/SettingFragment.java b/qDict/src/main/java/com/annie/dictionary/frags/SettingFragment.java
index 9f42e26..73d8497 100644
--- a/qDict/src/main/java/com/annie/dictionary/frags/SettingFragment.java
+++ b/qDict/src/main/java/com/annie/dictionary/frags/SettingFragment.java
@@ -1,19 +1,11 @@
-
 package com.annie.dictionary.frags;
 
-import com.annie.dictionary.DictSpeechEng;
-import com.annie.dictionary.MainActivity;
-import com.annie.dictionary.R;
-import com.annie.dictionary.service.QDictService;
-import com.annie.dictionary.standout.StandOutWindow;
-import com.annie.dictionary.utils.Utils;
-import com.annie.dictionary.utils.Utils.Def;
-import com.annie.dictionary.utils.Utils.RECV_UI;
-
 import android.app.AlertDialog;
+import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.DialogInterface;
 import android.content.Intent;
+import android.content.IntentFilter;
 import android.content.SharedPreferences;
 import android.content.SharedPreferences.Editor;
 import android.graphics.Paint;
@@ -23,42 +15,58 @@ import android.preference.CheckBoxPreference;
 import android.preference.ListPreference;
 import android.preference.Preference;
 import android.preference.Preference.OnPreferenceChangeListener;
+import android.preference.Preference.OnPreferenceClickListener;
 import android.support.v4.app.FragmentActivity;
 import android.text.SpannableStringBuilder;
 import android.text.Spanned;
 import android.text.TextPaint;
 import android.text.TextUtils;
 import android.text.style.TypefaceSpan;
-import android.util.Log;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 
-public class SettingFragment extends PreferenceFragment implements Def, OnPreferenceChangeListener {
+import com.annie.dictionary.DictSpeechEng;
+import com.annie.dictionary.MainActivity;
+import com.annie.dictionary.PathSelectActivity;
+import com.annie.dictionary.R;
+import com.annie.dictionary.service.QDictService;
+import com.annie.dictionary.standout.StandOutWindow;
+import com.annie.dictionary.utils.Utils;
+import com.annie.dictionary.utils.Utils.Def;
+import com.annie.dictionary.utils.Utils.RECV_UI;
+
+public class SettingFragment extends PreferenceFragment implements Def, OnPreferenceChangeListener, OnPreferenceClickListener {
 
+    public static final String DATA_SOURCE_INTENT = "com.annie.dictionary.DATA_SOURCE";
+    Typeface mFont;
+    String mCurrentLang;
+    String[] mLangValues;
     private SharedPreferences mSharedPreferences;
-
     private Preference mPrefSource;
-
     private ListPreference mFontPreference, mThemePreference, mMaxFavPreference, mLangPreference;
-
     private CheckBoxPreference mTTSPref, mNotifPref, mUseCapture;
-
-    Typeface mFont;
-
     private int mCurrentFontIndex = 0;
-
     private int mCurrentThemeIndex = 0;
-
-    String mCurrentLang;
-
-    String[] mLangValues;
+    private FragmentActivity activity;
+    BroadcastReceiver mUpdateDataSourceReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String newPath = intent.getStringExtra("filePath");
+            mPrefSource.setSummary(newPath);
+            Utils.setRootDictFolder(mSharedPreferences, newPath);
+            Intent intentReceiver = new Intent(MainActivity.ACTION_UPDATE_UI);
+            intentReceiver.putExtra(MainActivity.ACTION_UPDATE_KEY, RECV_UI.RELOAD_DICT);
+            activity.sendBroadcast(intentReceiver);
+        }
+    };
+    private DictSpeechEng mSpeechEng;
 
     public SettingFragment() {
         // default constructor
     }
 
-    public static final SettingFragment newInstance(DictSpeechEng speechEng) {
+    public static SettingFragment newInstance(DictSpeechEng speechEng) {
         SettingFragment s = new SettingFragment();
         s.mSpeechEng = speechEng;
         return s;
@@ -84,23 +92,25 @@ public class SettingFragment extends PreferenceFragment implements Def, OnPrefer
         addPreferencesFromResource(R.xml.prefs_settings);
         mSharedPreferences = activity.getSharedPreferences(APP_NAME, Context.MODE_PRIVATE);
         mPrefSource = findPreference(getString(R.string.prefs_key_source));
-        mFontPreference = (ListPreference)findPreference(getString(R.string.prefs_key_font_text));
+        mPrefSource.setOnPreferenceClickListener(this);
+        mFontPreference = (ListPreference) findPreference(getString(R.string.prefs_key_font_text));
         mFontPreference.setOnPreferenceChangeListener(this);
-        mThemePreference = (ListPreference)findPreference(getString(R.string.prefs_key_theme));
+        mThemePreference = (ListPreference) findPreference(getString(R.string.prefs_key_theme));
         mThemePreference.setOnPreferenceChangeListener(this);
-        mMaxFavPreference = (ListPreference)findPreference(getString(R.string.prefs_key_max_recent_word));
+        mMaxFavPreference = (ListPreference) findPreference(getString(R.string.prefs_key_max_recent_word));
         mMaxFavPreference.setOnPreferenceChangeListener(this);
-        mTTSPref = (CheckBoxPreference)findPreference(getResources().getString(R.string.prefs_key_using_tts));
+        mTTSPref = (CheckBoxPreference) findPreference(getResources().getString(R.string.prefs_key_using_tts));
         mTTSPref.setOnPreferenceChangeListener(this);
-        mLangPreference = (ListPreference)findPreference(getString(R.string.prefs_key_languages));
+        mLangPreference = (ListPreference) findPreference(getString(R.string.prefs_key_languages));
         mLangPreference.setOnPreferenceChangeListener(this);
-        mNotifPref = (CheckBoxPreference)findPreference(
+        mNotifPref = (CheckBoxPreference) findPreference(
                 getResources().getString(R.string.prefs_key_capture_notification));
         mNotifPref.setOnPreferenceChangeListener(this);
-        mUseCapture = (CheckBoxPreference)findPreference(getString(R.string.prefs_key_using_capture));
+        mUseCapture = (CheckBoxPreference) findPreference(getString(R.string.prefs_key_using_capture));
         mUseCapture.setOnPreferenceChangeListener(this);
         mLangValues = getResources().getStringArray(R.array.language_values);
         initInfo();
+        activity.registerReceiver(mUpdateDataSourceReceiver, new IntentFilter(DATA_SOURCE_INTENT));
     }
 
     @Override
@@ -110,11 +120,17 @@ public class SettingFragment extends PreferenceFragment implements Def, OnPrefer
         mFont = Utils.getFont(activity, s);
         mCurrentFontIndex = mFontPreference.findIndexOfValue(s);
         mCurrentThemeIndex = mSharedPreferences.getInt("prefs_key_theme", 0);
-        applyFont(mFont);
+        applyFont();
         return view;
     }
 
-    private void applyFont(Typeface font) {
+    @Override
+    public void onDestroy() {
+        activity.unregisterReceiver(mUpdateDataSourceReceiver);
+        super.onDestroy();
+    }
+
+    private void applyFont() {
         convertPreferenceToUseCustomFont(mPrefSource);
         convertPreferenceToUseCustomFont(mFontPreference);
         convertPreferenceToUseCustomFont(mThemePreference);
@@ -142,14 +158,13 @@ public class SettingFragment extends PreferenceFragment implements Def, OnPrefer
             mTTSPref.setEnabled(false);
             mTTSPref.setChecked(false);
         }
-        mPrefSource.setSummary(Utils.getRootFolder());
+        mPrefSource.setSummary(Utils.getRootDictFolder(mSharedPreferences));
         mFontPreference.setSummary(mFontPreference.getEntry());
         mThemePreference.setSummary(mThemePreference.getEntry());
         mMaxFavPreference.setSummary(
                 getString(R.string.prefs_title_max_favorite_word_summary, mMaxFavPreference.getEntry().toString()));
         if (TextUtils.isEmpty(mLangPreference.getEntry())) {
             String language = mSharedPreferences.getString("prefs_key_languages", "");
-            Log.e("NAMND", "language = " + language + ", index = " + getLanguageIndex(language));
             mLangPreference.setValueIndex(getLanguageIndex(language));
         }
         mCurrentLang = mLangPreference.getEntry().toString();
@@ -171,6 +186,16 @@ public class SettingFragment extends PreferenceFragment implements Def, OnPrefer
         return 0;
     }
 
+    @Override
+    public boolean onPreferenceClick(Preference preference) {
+        if (preference == mPrefSource) {
+            Intent i = new Intent(activity, PathSelectActivity.class);
+            activity.startActivity(i);
+            return true;
+        }
+        return false;
+    }
+
     @Override
     public boolean onPreferenceChange(Preference preference, Object newValue) {
         if (preference == mFontPreference) {
@@ -198,8 +223,8 @@ public class SettingFragment extends PreferenceFragment implements Def, OnPrefer
             return true;
         } else if (preference == mTTSPref) {
             mSharedPreferences.edit()
-                    .putBoolean(getResources().getString(R.string.prefs_key_using_tts), (Boolean)newValue).apply();
-            mTTSPref.setChecked((Boolean)newValue);
+                    .putBoolean(getResources().getString(R.string.prefs_key_using_tts), (Boolean) newValue).apply();
+            mTTSPref.setChecked((Boolean) newValue);
             return true;
         } else if (preference == mMaxFavPreference) {
             int index = mMaxFavPreference.findIndexOfValue(newValue.toString());
@@ -210,16 +235,16 @@ public class SettingFragment extends PreferenceFragment implements Def, OnPrefer
                     .setSummary(getString(R.string.prefs_title_max_favorite_word_summary, entries[index].toString()));
             return true;
         } else if (preference == mNotifPref) {
-            mSharedPreferences.edit().putBoolean("prefs_key_capture_notification", (Boolean)newValue).apply();
-            mNotifPref.setChecked((Boolean)newValue);
+            mSharedPreferences.edit().putBoolean("prefs_key_capture_notification", (Boolean) newValue).apply();
+            mNotifPref.setChecked((Boolean) newValue);
             if (QDictService.RUNNING) {
                 StandOutWindow.toggleNoti(getActivity(), QDictService.class, StandOutWindow.DEFAULT_ID,
-                        (Boolean)newValue);
+                        (Boolean) newValue);
             }
             return true;
         } else if (preference == mUseCapture) {
             if (newValue instanceof Boolean) {
-                Boolean boolVal = (Boolean)newValue;
+                Boolean boolVal = (Boolean) newValue;
                 SharedPreferences.Editor editor = mSharedPreferences.edit();
                 editor.putBoolean(getString(R.string.prefs_key_using_capture), boolVal);
                 editor.apply();
@@ -255,7 +280,7 @@ public class SettingFragment extends PreferenceFragment implements Def, OnPrefer
 
     @SuppressWarnings("unused")
     private void questionResetDlg() {
-        AlertDialog.Builder alertDialogBuilder = null;
+        AlertDialog.Builder alertDialogBuilder;
         if (Utils.hasHcAbove()) {
             alertDialogBuilder = new AlertDialog.Builder(activity, R.style.QDialog);
         } else {
@@ -305,16 +330,6 @@ public class SettingFragment extends PreferenceFragment implements Def, OnPrefer
             newType = type;
         }
 
-        @Override
-        public void updateDrawState(TextPaint ds) {
-            applyCustomTypeFace(ds, newType);
-        }
-
-        @Override
-        public void updateMeasureState(TextPaint paint) {
-            applyCustomTypeFace(paint, newType);
-        }
-
         private static void applyCustomTypeFace(Paint paint, Typeface tf) {
             int oldStyle;
             Typeface old = paint.getTypeface();
@@ -334,9 +349,15 @@ public class SettingFragment extends PreferenceFragment implements Def, OnPrefer
             }
             paint.setTypeface(tf);
         }
-    }
 
-    private FragmentActivity activity;
+        @Override
+        public void updateDrawState(TextPaint ds) {
+            applyCustomTypeFace(ds, newType);
+        }
 
-    private DictSpeechEng mSpeechEng;
+        @Override
+        public void updateMeasureState(TextPaint paint) {
+            applyCustomTypeFace(paint, newType);
+        }
+    }
 }
diff --git a/qDict/src/main/java/com/annie/dictionary/service/QDictBootReceiver.java b/qDict/src/main/java/com/annie/dictionary/service/QDictBootReceiver.java
index 83ae51d..c505925 100644
--- a/qDict/src/main/java/com/annie/dictionary/service/QDictBootReceiver.java
+++ b/qDict/src/main/java/com/annie/dictionary/service/QDictBootReceiver.java
@@ -1,14 +1,13 @@
-
 package com.annie.dictionary.service;
 
-import com.annie.dictionary.R;
-import com.annie.dictionary.utils.Utils.Def;
-
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.SharedPreferences;
 
+import com.annie.dictionary.R;
+import com.annie.dictionary.utils.Utils.Def;
+
 public class QDictBootReceiver extends BroadcastReceiver {
     @Override
     public void onReceive(Context context, Intent intent) {
diff --git a/qDict/src/main/java/com/annie/dictionary/service/QDictService.java b/qDict/src/main/java/com/annie/dictionary/service/QDictService.java
index cb7efb6..5c2aa87 100644
--- a/qDict/src/main/java/com/annie/dictionary/service/QDictService.java
+++ b/qDict/src/main/java/com/annie/dictionary/service/QDictService.java
@@ -1,22 +1,5 @@
-
 package com.annie.dictionary.service;
 
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-
-import com.annie.dictionary.BaseActivity;
-import com.annie.dictionary.MainActivity;
-import com.annie.dictionary.QDictions;
-import com.annie.dictionary.R;
-import com.annie.dictionary.standout.StandOutFlags;
-import com.annie.dictionary.standout.StandOutWindow;
-import com.annie.dictionary.standout.Window;
-import com.annie.dictionary.utils.Utils;
-import com.annie.dictionary.utils.Utils.Def;
-import com.annie.dictionary.utils.Utils.RECV_UI;
-import com.annie.dictionary.utils.WebViewClientCallback;
-import com.annie.dictionary.utils.WordsFileUtils;
-
 import android.content.ClipboardManager;
 import android.content.ClipboardManager.OnPrimaryClipChangedListener;
 import android.content.Context;
@@ -38,16 +21,25 @@ import android.widget.FrameLayout;
 import android.widget.ImageButton;
 import android.widget.TextView;
 
-public class QDictService extends StandOutWindow {
+import com.annie.dictionary.BaseActivity;
+import com.annie.dictionary.MainActivity;
+import com.annie.dictionary.QDictions;
+import com.annie.dictionary.R;
+import com.annie.dictionary.standout.StandOutFlags;
+import com.annie.dictionary.standout.StandOutWindow;
+import com.annie.dictionary.standout.Window;
+import com.annie.dictionary.utils.Utils;
+import com.annie.dictionary.utils.Utils.Def;
+import com.annie.dictionary.utils.Utils.RECV_UI;
+import com.annie.dictionary.utils.WordsFileUtils;
 
-    private OnPrimaryClipChangedListener mClipboardListener = new OnPrimaryClipChangedListener() {
-        public void onPrimaryClipChanged() {
-            clipboardCheck();
-        }
-    };
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
 
-    private static final int CLOSED = 0, OPENED = 1;
+public class QDictService extends StandOutWindow {
 
+    private static final int CLOSED = 0, OPENED = 1;
+    public static boolean RUNNING = false;
     private static int CLOSED_WIDTH = 500;
 
     private static int CLOSED_HEIGHT = 700;
@@ -55,15 +47,11 @@ public class QDictService extends StandOutWindow {
     private static int OPENED_WIDTH = 880;
 
     private static int OPENED_HEIGHT = 960;
-
-    public static boolean RUNNING = false;
-
     private static int windowState = OPENED;
-
     private static StandOutLayoutParams closedParams;
-
     private static StandOutLayoutParams openedParams;
-
+    // This is the object that receives interactions from clients.
+    private final IBinder mBinder = new LocalBinder();
     WebView mDictViewContent;
 
     EditText mKeywordEdt;
@@ -91,17 +79,13 @@ public class QDictService extends StandOutWindow {
     private android.text.ClipboardManager mClipboardManagerGINGER = null;
 
     private ExecutorService mThreadPool = Executors.newSingleThreadExecutor();
-
-    public class ServiceWebViewClientCallback extends WebViewClientCallback {
-
-        public ServiceWebViewClientCallback() {
+    private OnPrimaryClipChangedListener mClipboardListener = new OnPrimaryClipChangedListener() {
+        public void onPrimaryClipChanged() {
+            clipboardCheck();
         }
+    };
 
-        @Override
-        public void shouldOverrideUrlLoading(String word) {
-            makeDictContent(word);
-            setKeywordLable(word);
-        }
+    public QDictService() {
     }
 
     private void makeDictContent(String word) {
@@ -130,7 +114,7 @@ public class QDictService extends StandOutWindow {
 
     @SuppressWarnings("deprecation")
     private void clipboardCheck() {
-        String clipboardText = "";
+        String clipboardText;
         CharSequence s = null;
         if (Utils.hasHcAbove()) {
             if (mClipboardManager.hasPrimaryClip()) {
@@ -179,11 +163,11 @@ public class QDictService extends StandOutWindow {
         }
         float densityDpi = getResources().getDisplayMetrics().densityDpi + 0.1f;
         float scale = (densityDpi / DisplayMetrics.DENSITY_XXHIGH);
-        CLOSED_WIDTH = (int)(500 * scale);
-        CLOSED_HEIGHT = (int)(700 * scale);
+        CLOSED_WIDTH = (int) (500 * scale);
+        CLOSED_HEIGHT = (int) (700 * scale);
 
-        OPENED_WIDTH = (int)(880 * scale);
-        OPENED_HEIGHT = (int)(960 * scale);
+        OPENED_WIDTH = (int) (880 * scale);
+        OPENED_HEIGHT = (int) (960 * scale);
         if (!Utils.hasHcAbove())
             mClipboardTask = new Runnable() {
                 @Override
@@ -211,10 +195,10 @@ public class QDictService extends StandOutWindow {
     @Override
     public void initClipboardService() {
         if (Utils.hasHcAbove()) {
-            mClipboardManager = (ClipboardManager)getSystemService(Context.CLIPBOARD_SERVICE);
+            mClipboardManager = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);
             mClipboardManager.addPrimaryClipChangedListener(mClipboardListener);
         } else {
-            mClipboardManagerGINGER = (android.text.ClipboardManager)getSystemService(CLIPBOARD_SERVICE);
+            mClipboardManagerGINGER = (android.text.ClipboardManager) getSystemService(CLIPBOARD_SERVICE);
             if (mClipboardManagerGINGER.hasText())
                 mClipboardText = mClipboardManagerGINGER.getText().toString().trim();
         }
@@ -243,18 +227,6 @@ public class QDictService extends StandOutWindow {
         RUNNING = false;
     }
 
-    public QDictService() {
-    }
-
-    // This is the object that receives interactions from clients.
-    private final IBinder mBinder = new LocalBinder();
-
-    public class LocalBinder extends Binder {
-        QDictService getService() {
-            return QDictService.this;
-        }
-    }
-
     @Override
     protected void finalize() throws Throwable {
         super.finalize();
@@ -301,16 +273,16 @@ public class QDictService extends StandOutWindow {
 
     @Override
     public void createAndAttachView(int id, FrameLayout frame) {
-        LayoutInflater inflater = (LayoutInflater)getSystemService(LAYOUT_INFLATER_SERVICE);
+        LayoutInflater inflater = (LayoutInflater) getSystemService(LAYOUT_INFLATER_SERVICE);
         View view = inflater.inflate(R.layout.capture_window, frame, true);
-        mDictViewContent = (WebView)view.findViewById(R.id.dictContentView);
-        mKeywordLable = (TextView)view.findViewById(R.id.tv_title);
+        mDictViewContent = (WebView) view.findViewById(R.id.dictContentView);
+        mKeywordLable = (TextView) view.findViewById(R.id.tv_title);
         WebSettings webSettings = mDictViewContent.getSettings();
         webSettings.setLayoutAlgorithm(Utils.getLayoutAlgorithm(true));
         webSettings.setJavaScriptEnabled(true);
         webSettings.setDefaultTextEncodingName("UTF-8");
         // webSettings.setSupportZoom(true);
-        mSpeakImg = (ImageButton)view.findViewById(R.id.action_speak);
+        mSpeakImg = (ImageButton) view.findViewById(R.id.action_speak);
         mSpeakImg.setVisibility(/* tts ? View.VISIBLE : */View.GONE);
     }
 
@@ -335,10 +307,10 @@ public class QDictService extends StandOutWindow {
     private void synchronizePositions(int id, StandOutLayoutParams... params) {
 
         StandOutLayoutParams currentParam = getParams(id);
-        for (int i = 0; i < params.length; i++) {
-            if (params[i] != null) {
-                params[i].x = currentParam.x;
-                params[i].y = currentParam.y;
+        for (StandOutLayoutParams param : params) {
+            if (param != null) {
+                param.x = currentParam.x;
+                param.y = currentParam.y;
             }
         }
     }
@@ -378,10 +350,15 @@ public class QDictService extends StandOutWindow {
         return openedParams;
     }
 
-    private class WriteHistoryRunnable implements Runnable {
-        private WordsFileUtils mWordsFileUtilsHis;
+    public class LocalBinder extends Binder {
+        QDictService getService() {
+            return QDictService.this;
+        }
+    }
 
+    private class WriteHistoryRunnable implements Runnable {
         private final CharSequence mTextToWrite;
+        private WordsFileUtils mWordsFileUtilsHis;
 
         public WriteHistoryRunnable(CharSequence text) {
             mWordsFileUtilsHis = new WordsFileUtils(mSharedPreferences, Def.TYPE_RECENTWORDS);
diff --git a/qDict/src/main/java/com/annie/dictionary/standout/StandOutFlags.java b/qDict/src/main/java/com/annie/dictionary/standout/StandOutFlags.java
index 7d772be..640fd4e 100644
--- a/qDict/src/main/java/com/annie/dictionary/standout/StandOutFlags.java
+++ b/qDict/src/main/java/com/annie/dictionary/standout/StandOutFlags.java
@@ -1,4 +1,3 @@
-
 package com.annie.dictionary.standout;
 
 import android.view.Gravity;
@@ -7,7 +6,7 @@ import android.view.View;
 
 /**
  * Flags to be returned from {@link StandOutWindow#getFlags(int)}.
- * 
+ *
  * @author Mark Wei <markwei@gmail.com>
  */
 public class StandOutFlags {
@@ -23,7 +22,7 @@ public class StandOutFlags {
     /**
      * Setting this flag indicates that the window decorator should NOT provide
      * a close button.
-     * <p>
+     * <p/>
      * This flag also sets {@link #FLAG_DECORATION_SYSTEM}.
      */
     public static final int FLAG_DECORATION_CLOSE_DISABLE = FLAG_DECORATION_SYSTEM | 1 << flag_bit++;
@@ -31,7 +30,7 @@ public class StandOutFlags {
     /**
      * Setting this flag indicates that the window decorator should NOT provide
      * a resize handle.
-     * <p>
+     * <p/>
      * This flag also sets {@link #FLAG_DECORATION_SYSTEM}.
      */
     public static final int FLAG_DECORATION_RESIZE_DISABLE = FLAG_DECORATION_SYSTEM | 1 << flag_bit++;
@@ -39,7 +38,7 @@ public class StandOutFlags {
     /**
      * Setting this flag indicates that the window decorator should NOT provide
      * a resize handle.
-     * <p>
+     * <p/>
      * This flag also sets {@link #FLAG_DECORATION_SYSTEM}.
      */
     public static final int FLAG_DECORATION_MAXIMIZE_DISABLE = FLAG_DECORATION_SYSTEM | 1 << flag_bit++;
@@ -47,7 +46,7 @@ public class StandOutFlags {
     /**
      * Setting this flag indicates that the window decorator should NOT provide
      * a resize handle.
-     * <p>
+     * <p/>
      * This flag also sets {@link #FLAG_DECORATION_SYSTEM}.
      */
     public static final int FLAG_DECORATION_MOVE_DISABLE = FLAG_DECORATION_SYSTEM | 1 << flag_bit++;
@@ -55,7 +54,7 @@ public class StandOutFlags {
     /**
      * Setting this flag indicates that the window can be moved by dragging the
      * body.
-     * <p>
+     * <p/>
      * Note that if {@link #FLAG_DECORATION_SYSTEM} is set, the window can
      * always be moved by dragging the titlebar regardless of this flag.
      */
@@ -74,7 +73,7 @@ public class StandOutFlags {
     /**
      * Setting this flag indicates that the window should be brought to the
      * front upon user interaction.
-     * <p>
+     * <p/>
      * Note that if you set this flag, there is a noticeable flashing of the
      * window during {@link MotionEvent#ACTION_UP}. This the hack that allows
      * the system to bring the window to the front.
@@ -84,7 +83,7 @@ public class StandOutFlags {
     /**
      * Setting this flag indicates that the window should be brought to the
      * front upon user tap.
-     * <p>
+     * <p/>
      * Note that if you set this flag, there is a noticeable flashing of the
      * window during {@link MotionEvent#ACTION_UP}. This the hack that allows
      * the system to bring the window to the front.
@@ -95,7 +94,7 @@ public class StandOutFlags {
      * Setting this flag indicates that the system should keep the window's
      * position within the edges of the screen. If this flag is not set, the
      * window will be able to be dragged off of the screen.
-     * <p>
+     * <p/>
      * If this flag is set, the window's {@link Gravity} is recommended to be
      * {@link Gravity#TOP} | {@link Gravity#LEFT}. If the gravity is anything
      * other than TOP|LEFT, then even though the window will be displayed within
@@ -106,12 +105,12 @@ public class StandOutFlags {
     /**
      * Setting this flag indicates that the system should keep the window's
      * aspect ratio constant when resizing.
-     * <p>
+     * <p/>
      * The aspect ratio will only be enforced in
      * {@link StandOutWindow#onTouchHandleResize(int, Window, View, MotionEvent)}
      * . The aspect ratio will not be enforced if you set the width or height of
      * the window's LayoutParams manually.
-     * 
+     *
      * @see StandOutWindow#onTouchHandleResize(int, Window, View, MotionEvent)
      */
     public static final int FLAG_WINDOW_ASPECT_RATIO_ENABLE = 1 << flag_bit++;
@@ -119,7 +118,7 @@ public class StandOutFlags {
     /**
      * Setting this flag indicates that the system should resize the window when
      * it detects a pinch-to-zoom gesture.
-     * 
+     *
      * @see Window#onInterceptTouchEvent(MotionEvent)
      */
     public static final int FLAG_WINDOW_PINCH_RESIZE_ENABLE = 1 << flag_bit++;
@@ -128,14 +127,14 @@ public class StandOutFlags {
      * Setting this flag indicates that the window does not need focus. If this
      * flag is set, the system will not take care of setting and unsetting the
      * focus of windows based on user touch and key events.
-     * <p>
+     * <p/>
      * You will most likely need focus if your window contains any of the
      * following: Button, ListView, EditText.
-     * <p>
+     * <p/>
      * The benefit of disabling focus is that your window will not consume any
      * key events. Normally, focused windows will consume the Back and Menu
      * keys.
-     * 
+     *
      * @see {@link StandOutWindow#focus(int)}
      * @see {@link StandOutWindow#unfocus(int)}
      */
@@ -146,7 +145,7 @@ public class StandOutFlags {
      * window's visual state when focus is changed. If this flag is set, the
      * implementation can choose to change the visual state in
      * {@link StandOutWindow#onFocusChange(int, Window, boolean)}.
-     * 
+     *
      * @see {@link Window#onFocus(boolean)}
      */
     public static final int FLAG_WINDOW_FOCUS_INDICATOR_DISABLE = 1 << flag_bit++;
@@ -156,7 +155,7 @@ public class StandOutFlags {
      * compatibility workarounds. The default behavior is to run
      * {@link Window#fixCompatibility(View, int)} on the view returned by the
      * implementation.
-     * 
+     *
      * @see {@link Window#fixCompatibility(View, int)}
      */
     public static final int FLAG_FIX_COMPATIBILITY_ALL_DISABLE = 1 << flag_bit++;
@@ -166,7 +165,7 @@ public class StandOutFlags {
      * functionality. The default behavior is to run
      * {@link Window#addFunctionality(View, int)} on the view returned by the
      * implementation.
-     * 
+     *
      * @see {@link StandOutWindow#addFunctionality(View, int)}
      */
     public static final int FLAG_ADD_FUNCTIONALITY_ALL_DISABLE = 1 << flag_bit++;
@@ -174,10 +173,10 @@ public class StandOutFlags {
     /**
      * Setting this flag indicates that the system should disable adding the
      * resize handle additional functionality to a custom View R.id.corner.
-     * <p>
+     * <p/>
      * If {@link #FLAG_DECORATION_SYSTEM} is set, the user will always be able
      * to resize the window with the default corner.
-     * 
+     *
      * @see {@link Window#addFunctionality(View, int)}
      */
     public static final int FLAG_ADD_FUNCTIONALITY_RESIZE_DISABLE = 1 << flag_bit++;
@@ -186,10 +185,10 @@ public class StandOutFlags {
      * Setting this flag indicates that the system should disable adding the
      * drop down menu additional functionality to a custom View
      * R.id.window_icon.
-     * <p>
+     * <p/>
      * If {@link #FLAG_DECORATION_SYSTEM} is set, the user will always be able
      * to show the drop down menu with the default window icon.
-     * 
+     *
      * @see {@link Window#addFunctionality(View, int)}
      */
     public static final int FLAG_ADD_FUNCTIONALITY_DROP_DOWN_DISABLE = 1 << flag_bit++;
diff --git a/qDict/src/main/java/com/annie/dictionary/standout/StandOutWindow.java b/qDict/src/main/java/com/annie/dictionary/standout/StandOutWindow.java
index 9f02f2c..d10457a 100644
--- a/qDict/src/main/java/com/annie/dictionary/standout/StandOutWindow.java
+++ b/qDict/src/main/java/com/annie/dictionary/standout/StandOutWindow.java
@@ -1,15 +1,5 @@
-
 package com.annie.dictionary.standout;
 
-import java.util.ArrayList;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Set;
-
-import com.annie.dictionary.MainActivity;
-import com.annie.dictionary.R;
-import com.annie.dictionary.utils.Utils.Def;
-
 import android.app.Notification;
 import android.app.NotificationManager;
 import android.app.PendingIntent;
@@ -43,82 +33,96 @@ import android.widget.LinearLayout;
 import android.widget.PopupWindow;
 import android.widget.TextView;
 
+import com.annie.dictionary.MainActivity;
+import com.annie.dictionary.R;
+import com.annie.dictionary.utils.Utils.Def;
+
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+
 /**
  * Extend this class to easily create and manage floating StandOut windows.
- * 
+ *
  * @author Mark Wei <markwei@gmail.com> Contributors: Jason
  *         <github.com/jasonconnery>
  */
 public abstract class StandOutWindow extends Service {
-    static final String TAG = "StandOutWindow";
-
     /**
      * StandOut window id: You may use this sample id for your first window.
      */
     public static final int DEFAULT_ID = 0;
-
     public static final int HIDE_NOTIFICATION_ID = 1009;
-
     /**
      * Special StandOut window id: You may NOT use this id for any windows.
      */
     public static final int ONGOING_NOTIFICATION_ID = -1;
-
     /**
      * StandOut window id: You may use this id when you want it to be
      * disregarded. The system makes no distinction for this id; it is only used
      * to improve code readability.
      */
     public static final int DISREGARD_ID = -2;
-
     /**
      * Intent action: Show a new window corresponding to the id.
      */
     public static final String ACTION_SHOW = "SHOW";
-
     /**
      * Intent action: Restore a previously hidden window corresponding to the
      * id. The window should be previously hidden with {@link #ACTION_HIDE}.
      */
     public static final String ACTION_RESTORE = "RESTORE";
-
     /**
      * Intent action: Close an existing window with an existing id.
      */
     public static final String ACTION_CLOSE = "CLOSE";
-
     /**
      * Intent action: Close all existing windows.
      */
     public static final String ACTION_CLOSE_ALL = "CLOSE_ALL";
-
     /**
      * Intent action: Send data to a new or existing window.
      */
     public static final String ACTION_SEND_DATA = "SEND_DATA";
-
     public static final String ACTION_TOGGLE_NOTIFICATION = "TOGGLE_NOTIFICATION";
-
     /**
      * Intent action: Hide an existing window with an existing id. To enable the
      * ability to restore this window, make sure you implement
      * {@link #getHiddenNotification(int)}.
      */
     public static final String ACTION_HIDE = "HIDE";
+    static final String TAG = "StandOutWindow";
+    // internal map of ids to shown/hidden views
+    static WindowCache sWindowCache;
+    static Window sFocusedWindow;
 
+    // static constructors
+    static {
+        sWindowCache = new WindowCache();
+        sFocusedWindow = null;
+    }
+
+    protected SharedPreferences mSharedPreferences;
     int sThemeIndex = 0;
+    // internal system services
+    WindowManager mWindowManager;
+    LayoutInflater mLayoutInflater;
+    private NotificationManager mNotificationManager;
+    // internal state variables
+    private boolean startedForeground;
 
     /**
      * Show a new window corresponding to the id, or restore a previously hidden
      * window.
-     * 
+     *
      * @param context A Context of the application package implementing this
-     *            class.
-     * @param cls The Service extending {@link StandOutWindow} that will be used
-     *            to create and manage the window.
-     * @param id The id representing this window. If the id exists, and the
-     *            corresponding window was previously hidden, then that window
-     *            will be restored.
+     *                class.
+     * @param cls     The Service extending {@link StandOutWindow} that will be used
+     *                to create and manage the window.
+     * @param id      The id representing this window. If the id exists, and the
+     *                corresponding window was previously hidden, then that window
+     *                will be restored.
      * @see #show(int)
      */
     public static void show(Context context, Class<? extends StandOutWindow> cls, int id) {
@@ -133,13 +137,13 @@ public abstract class StandOutWindow extends Service {
      * Hide the existing window corresponding to the id. To enable the ability
      * to restore this window, make sure you implement
      * {@link #getHiddenNotification(int)}.
-     * 
+     *
      * @param context A Context of the application package implementing this
-     *            class.
-     * @param cls The Service extending {@link StandOutWindow} that is managing
-     *            the window.
-     * @param id The id representing this window. The window must previously be
-     *            shown.
+     *                class.
+     * @param cls     The Service extending {@link StandOutWindow} that is managing
+     *                the window.
+     * @param id      The id representing this window. The window must previously be
+     *                shown.
      * @see #hide(int)
      */
     public static void hide(Context context, Class<? extends StandOutWindow> cls, int id) {
@@ -148,13 +152,13 @@ public abstract class StandOutWindow extends Service {
 
     /**
      * Close an existing window with an existing id.
-     * 
+     *
      * @param context A Context of the application package implementing this
-     *            class.
-     * @param cls The Service extending {@link StandOutWindow} that is managing
-     *            the window.
-     * @param id The id representing this window. The window must previously be
-     *            shown.
+     *                class.
+     * @param cls     The Service extending {@link StandOutWindow} that is managing
+     *                the window.
+     * @param id      The id representing this window. The window must previously be
+     *                shown.
      * @see #close(int)
      */
     public static void close(Context context, Class<? extends StandOutWindow> cls, int id) {
@@ -163,11 +167,11 @@ public abstract class StandOutWindow extends Service {
 
     /**
      * Close all existing windows.
-     * 
+     *
      * @param context A Context of the application package implementing this
-     *            class.
-     * @param cls The Service extending {@link StandOutWindow} that is managing
-     *            the window.
+     *                class.
+     * @param cls     The Service extending {@link StandOutWindow} that is managing
+     *                the window.
      * @see #closeAll()
      */
     public static void closeAll(Context context, Class<? extends StandOutWindow> cls) {
@@ -177,43 +181,43 @@ public abstract class StandOutWindow extends Service {
     /**
      * This allows windows of different applications to communicate with each
      * other.
-     * <p>
+     * <p/>
      * Send {@link Parceleable} data in a {@link Bundle} to a new or existing
      * windows. The implementation of the recipient window can handle what to do
      * with the data. To receive a result, provide the class and id of the
      * sender.
-     * 
-     * @param context A Context of the application package implementing the
-     *            class of the sending window.
-     * @param toCls The Service's class extending {@link StandOutWindow} that is
-     *            managing the receiving window.
-     * @param toId The id of the receiving window, or DISREGARD_ID.
+     *
+     * @param context     A Context of the application package implementing the
+     *                    class of the sending window.
+     * @param toCls       The Service's class extending {@link StandOutWindow} that is
+     *                    managing the receiving window.
+     * @param toId        The id of the receiving window, or DISREGARD_ID.
      * @param requestCode Provide a request code to declare what kind of data is
-     *            being sent.
-     * @param data A bundle of parceleable data to be sent to the receiving
-     *            window.
-     * @param fromCls Provide the class of the sending window if you want a
-     *            result.
-     * @param fromId Provide the id of the sending window if you want a result.
+     *                    being sent.
+     * @param data        A bundle of parceleable data to be sent to the receiving
+     *                    window.
+     * @param fromCls     Provide the class of the sending window if you want a
+     *                    result.
+     * @param fromId      Provide the id of the sending window if you want a result.
      * @see #sendData(int, Class, int, int, Bundle)
      */
     public static void sendData(Context context, Class<? extends StandOutWindow> toCls, int toId, int requestCode,
-            Bundle data, Class<? extends StandOutWindow> fromCls, int fromId) {
+                                Bundle data, Class<? extends StandOutWindow> fromCls, int fromId) {
         context.startService(getSendDataIntent(context, toCls, toId, requestCode, data, fromCls, fromId));
     }
 
     /**
      * See {@link #show(Context, Class, int)}.
-     * 
+     *
      * @param context A Context of the application package implementing this
-     *            class.
-     * @param cls The Service extending {@link StandOutWindow} that will be used
-     *            to create and manage the window.
-     * @param id The id representing this window. If the id exists, and the
-     *            corresponding window was previously hidden, then that window
-     *            will be restored.
+     *                class.
+     * @param cls     The Service extending {@link StandOutWindow} that will be used
+     *                to create and manage the window.
+     * @param id      The id representing this window. If the id exists, and the
+     *                corresponding window was previously hidden, then that window
+     *                will be restored.
      * @return An {@link Intent} to use with
-     *         {@link Context#startService(Intent)}.
+     * {@link Context#startService(Intent)}.
      */
     public static Intent getShowIntent(Context context, Class<? extends StandOutWindow> cls, int id) {
         boolean cached = sWindowCache.isCached(id, cls);
@@ -223,23 +227,23 @@ public abstract class StandOutWindow extends Service {
     }
 
     public static Intent getToggleNoticationIntent(Context context, Class<? extends StandOutWindow> cls, int id,
-            boolean showNotifi) {
+                                                   boolean showNotifi) {
         String action = ACTION_TOGGLE_NOTIFICATION;
         return new Intent(context, cls).putExtra("id", id).putExtra("show_notification", showNotifi).setAction(action);
     }
 
     /**
      * See {@link #hide(Context, Class, int)}.
-     * 
+     *
      * @param context A Context of the application package implementing this
-     *            class.
-     * @param cls The Service extending {@link StandOutWindow} that is managing
-     *            the window.
-     * @param id The id representing this window. If the id exists, and the
-     *            corresponding window was previously hidden, then that window
-     *            will be restored.
+     *                class.
+     * @param cls     The Service extending {@link StandOutWindow} that is managing
+     *                the window.
+     * @param id      The id representing this window. If the id exists, and the
+     *                corresponding window was previously hidden, then that window
+     *                will be restored.
      * @return An {@link Intent} to use with
-     *         {@link Context#startService(Intent)}.
+     * {@link Context#startService(Intent)}.
      */
     public static Intent getHideIntent(Context context, Class<? extends StandOutWindow> cls, int id) {
         return new Intent(context, cls).putExtra("id", id).setAction(ACTION_HIDE);
@@ -247,16 +251,16 @@ public abstract class StandOutWindow extends Service {
 
     /**
      * See {@link #close(Context, Class, int)}.
-     * 
+     *
      * @param context A Context of the application package implementing this
-     *            class.
-     * @param cls The Service extending {@link StandOutWindow} that is managing
-     *            the window.
-     * @param id The id representing this window. If the id exists, and the
-     *            corresponding window was previously hidden, then that window
-     *            will be restored.
+     *                class.
+     * @param cls     The Service extending {@link StandOutWindow} that is managing
+     *                the window.
+     * @param id      The id representing this window. If the id exists, and the
+     *                corresponding window was previously hidden, then that window
+     *                will be restored.
      * @return An {@link Intent} to use with
-     *         {@link Context#startService(Intent)}.
+     * {@link Context#startService(Intent)}.
      */
     public static Intent getCloseIntent(Context context, Class<? extends StandOutWindow> cls, int id) {
         return new Intent(context, cls).putExtra("id", id).setAction(ACTION_CLOSE);
@@ -264,13 +268,13 @@ public abstract class StandOutWindow extends Service {
 
     /**
      * See {@link #closeAll(Context, Class, int)}.
-     * 
+     *
      * @param context A Context of the application package implementing this
-     *            class.
-     * @param cls The Service extending {@link StandOutWindow} that is managing
-     *            the window.
+     *                class.
+     * @param cls     The Service extending {@link StandOutWindow} that is managing
+     *                the window.
      * @return An {@link Intent} to use with
-     *         {@link Context#startService(Intent)}.
+     * {@link Context#startService(Intent)}.
      */
     public static Intent getCloseAllIntent(Context context, Class<? extends StandOutWindow> cls) {
         return new Intent(context, cls).setAction(ACTION_CLOSE_ALL);
@@ -278,53 +282,30 @@ public abstract class StandOutWindow extends Service {
 
     /**
      * See {@link #sendData(Context, Class, int, int, Bundle, Class, int)}.
-     * 
-     * @param context A Context of the application package implementing the
-     *            class of the sending window.
-     * @param toCls The Service's class extending {@link StandOutWindow} that is
-     *            managing the receiving window.
-     * @param toId The id of the receiving window.
+     *
+     * @param context     A Context of the application package implementing the
+     *                    class of the sending window.
+     * @param toCls       The Service's class extending {@link StandOutWindow} that is
+     *                    managing the receiving window.
+     * @param toId        The id of the receiving window.
      * @param requestCode Provide a request code to declare what kind of data is
-     *            being sent.
-     * @param data A bundle of parceleable data to be sent to the receiving
-     *            window.
-     * @param fromCls If the sending window wants a result, provide the class of
-     *            the sending window.
-     * @param fromId If the sending window wants a result, provide the id of the
-     *            sending window.
+     *                    being sent.
+     * @param data        A bundle of parceleable data to be sent to the receiving
+     *                    window.
+     * @param fromCls     If the sending window wants a result, provide the class of
+     *                    the sending window.
+     * @param fromId      If the sending window wants a result, provide the id of the
+     *                    sending window.
      * @return An {@link Intnet} to use with
-     *         {@link Context#startService(Intent)}.
+     * {@link Context#startService(Intent)}.
      */
     public static Intent getSendDataIntent(Context context, Class<? extends StandOutWindow> toCls, int toId,
-            int requestCode, Bundle data, Class<? extends StandOutWindow> fromCls, int fromId) {
+                                           int requestCode, Bundle data, Class<? extends StandOutWindow> fromCls, int fromId) {
         return new Intent(context, toCls).putExtra("id", toId).putExtra("requestCode", requestCode)
                 .putExtra("wei.mark.standout.data", data).putExtra("wei.mark.standout.fromCls", fromCls)
                 .putExtra("fromId", fromId).setAction(ACTION_SEND_DATA);
     }
 
-    // internal map of ids to shown/hidden views
-    static WindowCache sWindowCache;
-
-    static Window sFocusedWindow;
-
-    // static constructors
-    static {
-        sWindowCache = new WindowCache();
-        sFocusedWindow = null;
-    }
-
-    // internal system services
-    WindowManager mWindowManager;
-
-    private NotificationManager mNotificationManager;
-
-    LayoutInflater mLayoutInflater;
-
-    protected SharedPreferences mSharedPreferences;
-
-    // internal state variables
-    private boolean startedForeground;
-
     @Override
     public IBinder onBind(Intent intent) {
         return null;
@@ -334,9 +315,9 @@ public abstract class StandOutWindow extends Service {
     public void onCreate() {
         super.onCreate();
         mSharedPreferences = getSharedPreferences(Def.APP_NAME, Context.MODE_PRIVATE);
-        mWindowManager = (WindowManager)getSystemService(Context.WINDOW_SERVICE);
-        mNotificationManager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);
-        mLayoutInflater = (LayoutInflater)getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+        mWindowManager = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
+        mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
+        mLayoutInflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);
         sThemeIndex = mSharedPreferences.getInt("prefs_key_theme", 0);
         startedForeground = false;
     }
@@ -373,7 +354,7 @@ public abstract class StandOutWindow extends Service {
                 Bundle data = intent.getBundleExtra("wei.mark.standout.data");
                 int requestCode = intent.getIntExtra("requestCode", 0);
                 @SuppressWarnings("unchecked")
-                Class<? extends StandOutWindow> fromCls = (Class<? extends StandOutWindow>)intent
+                Class<? extends StandOutWindow> fromCls = (Class<? extends StandOutWindow>) intent
                         .getSerializableExtra("wei.mark.standout.fromCls");
                 int fromId = intent.getIntExtra("fromId", DEFAULT_ID);
                 onReceiveData(id, requestCode, data, fromCls, fromId);
@@ -436,7 +417,7 @@ public abstract class StandOutWindow extends Service {
      * Return the name of every window in this implementation. The name will
      * appear in the default implementations of the system window decoration
      * title and notification titles.
-     * 
+     *
      * @return The name.
      */
     public abstract String getAppName();
@@ -445,7 +426,7 @@ public abstract class StandOutWindow extends Service {
      * Return the icon resource for every window in this implementation. The
      * icon will appear in the default implementations of the system window
      * decoration and notifications.
-     * 
+     *
      * @return The icon.
      */
     public abstract int getAppIcon();
@@ -454,15 +435,15 @@ public abstract class StandOutWindow extends Service {
      * Create a new {@link View} corresponding to the id, and add it as a child
      * to the frame. The view will become the contents of this StandOut window.
      * The view MUST be newly created, and you MUST attach it to the frame.
-     * <p>
+     * <p/>
      * If you are inflating your view from XML, make sure you use
      * {@link LayoutInflater#inflate(int, ViewGroup, boolean)} to attach your
      * view to frame. Set the ViewGroup to be frame, and the boolean to true.
-     * <p>
+     * <p/>
      * If you are creating your view programmatically, make sure you use
      * {@link FrameLayout#addView(View)} to add your view to the frame.
-     * 
-     * @param id The id representing the window.
+     *
+     * @param id    The id representing the window.
      * @param frame The {@link FrameLayout} to attach your view as a child to.
      */
     public abstract void createAndAttachView(int id, FrameLayout frame);
@@ -473,27 +454,27 @@ public abstract class StandOutWindow extends Service {
      * Return the {@link StandOutWindow#LayoutParams} for the corresponding id.
      * The system will set the layout params on the view for this StandOut
      * window. The layout params may be reused.
-     * 
-     * @param id The id of the window.
+     *
+     * @param id     The id of the window.
      * @param window The window corresponding to the id. Given as courtesy, so
-     *            you may get the existing layout params.
+     *               you may get the existing layout params.
      * @return The {@link StandOutWindow#LayoutParams} corresponding to the id.
-     *         The layout params will be set on the window. The layout params
-     *         returned will be reused whenever possible, minimizing the number
-     *         of times getParams() will be called.
+     * The layout params will be set on the window. The layout params
+     * returned will be reused whenever possible, minimizing the number
+     * of times getParams() will be called.
      */
     public abstract StandOutLayoutParams getParams(int id, Window window);
 
     /**
      * Implement this method to change modify the behavior and appearance of the
      * window corresponding to the id.
-     * <p>
+     * <p/>
      * You may use any of the flags defined in {@link StandOutFlags}. This
      * method will be called many times, so keep it fast.
-     * <p>
+     * <p/>
      * Use bitwise OR (|) to set flags, and bitwise XOR (^) to unset flags. To
      * test if a flag is set, use {@link Utils#isSet(int, int)}.
-     * 
+     *
      * @param id The id of the window.
      * @return A combination of flags.
      */
@@ -504,7 +485,7 @@ public abstract class StandOutWindow extends Service {
     /**
      * Implement this method to set a custom title for the window corresponding
      * to the id.
-     * 
+     *
      * @param id The id of the window.
      * @return The title of the window.
      */
@@ -515,7 +496,7 @@ public abstract class StandOutWindow extends Service {
     /**
      * Implement this method to set a custom icon for the window corresponding
      * to the id.
-     * 
+     *
      * @param id The id of the window.
      * @return The icon of the window.
      */
@@ -526,7 +507,7 @@ public abstract class StandOutWindow extends Service {
     /**
      * Return the title for the persistent notification. This is called every
      * time {@link #show(int)} is called.
-     * 
+     *
      * @param id The id of the window shown.
      * @return The title for the persistent notification.
      */
@@ -537,7 +518,7 @@ public abstract class StandOutWindow extends Service {
     /**
      * Return the message for the persistent notification. This is called every
      * time {@link #show(int)} is called.
-     * 
+     *
      * @param id The id of the window shown.
      * @return The message for the persistent notification.
      */
@@ -548,10 +529,10 @@ public abstract class StandOutWindow extends Service {
     /**
      * Return the intent for the persistent notification. This is called every
      * time {@link #show(int)} is called.
-     * <p>
+     * <p/>
      * The returned intent will be packaged into a {@link PendingIntent} to be
      * invoked when the user clicks the notification.
-     * 
+     *
      * @param id The id of the window shown.
      * @return The intent for the persistent notification.
      */
@@ -566,19 +547,19 @@ public abstract class StandOutWindow extends Service {
      * {@link #getPersistentNotification(int)} may return null. This way Android
      * can start the StandOut window service in the foreground and will not kill
      * the service on low memory.
-     * <p>
+     * <p/>
      * As a courtesy, the system will request a notification for every new id
      * shown. Your implementation is encouraged to include the
      * {@link PendingIntent#FLAG_UPDATE_CURRENT} flag in the notification so
      * that there is only one system-wide persistent notification.
-     * <p>
+     * <p/>
      * See the StandOutExample project for an implementation of
      * {@link #getPersistentNotification(int)} that keeps one system-wide
      * persistent notification that creates a new window on every click.
-     * 
+     *
      * @param id The id of the window.
      * @return The {@link Notification} corresponding to the id, or null if
-     *         you've previously returned a notification.
+     * you've previously returned a notification.
      */
     public Notification getPersistentNotification(int id) {
         // basic notification stuff
@@ -610,7 +591,7 @@ public abstract class StandOutWindow extends Service {
     /**
      * Return the animation to play when the window corresponding to the id is
      * shown.
-     * 
+     *
      * @param id The id of the window.
      * @return The animation to play or null.
      */
@@ -621,7 +602,7 @@ public abstract class StandOutWindow extends Service {
     /**
      * Return the animation to play when the window corresponding to the id is
      * hidden.
-     * 
+     *
      * @param id The id of the window.
      * @return The animation to play or null.
      */
@@ -632,7 +613,7 @@ public abstract class StandOutWindow extends Service {
     /**
      * Return the animation to play when the window corresponding to the id is
      * closed.
-     * 
+     *
      * @param id The id of the window.
      * @return The animation to play or null.
      */
@@ -643,7 +624,7 @@ public abstract class StandOutWindow extends Service {
     /**
      * Implement this method to set a custom theme for all windows in this
      * implementation.
-     * 
+     *
      * @return The theme to set on the window, or 0 for device default.
      */
     public int getThemeStyle() {
@@ -665,14 +646,14 @@ public abstract class StandOutWindow extends Service {
      * You probably want to leave this method alone and implement
      * {@link #getDropDownItems(int)} instead. Only implement this method if you
      * want more control over the drop down menu.
-     * <p>
+     * <p/>
      * Implement this method to set a custom drop down menu when the user clicks
      * on the icon of the window corresponding to the id. The icon is only shown
      * when {@link StandOutFlags#FLAG_DECORATION_SYSTEM} is set.
-     * 
+     *
      * @param id The id of the window.
      * @return The drop down menu to be anchored to the icon, or null to have no
-     *         dropdown menu.
+     * dropdown menu.
      */
     public PopupWindow getDropDown(final int id) {
         final List<DropDownListItem> items;
@@ -688,11 +669,11 @@ public abstract class StandOutWindow extends Service {
         items.add(new DropDownListItem((sThemeIndex == 0) ? R.drawable.ic_dlg_close_orange : R.drawable.ic_dlg_close,
                 getResources().getString(R.string.close), new Runnable() {
 
-                    @Override
-                    public void run() {
-                        closeAll();
-                    }
-                }));
+            @Override
+            public void run() {
+                closeAll();
+            }
+        }));
 
         // turn item list into views in PopupWindow
         LinearLayout list = new LinearLayout(this);
@@ -702,13 +683,13 @@ public abstract class StandOutWindow extends Service {
                 StandOutLayoutParams.WRAP_CONTENT, true);
 
         for (final DropDownListItem item : items) {
-            ViewGroup listItem = (ViewGroup)mLayoutInflater.inflate(R.layout.drop_down_list_item, null);
+            ViewGroup listItem = (ViewGroup) mLayoutInflater.inflate(R.layout.drop_down_list_item, null);
             list.addView(listItem);
 
-            ImageView icon = (ImageView)listItem.findViewById(R.id.icon);
+            ImageView icon = (ImageView) listItem.findViewById(R.id.icon);
             icon.setImageResource(item.icon);
 
-            TextView description = (TextView)listItem.findViewById(R.id.description);
+            TextView description = (TextView) listItem.findViewById(R.id.description);
             description.setText(item.description);
 
             listItem.setOnClickListener(new OnClickListener() {
@@ -730,10 +711,10 @@ public abstract class StandOutWindow extends Service {
      * Implement this method to populate the drop down menu when the user clicks
      * on the icon of the window corresponding to the id. The icon is only shown
      * when {@link StandOutFlags#FLAG_DECORATION_SYSTEM} is set.
-     * 
+     *
      * @param id The id of the window.
      * @return The list of items to show in the drop down menu, or null or empty
-     *         to have no dropdown menu.
+     * to have no dropdown menu.
      */
     public List<DropDownListItem> getDropDownItems(int id) {
         return null;
@@ -742,15 +723,15 @@ public abstract class StandOutWindow extends Service {
     /**
      * Implement this method to be alerted to touch events in the body of the
      * window corresponding to the id.
-     * <p>
+     * <p/>
      * Note that even if you set {@link #FLAG_DECORATION_SYSTEM}, you will not
      * receive touch events from the system window decorations.
-     * 
-     * @see {@link View.OnTouchListener#onTouch(View, MotionEvent)}
-     * @param id The id of the view, provided as a courtesy.
+     *
+     * @param id     The id of the view, provided as a courtesy.
      * @param window The window corresponding to the id, provided as a courtesy.
-     * @param view The view where the event originated from.
-     * @param event See linked method.
+     * @param view   The view where the event originated from.
+     * @param event  See linked method.
+     * @see {@link View.OnTouchListener#onTouch(View, MotionEvent)}
      */
     public boolean onTouchBody(int id, Window window, View view, MotionEvent event) {
         return false;
@@ -759,11 +740,11 @@ public abstract class StandOutWindow extends Service {
     /**
      * Implement this method to be alerted to when the window corresponding to
      * the id is moved.
-     * 
-     * @param id The id of the view, provided as a courtesy.
+     *
+     * @param id     The id of the view, provided as a courtesy.
      * @param window The window corresponding to the id, provided as a courtesy.
-     * @param view The view where the event originated from.
-     * @param event See linked method.
+     * @param view   The view where the event originated from.
+     * @param event  See linked method.
      * @see {@link #onTouchHandleMove(int, Window, View, MotionEvent)}
      */
     public void onMove(int id, Window window, View view, MotionEvent event) {
@@ -772,11 +753,11 @@ public abstract class StandOutWindow extends Service {
     /**
      * Implement this method to be alerted to when the window corresponding to
      * the id is resized.
-     * 
-     * @param id The id of the view, provided as a courtesy.
+     *
+     * @param id     The id of the view, provided as a courtesy.
      * @param window The window corresponding to the id, provided as a courtesy.
-     * @param view The view where the event originated from.
-     * @param event See linked method.
+     * @param view   The view where the event originated from.
+     * @param event  See linked method.
      * @see {@link #onTouchHandleResize(int, Window, View, MotionEvent)}
      */
     public void onResize(int id, Window window, View view, MotionEvent event) {
@@ -786,11 +767,11 @@ public abstract class StandOutWindow extends Service {
      * Implement this callback to be alerted when a window corresponding to the
      * id is about to be shown. This callback will occur before the view is
      * added to the window manager.
-     * 
-     * @param id The id of the view, provided as a courtesy.
+     *
+     * @param id   The id of the view, provided as a courtesy.
      * @param view The view about to be shown.
      * @return Return true to cancel the view from being shown, or false to
-     *         continue.
+     * continue.
      * @see #show(int)
      */
     public boolean onShow(int id, Window window) {
@@ -802,11 +783,11 @@ public abstract class StandOutWindow extends Service {
      * id is about to be hidden. This callback will occur before the view is
      * removed from the window manager and {@link #getHiddenNotification(int)}
      * is called.
-     * 
-     * @param id The id of the view, provided as a courtesy.
+     *
+     * @param id   The id of the view, provided as a courtesy.
      * @param view The view about to be hidden.
      * @return Return true to cancel the view from being hidden, or false to
-     *         continue.
+     * continue.
      * @see #hide(int)
      */
     public boolean onHide(int id, Window window) {
@@ -817,11 +798,11 @@ public abstract class StandOutWindow extends Service {
      * Implement this callback to be alerted when a window corresponding to the
      * id is about to be closed. This callback will occur before the view is
      * removed from the window manager.
-     * 
-     * @param id The id of the view, provided as a courtesy.
+     *
+     * @param id   The id of the view, provided as a courtesy.
      * @param view The view about to be closed.
      * @return Return true to cancel the view from being closed, or false to
-     *         continue.
+     * continue.
      * @see #close(int)
      */
     public boolean onClose(int id, Window window) {
@@ -832,9 +813,9 @@ public abstract class StandOutWindow extends Service {
      * Implement this callback to be alerted when all windows are about to be
      * closed. This callback will occur before any views are removed from the
      * window manager.
-     * 
+     *
      * @return Return true to cancel the views from being closed, or false to
-     *         continue.
+     * continue.
      * @see #closeAll()
      */
     public boolean onCloseAll() {
@@ -846,31 +827,31 @@ public abstract class StandOutWindow extends Service {
      * id has received some data. The sender is described by fromCls and fromId
      * if the sender wants a result. To send a result, use
      * {@link #sendData(int, Class, int, int, Bundle)}.
-     * 
-     * @param id The id of your receiving window.
+     *
+     * @param id          The id of your receiving window.
      * @param requestCode The sending window provided this request code to
-     *            declare what kind of data is being sent.
-     * @param data A bundle of parceleable data that was sent to your receiving
-     *            window.
-     * @param fromCls The sending window's class. Provided if the sender wants a
-     *            result.
-     * @param fromId The sending window's id. Provided if the sender wants a
-     *            result.
+     *                    declare what kind of data is being sent.
+     * @param data        A bundle of parceleable data that was sent to your receiving
+     *                    window.
+     * @param fromCls     The sending window's class. Provided if the sender wants a
+     *                    result.
+     * @param fromId      The sending window's id. Provided if the sender wants a
+     *                    result.
      */
     public void onReceiveData(int id, int requestCode, Bundle data, Class<? extends StandOutWindow> fromCls,
-            int fromId) {
+                              int fromId) {
     }
 
     /**
      * Implement this callback to be alerted when a window corresponding to the
      * id is about to be updated in the layout. This callback will occur before
      * the view is updated by the window manager.
-     * 
-     * @param id The id of the window, provided as a courtesy.
-     * @param view The window about to be updated.
+     *
+     * @param id     The id of the window, provided as a courtesy.
+     * @param view   The window about to be updated.
      * @param params The updated layout params.
      * @return Return true to cancel the window from being updated, or false to
-     *         continue.
+     * continue.
      * @see #updateViewLayout(int, Window, StandOutLayoutParams)
      */
     public boolean onUpdate(int id, Window window, StandOutLayoutParams params) {
@@ -881,11 +862,11 @@ public abstract class StandOutWindow extends Service {
      * Implement this callback to be alerted when a window corresponding to the
      * id is about to be bought to the front. This callback will occur before
      * the window is brought to the front by the window manager.
-     * 
-     * @param id The id of the window, provided as a courtesy.
+     *
+     * @param id   The id of the window, provided as a courtesy.
      * @param view The window about to be brought to the front.
      * @return Return true to cancel the window from being brought to the front,
-     *         or false to continue.
+     * or false to continue.
      * @see #bringToFront(int)
      */
     public boolean onBringToFront(int id, Window window) {
@@ -896,12 +877,12 @@ public abstract class StandOutWindow extends Service {
      * Implement this callback to be alerted when a window corresponding to the
      * id is about to have its focus changed. This callback will occur before
      * the window's focus is changed.
-     * 
-     * @param id The id of the window, provided as a courtesy.
-     * @param view The window about to be brought to the front.
+     *
+     * @param id    The id of the window, provided as a courtesy.
+     * @param view  The window about to be brought to the front.
      * @param focus Whether the window is gaining or losing focus.
      * @return Return true to cancel the window's focus from being changed, or
-     *         false to continue.
+     * false to continue.
      * @see #focus(int)
      */
     public boolean onFocusChange(int id, Window window, boolean focus) {
@@ -912,12 +893,12 @@ public abstract class StandOutWindow extends Service {
      * Implement this callback to be alerted when a window corresponding to the
      * id receives a key event. This callback will occur before the window
      * handles the event with {@link Window#dispatchKeyEvent(KeyEvent)}.
-     * 
-     * @param id The id of the window, provided as a courtesy.
-     * @param view The window about to receive the key event.
+     *
+     * @param id    The id of the window, provided as a courtesy.
+     * @param view  The window about to receive the key event.
      * @param event The key event.
      * @return Return true to cancel the window from handling the key event, or
-     *         false to let the window handle the key event.
+     * false to let the window handle the key event.
      * @see {@link Window#dispatchKeyEvent(KeyEvent)}
      */
     public boolean onKeyEvent(int id, Window window, KeyEvent event) {
@@ -927,7 +908,7 @@ public abstract class StandOutWindow extends Service {
     /**
      * Show or restore a window corresponding to the id. Return the window that
      * was shown/restored.
-     * 
+     *
      * @param id The id of the window.
      * @return The window shown.
      */
@@ -1012,7 +993,7 @@ public abstract class StandOutWindow extends Service {
     /**
      * Hide a window corresponding to the id. Show a notification for the hidden
      * window.
-     * 
+     *
      * @param id The id of the window.
      */
     public final synchronized void hide(int id) {
@@ -1073,7 +1054,7 @@ public abstract class StandOutWindow extends Service {
 
     /**
      * Close a window corresponding to the id.
-     * 
+     *
      * @param id The id of the window.
      */
     public final synchronized void close(final int id) {
@@ -1179,25 +1160,25 @@ public abstract class StandOutWindow extends Service {
      * Send {@link Parceleable} data in a {@link Bundle} to a new or existing
      * windows. The implementation of the recipient window can handle what to do
      * with the data. To receive a result, provide the id of the sender.
-     * 
-     * @param fromId Provide the id of the sending window if you want a result.
-     * @param toCls The Service's class extending {@link StandOutWindow} that is
-     *            managing the receiving window.
-     * @param toId The id of the receiving window.
+     *
+     * @param fromId      Provide the id of the sending window if you want a result.
+     * @param toCls       The Service's class extending {@link StandOutWindow} that is
+     *                    managing the receiving window.
+     * @param toId        The id of the receiving window.
      * @param requestCode Provide a request code to declare what kind of data is
-     *            being sent.
-     * @param data A bundle of parceleable data to be sent to the receiving
-     *            window.
+     *                    being sent.
+     * @param data        A bundle of parceleable data to be sent to the receiving
+     *                    window.
      */
     public final void sendData(int fromId, Class<? extends StandOutWindow> toCls, int toId, int requestCode,
-            Bundle data) {
+                               Bundle data) {
         StandOutWindow.sendData(this, toCls, toId, requestCode, data, getClass(), fromId);
     }
 
     /**
      * Bring the window corresponding to this id in front of all other windows.
      * The window may flicker as it is removed and restored by the system.
-     * 
+     *
      * @param id The id of the window to bring to the front.
      */
     public final synchronized void bringToFront(int id) {
@@ -1239,7 +1220,7 @@ public abstract class StandOutWindow extends Service {
      * Request focus for the window corresponding to this id. A maximum of one
      * window can have focus, and that window will receive all key events,
      * including Back and Menu.
-     * 
+     *
      * @param id The id of the window.
      * @return True if focus changed successfully, false if it failed.
      */
@@ -1265,7 +1246,7 @@ public abstract class StandOutWindow extends Service {
     /**
      * Remove focus for the window corresponding to this id. Once a window is
      * unfocused, it will stop receiving key events.
-     * 
+     *
      * @param id The id of the window.
      * @return True if focus changed successfully, false if it failed.
      */
@@ -1277,7 +1258,7 @@ public abstract class StandOutWindow extends Service {
     /**
      * Courtesy method for your implementation to use if you want to. Gets a
      * unique id to assign to a new window.
-     * 
+     *
      * @return The unique id.
      */
     public final int getUniqueId() {
@@ -1292,11 +1273,11 @@ public abstract class StandOutWindow extends Service {
      * Return whether the window corresponding to the id exists. This is useful
      * for testing if the id is being restored (return true) or shown for the
      * first time (return false).
-     * 
+     *
      * @param id The id of the window.
      * @return True if the window corresponding to the id is either shown or
-     *         hidden, or false if it has never been shown or was previously
-     *         closed.
+     * hidden, or false if it has never been shown or was previously
+     * closed.
      */
     public final boolean isExistingId(int id) {
         return sWindowCache.isCached(id, getClass());
@@ -1304,7 +1285,7 @@ public abstract class StandOutWindow extends Service {
 
     /**
      * Return the ids of all shown or hidden windows.
-     * 
+     *
      * @return A set of ids, or an empty set.
      */
     public final Set<Integer> getExistingIds() {
@@ -1316,7 +1297,7 @@ public abstract class StandOutWindow extends Service {
      * window will not be created with
      * {@link #createAndAttachView(int, ViewGroup)}. This means the returned
      * value will be null if the window is not shown or hidden.
-     * 
+     *
      * @param id The id of the window.
      * @return The window if it is shown/hidden, or null if it is closed.
      */
@@ -1326,7 +1307,7 @@ public abstract class StandOutWindow extends Service {
 
     /**
      * Return the window that currently has focus.
-     * 
+     *
      * @return The window that has focus.
      */
     public final Window getFocusedWindow() {
@@ -1342,13 +1323,13 @@ public abstract class StandOutWindow extends Service {
 
     /**
      * Internal touch handler for handling moving the window.
-     * 
-     * @see {@link View#onTouchEvent(MotionEvent)}
+     *
      * @param id
      * @param window
      * @param view
      * @param event
      * @return
+     * @see {@link View#onTouchEvent(MotionEvent)}
      */
     public boolean onTouchHandleMove(int id, Window window, View view, MotionEvent event) {
         StandOutLayoutParams params = window.getLayoutParams();
@@ -1361,18 +1342,18 @@ public abstract class StandOutWindow extends Service {
 
         switch (event.getAction()) {
             case MotionEvent.ACTION_DOWN:
-                window.touchInfo.lastX = (int)event.getRawX();
-                window.touchInfo.lastY = (int)event.getRawY();
+                window.touchInfo.lastX = (int) event.getRawX();
+                window.touchInfo.lastY = (int) event.getRawY();
 
                 window.touchInfo.firstX = window.touchInfo.lastX;
                 window.touchInfo.firstY = window.touchInfo.lastY;
                 break;
             case MotionEvent.ACTION_MOVE:
-                int deltaX = (int)event.getRawX() - window.touchInfo.lastX;
-                int deltaY = (int)event.getRawY() - window.touchInfo.lastY;
+                int deltaX = (int) event.getRawX() - window.touchInfo.lastX;
+                int deltaY = (int) event.getRawY() - window.touchInfo.lastY;
 
-                window.touchInfo.lastX = (int)event.getRawX();
-                window.touchInfo.lastY = (int)event.getRawY();
+                window.touchInfo.lastX = (int) event.getRawX();
+                window.touchInfo.lastY = (int) event.getRawY();
 
                 if (window.touchInfo.moving || Math.abs(totalDeltaX) >= params.threshold
                         || Math.abs(totalDeltaY) >= params.threshold) {
@@ -1418,28 +1399,28 @@ public abstract class StandOutWindow extends Service {
 
     /**
      * Internal touch handler for handling resizing the window.
-     * 
-     * @see {@link View#onTouchEvent(MotionEvent)}
+     *
      * @param id
      * @param window
      * @param view
      * @param event
      * @return
+     * @see {@link View#onTouchEvent(MotionEvent)}
      */
     public boolean onTouchHandleResize(int id, Window window, View view, MotionEvent event) {
-        StandOutLayoutParams params = (StandOutLayoutParams)window.getLayoutParams();
+        StandOutLayoutParams params = (StandOutLayoutParams) window.getLayoutParams();
 
         switch (event.getAction()) {
             case MotionEvent.ACTION_DOWN:
-                window.touchInfo.lastX = (int)event.getRawX();
-                window.touchInfo.lastY = (int)event.getRawY();
+                window.touchInfo.lastX = (int) event.getRawX();
+                window.touchInfo.lastY = (int) event.getRawY();
 
                 window.touchInfo.firstX = window.touchInfo.lastX;
                 window.touchInfo.firstY = window.touchInfo.lastY;
                 break;
             case MotionEvent.ACTION_MOVE:
-                int deltaX = (int)event.getRawX() - window.touchInfo.lastX;
-                int deltaY = (int)event.getRawY() - window.touchInfo.lastY;
+                int deltaX = (int) event.getRawX() - window.touchInfo.lastX;
+                int deltaY = (int) event.getRawY() - window.touchInfo.lastY;
 
                 // update the size of the window
                 params.width += deltaX;
@@ -1447,11 +1428,11 @@ public abstract class StandOutWindow extends Service {
 
                 // keep window between min/max width/height
                 if (params.width >= params.minWidth && params.width <= params.maxWidth) {
-                    window.touchInfo.lastX = (int)event.getRawX();
+                    window.touchInfo.lastX = (int) event.getRawX();
                 }
 
                 if (params.height >= params.minHeight && params.height <= params.maxHeight) {
-                    window.touchInfo.lastY = (int)event.getRawY();
+                    window.touchInfo.lastY = (int) event.getRawY();
                 }
 
                 window.edit().setSize(params.width, params.height).commit();
@@ -1471,7 +1452,7 @@ public abstract class StandOutWindow extends Service {
      * interact with each other, except for
      * {@link #sendData(Context, Class, int, int, Bundle, Class, int)}, this
      * method is private.
-     * 
+     *
      * @param window The window to unfocus.
      * @return True if focus changed successfully, false if it failed.
      */
@@ -1484,8 +1465,8 @@ public abstract class StandOutWindow extends Service {
 
     /**
      * Update the window corresponding to this id with the given params.
-     * 
-     * @param id The id of the window.
+     *
+     * @param id     The id of the window.
      * @param params The updated layout params to apply.
      */
     public void updateViewLayout(int id, StandOutLayoutParams params) {
@@ -1519,7 +1500,7 @@ public abstract class StandOutWindow extends Service {
 
     /**
      * LayoutParams specific to floating StandOut windows.
-     * 
+     *
      * @author Mark Wei <markwei@gmail.com>
      */
     public class StandOutLayoutParams extends WindowManager.LayoutParams {
@@ -1595,8 +1576,8 @@ public abstract class StandOutWindow extends Service {
 
         /**
          * @param id The id of the window.
-         * @param w The width of the window.
-         * @param h The height of the window.
+         * @param w  The width of the window.
+         * @param h  The height of the window.
          */
         public StandOutLayoutParams(int id, int w, int h) {
             this(id);
@@ -1605,9 +1586,9 @@ public abstract class StandOutWindow extends Service {
         }
 
         /**
-         * @param id The id of the window.
-         * @param w The width of the window.
-         * @param h The height of the window.
+         * @param id   The id of the window.
+         * @param w    The width of the window.
+         * @param h    The height of the window.
          * @param xpos The x position of the window.
          * @param ypos The y position of the window.
          */
@@ -1640,12 +1621,12 @@ public abstract class StandOutWindow extends Service {
         }
 
         /**
-         * @param id The id of the window.
-         * @param w The width of the window.
-         * @param h The height of the window.
-         * @param xpos The x position of the window.
-         * @param ypos The y position of the window.
-         * @param minWidth The minimum width of the window.
+         * @param id        The id of the window.
+         * @param w         The width of the window.
+         * @param h         The height of the window.
+         * @param xpos      The x position of the window.
+         * @param ypos      The y position of the window.
+         * @param minWidth  The minimum width of the window.
          * @param minHeight The mininum height of the window.
          */
         public StandOutLayoutParams(int id, int w, int h, int xpos, int ypos, int minWidth, int minHeight) {
@@ -1656,18 +1637,18 @@ public abstract class StandOutWindow extends Service {
         }
 
         /**
-         * @param id The id of the window.
-         * @param w The width of the window.
-         * @param h The height of the window.
-         * @param xpos The x position of the window.
-         * @param ypos The y position of the window.
-         * @param minWidth The minimum width of the window.
+         * @param id        The id of the window.
+         * @param w         The width of the window.
+         * @param h         The height of the window.
+         * @param xpos      The x position of the window.
+         * @param ypos      The y position of the window.
+         * @param minWidth  The minimum width of the window.
          * @param minHeight The mininum height of the window.
          * @param threshold The touch distance threshold that distinguishes a
-         *            tap from a drag.
+         *                  tap from a drag.
          */
         public StandOutLayoutParams(int id, int w, int h, int xpos, int ypos, int minWidth, int minHeight,
-                int threshold) {
+                                    int threshold) {
             this(id, w, h, xpos, ypos, minWidth, minHeight);
 
             this.threshold = threshold;
diff --git a/qDict/src/main/java/com/annie/dictionary/standout/TouchInfo.java b/qDict/src/main/java/com/annie/dictionary/standout/TouchInfo.java
index 3dbee67..250a7da 100644
--- a/qDict/src/main/java/com/annie/dictionary/standout/TouchInfo.java
+++ b/qDict/src/main/java/com/annie/dictionary/standout/TouchInfo.java
@@ -1,4 +1,3 @@
-
 package com.annie.dictionary.standout;
 
 import java.util.Locale;
@@ -6,7 +5,7 @@ import java.util.Locale;
 /**
  * This class holds temporal touch and gesture information. Mainly used to hold
  * temporary data for onTouchEvent(MotionEvent).
- * 
+ *
  * @author Mark Wei <markwei@gmail.com>
  */
 public class TouchInfo {
diff --git a/qDict/src/main/java/com/annie/dictionary/standout/Utils.java b/qDict/src/main/java/com/annie/dictionary/standout/Utils.java
index 9310440..8c3f4e2 100644
--- a/qDict/src/main/java/com/annie/dictionary/standout/Utils.java
+++ b/qDict/src/main/java/com/annie/dictionary/standout/Utils.java
@@ -1,4 +1,3 @@
-
 package com.annie.dictionary.standout;
 
 public class Utils {
diff --git a/qDict/src/main/java/com/annie/dictionary/standout/Window.java b/qDict/src/main/java/com/annie/dictionary/standout/Window.java
index b875443..fbf7630 100644
--- a/qDict/src/main/java/com/annie/dictionary/standout/Window.java
+++ b/qDict/src/main/java/com/annie/dictionary/standout/Window.java
@@ -1,12 +1,5 @@
-
 package com.annie.dictionary.standout;
 
-import java.util.LinkedList;
-import java.util.Queue;
-
-import com.annie.dictionary.R;
-import com.annie.dictionary.standout.StandOutWindow.StandOutLayoutParams;
-
 import android.content.Context;
 import android.os.Bundle;
 import android.text.TextUtils;
@@ -23,6 +16,12 @@ import android.widget.FrameLayout;
 import android.widget.ImageView;
 import android.widget.PopupWindow;
 
+import com.annie.dictionary.R;
+import com.annie.dictionary.standout.StandOutWindow.StandOutLayoutParams;
+
+import java.util.LinkedList;
+import java.util.Queue;
+
 /**
  * Special view that represents a floating window.
  */
@@ -34,60 +33,65 @@ public class Window extends FrameLayout {
     public static final int VISIBILITY_TRANSITION = 2;
 
     static final String TAG = "Window";
-
+    /**
+     * Context of the window.
+     */
+    private final StandOutWindow mContext;
     /**
      * Class of the window, indicating which application the window belongs to.
      */
     public Class<? extends StandOutWindow> cls;
-
     /**
      * Id of the window.
      */
     public int id;
-
     /**
      * Whether the window is shown, hidden/closed, or in transition.
      */
     public int visibility;
-
     /**
      * Whether the window is focused.
      */
     public boolean focused;
-
     /**
      * Original params from {@link StandOutWindow#getParams(int, Window)}.
      */
     public StandOutLayoutParams originalParams;
-
     public EditText searchEdt;
-
     /**
      * Original flags from {@link StandOutWindow#getFlags(int)}.
      */
     public int flags;
-
     /**
      * Touch information of the window.
      */
     public TouchInfo touchInfo;
-
     /**
      * Data attached to the window.
      */
     public Bundle data;
-
     /**
      * Width and height of the screen.
      */
     int displayWidth, displayHeight;
+    private LayoutInflater mLayoutInflater;
+    private OnTouchListener mTouch = new OnTouchListener() {
 
-    /**
-     * Context of the window.
-     */
-    private final StandOutWindow mContext;
+        @Override
+        public boolean onTouch(View v, MotionEvent event) {
+            // pass all touch events to the implementation
+            boolean consumed = false;
 
-    private LayoutInflater mLayoutInflater;
+            // handle move and bring to front
+            consumed = mContext.onTouchHandleMove(id, Window.this, v, event) || consumed;
+
+            // alert implementation
+            // consumed = mContext.onTouchBody(id, Window.this, v, event)
+            // || consumed;
+
+            return consumed;
+        }
+    };
 
     public Window(Context context) {
         super(context);
@@ -106,11 +110,11 @@ public class Window extends FrameLayout {
         this.originalParams = context.getParams(id, this);
         this.flags = context.getFlags(id);
         this.touchInfo = new TouchInfo();
-        touchInfo.ratio = (float)originalParams.width / originalParams.height;
+        touchInfo.ratio = (float) originalParams.width / originalParams.height;
         this.data = new Bundle();
         DisplayMetrics metrics = mContext.getResources().getDisplayMetrics();
         displayWidth = metrics.widthPixels;
-        displayHeight = (int)(metrics.heightPixels - 25 * metrics.density);
+        displayHeight = (int) (metrics.heightPixels - 25 * metrics.density);
 
         // create the window contents
         View content;
@@ -119,12 +123,12 @@ public class Window extends FrameLayout {
         if (Utils.isSet(flags, StandOutFlags.FLAG_DECORATION_SYSTEM)) {
             // requested system window decorations
             content = getSystemDecorations();
-            body = (FrameLayout)content.findViewById(R.id.body);
+            body = (FrameLayout) content.findViewById(R.id.body);
         } else {
             // did not request decorations. will provide own implementation
             content = new FrameLayout(context);
             content.setId(R.id.content);
-            body = (FrameLayout)content;
+            body = (FrameLayout) content;
         }
 
         addView(content);
@@ -177,24 +181,6 @@ public class Window extends FrameLayout {
         return false;
     }
 
-    private OnTouchListener mTouch = new OnTouchListener() {
-
-        @Override
-        public boolean onTouch(View v, MotionEvent event) {
-            // pass all touch events to the implementation
-            boolean consumed = false;
-
-            // handle move and bring to front
-            consumed = mContext.onTouchHandleMove(id, Window.this, v, event) || consumed;
-
-            // alert implementation
-            // consumed = mContext.onTouchBody(id, Window.this, v, event)
-            // || consumed;
-
-            return consumed;
-        }
-    };
-
     @Override
     public boolean onTouchEvent(MotionEvent event) {
         // handle touching outside
@@ -229,8 +215,8 @@ public class Window extends FrameLayout {
                     touchInfo.dist = dist;
 
                     // scale the window with anchor point set to middle
-                    edit().setAnchorPoint(.5f, .5f).setSize((int)(touchInfo.firstWidth * touchInfo.scale),
-                            (int)(touchInfo.firstHeight * touchInfo.scale)).commit();
+                    edit().setAnchorPoint(.5f, .5f).setSize((int) (touchInfo.firstWidth * touchInfo.scale),
+                            (int) (touchInfo.firstHeight * touchInfo.scale)).commit();
                     break;
             }
             mContext.onResize(id, this, this, event);
@@ -259,7 +245,7 @@ public class Window extends FrameLayout {
 
     /**
      * Request or remove the focus from this window.
-     * 
+     *
      * @param focus Whether we want to gain or lose focus.
      * @return True if focus changed successfully, false if it failed.
      */
@@ -319,21 +305,11 @@ public class Window extends FrameLayout {
         return false;
     }
 
-    @Override
-    public void setLayoutParams(ViewGroup.LayoutParams params) {
-        if (params instanceof StandOutLayoutParams) {
-            super.setLayoutParams(params);
-        } else {
-            throw new IllegalArgumentException(
-                    "Window" + id + ": LayoutParams must be an instance of StandOutLayoutParams.");
-        }
-    }
-
     /**
      * Convenience method to start editting the size and position of this
      * window. Make sure you call {@link Editor#commit()} when you are done to
      * update the window.
-     * 
+     *
      * @return The Editor associated with this window.
      */
     public Editor edit() {
@@ -342,27 +318,37 @@ public class Window extends FrameLayout {
 
     @Override
     public StandOutLayoutParams getLayoutParams() {
-        StandOutLayoutParams params = (StandOutLayoutParams)super.getLayoutParams();
+        StandOutLayoutParams params = (StandOutLayoutParams) super.getLayoutParams();
         if (params == null) {
             params = originalParams;
         }
         return params;
     }
 
+    @Override
+    public void setLayoutParams(ViewGroup.LayoutParams params) {
+        if (params instanceof StandOutLayoutParams) {
+            super.setLayoutParams(params);
+        } else {
+            throw new IllegalArgumentException(
+                    "Window" + id + ": LayoutParams must be an instance of StandOutLayoutParams.");
+        }
+    }
+
     /**
      * Returns the system window decorations if the implementation sets
      * {@link #FLAG_DECORATION_SYSTEM}.
-     * <p>
+     * <p/>
      * The system window decorations support hiding, closing, moving, and
      * resizing.
-     * 
+     *
      * @return The frame view containing the system window decorations.
      */
     private View getSystemDecorations() {
         final View decorations = mLayoutInflater.inflate(R.layout.system_window_decorators, null);
 
         // icon
-        final ImageView icon = (ImageView)decorations.findViewById(R.id.menu_icon);
+        final ImageView icon = (ImageView) decorations.findViewById(R.id.menu_icon);
         icon.setOnClickListener(new OnClickListener() {
 
             @Override
@@ -375,7 +361,7 @@ public class Window extends FrameLayout {
         });
         icon.setVisibility(View.GONE);
         // search
-        searchEdt = (EditText)decorations.findViewById(R.id.search_edt);
+        searchEdt = (EditText) decorations.findViewById(R.id.search_edt);
         searchEdt.setOnKeyListener(new View.OnKeyListener() {
 
             @Override
@@ -449,7 +435,7 @@ public class Window extends FrameLayout {
         });
 
         // resize
-        ImageView corner = (ImageView)decorations.findViewById(R.id.corner);
+        ImageView corner = (ImageView) decorations.findViewById(R.id.corner);
         corner.setOnTouchListener(new OnTouchListener() {
 
             @Override
@@ -494,12 +480,12 @@ public class Window extends FrameLayout {
 
     /**
      * Implement StandOut specific additional functionalities.
-     * <p>
+     * <p/>
      * Currently, this method does the following:
-     * <p>
+     * <p/>
      * Attach resize handles: For every View found to have id R.id.corner,
      * attach an OnTouchListener that implements resizing the window.
-     * 
+     *
      * @param root The view hierarchy that is part of the window.
      */
     void addFunctionality(View root) {
@@ -541,11 +527,11 @@ public class Window extends FrameLayout {
     /**
      * Iterate through each View in the view hiearchy and implement StandOut
      * specific compatibility workarounds.
-     * <p>
+     * <p/>
      * Currently, this method does the following:
-     * <p>
+     * <p/>
      * Nothing yet.
-     * 
+     *
      * @param root The root view hierarchy to iterate through and check.
      */
     void fixCompatibility(View root) {
@@ -558,7 +544,7 @@ public class Window extends FrameLayout {
 
             // iterate through children
             if (view instanceof ViewGroup) {
-                ViewGroup group = (ViewGroup)view;
+                ViewGroup group = (ViewGroup) view;
                 for (int i = 0; i < group.getChildCount(); i++) {
                     queue.add(group.getChildAt(i));
                 }
@@ -566,10 +552,22 @@ public class Window extends FrameLayout {
         }
     }
 
+    public static class WindowDataKeys {
+        public static final String IS_MAXIMIZED = "isMaximized";
+
+        public static final String WIDTH_BEFORE_MAXIMIZE = "widthBeforeMaximize";
+
+        public static final String HEIGHT_BEFORE_MAXIMIZE = "heightBeforeMaximize";
+
+        public static final String X_BEFORE_MAXIMIZE = "xBeforeMaximize";
+
+        public static final String Y_BEFORE_MAXIMIZE = "yBeforeMaximize";
+    }
+
     /**
      * Convenient way to resize or reposition a Window. The Editor allows you to
      * easily resize and reposition the window around anchor points.
-     * 
+     *
      * @author Mark Wei <markwei@gmail.com>
      */
     public class Editor {
@@ -587,13 +585,13 @@ public class Window extends FrameLayout {
         /**
          * The position of the anchor point as a percentage of the window's
          * width/height. The anchor point is only used by the {@link Editor}.
-         * <p>
+         * <p/>
          * The anchor point effects the following methods:
-         * <p>
+         * <p/>
          * {@link #setSize(float, float)}, {@link #setSize(int, int)},
          * {@link #setPosition(int, int)}, {@link #setPosition(int, int)}. The
          * window will move, expand, or shrink around the anchor point.
-         * <p>
+         * <p/>
          * Values must be between 0 and 1, inclusive. 0 means the left/top, 0.5
          * is the center, 1 is the right/bottom.
          */
@@ -621,13 +619,13 @@ public class Window extends FrameLayout {
          * you've set a different anchor point with
          * {@link #setAnchorPoint(float, float)}. Changes will not applied until
          * you {@link #commit()}.
-         * 
+         *
          * @param percentWidth
          * @param percentHeight
          * @return The same Editor, useful for method chaining.
          */
         public Editor setSize(float percentWidth, float percentHeight) {
-            return setSize((int)(displayWidth * percentWidth), (int)(displayHeight * percentHeight));
+            return setSize((int) (displayWidth * percentWidth), (int) (displayHeight * percentHeight));
         }
 
         /**
@@ -635,7 +633,7 @@ public class Window extends FrameLayout {
          * expand and shrink around the top-left corner, unless you've set a
          * different anchor point with {@link #setAnchorPoint(float, float)}.
          * Changes will not applied until you {@link #commit()}.
-         * 
+         *
          * @param width
          * @param height
          * @return The same Editor, useful for method chaining.
@@ -649,11 +647,11 @@ public class Window extends FrameLayout {
          * expand and shrink around the top-left corner, unless you've set a
          * different anchor point with {@link #setAnchorPoint(float, float)}.
          * Changes will not applied until you {@link #commit()}.
-         * 
+         *
          * @param width
          * @param height
-         * @param skip Don't call {@link #setPosition(int, int)} to avoid stack
-         *            overflow.
+         * @param skip   Don't call {@link #setPosition(int, int)} to avoid stack
+         *               overflow.
          * @return The same Editor, useful for method chaining.
          */
         private Editor setSize(int width, int height, boolean skip) {
@@ -677,8 +675,8 @@ public class Window extends FrameLayout {
                 int maxHeight = mParams.maxHeight;
 
                 if (Utils.isSet(flags, StandOutFlags.FLAG_WINDOW_EDGE_LIMITS_ENABLE)) {
-                    maxWidth = (int)Math.min(maxWidth, displayWidth);
-                    maxHeight = (int)Math.min(maxHeight, displayHeight);
+                    maxWidth = (int) Math.min(maxWidth, displayWidth);
+                    maxHeight = (int) Math.min(maxHeight, displayHeight);
                 }
 
                 // keep window between min and max
@@ -687,8 +685,8 @@ public class Window extends FrameLayout {
 
                 // keep window in aspect ratio
                 if (Utils.isSet(flags, StandOutFlags.FLAG_WINDOW_ASPECT_RATIO_ENABLE)) {
-                    int ratioWidth = (int)(mParams.height * touchInfo.ratio);
-                    int ratioHeight = (int)(mParams.width / touchInfo.ratio);
+                    int ratioWidth = (int) (mParams.height * touchInfo.ratio);
+                    int ratioHeight = (int) (mParams.width / touchInfo.ratio);
                     if (ratioHeight >= mParams.minHeight && ratioHeight <= mParams.maxHeight) {
                         // width good adjust height
                         mParams.height = ratioHeight;
@@ -700,7 +698,7 @@ public class Window extends FrameLayout {
 
                 if (!skip) {
                     // set position based on anchor point
-                    setPosition((int)(mParams.x + lastWidth * anchorX), (int)(mParams.y + lastHeight * anchorY));
+                    setPosition((int) (mParams.x + lastWidth * anchorX), (int) (mParams.y + lastHeight * anchorY));
                 }
             }
 
@@ -713,13 +711,13 @@ public class Window extends FrameLayout {
          * unless you've set a different anchor point with
          * {@link #setAnchorPoint(float, float)}. Changes will not applied until
          * you {@link #commit()}.
-         * 
+         *
          * @param percentWidth
          * @param percentHeight
          * @return The same Editor, useful for method chaining.
          */
         public Editor setPosition(float percentWidth, float percentHeight) {
-            return setPosition((int)(displayWidth * percentWidth), (int)(displayHeight * percentHeight));
+            return setPosition((int) (displayWidth * percentWidth), (int) (displayHeight * percentHeight));
         }
 
         /**
@@ -728,7 +726,7 @@ public class Window extends FrameLayout {
          * you've set a different anchor point with
          * {@link #setAnchorPoint(float, float)}. Changes will not applied until
          * you {@link #commit()}.
-         * 
+         *
          * @param x
          * @param y
          * @return The same Editor, useful for method chaining.
@@ -743,11 +741,11 @@ public class Window extends FrameLayout {
          * you've set a different anchor point with
          * {@link #setAnchorPoint(float, float)}. Changes will not applied until
          * you {@link #commit()}.
-         * 
+         *
          * @param x
          * @param y
          * @param skip Don't call {@link #setPosition(int, int)} and
-         *            {@link #setSize(int, int)} to avoid stack overflow.
+         *             {@link #setSize(int, int)} to avoid stack overflow.
          * @return The same Editor, useful for method chaining.
          */
         private Editor setPosition(int x, int y, boolean skip) {
@@ -759,10 +757,10 @@ public class Window extends FrameLayout {
                 // sets the x and y correctly according to anchorX and
                 // anchorY
                 if (x != UNCHANGED) {
-                    mParams.x = (int)(x - mParams.width * anchorX);
+                    mParams.x = (int) (x - mParams.width * anchorX);
                 }
                 if (y != UNCHANGED) {
-                    mParams.y = (int)(y - mParams.height * anchorY);
+                    mParams.y = (int) (y - mParams.height * anchorY);
                 }
 
                 if (Utils.isSet(flags, StandOutFlags.FLAG_WINDOW_EDGE_LIMITS_ENABLE)) {
@@ -792,16 +790,4 @@ public class Window extends FrameLayout {
             }
         }
     }
-
-    public static class WindowDataKeys {
-        public static final String IS_MAXIMIZED = "isMaximized";
-
-        public static final String WIDTH_BEFORE_MAXIMIZE = "widthBeforeMaximize";
-
-        public static final String HEIGHT_BEFORE_MAXIMIZE = "heightBeforeMaximize";
-
-        public static final String X_BEFORE_MAXIMIZE = "xBeforeMaximize";
-
-        public static final String Y_BEFORE_MAXIMIZE = "yBeforeMaximize";
-    }
 }
diff --git a/qDict/src/main/java/com/annie/dictionary/standout/WindowCache.java b/qDict/src/main/java/com/annie/dictionary/standout/WindowCache.java
index 7e991cd..886c7dd 100644
--- a/qDict/src/main/java/com/annie/dictionary/standout/WindowCache.java
+++ b/qDict/src/main/java/com/annie/dictionary/standout/WindowCache.java
@@ -1,13 +1,12 @@
-
 package com.annie.dictionary.standout;
 
+import android.util.SparseArray;
+
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 
-import android.util.SparseArray;
-
 public class WindowCache {
     public Map<Class<? extends StandOutWindow>, SparseArray<Window>> sWindows;
 
@@ -18,11 +17,11 @@ public class WindowCache {
     /**
      * Returns whether the window corresponding to the class and id exists in
      * the {@link #sWindows} cache.
-     * 
-     * @param id The id representing the window.
+     *
+     * @param id  The id representing the window.
      * @param cls Class corresponding to the window.
      * @return True if the window corresponding to the class and id exists in
-     *         the cache, or false if it does not exist.
+     * the cache, or false if it does not exist.
      */
     public boolean isCached(int id, Class<? extends StandOutWindow> cls) {
         return getCache(id, cls) != null;
@@ -31,11 +30,11 @@ public class WindowCache {
     /**
      * Returns the window corresponding to the id from the {@link #sWindows}
      * cache.
-     * 
-     * @param id The id representing the window.
+     *
+     * @param id  The id representing the window.
      * @param cls The class of the implementation of the window.
      * @return The window corresponding to the id if it exists in the cache, or
-     *         null if it does not.
+     * null if it does not.
      */
     public Window getCache(int id, Class<? extends StandOutWindow> cls) {
         SparseArray<Window> l2 = sWindows.get(cls);
@@ -48,9 +47,9 @@ public class WindowCache {
 
     /**
      * Add the window corresponding to the id in the {@link #sWindows} cache.
-     * 
-     * @param id The id representing the window.
-     * @param cls The class of the implementation of the window.
+     *
+     * @param id     The id representing the window.
+     * @param cls    The class of the implementation of the window.
      * @param window The window to be put in the cache.
      */
     public void putCache(int id, Class<? extends StandOutWindow> cls, Window window) {
@@ -66,8 +65,8 @@ public class WindowCache {
     /**
      * Remove the window corresponding to the id from the {@link #sWindows}
      * cache.
-     * 
-     * @param id The id representing the window.
+     *
+     * @param id  The id representing the window.
      * @param cls The class of the implementation of the window.
      */
     public void removeCache(int id, Class<? extends StandOutWindow> cls) {
@@ -82,10 +81,10 @@ public class WindowCache {
 
     /**
      * Returns the size of the {@link #sWindows} cache.
-     * 
-     * @return True if the cache corresponding to this class is empty, false if
-     *         it is not empty.
+     *
      * @param cls The class of the implementation of the window.
+     * @return True if the cache corresponding to this class is empty, false if
+     * it is not empty.
      */
     public int getCacheSize(Class<? extends StandOutWindow> cls) {
         SparseArray<Window> l2 = sWindows.get(cls);
@@ -98,7 +97,7 @@ public class WindowCache {
 
     /**
      * Returns the ids in the {@link #sWindows} cache.
-     * 
+     *
      * @param cls The class of the implementation of the window.
      * @return The ids representing the cached windows.
      */
diff --git a/qDict/src/main/java/com/annie/dictionary/utils/Utils.java b/qDict/src/main/java/com/annie/dictionary/utils/Utils.java
index a98f370..fe842cf 100644
--- a/qDict/src/main/java/com/annie/dictionary/utils/Utils.java
+++ b/qDict/src/main/java/com/annie/dictionary/utils/Utils.java
@@ -1,175 +1,43 @@
-
 package com.annie.dictionary.utils;
 
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.math.BigDecimal;
-import java.util.Locale;
-import java.util.UUID;
-
-import com.annie.dictionary.R;
-
 import android.app.Activity;
 import android.app.AlertDialog;
 import android.app.Dialog;
-import android.app.Service;
 import android.content.Context;
 import android.content.DialogInterface;
 import android.content.Intent;
+import android.content.SharedPreferences;
 import android.content.pm.PackageManager;
 import android.content.res.Configuration;
 import android.content.res.Resources;
 import android.content.res.TypedArray;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
 import android.graphics.Color;
 import android.graphics.Typeface;
 import android.graphics.drawable.Drawable;
 import android.net.Uri;
 import android.os.Build;
 import android.os.Environment;
-import android.os.StatFs;
 import android.text.TextUtils;
 import android.util.Log;
 import android.view.LayoutInflater;
 import android.webkit.WebSettings;
 
+import com.annie.dictionary.R;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.util.Locale;
+
 public class Utils {
+    public static final int ORANGE_500 = Color.parseColor("#ff9800");
     private static final String TAG = "Utils";
-
-    private static String[] LANGUAGE_SUPPORTS = new String[] {
+    private static final String MADMAN_FB_ID = "419249474927176";
+    private static String[] LANGUAGE_SUPPORTS = new String[]{
             "en", "es", "vi", "zh"
     };
 
-    /**
-     * const::control navigation
-     * 
-     * @author madman
-     */
-    public interface NAVIG {
-        public static final int HOME = 0;
-
-        public static final int RECENT = 1;
-
-        public static final int FAVORITE = 2;
-
-        public static final int SELECT_DICT = 3;
-
-        public static final int SETTINGS = 4;
-
-        public static final int JOIN_US = 5;
-
-        public static final int SEARCH = 6;
-
-    }
-
-    /**
-     * const::control receiver values
-     * 
-     * @author madman
-     */
-    public interface RECV_UI {
-        public static final int CHANGE_THEME = 1001;
-
-        public static final int SELECT_DICT = 1003;
-
-        public static final int SEARCH_WORD = 1005;
-
-        public static final int RELOAD_DICT = 1007;
-
-        public static final int RUN_SERVICE = 1009;
-
-        public static final int CHANGE_FONT = 1011;
-
-        public static final int CHANGE_FRAG = 1013;
-    }
-
-    /**
-     * const::dialog Id
-     * 
-     * @author madman
-     */
-    public interface DIALOG {
-        public static final int ABOUT = 1011;
-
-        public static final int CHANGE_LOG = 1013;
-
-        public static final int RATE = 1015;
-    }
-
-    /**
-     * const:: qdict
-     * 
-     * @author madman
-     */
-    public interface Def {
-
-        public static final String APP_NAME = "QDict";
-
-        // key preference
-        public static final String PREF_INDEX_CHECKED = "prefs_key_index_checked";
-
-        public static final String PREF_INDEX_ALL = "prefs_key_index_all";
-
-        public static final String PREF_KEY_FONT = "prefs_key_font_text";
-
-        public static final String PREF_KEY_COLOR_TEXT = "prefs_key_color_text";
-
-        public static final String PREF_KEY_COLOR_WORD = "prefs_key_color_word";
-
-        public static final String PREF_KEY_COLOR_BACKGROUND = "prefs_key_color_background";
-
-        public static final String DICT_FOLDER = "/dicts";
-
-        // max count -- max item in wordlist history
-        public final int MAX_COUNT = 99;
-
-        // max speak char == max characters when text-to-speech
-        public final int MAX_SPEAK_CHAR = 100;
-
-        // limit character using google translate free
-        public final int LIMIT_TRANSLATE_CHAR = 256;
-
-        // word list type
-        public static final int TYPE_RECENTWORDS = 101;
-
-        public static final int TYPE_FAVORITEWORDS = 103;
-
-        public final static String WORDSLIST_FOLDER = "hiswords/";
-
-        public final static String FAVORITEWORDS_FILENAME = "favoritewords.qdc";
-
-        public final static String RECENTWORDS_FILENAME = "recentwords.qdc";
-
-        // mime
-        public static final String MIME_TYPE = "text/html";
-
-        public static final String HTML_ENCODING = "UTF-8";
-
-        public static final String BWORD_URL = "bword://";
-
-        public static final String HTTP_URL = "http://";
-
-        public static final String HTTPS_URL = "https://";
-
-        // for service
-        public static final int CLIPBOARD_TIMER = 1500;
-
-        public static final String DEFAULT_TEXT_COLOR = "#FF000000";
-
-        public static final String DEFAULT_WORD_COLOR = "#FF002DFF";
-
-        public static final String DEFAULT_FONT = "Roboto.ttf";
-    }
-
-    private static final long LOW_STORAGE_THRESHOLD = 1024 * 1024 * 10;
-
-    public static final int ORANGE_500 = Color.parseColor("#ff9800");
-
     private Utils() {
     }
 
@@ -179,28 +47,52 @@ public class Utils {
 
     // -----------------------------------------------------------------------------------------------------//
     // Public static class
-
-    public static String getRootFolder() {
-        File SDCardFolder = null;
-        boolean SDCardExist = Environment.getExternalStorageState().equals(android.os.Environment.MEDIA_MOUNTED);
+    public static String getSDCardPath() {
+        boolean SDCardExist = Environment.getExternalStorageState().equals(
+                android.os.Environment.MEDIA_MOUNTED);
         if (SDCardExist) {
-            SDCardFolder = Environment.getExternalStorageDirectory();
-            String root = SDCardFolder.toString() + "/" + Def.APP_NAME;
-            return root;
+            File SDCardFolder = Environment.getExternalStorageDirectory();
+            File parent = SDCardFolder.getParentFile();
+            if (parent.canRead())
+                return SDCardFolder.getParent();
+            else
+                return SDCardFolder.toString();
         }
         return null;
     }
 
+    public static String getRootDictFolder(SharedPreferences shares) {
+        String root = shares.getString(Def.PREF_DATA_SOURCE, "");
+        File rootFile = new File(root);
+        if (TextUtils.isEmpty(root) || !rootFile.canRead()) {
+            boolean SDCardExist = Environment.getExternalStorageState().equals(android.os.Environment.MEDIA_MOUNTED);
+            if (SDCardExist) {
+                File SDCardFolder = Environment.getExternalStorageDirectory();
+                root = SDCardFolder.toString() + "/" + Def.APP_NAME;
+                shares.edit().putString(Def.PREF_DATA_SOURCE, root).apply();
+                return root;
+            } else {
+                return null;
+            }
+        } else {
+            return root;
+        }
+    }
+
+    public static void setRootDictFolder(SharedPreferences shares, String pathRootDict) {
+        shares.edit().putString(Def.PREF_DATA_SOURCE, pathRootDict).apply();
+    }
+
     public static String getFileInfoName(String dictFolderPath) {
         String dictName = null;
         File f = new File(dictFolderPath);
         if (!f.exists())
             return null;
         File[] files = f.listFiles();
-        for (int i = 0; i < files.length; i++) {
-            if (files[i].isFile()) {
-                if (files[i].getName().endsWith(".ifo")) {
-                    dictName = files[i].getName().replace(".ifo", "");
+        for (File file : files) {
+            if (file.isFile()) {
+                if (file.getName().endsWith(".ifo")) {
+                    dictName = file.getName().replace(".ifo", "");
                     break;
                 }
             }
@@ -208,42 +100,9 @@ public class Utils {
         return dictName;
     }
 
-    public static double roundDouble(double value, int scale, int roundingMode) {
-        BigDecimal bd = new BigDecimal(value);
-        bd = bd.setScale(scale, roundingMode);
-        double d = bd.doubleValue();
-        bd = null;
-        return d;
-    }
-
-    public static int argbToColor(String color) {
-        return Color.parseColor(color);
-    }
-
-    public static String colorToARGB(int color) {
-        String alpha = Integer.toHexString(Color.alpha(color));
-        String red = Integer.toHexString(Color.red(color));
-        String green = Integer.toHexString(Color.green(color));
-        String blue = Integer.toHexString(Color.blue(color));
-
-        if (alpha.length() == 1) {
-            alpha = "0" + alpha;
-        }
-        if (red.length() == 1) {
-            red = "0" + red;
-        }
-        if (green.length() == 1) {
-            green = "0" + green;
-        }
-        if (blue.length() == 1) {
-            blue = "0" + blue;
-        }
-        return "#" + alpha + red + green + blue;
-    }
-
     public static Dialog createAboutDialog(final Context context) {
         LayoutInflater inflater = LayoutInflater.from(context);
-        AlertDialog.Builder builder = null;
+        AlertDialog.Builder builder;
         if (Utils.hasHcAbove()) {
             builder = new AlertDialog.Builder(context, R.style.QDialog);
         } else {
@@ -268,7 +127,7 @@ public class Utils {
     }
 
     public static Dialog createWhatsNewDialog(Context context) {
-        AlertDialog.Builder builder = null;
+        AlertDialog.Builder builder;
         if (Utils.hasHcAbove()) {
             builder = new AlertDialog.Builder(context, R.style.QDialog);
         } else {
@@ -287,65 +146,18 @@ public class Utils {
 
     }
 
-    public static String getFileNameFromUrl(String url) {
-        int index = url.lastIndexOf('?');
-        String filename;
-        if (index > 1) {
-            filename = url.substring(url.lastIndexOf('/') + 1, index);
-        } else {
-            filename = url.substring(url.lastIndexOf('/') + 1);
-        }
-
-        if (filename == null || "".equals(filename.trim())) {
-            filename = UUID.randomUUID() + ".apk";//
-        }
-        return filename;
-    }
-
-    public static String getLocaleName(Context context, String name) {
-        String localeSuffix = getLocaleSuffix(context);
-        if (localeSuffix == null)
-            return name;
-        StringBuilder sb = new StringBuilder(name);
-        int lastDotIdx = name.lastIndexOf('.');
-        if (lastDotIdx > -1) {
-            sb.insert(lastDotIdx, localeSuffix);
-        } else {
-            sb.append(localeSuffix);
-        }
-        return sb.toString();
-
-    }
-
-    /**
-     * read txt
-     * 
-     * @param context
-     * @return null if current locale is not in [vi_VN, ja_JP]
-     */
-    private static String getLocaleSuffix(Context context) {
-        Locale locale = context.getResources().getConfiguration().locale;
-        String localeSuffix = null;
-        if (locale.equals(new Locale("vi", "VN"))) {
-            localeSuffix = "_vi_VN";
-        } else if (locale.equals(Locale.JAPAN)) {
-            localeSuffix = "_ja_JP";
-        }
-        return localeSuffix;
-    }
-
     public static CharSequence getTextFromAssets(Context context, String name) {
-        String filename = name;// getLocaleName(context, name);
         BufferedReader in = null;
         StringBuilder sb = new StringBuilder();
         try {
-            in = new BufferedReader(new InputStreamReader(context.getAssets().open(filename)));
+            in = new BufferedReader(new InputStreamReader(context.getAssets().open(name)));
             String line;
             while ((line = in.readLine()) != null) {
                 sb.append(line);
                 sb.append('\n');
             }
         } catch (IOException e) {
+            Log.e(TAG, e.toString());
         } finally {
             try {
                 if (in != null)
@@ -359,57 +171,11 @@ public class Utils {
 
     // SDcard
     public static boolean isSdCardWrittenable() {
-        if (android.os.Environment.getExternalStorageState().equals(android.os.Environment.MEDIA_MOUNTED)) {
-            return true;
-        }
-        return false;
-    }
-
-    @SuppressWarnings("deprecation")
-    public static long getAvailableStorage() {
-
-        String storageDirectory = null;
-        storageDirectory = Environment.getExternalStorageDirectory().toString();
-
-        try {
-            StatFs stat = new StatFs(storageDirectory);
-            long avaliableSize = ((long)stat.getAvailableBlocks() * (long)stat.getBlockSize());
-            Log.d(TAG, "getAvailableStorage. avaliableSize : " + avaliableSize);
-            return avaliableSize;
-        } catch (RuntimeException ex) {
-            Log.e(TAG, "getAvailableStorage - exception. return 0");
-            return 0;
-        }
-    }
-
-    public static boolean checkAvailableStorage() {
-        Log.d(TAG, "checkAvailableStorage E");
-
-        if (getAvailableStorage() < LOW_STORAGE_THRESHOLD) {
-            return false;
-        }
-
-        return true;
-    }
-
-    public static boolean isSDCardPresent() {
         return Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED);
     }
 
-    public static Bitmap getLoacalBitmap(String url) {
-        try {
-            FileInputStream fis = new FileInputStream(url);
-            return BitmapFactory.decodeStream(fis);
-        } catch (FileNotFoundException e) {
-            e.printStackTrace();
-            return null;
-        }
-    }
-
-    private static final String MADMAN_FB_ID = "419249474927176";
-
     public static Intent getOpenPageFBIntent(Context context) {
-        Intent intent = null;
+        Intent intent;
         try {
             context.getPackageManager().getPackageInfo("com.facebook.katana", 0);
             intent = new Intent(Intent.ACTION_VIEW, Uri.parse("fb://page/" + MADMAN_FB_ID));
@@ -420,27 +186,10 @@ public class Utils {
         return intent;
     }
 
-    // public static Intent getTwitterIntent(Context context) {
-    // Intent intent = null;
-    // try {
-    // // get the Twitter app if possible
-    // context.getPackageManager()
-    // .getPackageInfo("com.twitter.android", 0);
-    // intent = new Intent(Intent.ACTION_VIEW,
-    // Uri.parse("twitter://user?user_id=" + STAVIRA_TWITTER_ID));
-    // intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-    // } catch (Exception e) {
-    // // no Twitter app, revert to browser
-    // intent = new Intent(Intent.ACTION_VIEW,
-    // Uri.parse("https://twitter.com/staviravn"));
-    // }
-    // return intent;
-    // }
-
     /**
      * share data to any
-     * 
-     * @param context
+     *
+     * @param clz
      */
     public static Intent getIntentShareData(Class<?> clz) {
         Intent sendIntent = new Intent();
@@ -452,33 +201,10 @@ public class Utils {
         return sendIntent;
     }
 
-    public static Intent sendMailIntent(Context context, String sub) {
-        try {
-            Intent intent = new Intent(Intent.ACTION_SENDTO); // it's not
-                                                              // ACTION_SEND
-            intent.setType("text/plain");
-            intent.putExtra(Intent.EXTRA_SUBJECT, sub);
-            intent.putExtra(Intent.EXTRA_TEXT, "Your message here");
-            intent.setData(Uri.parse("mailto:" + context.getString(R.string.app_email))); // or
-                                                                                          // just
-            // "mailto:"
-            // for blank
-            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-            return intent;
-        } catch (Exception e) {
-            return null;
-        }
-    }
-
     /**
      * madman: move to app in play store
      */
 
-    public static Intent goToPlayStore(Class<?> clz) {
-        String url = clz.getPackage().getName();
-        return new Intent(Intent.ACTION_VIEW, Uri.parse("market://details?id=" + url));
-    }
-
     public static Intent goToFTPServer() {
         String appId = "com.m2t.ftpserver";
         return new Intent(Intent.ACTION_VIEW, Uri.parse("market://details?id=" + appId));
@@ -486,7 +212,7 @@ public class Utils {
 
     public static Intent goToFTPServerLink() {
         String appId = "com.m2t.ftpserver";
-        return new Intent(Intent.ACTION_VIEW, Uri.parse("https://play.google.com/store/apps/details?id=" + appId));
+        return new Intent(Intent.ACTION_VIEW, Uri.parse("market://details?id=" + appId));
     }
 
     public static Drawable getDrawable(Activity activity, int attrResId) {
@@ -518,29 +244,27 @@ public class Utils {
         activity.startActivity(new Intent(activity, activity.getClass()));
     }
 
-    public static void onActivityCreateSetTheme(Activity activity, int themeIndex, boolean home) {
+    public static void onActivityCreateSetTheme(Activity activity, int themeIndex, int themeActivity) {
         switch (themeIndex) {
             case 1:
-                activity.setTheme(home ? R.style.AppBlueLightTheme : R.style.AppBlueLightThemeWithActionBar);
+                if (themeActivity == ThemeActivity.HOME)
+                    activity.setTheme(R.style.AppBlueLightTheme);
+                else if (themeActivity == ThemeActivity.SETTING)
+                    activity.setTheme(R.style.AppBlueLightThemeWithActionBar);
+                else if (themeActivity == ThemeActivity.DIALOG)
+                    activity.setTheme(R.style.QDialog_Blue);
                 break;
             default:
-                activity.setTheme(home ? R.style.AppOrangeTheme : R.style.AppOrangeThemeWithActionBar);
+                if (themeActivity == ThemeActivity.HOME)
+                    activity.setTheme(R.style.AppOrangeTheme);
+                else if (themeActivity == ThemeActivity.SETTING)
+                    activity.setTheme(R.style.AppOrangeThemeWithActionBar);
+                else if (themeActivity == ThemeActivity.DIALOG)
+                    activity.setTheme(R.style.QDialog_Orange);
                 break;
         }
     }
 
-    public static void onServiceSetTheme(Service service, int themeIndex) {
-        switch (themeIndex) {
-            case 1:
-                service.setTheme(R.style.AppBlueLightTheme);
-                break;
-            default:
-                service.setTheme(R.style.AppOrangeTheme);
-                break;
-        }
-
-    }
-
     public static WebSettings.LayoutAlgorithm getLayoutAlgorithm(boolean isSingColumn) {
         if (!isSingColumn) {
             if (hasKkAbove()) {
@@ -621,7 +345,7 @@ public class Utils {
     }
 
     public static void changeLocale(Resources resources, String language, String country) {
-        Locale locale = null;
+        Locale locale;
         if (TextUtils.isEmpty(country)) {
             locale = new Locale(language);
         } else {
@@ -640,4 +364,88 @@ public class Utils {
         }
         return false;
     }
+
+    /**
+     * const::control navigation
+     *
+     * @author madman
+     */
+    public interface NAVIG {
+        int HOME = 0;
+        int RECENT = 1;
+        int FAVORITE = 2;
+        int SELECT_DICT = 3;
+        int SETTINGS = 4;
+        int JOIN_US = 5;
+        int SEARCH = 6;
+
+    }
+
+    /**
+     * const::control receiver values
+     *
+     * @author madman
+     */
+    public interface RECV_UI {
+        int CHANGE_THEME = 1001;
+        int SELECT_DICT = 1003;
+        int SEARCH_WORD = 1005;
+        int RELOAD_DICT = 1007;
+        int RUN_SERVICE = 1009;
+        int CHANGE_FONT = 1011;
+        int CHANGE_FRAG = 1013;
+    }
+
+    /**
+     * const::dialog Id
+     *
+     * @author madman
+     */
+    public interface DIALOG {
+        int ABOUT = 1011;
+        int CHANGE_LOG = 1013;
+    }
+
+    /**
+     * const:: qdict
+     *
+     * @author madman
+     */
+    public interface Def {
+
+        String APP_NAME = "QDict";
+        // key preference
+        String PREF_DATA_SOURCE = "prefs_key_source";
+        String PREF_INDEX_CHECKED = "prefs_key_index_checked";
+        String PREF_INDEX_ALL = "prefs_key_index_all";
+        String PREF_KEY_FONT = "prefs_key_font_text";
+        String DICT_FOLDER = "/dicts";
+        // max count -- max item in wordlist history
+        int MAX_COUNT = 99;
+        // limit character using google translate free
+        int LIMIT_TRANSLATE_CHAR = 256;
+        // word list type
+        int TYPE_RECENTWORDS = 101;
+        int TYPE_FAVORITEWORDS = 103;
+        String WORDSLIST_FOLDER = "hiswords/";
+        String FAVORITEWORDS_FILENAME = "favoritewords.qdc";
+        String RECENTWORDS_FILENAME = "recentwords.qdc";
+        // MIME
+        String MIME_TYPE = "text/html";
+        String HTML_ENCODING = "UTF-8";
+        String BWORD_URL = "bword://";
+        String HTTP_URL = "http://";
+        String HTTPS_URL = "https://";
+        // for service
+        int CLIPBOARD_TIMER = 1500;
+        String DEFAULT_TEXT_COLOR = "#FF000000";
+        String DEFAULT_WORD_COLOR = "#FF002DFF";
+        String DEFAULT_FONT = "Roboto.ttf";
+    }
+
+    public interface ThemeActivity {
+        int HOME = 0;
+        int SETTING = 1;
+        int DIALOG = 2;
+    }
 }
diff --git a/qDict/src/main/java/com/annie/dictionary/utils/WebViewClientCallback.java b/qDict/src/main/java/com/annie/dictionary/utils/WebViewClientCallback.java
index 0bfa368..45ba730 100644
--- a/qDict/src/main/java/com/annie/dictionary/utils/WebViewClientCallback.java
+++ b/qDict/src/main/java/com/annie/dictionary/utils/WebViewClientCallback.java
@@ -1,4 +1,3 @@
-
 package com.annie.dictionary.utils;
 
 public class WebViewClientCallback {
diff --git a/qDict/src/main/java/com/annie/dictionary/utils/WordsFileUtils.java b/qDict/src/main/java/com/annie/dictionary/utils/WordsFileUtils.java
index ec48825..4c6472e 100644
--- a/qDict/src/main/java/com/annie/dictionary/utils/WordsFileUtils.java
+++ b/qDict/src/main/java/com/annie/dictionary/utils/WordsFileUtils.java
@@ -1,6 +1,10 @@
-
 package com.annie.dictionary.utils;
 
+import android.content.SharedPreferences;
+import android.util.Log;
+
+import com.annie.dictionary.utils.Utils.Def;
+
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
@@ -10,53 +14,36 @@ import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.OutputStreamWriter;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Locale;
 
-import com.annie.dictionary.utils.Utils.Def;
-
-import android.content.SharedPreferences;
-
 public class WordsFileUtils {
 
+    SharedPreferences mShares;
+    int maxWords = Def.MAX_COUNT;
     private String mPath = null;
-
     private String mName = null;
-
     private boolean mChanged = false;
-
     private ArrayList<String> mWordsArrayList = null;
 
-    SharedPreferences mShares;
-
-    private int mTypeHis;
-
-    int maxWords = Def.MAX_COUNT;
-
     public WordsFileUtils(SharedPreferences shares, int typeHis) {
-        mPath = Utils.getRootFolder() + "/" + Def.WORDSLIST_FOLDER;
-        mTypeHis = typeHis;
-        if (mTypeHis == Def.TYPE_FAVORITEWORDS) {
+        mPath = Utils.getRootDictFolder(shares) + "/" + Def.WORDSLIST_FOLDER;
+        if (typeHis == Def.TYPE_FAVORITEWORDS) {
             mName = Def.FAVORITEWORDS_FILENAME;
             maxWords = shares.getInt("prefs_key_max_recent_word", 100);
-        } else if (mTypeHis == Def.TYPE_RECENTWORDS) {
+        } else if (typeHis == Def.TYPE_RECENTWORDS) {
             mName = Def.RECENTWORDS_FILENAME;
         }
         mChanged = false;
-        String[] wordsList = null;
+        String[] wordsList;
         mShares = shares;
         // String emptySet = "";
-        mWordsArrayList = new ArrayList<String>();
+        mWordsArrayList = new ArrayList<>();
         String data = read();
         if (null == data)
             return;
-
         wordsList = data.split(";");
-
-        if (null != wordsList) {
-            for (int i = 0; i < wordsList.length; i++) {
-                mWordsArrayList.add(wordsList[i]);
-            }
-        }
+        mWordsArrayList.addAll(Arrays.asList(wordsList));
     }
 
     public ArrayList<String> getArrayList() {
@@ -76,10 +63,7 @@ public class WordsFileUtils {
     }
 
     public boolean canBackSearch(int index) {
-        if (mWordsArrayList.isEmpty() || mWordsArrayList.size() <= 1) {
-            return false;
-        }
-        return (index < mWordsArrayList.size());
+        return (!(mWordsArrayList.isEmpty() || mWordsArrayList.size() <= 1) && (index < mWordsArrayList.size()));
     }
 
     public boolean contains(String word) {
@@ -88,11 +72,11 @@ public class WordsFileUtils {
 
     public void addWord(String word) {
         String newword = word.replace(";", "").toLowerCase(Locale.ENGLISH); // remove
-                                                                            // ';'
-                                                                            // if
-                                                                            // it
-                                                                            // exists
-                                                                            // in
+        // ';'
+        // if
+        // it
+        // exists
+        // in
         // the word.
         if (newword.length() <= 0) {
             return;
@@ -123,7 +107,7 @@ public class WordsFileUtils {
 
     public void removeAll() {
         mWordsArrayList.clear();
-        mWordsArrayList = new ArrayList<String>();
+        mWordsArrayList = new ArrayList<>();
         mChanged = true;
     }
 
@@ -135,7 +119,7 @@ public class WordsFileUtils {
         if (mDictIndexAll.isEmpty()) {
             return;
         }
-        if (cnt < 0 || false == mChanged) {
+        if (cnt < 0 || !mChanged) {
             return;
         }
 
@@ -144,7 +128,8 @@ public class WordsFileUtils {
 
         File folder = new File(mPath);
         if (!folder.exists()) {
-            folder.mkdirs();
+            if (!folder.mkdirs())
+                return;
         }
 
         for (int i = 0; i < cnt; i++) {
@@ -153,17 +138,20 @@ public class WordsFileUtils {
         try {
             File f = new File(mPath + mName);
             if (f.exists()) {
-                f.delete();
+                if (!f.delete())
+                    return;
             }
             writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(f)), 8192);
             writer.write(data);
             writer.flush();
         } catch (IOException e) {
+            Log.e("WordsFileUtils", e.toString());
         } finally {
             try {
                 if (writer != null)
                     writer.close();
             } catch (IOException e) {
+                Log.e("WordsFileUtils", e.toString());
             }
         }
     }
@@ -179,11 +167,13 @@ public class WordsFileUtils {
                 data = reader.readLine();
             }
         } catch (IOException e) {
+            Log.e("WordsFileUtils", e.toString());
         } finally {
             try {
                 if (reader != null)
                     reader.close();
             } catch (IOException e) {
+                Log.e("WordsFileUtils", e.toString());
             }
         }
         return data;
diff --git a/qDict/src/main/java/com/mmt/app/ActionBarListActivity.java b/qDict/src/main/java/com/mmt/app/ActionBarListActivity.java
index 2877a34..cd78256 100644
--- a/qDict/src/main/java/com/mmt/app/ActionBarListActivity.java
+++ b/qDict/src/main/java/com/mmt/app/ActionBarListActivity.java
@@ -1,4 +1,3 @@
-
 package com.mmt.app;
 
 import android.support.v7.app.ActionBarActivity;
@@ -12,21 +11,21 @@ public abstract class ActionBarListActivity extends ActionBarActivity {
 
     protected ListView getListView() {
         if (mListView == null) {
-            mListView = (ListView)findViewById(android.R.id.list);
+            mListView = (ListView) findViewById(android.R.id.list);
         }
         return mListView;
     }
 
-    protected void setListAdapter(ListAdapter adapter) {
-        getListView().setAdapter(adapter);
-    }
-
     protected ListAdapter getListAdapter() {
         ListAdapter adapter = getListView().getAdapter();
         if (adapter instanceof HeaderViewListAdapter) {
-            return ((HeaderViewListAdapter)adapter).getWrappedAdapter();
+            return ((HeaderViewListAdapter) adapter).getWrappedAdapter();
         } else {
             return adapter;
         }
     }
+
+    protected void setListAdapter(ListAdapter adapter) {
+        getListView().setAdapter(adapter);
+    }
 }
diff --git a/qDict/src/main/java/com/mmt/app/SlidingActivityBase.java b/qDict/src/main/java/com/mmt/app/SlidingActivityBase.java
index c22f927..fda7b1c 100644
--- a/qDict/src/main/java/com/mmt/app/SlidingActivityBase.java
+++ b/qDict/src/main/java/com/mmt/app/SlidingActivityBase.java
@@ -1,19 +1,18 @@
-
 package com.mmt.app;
 
-import com.mmt.widget.slidemenu.SlidingMenu;
-
 import android.view.View;
 import android.view.ViewGroup.LayoutParams;
 
+import com.mmt.widget.slidemenu.SlidingMenu;
+
 public interface SlidingActivityBase {
 
     /**
      * Set the behind view content to an explicit view. This view is placed
      * directly into the behind view 's view hierarchy. It can itself be a
      * complex view hierarchy.
-     * 
-     * @param view The desired content to display.
+     *
+     * @param view         The desired content to display.
      * @param layoutParams Layout parameters for the view.
      */
     public void setBehindContentView(View view, LayoutParams layoutParams);
@@ -26,7 +25,7 @@ public interface SlidingActivityBase {
      * view are set by default to MATCH_PARENT. To use your own layout
      * parameters, invoke setContentView(android.view.View,
      * android.view.ViewGroup.LayoutParams) instead.
-     * 
+     *
      * @param view The desired content to display.
      */
     public void setBehindContentView(View view);
@@ -34,14 +33,14 @@ public interface SlidingActivityBase {
     /**
      * Set the behind view content from a layout resource. The resource will be
      * inflated, adding all top-level views to the behind view.
-     * 
+     *
      * @param layoutResID Resource ID to be inflated.
      */
     public void setBehindContentView(int layoutResID);
 
     /**
      * Gets the SlidingMenu associated with this activity.
-     * 
+     *
      * @return the SlidingMenu associated with this activity.
      */
     public SlidingMenu getSlidingMenu();
@@ -70,10 +69,10 @@ public interface SlidingActivityBase {
     /**
      * Controls whether the ActionBar slides along with the above view when the
      * menu is opened, or if it stays in place.
-     * 
+     *
      * @param slidingActionBarEnabled True if you want the ActionBar to slide
-     *            along with the SlidingMenu, false if you want the ActionBar to
-     *            stay in place
+     *                                along with the SlidingMenu, false if you want the ActionBar to
+     *                                stay in place
      */
     public void setSlidingActionBarEnabled(boolean slidingActionBarEnabled);
 
diff --git a/qDict/src/main/java/com/mmt/app/SlidingActivityHelper.java b/qDict/src/main/java/com/mmt/app/SlidingActivityHelper.java
index e1cc995..b2e25e2 100644
--- a/qDict/src/main/java/com/mmt/app/SlidingActivityHelper.java
+++ b/qDict/src/main/java/com/mmt/app/SlidingActivityHelper.java
@@ -1,9 +1,5 @@
-
 package com.mmt.app;
 
-import com.annie.dictionary.R;
-import com.mmt.widget.slidemenu.SlidingMenu;
-
 import android.app.Activity;
 import android.os.Bundle;
 import android.os.Handler;
@@ -12,6 +8,9 @@ import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup.LayoutParams;
 
+import com.annie.dictionary.R;
+import com.mmt.widget.slidemenu.SlidingMenu;
+
 public class SlidingActivityHelper {
 
     private Activity mActivity;
@@ -30,7 +29,7 @@ public class SlidingActivityHelper {
 
     /**
      * Instantiates a new SlidingActivityHelper.
-     * 
+     *
      * @param activity the associated activity
      */
     public SlidingActivityHelper(Activity activity) {
@@ -40,17 +39,17 @@ public class SlidingActivityHelper {
     /**
      * Sets mSlidingMenu as a newly inflated SlidingMenu. Should be called
      * within the activitiy's onCreate()
-     * 
+     *
      * @param savedInstanceState the saved instance state (unused)
      */
     public void onCreate(Bundle savedInstanceState) {
-        mSlidingMenu = (SlidingMenu)LayoutInflater.from(mActivity).inflate(R.layout.slidingmenumain, null);
+        mSlidingMenu = (SlidingMenu) LayoutInflater.from(mActivity).inflate(R.layout.slidingmenumain, null);
     }
 
     /**
      * Further SlidingMenu initialization. Should be called within the
      * activitiy's onPostCreate()
-     * 
+     *
      * @param savedInstanceState the saved instance state (unused)
      */
     public void onPostCreate(Bundle savedInstanceState) {
@@ -91,10 +90,10 @@ public class SlidingActivityHelper {
     /**
      * Controls whether the ActionBar slides along with the above view when the
      * menu is opened, or if it stays in place.
-     * 
+     *
      * @param slidingActionBarEnabled True if you want the ActionBar to slide
-     *            along with the SlidingMenu, false if you want the ActionBar to
-     *            stay in place
+     *                                along with the SlidingMenu, false if you want the ActionBar to
+     *                                stay in place
      */
     public void setSlidingActionBarEnabled(boolean slidingActionBarEnabled) {
         if (mOnPostCreateCalled)
@@ -105,7 +104,7 @@ public class SlidingActivityHelper {
     /**
      * Finds a view that was identified by the id attribute from the XML that
      * was processed in onCreate(Bundle).
-     * 
+     *
      * @param id the resource id of the desired view
      * @return The view if found or null otherwise.
      */
@@ -124,7 +123,7 @@ public class SlidingActivityHelper {
      * killed so that the state can be restored in onCreate(Bundle) or
      * onRestoreInstanceState(Bundle) (the Bundle populated by this method will
      * be passed to both).
-     * 
+     *
      * @param outState Bundle in which to place your saved state.
      */
     public void onSaveInstanceState(Bundle outState) {
@@ -134,8 +133,8 @@ public class SlidingActivityHelper {
 
     /**
      * Register the above content view.
-     * 
-     * @param v the above content view to register
+     *
+     * @param v      the above content view to register
      * @param params LayoutParams for that view (unused)
      */
     public void registerAboveContentView(View v, LayoutParams params) {
@@ -151,7 +150,7 @@ public class SlidingActivityHelper {
      * set by default to MATCH_PARENT. To use your own layout parameters, invoke
      * setContentView(android.view.View, android.view.ViewGroup.LayoutParams)
      * instead.
-     * 
+     *
      * @param v The desired content to display.
      */
     public void setContentView(View v) {
@@ -163,8 +162,8 @@ public class SlidingActivityHelper {
      * Set the behind view content to an explicit view. This view is placed
      * directly into the behind view 's view hierarchy. It can itself be a
      * complex view hierarchy.
-     * 
-     * @param view The desired content to display.
+     *
+     * @param view         The desired content to display.
      * @param layoutParams Layout parameters for the view. (unused)
      */
     public void setBehindContentView(View view, LayoutParams layoutParams) {
@@ -174,7 +173,7 @@ public class SlidingActivityHelper {
 
     /**
      * Gets the SlidingMenu associated with this activity.
-     * 
+     *
      * @return the SlidingMenu associated with this activity.
      */
     public SlidingMenu getSlidingMenu() {
@@ -212,9 +211,9 @@ public class SlidingActivityHelper {
 
     /**
      * On key up.
-     * 
+     *
      * @param keyCode the key code
-     * @param event the event
+     * @param event   the event
      * @return true, if successful
      */
     public boolean onKeyUp(int keyCode, KeyEvent event) {
diff --git a/qDict/src/main/java/com/mmt/app/SlidingFragmentActivity.java b/qDict/src/main/java/com/mmt/app/SlidingFragmentActivity.java
index 49377d2..9c1ac08 100644
--- a/qDict/src/main/java/com/mmt/app/SlidingFragmentActivity.java
+++ b/qDict/src/main/java/com/mmt/app/SlidingFragmentActivity.java
@@ -1,14 +1,13 @@
-
 package com.mmt.app;
 
-import com.mmt.widget.slidemenu.SlidingMenu;
-
 import android.os.Bundle;
 import android.support.v7.app.ActionBarActivity;
 import android.view.KeyEvent;
 import android.view.View;
 import android.view.ViewGroup.LayoutParams;
 
+import com.mmt.widget.slidemenu.SlidingMenu;
+
 public abstract class SlidingFragmentActivity extends ActionBarActivity implements SlidingActivityBase {
 
     private SlidingActivityHelper mHelper;
diff --git a/qDict/src/main/java/com/mmt/app/SystemBarTintManager.java b/qDict/src/main/java/com/mmt/app/SystemBarTintManager.java
index 5c85fad..e1cdd61 100644
--- a/qDict/src/main/java/com/mmt/app/SystemBarTintManager.java
+++ b/qDict/src/main/java/com/mmt/app/SystemBarTintManager.java
@@ -1,4 +1,3 @@
-
 package com.mmt.app;
 /*
  * Copyright (C) 2013 readyState Software Ltd
@@ -16,8 +15,6 @@ package com.mmt.app;
  * limitations under the License.
  */
 
-import java.lang.reflect.Method;
-
 import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.app.Activity;
@@ -37,12 +34,20 @@ import android.view.Window;
 import android.view.WindowManager;
 import android.widget.FrameLayout.LayoutParams;
 
+import java.lang.reflect.Method;
+
 /**
  * Class to manage status and navigation bar tint effects when using KitKat
  * translucent system UI modes.
  */
 public class SystemBarTintManager {
 
+    /**
+     * The default system bar tint color value.
+     */
+    public static final int DEFAULT_TINT_COLOR = 0x99000000;
+    private static String sNavBarOverride;
+
     static {
         // Android allows a system property to override the presence of the
         // navigation bar.
@@ -54,20 +59,13 @@ public class SystemBarTintManager {
                 Class c = Class.forName("android.os.SystemProperties");
                 Method m = c.getDeclaredMethod("get", String.class);
                 m.setAccessible(true);
-                sNavBarOverride = (String)m.invoke(null, "qemu.hw.mainkeys");
+                sNavBarOverride = (String) m.invoke(null, "qemu.hw.mainkeys");
             } catch (Throwable e) {
                 sNavBarOverride = null;
             }
         }
     }
 
-    /**
-     * The default system bar tint color value.
-     */
-    public static final int DEFAULT_TINT_COLOR = 0x99000000;
-
-    private static String sNavBarOverride;
-
     private final SystemBarConfig mConfig;
 
     private boolean mStatusBarAvailable;
@@ -93,7 +91,7 @@ public class SystemBarTintManager {
     public SystemBarTintManager(Activity activity) {
 
         Window win = activity.getWindow();
-        ViewGroup decorViewGroup = (ViewGroup)win.getDecorView();
+        ViewGroup decorViewGroup = (ViewGroup) win.getDecorView();
 
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
             // check theme attrs
@@ -135,20 +133,6 @@ public class SystemBarTintManager {
 
     }
 
-    /**
-     * Enable tinting of the system status bar. If the platform is running Jelly
-     * Bean or earlier, or translucent system UI modes have not been enabled in
-     * either the theme or via window flags, then this method does nothing.
-     *
-     * @param enabled True to enable tinting, false to disable it (default).
-     */
-    public void setStatusBarTintEnabled(boolean enabled) {
-        mStatusBarTintEnabled = enabled;
-        if (mStatusBarAvailable) {
-            mStatusBarTintView.setVisibility(enabled ? View.VISIBLE : View.GONE);
-        }
-    }
-
     /**
      * Enable tinting of the system navigation bar. If the platform does not
      * have soft navigation keys, is running Jelly Bean or earlier, or
@@ -188,7 +172,7 @@ public class SystemBarTintManager {
      * Apply the specified drawable to all system UI bars.
      *
      * @param drawable The drawable to use as the background, or null to remove
-     *            it.
+     *                 it.
      */
     public void setTintDrawable(Drawable drawable) {
         setStatusBarTintDrawable(drawable);
@@ -231,7 +215,7 @@ public class SystemBarTintManager {
      * Apply the specified drawable to the system status bar.
      *
      * @param drawable The drawable to use as the background, or null to remove
-     *            it.
+     *                 it.
      */
     @SuppressWarnings("deprecation")
     public void setStatusBarTintDrawable(Drawable drawable) {
@@ -279,7 +263,7 @@ public class SystemBarTintManager {
      * Apply the specified drawable to the system navigation bar.
      *
      * @param drawable The drawable to use as the background, or null to remove
-     *            it.
+     *                 it.
      */
     @SuppressWarnings("deprecation")
     public void setNavigationBarTintDrawable(Drawable drawable) {
@@ -304,7 +288,7 @@ public class SystemBarTintManager {
      * Get the system bar configuration.
      *
      * @return The system bar configuration for the current device
-     *         configuration.
+     * configuration.
      */
     public SystemBarConfig getConfig() {
         return mConfig;
@@ -319,6 +303,20 @@ public class SystemBarTintManager {
         return mStatusBarTintEnabled;
     }
 
+    /**
+     * Enable tinting of the system status bar. If the platform is running Jelly
+     * Bean or earlier, or translucent system UI modes have not been enabled in
+     * either the theme or via window flags, then this method does nothing.
+     *
+     * @param enabled True to enable tinting, false to disable it (default).
+     */
+    public void setStatusBarTintEnabled(boolean enabled) {
+        mStatusBarTintEnabled = enabled;
+        if (mStatusBarAvailable) {
+            mStatusBarTintView.setVisibility(enabled ? View.VISIBLE : View.GONE);
+        }
+    }
+
     /**
      * Is tinting enabled for the system navigation bar?
      *
@@ -492,7 +490,7 @@ public class SystemBarTintManager {
          * right side of the screen in certain configurations.
          *
          * @return True if navigation should appear at the bottom of the screen,
-         *         False otherwise.
+         * False otherwise.
          */
         public boolean isNavigationAtBottom() {
             return (mSmallestWidthDp >= 600 || mInPortrait);
@@ -520,7 +518,7 @@ public class SystemBarTintManager {
          * Does this device have a system navigation bar?
          *
          * @return True if this device uses soft key navigation, False
-         *         otherwise.
+         * otherwise.
          */
         public boolean hasNavigtionBar() {
             return mHasNavigationBar;
@@ -530,8 +528,8 @@ public class SystemBarTintManager {
          * Get the height of the system navigation bar.
          *
          * @return The height of the navigation bar (in pixels). If the device
-         *         does not have soft navigation keys, this will always return
-         *         0.
+         * does not have soft navigation keys, this will always return
+         * 0.
          */
         public int getNavigationBarHeight() {
             return mNavigationBarHeight;
@@ -542,8 +540,8 @@ public class SystemBarTintManager {
          * vertically on the screen.
          *
          * @return The width of the navigation bar (in pixels). If the device
-         *         does not have soft navigation keys, this will always return
-         *         0.
+         * does not have soft navigation keys, this will always return
+         * 0.
          */
         public int getNavigationBarWidth() {
             return mNavigationBarWidth;
@@ -554,7 +552,7 @@ public class SystemBarTintManager {
          * screen.
          *
          * @param withActionBar True to include the height of the action bar,
-         *            False otherwise.
+         *                      False otherwise.
          * @return The layout inset (in pixels).
          */
         public int getPixelInsetTop(boolean withActionBar) {
diff --git a/qDict/src/main/java/com/mmt/widget/CheckableLinearLayout.java b/qDict/src/main/java/com/mmt/widget/CheckableLinearLayout.java
index 1a6b201..fef4018 100644
--- a/qDict/src/main/java/com/mmt/widget/CheckableLinearLayout.java
+++ b/qDict/src/main/java/com/mmt/widget/CheckableLinearLayout.java
@@ -1,4 +1,3 @@
-
 package com.mmt.widget;
 
 import android.content.Context;
@@ -19,7 +18,7 @@ public class CheckableLinearLayout extends LinearLayout implements Checkable {
     @Override
     protected void onFinishInflate() {
         super.onFinishInflate();
-        child = (Checkable)getChildAt(CHECKABLE_CHILD_INDEX);
+        child = (Checkable) getChildAt(CHECKABLE_CHILD_INDEX);
     }
 
     @Override
diff --git a/qDict/src/main/java/com/mmt/widget/DragSortListView.java b/qDict/src/main/java/com/mmt/widget/DragSortListView.java
index 8b2715d..61fc981 100644
--- a/qDict/src/main/java/com/mmt/widget/DragSortListView.java
+++ b/qDict/src/main/java/com/mmt/widget/DragSortListView.java
@@ -21,17 +21,6 @@
 
 package com.mmt.widget;
 
-import java.io.File;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.util.ArrayList;
-
-import com.annie.dictionary.R;
-import com.mmt.widget.draglistview.DragSortController;
-import com.mmt.widget.draglistview.DragSortItemView;
-import com.mmt.widget.draglistview.DragSortItemViewCheckable;
-import com.mmt.widget.draglistview.SimpleFloatViewManager;
-
 import android.content.Context;
 import android.content.res.TypedArray;
 import android.database.DataSetObserver;
@@ -55,18 +44,74 @@ import android.widget.Checkable;
 import android.widget.ListAdapter;
 import android.widget.ListView;
 
+import com.annie.dictionary.R;
+import com.mmt.widget.draglistview.DragSortController;
+import com.mmt.widget.draglistview.DragSortItemView;
+import com.mmt.widget.draglistview.DragSortItemViewCheckable;
+import com.mmt.widget.draglistview.SimpleFloatViewManager;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.util.ArrayList;
+
 /**
  * ListView subclass that mediates drag and drop resorting of items.
- * 
+ *
  * @author heycosmo
  */
 public class DragSortListView extends ListView {
 
+    /**
+     * Drag flag bit. Floating View can move in the positive x direction.
+     */
+    public final static int DRAG_POS_X = 0x1;
+    /**
+     * Drag flag bit. Floating View can move in the negative x direction.
+     */
+    public final static int DRAG_NEG_X = 0x2;
+    /**
+     * Drag flag bit. Floating View can move in the positive y direction. This
+     * is subtle. What this actually means is that, if enabled, the floating
+     * View can be dragged below its starting position. Remove in favor of
+     * upper-bounding item position?
+     */
+    public final static int DRAG_POS_Y = 0x4;
+    /**
+     * Drag flag bit. Floating View can move in the negative y direction. This
+     * is subtle. What this actually means is that the floating View can be
+     * dragged above its starting position. Remove in favor of lower-bounding
+     * item position?
+     */
+    public final static int DRAG_NEG_Y = 0x8;
+    /**
+     * Drag state enum.
+     */
+    private final static int IDLE = 0;
+    private final static int REMOVING = 1;
+    private final static int DROPPING = 2;
+    private final static int STOPPED = 3;
+    private final static int DRAGGING = 4;
+    /**
+     * Enum telling where to cancel the ListView action when a drag-sort begins
+     */
+    private static final int NO_CANCEL = 0;
+    private static final int ON_TOUCH_EVENT = 1;
+    private static final int ON_INTERCEPT_TOUCH_EVENT = 2;
+    /**
+     * Caches DragSortItemView child heights. Sometimes DSLV has to know the
+     * height of an offscreen item. Since ListView virtualizes these, DSLV must
+     * get the item from the ListAdapter to obtain its height. That process can
+     * be expensive, but often the same offscreen item will be requested many
+     * times in a row. Once an offscreen item height is calculated, we cache it
+     * in this guy. Actually, we cache the height of the child of the
+     * DragSortItemView since the item height changes often during a drag-sort.
+     */
+    private static final int sCacheSize = 3;
     /**
      * The View that floats above the ListView and represents the dragged item.
      */
     private View mFloatView;
-
     /**
      * The float View location. First based on touch location and given deltaX
      * and deltaY. Then restricted by callback to
@@ -74,198 +119,161 @@ public class DragSortListView extends ListView {
      */
     private Point mFloatLoc = new Point();
 
-    private Point mTouchLoc = new Point();
+    /**
+     * The difference (in x) between screen coordinates and coordinates in this
+     * view.
+     */
+    // private int mOffsetX;
 
+    /**
+     * The difference (in y) between screen coordinates and coordinates in this
+     * view.
+     */
+    // private int mOffsetY;
+    private Point mTouchLoc = new Point();
     /**
      * The middle (in the y-direction) of the floating View.
      */
     private int mFloatViewMid;
-
     /**
      * Flag to make sure float View isn't measured twice
      */
     private boolean mFloatViewOnMeasured = false;
-
     /**
      * Watch the Adapter for data changes. Cancel a drag if coincident with a
      * change.
      */
     private DataSetObserver mObserver;
-
     /**
      * Transparency for the floating View (XML attribute).
      */
     private float mFloatAlpha = 1.0f;
-
     private float mCurrFloatAlpha = 1.0f;
-
     /**
      * While drag-sorting, the current position of the floating View. If
      * dropped, the dragged item will land in this position.
      */
     private int mFloatPos;
-
     /**
      * The first expanded ListView position that helps represent the drop slot
      * tracking the floating View.
      */
     private int mFirstExpPos;
-
     /**
      * The second expanded ListView position that helps represent the drop slot
      * tracking the floating View. This can equal mFirstExpPos if there is no
      * slide shuffle occurring; otherwise it is equal to mFirstExpPos + 1.
      */
     private int mSecondExpPos;
-
     /**
      * Flag set if slide shuffling is enabled.
      */
     private boolean mAnimate = false;
-
     /**
      * The user dragged from this position.
      */
     private int mSrcPos;
-
     /**
      * Offset (in x) within the dragged item at which the user picked it up (or
      * first touched down with the digitalis).
      */
     private int mDragDeltaX;
-
     /**
      * Offset (in y) within the dragged item at which the user picked it up (or
      * first touched down with the digitalis).
      */
     private int mDragDeltaY;
-
-    /**
-     * The difference (in x) between screen coordinates and coordinates in this
-     * view.
-     */
-    // private int mOffsetX;
-
-    /**
-     * The difference (in y) between screen coordinates and coordinates in this
-     * view.
-     */
-    // private int mOffsetY;
-
     /**
      * A listener that receives callbacks whenever the floating View hovers over
      * a new position.
      */
     private DragListener mDragListener;
-
     /**
      * A listener that receives a callback when the floating View is dropped.
      */
     private DropListener mDropListener;
-
     /**
      * A listener that receives a callback when the floating View (or more
      * precisely the originally dragged item) is removed by one of the provided
      * gestures.
      */
     private RemoveListener mRemoveListener;
-
     /**
      * Enable/Disable item dragging
-     * 
+     *
      * @attr name dslv:drag_enabled
      */
     private boolean mDragEnabled = true;
-
-    /**
-     * Drag state enum.
-     */
-    private final static int IDLE = 0;
-
-    private final static int REMOVING = 1;
-
-    private final static int DROPPING = 2;
-
-    private final static int STOPPED = 3;
-
-    private final static int DRAGGING = 4;
-
     private int mDragState = IDLE;
-
     /**
      * Height in pixels to which the originally dragged item is collapsed during
      * a drag-sort. Currently, this value must be greater than zero.
      */
     private int mItemHeightCollapsed = 1;
-
     /**
      * Height of the floating View. Stored for the purpose of providing the
      * tracking drop slot.
      */
     private int mFloatViewHeight;
-
     /**
      * Convenience member. See above.
      */
     private int mFloatViewHeightHalf;
-
     /**
      * Save the given width spec for use in measuring children
      */
     private int mWidthMeasureSpec = 0;
-
     /**
      * Sample Views ultimately used for calculating the height of ListView items
      * that are off-screen.
      */
     private View[] mSampleViewTypes = new View[1];
-
     /**
      * Drag-scroll encapsulator!
      */
     private DragScroller mDragScroller;
-
     /**
      * Determines the start of the upward drag-scroll region at the top of the
      * ListView. Specified by a fraction of the ListView height, thus screen
      * resolution agnostic.
      */
     private float mDragUpScrollStartFrac = 1.0f / 3.0f;
-
     /**
      * Determines the start of the downward drag-scroll region at the bottom of
      * the ListView. Specified by a fraction of the ListView height, thus screen
      * resolution agnostic.
      */
     private float mDragDownScrollStartFrac = 1.0f / 3.0f;
-
     /**
      * The following are calculated from the above fracs.
      */
     private int mUpScrollStartY;
-
     private int mDownScrollStartY;
 
+    /**
+     * Last touch x.
+     */
+    // private int mLastX;
     private float mDownScrollStartYF;
 
+    /**
+     * The touch y-coord at which drag started
+     */
+    // private int mDragStartY;
     private float mUpScrollStartYF;
-
     /**
      * Calculated from above above and current ListView height.
      */
     private float mDragUpScrollHeight;
-
     /**
      * Calculated from above above and current ListView height.
      */
     private float mDragDownScrollHeight;
-
     /**
      * Maximum drag-scroll speed in pixels per ms. Only used with default linear
      * drag-scroll profile.
      */
     private float mMaxScrollSpeed = 0.5f;
-
     /**
      * Defines the scroll speed during a drag-scroll. User can provide their
      * own; this default is a simple linear profile where scroll speed increases
@@ -277,105 +285,49 @@ public class DragSortListView extends ListView {
             return mMaxScrollSpeed * w;
         }
     };
-
     /**
      * Current touch x.
      */
     private int mX;
-
     /**
      * Current touch y.
      */
     private int mY;
-
-    /**
-     * Last touch x.
-     */
-    // private int mLastX;
-
     /**
      * Last touch y.
      */
     private int mLastY;
-
-    /**
-     * The touch y-coord at which drag started
-     */
-    // private int mDragStartY;
-
-    /**
-     * Drag flag bit. Floating View can move in the positive x direction.
-     */
-    public final static int DRAG_POS_X = 0x1;
-
-    /**
-     * Drag flag bit. Floating View can move in the negative x direction.
-     */
-    public final static int DRAG_NEG_X = 0x2;
-
-    /**
-     * Drag flag bit. Floating View can move in the positive y direction. This
-     * is subtle. What this actually means is that, if enabled, the floating
-     * View can be dragged below its starting position. Remove in favor of
-     * upper-bounding item position?
-     */
-    public final static int DRAG_POS_Y = 0x4;
-
-    /**
-     * Drag flag bit. Floating View can move in the negative y direction. This
-     * is subtle. What this actually means is that the floating View can be
-     * dragged above its starting position. Remove in favor of lower-bounding
-     * item position?
-     */
-    public final static int DRAG_NEG_Y = 0x8;
-
     /**
      * Flags that determine limits on the motion of the floating View. See flags
      * above.
      */
     private int mDragFlags = 0;
-
     /**
      * Last call to an on*TouchEvent was a call to onInterceptTouchEvent.
      */
     private boolean mLastCallWasIntercept = false;
-
     /**
      * A touch event is in progress.
      */
     private boolean mInTouchEvent = false;
-
     /**
      * Let the user customize the floating View.
      */
     private FloatViewManager mFloatViewManager = null;
-
     /**
      * Given to ListView to cancel its action when a drag-sort begins.
      */
     private MotionEvent mCancelEvent;
-
-    /**
-     * Enum telling where to cancel the ListView action when a drag-sort begins
-     */
-    private static final int NO_CANCEL = 0;
-
-    private static final int ON_TOUCH_EVENT = 1;
-
-    private static final int ON_INTERCEPT_TOUCH_EVENT = 2;
-
     /**
      * Where to cancel the ListView action when a drag-sort begins
      */
     private int mCancelMethod = NO_CANCEL;
-
     /**
      * Determines when a slide shuffle animation starts. That is, defines how
      * close to the edge of the drop slot the floating View must be to initiate
      * the slide.
      */
     private float mSlideRegionFrac = 0.25f;
-
     /**
      * Number between 0 and 1 indicating the relative location of a sliding item
      * (only used if drag-sort animations are turned on). Nearly 1 means the
@@ -383,46 +335,29 @@ public class DragSortListView extends ListView {
      * directly below).
      */
     private float mSlideFrac = 0.0f;
-
     /**
      * Wraps the user-provided ListAdapter. This is used to wrap each item View
      * given by the user inside another View (currenly a RelativeLayout) which
      * expands and collapses to simulate the item shuffling.
      */
     private AdapterWrapper mAdapterWrapper;
-
     /**
      * Turn on custom debugger.
      */
     private boolean mTrackDragSort = false;
-
     /**
      * Debugging class.
      */
     private DragSortTracker mDragSortTracker;
-
     /**
      * Needed for adjusting item heights from within layoutChildren
      */
     private boolean mBlockLayoutRequests = false;
-
     /**
      * Set to true when a down event happens during drag sort; for example, when
      * drag finish animations are playing.
      */
     private boolean mIgnoreTouchEvent = false;
-
-    /**
-     * Caches DragSortItemView child heights. Sometimes DSLV has to know the
-     * height of an offscreen item. Since ListView virtualizes these, DSLV must
-     * get the item from the ListAdapter to obtain its height. That process can
-     * be expensive, but often the same offscreen item will be requested many
-     * times in a row. Once an offscreen item height is calculated, we cache it
-     * in this guy. Actually, we cache the height of the child of the
-     * DragSortItemView since the item height changes often during a drag-sort.
-     */
-    private static final int sCacheSize = 3;
-
     private HeightCache mChildHeightCache = new HeightCache(sCacheSize);
 
     private RemoveAnimator mRemoveAnimator;
@@ -434,6 +369,7 @@ public class DragSortListView extends ListView {
     private boolean mUseRemoveVelocity;
 
     private float mRemoveVelocityX = 0;
+    private boolean mListViewIntercepted = false;
 
     public DragSortListView(Context context, AttributeSet attrs) {
         super(context, attrs);
@@ -533,50 +469,134 @@ public class DragSortListView extends ListView {
         };
     }
 
-    /**
-     * Usually called from a FloatViewManager. The float alpha will be reset to
-     * the xml-defined value every time a drag is stopped.
-     */
-    public void setFloatAlpha(float alpha) {
-        mCurrFloatAlpha = alpha;
-    }
-
-    public float getFloatAlpha() {
-        return mCurrFloatAlpha;
-    }
-
-    /**
-     * Set maximum drag scroll speed in positions/second. Only applies if using
-     * default ScrollSpeedProfile.
-     * 
-     * @param max Maximum scroll speed.
-     */
-    public void setMaxScrollSpeed(float max) {
-        mMaxScrollSpeed = max;
-    }
+    private static int buildRunList(SparseBooleanArray cip, int rangeStart, int rangeEnd, int[] runStart,
+                                    int[] runEnd) {
+        int runCount = 0;
 
-    /**
-     * For each DragSortListView Listener interface implemented by
-     * <code>adapter</code>, this method calls the appropriate set*Listener
-     * method with <code>adapter</code> as the argument.
-     * 
-     * @param adapter The ListAdapter providing data to back DragSortListView.
-     * @see android.widget.ListView#setAdapter(android.widget.ListAdapter)
-     */
-    @Override
-    public void setAdapter(ListAdapter adapter) {
-        if (adapter != null) {
-            mAdapterWrapper = new AdapterWrapper(adapter);
-            adapter.registerDataSetObserver(mObserver);
+        int i = findFirstSetIndex(cip, rangeStart, rangeEnd);
+        if (i == -1)
+            return 0;
+
+        int position = cip.keyAt(i);
+        int currentRunStart = position;
+        int currentRunEnd = currentRunStart + 1;
+        for (i++; i < cip.size() && (position = cip.keyAt(i)) < rangeEnd; i++) {
+            if (!cip.valueAt(i)) // not checked => not interesting
+                continue;
+            if (position == currentRunEnd) {
+                currentRunEnd++;
+            } else {
+                runStart[runCount] = currentRunStart;
+                runEnd[runCount] = currentRunEnd;
+                runCount++;
+                currentRunStart = position;
+                currentRunEnd = position + 1;
+            }
+        }
+
+        if (currentRunEnd == rangeEnd) {
+            // rangeStart and rangeEnd are equivalent positions so to be
+            // consistent we translate them to the same integer value. That way
+            // we can check whether a run covers the entire range by just
+            // checking if the start equals the end position.
+            currentRunEnd = rangeStart;
+        }
+        runStart[runCount] = currentRunStart;
+        runEnd[runCount] = currentRunEnd;
+        runCount++;
+
+        if (runCount > 1) {
+            if (runStart[0] == rangeStart && runEnd[runCount - 1] == rangeStart) {
+                // The last run ends at the end of the range, and the first run
+                // starts at the beginning of the range. So they are actually
+                // part of the same run, except they wrap around the end of the
+                // range. To avoid adjacent runs, we need to merge them.
+                runStart[0] = runStart[runCount - 1];
+                runCount--;
+            }
+        }
+        return runCount;
+    }
+
+    private static int rotate(int value, int offset, int lowerBound, int upperBound) {
+        int windowSize = upperBound - lowerBound;
+
+        value += offset;
+        if (value < lowerBound) {
+            value += windowSize;
+        } else if (value >= upperBound) {
+            value -= windowSize;
+        }
+        return value;
+    }
+
+    private static int findFirstSetIndex(SparseBooleanArray sba, int rangeStart, int rangeEnd) {
+        int size = sba.size();
+        int i = insertionIndexForKey(sba, rangeStart);
+        while (i < size && sba.keyAt(i) < rangeEnd && !sba.valueAt(i))
+            i++;
+        if (i == size || sba.keyAt(i) >= rangeEnd)
+            return -1;
+        return i;
+    }
+
+    private static int insertionIndexForKey(SparseBooleanArray sba, int key) {
+        int low = 0;
+        int high = sba.size();
+        while (high - low > 0) {
+            int middle = (low + high) >> 1;
+            if (sba.keyAt(middle) < key)
+                low = middle + 1;
+            else
+                high = middle;
+        }
+        return low;
+    }
+
+    public float getFloatAlpha() {
+        return mCurrFloatAlpha;
+    }
+
+    /**
+     * Usually called from a FloatViewManager. The float alpha will be reset to
+     * the xml-defined value every time a drag is stopped.
+     */
+    public void setFloatAlpha(float alpha) {
+        mCurrFloatAlpha = alpha;
+    }
+
+    /**
+     * Set maximum drag scroll speed in positions/second. Only applies if using
+     * default ScrollSpeedProfile.
+     *
+     * @param max Maximum scroll speed.
+     */
+    public void setMaxScrollSpeed(float max) {
+        mMaxScrollSpeed = max;
+    }
+
+    /**
+     * For each DragSortListView Listener interface implemented by
+     * <code>adapter</code>, this method calls the appropriate set*Listener
+     * method with <code>adapter</code> as the argument.
+     *
+     * @param adapter The ListAdapter providing data to back DragSortListView.
+     * @see android.widget.ListView#setAdapter(android.widget.ListAdapter)
+     */
+    @Override
+    public void setAdapter(ListAdapter adapter) {
+        if (adapter != null) {
+            mAdapterWrapper = new AdapterWrapper(adapter);
+            adapter.registerDataSetObserver(mObserver);
 
             if (adapter instanceof DropListener) {
-                setDropListener((DropListener)adapter);
+                setDropListener((DropListener) adapter);
             }
             if (adapter instanceof DragListener) {
-                setDragListener((DragListener)adapter);
+                setDragListener((DragListener) adapter);
             }
             if (adapter instanceof RemoveListener) {
-                setRemoveListener((RemoveListener)adapter);
+                setRemoveListener((RemoveListener) adapter);
             }
         } else {
             mAdapterWrapper = null;
@@ -585,11 +605,16 @@ public class DragSortListView extends ListView {
         super.setAdapter(mAdapterWrapper);
     }
 
+    // private void printPosData() {
+    // Log.d("mobeta", "mSrcPos=" + mSrcPos + " mFirstExpPos=" + mFirstExpPos
+    // + " mSecondExpPos=" + mSecondExpPos);
+    // }
+
     /**
      * As opposed to {@link ListView#getAdapter()}, which returns a heavily
      * wrapped ListAdapter (DragSortListView wraps the input ListAdapter {\emph
      * and} ListView wraps the wrapped one).
-     * 
+     *
      * @return The ListAdapter set as the argument of {@link setAdapter()}
      */
     public ListAdapter getInputAdapter() {
@@ -600,113 +625,6 @@ public class DragSortListView extends ListView {
         }
     }
 
-    private class AdapterWrapper extends BaseAdapter {
-        private ListAdapter mAdapter;
-
-        public AdapterWrapper(ListAdapter adapter) {
-            super();
-            mAdapter = adapter;
-
-            mAdapter.registerDataSetObserver(new DataSetObserver() {
-                public void onChanged() {
-                    notifyDataSetChanged();
-                }
-
-                public void onInvalidated() {
-                    notifyDataSetInvalidated();
-                }
-            });
-        }
-
-        public ListAdapter getAdapter() {
-            return mAdapter;
-        }
-
-        @Override
-        public long getItemId(int position) {
-            return mAdapter.getItemId(position);
-        }
-
-        @Override
-        public Object getItem(int position) {
-            return mAdapter.getItem(position);
-        }
-
-        @Override
-        public int getCount() {
-            return mAdapter.getCount();
-        }
-
-        @Override
-        public boolean areAllItemsEnabled() {
-            return mAdapter.areAllItemsEnabled();
-        }
-
-        @Override
-        public boolean isEnabled(int position) {
-            return mAdapter.isEnabled(position);
-        }
-
-        @Override
-        public int getItemViewType(int position) {
-            return mAdapter.getItemViewType(position);
-        }
-
-        @Override
-        public int getViewTypeCount() {
-            return mAdapter.getViewTypeCount();
-        }
-
-        @Override
-        public boolean hasStableIds() {
-            return mAdapter.hasStableIds();
-        }
-
-        @Override
-        public boolean isEmpty() {
-            return mAdapter.isEmpty();
-        }
-
-        @Override
-        public View getView(int position, View convertView, ViewGroup parent) {
-
-            DragSortItemView v;
-            View child;
-            // Log.d("mobeta",
-            // "getView: position="+position+" convertView="+convertView);
-            if (convertView != null) {
-                v = (DragSortItemView)convertView;
-                View oldChild = v.getChildAt(0);
-
-                child = mAdapter.getView(position, oldChild, DragSortListView.this);
-                if (child != oldChild) {
-                    // shouldn't get here if user is reusing convertViews
-                    // properly
-                    if (oldChild != null) {
-                        v.removeViewAt(0);
-                    }
-                    v.addView(child);
-                }
-            } else {
-                child = mAdapter.getView(position, null, DragSortListView.this);
-                if (child instanceof Checkable) {
-                    v = new DragSortItemViewCheckable(getContext());
-                } else {
-                    v = new DragSortItemView(getContext());
-                }
-                v.setLayoutParams(new AbsListView.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
-                        ViewGroup.LayoutParams.WRAP_CONTENT));
-                v.addView(child);
-            }
-
-            // Set the correct item height given drag state; passed
-            // View needs to be measured if measurement is required.
-            adjustItem(position + getHeaderViewsCount(), v, true);
-
-            return v;
-        }
-    }
-
     private void drawDivider(int expPosition, Canvas canvas) {
 
         final Drawable divider = getDivider();
@@ -714,7 +632,7 @@ public class DragSortListView extends ListView {
         // Log.d("mobeta", "div="+divider+" divH="+dividerHeight);
 
         if (divider != null && dividerHeight != 0) {
-            final ViewGroup expItem = (ViewGroup)getChildAt(expPosition - getFirstVisiblePosition());
+            final ViewGroup expItem = (ViewGroup) getChildAt(expPosition - getFirstVisiblePosition());
             if (expItem != null) {
                 final int l = getPaddingLeft();
                 final int r = getWidth() - getPaddingRight();
@@ -768,13 +686,13 @@ public class DragSortListView extends ListView {
                 x = -x;
             float alphaMod;
             if (x < width) {
-                alphaMod = ((float)(width - x)) / ((float)width);
+                alphaMod = ((float) (width - x)) / ((float) width);
                 alphaMod *= alphaMod;
             } else {
                 alphaMod = 0;
             }
 
-            final int alpha = (int)(255f * mCurrFloatAlpha * alphaMod);
+            final int alpha = (int) (255f * mCurrFloatAlpha * alphaMod);
 
             canvas.save();
             // Log.d("mobeta", "clip rect bounds: " + canvas.getClipBounds());
@@ -802,90 +720,40 @@ public class DragSortListView extends ListView {
         }
     }
 
-    // private void printPosData() {
-    // Log.d("mobeta", "mSrcPos=" + mSrcPos + " mFirstExpPos=" + mFirstExpPos
-    // + " mSecondExpPos=" + mSecondExpPos);
-    // }
+    /**
+     * Get the shuffle edge for item at position when top of item is at y-coord
+     * top. Assumes that current item heights are consistent with current float
+     * view location and thus expanded positions and slide fraction. i.e. Should
+     * not be called between update of expanded positions/slide fraction and
+     * layoutChildren.
+     *
+     * @param position
+     * @param top
+     * @param height   Height of item at position. If -1, this function calculates
+     *                 this height.
+     * @return Shuffle line between position-1 and position (for the given view
+     * of the list; that is, for when top of item at position has
+     * y-coord of given `top`). If floating View (treated as horizontal
+     * line) is dropped immediately above this line, it lands in
+     * position-1. If dropped immediately below this line, it lands in
+     * position.
+     */
+    private int getShuffleEdge(int position, int top) {
 
-    private class HeightCache {
+        final int numHeaders = getHeaderViewsCount();
+        final int numFooters = getFooterViewsCount();
 
-        private SparseIntArray mMap;
+        // shuffle edges are defined between items that can be
+        // dragged; there are N-1 of them if there are N draggable
+        // items.
 
-        private ArrayList<Integer> mOrder;
+        if (position <= numHeaders || (position >= getCount() - numFooters)) {
+            return top;
+        }
 
-        private int mMaxSize;
+        int divHeight = getDividerHeight();
 
-        public HeightCache(int size) {
-            mMap = new SparseIntArray(size);
-            mOrder = new ArrayList<Integer>(size);
-            mMaxSize = size;
-        }
-
-        /**
-         * Add item height at position if doesn't already exist.
-         */
-        public void add(int position, int height) {
-            int currHeight = mMap.get(position, -1);
-            if (currHeight != height) {
-                if (currHeight == -1) {
-                    if (mMap.size() == mMaxSize) {
-                        // remove oldest entry
-                        mMap.delete(mOrder.remove(0));
-                    }
-                } else {
-                    // move position to newest slot
-                    mOrder.remove((Integer)position);
-                }
-                mMap.put(position, height);
-                mOrder.add(position);
-            }
-        }
-
-        public int get(int position) {
-            return mMap.get(position, -1);
-        }
-
-        public void clear() {
-            mMap.clear();
-            mOrder.clear();
-        }
-
-    }
-
-    /**
-     * Get the shuffle edge for item at position when top of item is at y-coord
-     * top. Assumes that current item heights are consistent with current float
-     * view location and thus expanded positions and slide fraction. i.e. Should
-     * not be called between update of expanded positions/slide fraction and
-     * layoutChildren.
-     * 
-     * @param position
-     * @param top
-     * @param height Height of item at position. If -1, this function calculates
-     *            this height.
-     * @return Shuffle line between position-1 and position (for the given view
-     *         of the list; that is, for when top of item at position has
-     *         y-coord of given `top`). If floating View (treated as horizontal
-     *         line) is dropped immediately above this line, it lands in
-     *         position-1. If dropped immediately below this line, it lands in
-     *         position.
-     */
-    private int getShuffleEdge(int position, int top) {
-
-        final int numHeaders = getHeaderViewsCount();
-        final int numFooters = getFooterViewsCount();
-
-        // shuffle edges are defined between items that can be
-        // dragged; there are N-1 of them if there are N draggable
-        // items.
-
-        if (position <= numHeaders || (position >= getCount() - numFooters)) {
-            return top;
-        }
-
-        int divHeight = getDividerHeight();
-
-        int edge;
+        int edge;
 
         int maxBlankHeight = mFloatViewHeight - mItemHeightCollapsed;
         int childHeight = getChildHeight(position);
@@ -1021,8 +889,8 @@ public class DragSortListView extends ListView {
             }
             // Log.d("mobeta", "edgeTop="+edgeTop+" edgeBot="+edgeBottom);
 
-            int slideRgnHeight = (int)(0.5f * mSlideRegionFrac * edgeToEdge);
-            float slideRgnHeightF = (float)slideRgnHeight;
+            int slideRgnHeight = (int) (0.5f * mSlideRegionFrac * edgeToEdge);
+            float slideRgnHeightF = (float) slideRgnHeight;
             int slideEdgeTop = edgeTop + slideRgnHeight;
             int slideEdgeBottom = edgeBottom - slideRgnHeight;
 
@@ -1030,7 +898,7 @@ public class DragSortListView extends ListView {
             if (mFloatViewMid < slideEdgeTop) {
                 mFirstExpPos = itemPos - 1;
                 mSecondExpPos = itemPos;
-                mSlideFrac = 0.5f * ((float)(slideEdgeTop - mFloatViewMid)) / slideRgnHeightF;
+                mSlideFrac = 0.5f * ((float) (slideEdgeTop - mFloatViewMid)) / slideRgnHeightF;
                 // Log.d("mobeta",
                 // "firstExp="+mFirstExpPos+" secExp="+mSecondExpPos+"
                 // slideFrac="+mSlideFrac);
@@ -1040,7 +908,7 @@ public class DragSortListView extends ListView {
             } else {
                 mFirstExpPos = itemPos;
                 mSecondExpPos = itemPos + 1;
-                mSlideFrac = 0.5f * (1.0f + ((float)(edgeBottom - mFloatViewMid)) / slideRgnHeightF);
+                mSlideFrac = 0.5f * (1.0f + ((float) (edgeBottom - mFloatViewMid)) / slideRgnHeightF);
                 // Log.d("mobeta",
                 // "firstExp="+mFirstExpPos+" secExp="+mSecondExpPos+"
                 // slideFrac="+mSlideFrac);
@@ -1087,1685 +955,1741 @@ public class DragSortListView extends ListView {
         }
     }
 
-    private class SmoothAnimator implements Runnable {
-        protected long mStartTime;
+    public void removeItem(int which) {
 
-        private float mDurationF;
+        mUseRemoveVelocity = false;
+        removeItem(which, 0);
+    }
 
-        private float mAlpha;
+    /**
+     * Removes an item from the list and animates the removal.
+     *
+     * @param which     Position to remove (NOTE: headers/footers ignored! this is a
+     *                  position in your input ListAdapter).
+     * @param velocityX
+     */
+    public void removeItem(int which, float velocityX) {
+        if (mDragState == IDLE || mDragState == DRAGGING) {
 
-        private float mA, mB, mC, mD;
+            if (mDragState == IDLE) {
+                // called from outside drag-sort
+                mSrcPos = getHeaderViewsCount() + which;
+                mFirstExpPos = mSrcPos;
+                mSecondExpPos = mSrcPos;
+                mFloatPos = mSrcPos;
+                View v = getChildAt(mSrcPos - getFirstVisiblePosition());
+                if (v != null) {
+                    v.setVisibility(View.INVISIBLE);
+                }
+            }
 
-        private boolean mCanceled;
+            mDragState = REMOVING;
+            mRemoveVelocityX = velocityX;
 
-        public SmoothAnimator(float smoothness, int duration) {
-            mAlpha = smoothness;
-            mDurationF = (float)duration;
-            mA = mD = 1f / (2f * mAlpha * (1f - mAlpha));
-            mB = mAlpha / (2f * (mAlpha - 1f));
-            mC = 1f / (1f - mAlpha);
-        }
+            if (mInTouchEvent) {
+                switch (mCancelMethod) {
+                    case ON_TOUCH_EVENT:
+                        super.onTouchEvent(mCancelEvent);
+                        break;
+                    case ON_INTERCEPT_TOUCH_EVENT:
+                        super.onInterceptTouchEvent(mCancelEvent);
+                        break;
+                }
+            }
 
-        public float transform(float frac) {
-            if (frac < mAlpha) {
-                return mA * frac * frac;
-            } else if (frac < 1f - mAlpha) {
-                return mB + mC * frac;
+            if (mRemoveAnimator != null) {
+                mRemoveAnimator.start();
             } else {
-                return 1f - mD * (frac - 1f) * (frac - 1f);
+                doRemoveItem(which);
             }
         }
+    }
 
-        public void start() {
-            mStartTime = SystemClock.uptimeMillis();
-            mCanceled = false;
-            onStart();
-            post(this);
+    /**
+     * Move an item, bypassing the drag-sort process. Simply calls through to
+     * {@link DropListener#drop(int, int)}.
+     *
+     * @param from Position to move (NOTE: headers/footers ignored! this is a
+     *             position in your input ListAdapter).
+     * @param to   Target position (NOTE: headers/footers ignored! this is a
+     *             position in your input ListAdapter).
+     */
+    public void moveItem(int from, int to) {
+        if (mDropListener != null) {
+            final int count = getInputAdapter().getCount();
+            if (from >= 0 && from < count && to >= 0 && to < count) {
+                mDropListener.drop(from, to);
+            }
         }
+    }
 
-        public void cancel() {
-            mCanceled = true;
-        }
+    /**
+     * Cancel a drag. Calls {@link #stopDrag(boolean, boolean)} with
+     * <code>true</code> as the first argument.
+     */
+    public void cancelDrag() {
+        if (mDragState == DRAGGING) {
+            mDragScroller.stopScrolling(true);
+            destroyFloatView();
+            clearPositions();
+            adjustAllItems();
 
-        public void onStart() {
-            // stub
+            if (mInTouchEvent) {
+                mDragState = STOPPED;
+            } else {
+                mDragState = IDLE;
+            }
         }
+    }
 
-        public void onUpdate(float frac, float smoothFrac) {
-            // stub
-        }
+    private void clearPositions() {
+        mSrcPos = -1;
+        mFirstExpPos = -1;
+        mSecondExpPos = -1;
+        mFloatPos = -1;
+    }
 
-        public void onStop() {
-            // stub
+    private void dropFloatView() {
+        // must set to avoid cancelDrag being called from the
+        // DataSetObserver
+        mDragState = DROPPING;
+
+        if (mDropListener != null && mFloatPos >= 0 && mFloatPos < getCount()) {
+            final int numHeaders = getHeaderViewsCount();
+            mDropListener.drop(mSrcPos - numHeaders, mFloatPos - numHeaders);
         }
 
-        @Override
-        public void run() {
-            if (mCanceled) {
-                return;
-            }
+        destroyFloatView();
 
-            float fraction = ((float)(SystemClock.uptimeMillis() - mStartTime)) / mDurationF;
+        adjustOnReorder();
+        clearPositions();
+        adjustAllItems();
 
-            if (fraction >= 1f) {
-                onUpdate(1f, 1f);
-                onStop();
-            } else {
-                onUpdate(fraction, transform(fraction));
-                post(this);
-            }
+        // now the drag is done
+        if (mInTouchEvent) {
+            mDragState = STOPPED;
+        } else {
+            mDragState = IDLE;
         }
     }
 
+    private void doRemoveItem() {
+        doRemoveItem(mSrcPos - getHeaderViewsCount());
+    }
+
     /**
-     * Centers floating View under touch point.
+     * Removes dragged item from the list. Calls RemoveListener.
      */
-    private class LiftAnimator extends SmoothAnimator {
+    private void doRemoveItem(int which) {
+        // must set to avoid cancelDrag being called from the
+        // DataSetObserver
+        mDragState = REMOVING;
 
-        private float mInitDragDeltaY;
+        // end it
+        if (mRemoveListener != null) {
+            mRemoveListener.remove(which);
+        }
 
-        private float mFinalDragDeltaY;
+        destroyFloatView();
 
-        public LiftAnimator(float smoothness, int duration) {
-            super(smoothness, duration);
-        }
+        adjustOnReorder();
+        clearPositions();
 
-        @Override
-        public void onStart() {
-            mInitDragDeltaY = mDragDeltaY;
-            mFinalDragDeltaY = mFloatViewHeightHalf;
+        // now the drag is done
+        if (mInTouchEvent) {
+            mDragState = STOPPED;
+        } else {
+            mDragState = IDLE;
         }
+    }
 
-        @Override
-        public void onUpdate(float frac, float smoothFrac) {
-            if (mDragState != DRAGGING) {
-                cancel();
-            } else {
-                mDragDeltaY = (int)(smoothFrac * mFinalDragDeltaY + (1f - smoothFrac) * mInitDragDeltaY);
-                mFloatLoc.y = mY - mDragDeltaY;
-                doDragFloatView(true);
+    private void adjustOnReorder() {
+        final int firstPos = getFirstVisiblePosition();
+        // Log.d("mobeta", "first="+firstPos+" src="+mSrcPos);
+        if (mSrcPos < firstPos) {
+            // collapsed src item is off screen;
+            // adjust the scroll after item heights have been fixed
+            View v = getChildAt(0);
+            int top = 0;
+            if (v != null) {
+                top = v.getTop();
             }
+            // Log.d("mobeta", "top="+top+" fvh="+mFloatViewHeight);
+            setSelectionFromTop(firstPos - 1, top - getPaddingTop());
         }
     }
 
     /**
-     * Centers floating View over drop slot before destroying.
+     * Stop a drag in progress. Pass <code>true</code> if you would like to
+     * remove the dragged item from the list.
+     *
+     * @param remove Remove the dragged item from the list. Calls a registered
+     *               RemoveListener, if one exists. Otherwise, calls the
+     *               DropListener, if one exists.
+     * @return True if the stop was successful. False if there is no floating
+     * View.
      */
-    private class DropAnimator extends SmoothAnimator {
-
-        private int mDropPos;
+    public boolean stopDrag(boolean remove) {
+        mUseRemoveVelocity = false;
+        return stopDrag(remove, 0);
+    }
 
-        private int srcPos;
+    public boolean stopDragWithVelocity(boolean remove, float velocityX) {
 
-        private float mInitDeltaY;
-
-        private float mInitDeltaX;
-
-        public DropAnimator(float smoothness, int duration) {
-            super(smoothness, duration);
-        }
+        mUseRemoveVelocity = true;
+        return stopDrag(remove, velocityX);
+    }
 
-        @Override
-        public void onStart() {
-            mDropPos = mFloatPos;
-            srcPos = mSrcPos;
-            mDragState = DROPPING;
-            mInitDeltaY = mFloatLoc.y - getTargetY();
-            mInitDeltaX = mFloatLoc.x - getPaddingLeft();
-        }
+    public boolean stopDrag(boolean remove, float velocityX) {
+        if (mFloatView != null) {
+            mDragScroller.stopScrolling(true);
 
-        private int getTargetY() {
-            final int first = getFirstVisiblePosition();
-            final int otherAdjust = (mItemHeightCollapsed + getDividerHeight()) / 2;
-            View v = getChildAt(mDropPos - first);
-            int targetY = -1;
-            if (v != null) {
-                if (mDropPos == srcPos) {
-                    targetY = v.getTop();
-                } else if (mDropPos < srcPos) {
-                    // expanded down
-                    targetY = v.getTop() - otherAdjust;
+            if (remove) {
+                removeItem(mSrcPos - getHeaderViewsCount(), velocityX);
+            } else {
+                if (mDropAnimator != null) {
+                    mDropAnimator.start();
                 } else {
-                    // expanded up
-                    targetY = v.getBottom() + otherAdjust - mFloatViewHeight;
+                    dropFloatView();
                 }
-            } else {
-                // drop position is not on screen?? no animation
-                cancel();
             }
 
-            return targetY;
-        }
-
-        @Override
-        public void onUpdate(float frac, float smoothFrac) {
-            final int targetY = getTargetY();
-            final int targetX = getPaddingLeft();
-            final float deltaY = mFloatLoc.y - targetY;
-            final float deltaX = mFloatLoc.x - targetX;
-            final float f = 1f - smoothFrac;
-            if (f < Math.abs(deltaY / mInitDeltaY) || f < Math.abs(deltaX / mInitDeltaX)) {
-                mFloatLoc.y = targetY + (int)(mInitDeltaY * f);
-                mFloatLoc.x = getPaddingLeft() + (int)(mInitDeltaX * f);
-                doDragFloatView(true);
+            if (mTrackDragSort) {
+                mDragSortTracker.stopTracking();
             }
+
+            return true;
+        } else {
+            // stop failed
+            return false;
         }
+    }
 
-        @Override
-        public void onStop() {
-            dropFloatView();
+    @Override
+    public boolean onTouchEvent(MotionEvent ev) {
+        if (mIgnoreTouchEvent) {
+            mIgnoreTouchEvent = false;
+            return false;
         }
 
-    }
+        if (!mDragEnabled) {
+            return super.onTouchEvent(ev);
+        }
 
-    /**
-     * Collapses expanded items.
-     */
-    private class RemoveAnimator extends SmoothAnimator {
+        boolean more = false;
 
-        private float mFloatLocX;
+        boolean lastCallWasIntercept = mLastCallWasIntercept;
+        mLastCallWasIntercept = false;
 
-        private float mFirstStartBlank;
+        if (!lastCallWasIntercept) {
+            saveTouchCoords(ev);
+        }
 
-        private float mSecondStartBlank;
+        // if (mFloatView != null) {
+        if (mDragState == DRAGGING) {
+            onDragTouchEvent(ev);
+            more = true; // give us more!
+        } else {
+            // what if float view is null b/c we dropped in middle
+            // of drag touch event?
 
-        private int mFirstChildHeight = -1;
+            // if (mDragState != STOPPED) {
+            if (mDragState == IDLE) {
+                if (super.onTouchEvent(ev)) {
+                    more = true;
+                }
+            }
 
-        private int mSecondChildHeight = -1;
+            int action = ev.getAction() & MotionEvent.ACTION_MASK;
 
-        private int mFirstPos;
+            switch (action) {
+                case MotionEvent.ACTION_CANCEL:
+                case MotionEvent.ACTION_UP:
+                    doActionUpOrCancel();
+                    break;
+                default:
+                    if (more) {
+                        mCancelMethod = ON_TOUCH_EVENT;
+                    }
+            }
+        }
 
-        private int mSecondPos;
+        return more;
+    }
 
-        // private int srcPos;
+    private void doActionUpOrCancel() {
+        mCancelMethod = NO_CANCEL;
+        mInTouchEvent = false;
+        if (mDragState == STOPPED) {
+            mDragState = IDLE;
+        }
+        mCurrFloatAlpha = mFloatAlpha;
+        mListViewIntercepted = false;
+        mChildHeightCache.clear();
+    }
 
-        public RemoveAnimator(float smoothness, int duration) {
-            super(smoothness, duration);
+    private void saveTouchCoords(MotionEvent ev) {
+        int action = ev.getAction() & MotionEvent.ACTION_MASK;
+        if (action != MotionEvent.ACTION_DOWN) {
+            // mLastX = mX;
+            mLastY = mY;
         }
+        mX = (int) ev.getX();
+        mY = (int) ev.getY();
+        if (action == MotionEvent.ACTION_DOWN) {
+            // mLastX = mX;
+            mLastY = mY;
+        }
+        // mOffsetX = (int) ev.getRawX() - mX;
+        // mOffsetY = (int) ev.getRawY() - mY;
+    }
 
-        @Override
-        public void onStart() {
-            mFirstChildHeight = -1;
-            mSecondChildHeight = -1;
-            mFirstPos = mFirstExpPos;
-            mSecondPos = mSecondExpPos;
-            // srcPos = mSrcPos;
-            mDragState = REMOVING;
+    public boolean listViewIntercepted() {
+        return mListViewIntercepted;
+    }
 
-            mFloatLocX = mFloatLoc.x;
-            if (mUseRemoveVelocity) {
-                float minVelocity = 2f * getWidth();
-                if (mRemoveVelocityX == 0) {
-                    mRemoveVelocityX = (mFloatLocX < 0 ? -1 : 1) * minVelocity;
-                } else {
-                    minVelocity *= 2;
-                    if (mRemoveVelocityX < 0 && mRemoveVelocityX > -minVelocity)
-                        mRemoveVelocityX = -minVelocity;
-                    else if (mRemoveVelocityX > 0 && mRemoveVelocityX < minVelocity)
-                        mRemoveVelocityX = minVelocity;
-                }
-            } else {
-                destroyFloatView();
-            }
+    @Override
+    public boolean onInterceptTouchEvent(MotionEvent ev) {
+        if (!mDragEnabled) {
+            return super.onInterceptTouchEvent(ev);
         }
 
-        @Override
-        public void onUpdate(float frac, float smoothFrac) {
-            float f = 1f - smoothFrac;
+        saveTouchCoords(ev);
+        mLastCallWasIntercept = true;
 
-            final int firstVis = getFirstVisiblePosition();
-            View item = getChildAt(mFirstPos - firstVis);
-            ViewGroup.LayoutParams lp;
-            int blank;
+        int action = ev.getAction() & MotionEvent.ACTION_MASK;
 
-            if (mUseRemoveVelocity) {
-                float dt = (float)(SystemClock.uptimeMillis() - mStartTime) / 1000;
-                if (dt == 0)
-                    return;
-                float dx = mRemoveVelocityX * dt;
-                int w = getWidth();
-                mRemoveVelocityX += (mRemoveVelocityX > 0 ? 1 : -1) * dt * w;
-                mFloatLocX += dx;
-                mFloatLoc.x = (int)mFloatLocX;
-                if (mFloatLocX < w && mFloatLocX > -w) {
-                    mStartTime = SystemClock.uptimeMillis();
-                    doDragFloatView(true);
-                    return;
-                }
+        if (action == MotionEvent.ACTION_DOWN) {
+            if (mDragState != IDLE) {
+                // intercept and ignore
+                mIgnoreTouchEvent = true;
+                return true;
             }
+            mInTouchEvent = true;
+        }
 
-            if (item != null) {
-                if (mFirstChildHeight == -1) {
-                    mFirstChildHeight = getChildHeight(mFirstPos, item, false);
-                    mFirstStartBlank = (float)(item.getHeight() - mFirstChildHeight);
-                }
-                blank = Math.max((int)(f * mFirstStartBlank), 1);
-                lp = item.getLayoutParams();
-                lp.height = mFirstChildHeight + blank;
-                item.setLayoutParams(lp);
+        boolean intercept = false;
+
+        // the following deals with calls to super.onInterceptTouchEvent
+        if (mFloatView != null) {
+            // super's touch event canceled in startDrag
+            intercept = true;
+        } else {
+            if (super.onInterceptTouchEvent(ev)) {
+                mListViewIntercepted = true;
+                intercept = true;
             }
-            if (mSecondPos != mFirstPos) {
-                item = getChildAt(mSecondPos - firstVis);
-                if (item != null) {
-                    if (mSecondChildHeight == -1) {
-                        mSecondChildHeight = getChildHeight(mSecondPos, item, false);
-                        mSecondStartBlank = (float)(item.getHeight() - mSecondChildHeight);
+
+            switch (action) {
+                case MotionEvent.ACTION_CANCEL:
+                case MotionEvent.ACTION_UP:
+                    doActionUpOrCancel();
+                    break;
+                default:
+                    if (intercept) {
+                        mCancelMethod = ON_TOUCH_EVENT;
+                    } else {
+                        mCancelMethod = ON_INTERCEPT_TOUCH_EVENT;
                     }
-                    blank = Math.max((int)(f * mSecondStartBlank), 1);
-                    lp = item.getLayoutParams();
-                    lp.height = mSecondChildHeight + blank;
-                    item.setLayoutParams(lp);
-                }
             }
         }
 
-        @Override
-        public void onStop() {
-            doRemoveItem();
+        if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL) {
+            mInTouchEvent = false;
         }
-    }
-
-    public void removeItem(int which) {
 
-        mUseRemoveVelocity = false;
-        removeItem(which, 0);
+        return intercept;
     }
 
     /**
-     * Removes an item from the list and animates the removal.
-     * 
-     * @param which Position to remove (NOTE: headers/footers ignored! this is a
-     *            position in your input ListAdapter).
-     * @param velocityX
+     * Set the width of each drag scroll region by specifying a fraction of the
+     * ListView height.
+     *
+     * @param heightFraction Fraction of ListView height. Capped at 0.5f.
      */
-    public void removeItem(int which, float velocityX) {
-        if (mDragState == IDLE || mDragState == DRAGGING) {
-
-            if (mDragState == IDLE) {
-                // called from outside drag-sort
-                mSrcPos = getHeaderViewsCount() + which;
-                mFirstExpPos = mSrcPos;
-                mSecondExpPos = mSrcPos;
-                mFloatPos = mSrcPos;
-                View v = getChildAt(mSrcPos - getFirstVisiblePosition());
-                if (v != null) {
-                    v.setVisibility(View.INVISIBLE);
-                }
-            }
-
-            mDragState = REMOVING;
-            mRemoveVelocityX = velocityX;
-
-            if (mInTouchEvent) {
-                switch (mCancelMethod) {
-                    case ON_TOUCH_EVENT:
-                        super.onTouchEvent(mCancelEvent);
-                        break;
-                    case ON_INTERCEPT_TOUCH_EVENT:
-                        super.onInterceptTouchEvent(mCancelEvent);
-                        break;
-                }
-            }
-
-            if (mRemoveAnimator != null) {
-                mRemoveAnimator.start();
-            } else {
-                doRemoveItem(which);
-            }
-        }
+    public void setDragScrollStart(float heightFraction) {
+        setDragScrollStarts(heightFraction, heightFraction);
     }
 
     /**
-     * Move an item, bypassing the drag-sort process. Simply calls through to
-     * {@link DropListener#drop(int, int)}.
-     * 
-     * @param from Position to move (NOTE: headers/footers ignored! this is a
-     *            position in your input ListAdapter).
-     * @param to Target position (NOTE: headers/footers ignored! this is a
-     *            position in your input ListAdapter).
+     * Set the width of each drag scroll region by specifying a fraction of the
+     * ListView height.
+     *
+     * @param upperFrac Fraction of ListView height for up-scroll bound. Capped
+     *                  at 0.5f.
+     * @param lowerFrac Fraction of ListView height for down-scroll bound.
+     *                  Capped at 0.5f.
      */
-    public void moveItem(int from, int to) {
-        if (mDropListener != null) {
-            final int count = getInputAdapter().getCount();
-            if (from >= 0 && from < count && to >= 0 && to < count) {
-                mDropListener.drop(from, to);
-            }
+    public void setDragScrollStarts(float upperFrac, float lowerFrac) {
+        if (lowerFrac > 0.5f) {
+            mDragDownScrollStartFrac = 0.5f;
+        } else {
+            mDragDownScrollStartFrac = lowerFrac;
         }
-    }
-
-    /**
-     * Cancel a drag. Calls {@link #stopDrag(boolean, boolean)} with
-     * <code>true</code> as the first argument.
-     */
-    public void cancelDrag() {
-        if (mDragState == DRAGGING) {
-            mDragScroller.stopScrolling(true);
-            destroyFloatView();
-            clearPositions();
-            adjustAllItems();
 
-            if (mInTouchEvent) {
-                mDragState = STOPPED;
-            } else {
-                mDragState = IDLE;
-            }
+        if (upperFrac > 0.5f) {
+            mDragUpScrollStartFrac = 0.5f;
+        } else {
+            mDragUpScrollStartFrac = upperFrac;
         }
-    }
 
-    private void clearPositions() {
-        mSrcPos = -1;
-        mFirstExpPos = -1;
-        mSecondExpPos = -1;
-        mFloatPos = -1;
+        if (getHeight() != 0) {
+            updateScrollStarts();
+        }
     }
 
-    private void dropFloatView() {
-        // must set to avoid cancelDrag being called from the
-        // DataSetObserver
-        mDragState = DROPPING;
+    private void continueDrag(int x, int y) {
 
-        if (mDropListener != null && mFloatPos >= 0 && mFloatPos < getCount()) {
-            final int numHeaders = getHeaderViewsCount();
-            mDropListener.drop(mSrcPos - numHeaders, mFloatPos - numHeaders);
-        }
+        // proposed position
+        mFloatLoc.x = x - mDragDeltaX;
+        mFloatLoc.y = y - mDragDeltaY;
 
-        destroyFloatView();
+        doDragFloatView(true);
 
-        adjustOnReorder();
-        clearPositions();
-        adjustAllItems();
+        int minY = Math.min(y, mFloatViewMid + mFloatViewHeightHalf);
+        int maxY = Math.max(y, mFloatViewMid - mFloatViewHeightHalf);
 
-        // now the drag is done
-        if (mInTouchEvent) {
-            mDragState = STOPPED;
-        } else {
-            mDragState = IDLE;
-        }
-    }
+        // get the current scroll direction
+        int currentScrollDir = mDragScroller.getScrollDir();
 
-    private void doRemoveItem() {
-        doRemoveItem(mSrcPos - getHeaderViewsCount());
-    }
+        if (minY > mLastY && minY > mDownScrollStartY && currentScrollDir != DragScroller.DOWN) {
+            // dragged down, it is below the down scroll start and it is not
+            // scrolling up
 
-    /**
-     * Removes dragged item from the list. Calls RemoveListener.
-     */
-    private void doRemoveItem(int which) {
-        // must set to avoid cancelDrag being called from the
-        // DataSetObserver
-        mDragState = REMOVING;
+            if (currentScrollDir != DragScroller.STOP) {
+                // moved directly from up scroll to down scroll
+                mDragScroller.stopScrolling(true);
+            }
 
-        // end it
-        if (mRemoveListener != null) {
-            mRemoveListener.remove(which);
-        }
+            // start scrolling down
+            mDragScroller.startScrolling(DragScroller.DOWN);
+        } else if (maxY < mLastY && maxY < mUpScrollStartY && currentScrollDir != DragScroller.UP) {
+            // dragged up, it is above the up scroll start and it is not
+            // scrolling up
 
-        destroyFloatView();
+            if (currentScrollDir != DragScroller.STOP) {
+                // moved directly from down scroll to up scroll
+                mDragScroller.stopScrolling(true);
+            }
 
-        adjustOnReorder();
-        clearPositions();
+            // start scrolling up
+            mDragScroller.startScrolling(DragScroller.UP);
+        } else if (maxY >= mUpScrollStartY && minY <= mDownScrollStartY && mDragScroller.isScrolling()) {
+            // not in the upper nor in the lower drag-scroll regions but it is
+            // still scrolling
 
-        // now the drag is done
-        if (mInTouchEvent) {
-            mDragState = STOPPED;
-        } else {
-            mDragState = IDLE;
+            mDragScroller.stopScrolling(true);
         }
     }
 
-    private void adjustOnReorder() {
-        final int firstPos = getFirstVisiblePosition();
-        // Log.d("mobeta", "first="+firstPos+" src="+mSrcPos);
-        if (mSrcPos < firstPos) {
-            // collapsed src item is off screen;
-            // adjust the scroll after item heights have been fixed
-            View v = getChildAt(0);
-            int top = 0;
-            if (v != null) {
-                top = v.getTop();
-            }
-            // Log.d("mobeta", "top="+top+" fvh="+mFloatViewHeight);
-            setSelectionFromTop(firstPos - 1, top - getPaddingTop());
-        }
-    }
+    private void updateScrollStarts() {
+        final int padTop = getPaddingTop();
+        final int listHeight = getHeight() - padTop - getPaddingBottom();
+        float heightF = (float) listHeight;
 
-    /**
-     * Stop a drag in progress. Pass <code>true</code> if you would like to
-     * remove the dragged item from the list.
-     * 
-     * @param remove Remove the dragged item from the list. Calls a registered
-     *            RemoveListener, if one exists. Otherwise, calls the
-     *            DropListener, if one exists.
-     * @return True if the stop was successful. False if there is no floating
-     *         View.
-     */
-    public boolean stopDrag(boolean remove) {
-        mUseRemoveVelocity = false;
-        return stopDrag(remove, 0);
-    }
+        mUpScrollStartYF = padTop + mDragUpScrollStartFrac * heightF;
+        mDownScrollStartYF = padTop + (1.0f - mDragDownScrollStartFrac) * heightF;
 
-    public boolean stopDragWithVelocity(boolean remove, float velocityX) {
+        mUpScrollStartY = (int) mUpScrollStartYF;
+        mDownScrollStartY = (int) mDownScrollStartYF;
 
-        mUseRemoveVelocity = true;
-        return stopDrag(remove, velocityX);
+        mDragUpScrollHeight = mUpScrollStartYF - padTop;
+        mDragDownScrollHeight = padTop + listHeight - mDownScrollStartYF;
     }
 
-    public boolean stopDrag(boolean remove, float velocityX) {
-        if (mFloatView != null) {
-            mDragScroller.stopScrolling(true);
+    @Override
+    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
+        super.onSizeChanged(w, h, oldw, oldh);
+        updateScrollStarts();
+    }
 
-            if (remove) {
-                removeItem(mSrcPos - getHeaderViewsCount(), velocityX);
-            } else {
-                if (mDropAnimator != null) {
-                    mDropAnimator.start();
-                } else {
-                    dropFloatView();
-                }
-            }
+    private void adjustAllItems() {
+        final int first = getFirstVisiblePosition();
+        final int last = getLastVisiblePosition();
 
-            if (mTrackDragSort) {
-                mDragSortTracker.stopTracking();
+        int begin = Math.max(0, getHeaderViewsCount() - first);
+        int end = Math.min(last - first, getCount() - 1 - getFooterViewsCount() - first);
+
+        for (int i = begin; i <= end; ++i) {
+            View v = getChildAt(i);
+            if (v != null) {
+                adjustItem(first + i, v, false);
             }
+        }
+    }
 
-            return true;
+    /**
+     * Sets layout param height, gravity, and visibility on wrapped item.
+     */
+    private void adjustItem(int position, View v, boolean invalidChildHeight) {
+
+        // Adjust item height
+        ViewGroup.LayoutParams lp = v.getLayoutParams();
+        int height;
+        if (position != mSrcPos && position != mFirstExpPos && position != mSecondExpPos) {
+            height = ViewGroup.LayoutParams.WRAP_CONTENT;
         } else {
-            // stop failed
-            return false;
+            height = calcItemHeight(position, v, invalidChildHeight);
         }
-    }
 
-    @Override
-    public boolean onTouchEvent(MotionEvent ev) {
-        if (mIgnoreTouchEvent) {
-            mIgnoreTouchEvent = false;
-            return false;
+        if (height != lp.height) {
+            lp.height = height;
+            v.setLayoutParams(lp);
         }
 
-        if (!mDragEnabled) {
-            return super.onTouchEvent(ev);
+        // Adjust item gravity
+        if (position == mFirstExpPos || position == mSecondExpPos) {
+            if (position < mSrcPos) {
+                ((DragSortItemView) v).setGravity(Gravity.BOTTOM);
+            } else if (position > mSrcPos) {
+                ((DragSortItemView) v).setGravity(Gravity.TOP);
+            }
         }
 
-        boolean more = false;
+        // Finally adjust item visibility
 
-        boolean lastCallWasIntercept = mLastCallWasIntercept;
-        mLastCallWasIntercept = false;
+        int oldVis = v.getVisibility();
+        int vis = View.VISIBLE;
 
-        if (!lastCallWasIntercept) {
-            saveTouchCoords(ev);
+        if (position == mSrcPos && mFloatView != null) {
+            vis = View.INVISIBLE;
         }
 
-        // if (mFloatView != null) {
-        if (mDragState == DRAGGING) {
-            onDragTouchEvent(ev);
-            more = true; // give us more!
-        } else {
-            // what if float view is null b/c we dropped in middle
-            // of drag touch event?
+        if (vis != oldVis) {
+            v.setVisibility(vis);
+        }
+    }
 
-            // if (mDragState != STOPPED) {
-            if (mDragState == IDLE) {
-                if (super.onTouchEvent(ev)) {
-                    more = true;
-                }
-            }
+    private int getChildHeight(int position) {
+        if (position == mSrcPos) {
+            return 0;
+        }
 
-            int action = ev.getAction() & MotionEvent.ACTION_MASK;
+        View v = getChildAt(position - getFirstVisiblePosition());
 
-            switch (action) {
-                case MotionEvent.ACTION_CANCEL:
-                case MotionEvent.ACTION_UP:
-                    doActionUpOrCancel();
-                    break;
-                default:
-                    if (more) {
-                        mCancelMethod = ON_TOUCH_EVENT;
-                    }
+        if (v != null) {
+            // item is onscreen, therefore child height is valid,
+            // hence the "true"
+            return getChildHeight(position, v, false);
+        } else {
+            // item is offscreen
+            // first check cache for child height at this position
+            int childHeight = mChildHeightCache.get(position);
+            if (childHeight != -1) {
+                // Log.d("mobeta", "found child height in cache!");
+                return childHeight;
             }
-        }
 
-        return more;
-    }
+            final ListAdapter adapter = getAdapter();
+            int type = adapter.getItemViewType(position);
 
-    private void doActionUpOrCancel() {
-        mCancelMethod = NO_CANCEL;
-        mInTouchEvent = false;
-        if (mDragState == STOPPED) {
-            mDragState = IDLE;
-        }
-        mCurrFloatAlpha = mFloatAlpha;
-        mListViewIntercepted = false;
-        mChildHeightCache.clear();
-    }
+            // There might be a better place for checking for the following
+            final int typeCount = adapter.getViewTypeCount();
+            if (typeCount != mSampleViewTypes.length) {
+                mSampleViewTypes = new View[typeCount];
+            }
 
-    private void saveTouchCoords(MotionEvent ev) {
-        int action = ev.getAction() & MotionEvent.ACTION_MASK;
-        if (action != MotionEvent.ACTION_DOWN) {
-            // mLastX = mX;
-            mLastY = mY;
-        }
-        mX = (int)ev.getX();
-        mY = (int)ev.getY();
-        if (action == MotionEvent.ACTION_DOWN) {
-            // mLastX = mX;
-            mLastY = mY;
-        }
-        // mOffsetX = (int) ev.getRawX() - mX;
-        // mOffsetY = (int) ev.getRawY() - mY;
-    }
+            if (type >= 0) {
+                if (mSampleViewTypes[type] == null) {
+                    v = adapter.getView(position, null, this);
+                    mSampleViewTypes[type] = v;
+                } else {
+                    v = adapter.getView(position, mSampleViewTypes[type], this);
+                }
+            } else {
+                // type is HEADER_OR_FOOTER or IGNORE
+                v = adapter.getView(position, null, this);
+            }
 
-    public boolean listViewIntercepted() {
-        return mListViewIntercepted;
-    }
+            // current child height is invalid, hence "true" below
+            childHeight = getChildHeight(position, v, true);
 
-    private boolean mListViewIntercepted = false;
+            // cache it because this could have been expensive
+            mChildHeightCache.add(position, childHeight);
 
-    @Override
-    public boolean onInterceptTouchEvent(MotionEvent ev) {
-        if (!mDragEnabled) {
-            return super.onInterceptTouchEvent(ev);
+            return childHeight;
         }
+    }
 
-        saveTouchCoords(ev);
-        mLastCallWasIntercept = true;
-
-        int action = ev.getAction() & MotionEvent.ACTION_MASK;
+    // private void adjustItem(int position) {
+    // View v = getChildAt(position - getFirstVisiblePosition());
+    //
+    // if (v != null) {
+    // adjustItem(position, v, false);
+    // }
+    // }
 
-        if (action == MotionEvent.ACTION_DOWN) {
-            if (mDragState != IDLE) {
-                // intercept and ignore
-                mIgnoreTouchEvent = true;
-                return true;
-            }
-            mInTouchEvent = true;
+    private int getChildHeight(int position, View item, boolean invalidChildHeight) {
+        if (position == mSrcPos) {
+            return 0;
         }
 
-        boolean intercept = false;
-
-        // the following deals with calls to super.onInterceptTouchEvent
-        if (mFloatView != null) {
-            // super's touch event canceled in startDrag
-            intercept = true;
+        View child;
+        if (position < getHeaderViewsCount() || position >= getCount() - getFooterViewsCount()) {
+            child = item;
         } else {
-            if (super.onInterceptTouchEvent(ev)) {
-                mListViewIntercepted = true;
-                intercept = true;
-            }
+            child = ((ViewGroup) item).getChildAt(0);
+        }
 
-            switch (action) {
-                case MotionEvent.ACTION_CANCEL:
-                case MotionEvent.ACTION_UP:
-                    doActionUpOrCancel();
-                    break;
-                default:
-                    if (intercept) {
-                        mCancelMethod = ON_TOUCH_EVENT;
-                    } else {
-                        mCancelMethod = ON_INTERCEPT_TOUCH_EVENT;
-                    }
+        ViewGroup.LayoutParams lp = child.getLayoutParams();
+
+        if (lp != null) {
+            if (lp.height > 0) {
+                return lp.height;
             }
         }
 
-        if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL) {
-            mInTouchEvent = false;
+        int childHeight = child.getHeight();
+
+        if (childHeight == 0 || invalidChildHeight) {
+            measureItem(child);
+            childHeight = child.getMeasuredHeight();
         }
 
-        return intercept;
+        return childHeight;
     }
 
-    /**
-     * Set the width of each drag scroll region by specifying a fraction of the
-     * ListView height.
-     * 
-     * @param heightFraction Fraction of ListView height. Capped at 0.5f.
-     */
-    public void setDragScrollStart(float heightFraction) {
-        setDragScrollStarts(heightFraction, heightFraction);
+    private int calcItemHeight(int position, View item, boolean invalidChildHeight) {
+        return calcItemHeight(position, getChildHeight(position, item, invalidChildHeight));
     }
 
-    /**
-     * Set the width of each drag scroll region by specifying a fraction of the
-     * ListView height.
-     * 
-     * @param upperFrac Fraction of ListView height for up-scroll bound. Capped
-     *            at 0.5f.
-     * @param lowerFrac Fraction of ListView height for down-scroll bound.
-     *            Capped at 0.5f.
-     */
-    public void setDragScrollStarts(float upperFrac, float lowerFrac) {
-        if (lowerFrac > 0.5f) {
-            mDragDownScrollStartFrac = 0.5f;
-        } else {
-            mDragDownScrollStartFrac = lowerFrac;
-        }
+    private int calcItemHeight(int position, int childHeight) {
 
-        if (upperFrac > 0.5f) {
-            mDragUpScrollStartFrac = 0.5f;
+        // int divHeight = getDividerHeight();
+
+        boolean isSliding = mAnimate && mFirstExpPos != mSecondExpPos;
+        int maxNonSrcBlankHeight = mFloatViewHeight - mItemHeightCollapsed;
+        int slideHeight = (int) (mSlideFrac * maxNonSrcBlankHeight);
+
+        int height;
+
+        if (position == mSrcPos) {
+            if (mSrcPos == mFirstExpPos) {
+                if (isSliding) {
+                    height = slideHeight + mItemHeightCollapsed;
+                } else {
+                    height = mFloatViewHeight;
+                }
+            } else if (mSrcPos == mSecondExpPos) {
+                // if gets here, we know an item is sliding
+                height = mFloatViewHeight - slideHeight;
+            } else {
+                height = mItemHeightCollapsed;
+            }
+        } else if (position == mFirstExpPos) {
+            if (isSliding) {
+                height = childHeight + slideHeight;
+            } else {
+                height = childHeight + maxNonSrcBlankHeight;
+            }
+        } else if (position == mSecondExpPos) {
+            // we know an item is sliding (b/c 2ndPos != 1stPos)
+            height = childHeight + maxNonSrcBlankHeight - slideHeight;
         } else {
-            mDragUpScrollStartFrac = upperFrac;
+            height = childHeight;
         }
 
-        if (getHeight() != 0) {
-            updateScrollStarts();
+        return height;
+    }
+
+    @Override
+    public void requestLayout() {
+        if (!mBlockLayoutRequests) {
+            super.requestLayout();
         }
     }
 
-    private void continueDrag(int x, int y) {
+    private int adjustScroll(int movePos, View moveItem, int oldFirstExpPos, int oldSecondExpPos) {
+        int adjust = 0;
 
-        // proposed position
-        mFloatLoc.x = x - mDragDeltaX;
-        mFloatLoc.y = y - mDragDeltaY;
+        final int childHeight = getChildHeight(movePos);
 
-        doDragFloatView(true);
+        int moveHeightBefore = moveItem.getHeight();
+        int moveHeightAfter = calcItemHeight(movePos, childHeight);
 
-        int minY = Math.min(y, mFloatViewMid + mFloatViewHeightHalf);
-        int maxY = Math.max(y, mFloatViewMid - mFloatViewHeightHalf);
+        int moveBlankBefore = moveHeightBefore;
+        int moveBlankAfter = moveHeightAfter;
+        if (movePos != mSrcPos) {
+            moveBlankBefore -= childHeight;
+            moveBlankAfter -= childHeight;
+        }
 
-        // get the current scroll direction
-        int currentScrollDir = mDragScroller.getScrollDir();
+        int maxBlank = mFloatViewHeight;
+        if (mSrcPos != mFirstExpPos && mSrcPos != mSecondExpPos) {
+            maxBlank -= mItemHeightCollapsed;
+        }
 
-        if (minY > mLastY && minY > mDownScrollStartY && currentScrollDir != DragScroller.DOWN) {
-            // dragged down, it is below the down scroll start and it is not
-            // scrolling up
-
-            if (currentScrollDir != DragScroller.STOP) {
-                // moved directly from up scroll to down scroll
-                mDragScroller.stopScrolling(true);
+        if (movePos <= oldFirstExpPos) {
+            if (movePos > mFirstExpPos) {
+                adjust += maxBlank - moveBlankAfter;
             }
-
-            // start scrolling down
-            mDragScroller.startScrolling(DragScroller.DOWN);
-        } else if (maxY < mLastY && maxY < mUpScrollStartY && currentScrollDir != DragScroller.UP) {
-            // dragged up, it is above the up scroll start and it is not
-            // scrolling up
-
-            if (currentScrollDir != DragScroller.STOP) {
-                // moved directly from down scroll to up scroll
-                mDragScroller.stopScrolling(true);
+        } else if (movePos == oldSecondExpPos) {
+            if (movePos <= mFirstExpPos) {
+                adjust += moveBlankBefore - maxBlank;
+            } else if (movePos == mSecondExpPos) {
+                adjust += moveHeightBefore - moveHeightAfter;
+            } else {
+                adjust += moveBlankBefore;
+            }
+        } else {
+            if (movePos <= mFirstExpPos) {
+                adjust -= maxBlank;
+            } else if (movePos == mSecondExpPos) {
+                adjust -= moveBlankAfter;
             }
+        }
 
-            // start scrolling up
-            mDragScroller.startScrolling(DragScroller.UP);
-        } else if (maxY >= mUpScrollStartY && minY <= mDownScrollStartY && mDragScroller.isScrolling()) {
-            // not in the upper nor in the lower drag-scroll regions but it is
-            // still scrolling
+        return adjust;
+    }
 
-            mDragScroller.stopScrolling(true);
+    private void measureItem(View item) {
+        ViewGroup.LayoutParams lp = item.getLayoutParams();
+        if (lp == null) {
+            lp = new AbsListView.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);
+            item.setLayoutParams(lp);
+        }
+        int wspec = ViewGroup.getChildMeasureSpec(mWidthMeasureSpec, getListPaddingLeft() + getListPaddingRight(),
+                lp.width);
+        int hspec;
+        if (lp.height > 0) {
+            hspec = MeasureSpec.makeMeasureSpec(lp.height, MeasureSpec.EXACTLY);
+        } else {
+            hspec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
         }
+        item.measure(wspec, hspec);
     }
 
-    private void updateScrollStarts() {
-        final int padTop = getPaddingTop();
-        final int listHeight = getHeight() - padTop - getPaddingBottom();
-        float heightF = (float)listHeight;
-
-        mUpScrollStartYF = padTop + mDragUpScrollStartFrac * heightF;
-        mDownScrollStartYF = padTop + (1.0f - mDragDownScrollStartFrac) * heightF;
-
-        mUpScrollStartY = (int)mUpScrollStartYF;
-        mDownScrollStartY = (int)mDownScrollStartYF;
-
-        mDragUpScrollHeight = mUpScrollStartYF - padTop;
-        mDragDownScrollHeight = padTop + listHeight - mDownScrollStartYF;
+    private void measureFloatView() {
+        if (mFloatView != null) {
+            measureItem(mFloatView);
+            mFloatViewHeight = mFloatView.getMeasuredHeight();
+            mFloatViewHeightHalf = mFloatViewHeight / 2;
+        }
     }
 
     @Override
-    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
-        super.onSizeChanged(w, h, oldw, oldh);
-        updateScrollStarts();
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+        // Log.d("mobeta", "onMeasure called");
+        if (mFloatView != null) {
+            if (mFloatView.isLayoutRequested()) {
+                measureFloatView();
+            }
+            mFloatViewOnMeasured = true; // set to false after layout
+        }
+        mWidthMeasureSpec = widthMeasureSpec;
     }
 
-    private void adjustAllItems() {
-        final int first = getFirstVisiblePosition();
-        final int last = getLastVisiblePosition();
-
-        int begin = Math.max(0, getHeaderViewsCount() - first);
-        int end = Math.min(last - first, getCount() - 1 - getFooterViewsCount() - first);
+    @Override
+    protected void layoutChildren() {
+        super.layoutChildren();
 
-        for (int i = begin; i <= end; ++i) {
-            View v = getChildAt(i);
-            if (v != null) {
-                adjustItem(first + i, v, false);
+        if (mFloatView != null) {
+            if (mFloatView.isLayoutRequested() && !mFloatViewOnMeasured) {
+                // Have to measure here when usual android measure
+                // pass is skipped. This happens during a drag-sort
+                // when layoutChildren is called directly.
+                measureFloatView();
             }
+            mFloatView.layout(0, 0, mFloatView.getMeasuredWidth(), mFloatView.getMeasuredHeight());
+            mFloatViewOnMeasured = false;
         }
     }
 
-    // private void adjustItem(int position) {
-    // View v = getChildAt(position - getFirstVisiblePosition());
-    //
-    // if (v != null) {
-    // adjustItem(position, v, false);
-    // }
-    // }
+    protected boolean onDragTouchEvent(MotionEvent ev) {
+        // we are in a drag
+        // int action = ev.getAction() & MotionEvent.ACTION_MASK;
+
+        switch (ev.getAction() & MotionEvent.ACTION_MASK) {
+            case MotionEvent.ACTION_CANCEL:
+                if (mDragState == DRAGGING) {
+                    cancelDrag();
+                }
+                doActionUpOrCancel();
+                break;
+            case MotionEvent.ACTION_UP:
+                // Log.d("mobeta", "calling stopDrag from onDragTouchEvent");
+                if (mDragState == DRAGGING) {
+                    stopDrag(false);
+                }
+                doActionUpOrCancel();
+                break;
+            case MotionEvent.ACTION_MOVE:
+                continueDrag((int) ev.getX(), (int) ev.getY());
+                break;
+        }
+
+        return true;
+    }
 
     /**
-     * Sets layout param height, gravity, and visibility on wrapped item.
+     * Start a drag of item at <code>position</code> using the registered
+     * FloatViewManager. Calls through to
+     * {@link #startDrag(int, View, int, int, int)} after obtaining the floating
+     * View from the FloatViewManager.
+     *
+     * @param position  Item to drag.
+     * @param dragFlags Flags that restrict some movements of the floating View.
+     *                  For example, set <code>dragFlags |=
+     *                  ~{@link #DRAG_NEG_X}</code> to allow dragging the floating View in all
+     *                  directions except off the screen to the left.
+     * @param deltaX    Offset in x of the touch coordinate from the left edge of
+     *                  the floating View (i.e. touch-x minus float View left).
+     * @param deltaY    Offset in y of the touch coordinate from the top edge of
+     *                  the floating View (i.e. touch-y minus float View top).
+     * @return True if the drag was started, false otherwise. This
+     * <code>startDrag</code> will fail if we are not currently in a
+     * touch event, there is no registered FloatViewManager, or the
+     * FloatViewManager returns a null View.
      */
-    private void adjustItem(int position, View v, boolean invalidChildHeight) {
+    public boolean startDrag(int position, int dragFlags, int deltaX, int deltaY) {
+        if (!mInTouchEvent || mFloatViewManager == null) {
+            return false;
+        }
 
-        // Adjust item height
-        ViewGroup.LayoutParams lp = v.getLayoutParams();
-        int height;
-        if (position != mSrcPos && position != mFirstExpPos && position != mSecondExpPos) {
-            height = ViewGroup.LayoutParams.WRAP_CONTENT;
+        View v = mFloatViewManager.onCreateFloatView(position);
+
+        if (v == null) {
+            return false;
         } else {
-            height = calcItemHeight(position, v, invalidChildHeight);
+            return startDrag(position, v, dragFlags, deltaX, deltaY);
         }
 
-        if (height != lp.height) {
-            lp.height = height;
-            v.setLayoutParams(lp);
+    }
+
+    /**
+     * Start a drag of item at <code>position</code> without using a
+     * FloatViewManager.
+     *
+     * @param position  Item to drag.
+     * @param floatView Floating View.
+     * @param dragFlags Flags that restrict some movements of the floating View.
+     *                  For example, set <code>dragFlags |=
+     *                  ~{@link #DRAG_NEG_X}</code> to allow dragging the floating View in all
+     *                  directions except off the screen to the left.
+     * @param deltaX    Offset in x of the touch coordinate from the left edge of
+     *                  the floating View (i.e. touch-x minus float View left).
+     * @param deltaY    Offset in y of the touch coordinate from the top edge of
+     *                  the floating View (i.e. touch-y minus float View top).
+     * @return True if the drag was started, false otherwise. This
+     * <code>startDrag</code> will fail if we are not currently in a
+     * touch event, <code>floatView</code> is null, or there is a drag
+     * in progress.
+     */
+    public boolean startDrag(int position, View floatView, int dragFlags, int deltaX, int deltaY) {
+        if (mDragState != IDLE || !mInTouchEvent || mFloatView != null || floatView == null || !mDragEnabled) {
+            return false;
         }
 
-        // Adjust item gravity
-        if (position == mFirstExpPos || position == mSecondExpPos) {
-            if (position < mSrcPos) {
-                ((DragSortItemView)v).setGravity(Gravity.BOTTOM);
-            } else if (position > mSrcPos) {
-                ((DragSortItemView)v).setGravity(Gravity.TOP);
-            }
+        if (getParent() != null) {
+            getParent().requestDisallowInterceptTouchEvent(true);
         }
 
-        // Finally adjust item visibility
+        int pos = position + getHeaderViewsCount();
+        mFirstExpPos = pos;
+        mSecondExpPos = pos;
+        mSrcPos = pos;
+        mFloatPos = pos;
 
-        int oldVis = v.getVisibility();
-        int vis = View.VISIBLE;
+        // mDragState = dragType;
+        mDragState = DRAGGING;
+        mDragFlags = 0;
+        mDragFlags |= dragFlags;
 
-        if (position == mSrcPos && mFloatView != null) {
-            vis = View.INVISIBLE;
+        mFloatView = floatView;
+        measureFloatView(); // sets mFloatViewHeight
+
+        mDragDeltaX = deltaX;
+        mDragDeltaY = deltaY;
+        // mDragStartY = mY;
+
+        // updateFloatView(mX - mDragDeltaX, mY - mDragDeltaY);
+        mFloatLoc.x = mX - mDragDeltaX;
+        mFloatLoc.y = mY - mDragDeltaY;
+
+        // set src item invisible
+        final View srcItem = getChildAt(mSrcPos - getFirstVisiblePosition());
+
+        if (srcItem != null) {
+            srcItem.setVisibility(View.INVISIBLE);
         }
 
-        if (vis != oldVis) {
-            v.setVisibility(vis);
+        if (mTrackDragSort) {
+            mDragSortTracker.startTracking();
         }
-    }
 
-    private int getChildHeight(int position) {
-        if (position == mSrcPos) {
-            return 0;
+        // once float view is created, events are no longer passed
+        // to ListView
+        switch (mCancelMethod) {
+            case ON_TOUCH_EVENT:
+                super.onTouchEvent(mCancelEvent);
+                break;
+            case ON_INTERCEPT_TOUCH_EVENT:
+                super.onInterceptTouchEvent(mCancelEvent);
+                break;
         }
 
-        View v = getChildAt(position - getFirstVisiblePosition());
+        requestLayout();
 
-        if (v != null) {
-            // item is onscreen, therefore child height is valid,
-            // hence the "true"
-            return getChildHeight(position, v, false);
-        } else {
-            // item is offscreen
-            // first check cache for child height at this position
-            int childHeight = mChildHeightCache.get(position);
-            if (childHeight != -1) {
-                // Log.d("mobeta", "found child height in cache!");
-                return childHeight;
-            }
+        if (mLiftAnimator != null) {
+            mLiftAnimator.start();
+        }
 
-            final ListAdapter adapter = getAdapter();
-            int type = adapter.getItemViewType(position);
+        return true;
+    }
 
-            // There might be a better place for checking for the following
-            final int typeCount = adapter.getViewTypeCount();
-            if (typeCount != mSampleViewTypes.length) {
-                mSampleViewTypes = new View[typeCount];
-            }
+    // private boolean mFloatViewInvalidated = false;
 
-            if (type >= 0) {
-                if (mSampleViewTypes[type] == null) {
-                    v = adapter.getView(position, null, this);
-                    mSampleViewTypes[type] = v;
-                } else {
-                    v = adapter.getView(position, mSampleViewTypes[type], this);
-                }
-            } else {
-                // type is HEADER_OR_FOOTER or IGNORE
-                v = adapter.getView(position, null, this);
-            }
-
-            // current child height is invalid, hence "true" below
-            childHeight = getChildHeight(position, v, true);
+    // private void invalidateFloatView() {
+    // mFloatViewInvalidated = true;
+    // }
 
-            // cache it because this could have been expensive
-            mChildHeightCache.add(position, childHeight);
+    private void doDragFloatView(boolean forceInvalidate) {
+        int movePos = getFirstVisiblePosition() + getChildCount() / 2;
+        View moveItem = getChildAt(getChildCount() / 2);
 
-            return childHeight;
+        if (moveItem == null) {
+            return;
         }
+
+        doDragFloatView(movePos, moveItem, forceInvalidate);
     }
 
-    private int getChildHeight(int position, View item, boolean invalidChildHeight) {
-        if (position == mSrcPos) {
-            return 0;
-        }
+    private void doDragFloatView(int movePos, View moveItem, boolean forceInvalidate) {
+        mBlockLayoutRequests = true;
 
-        View child;
-        if (position < getHeaderViewsCount() || position >= getCount() - getFooterViewsCount()) {
-            child = item;
-        } else {
-            child = ((ViewGroup)item).getChildAt(0);
-        }
+        updateFloatView();
 
-        ViewGroup.LayoutParams lp = child.getLayoutParams();
+        int oldFirstExpPos = mFirstExpPos;
+        int oldSecondExpPos = mSecondExpPos;
 
-        if (lp != null) {
-            if (lp.height > 0) {
-                return lp.height;
-            }
-        }
+        boolean updated = updatePositions();
 
-        int childHeight = child.getHeight();
+        if (updated) {
+            adjustAllItems();
+            int scroll = adjustScroll(movePos, moveItem, oldFirstExpPos, oldSecondExpPos);
+            // Log.d("mobeta", " adjust scroll="+scroll);
 
-        if (childHeight == 0 || invalidChildHeight) {
-            measureItem(child);
-            childHeight = child.getMeasuredHeight();
+            setSelectionFromTop(movePos, moveItem.getTop() + scroll - getPaddingTop());
+            layoutChildren();
         }
 
-        return childHeight;
-    }
+        if (updated || forceInvalidate) {
+            invalidate();
+        }
 
-    private int calcItemHeight(int position, View item, boolean invalidChildHeight) {
-        return calcItemHeight(position, getChildHeight(position, item, invalidChildHeight));
+        mBlockLayoutRequests = false;
     }
 
-    private int calcItemHeight(int position, int childHeight) {
-
-        // int divHeight = getDividerHeight();
-
-        boolean isSliding = mAnimate && mFirstExpPos != mSecondExpPos;
-        int maxNonSrcBlankHeight = mFloatViewHeight - mItemHeightCollapsed;
-        int slideHeight = (int)(mSlideFrac * maxNonSrcBlankHeight);
-
-        int height;
+    /**
+     * Sets float View location based on suggested values and constraints set in
+     * mDragFlags.
+     */
+    private void updateFloatView() {
 
-        if (position == mSrcPos) {
-            if (mSrcPos == mFirstExpPos) {
-                if (isSliding) {
-                    height = slideHeight + mItemHeightCollapsed;
-                } else {
-                    height = mFloatViewHeight;
-                }
-            } else if (mSrcPos == mSecondExpPos) {
-                // if gets here, we know an item is sliding
-                height = mFloatViewHeight - slideHeight;
-            } else {
-                height = mItemHeightCollapsed;
-            }
-        } else if (position == mFirstExpPos) {
-            if (isSliding) {
-                height = childHeight + slideHeight;
-            } else {
-                height = childHeight + maxNonSrcBlankHeight;
-            }
-        } else if (position == mSecondExpPos) {
-            // we know an item is sliding (b/c 2ndPos != 1stPos)
-            height = childHeight + maxNonSrcBlankHeight - slideHeight;
-        } else {
-            height = childHeight;
+        if (mFloatViewManager != null) {
+            mTouchLoc.set(mX, mY);
+            mFloatViewManager.onDragFloatView(mFloatView, mFloatLoc, mTouchLoc);
         }
 
-        return height;
-    }
+        final int floatX = mFloatLoc.x;
+        final int floatY = mFloatLoc.y;
 
-    @Override
-    public void requestLayout() {
-        if (!mBlockLayoutRequests) {
-            super.requestLayout();
+        // restrict x motion
+        int padLeft = getPaddingLeft();
+        if ((mDragFlags & DRAG_POS_X) == 0 && floatX > padLeft) {
+            mFloatLoc.x = padLeft;
+        } else if ((mDragFlags & DRAG_NEG_X) == 0 && floatX < padLeft) {
+            mFloatLoc.x = padLeft;
         }
-    }
-
-    private int adjustScroll(int movePos, View moveItem, int oldFirstExpPos, int oldSecondExpPos) {
-        int adjust = 0;
-
-        final int childHeight = getChildHeight(movePos);
 
-        int moveHeightBefore = moveItem.getHeight();
-        int moveHeightAfter = calcItemHeight(movePos, childHeight);
-
-        int moveBlankBefore = moveHeightBefore;
-        int moveBlankAfter = moveHeightAfter;
-        if (movePos != mSrcPos) {
-            moveBlankBefore -= childHeight;
-            moveBlankAfter -= childHeight;
-        }
+        // keep floating view from going past bottom of last header view
+        final int numHeaders = getHeaderViewsCount();
+        final int numFooters = getFooterViewsCount();
+        final int firstPos = getFirstVisiblePosition();
+        final int lastPos = getLastVisiblePosition();
 
-        int maxBlank = mFloatViewHeight;
-        if (mSrcPos != mFirstExpPos && mSrcPos != mSecondExpPos) {
-            maxBlank -= mItemHeightCollapsed;
+        // Log.d("mobeta",
+        // "nHead="+numHeaders+" nFoot="+numFooters+" first="+firstPos+"
+        // last="+lastPos);
+        int topLimit = getPaddingTop();
+        if (firstPos < numHeaders) {
+            topLimit = getChildAt(numHeaders - firstPos - 1).getBottom();
         }
-
-        if (movePos <= oldFirstExpPos) {
-            if (movePos > mFirstExpPos) {
-                adjust += maxBlank - moveBlankAfter;
-            }
-        } else if (movePos == oldSecondExpPos) {
-            if (movePos <= mFirstExpPos) {
-                adjust += moveBlankBefore - maxBlank;
-            } else if (movePos == mSecondExpPos) {
-                adjust += moveHeightBefore - moveHeightAfter;
-            } else {
-                adjust += moveBlankBefore;
+        if ((mDragFlags & DRAG_NEG_Y) == 0) {
+            if (firstPos <= mSrcPos) {
+                topLimit = Math.max(getChildAt(mSrcPos - firstPos).getTop(), topLimit);
             }
-        } else {
-            if (movePos <= mFirstExpPos) {
-                adjust -= maxBlank;
-            } else if (movePos == mSecondExpPos) {
-                adjust -= moveBlankAfter;
+        }
+        // bottom limit is top of first footer View or
+        // bottom of last item in list
+        int bottomLimit = getHeight() - getPaddingBottom();
+        if (lastPos >= getCount() - numFooters - 1) {
+            bottomLimit = getChildAt(getCount() - numFooters - 1 - firstPos).getBottom();
+        }
+        if ((mDragFlags & DRAG_POS_Y) == 0) {
+            if (lastPos >= mSrcPos) {
+                bottomLimit = Math.min(getChildAt(mSrcPos - firstPos).getBottom(), bottomLimit);
             }
         }
 
-        return adjust;
-    }
+        // Log.d("mobeta", "dragView top=" + (y - mDragDeltaY));
+        // Log.d("mobeta", "limit=" + limit);
+        // Log.d("mobeta", "mDragDeltaY=" + mDragDeltaY);
 
-    private void measureItem(View item) {
-        ViewGroup.LayoutParams lp = item.getLayoutParams();
-        if (lp == null) {
-            lp = new AbsListView.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);
-            item.setLayoutParams(lp);
-        }
-        int wspec = ViewGroup.getChildMeasureSpec(mWidthMeasureSpec, getListPaddingLeft() + getListPaddingRight(),
-                lp.width);
-        int hspec;
-        if (lp.height > 0) {
-            hspec = MeasureSpec.makeMeasureSpec(lp.height, MeasureSpec.EXACTLY);
-        } else {
-            hspec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
+        if (floatY < topLimit) {
+            mFloatLoc.y = topLimit;
+        } else if (floatY + mFloatViewHeight > bottomLimit) {
+            mFloatLoc.y = bottomLimit - mFloatViewHeight;
         }
-        item.measure(wspec, hspec);
-    }
 
-    private void measureFloatView() {
-        if (mFloatView != null) {
-            measureItem(mFloatView);
-            mFloatViewHeight = mFloatView.getMeasuredHeight();
-            mFloatViewHeightHalf = mFloatViewHeight / 2;
-        }
+        // get y-midpoint of floating view (constrained to ListView bounds)
+        mFloatViewMid = mFloatLoc.y + mFloatViewHeightHalf;
     }
 
-    @Override
-    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
-        // Log.d("mobeta", "onMeasure called");
+    private void destroyFloatView() {
         if (mFloatView != null) {
-            if (mFloatView.isLayoutRequested()) {
-                measureFloatView();
+            mFloatView.setVisibility(GONE);
+            if (mFloatViewManager != null) {
+                mFloatViewManager.onDestroyFloatView(mFloatView);
             }
-            mFloatViewOnMeasured = true; // set to false after layout
+            mFloatView = null;
+            invalidate();
         }
-        mWidthMeasureSpec = widthMeasureSpec;
     }
 
-    @Override
-    protected void layoutChildren() {
-        super.layoutChildren();
+    public void setFloatViewManager(FloatViewManager manager) {
+        mFloatViewManager = manager;
+    }
 
-        if (mFloatView != null) {
-            if (mFloatView.isLayoutRequested() && !mFloatViewOnMeasured) {
-                // Have to measure here when usual android measure
-                // pass is skipped. This happens during a drag-sort
-                // when layoutChildren is called directly.
-                measureFloatView();
-            }
-            mFloatView.layout(0, 0, mFloatView.getMeasuredWidth(), mFloatView.getMeasuredHeight());
-            mFloatViewOnMeasured = false;
-        }
+    public void setDragListener(DragListener l) {
+        mDragListener = l;
     }
 
-    protected boolean onDragTouchEvent(MotionEvent ev) {
-        // we are in a drag
-        // int action = ev.getAction() & MotionEvent.ACTION_MASK;
+    public boolean isDragEnabled() {
+        return mDragEnabled;
+    }
 
-        switch (ev.getAction() & MotionEvent.ACTION_MASK) {
-            case MotionEvent.ACTION_CANCEL:
-                if (mDragState == DRAGGING) {
-                    cancelDrag();
-                }
-                doActionUpOrCancel();
-                break;
-            case MotionEvent.ACTION_UP:
-                // Log.d("mobeta", "calling stopDrag from onDragTouchEvent");
-                if (mDragState == DRAGGING) {
-                    stopDrag(false);
-                }
-                doActionUpOrCancel();
-                break;
-            case MotionEvent.ACTION_MOVE:
-                continueDrag((int)ev.getX(), (int)ev.getY());
-                break;
-        }
+    /**
+     * Allows for easy toggling between a DragSortListView and a regular old
+     * ListView. If enabled, items are draggable, where the drag init mode
+     * determines how items are lifted (see {@link setDragInitMode(int)}). If
+     * disabled, items cannot be dragged.
+     *
+     * @param enabled Set <code>true</code> to enable list item dragging
+     */
+    public void setDragEnabled(boolean enabled) {
+        mDragEnabled = enabled;
+    }
 
-        return true;
+    /**
+     * This better reorder your ListAdapter! DragSortListView does not do this
+     * for you; doesn't make sense to. Make sure
+     * {@link BaseAdapter#notifyDataSetChanged()} or something like it is called
+     * in your implementation. Furthermore, if you have a choiceMode other than
+     * none and the ListAdapter does not return true for
+     * {@link ListAdapter#hasStableIds()}, you will need to call
+     * {@link #moveCheckState(int, int)} to move the check boxes along with the
+     * list items.
+     *
+     * @param l
+     */
+    public void setDropListener(DropListener l) {
+        mDropListener = l;
     }
 
-    // private boolean mFloatViewInvalidated = false;
+    /**
+     * Probably a no-brainer, but make sure that your remove listener calls
+     * {@link BaseAdapter#notifyDataSetChanged()} or something like it. When an
+     * item removal occurs, DragSortListView relies on a redraw of all the items
+     * to recover invisible views and such. Strictly speaking, if you remove
+     * something, your dataset has changed...
+     *
+     * @param l
+     */
+    public void setRemoveListener(RemoveListener l) {
+        mRemoveListener = l;
+    }
 
-    // private void invalidateFloatView() {
-    // mFloatViewInvalidated = true;
-    // }
+    public void setDragSortListener(DragSortListener l) {
+        setDropListener(l);
+        setDragListener(l);
+        setRemoveListener(l);
+    }
 
     /**
-     * Start a drag of item at <code>position</code> using the registered
-     * FloatViewManager. Calls through to
-     * {@link #startDrag(int,View,int,int,int)} after obtaining the floating
-     * View from the FloatViewManager.
-     * 
-     * @param position Item to drag.
-     * @param dragFlags Flags that restrict some movements of the floating View.
-     *            For example, set <code>dragFlags |= 
-     * ~{@link #DRAG_NEG_X}</code> to allow dragging the floating View in all
-     *            directions except off the screen to the left.
-     * @param deltaX Offset in x of the touch coordinate from the left edge of
-     *            the floating View (i.e. touch-x minus float View left).
-     * @param deltaY Offset in y of the touch coordinate from the top edge of
-     *            the floating View (i.e. touch-y minus float View top).
-     * @return True if the drag was started, false otherwise. This
-     *         <code>startDrag</code> will fail if we are not currently in a
-     *         touch event, there is no registered FloatViewManager, or the
-     *         FloatViewManager returns a null View.
+     * Completely custom scroll speed profile. Default increases linearly with
+     * position and is constant in time. Create your own by implementing
+     * {@link DragSortListView.DragScrollProfile}.
+     *
+     * @param ssp
      */
-    public boolean startDrag(int position, int dragFlags, int deltaX, int deltaY) {
-        if (!mInTouchEvent || mFloatViewManager == null) {
-            return false;
+    public void setDragScrollProfile(DragScrollProfile ssp) {
+        if (ssp != null) {
+            mScrollProfile = ssp;
         }
+    }
 
-        View v = mFloatViewManager.onCreateFloatView(position);
+    /**
+     * Use this to move the check state of an item from one position to another
+     * in a drop operation. If you have a choiceMode which is not none, this
+     * method must be called when the order of items changes in an underlying
+     * adapter which does not have stable IDs (see
+     * {@link ListAdapter#hasStableIds()}). This is because without IDs, the
+     * ListView has no way of knowing which items have moved where, and cannot
+     * update the check state accordingly.
+     * <p/>
+     * A word of warning about a "feature" in Android that you may run into when
+     * dealing with movable list items: for an adapter that <em>does</em> have
+     * stable IDs, ListView will attempt to locate each item based on its ID and
+     * move the check state from the item's old position to the new position 
+     * which is all fine and good (and removes the need for calling this
+     * function), except for the half-baked approach. Apparently to save time in
+     * the naive algorithm used, ListView will only search for an ID in the
+     * close neighborhood of the old position. If the user moves an item too far
+     * (specifically, more than 20 rows away), ListView will give up and just
+     * force the item to be unchecked. So if there is a reasonable chance that
+     * the user will move items more than 20 rows away from the original
+     * position, you may wish to use an adapter with unstable IDs and call this
+     * method manually instead.
+     *
+     * @param from
+     * @param to
+     */
+    public void moveCheckState(int from, int to) {
+        // This method runs in O(n log n) time (n being the number of list
+        // items). The bottleneck is the call to AbsListView.setItemChecked,
+        // which is O(log n) because of the binary search involved in calling
+        // SparseBooleanArray.put().
+        //
+        // To improve on the average time, we minimize the number of calls to
+        // setItemChecked by only calling it for items that actually have a
+        // changed state. This is achieved by building a list containing the
+        // start and end of the "runs" of checked items, and then moving the
+        // runs. Note that moving an item from A to B is essentially a rotation
+        // of the range of items in [A, B]. Let's say we have
+        // . . U V X Y Z . .
+        // and move U after Z. This is equivalent to a rotation one step to the
+        // left within the range you are moving across:
+        // . . V X Y Z U . .
+        //
+        // So, to perform the move we enumerate all the runs within the move
+        // range, then rotate each run one step to the left or right (depending
+        // on move direction). For example, in the list:
+        // X X . X X X . X
+        // we have two runs. One begins at the last item of the list and wraps
+        // around to the beginning, ending at position 1. The second begins at
+        // position 3 and ends at position 5. To rotate a run, regardless of
+        // length, we only need to set a check mark at one end of the run, and
+        // clear a check mark at the other end:
+        // X . X X X . X X
+        SparseBooleanArray cip = getCheckedItemPositions();
+        int rangeStart = from;
+        int rangeEnd = to;
+        if (to < from) {
+            rangeStart = to;
+            rangeEnd = from;
+        }
+        rangeEnd += 1;
+
+        int[] runStart = new int[cip.size()];
+        int[] runEnd = new int[cip.size()];
+        int runCount = buildRunList(cip, rangeStart, rangeEnd, runStart, runEnd);
+        if (runCount == 1 && (runStart[0] == runEnd[0])) {
+            // Special case where all items are checked, we can never set any
+            // item to false like we do below.
+            return;
+        }
+
+        if (from < to) {
+            for (int i = 0; i != runCount; i++) {
+                setItemChecked(rotate(runStart[i], -1, rangeStart, rangeEnd), true);
+                setItemChecked(rotate(runEnd[i], -1, rangeStart, rangeEnd), false);
+            }
 
-        if (v == null) {
-            return false;
         } else {
-            return startDrag(position, v, dragFlags, deltaX, deltaY);
+            for (int i = 0; i != runCount; i++) {
+                setItemChecked(runStart[i], false);
+                setItemChecked(runEnd[i], true);
+            }
         }
+    }
+
+    /**
+     * Use this when an item has been deleted, to move the check state of all
+     * following items up one step. If you have a choiceMode which is not none,
+     * this method must be called when the order of items changes in an
+     * underlying adapter which does not have stable IDs (see
+     * {@link ListAdapter#hasStableIds()}). This is because without IDs, the
+     * ListView has no way of knowing which items have moved where, and cannot
+     * update the check state accordingly. See also further comments on
+     * {@link #moveCheckState(int, int)}.
+     *
+     * @param position
+     */
+    public void removeCheckState(int position) {
+        SparseBooleanArray cip = getCheckedItemPositions();
+
+        if (cip.size() == 0)
+            return;
+        int[] runStart = new int[cip.size()];
+        int[] runEnd = new int[cip.size()];
+        int rangeStart = position;
+        int rangeEnd = cip.keyAt(cip.size() - 1) + 1;
+        int runCount = buildRunList(cip, rangeStart, rangeEnd, runStart, runEnd);
+        for (int i = 0; i != runCount; i++) {
+            if (!(runStart[i] == position || (runEnd[i] < runStart[i] && runEnd[i] > position))) {
+                // Only set a new check mark in front of this run if it does
+                // not contain the deleted position. If it does, we only need
+                // to make it one check mark shorter at the end.
+                setItemChecked(rotate(runStart[i], -1, rangeStart, rangeEnd), true);
+            }
+            setItemChecked(rotate(runEnd[i], -1, rangeStart, rangeEnd), false);
+        }
+    }
+
+    /**
+     * Interface for customization of the floating View appearance and dragging
+     * behavior. Implement your own and pass it to {@link #setFloatViewManager}.
+     * If your own is not passed, the default {@link SimpleFloatViewManager}
+     * implementation is used.
+     */
+    public interface FloatViewManager {
+        /**
+         * Return the floating View for item at <code>position</code>.
+         * DragSortListView will measure and layout this View for you, so feel
+         * free to just inflate it. You can help DSLV by setting some
+         * {@link ViewGroup.LayoutParams} on this View; otherwise it will set
+         * some for you (with a width of FILL_PARENT and a height of
+         * WRAP_CONTENT).
+         *
+         * @param position Position of item to drag (NOTE: <code>position</code>
+         *                 excludes header Views; thus, if you want to call
+         *                 {@link ListView#getChildAt(int)}, you will need to add
+         *                 {@link ListView#getHeaderViewsCount()} to the index).
+         * @return The View you wish to display as the floating View.
+         */
+        public View onCreateFloatView(int position);
+
+        /**
+         * Called whenever the floating View is dragged. Float View properties
+         * can be changed here. Also, the upcoming location of the float View
+         * can be altered by setting <code>location.x</code> and
+         * <code>location.y</code>.
+         *
+         * @param floatView     The floating View.
+         * @param location      The location (top-left; relative to DSLV top-left) at
+         *                      which the float View would like to appear, given the
+         *                      current touch location and the offset provided in
+         *                      {@link DragSortListView#startDrag}.
+         * @param touch         The current touch location (relative to DSLV top-left).
+         * @param pendingScroll
+         */
+        public void onDragFloatView(View floatView, Point location, Point touch);
+
+        /**
+         * Called when the float View is dropped; lets you perform any necessary
+         * cleanup. The internal DSLV floating View reference is set to null
+         * immediately after this is called.
+         *
+         * @param floatView The floating View passed to
+         *                  {@link #onCreateFloatView(int)}.
+         */
+        public void onDestroyFloatView(View floatView);
+    }
+
+    public interface DragListener {
+        public void drag(int from, int to);
+    }
+
+    /**
+     * Your implementation of this has to reorder your ListAdapter! Make sure to
+     * call {@link BaseAdapter#notifyDataSetChanged()} or something like it in
+     * your implementation.
+     *
+     * @author heycosmo
+     */
+    public interface DropListener {
+        public void drop(int from, int to);
+    }
+
+    /**
+     * Make sure to call {@link BaseAdapter#notifyDataSetChanged()} or something
+     * like it in your implementation.
+     *
+     * @author heycosmo
+     */
+    public interface RemoveListener {
+        public void remove(int which);
+    }
+
+    public interface DragSortListener extends DropListener, DragListener, RemoveListener {
+    }
+
+    /**
+     * Interface for controlling scroll speed as a function of touch position
+     * and time. Use
+     * {@link DragSortListView#setDragScrollProfile(DragScrollProfile)} to set
+     * custom profile.
+     *
+     * @author heycosmo
+     */
+    public interface DragScrollProfile {
+        /**
+         * Return a scroll speed in pixels/millisecond. Always return a positive
+         * number.
+         *
+         * @param w Normalized position in scroll region (i.e. w \in [0,1]).
+         *          Small w typically means slow scrolling.
+         * @param t Time (in milliseconds) since start of scroll (handy if you
+         *          want scroll acceleration).
+         * @return Scroll speed at position w and time t in pixels/ms.
+         */
+        float getSpeed(float w, long t);
+    }
+
+    private class AdapterWrapper extends BaseAdapter {
+        private ListAdapter mAdapter;
 
-    }
+        public AdapterWrapper(ListAdapter adapter) {
+            super();
+            mAdapter = adapter;
 
-    /**
-     * Start a drag of item at <code>position</code> without using a
-     * FloatViewManager.
-     * 
-     * @param position Item to drag.
-     * @param floatView Floating View.
-     * @param dragFlags Flags that restrict some movements of the floating View.
-     *            For example, set <code>dragFlags |= 
-     * ~{@link #DRAG_NEG_X}</code> to allow dragging the floating View in all
-     *            directions except off the screen to the left.
-     * @param deltaX Offset in x of the touch coordinate from the left edge of
-     *            the floating View (i.e. touch-x minus float View left).
-     * @param deltaY Offset in y of the touch coordinate from the top edge of
-     *            the floating View (i.e. touch-y minus float View top).
-     * @return True if the drag was started, false otherwise. This
-     *         <code>startDrag</code> will fail if we are not currently in a
-     *         touch event, <code>floatView</code> is null, or there is a drag
-     *         in progress.
-     */
-    public boolean startDrag(int position, View floatView, int dragFlags, int deltaX, int deltaY) {
-        if (mDragState != IDLE || !mInTouchEvent || mFloatView != null || floatView == null || !mDragEnabled) {
-            return false;
+            mAdapter.registerDataSetObserver(new DataSetObserver() {
+                public void onChanged() {
+                    notifyDataSetChanged();
+                }
+
+                public void onInvalidated() {
+                    notifyDataSetInvalidated();
+                }
+            });
         }
 
-        if (getParent() != null) {
-            getParent().requestDisallowInterceptTouchEvent(true);
+        public ListAdapter getAdapter() {
+            return mAdapter;
         }
 
-        int pos = position + getHeaderViewsCount();
-        mFirstExpPos = pos;
-        mSecondExpPos = pos;
-        mSrcPos = pos;
-        mFloatPos = pos;
+        @Override
+        public long getItemId(int position) {
+            return mAdapter.getItemId(position);
+        }
 
-        // mDragState = dragType;
-        mDragState = DRAGGING;
-        mDragFlags = 0;
-        mDragFlags |= dragFlags;
+        @Override
+        public Object getItem(int position) {
+            return mAdapter.getItem(position);
+        }
 
-        mFloatView = floatView;
-        measureFloatView(); // sets mFloatViewHeight
+        @Override
+        public int getCount() {
+            return mAdapter.getCount();
+        }
 
-        mDragDeltaX = deltaX;
-        mDragDeltaY = deltaY;
-        // mDragStartY = mY;
+        @Override
+        public boolean areAllItemsEnabled() {
+            return mAdapter.areAllItemsEnabled();
+        }
 
-        // updateFloatView(mX - mDragDeltaX, mY - mDragDeltaY);
-        mFloatLoc.x = mX - mDragDeltaX;
-        mFloatLoc.y = mY - mDragDeltaY;
+        @Override
+        public boolean isEnabled(int position) {
+            return mAdapter.isEnabled(position);
+        }
 
-        // set src item invisible
-        final View srcItem = getChildAt(mSrcPos - getFirstVisiblePosition());
+        @Override
+        public int getItemViewType(int position) {
+            return mAdapter.getItemViewType(position);
+        }
 
-        if (srcItem != null) {
-            srcItem.setVisibility(View.INVISIBLE);
+        @Override
+        public int getViewTypeCount() {
+            return mAdapter.getViewTypeCount();
         }
 
-        if (mTrackDragSort) {
-            mDragSortTracker.startTracking();
+        @Override
+        public boolean hasStableIds() {
+            return mAdapter.hasStableIds();
         }
 
-        // once float view is created, events are no longer passed
-        // to ListView
-        switch (mCancelMethod) {
-            case ON_TOUCH_EVENT:
-                super.onTouchEvent(mCancelEvent);
-                break;
-            case ON_INTERCEPT_TOUCH_EVENT:
-                super.onInterceptTouchEvent(mCancelEvent);
-                break;
+        @Override
+        public boolean isEmpty() {
+            return mAdapter.isEmpty();
         }
 
-        requestLayout();
+        @Override
+        public View getView(int position, View convertView, ViewGroup parent) {
 
-        if (mLiftAnimator != null) {
-            mLiftAnimator.start();
-        }
+            DragSortItemView v;
+            View child;
+            // Log.d("mobeta",
+            // "getView: position="+position+" convertView="+convertView);
+            if (convertView != null) {
+                v = (DragSortItemView) convertView;
+                View oldChild = v.getChildAt(0);
 
-        return true;
-    }
+                child = mAdapter.getView(position, oldChild, DragSortListView.this);
+                if (child != oldChild) {
+                    // shouldn't get here if user is reusing convertViews
+                    // properly
+                    if (oldChild != null) {
+                        v.removeViewAt(0);
+                    }
+                    v.addView(child);
+                }
+            } else {
+                child = mAdapter.getView(position, null, DragSortListView.this);
+                if (child instanceof Checkable) {
+                    v = new DragSortItemViewCheckable(getContext());
+                } else {
+                    v = new DragSortItemView(getContext());
+                }
+                v.setLayoutParams(new AbsListView.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
+                        ViewGroup.LayoutParams.WRAP_CONTENT));
+                v.addView(child);
+            }
 
-    private void doDragFloatView(boolean forceInvalidate) {
-        int movePos = getFirstVisiblePosition() + getChildCount() / 2;
-        View moveItem = getChildAt(getChildCount() / 2);
+            // Set the correct item height given drag state; passed
+            // View needs to be measured if measurement is required.
+            adjustItem(position + getHeaderViewsCount(), v, true);
 
-        if (moveItem == null) {
-            return;
+            return v;
         }
-
-        doDragFloatView(movePos, moveItem, forceInvalidate);
     }
 
-    private void doDragFloatView(int movePos, View moveItem, boolean forceInvalidate) {
-        mBlockLayoutRequests = true;
+    private class HeightCache {
 
-        updateFloatView();
+        private SparseIntArray mMap;
 
-        int oldFirstExpPos = mFirstExpPos;
-        int oldSecondExpPos = mSecondExpPos;
+        private ArrayList<Integer> mOrder;
 
-        boolean updated = updatePositions();
+        private int mMaxSize;
 
-        if (updated) {
-            adjustAllItems();
-            int scroll = adjustScroll(movePos, moveItem, oldFirstExpPos, oldSecondExpPos);
-            // Log.d("mobeta", " adjust scroll="+scroll);
+        public HeightCache(int size) {
+            mMap = new SparseIntArray(size);
+            mOrder = new ArrayList<Integer>(size);
+            mMaxSize = size;
+        }
 
-            setSelectionFromTop(movePos, moveItem.getTop() + scroll - getPaddingTop());
-            layoutChildren();
+        /**
+         * Add item height at position if doesn't already exist.
+         */
+        public void add(int position, int height) {
+            int currHeight = mMap.get(position, -1);
+            if (currHeight != height) {
+                if (currHeight == -1) {
+                    if (mMap.size() == mMaxSize) {
+                        // remove oldest entry
+                        mMap.delete(mOrder.remove(0));
+                    }
+                } else {
+                    // move position to newest slot
+                    mOrder.remove((Integer) position);
+                }
+                mMap.put(position, height);
+                mOrder.add(position);
+            }
         }
 
-        if (updated || forceInvalidate) {
-            invalidate();
+        public int get(int position) {
+            return mMap.get(position, -1);
+        }
+
+        public void clear() {
+            mMap.clear();
+            mOrder.clear();
         }
 
-        mBlockLayoutRequests = false;
     }
 
-    /**
-     * Sets float View location based on suggested values and constraints set in
-     * mDragFlags.
-     */
-    private void updateFloatView() {
+    private class SmoothAnimator implements Runnable {
+        protected long mStartTime;
 
-        if (mFloatViewManager != null) {
-            mTouchLoc.set(mX, mY);
-            mFloatViewManager.onDragFloatView(mFloatView, mFloatLoc, mTouchLoc);
-        }
+        private float mDurationF;
 
-        final int floatX = mFloatLoc.x;
-        final int floatY = mFloatLoc.y;
+        private float mAlpha;
 
-        // restrict x motion
-        int padLeft = getPaddingLeft();
-        if ((mDragFlags & DRAG_POS_X) == 0 && floatX > padLeft) {
-            mFloatLoc.x = padLeft;
-        } else if ((mDragFlags & DRAG_NEG_X) == 0 && floatX < padLeft) {
-            mFloatLoc.x = padLeft;
-        }
+        private float mA, mB, mC, mD;
 
-        // keep floating view from going past bottom of last header view
-        final int numHeaders = getHeaderViewsCount();
-        final int numFooters = getFooterViewsCount();
-        final int firstPos = getFirstVisiblePosition();
-        final int lastPos = getLastVisiblePosition();
+        private boolean mCanceled;
 
-        // Log.d("mobeta",
-        // "nHead="+numHeaders+" nFoot="+numFooters+" first="+firstPos+"
-        // last="+lastPos);
-        int topLimit = getPaddingTop();
-        if (firstPos < numHeaders) {
-            topLimit = getChildAt(numHeaders - firstPos - 1).getBottom();
+        public SmoothAnimator(float smoothness, int duration) {
+            mAlpha = smoothness;
+            mDurationF = (float) duration;
+            mA = mD = 1f / (2f * mAlpha * (1f - mAlpha));
+            mB = mAlpha / (2f * (mAlpha - 1f));
+            mC = 1f / (1f - mAlpha);
         }
-        if ((mDragFlags & DRAG_NEG_Y) == 0) {
-            if (firstPos <= mSrcPos) {
-                topLimit = Math.max(getChildAt(mSrcPos - firstPos).getTop(), topLimit);
+
+        public float transform(float frac) {
+            if (frac < mAlpha) {
+                return mA * frac * frac;
+            } else if (frac < 1f - mAlpha) {
+                return mB + mC * frac;
+            } else {
+                return 1f - mD * (frac - 1f) * (frac - 1f);
             }
         }
-        // bottom limit is top of first footer View or
-        // bottom of last item in list
-        int bottomLimit = getHeight() - getPaddingBottom();
-        if (lastPos >= getCount() - numFooters - 1) {
-            bottomLimit = getChildAt(getCount() - numFooters - 1 - firstPos).getBottom();
+
+        public void start() {
+            mStartTime = SystemClock.uptimeMillis();
+            mCanceled = false;
+            onStart();
+            post(this);
         }
-        if ((mDragFlags & DRAG_POS_Y) == 0) {
-            if (lastPos >= mSrcPos) {
-                bottomLimit = Math.min(getChildAt(mSrcPos - firstPos).getBottom(), bottomLimit);
-            }
+
+        public void cancel() {
+            mCanceled = true;
+        }
+
+        public void onStart() {
+            // stub
         }
 
-        // Log.d("mobeta", "dragView top=" + (y - mDragDeltaY));
-        // Log.d("mobeta", "limit=" + limit);
-        // Log.d("mobeta", "mDragDeltaY=" + mDragDeltaY);
+        public void onUpdate(float frac, float smoothFrac) {
+            // stub
+        }
 
-        if (floatY < topLimit) {
-            mFloatLoc.y = topLimit;
-        } else if (floatY + mFloatViewHeight > bottomLimit) {
-            mFloatLoc.y = bottomLimit - mFloatViewHeight;
+        public void onStop() {
+            // stub
         }
 
-        // get y-midpoint of floating view (constrained to ListView bounds)
-        mFloatViewMid = mFloatLoc.y + mFloatViewHeightHalf;
-    }
+        @Override
+        public void run() {
+            if (mCanceled) {
+                return;
+            }
 
-    private void destroyFloatView() {
-        if (mFloatView != null) {
-            mFloatView.setVisibility(GONE);
-            if (mFloatViewManager != null) {
-                mFloatViewManager.onDestroyFloatView(mFloatView);
+            float fraction = ((float) (SystemClock.uptimeMillis() - mStartTime)) / mDurationF;
+
+            if (fraction >= 1f) {
+                onUpdate(1f, 1f);
+                onStop();
+            } else {
+                onUpdate(fraction, transform(fraction));
+                post(this);
             }
-            mFloatView = null;
-            invalidate();
         }
     }
 
     /**
-     * Interface for customization of the floating View appearance and dragging
-     * behavior. Implement your own and pass it to {@link #setFloatViewManager}.
-     * If your own is not passed, the default {@link SimpleFloatViewManager}
-     * implementation is used.
+     * Centers floating View under touch point.
      */
-    public interface FloatViewManager {
-        /**
-         * Return the floating View for item at <code>position</code>.
-         * DragSortListView will measure and layout this View for you, so feel
-         * free to just inflate it. You can help DSLV by setting some
-         * {@link ViewGroup.LayoutParams} on this View; otherwise it will set
-         * some for you (with a width of FILL_PARENT and a height of
-         * WRAP_CONTENT).
-         * 
-         * @param position Position of item to drag (NOTE: <code>position</code>
-         *            excludes header Views; thus, if you want to call
-         *            {@link ListView#getChildAt(int)}, you will need to add
-         *            {@link ListView#getHeaderViewsCount()} to the index).
-         * @return The View you wish to display as the floating View.
-         */
-        public View onCreateFloatView(int position);
-
-        /**
-         * Called whenever the floating View is dragged. Float View properties
-         * can be changed here. Also, the upcoming location of the float View
-         * can be altered by setting <code>location.x</code> and
-         * <code>location.y</code>.
-         * 
-         * @param floatView The floating View.
-         * @param location The location (top-left; relative to DSLV top-left) at
-         *            which the float View would like to appear, given the
-         *            current touch location and the offset provided in
-         *            {@link DragSortListView#startDrag}.
-         * @param touch The current touch location (relative to DSLV top-left).
-         * @param pendingScroll
-         */
-        public void onDragFloatView(View floatView, Point location, Point touch);
-
-        /**
-         * Called when the float View is dropped; lets you perform any necessary
-         * cleanup. The internal DSLV floating View reference is set to null
-         * immediately after this is called.
-         * 
-         * @param floatView The floating View passed to
-         *            {@link #onCreateFloatView(int)}.
-         */
-        public void onDestroyFloatView(View floatView);
-    }
+    private class LiftAnimator extends SmoothAnimator {
 
-    public void setFloatViewManager(FloatViewManager manager) {
-        mFloatViewManager = manager;
-    }
+        private float mInitDragDeltaY;
 
-    public void setDragListener(DragListener l) {
-        mDragListener = l;
-    }
+        private float mFinalDragDeltaY;
 
-    /**
-     * Allows for easy toggling between a DragSortListView and a regular old
-     * ListView. If enabled, items are draggable, where the drag init mode
-     * determines how items are lifted (see {@link setDragInitMode(int)}). If
-     * disabled, items cannot be dragged.
-     * 
-     * @param enabled Set <code>true</code> to enable list item dragging
-     */
-    public void setDragEnabled(boolean enabled) {
-        mDragEnabled = enabled;
-    }
+        public LiftAnimator(float smoothness, int duration) {
+            super(smoothness, duration);
+        }
 
-    public boolean isDragEnabled() {
-        return mDragEnabled;
-    }
+        @Override
+        public void onStart() {
+            mInitDragDeltaY = mDragDeltaY;
+            mFinalDragDeltaY = mFloatViewHeightHalf;
+        }
 
-    /**
-     * This better reorder your ListAdapter! DragSortListView does not do this
-     * for you; doesn't make sense to. Make sure
-     * {@link BaseAdapter#notifyDataSetChanged()} or something like it is called
-     * in your implementation. Furthermore, if you have a choiceMode other than
-     * none and the ListAdapter does not return true for
-     * {@link ListAdapter#hasStableIds()}, you will need to call
-     * {@link #moveCheckState(int, int)} to move the check boxes along with the
-     * list items.
-     * 
-     * @param l
-     */
-    public void setDropListener(DropListener l) {
-        mDropListener = l;
+        @Override
+        public void onUpdate(float frac, float smoothFrac) {
+            if (mDragState != DRAGGING) {
+                cancel();
+            } else {
+                mDragDeltaY = (int) (smoothFrac * mFinalDragDeltaY + (1f - smoothFrac) * mInitDragDeltaY);
+                mFloatLoc.y = mY - mDragDeltaY;
+                doDragFloatView(true);
+            }
+        }
     }
 
     /**
-     * Probably a no-brainer, but make sure that your remove listener calls
-     * {@link BaseAdapter#notifyDataSetChanged()} or something like it. When an
-     * item removal occurs, DragSortListView relies on a redraw of all the items
-     * to recover invisible views and such. Strictly speaking, if you remove
-     * something, your dataset has changed...
-     * 
-     * @param l
+     * Centers floating View over drop slot before destroying.
      */
-    public void setRemoveListener(RemoveListener l) {
-        mRemoveListener = l;
-    }
-
-    public interface DragListener {
-        public void drag(int from, int to);
-    }
+    private class DropAnimator extends SmoothAnimator {
 
-    /**
-     * Your implementation of this has to reorder your ListAdapter! Make sure to
-     * call {@link BaseAdapter#notifyDataSetChanged()} or something like it in
-     * your implementation.
-     * 
-     * @author heycosmo
-     */
-    public interface DropListener {
-        public void drop(int from, int to);
-    }
+        private int mDropPos;
 
-    /**
-     * Make sure to call {@link BaseAdapter#notifyDataSetChanged()} or something
-     * like it in your implementation.
-     * 
-     * @author heycosmo
-     */
-    public interface RemoveListener {
-        public void remove(int which);
-    }
+        private int srcPos;
 
-    public interface DragSortListener extends DropListener, DragListener, RemoveListener {
-    }
+        private float mInitDeltaY;
 
-    public void setDragSortListener(DragSortListener l) {
-        setDropListener(l);
-        setDragListener(l);
-        setRemoveListener(l);
-    }
+        private float mInitDeltaX;
 
-    /**
-     * Completely custom scroll speed profile. Default increases linearly with
-     * position and is constant in time. Create your own by implementing
-     * {@link DragSortListView.DragScrollProfile}.
-     * 
-     * @param ssp
-     */
-    public void setDragScrollProfile(DragScrollProfile ssp) {
-        if (ssp != null) {
-            mScrollProfile = ssp;
+        public DropAnimator(float smoothness, int duration) {
+            super(smoothness, duration);
         }
-    }
 
-    /**
-     * Use this to move the check state of an item from one position to another
-     * in a drop operation. If you have a choiceMode which is not none, this
-     * method must be called when the order of items changes in an underlying
-     * adapter which does not have stable IDs (see
-     * {@link ListAdapter#hasStableIds()}). This is because without IDs, the
-     * ListView has no way of knowing which items have moved where, and cannot
-     * update the check state accordingly.
-     * <p>
-     * A word of warning about a "feature" in Android that you may run into when
-     * dealing with movable list items: for an adapter that <em>does</em> have
-     * stable IDs, ListView will attempt to locate each item based on its ID and
-     * move the check state from the item's old position to the new position 
-     * which is all fine and good (and removes the need for calling this
-     * function), except for the half-baked approach. Apparently to save time in
-     * the naive algorithm used, ListView will only search for an ID in the
-     * close neighborhood of the old position. If the user moves an item too far
-     * (specifically, more than 20 rows away), ListView will give up and just
-     * force the item to be unchecked. So if there is a reasonable chance that
-     * the user will move items more than 20 rows away from the original
-     * position, you may wish to use an adapter with unstable IDs and call this
-     * method manually instead.
-     * 
-     * @param from
-     * @param to
-     */
-    public void moveCheckState(int from, int to) {
-        // This method runs in O(n log n) time (n being the number of list
-        // items). The bottleneck is the call to AbsListView.setItemChecked,
-        // which is O(log n) because of the binary search involved in calling
-        // SparseBooleanArray.put().
-        //
-        // To improve on the average time, we minimize the number of calls to
-        // setItemChecked by only calling it for items that actually have a
-        // changed state. This is achieved by building a list containing the
-        // start and end of the "runs" of checked items, and then moving the
-        // runs. Note that moving an item from A to B is essentially a rotation
-        // of the range of items in [A, B]. Let's say we have
-        // . . U V X Y Z . .
-        // and move U after Z. This is equivalent to a rotation one step to the
-        // left within the range you are moving across:
-        // . . V X Y Z U . .
-        //
-        // So, to perform the move we enumerate all the runs within the move
-        // range, then rotate each run one step to the left or right (depending
-        // on move direction). For example, in the list:
-        // X X . X X X . X
-        // we have two runs. One begins at the last item of the list and wraps
-        // around to the beginning, ending at position 1. The second begins at
-        // position 3 and ends at position 5. To rotate a run, regardless of
-        // length, we only need to set a check mark at one end of the run, and
-        // clear a check mark at the other end:
-        // X . X X X . X X
-        SparseBooleanArray cip = getCheckedItemPositions();
-        int rangeStart = from;
-        int rangeEnd = to;
-        if (to < from) {
-            rangeStart = to;
-            rangeEnd = from;
+        @Override
+        public void onStart() {
+            mDropPos = mFloatPos;
+            srcPos = mSrcPos;
+            mDragState = DROPPING;
+            mInitDeltaY = mFloatLoc.y - getTargetY();
+            mInitDeltaX = mFloatLoc.x - getPaddingLeft();
         }
-        rangeEnd += 1;
 
-        int[] runStart = new int[cip.size()];
-        int[] runEnd = new int[cip.size()];
-        int runCount = buildRunList(cip, rangeStart, rangeEnd, runStart, runEnd);
-        if (runCount == 1 && (runStart[0] == runEnd[0])) {
-            // Special case where all items are checked, we can never set any
-            // item to false like we do below.
-            return;
+        private int getTargetY() {
+            final int first = getFirstVisiblePosition();
+            final int otherAdjust = (mItemHeightCollapsed + getDividerHeight()) / 2;
+            View v = getChildAt(mDropPos - first);
+            int targetY = -1;
+            if (v != null) {
+                if (mDropPos == srcPos) {
+                    targetY = v.getTop();
+                } else if (mDropPos < srcPos) {
+                    // expanded down
+                    targetY = v.getTop() - otherAdjust;
+                } else {
+                    // expanded up
+                    targetY = v.getBottom() + otherAdjust - mFloatViewHeight;
+                }
+            } else {
+                // drop position is not on screen?? no animation
+                cancel();
+            }
+
+            return targetY;
         }
 
-        if (from < to) {
-            for (int i = 0; i != runCount; i++) {
-                setItemChecked(rotate(runStart[i], -1, rangeStart, rangeEnd), true);
-                setItemChecked(rotate(runEnd[i], -1, rangeStart, rangeEnd), false);
+        @Override
+        public void onUpdate(float frac, float smoothFrac) {
+            final int targetY = getTargetY();
+            final int targetX = getPaddingLeft();
+            final float deltaY = mFloatLoc.y - targetY;
+            final float deltaX = mFloatLoc.x - targetX;
+            final float f = 1f - smoothFrac;
+            if (f < Math.abs(deltaY / mInitDeltaY) || f < Math.abs(deltaX / mInitDeltaX)) {
+                mFloatLoc.y = targetY + (int) (mInitDeltaY * f);
+                mFloatLoc.x = getPaddingLeft() + (int) (mInitDeltaX * f);
+                doDragFloatView(true);
             }
+        }
 
-        } else {
-            for (int i = 0; i != runCount; i++) {
-                setItemChecked(runStart[i], false);
-                setItemChecked(runEnd[i], true);
-            }
+        @Override
+        public void onStop() {
+            dropFloatView();
         }
+
     }
 
     /**
-     * Use this when an item has been deleted, to move the check state of all
-     * following items up one step. If you have a choiceMode which is not none,
-     * this method must be called when the order of items changes in an
-     * underlying adapter which does not have stable IDs (see
-     * {@link ListAdapter#hasStableIds()}). This is because without IDs, the
-     * ListView has no way of knowing which items have moved where, and cannot
-     * update the check state accordingly. See also further comments on
-     * {@link #moveCheckState(int, int)}.
-     * 
-     * @param position
+     * Collapses expanded items.
      */
-    public void removeCheckState(int position) {
-        SparseBooleanArray cip = getCheckedItemPositions();
+    private class RemoveAnimator extends SmoothAnimator {
 
-        if (cip.size() == 0)
-            return;
-        int[] runStart = new int[cip.size()];
-        int[] runEnd = new int[cip.size()];
-        int rangeStart = position;
-        int rangeEnd = cip.keyAt(cip.size() - 1) + 1;
-        int runCount = buildRunList(cip, rangeStart, rangeEnd, runStart, runEnd);
-        for (int i = 0; i != runCount; i++) {
-            if (!(runStart[i] == position || (runEnd[i] < runStart[i] && runEnd[i] > position))) {
-                // Only set a new check mark in front of this run if it does
-                // not contain the deleted position. If it does, we only need
-                // to make it one check mark shorter at the end.
-                setItemChecked(rotate(runStart[i], -1, rangeStart, rangeEnd), true);
-            }
-            setItemChecked(rotate(runEnd[i], -1, rangeStart, rangeEnd), false);
-        }
-    }
+        private float mFloatLocX;
 
-    private static int buildRunList(SparseBooleanArray cip, int rangeStart, int rangeEnd, int[] runStart,
-            int[] runEnd) {
-        int runCount = 0;
+        private float mFirstStartBlank;
 
-        int i = findFirstSetIndex(cip, rangeStart, rangeEnd);
-        if (i == -1)
-            return 0;
+        private float mSecondStartBlank;
 
-        int position = cip.keyAt(i);
-        int currentRunStart = position;
-        int currentRunEnd = currentRunStart + 1;
-        for (i++; i < cip.size() && (position = cip.keyAt(i)) < rangeEnd; i++) {
-            if (!cip.valueAt(i)) // not checked => not interesting
-                continue;
-            if (position == currentRunEnd) {
-                currentRunEnd++;
-            } else {
-                runStart[runCount] = currentRunStart;
-                runEnd[runCount] = currentRunEnd;
-                runCount++;
-                currentRunStart = position;
-                currentRunEnd = position + 1;
-            }
-        }
+        private int mFirstChildHeight = -1;
 
-        if (currentRunEnd == rangeEnd) {
-            // rangeStart and rangeEnd are equivalent positions so to be
-            // consistent we translate them to the same integer value. That way
-            // we can check whether a run covers the entire range by just
-            // checking if the start equals the end position.
-            currentRunEnd = rangeStart;
+        private int mSecondChildHeight = -1;
+
+        private int mFirstPos;
+
+        private int mSecondPos;
+
+        // private int srcPos;
+
+        public RemoveAnimator(float smoothness, int duration) {
+            super(smoothness, duration);
         }
-        runStart[runCount] = currentRunStart;
-        runEnd[runCount] = currentRunEnd;
-        runCount++;
 
-        if (runCount > 1) {
-            if (runStart[0] == rangeStart && runEnd[runCount - 1] == rangeStart) {
-                // The last run ends at the end of the range, and the first run
-                // starts at the beginning of the range. So they are actually
-                // part of the same run, except they wrap around the end of the
-                // range. To avoid adjacent runs, we need to merge them.
-                runStart[0] = runStart[runCount - 1];
-                runCount--;
+        @Override
+        public void onStart() {
+            mFirstChildHeight = -1;
+            mSecondChildHeight = -1;
+            mFirstPos = mFirstExpPos;
+            mSecondPos = mSecondExpPos;
+            // srcPos = mSrcPos;
+            mDragState = REMOVING;
+
+            mFloatLocX = mFloatLoc.x;
+            if (mUseRemoveVelocity) {
+                float minVelocity = 2f * getWidth();
+                if (mRemoveVelocityX == 0) {
+                    mRemoveVelocityX = (mFloatLocX < 0 ? -1 : 1) * minVelocity;
+                } else {
+                    minVelocity *= 2;
+                    if (mRemoveVelocityX < 0 && mRemoveVelocityX > -minVelocity)
+                        mRemoveVelocityX = -minVelocity;
+                    else if (mRemoveVelocityX > 0 && mRemoveVelocityX < minVelocity)
+                        mRemoveVelocityX = minVelocity;
+                }
+            } else {
+                destroyFloatView();
             }
         }
-        return runCount;
-    }
 
-    private static int rotate(int value, int offset, int lowerBound, int upperBound) {
-        int windowSize = upperBound - lowerBound;
+        @Override
+        public void onUpdate(float frac, float smoothFrac) {
+            float f = 1f - smoothFrac;
 
-        value += offset;
-        if (value < lowerBound) {
-            value += windowSize;
-        } else if (value >= upperBound) {
-            value -= windowSize;
-        }
-        return value;
-    }
+            final int firstVis = getFirstVisiblePosition();
+            View item = getChildAt(mFirstPos - firstVis);
+            ViewGroup.LayoutParams lp;
+            int blank;
 
-    private static int findFirstSetIndex(SparseBooleanArray sba, int rangeStart, int rangeEnd) {
-        int size = sba.size();
-        int i = insertionIndexForKey(sba, rangeStart);
-        while (i < size && sba.keyAt(i) < rangeEnd && !sba.valueAt(i))
-            i++;
-        if (i == size || sba.keyAt(i) >= rangeEnd)
-            return -1;
-        return i;
-    }
+            if (mUseRemoveVelocity) {
+                float dt = (float) (SystemClock.uptimeMillis() - mStartTime) / 1000;
+                if (dt == 0)
+                    return;
+                float dx = mRemoveVelocityX * dt;
+                int w = getWidth();
+                mRemoveVelocityX += (mRemoveVelocityX > 0 ? 1 : -1) * dt * w;
+                mFloatLocX += dx;
+                mFloatLoc.x = (int) mFloatLocX;
+                if (mFloatLocX < w && mFloatLocX > -w) {
+                    mStartTime = SystemClock.uptimeMillis();
+                    doDragFloatView(true);
+                    return;
+                }
+            }
 
-    private static int insertionIndexForKey(SparseBooleanArray sba, int key) {
-        int low = 0;
-        int high = sba.size();
-        while (high - low > 0) {
-            int middle = (low + high) >> 1;
-            if (sba.keyAt(middle) < key)
-                low = middle + 1;
-            else
-                high = middle;
+            if (item != null) {
+                if (mFirstChildHeight == -1) {
+                    mFirstChildHeight = getChildHeight(mFirstPos, item, false);
+                    mFirstStartBlank = (float) (item.getHeight() - mFirstChildHeight);
+                }
+                blank = Math.max((int) (f * mFirstStartBlank), 1);
+                lp = item.getLayoutParams();
+                lp.height = mFirstChildHeight + blank;
+                item.setLayoutParams(lp);
+            }
+            if (mSecondPos != mFirstPos) {
+                item = getChildAt(mSecondPos - firstVis);
+                if (item != null) {
+                    if (mSecondChildHeight == -1) {
+                        mSecondChildHeight = getChildHeight(mSecondPos, item, false);
+                        mSecondStartBlank = (float) (item.getHeight() - mSecondChildHeight);
+                    }
+                    blank = Math.max((int) (f * mSecondStartBlank), 1);
+                    lp = item.getLayoutParams();
+                    lp.height = mSecondChildHeight + blank;
+                    item.setLayoutParams(lp);
+                }
+            }
         }
-        return low;
-    }
 
-    /**
-     * Interface for controlling scroll speed as a function of touch position
-     * and time. Use
-     * {@link DragSortListView#setDragScrollProfile(DragScrollProfile)} to set
-     * custom profile.
-     * 
-     * @author heycosmo
-     */
-    public interface DragScrollProfile {
-        /**
-         * Return a scroll speed in pixels/millisecond. Always return a positive
-         * number.
-         * 
-         * @param w Normalized position in scroll region (i.e. w \in [0,1]).
-         *            Small w typically means slow scrolling.
-         * @param t Time (in milliseconds) since start of scroll (handy if you
-         *            want scroll acceleration).
-         * @return Scroll speed at position w and time t in pixels/ms.
-         */
-        float getSpeed(float w, long t);
+        @Override
+        public void onStop() {
+            doRemoveItem();
+        }
     }
 
     private class DragScroller implements Runnable {
 
+        public final static int STOP = -1;
+        public final static int UP = 0;
+        public final static int DOWN = 1;
         private boolean mAbort;
-
         private long mPrevTime;
-
         private long mCurrTime;
-
         private int dy;
-
         private float dt;
-
         private long tStart;
-
         private int scrollDir;
-
-        public final static int STOP = -1;
-
-        public final static int UP = 0;
-
-        public final static int DOWN = 1;
-
         private float mScrollSpeed; // pixels per ms
 
         private boolean mScrolling = false;
@@ -2773,6 +2697,9 @@ public class DragSortListView extends ListView {
         // private int mLastHeader;
         // private int mFirstFooter;
 
+        public DragScroller() {
+        }
+
         public boolean isScrolling() {
             return mScrolling;
         }
@@ -2781,9 +2708,6 @@ public class DragSortListView extends ListView {
             return mScrolling ? scrollDir : STOP;
         }
 
-        public DragScroller() {
-        }
-
         public void startScrolling(int dir) {
             if (!mScrolling) {
                 // Debug.startMethodTracing("dslv-scroll");
@@ -2853,13 +2777,13 @@ public class DragSortListView extends ListView {
             }
 
             mCurrTime = SystemClock.uptimeMillis();
-            dt = (float)(mCurrTime - mPrevTime);
+            dt = (float) (mCurrTime - mPrevTime);
 
             // dy is change in View position of a list item; i.e. positive dy
             // means user is scrolling up (list item moves down the screen,
             // remember
             // y=0 is at top of View).
-            dy = (int)Math.round(mScrollSpeed * dt);
+            dy = (int) Math.round(mScrollSpeed * dt);
 
             int movePos;
             if (dy >= 0) {
diff --git a/qDict/src/main/java/com/mmt/widget/DropDownListView.java b/qDict/src/main/java/com/mmt/widget/DropDownListView.java
index 2ac59c0..e1f9ef6 100644
--- a/qDict/src/main/java/com/mmt/widget/DropDownListView.java
+++ b/qDict/src/main/java/com/mmt/widget/DropDownListView.java
@@ -1,4 +1,3 @@
-
 package com.mmt.widget;
 
 import android.annotation.TargetApi;
diff --git a/qDict/src/main/java/com/mmt/widget/M2tListView.java b/qDict/src/main/java/com/mmt/widget/M2tListView.java
index ffd719f..0a7e161 100644
--- a/qDict/src/main/java/com/mmt/widget/M2tListView.java
+++ b/qDict/src/main/java/com/mmt/widget/M2tListView.java
@@ -1,4 +1,3 @@
-
 package com.mmt.widget;
 
 import android.content.Context;
@@ -26,6 +25,10 @@ public class M2tListView extends ListView {
         return expanded;
     }
 
+    public void setExpanded(boolean expanded) {
+        this.expanded = expanded;
+    }
+
     @Override
     public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
         // HACK! TAKE THAT ANDROID!
@@ -42,8 +45,4 @@ public class M2tListView extends ListView {
             super.onMeasure(widthMeasureSpec, heightMeasureSpec);
         }
     }
-
-    public void setExpanded(boolean expanded) {
-        this.expanded = expanded;
-    }
 }
diff --git a/qDict/src/main/java/com/mmt/widget/M2tToast.java b/qDict/src/main/java/com/mmt/widget/M2tToast.java
index 1ba972f..635c053 100644
--- a/qDict/src/main/java/com/mmt/widget/M2tToast.java
+++ b/qDict/src/main/java/com/mmt/widget/M2tToast.java
@@ -1,8 +1,5 @@
-
 package com.mmt.widget;
 
-import com.annie.dictionary.R;
-
 import android.content.Context;
 import android.content.res.Resources;
 import android.graphics.Color;
@@ -13,6 +10,8 @@ import android.view.View;
 import android.widget.TextView;
 import android.widget.Toast;
 
+import com.annie.dictionary.R;
+
 public class M2tToast extends Toast {
 
     private static int SHADOW_TEXTVIEW = 1;
@@ -20,22 +19,21 @@ public class M2tToast extends Toast {
     private static M2tToast mInstance;
 
     private static int mToastYOffset;
+    private static TextView tvMessage;
 
     public M2tToast(Context context) {
         super(context);
     }
 
-    private static TextView tvMessage;
-
     public static M2tToast makeText(Context context, CharSequence text, int duration) {
         if (mInstance == null) {
             mInstance = new M2tToast(context);
         }
 
-        LayoutInflater inflate = (LayoutInflater)context.getApplicationContext()
+        LayoutInflater inflate = (LayoutInflater) context.getApplicationContext()
                 .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
         View v = inflate.inflate(R.layout.transient_notification, null);
-        tvMessage = (TextView)v.findViewById(android.R.id.message);
+        tvMessage = (TextView) v.findViewById(android.R.id.message);
         tvMessage.setGravity(Gravity.CENTER_VERTICAL);
         tvMessage.setText(text);
         tvMessage.setTypeface(Typeface.defaultFromStyle(Typeface.NORMAL));
@@ -49,14 +47,14 @@ public class M2tToast extends Toast {
         return mInstance;
     }
 
-    public void setTypeface(Typeface typeface) {
-        tvMessage.setTypeface(typeface);
-    }
-
     public static M2tToast makeText(Context context, int resId, int duration) throws Resources.NotFoundException {
         return makeText(context, context.getResources().getText(resId), duration);
     }
 
+    public void setTypeface(Typeface typeface) {
+        tvMessage.setTypeface(typeface);
+    }
+
     public M2tToast setToastOnTop() {
         if (mInstance == null) {
             throw new RuntimeException("Must call makeText method first");
diff --git a/qDict/src/main/java/com/mmt/widget/QButton.java b/qDict/src/main/java/com/mmt/widget/QButton.java
index 88d5518..4ef6d3e 100644
--- a/qDict/src/main/java/com/mmt/widget/QButton.java
+++ b/qDict/src/main/java/com/mmt/widget/QButton.java
@@ -1,9 +1,5 @@
-
 package com.mmt.widget;
 
-import com.annie.dictionary.utils.Utils;
-import com.annie.dictionary.utils.Utils.Def;
-
 import android.annotation.TargetApi;
 import android.content.Context;
 import android.content.SharedPreferences;
@@ -11,6 +7,9 @@ import android.graphics.Typeface;
 import android.util.AttributeSet;
 import android.widget.Button;
 
+import com.annie.dictionary.utils.Utils;
+import com.annie.dictionary.utils.Utils.Def;
+
 /**
  * Extends widget.Button: Custom font for Button
  */
@@ -27,13 +26,13 @@ public class QButton extends Button {
         init(context, attrs);
     }
 
+    public QButton(Context context) {
+        super(context);
+    }
+
     private void init(Context context, AttributeSet attrs) {
         SharedPreferences mSharedPreferences = context.getSharedPreferences(Def.APP_NAME, Context.MODE_PRIVATE);
         Typeface mFont = Utils.getFont(context, mSharedPreferences.getString(Def.PREF_KEY_FONT, Def.DEFAULT_FONT));
         setTypeface(mFont);
     }
-
-    public QButton(Context context) {
-        super(context);
-    }
 }
diff --git a/qDict/src/main/java/com/mmt/widget/QCheckedTextView.java b/qDict/src/main/java/com/mmt/widget/QCheckedTextView.java
index f0d40f9..1193e41 100644
--- a/qDict/src/main/java/com/mmt/widget/QCheckedTextView.java
+++ b/qDict/src/main/java/com/mmt/widget/QCheckedTextView.java
@@ -1,9 +1,5 @@
-
 package com.mmt.widget;
 
-import com.annie.dictionary.utils.Utils;
-import com.annie.dictionary.utils.Utils.Def;
-
 import android.annotation.TargetApi;
 import android.content.Context;
 import android.content.SharedPreferences;
@@ -11,6 +7,9 @@ import android.graphics.Typeface;
 import android.util.AttributeSet;
 import android.widget.CheckedTextView;
 
+import com.annie.dictionary.utils.Utils;
+import com.annie.dictionary.utils.Utils.Def;
+
 /**
  * Extends widget.CheckedTextView: Custom font for CheckedTextView
  */
@@ -27,17 +26,17 @@ public class QCheckedTextView extends CheckedTextView {
         init(context);
     }
 
+    public QCheckedTextView(Context context) {
+        super(context);
+        init(context);
+    }
+
     private void init(Context context) {
         SharedPreferences mSharedPreferences = context.getSharedPreferences(Def.APP_NAME, Context.MODE_PRIVATE);
         Typeface mFont = Utils.getFont(context, mSharedPreferences.getString(Def.PREF_KEY_FONT, Def.DEFAULT_FONT));
         setTypeface(mFont);
     }
 
-    public QCheckedTextView(Context context) {
-        super(context);
-        init(context);
-    }
-
     public void updateFont(Context context) {
         init(context);
     }
diff --git a/qDict/src/main/java/com/mmt/widget/QEditText.java b/qDict/src/main/java/com/mmt/widget/QEditText.java
index 969fc10..e1c054a 100644
--- a/qDict/src/main/java/com/mmt/widget/QEditText.java
+++ b/qDict/src/main/java/com/mmt/widget/QEditText.java
@@ -1,9 +1,5 @@
-
 package com.mmt.widget;
 
-import com.annie.dictionary.utils.Utils;
-import com.annie.dictionary.utils.Utils.Def;
-
 import android.annotation.TargetApi;
 import android.content.Context;
 import android.content.SharedPreferences;
@@ -11,6 +7,9 @@ import android.graphics.Typeface;
 import android.util.AttributeSet;
 import android.widget.EditText;
 
+import com.annie.dictionary.utils.Utils;
+import com.annie.dictionary.utils.Utils.Def;
+
 /**
  * Extends widget.EditText: Custom font for EditText
  */
@@ -27,13 +26,13 @@ public class QEditText extends EditText {
         init(context, attrs);
     }
 
+    public QEditText(Context context) {
+        super(context);
+    }
+
     private void init(Context context, AttributeSet attrs) {
         SharedPreferences mSharedPreferences = context.getSharedPreferences(Def.APP_NAME, Context.MODE_PRIVATE);
         Typeface mFont = Utils.getFont(context, mSharedPreferences.getString(Def.PREF_KEY_FONT, Def.DEFAULT_FONT));
         setTypeface(mFont);
     }
-
-    public QEditText(Context context) {
-        super(context);
-    }
 }
diff --git a/qDict/src/main/java/com/mmt/widget/QTextView.java b/qDict/src/main/java/com/mmt/widget/QTextView.java
index a596ba4..06f04d3 100644
--- a/qDict/src/main/java/com/mmt/widget/QTextView.java
+++ b/qDict/src/main/java/com/mmt/widget/QTextView.java
@@ -1,9 +1,5 @@
-
 package com.mmt.widget;
 
-import com.annie.dictionary.utils.Utils;
-import com.annie.dictionary.utils.Utils.Def;
-
 import android.annotation.TargetApi;
 import android.content.Context;
 import android.content.SharedPreferences;
@@ -11,6 +7,9 @@ import android.graphics.Typeface;
 import android.util.AttributeSet;
 import android.widget.TextView;
 
+import com.annie.dictionary.utils.Utils;
+import com.annie.dictionary.utils.Utils.Def;
+
 /**
  * Extends View.TextView: Custom font for TextView
  */
@@ -27,17 +26,17 @@ public class QTextView extends TextView {
         init(context);
     }
 
+    public QTextView(Context context) {
+        super(context);
+        init(context);
+    }
+
     private void init(Context context) {
         SharedPreferences mSharedPreferences = context.getSharedPreferences(Def.APP_NAME, Context.MODE_PRIVATE);
         Typeface mFont = Utils.getFont(context, mSharedPreferences.getString(Def.PREF_KEY_FONT, Def.DEFAULT_FONT));
         setTypeface(mFont);
     }
 
-    public QTextView(Context context) {
-        super(context);
-        init(context);
-    }
-
     public void updateFont(Context context) {
         init(context);
     }
diff --git a/qDict/src/main/java/com/mmt/widget/SlidingUpPanelLayout.java b/qDict/src/main/java/com/mmt/widget/SlidingUpPanelLayout.java
index e3871f2..b2b213e 100644
--- a/qDict/src/main/java/com/mmt/widget/SlidingUpPanelLayout.java
+++ b/qDict/src/main/java/com/mmt/widget/SlidingUpPanelLayout.java
@@ -1,10 +1,5 @@
-
 package com.mmt.widget;
 
-import com.annie.dictionary.R;
-import com.mmt.widget.slidemenu.SlidingMenu;
-import com.nineoldandroids.view.animation.AnimatorProxy;
-
 import android.annotation.SuppressLint;
 import android.content.Context;
 import android.content.res.TypedArray;
@@ -25,6 +20,10 @@ import android.view.View;
 import android.view.ViewGroup;
 import android.view.accessibility.AccessibilityEvent;
 
+import com.annie.dictionary.R;
+import com.mmt.widget.slidemenu.SlidingMenu;
+import com.nineoldandroids.view.animation.AnimatorProxy;
+
 public class SlidingUpPanelLayout extends ViewGroup {
 
     public static final String TAG = SlidingUpPanelLayout.class.getSimpleName();
@@ -38,170 +37,130 @@ public class SlidingUpPanelLayout extends ViewGroup {
      * Default anchor point height
      */
     private static final float DEFAULT_ANCHOR_POINT = 1.0f; // In relative %
-
-    /**
-     * Default initial state for the component
-     */
-    private static PanelState DEFAULT_SLIDE_STATE = PanelState.HIDDEN;
-
     /**
      * Default height of the shadow above the peeking out panel
      */
     private static final int DEFAULT_SHADOW_HEIGHT = 4; // dp;
-
     /**
      * If no fade color is given by default it will fade to 80% gray.
      */
     private static final int DEFAULT_FADE_COLOR = 0x99000000;
-
     /**
      * Default Minimum velocity that will be detected as a fling
      */
     private static final int DEFAULT_MIN_FLING_VELOCITY = 400; // dips per
-                                                               // second
-
     /**
      * Default is set to false because that is how it was written
      */
     private static final boolean DEFAULT_OVERLAY_FLAG = false;
-
+    // second
     /**
      * Default is set to true for clip panel for performance reasons
      */
     private static final boolean DEFAULT_CLIP_PANEL_FLAG = true;
-
     /**
      * Default attributes for layout
      */
-    private static final int[] DEFAULT_ATTRS = new int[] {
+    private static final int[] DEFAULT_ATTRS = new int[]{
             android.R.attr.gravity
     };
-
-    /**
-     * Minimum velocity that will be detected as a fling
-     */
-    private int mMinFlingVelocity = DEFAULT_MIN_FLING_VELOCITY;
-
-    /**
-     * The fade color used for the panel covered by the slider. 0 = no fading.
-     */
-    private int mCoveredFadeColor = DEFAULT_FADE_COLOR;
-
     /**
      * Default paralax length of the main view
      */
     private static final int DEFAULT_PARALAX_OFFSET = 0;
-
+    /**
+     * Default initial state for the component
+     */
+    private static PanelState DEFAULT_SLIDE_STATE = PanelState.HIDDEN;
     /**
      * The paint used to dim the main layout when sliding
      */
     private final Paint mCoveredFadePaint = new Paint();
-
     /**
      * Drawable used to draw the shadow between panes.
      */
     private final Drawable mShadowDrawable;
-
+    private final ViewDragHelper mDragHelper;
+    private final Rect mTmpRect = new Rect();
+    /**
+     * Minimum velocity that will be detected as a fling
+     */
+    private int mMinFlingVelocity = DEFAULT_MIN_FLING_VELOCITY;
+    /**
+     * The fade color used for the panel covered by the slider. 0 = no fading.
+     */
+    private int mCoveredFadeColor = DEFAULT_FADE_COLOR;
     /**
      * The size of the overhang in pixels.
      */
     private int mPanelHeight = -1;
-
     /**
      * The size of the shadow in pixels.
      */
     private int mShadowHeight = -1;
-
     /**
      * Paralax offset
      */
     private int mParallaxOffset = -1;
-
     /**
      * True if the collapsed panel should be dragged up.
      */
     private boolean mIsSlidingUp;
-
     /**
      * Panel overlays the windows instead of putting it underneath it.
      */
     private boolean mOverlayContent = DEFAULT_OVERLAY_FLAG;
-
     /**
      * The main view is clipped to the main top border
      */
     private boolean mClipPanel = DEFAULT_CLIP_PANEL_FLAG;
-
     /**
      * If provided, the panel can be dragged by only this view. Otherwise, the
      * entire panel can be used for dragging.
      */
     private View mDragView;
-
     /**
      * If provided, the panel can be dragged by only this view. Otherwise, the
      * entire panel can be used for dragging.
      */
     private int mDragViewResId = -1;
-
     /**
      * The child view that can slide, if any.
      */
     private View mSlideableView;
-
     /**
      * The main view
      */
     private View mMainView;
-
-    /**
-     * Current state of the slideable view.
-     */
-    public enum PanelState {
-        EXPANDED, COLLAPSED, ANCHORED, HIDDEN, DRAGGING
-    }
-
     private PanelState mSlideState = DEFAULT_SLIDE_STATE;
-
     /**
      * How far the panel is offset from its expanded position. range [0, 1]
      * where 0 = collapsed, 1 = expanded.
      */
     private float mSlideOffset;
-
     /**
      * How far in pixels the slideable panel may move.
      */
     private int mSlideRange;
-
     /**
      * A panel view is locked into internal scrolling or another condition that
      * is preventing a drag.
      */
     private boolean mIsUnableToDrag;
-
     /**
      * Flag indicating that sliding feature is enabled\disabled
      */
     private boolean mIsTouchEnabled;
-
     /**
      * Flag indicating if a drag view can have its own touch events. If set to
      * true, a drag view can scroll horizontally and have its own click
      * listener. Default is set to false.
      */
     private boolean mIsUsingDragViewTouchEvents;
-
     private float mInitialMotionX;
-
     private float mInitialMotionY;
-
     private float mAnchorPoint = 1.f;
-
     private PanelSlideListener mPanelSlideListener;
-
-    private final ViewDragHelper mDragHelper;
-
     /**
      * Stores whether or not the pane was expanded the last time it was
      * slideable. If expand/collapse operations are invoked this state is
@@ -209,77 +168,6 @@ public class SlidingUpPanelLayout extends ViewGroup {
      */
     private boolean mFirstLayout = true;
 
-    private final Rect mTmpRect = new Rect();
-
-    /**
-     * Listener for monitoring events about sliding panes.
-     */
-    public interface PanelSlideListener {
-        /**
-         * Called when a sliding pane's position changes.
-         * 
-         * @param panel The child view that was moved
-         * @param slideOffset The new offset of this sliding pane within its
-         *            range, from 0-1
-         */
-        public void onPanelSlide(View panel, float slideOffset);
-
-        /**
-         * Called when a sliding panel becomes slid completely collapsed.
-         * 
-         * @param panel The child view that was slid to an collapsed position
-         */
-        public void onPanelCollapsed(View panel);
-
-        /**
-         * Called when a sliding panel becomes slid completely expanded.
-         * 
-         * @param panel The child view that was slid to a expanded position
-         */
-        public void onPanelExpanded(View panel);
-
-        /**
-         * Called when a sliding panel becomes anchored.
-         * 
-         * @param panel The child view that was slid to a anchored position
-         */
-        public void onPanelAnchored(View panel);
-
-        /**
-         * Called when a sliding panel becomes completely hidden.
-         * 
-         * @param panel The child view that was slid to a hidden position
-         */
-        public void onPanelHidden(View panel);
-    }
-
-    /**
-     * No-op stubs for {@link PanelSlideListener}. If you only want to implement
-     * a subset of the listener methods you can extend this instead of implement
-     * the full interface.
-     */
-    public static class SimplePanelSlideListener implements PanelSlideListener {
-        @Override
-        public void onPanelSlide(View panel, float slideOffset) {
-        }
-
-        @Override
-        public void onPanelCollapsed(View panel) {
-        }
-
-        @Override
-        public void onPanelExpanded(View panel) {
-        }
-
-        @Override
-        public void onPanelAnchored(View panel) {
-        }
-
-        @Override
-        public void onPanelHidden(View panel) {
-        }
-    }
-
     public SlidingUpPanelLayout(Context context) {
         this(context, null);
     }
@@ -334,13 +222,13 @@ public class SlidingUpPanelLayout extends ViewGroup {
 
         final float density = context.getResources().getDisplayMetrics().density;
         if (mPanelHeight == -1) {
-            mPanelHeight = (int)(DEFAULT_PANEL_HEIGHT * density + 0.5f);
+            mPanelHeight = (int) (DEFAULT_PANEL_HEIGHT * density + 0.5f);
         }
         if (mShadowHeight == -1) {
-            mShadowHeight = (int)(DEFAULT_SHADOW_HEIGHT * density + 0.5f);
+            mShadowHeight = (int) (DEFAULT_SHADOW_HEIGHT * density + 0.5f);
         }
         if (mParallaxOffset == -1) {
-            mParallaxOffset = (int)(DEFAULT_PARALAX_OFFSET * density);
+            mParallaxOffset = (int) (DEFAULT_PARALAX_OFFSET * density);
         }
         // If the shadow height is zero, don't show the shadow
         if (mShadowHeight > 0) {
@@ -362,6 +250,11 @@ public class SlidingUpPanelLayout extends ViewGroup {
         mIsTouchEnabled = true;
     }
 
+    private static boolean hasOpaqueBackground(View v) {
+        final Drawable bg = v.getBackground();
+        return bg != null && bg.getOpacity() == PixelFormat.OPAQUE;
+    }
+
     /**
      * Set the Drag View after the view is inflated
      */
@@ -383,10 +276,17 @@ public class SlidingUpPanelLayout extends ViewGroup {
         }
     }
 
+    /**
+     * @return The ARGB-packed color value used to fade the fixed pane
+     */
+    public int getCoveredFadeColor() {
+        return mCoveredFadeColor;
+    }
+
     /**
      * Set the color used to fade the pane covered by the sliding pane out when
      * the pane will become fully covered in the expanded state.
-     * 
+     *
      * @param color An ARGB-packed color value
      */
     public void setCoveredFadeColor(int color) {
@@ -394,48 +294,19 @@ public class SlidingUpPanelLayout extends ViewGroup {
         invalidate();
     }
 
-    /**
-     * @return The ARGB-packed color value used to fade the fixed pane
-     */
-    public int getCoveredFadeColor() {
-        return mCoveredFadeColor;
+    public boolean isTouchEnabled() {
+        return mIsTouchEnabled && mSlideableView != null && mSlideState != PanelState.HIDDEN;
     }
 
     /**
      * Set sliding enabled flag
-     * 
+     *
      * @param enabled flag value
      */
     public void setTouchEnabled(boolean enabled) {
         mIsTouchEnabled = enabled;
     }
 
-    public boolean isTouchEnabled() {
-        return mIsTouchEnabled && mSlideableView != null && mSlideState != PanelState.HIDDEN;
-    }
-
-    /**
-     * Set the collapsed panel height in pixels
-     * 
-     * @param val A height in pixels
-     */
-    public void setPanelHeight(int val) {
-        if (getPanelHeight() == val) {
-            return;
-        }
-
-        mPanelHeight = val;
-        if (!mFirstLayout) {
-            requestLayout();
-        }
-
-        if (getPanelState() == PanelState.COLLAPSED) {
-            smoothToBottom();
-            invalidate();
-            return;
-        }
-    }
-
     protected void smoothToBottom() {
         smoothSlideTo(0, 0);
     }
@@ -449,7 +320,7 @@ public class SlidingUpPanelLayout extends ViewGroup {
 
     /**
      * Set the shadow height
-     * 
+     *
      * @param val A height in pixels
      */
     public void setShadowHeight(int val) {
@@ -466,18 +337,40 @@ public class SlidingUpPanelLayout extends ViewGroup {
         return mPanelHeight;
     }
 
+    /**
+     * Set the collapsed panel height in pixels
+     *
+     * @param val A height in pixels
+     */
+    public void setPanelHeight(int val) {
+        if (getPanelHeight() == val) {
+            return;
+        }
+
+        mPanelHeight = val;
+        if (!mFirstLayout) {
+            requestLayout();
+        }
+
+        if (getPanelState() == PanelState.COLLAPSED) {
+            smoothToBottom();
+            invalidate();
+            return;
+        }
+    }
+
     /**
      * @return The current paralax offset
      */
     public int getCurrentParalaxOffset() {
         // Clamp slide offset at zero for parallax computation;
-        int offset = (int)(mParallaxOffset * Math.max(mSlideOffset, 0));
+        int offset = (int) (mParallaxOffset * Math.max(mSlideOffset, 0));
         return mIsSlidingUp ? -offset : offset;
     }
 
     /**
      * Set parallax offset for the panel
-     * 
+     *
      * @param val A height in pixels
      */
     public void setParalaxOffset(int val) {
@@ -496,7 +389,7 @@ public class SlidingUpPanelLayout extends ViewGroup {
 
     /**
      * Sets the minimum fling velocity for the panel
-     * 
+     *
      * @param val the new value
      */
     public void setMinFlingVelocity(int val) {
@@ -505,7 +398,7 @@ public class SlidingUpPanelLayout extends ViewGroup {
 
     /**
      * Sets the panel slide listener
-     * 
+     *
      * @param listener
      */
     public void setPanelSlideListener(PanelSlideListener listener) {
@@ -515,7 +408,7 @@ public class SlidingUpPanelLayout extends ViewGroup {
     /**
      * Set the draggable view portion. Use to null, to allow the whole panel to
      * be draggable
-     * 
+     *
      * @param dragView A view that will be used to drag the panel.
      */
     public void setDragView(View dragView) {
@@ -551,7 +444,7 @@ public class SlidingUpPanelLayout extends ViewGroup {
     /**
      * Set the draggable view portion. Use to null, to allow the whole panel to
      * be draggable
-     * 
+     *
      * @param dragViewResId The resource ID of the new drag view
      */
     public void setDragView(int dragViewResId) {
@@ -559,11 +452,20 @@ public class SlidingUpPanelLayout extends ViewGroup {
         setDragView(findViewById(dragViewResId));
     }
 
+    /**
+     * Gets the currently set anchor point
+     *
+     * @return the currently set anchor point
+     */
+    public float getAnchorPoint() {
+        return mAnchorPoint;
+    }
+
     /**
      * Set an anchor point where the panel can stop during sliding
-     * 
+     *
      * @param anchorPoint A value between 0 and 1, determining the position of
-     *            the anchor point starting from the top of the layout.
+     *                    the anchor point starting from the top of the layout.
      */
     public void setAnchorPoint(float anchorPoint) {
         if (anchorPoint > 0 && anchorPoint <= 1) {
@@ -572,17 +474,15 @@ public class SlidingUpPanelLayout extends ViewGroup {
     }
 
     /**
-     * Gets the currently set anchor point
-     * 
-     * @return the currently set anchor point
+     * Check if the panel is set as an overlay.
      */
-    public float getAnchorPoint() {
-        return mAnchorPoint;
+    public boolean isOverlayed() {
+        return mOverlayContent;
     }
 
     /**
      * Sets whether or not the panel overlays the content
-     * 
+     *
      * @param overlayed
      */
     public void setOverlayed(boolean overlayed) {
@@ -590,28 +490,21 @@ public class SlidingUpPanelLayout extends ViewGroup {
     }
 
     /**
-     * Check if the panel is set as an overlay.
+     * Check whether or not the main content is clipped to the top of the panel
      */
-    public boolean isOverlayed() {
-        return mOverlayContent;
+    public boolean isClipPanel() {
+        return mClipPanel;
     }
 
     /**
      * Sets whether or not the main content is clipped to the top of the panel
-     * 
+     *
      * @param overlayed
      */
     public void setClipPanel(boolean clip) {
         mClipPanel = clip;
     }
 
-    /**
-     * Check whether or not the main content is clipped to the top of the panel
-     */
-    public boolean isClipPanel() {
-        return mClipPanel;
-    }
-
     void dispatchOnPanelSlide(View panel) {
         if (mPanelSlideListener != null) {
             mPanelSlideListener.onPanelSlide(panel, mSlideOffset);
@@ -690,11 +583,6 @@ public class SlidingUpPanelLayout extends ViewGroup {
         }
     }
 
-    private static boolean hasOpaqueBackground(View v) {
-        final Drawable bg = v.getBackground();
-        return bg != null && bg.getOpacity() == PixelFormat.OPAQUE;
-    }
-
     @Override
     protected void onAttachedToWindow() {
         super.onAttachedToWindow();
@@ -744,7 +632,7 @@ public class SlidingUpPanelLayout extends ViewGroup {
         // First pass. Measure based on child LayoutParams width/height.
         for (int i = 0; i < childCount; i++) {
             final View child = getChildAt(i);
-            final LayoutParams lp = (LayoutParams)child.getLayoutParams();
+            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
 
             // We always measure the sliding panel in order to know it's height
             // (needed for show panel)
@@ -822,7 +710,7 @@ public class SlidingUpPanelLayout extends ViewGroup {
 
         for (int i = 0; i < childCount; i++) {
             final View child = getChildAt(i);
-            final LayoutParams lp = (LayoutParams)child.getLayoutParams();
+            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
 
             // Always layout the sliding view on the first layout
             if (child.getVisibility() == GONE && (i == 0 || mFirstLayout)) {
@@ -913,7 +801,7 @@ public class SlidingUpPanelLayout extends ViewGroup {
                     return super.onInterceptTouchEvent(ev);
                 }
 
-                if ((ady > dragSlop && adx > ady) || !isDragViewUnder((int)mInitialMotionX, (int)mInitialMotionY)) {
+                if ((ady > dragSlop && adx > ady) || !isDragViewUnder((int) mInitialMotionX, (int) mInitialMotionY)) {
                     mDragHelper.cancel();
                     mIsUnableToDrag = true;
                     return false;
@@ -952,7 +840,7 @@ public class SlidingUpPanelLayout extends ViewGroup {
      */
     private int computePanelTopPosition(float slideOffset) {
         int slidingViewHeight = mSlideableView != null ? mSlideableView.getMeasuredHeight() : 0;
-        int slidePixelOffset = (int)(slideOffset * mSlideRange);
+        int slidePixelOffset = (int) (slideOffset * mSlideRange);
         // Compute the top of the panel if its collapsed
         return mIsSlidingUp ? getMeasuredHeight() - getPaddingBottom() - mPanelHeight - slidePixelOffset
                 : getPaddingTop() - slidingViewHeight + mPanelHeight + slidePixelOffset;
@@ -968,13 +856,13 @@ public class SlidingUpPanelLayout extends ViewGroup {
         // Determine the new slide offset based on the collapsed top position
         // and the new required
         // top position
-        return (mIsSlidingUp ? (float)(topBoundCollapsed - topPosition) / mSlideRange
-                : (float)(topPosition - topBoundCollapsed) / mSlideRange);
+        return (mIsSlidingUp ? (float) (topBoundCollapsed - topPosition) / mSlideRange
+                : (float) (topPosition - topBoundCollapsed) / mSlideRange);
     }
 
     /**
      * Returns the current state of the panel as an enum.
-     * 
+     *
      * @return the current panel state
      */
     public PanelState getPanelState() {
@@ -983,7 +871,7 @@ public class SlidingUpPanelLayout extends ViewGroup {
 
     /**
      * Change panel state to the given state with
-     * 
+     *
      * @param state - new panel state
      */
     public void setPanelState(PanelState state) {
@@ -1046,7 +934,7 @@ public class SlidingUpPanelLayout extends ViewGroup {
         // If the slide offset is negative, and overlay is not on, we need to
         // increase the
         // height of the main content
-        LayoutParams lp = (LayoutParams)mMainView.getLayoutParams();
+        LayoutParams lp = (LayoutParams) mMainView.getLayoutParams();
         int defaultHeight = getHeight() - getPaddingBottom() - getPaddingTop() - mPanelHeight;
 
         if (mSlideOffset <= 0 && !mOverlayContent) {
@@ -1085,7 +973,7 @@ public class SlidingUpPanelLayout extends ViewGroup {
 
             if (mCoveredFadeColor != 0 && mSlideOffset > 0) {
                 final int baseAlpha = (mCoveredFadeColor & 0xff000000) >>> 24;
-                final int imag = (int)(baseAlpha * mSlideOffset);
+                final int imag = (int) (baseAlpha * mSlideOffset);
                 final int color = imag << 24 | (mCoveredFadeColor & 0xffffff);
                 mCoveredFadePaint.setColor(color);
                 canvas.drawRect(mTmpRect, mCoveredFadePaint);
@@ -1101,9 +989,9 @@ public class SlidingUpPanelLayout extends ViewGroup {
 
     /**
      * Smoothly animate mDraggingPane to the target X position within its range.
-     * 
+     *
      * @param slideOffset position to animate to
-     * @param velocity initial velocity in case of fling, or 0.
+     * @param velocity    initial velocity in case of fling, or 0.
      */
     boolean smoothSlideTo(float slideOffset, int velocity) {
         if (!isEnabled()) {
@@ -1156,18 +1044,18 @@ public class SlidingUpPanelLayout extends ViewGroup {
 
     /**
      * Tests scrollability within child views of v given a delta of dx.
-     * 
-     * @param v View to test for horizontal scrollability
+     *
+     * @param v      View to test for horizontal scrollability
      * @param checkV Whether the view v passed should itself be checked for
-     *            scrollability (true), or just its children (false).
-     * @param dx Delta scrolled in pixels
-     * @param x X coordinate of the active touch point
-     * @param y Y coordinate of the active touch point
+     *               scrollability (true), or just its children (false).
+     * @param dx     Delta scrolled in pixels
+     * @param x      X coordinate of the active touch point
+     * @param y      Y coordinate of the active touch point
      * @return true if child views of v can be scrolled by delta of dx.
      */
     protected boolean canScroll(View v, boolean checkV, int dx, int x, int y) {
         if (v instanceof ViewGroup) {
-            final ViewGroup group = (ViewGroup)v;
+            final ViewGroup group = (ViewGroup) v;
             final int scrollX = v.getScrollX();
             final int scrollY = v.getScrollY();
             final int count = group.getChildCount();
@@ -1192,7 +1080,7 @@ public class SlidingUpPanelLayout extends ViewGroup {
 
     @Override
     protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) {
-        return p instanceof MarginLayoutParams ? new LayoutParams((MarginLayoutParams)p) : new LayoutParams(p);
+        return p instanceof MarginLayoutParams ? new LayoutParams((MarginLayoutParams) p) : new LayoutParams(p);
     }
 
     @Override
@@ -1217,11 +1105,155 @@ public class SlidingUpPanelLayout extends ViewGroup {
 
     @Override
     public void onRestoreInstanceState(Parcelable state) {
-        SavedState ss = (SavedState)state;
+        SavedState ss = (SavedState) state;
         super.onRestoreInstanceState(ss.getSuperState());
         mSlideState = ss.mSlideState;
     }
 
+    /**
+     * Current state of the slideable view.
+     */
+    public enum PanelState {
+        EXPANDED, COLLAPSED, ANCHORED, HIDDEN, DRAGGING
+    }
+
+    /**
+     * Listener for monitoring events about sliding panes.
+     */
+    public interface PanelSlideListener {
+        /**
+         * Called when a sliding pane's position changes.
+         *
+         * @param panel       The child view that was moved
+         * @param slideOffset The new offset of this sliding pane within its
+         *                    range, from 0-1
+         */
+        public void onPanelSlide(View panel, float slideOffset);
+
+        /**
+         * Called when a sliding panel becomes slid completely collapsed.
+         *
+         * @param panel The child view that was slid to an collapsed position
+         */
+        public void onPanelCollapsed(View panel);
+
+        /**
+         * Called when a sliding panel becomes slid completely expanded.
+         *
+         * @param panel The child view that was slid to a expanded position
+         */
+        public void onPanelExpanded(View panel);
+
+        /**
+         * Called when a sliding panel becomes anchored.
+         *
+         * @param panel The child view that was slid to a anchored position
+         */
+        public void onPanelAnchored(View panel);
+
+        /**
+         * Called when a sliding panel becomes completely hidden.
+         *
+         * @param panel The child view that was slid to a hidden position
+         */
+        public void onPanelHidden(View panel);
+    }
+
+    /**
+     * No-op stubs for {@link PanelSlideListener}. If you only want to implement
+     * a subset of the listener methods you can extend this instead of implement
+     * the full interface.
+     */
+    public static class SimplePanelSlideListener implements PanelSlideListener {
+        @Override
+        public void onPanelSlide(View panel, float slideOffset) {
+        }
+
+        @Override
+        public void onPanelCollapsed(View panel) {
+        }
+
+        @Override
+        public void onPanelExpanded(View panel) {
+        }
+
+        @Override
+        public void onPanelAnchored(View panel) {
+        }
+
+        @Override
+        public void onPanelHidden(View panel) {
+        }
+    }
+
+    public static class LayoutParams extends ViewGroup.MarginLayoutParams {
+        private static final int[] ATTRS = new int[]{
+                android.R.attr.layout_weight
+        };
+
+        public LayoutParams() {
+            super(MATCH_PARENT, MATCH_PARENT);
+        }
+
+        public LayoutParams(int width, int height) {
+            super(width, height);
+        }
+
+        public LayoutParams(android.view.ViewGroup.LayoutParams source) {
+            super(source);
+        }
+
+        public LayoutParams(MarginLayoutParams source) {
+            super(source);
+        }
+
+        public LayoutParams(LayoutParams source) {
+            super(source);
+        }
+
+        public LayoutParams(Context c, AttributeSet attrs) {
+            super(c, attrs);
+
+            final TypedArray a = c.obtainStyledAttributes(attrs, ATTRS);
+            a.recycle();
+        }
+
+    }
+
+    static class SavedState extends BaseSavedState {
+        public static final Parcelable.Creator<SavedState> CREATOR = new Parcelable.Creator<SavedState>() {
+            @Override
+            public SavedState createFromParcel(Parcel in) {
+                return new SavedState(in);
+            }
+
+            @Override
+            public SavedState[] newArray(int size) {
+                return new SavedState[size];
+            }
+        };
+        PanelState mSlideState;
+
+        SavedState(Parcelable superState) {
+            super(superState);
+        }
+
+        private SavedState(Parcel in) {
+            super(in);
+            try {
+                mSlideState = Enum.valueOf(PanelState.class, in.readString());
+            } catch (IllegalArgumentException e) {
+                mSlideState = PanelState.COLLAPSED;
+            }
+        }
+
+        @Override
+        public void writeToParcel(Parcel out, int flags) {
+            super.writeToParcel(out, flags);
+            out.writeString(mSlideState.toString());
+        }
+    }
+
     private class DragHelperCallback extends ViewDragHelper.Callback {
 
         @Override
@@ -1324,73 +1356,4 @@ public class SlidingUpPanelLayout extends ViewGroup {
             }
         }
     }
-
-    public static class LayoutParams extends ViewGroup.MarginLayoutParams {
-        private static final int[] ATTRS = new int[] {
-                android.R.attr.layout_weight
-        };
-
-        public LayoutParams() {
-            super(MATCH_PARENT, MATCH_PARENT);
-        }
-
-        public LayoutParams(int width, int height) {
-            super(width, height);
-        }
-
-        public LayoutParams(android.view.ViewGroup.LayoutParams source) {
-            super(source);
-        }
-
-        public LayoutParams(MarginLayoutParams source) {
-            super(source);
-        }
-
-        public LayoutParams(LayoutParams source) {
-            super(source);
-        }
-
-        public LayoutParams(Context c, AttributeSet attrs) {
-            super(c, attrs);
-
-            final TypedArray a = c.obtainStyledAttributes(attrs, ATTRS);
-            a.recycle();
-        }
-
-    }
-
-    static class SavedState extends BaseSavedState {
-        PanelState mSlideState;
-
-        SavedState(Parcelable superState) {
-            super(superState);
-        }
-
-        private SavedState(Parcel in) {
-            super(in);
-            try {
-                mSlideState = Enum.valueOf(PanelState.class, in.readString());
-            } catch (IllegalArgumentException e) {
-                mSlideState = PanelState.COLLAPSED;
-            }
-        }
-
-        @Override
-        public void writeToParcel(Parcel out, int flags) {
-            super.writeToParcel(out, flags);
-            out.writeString(mSlideState.toString());
-        }
-
-        public static final Parcelable.Creator<SavedState> CREATOR = new Parcelable.Creator<SavedState>() {
-            @Override
-            public SavedState createFromParcel(Parcel in) {
-                return new SavedState(in);
-            }
-
-            @Override
-            public SavedState[] newArray(int size) {
-                return new SavedState[size];
-            }
-        };
-    }
 }
diff --git a/qDict/src/main/java/com/mmt/widget/ViewDragHelper.java b/qDict/src/main/java/com/mmt/widget/ViewDragHelper.java
index a075b8f..67d1646 100644
--- a/qDict/src/main/java/com/mmt/widget/ViewDragHelper.java
+++ b/qDict/src/main/java/com/mmt/widget/ViewDragHelper.java
@@ -16,8 +16,6 @@
 
 package com.mmt.widget;
 
-import java.util.Arrays;
-
 import android.content.Context;
 import android.support.v4.view.MotionEventCompat;
 import android.support.v4.view.VelocityTrackerCompat;
@@ -30,6 +28,8 @@ import android.view.ViewConfiguration;
 import android.view.ViewGroup;
 import android.view.animation.Interpolator;
 
+import java.util.Arrays;
+
 /**
  * ViewDragHelper is a utility class for writing custom ViewGroups. It offers a
  * number of useful operations and state tracking for allowing a user to drag
@@ -105,306 +105,51 @@ public class ViewDragHelper {
     private static final int BASE_SETTLE_DURATION = 256; // ms
 
     private static final int MAX_SETTLE_DURATION = 600; // ms
-
+    /**
+     * Interpolator defining the animation curve for mScroller
+     */
+    private static final Interpolator sInterpolator = new Interpolator() {
+        public float getInterpolation(float t) {
+            t -= 1.0f;
+            return t * t * t * t * t + 1.0f;
+        }
+    };
+    private final Callback mCallback;
+    private final ViewGroup mParentView;
     // Current drag state; idle, dragging or settling
     private int mDragState;
-
     // Distance to travel before a drag may begin
     private int mTouchSlop;
-
     // Last known position/pointer tracking
     private int mActivePointerId = INVALID_POINTER;
-
     private float[] mInitialMotionX;
-
     private float[] mInitialMotionY;
-
     private float[] mLastMotionX;
-
     private float[] mLastMotionY;
-
     private int[] mInitialEdgesTouched;
-
     private int[] mEdgeDragsInProgress;
-
     private int[] mEdgeDragsLocked;
-
     private int mPointersDown;
-
     private VelocityTracker mVelocityTracker;
-
     private float mMaxVelocity;
-
     private float mMinVelocity;
-
     private int mEdgeSize;
-
     private int mTrackingEdges;
-
     private ScrollerCompat mScroller;
-
-    private final Callback mCallback;
-
     private View mCapturedView;
-
-    private boolean mReleaseInProgress;
-
-    private final ViewGroup mParentView;
-
-    /**
-     * A Callback is used as a communication channel with the ViewDragHelper
-     * back to the parent view using it. <code>on*</code>methods are invoked on
-     * siginficant events and several accessor methods are expected to provide
-     * the ViewDragHelper with more information about the state of the parent
-     * view upon request. The callback also makes decisions governing the range
-     * and draggability of child views.
-     */
-    public static abstract class Callback {
-        /**
-         * Called when the drag state changes. See the <code>STATE_*</code>
-         * constants for more information.
-         * 
-         * @param state The new drag state
-         * @see #STATE_IDLE
-         * @see #STATE_DRAGGING
-         * @see #STATE_SETTLING
-         */
-        public void onViewDragStateChanged(int state) {
-        }
-
-        /**
-         * Called when the captured view's position changes as the result of a
-         * drag or settle.
-         * 
-         * @param changedView View whose position changed
-         * @param left New X coordinate of the left edge of the view
-         * @param top New Y coordinate of the top edge of the view
-         * @param dx Change in X position from the last call
-         * @param dy Change in Y position from the last call
-         */
-        public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) {
-        }
-
-        /**
-         * Called when a child view is captured for dragging or settling. The ID
-         * of the pointer currently dragging the captured view is supplied. If
-         * activePointerId is identified as {@link #INVALID_POINTER} the capture
-         * is programmatic instead of pointer-initiated.
-         * 
-         * @param capturedChild Child view that was captured
-         * @param activePointerId Pointer id tracking the child capture
-         */
-        public void onViewCaptured(View capturedChild, int activePointerId) {
-        }
-
-        /**
-         * Called when the child view is no longer being actively dragged. The
-         * fling velocity is also supplied, if relevant. The velocity values may
-         * be clamped to system minimums or maximums.
-         * <p>
-         * Calling code may decide to fling or otherwise release the view to let
-         * it settle into place. It should do so using
-         * {@link #settleCapturedViewAt(int, int)} or
-         * {@link #flingCapturedView(int, int, int, int)}. If the Callback
-         * invokes one of these methods, the ViewDragHelper will enter
-         * {@link #STATE_SETTLING} and the view capture will not fully end until
-         * it comes to a complete stop. If neither of these methods is invoked
-         * before <code>onViewReleased</code> returns, the view will stop in
-         * place and the ViewDragHelper will return to {@link #STATE_IDLE}.
-         * </p>
-         * 
-         * @param releasedChild The captured child view now being released
-         * @param xvel X velocity of the pointer as it left the screen in pixels
-         *            per second.
-         * @param yvel Y velocity of the pointer as it left the screen in pixels
-         *            per second.
-         */
-        public void onViewReleased(View releasedChild, float xvel, float yvel) {
-        }
-
-        /**
-         * Called when one of the subscribed edges in the parent view has been
-         * touched by the user while no child view is currently captured.
-         * 
-         * @param edgeFlags A combination of edge flags describing the edge(s)
-         *            currently touched
-         * @param pointerId ID of the pointer touching the described edge(s)
-         * @see #EDGE_LEFT
-         * @see #EDGE_TOP
-         * @see #EDGE_RIGHT
-         * @see #EDGE_BOTTOM
-         */
-        public void onEdgeTouched(int edgeFlags, int pointerId) {
-        }
-
-        /**
-         * Called when the given edge may become locked. This can happen if an
-         * edge drag was preliminarily rejected before beginning, but after
-         * {@link #onEdgeTouched(int, int)} was called. This method should
-         * return true to lock this edge or false to leave it unlocked. The
-         * default behavior is to leave edges unlocked.
-         * 
-         * @param edgeFlags A combination of edge flags describing the edge(s)
-         *            locked
-         * @return true to lock the edge, false to leave it unlocked
-         */
-        public boolean onEdgeLock(int edgeFlags) {
-            return false;
-        }
-
-        /**
-         * Called when the user has started a deliberate drag away from one of
-         * the subscribed edges in the parent view while no child view is
-         * currently captured.
-         * 
-         * @param edgeFlags A combination of edge flags describing the edge(s)
-         *            dragged
-         * @param pointerId ID of the pointer touching the described edge(s)
-         * @see #EDGE_LEFT
-         * @see #EDGE_TOP
-         * @see #EDGE_RIGHT
-         * @see #EDGE_BOTTOM
-         */
-        public void onEdgeDragStarted(int edgeFlags, int pointerId) {
-        }
-
-        /**
-         * Called to determine the Z-order of child views.
-         * 
-         * @param index the ordered position to query for
-         * @return index of the view that should be ordered at position
-         *         <code>index</code>
-         */
-        public int getOrderedChildIndex(int index) {
-            return index;
-        }
-
-        /**
-         * Return the magnitude of a draggable child view's horizontal range of
-         * motion in pixels. This method should return 0 for views that cannot
-         * move horizontally.
-         * 
-         * @param child Child view to check
-         * @return range of horizontal motion in pixels
-         */
-        public int getViewHorizontalDragRange(View child) {
-            return 0;
-        }
-
-        /**
-         * Return the magnitude of a draggable child view's vertical range of
-         * motion in pixels. This method should return 0 for views that cannot
-         * move vertically.
-         * 
-         * @param child Child view to check
-         * @return range of vertical motion in pixels
-         */
-        public int getViewVerticalDragRange(View child) {
-            return 0;
-        }
-
-        /**
-         * Called when the user's input indicates that they want to capture the
-         * given child view with the pointer indicated by pointerId. The
-         * callback should return true if the user is permitted to drag the
-         * given view with the indicated pointer.
-         * <p>
-         * ViewDragHelper may call this method multiple times for the same view
-         * even if the view is already captured; this indicates that a new
-         * pointer is trying to take control of the view.
-         * </p>
-         * <p>
-         * If this method returns true, a call to
-         * {@link #onViewCaptured(android.view.View, int)} will follow if the
-         * capture is successful.
-         * </p>
-         * 
-         * @param child Child the user is attempting to capture
-         * @param pointerId ID of the pointer attempting the capture
-         * @return true if capture should be allowed, false otherwise
-         */
-        public abstract boolean tryCaptureView(View child, int pointerId);
-
-        /**
-         * Restrict the motion of the dragged child view along the horizontal
-         * axis. The default implementation does not allow horizontal motion;
-         * the extending class must override this method and provide the desired
-         * clamping.
-         * 
-         * @param child Child view being dragged
-         * @param left Attempted motion along the X axis
-         * @param dx Proposed change in position for left
-         * @return The new clamped position for left
-         */
-        public int clampViewPositionHorizontal(View child, int left, int dx) {
-            return 0;
-        }
-
-        /**
-         * Restrict the motion of the dragged child view along the vertical
-         * axis. The default implementation does not allow vertical motion; the
-         * extending class must override this method and provide the desired
-         * clamping.
-         * 
-         * @param child Child view being dragged
-         * @param top Attempted motion along the Y axis
-         * @param dy Proposed change in position for top
-         * @return The new clamped position for top
-         */
-        public int clampViewPositionVertical(View child, int top, int dy) {
-            return 0;
-        }
-    }
-
-    /**
-     * Interpolator defining the animation curve for mScroller
-     */
-    private static final Interpolator sInterpolator = new Interpolator() {
-        public float getInterpolation(float t) {
-            t -= 1.0f;
-            return t * t * t * t * t + 1.0f;
-        }
-    };
-
     private final Runnable mSetIdleRunnable = new Runnable() {
         public void run() {
             setDragState(STATE_IDLE);
         }
     };
-
-    /**
-     * Factory method to create a new ViewDragHelper.
-     * 
-     * @param forParent Parent view to monitor
-     * @param cb Callback to provide information and receive events
-     * @return a new ViewDragHelper instance
-     */
-    public static ViewDragHelper create(ViewGroup forParent, Callback cb) {
-        return new ViewDragHelper(forParent.getContext(), forParent, cb);
-    }
-
-    /**
-     * Factory method to create a new ViewDragHelper.
-     * 
-     * @param forParent Parent view to monitor
-     * @param sensitivity Multiplier for how sensitive the helper should be
-     *            about detecting the start of a drag. Larger values are more
-     *            sensitive. 1.0f is normal.
-     * @param cb Callback to provide information and receive events
-     * @return a new ViewDragHelper instance
-     */
-    public static ViewDragHelper create(ViewGroup forParent, float sensitivity, Callback cb) {
-        final ViewDragHelper helper = create(forParent, cb);
-        helper.mTouchSlop = (int)(helper.mTouchSlop * (1 / sensitivity));
-        return helper;
-    }
+    private boolean mReleaseInProgress;
 
     /**
      * Apps should use ViewDragHelper.create() to get a new instance. This will
      * allow VDH to use internal compatibility implementations for different
      * platform versions.
-     * 
-     * @param context Context to initialize config-dependent params from
+     *
+     * @param context   Context to initialize config-dependent params from
      * @param forParent Parent view to monitor
      */
     private ViewDragHelper(Context context, ViewGroup forParent, Callback cb) {
@@ -420,7 +165,7 @@ public class ViewDragHelper {
 
         final ViewConfiguration vc = ViewConfiguration.get(context);
         final float density = context.getResources().getDisplayMetrics().density;
-        mEdgeSize = (int)(EDGE_SIZE * density + 0.5f);
+        mEdgeSize = (int) (EDGE_SIZE * density + 0.5f);
 
         mTouchSlop = vc.getScaledTouchSlop();
         mMaxVelocity = vc.getScaledMaximumFlingVelocity();
@@ -429,14 +174,30 @@ public class ViewDragHelper {
     }
 
     /**
-     * Set the minimum velocity that will be detected as having a magnitude
-     * greater than zero in pixels per second. Callback methods accepting a
-     * velocity will be clamped appropriately.
-     * 
-     * @param minVel Minimum velocity to detect
+     * Factory method to create a new ViewDragHelper.
+     *
+     * @param forParent Parent view to monitor
+     * @param cb        Callback to provide information and receive events
+     * @return a new ViewDragHelper instance
      */
-    public void setMinVelocity(float minVel) {
-        mMinVelocity = minVel;
+    public static ViewDragHelper create(ViewGroup forParent, Callback cb) {
+        return new ViewDragHelper(forParent.getContext(), forParent, cb);
+    }
+
+    /**
+     * Factory method to create a new ViewDragHelper.
+     *
+     * @param forParent   Parent view to monitor
+     * @param sensitivity Multiplier for how sensitive the helper should be
+     *                    about detecting the start of a drag. Larger values are more
+     *                    sensitive. 1.0f is normal.
+     * @param cb          Callback to provide information and receive events
+     * @return a new ViewDragHelper instance
+     */
+    public static ViewDragHelper create(ViewGroup forParent, float sensitivity, Callback cb) {
+        final ViewDragHelper helper = create(forParent, cb);
+        helper.mTouchSlop = (int) (helper.mTouchSlop * (1 / sensitivity));
+        return helper;
     }
 
     /**
@@ -444,17 +205,28 @@ public class ViewDragHelper {
      * magnitude less than this value in pixels per second. Callback methods
      * accepting a velocity will receive zero as a velocity value if the real
      * detected velocity was below this threshold.
-     * 
+     *
      * @return the minimum velocity that will be detected
      */
     public float getMinVelocity() {
         return mMinVelocity;
     }
 
+    /**
+     * Set the minimum velocity that will be detected as having a magnitude
+     * greater than zero in pixels per second. Callback methods accepting a
+     * velocity will be clamped appropriately.
+     *
+     * @param minVel Minimum velocity to detect
+     */
+    public void setMinVelocity(float minVel) {
+        mMinVelocity = minVel;
+    }
+
     /**
      * Retrieve the current drag state of this helper. This will return one of
      * {@link #STATE_IDLE}, {@link #STATE_DRAGGING} or {@link #STATE_SETTLING}.
-     * 
+     *
      * @return The current drag state
      */
     public int getViewDragState() {
@@ -466,7 +238,7 @@ public class ViewDragHelper {
      * callback's {@link Callback#onEdgeTouched(int, int)} and
      * {@link Callback#onEdgeDragStarted(int, int)} methods will only be invoked
      * for edges for which edge tracking has been enabled.
-     * 
+     *
      * @param edgeFlags Combination of edge flags describing the edges to watch
      * @see #EDGE_LEFT
      * @see #EDGE_TOP
@@ -481,7 +253,7 @@ public class ViewDragHelper {
      * Return the size of an edge. This is the range in pixels along the edges
      * of this view that will actively detect edge touches or drags if edge
      * tracking is enabled.
-     * 
+     *
      * @return The size of an edge in pixels
      * @see #setEdgeTrackingEnabled(int)
      */
@@ -494,10 +266,10 @@ public class ViewDragHelper {
      * callback will be notified but
      * {@link Callback#tryCaptureView(android.view.View, int)} will not be asked
      * permission to capture this view.
-     * 
-     * @param childView Child view to capture
+     *
+     * @param childView       Child view to capture
      * @param activePointerId ID of the pointer that is dragging the captured
-     *            child view
+     *                        child view
      */
     public void captureChildView(View childView, int activePointerId) {
         if (childView.getParent() != mParentView) {
@@ -513,7 +285,7 @@ public class ViewDragHelper {
 
     /**
      * @return The currently captured view, or null if no view has been
-     *         captured.
+     * captured.
      */
     public View getCapturedView() {
         return mCapturedView;
@@ -521,7 +293,7 @@ public class ViewDragHelper {
 
     /**
      * @return The ID of the pointer currently dragging the captured view, or
-     *         {@link #INVALID_POINTER}.
+     * {@link #INVALID_POINTER}.
      */
     public int getActivePointerId() {
         return mActivePointerId;
@@ -529,7 +301,7 @@ public class ViewDragHelper {
 
     /**
      * @return The minimum distance in pixels that the user must travel to
-     *         initiate a drag
+     * initiate a drag
      */
     public int getTouchSlop() {
         return mTouchSlop;
@@ -578,12 +350,12 @@ public class ViewDragHelper {
      * {@link #getCapturedView()} will still report the sliding view while the
      * slide is in progress.
      * </p>
-     * 
-     * @param child Child view to capture and animate
+     *
+     * @param child     Child view to capture and animate
      * @param finalLeft Final left position of child
-     * @param finalTop Final top position of child
+     * @param finalTop  Final top position of child
      * @return true if animation should continue through
-     *         {@link #continueSettling(boolean)} calls
+     * {@link #continueSettling(boolean)} calls
      */
     public boolean smoothSlideViewTo(View child, int finalLeft, int finalTop) {
         mCapturedView = child;
@@ -599,11 +371,11 @@ public class ViewDragHelper {
      * {@link #continueSettling(boolean)} on each subsequent frame to continue
      * the motion until it returns false. If this method returns false there is
      * no further work to do to complete the movement.
-     * 
+     *
      * @param finalLeft Settled left edge position for the captured view
-     * @param finalTop Settled top edge position for the captured view
+     * @param finalTop  Settled top edge position for the captured view
      * @return true if animation should continue through
-     *         {@link #continueSettling(boolean)} calls
+     * {@link #continueSettling(boolean)} calls
      */
     public boolean settleCapturedViewAt(int finalLeft, int finalTop) {
         if (!mReleaseInProgress) {
@@ -612,19 +384,19 @@ public class ViewDragHelper {
         }
 
         return forceSettleCapturedViewAt(finalLeft, finalTop,
-                (int)VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),
-                (int)VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId));
+                (int) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),
+                (int) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId));
     }
 
     /**
      * Settle the captured view at the given (left, top) position.
-     * 
+     *
      * @param finalLeft Target left position for the captured view
-     * @param finalTop Target top position for the captured view
-     * @param xvel Horizontal velocity
-     * @param yvel Vertical velocity
+     * @param finalTop  Target top position for the captured view
+     * @param xvel      Horizontal velocity
+     * @param yvel      Vertical velocity
      * @return true if animation should continue through
-     *         {@link #continueSettling(boolean)} calls
+     * {@link #continueSettling(boolean)} calls
      */
     private boolean forceSettleCapturedViewAt(int finalLeft, int finalTop, int xvel, int yvel) {
         final int startLeft = mCapturedView.getLeft();
@@ -647,8 +419,8 @@ public class ViewDragHelper {
     }
 
     private int computeSettleDuration(View child, int dx, int dy, int xvel, int yvel) {
-        xvel = clampMag(xvel, (int)mMinVelocity, (int)mMaxVelocity);
-        yvel = clampMag(yvel, (int)mMinVelocity, (int)mMaxVelocity);
+        xvel = clampMag(xvel, (int) mMinVelocity, (int) mMaxVelocity);
+        yvel = clampMag(yvel, (int) mMinVelocity, (int) mMaxVelocity);
         final int absDx = Math.abs(dx);
         final int absDy = Math.abs(dy);
         final int absXVel = Math.abs(xvel);
@@ -656,13 +428,13 @@ public class ViewDragHelper {
         final int addedVel = absXVel + absYVel;
         final int addedDistance = absDx + absDy;
 
-        final float xweight = xvel != 0 ? (float)absXVel / addedVel : (float)absDx / addedDistance;
-        final float yweight = yvel != 0 ? (float)absYVel / addedVel : (float)absDy / addedDistance;
+        final float xweight = xvel != 0 ? (float) absXVel / addedVel : (float) absDx / addedDistance;
+        final float yweight = yvel != 0 ? (float) absYVel / addedVel : (float) absDy / addedDistance;
 
         int xduration = computeAxisDuration(dx, xvel, mCallback.getViewHorizontalDragRange(child));
         int yduration = computeAxisDuration(dy, yvel, mCallback.getViewVerticalDragRange(child));
 
-        return (int)(xduration * xweight + yduration * yweight);
+        return (int) (xduration * xweight + yduration * yweight);
     }
 
     private int computeAxisDuration(int delta, int velocity, int motionRange) {
@@ -672,7 +444,7 @@ public class ViewDragHelper {
 
         final int width = mParentView.getWidth();
         final int halfWidth = width / 2;
-        final float distanceRatio = Math.min(1f, (float)Math.abs(delta) / width);
+        final float distanceRatio = Math.min(1f, (float) Math.abs(delta) / width);
         final float distance = halfWidth + halfWidth * distanceInfluenceForSnapDuration(distanceRatio);
 
         int duration;
@@ -680,8 +452,8 @@ public class ViewDragHelper {
         if (velocity > 0) {
             duration = 4 * Math.round(1000 * Math.abs(distance / velocity));
         } else {
-            final float range = (float)Math.abs(delta) / motionRange;
-            duration = (int)((range + 1) * BASE_SETTLE_DURATION);
+            final float range = (float) Math.abs(delta) / motionRange;
+            duration = (int) ((range + 1) * BASE_SETTLE_DURATION);
         }
         return Math.min(duration, MAX_SETTLE_DURATION);
     }
@@ -690,8 +462,8 @@ public class ViewDragHelper {
      * Clamp the magnitude of value for absMin and absMax. If the value is below
      * the minimum, it will be clamped to zero. If the value is above the
      * maximum, it will be clamped to the maximum.
-     * 
-     * @param value Value to clamp
+     *
+     * @param value  Value to clamp
      * @param absMin Absolute value of the minimum significant value to return
      * @param absMax Absolute value of the maximum value to return
      * @return The clamped value with the same sign as <code>value</code>
@@ -709,8 +481,8 @@ public class ViewDragHelper {
      * Clamp the magnitude of value for absMin and absMax. If the value is below
      * the minimum, it will be clamped to zero. If the value is above the
      * maximum, it will be clamped to the maximum.
-     * 
-     * @param value Value to clamp
+     *
+     * @param value  Value to clamp
      * @param absMin Absolute value of the minimum significant value to return
      * @param absMax Absolute value of the maximum value to return
      * @return The clamped value with the same sign as <code>value</code>
@@ -727,18 +499,18 @@ public class ViewDragHelper {
     private float distanceInfluenceForSnapDuration(float f) {
         f -= 0.5f; // center the values about 0.
         f *= 0.3f * Math.PI / 2.0f;
-        return (float)Math.sin(f);
+        return (float) Math.sin(f);
     }
 
     /**
      * Settle the captured view based on standard free-moving fling behavior.
      * The caller should invoke {@link #continueSettling(boolean)} on each
      * subsequent frame to continue the motion until it returns false.
-     * 
+     *
      * @param minLeft Minimum X position for the view's left edge
-     * @param minTop Minimum Y position for the view's top edge
+     * @param minTop  Minimum Y position for the view's top edge
      * @param maxLeft Maximum X position for the view's left edge
-     * @param maxTop Maximum Y position for the view's top edge
+     * @param maxTop  Maximum Y position for the view's top edge
      */
     public void flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop) {
         if (!mReleaseInProgress) {
@@ -747,8 +519,8 @@ public class ViewDragHelper {
         }
 
         mScroller.fling(mCapturedView.getLeft(), mCapturedView.getTop(),
-                (int)VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),
-                (int)VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId), minLeft, maxLeft, minTop,
+                (int) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),
+                (int) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId), minLeft, maxLeft, minTop,
                 maxTop);
 
         setDragState(STATE_SETTLING);
@@ -758,11 +530,11 @@ public class ViewDragHelper {
      * Move the captured settling view by the appropriate amount for the current
      * time. If <code>continueSettling</code> returns true, the caller should
      * call it again on the next frame to continue.
-     * 
+     *
      * @param deferCallbacks true if state callbacks should be deferred via
-     *            posted message. Set this to true if you are calling this
-     *            method from {@link android.view.View#computeScroll()} or
-     *            similar methods invoked as part of layout or drawing.
+     *                       posted message. Set this to true if you are calling this
+     *                       method from {@link android.view.View#computeScroll()} or
+     *                       similar methods invoked as part of layout or drawing.
      * @return true if settle is still in progress
      */
     public boolean continueSettling(boolean deferCallbacks) {
@@ -888,7 +660,7 @@ public class ViewDragHelper {
         ensureMotionHistorySizeForId(pointerId);
         mInitialMotionX[pointerId] = mLastMotionX[pointerId] = x;
         mInitialMotionY[pointerId] = mLastMotionY[pointerId] = y;
-        mInitialEdgesTouched[pointerId] = getEdgesTouched((int)x, (int)y);
+        mInitialEdgesTouched[pointerId] = getEdgesTouched((int) x, (int) y);
         mPointersDown |= 1 << pointerId;
     }
 
@@ -915,9 +687,9 @@ public class ViewDragHelper {
      * methods has not been called for all relevant MotionEvents to track, the
      * information reported by this method may be stale or incorrect.
      * </p>
-     * 
+     *
      * @param pointerId pointer ID to check; corresponds to IDs provided by
-     *            MotionEvent
+     *                  MotionEvent
      * @return true if the pointer with the given ID is still down
      */
     public boolean isPointerDown(int pointerId) {
@@ -939,7 +711,7 @@ public class ViewDragHelper {
      * be involved. This will put us into the "dragging" state. If we've already
      * captured this view with this pointer this method will immediately return
      * true without consulting the callback.
-     * 
+     *
      * @param toCapture View to capture
      * @param pointerId Pointer to capture with
      * @return true if capture was successful
@@ -959,19 +731,19 @@ public class ViewDragHelper {
 
     /**
      * Tests scrollability within child views of v given a delta of dx.
-     * 
-     * @param v View to test for horizontal scrollability
+     *
+     * @param v      View to test for horizontal scrollability
      * @param checkV Whether the view v passed should itself be checked for
-     *            scrollability (true), or just its children (false).
-     * @param dx Delta scrolled in pixels along the X axis
-     * @param dy Delta scrolled in pixels along the Y axis
-     * @param x X coordinate of the active touch point
-     * @param y Y coordinate of the active touch point
+     *               scrollability (true), or just its children (false).
+     * @param dx     Delta scrolled in pixels along the X axis
+     * @param dy     Delta scrolled in pixels along the Y axis
+     * @param x      X coordinate of the active touch point
+     * @param y      Y coordinate of the active touch point
      * @return true if child views of v can be scrolled by delta of dx.
      */
     protected boolean canScroll(View v, boolean checkV, int dx, int dy, int x, int y) {
         if (v instanceof ViewGroup) {
-            final ViewGroup group = (ViewGroup)v;
+            final ViewGroup group = (ViewGroup) v;
             final int scrollX = v.getScrollX();
             final int scrollY = v.getScrollY();
             final int count = group.getChildCount();
@@ -983,7 +755,7 @@ public class ViewDragHelper {
                 final View child = group.getChildAt(i);
                 if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight() && y + scrollY >= child.getTop()
                         && y + scrollY < child.getBottom() && canScroll(child, true, dx, dy,
-                                x + scrollX - child.getLeft(), y + scrollY - child.getTop())) {
+                        x + scrollX - child.getLeft(), y + scrollY - child.getTop())) {
                     return true;
                 }
             }
@@ -996,10 +768,10 @@ public class ViewDragHelper {
      * Check if this event as provided to the parent view's
      * onInterceptTouchEvent should cause the parent to intercept the touch
      * event stream.
-     * 
+     *
      * @param ev MotionEvent provided to onInterceptTouchEvent
      * @return true if the parent view should return true from
-     *         onInterceptTouchEvent
+     * onInterceptTouchEvent
      */
     public boolean shouldInterceptTouchEvent(MotionEvent ev) {
         final int action = MotionEventCompat.getActionMasked(ev);
@@ -1023,7 +795,7 @@ public class ViewDragHelper {
                 final int pointerId = MotionEventCompat.getPointerId(ev, 0);
                 saveInitialMotion(x, y, pointerId);
 
-                final View toCapture = findTopChildUnder((int)x, (int)y);
+                final View toCapture = findTopChildUnder((int) x, (int) y);
 
                 // Catch a settling view if possible.
                 if (toCapture == mCapturedView && mDragState == STATE_SETTLING) {
@@ -1052,7 +824,7 @@ public class ViewDragHelper {
                     }
                 } else if (mDragState == STATE_SETTLING) {
                     // Catch a settling view if possible.
-                    final View toCapture = findTopChildUnder((int)x, (int)y);
+                    final View toCapture = findTopChildUnder((int) x, (int) y);
                     if (toCapture == mCapturedView) {
                         tryCaptureViewForDrag(toCapture, pointerId);
                     }
@@ -1080,8 +852,8 @@ public class ViewDragHelper {
                         break;
                     }
 
-                    final View toCapture = findTopChildUnder((int)mInitialMotionX[pointerId],
-                            (int)mInitialMotionY[pointerId]);
+                    final View toCapture = findTopChildUnder((int) mInitialMotionX[pointerId],
+                            (int) mInitialMotionY[pointerId]);
                     if (toCapture != null && checkTouchSlop(toCapture, dx, dy)
                             && tryCaptureViewForDrag(toCapture, pointerId)) {
                         break;
@@ -1111,7 +883,7 @@ public class ViewDragHelper {
      * Process a touch event received by the parent view. This method will
      * dispatch callback events as needed before returning. The parent view's
      * onTouchEvent implementation should call this.
-     * 
+     *
      * @param ev The touch event received by the parent view
      */
     public void processTouchEvent(MotionEvent ev) {
@@ -1134,7 +906,7 @@ public class ViewDragHelper {
                 final float x = ev.getX();
                 final float y = ev.getY();
                 final int pointerId = MotionEventCompat.getPointerId(ev, 0);
-                final View toCapture = findTopChildUnder((int)x, (int)y);
+                final View toCapture = findTopChildUnder((int) x, (int) y);
 
                 saveInitialMotion(x, y, pointerId);
 
@@ -1164,14 +936,14 @@ public class ViewDragHelper {
                     // down
                     // event.
 
-                    final View toCapture = findTopChildUnder((int)x, (int)y);
+                    final View toCapture = findTopChildUnder((int) x, (int) y);
                     tryCaptureViewForDrag(toCapture, pointerId);
 
                     final int edgesTouched = mInitialEdgesTouched[pointerId];
                     if ((edgesTouched & mTrackingEdges) != 0) {
                         mCallback.onEdgeTouched(edgesTouched & mTrackingEdges, pointerId);
                     }
-                } else if (isCapturedViewUnder((int)x, (int)y)) {
+                } else if (isCapturedViewUnder((int) x, (int) y)) {
                     // We're still tracking a captured view. If the same view is
                     // under this
                     // point, we'll swap to controlling it with this pointer
@@ -1189,8 +961,8 @@ public class ViewDragHelper {
                     final int index = MotionEventCompat.findPointerIndex(ev, mActivePointerId);
                     final float x = MotionEventCompat.getX(ev, index);
                     final float y = MotionEventCompat.getY(ev, index);
-                    final int idx = (int)(x - mLastMotionX[mActivePointerId]);
-                    final int idy = (int)(y - mLastMotionY[mActivePointerId]);
+                    final int idx = (int) (x - mLastMotionX[mActivePointerId]);
+                    final int idy = (int) (y - mLastMotionY[mActivePointerId]);
 
                     dragTo(mCapturedView.getLeft() + idx, mCapturedView.getTop() + idy, idx, idy);
 
@@ -1211,7 +983,7 @@ public class ViewDragHelper {
                             break;
                         }
 
-                        final View toCapture = findTopChildUnder((int)x, (int)y);
+                        final View toCapture = findTopChildUnder((int) x, (int) y);
                         if (checkTouchSlop(toCapture, dx, dy) && tryCaptureViewForDrag(toCapture, pointerId)) {
                             break;
                         }
@@ -1238,7 +1010,7 @@ public class ViewDragHelper {
 
                         final float x = MotionEventCompat.getX(ev, i);
                         final float y = MotionEventCompat.getY(ev, i);
-                        if (findTopChildUnder((int)x, (int)y) == mCapturedView
+                        if (findTopChildUnder((int) x, (int) y) == mCapturedView
                                 && tryCaptureViewForDrag(mCapturedView, id)) {
                             newActivePointer = mActivePointerId;
                             break;
@@ -1315,10 +1087,10 @@ public class ViewDragHelper {
      * Check if we've crossed a reasonable touch slop for the given child view.
      * If the child cannot be dragged along the horizontal or vertical axis,
      * motion along that axis will not count toward the slop check.
-     * 
+     *
      * @param child Child to check
-     * @param dx Motion since initial position along X axis
-     * @param dy Motion since initial position along Y axis
+     * @param dx    Motion since initial position along X axis
+     * @param dy    Motion since initial position along Y axis
      * @return true if the touch slop has been crossed
      */
     private boolean checkTouchSlop(View child, float dx, float dy) {
@@ -1348,10 +1120,10 @@ public class ViewDragHelper {
      * rely on the results of this method after all currently available touch
      * data has been provided to one of these two methods.
      * </p>
-     * 
+     *
      * @param directions Combination of direction flags, see
-     *            {@link #DIRECTION_HORIZONTAL}, {@link #DIRECTION_VERTICAL},
-     *            {@link #DIRECTION_ALL}
+     *                   {@link #DIRECTION_HORIZONTAL}, {@link #DIRECTION_VERTICAL},
+     *                   {@link #DIRECTION_ALL}
      * @return true if the slop threshold has been crossed, false otherwise
      */
     public boolean checkTouchSlop(int directions) {
@@ -1374,12 +1146,12 @@ public class ViewDragHelper {
      * rely on the results of this method after all currently available touch
      * data has been provided to one of these two methods.
      * </p>
-     * 
+     *
      * @param directions Combination of direction flags, see
-     *            {@link #DIRECTION_HORIZONTAL}, {@link #DIRECTION_VERTICAL},
-     *            {@link #DIRECTION_ALL}
-     * @param pointerId ID of the pointer to slop check as specified by
-     *            MotionEvent
+     *                   {@link #DIRECTION_HORIZONTAL}, {@link #DIRECTION_VERTICAL},
+     *                   {@link #DIRECTION_ALL}
+     * @param pointerId  ID of the pointer to slop check as specified by
+     *                   MotionEvent
      * @return true if the slop threshold has been crossed, false otherwise
      */
     public boolean checkTouchSlop(int directions, int pointerId) {
@@ -1407,12 +1179,12 @@ public class ViewDragHelper {
      * Check if any of the edges specified were initially touched in the
      * currently active gesture. If there is no currently active gesture this
      * method will return false.
-     * 
+     *
      * @param edges Edges to check for an initial edge touch. See
-     *            {@link #EDGE_LEFT}, {@link #EDGE_TOP}, {@link #EDGE_RIGHT},
-     *            {@link #EDGE_BOTTOM} and {@link #EDGE_ALL}
+     *              {@link #EDGE_LEFT}, {@link #EDGE_TOP}, {@link #EDGE_RIGHT},
+     *              {@link #EDGE_BOTTOM} and {@link #EDGE_ALL}
      * @return true if any of the edges specified were initially touched in the
-     *         current gesture
+     * current gesture
      */
     public boolean isEdgeTouched(int edges) {
         final int count = mInitialEdgesTouched.length;
@@ -1429,12 +1201,12 @@ public class ViewDragHelper {
      * with the specified ID. If there is no currently active gesture or if
      * there is no pointer with the given ID currently down this method will
      * return false.
-     * 
+     *
      * @param edges Edges to check for an initial edge touch. See
-     *            {@link #EDGE_LEFT}, {@link #EDGE_TOP}, {@link #EDGE_RIGHT},
-     *            {@link #EDGE_BOTTOM} and {@link #EDGE_ALL}
+     *              {@link #EDGE_LEFT}, {@link #EDGE_TOP}, {@link #EDGE_RIGHT},
+     *              {@link #EDGE_BOTTOM} and {@link #EDGE_ALL}
      * @return true if any of the edges specified were initially touched in the
-     *         current gesture
+     * current gesture
      */
     public boolean isEdgeTouched(int edges, int pointerId) {
         return isPointerDown(pointerId) && (mInitialEdgesTouched[pointerId] & edges) != 0;
@@ -1474,11 +1246,11 @@ public class ViewDragHelper {
      * Determine if the currently captured view is under the given point in the
      * parent view's coordinate system. If there is no captured view this method
      * will return false.
-     * 
+     *
      * @param x X position to test in the parent's coordinate system
      * @param y Y position to test in the parent's coordinate system
      * @return true if the captured view is under the given point, false
-     *         otherwise
+     * otherwise
      */
     public boolean isCapturedViewUnder(int x, int y) {
         return isViewUnder(mCapturedView, x, y);
@@ -1487,12 +1259,12 @@ public class ViewDragHelper {
     /**
      * Determine if the supplied view is under the given point in the parent
      * view's coordinate system.
-     * 
+     *
      * @param view Child view of the parent to hit test
-     * @param x X position to test in the parent's coordinate system
-     * @param y Y position to test in the parent's coordinate system
+     * @param x    X position to test in the parent's coordinate system
+     * @param y    Y position to test in the parent's coordinate system
      * @return true if the supplied view is under the given point, false
-     *         otherwise
+     * otherwise
      */
     public boolean isViewUnder(View view, int x, int y) {
         if (view == null) {
@@ -1505,7 +1277,7 @@ public class ViewDragHelper {
      * Find the topmost child under the given point within the parent view's
      * coordinate system. The child order is determined using
      * {@link Callback#getOrderedChildIndex(int)}.
-     * 
+     *
      * @param x X position to test in the parent's coordinate system
      * @param y Y position to test in the parent's coordinate system
      * @return The topmost child view under (x, y) or null if none found.
@@ -1535,4 +1307,209 @@ public class ViewDragHelper {
 
         return result;
     }
+
+    /**
+     * A Callback is used as a communication channel with the ViewDragHelper
+     * back to the parent view using it. <code>on*</code>methods are invoked on
+     * siginficant events and several accessor methods are expected to provide
+     * the ViewDragHelper with more information about the state of the parent
+     * view upon request. The callback also makes decisions governing the range
+     * and draggability of child views.
+     */
+    public static abstract class Callback {
+        /**
+         * Called when the drag state changes. See the <code>STATE_*</code>
+         * constants for more information.
+         *
+         * @param state The new drag state
+         * @see #STATE_IDLE
+         * @see #STATE_DRAGGING
+         * @see #STATE_SETTLING
+         */
+        public void onViewDragStateChanged(int state) {
+        }
+
+        /**
+         * Called when the captured view's position changes as the result of a
+         * drag or settle.
+         *
+         * @param changedView View whose position changed
+         * @param left        New X coordinate of the left edge of the view
+         * @param top         New Y coordinate of the top edge of the view
+         * @param dx          Change in X position from the last call
+         * @param dy          Change in Y position from the last call
+         */
+        public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) {
+        }
+
+        /**
+         * Called when a child view is captured for dragging or settling. The ID
+         * of the pointer currently dragging the captured view is supplied. If
+         * activePointerId is identified as {@link #INVALID_POINTER} the capture
+         * is programmatic instead of pointer-initiated.
+         *
+         * @param capturedChild   Child view that was captured
+         * @param activePointerId Pointer id tracking the child capture
+         */
+        public void onViewCaptured(View capturedChild, int activePointerId) {
+        }
+
+        /**
+         * Called when the child view is no longer being actively dragged. The
+         * fling velocity is also supplied, if relevant. The velocity values may
+         * be clamped to system minimums or maximums.
+         * <p>
+         * Calling code may decide to fling or otherwise release the view to let
+         * it settle into place. It should do so using
+         * {@link #settleCapturedViewAt(int, int)} or
+         * {@link #flingCapturedView(int, int, int, int)}. If the Callback
+         * invokes one of these methods, the ViewDragHelper will enter
+         * {@link #STATE_SETTLING} and the view capture will not fully end until
+         * it comes to a complete stop. If neither of these methods is invoked
+         * before <code>onViewReleased</code> returns, the view will stop in
+         * place and the ViewDragHelper will return to {@link #STATE_IDLE}.
+         * </p>
+         *
+         * @param releasedChild The captured child view now being released
+         * @param xvel          X velocity of the pointer as it left the screen in pixels
+         *                      per second.
+         * @param yvel          Y velocity of the pointer as it left the screen in pixels
+         *                      per second.
+         */
+        public void onViewReleased(View releasedChild, float xvel, float yvel) {
+        }
+
+        /**
+         * Called when one of the subscribed edges in the parent view has been
+         * touched by the user while no child view is currently captured.
+         *
+         * @param edgeFlags A combination of edge flags describing the edge(s)
+         *                  currently touched
+         * @param pointerId ID of the pointer touching the described edge(s)
+         * @see #EDGE_LEFT
+         * @see #EDGE_TOP
+         * @see #EDGE_RIGHT
+         * @see #EDGE_BOTTOM
+         */
+        public void onEdgeTouched(int edgeFlags, int pointerId) {
+        }
+
+        /**
+         * Called when the given edge may become locked. This can happen if an
+         * edge drag was preliminarily rejected before beginning, but after
+         * {@link #onEdgeTouched(int, int)} was called. This method should
+         * return true to lock this edge or false to leave it unlocked. The
+         * default behavior is to leave edges unlocked.
+         *
+         * @param edgeFlags A combination of edge flags describing the edge(s)
+         *                  locked
+         * @return true to lock the edge, false to leave it unlocked
+         */
+        public boolean onEdgeLock(int edgeFlags) {
+            return false;
+        }
+
+        /**
+         * Called when the user has started a deliberate drag away from one of
+         * the subscribed edges in the parent view while no child view is
+         * currently captured.
+         *
+         * @param edgeFlags A combination of edge flags describing the edge(s)
+         *                  dragged
+         * @param pointerId ID of the pointer touching the described edge(s)
+         * @see #EDGE_LEFT
+         * @see #EDGE_TOP
+         * @see #EDGE_RIGHT
+         * @see #EDGE_BOTTOM
+         */
+        public void onEdgeDragStarted(int edgeFlags, int pointerId) {
+        }
+
+        /**
+         * Called to determine the Z-order of child views.
+         *
+         * @param index the ordered position to query for
+         * @return index of the view that should be ordered at position
+         * <code>index</code>
+         */
+        public int getOrderedChildIndex(int index) {
+            return index;
+        }
+
+        /**
+         * Return the magnitude of a draggable child view's horizontal range of
+         * motion in pixels. This method should return 0 for views that cannot
+         * move horizontally.
+         *
+         * @param child Child view to check
+         * @return range of horizontal motion in pixels
+         */
+        public int getViewHorizontalDragRange(View child) {
+            return 0;
+        }
+
+        /**
+         * Return the magnitude of a draggable child view's vertical range of
+         * motion in pixels. This method should return 0 for views that cannot
+         * move vertically.
+         *
+         * @param child Child view to check
+         * @return range of vertical motion in pixels
+         */
+        public int getViewVerticalDragRange(View child) {
+            return 0;
+        }
+
+        /**
+         * Called when the user's input indicates that they want to capture the
+         * given child view with the pointer indicated by pointerId. The
+         * callback should return true if the user is permitted to drag the
+         * given view with the indicated pointer.
+         * <p>
+         * ViewDragHelper may call this method multiple times for the same view
+         * even if the view is already captured; this indicates that a new
+         * pointer is trying to take control of the view.
+         * </p>
+         * <p>
+         * If this method returns true, a call to
+         * {@link #onViewCaptured(android.view.View, int)} will follow if the
+         * capture is successful.
+         * </p>
+         *
+         * @param child     Child the user is attempting to capture
+         * @param pointerId ID of the pointer attempting the capture
+         * @return true if capture should be allowed, false otherwise
+         */
+        public abstract boolean tryCaptureView(View child, int pointerId);
+
+        /**
+         * Restrict the motion of the dragged child view along the horizontal
+         * axis. The default implementation does not allow horizontal motion;
+         * the extending class must override this method and provide the desired
+         * clamping.
+         *
+         * @param child Child view being dragged
+         * @param left  Attempted motion along the X axis
+         * @param dx    Proposed change in position for left
+         * @return The new clamped position for left
+         */
+        public int clampViewPositionHorizontal(View child, int left, int dx) {
+            return 0;
+        }
+
+        /**
+         * Restrict the motion of the dragged child view along the vertical
+         * axis. The default implementation does not allow vertical motion; the
+         * extending class must override this method and provide the desired
+         * clamping.
+         *
+         * @param child Child view being dragged
+         * @param top   Attempted motion along the Y axis
+         * @param dy    Proposed change in position for top
+         * @return The new clamped position for top
+         */
+        public int clampViewPositionVertical(View child, int top, int dy) {
+            return 0;
+        }
+    }
 }
diff --git a/qDict/src/main/java/com/mmt/widget/draglistview/DragSortController.java b/qDict/src/main/java/com/mmt/widget/draglistview/DragSortController.java
index 6a355ac..792138a 100644
--- a/qDict/src/main/java/com/mmt/widget/draglistview/DragSortController.java
+++ b/qDict/src/main/java/com/mmt/widget/draglistview/DragSortController.java
@@ -1,8 +1,5 @@
-
 package com.mmt.widget.draglistview;
 
-import com.mmt.widget.DragSortListView;
-
 import android.graphics.Point;
 import android.view.GestureDetector;
 import android.view.HapticFeedbackConstants;
@@ -11,6 +8,8 @@ import android.view.View;
 import android.view.ViewConfiguration;
 import android.widget.AdapterView;
 
+import com.mmt.widget.DragSortListView;
+
 /**
  * Class that starts and stops item drags on a {@link DragSortListView} based on
  * touch gestures. This class also inherits from {@link SimpleFloatViewManager},
@@ -30,35 +29,23 @@ public class DragSortController extends SimpleFloatViewManager
     public static final int ON_DRAG = 1;
 
     public static final int ON_LONG_PRESS = 2;
-
-    private int mDragInitMode = ON_DOWN;
-
-    private boolean mSortEnabled = true;
-
     /**
      * Remove mode enum.
      */
     public static final int CLICK_REMOVE = 0;
-
     public static final int FLING_REMOVE = 1;
-
+    public static final int MISS = -1;
+    private int mDragInitMode = ON_DOWN;
+    private boolean mSortEnabled = true;
     /**
      * The current remove mode.
      */
     private int mRemoveMode;
-
     private boolean mRemoveEnabled = false;
-
     private boolean mIsRemoving = false;
-
     private GestureDetector mDetector;
-
     private GestureDetector mFlingRemoveDetector;
-
     private int mTouchSlop;
-
-    public static final int MISS = -1;
-
     private int mHitPos = MISS;
 
     private int mFlingHitPos = MISS;
@@ -90,12 +77,33 @@ public class DragSortController extends SimpleFloatViewManager
     private DragSortListView mDslv;
 
     private int mPositionX;
+    private GestureDetector.OnGestureListener mFlingRemoveListener = new GestureDetector.SimpleOnGestureListener() {
+        @Override
+        public final boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
+            // Log.d("mobeta", "on fling remove called");
+            if (mRemoveEnabled && mIsRemoving) {
+                int w = mDslv.getWidth();
+                int minPos = w / 5;
+                if (velocityX > mFlingSpeed) {
+                    if (mPositionX > -minPos) {
+                        mDslv.stopDragWithVelocity(true, velocityX);
+                    }
+                } else if (velocityX < -mFlingSpeed) {
+                    if (mPositionX < minPos) {
+                        mDslv.stopDragWithVelocity(true, velocityX);
+                    }
+                }
+                mIsRemoving = false;
+            }
+            return false;
+        }
+    };
 
     /**
      * Calls {@link #DragSortController(DragSortListView, int)} with a 0 drag
      * handle id, FLING_RIGHT_REMOVE remove mode, and ON_DOWN drag init. By
      * default, sorting is enabled, and removal is disabled.
-     * 
+     *
      * @param dslv The DSLV instance
      */
     public DragSortController(DragSortListView dslv) {
@@ -107,19 +115,19 @@ public class DragSortController extends SimpleFloatViewManager
     }
 
     public DragSortController(DragSortListView dslv, int dragHandleId, int dragInitMode, int removeMode,
-            int clickRemoveId) {
+                              int clickRemoveId) {
         this(dslv, dragHandleId, dragInitMode, removeMode, clickRemoveId, 0);
     }
 
     /**
      * By default, sorting is enabled, and removal is disabled.
-     * 
-     * @param dslv The DSLV instance
+     *
+     * @param dslv         The DSLV instance
      * @param dragHandleId The resource id of the View that represents the drag
-     *            handle in a list item.
+     *                     handle in a list item.
      */
     public DragSortController(DragSortListView dslv, int dragHandleId, int dragInitMode, int removeMode,
-            int clickRemoveId, int flingHandleId) {
+                              int clickRemoveId, int flingHandleId) {
         super(dslv);
         mDslv = dslv;
         mDetector = new GestureDetector(dslv.getContext(), this);
@@ -140,25 +148,29 @@ public class DragSortController extends SimpleFloatViewManager
     /**
      * Set how a drag is initiated. Needs to be one of {@link ON_DOWN},
      * {@link ON_DRAG}, or {@link ON_LONG_PRESS}.
-     * 
+     *
      * @param mode The drag init mode.
      */
     public void setDragInitMode(int mode) {
         mDragInitMode = mode;
     }
 
+    public boolean isSortEnabled() {
+        return mSortEnabled;
+    }
+
     /**
      * Enable/Disable list item sorting. Disabling is useful if only item
      * removal is desired. Prevents drags in the vertical direction.
-     * 
+     *
      * @param enabled Set <code>true</code> to enable list item sorting.
      */
     public void setSortEnabled(boolean enabled) {
         mSortEnabled = enabled;
     }
 
-    public boolean isSortEnabled() {
-        return mSortEnabled;
+    public int getRemoveMode() {
+        return mRemoveMode;
     }
 
     /**
@@ -170,8 +182,8 @@ public class DragSortController extends SimpleFloatViewManager
         mRemoveMode = mode;
     }
 
-    public int getRemoveMode() {
-        return mRemoveMode;
+    public boolean isRemoveEnabled() {
+        return mRemoveEnabled;
     }
 
     /**
@@ -181,14 +193,10 @@ public class DragSortController extends SimpleFloatViewManager
         mRemoveEnabled = enabled;
     }
 
-    public boolean isRemoveEnabled() {
-        return mRemoveEnabled;
-    }
-
     /**
      * Set the resource id for the View that represents the drag handle in a
      * list item.
-     * 
+     *
      * @param id An android resource id.
      */
     public void setDragHandleId(int id) {
@@ -198,7 +206,7 @@ public class DragSortController extends SimpleFloatViewManager
     /**
      * Set the resource id for the View that represents the fling handle in a
      * list item.
-     * 
+     *
      * @param id An android resource id.
      */
     public void setFlingHandleId(int id) {
@@ -207,7 +215,7 @@ public class DragSortController extends SimpleFloatViewManager
 
     /**
      * Set the resource id for the View that represents click removal button.
-     * 
+     *
      * @param id An android resource id.
      */
     public void setClickRemoveId(int id) {
@@ -218,10 +226,10 @@ public class DragSortController extends SimpleFloatViewManager
      * Sets flags to restrict certain motions of the floating View based on
      * DragSortController settings (such as remove mode). Starts the drag on the
      * DragSortListView.
-     * 
+     *
      * @param position The list item position (includes headers).
-     * @param deltaX Touch x-coord minus left edge of floating View.
-     * @param deltaY Touch y-coord minus top edge of floating View.
+     * @param deltaX   Touch x-coord minus left edge of floating View.
+     * @param deltaY   Touch y-coord minus top edge of floating View.
      * @return True if drag started, false otherwise.
      */
     public boolean startDrag(int position, int deltaX, int deltaY) {
@@ -253,8 +261,8 @@ public class DragSortController extends SimpleFloatViewManager
         int action = ev.getAction() & MotionEvent.ACTION_MASK;
         switch (action) {
             case MotionEvent.ACTION_DOWN:
-                mCurrX = (int)ev.getX();
-                mCurrY = (int)ev.getY();
+                mCurrX = (int) ev.getX();
+                mCurrY = (int) ev.getY();
                 break;
             case MotionEvent.ACTION_UP:
                 if (mRemoveEnabled && mIsRemoving) {
@@ -289,10 +297,10 @@ public class DragSortController extends SimpleFloatViewManager
      * This function simply calls {@link #dragHandleHitPosition(MotionEvent)}.
      * Override to change drag handle behavior; this function is called
      * internally when an ACTION_DOWN event is detected.
-     * 
+     *
      * @param ev The ACTION_DOWN MotionEvent.
      * @return The list position to drag if a drag-init gesture is detected;
-     *         MISS if unsuccessful.
+     * MISS if unsuccessful.
      */
     public int startDragPosition(MotionEvent ev) {
         return dragHandleHitPosition(ev);
@@ -306,10 +314,10 @@ public class DragSortController extends SimpleFloatViewManager
      * Checks for the touch of an item's drag handle (specified by
      * {@link #setDragHandleId(int)}), and returns that item's position if a
      * drag handle touch was detected.
-     * 
+     *
      * @param ev The ACTION_DOWN MotionEvent.
      * @return The list position of the item whose drag handle was touched; MISS
-     *         if unsuccessful.
+     * if unsuccessful.
      */
     public int dragHandleHitPosition(MotionEvent ev) {
         return viewIdHitPosition(ev, mDragHandleId);
@@ -320,8 +328,8 @@ public class DragSortController extends SimpleFloatViewManager
     }
 
     public int viewIdHitPosition(MotionEvent ev, int id) {
-        final int x = (int)ev.getX();
-        final int y = (int)ev.getY();
+        final int x = (int) ev.getX();
+        final int y = (int) ev.getY();
 
         int touchPos = mDslv.pointToPosition(x, y); // includes headers/footers
 
@@ -334,10 +342,10 @@ public class DragSortController extends SimpleFloatViewManager
         // item that's not a header or footer.
         if (touchPos != AdapterView.INVALID_POSITION && touchPos >= numHeaders && touchPos < (count - numFooters)) {
             final View item = mDslv.getChildAt(touchPos - mDslv.getFirstVisiblePosition());
-            final int rawX = (int)ev.getRawX();
-            final int rawY = (int)ev.getRawY();
+            final int rawX = (int) ev.getRawX();
+            final int rawY = (int) ev.getRawY();
 
-            View dragBox = id == 0 ? item : (View)item.findViewById(id);
+            View dragBox = id == 0 ? item : (View) item.findViewById(id);
             if (dragBox != null) {
                 dragBox.getLocationOnScreen(mTempLoc);
 
@@ -363,7 +371,7 @@ public class DragSortController extends SimpleFloatViewManager
 
         mHitPos = startDragPosition(ev);
         if (mHitPos != MISS && mDragInitMode == ON_DOWN) {
-            startDrag(mHitPos, (int)ev.getX() - mItemX, (int)ev.getY() - mItemY);
+            startDrag(mHitPos, (int) ev.getX() - mItemX, (int) ev.getY() - mItemY);
         }
 
         mIsRemoving = false;
@@ -377,10 +385,10 @@ public class DragSortController extends SimpleFloatViewManager
     @Override
     public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
 
-        final int x1 = (int)e1.getX();
-        final int y1 = (int)e1.getY();
-        final int x2 = (int)e2.getX();
-        final int y2 = (int)e2.getY();
+        final int x1 = (int) e1.getX();
+        final int y1 = (int) e1.getY();
+        final int x2 = (int) e2.getX();
+        final int y2 = (int) e2.getY();
         final int deltaX = x2 - mItemX;
         final int deltaY = y2 - mItemY;
 
@@ -398,8 +406,8 @@ public class DragSortController extends SimpleFloatViewManager
                     startDrag(mFlingHitPos, deltaX, deltaY);
                 } else if (Math.abs(y2 - y1) > mTouchSlop) {
                     mCanDrag = false; // if started to scroll the list then
-                                      // don't allow sorting nor
-                                      // fling-removing
+                    // don't allow sorting nor
+                    // fling-removing
                 }
             }
         }
@@ -439,26 +447,4 @@ public class DragSortController extends SimpleFloatViewManager
         // do nothing
     }
 
-    private GestureDetector.OnGestureListener mFlingRemoveListener = new GestureDetector.SimpleOnGestureListener() {
-        @Override
-        public final boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
-            // Log.d("mobeta", "on fling remove called");
-            if (mRemoveEnabled && mIsRemoving) {
-                int w = mDslv.getWidth();
-                int minPos = w / 5;
-                if (velocityX > mFlingSpeed) {
-                    if (mPositionX > -minPos) {
-                        mDslv.stopDragWithVelocity(true, velocityX);
-                    }
-                } else if (velocityX < -mFlingSpeed) {
-                    if (mPositionX < minPos) {
-                        mDslv.stopDragWithVelocity(true, velocityX);
-                    }
-                }
-                mIsRemoving = false;
-            }
-            return false;
-        }
-    };
-
 }
diff --git a/qDict/src/main/java/com/mmt/widget/draglistview/DragSortCursorAdapter.java b/qDict/src/main/java/com/mmt/widget/draglistview/DragSortCursorAdapter.java
index 51cdde6..9d058d0 100644
--- a/qDict/src/main/java/com/mmt/widget/draglistview/DragSortCursorAdapter.java
+++ b/qDict/src/main/java/com/mmt/widget/draglistview/DragSortCursorAdapter.java
@@ -1,11 +1,5 @@
-
 package com.mmt.widget.draglistview;
 
-import java.util.ArrayList;
-
-import com.mmt.widget.DragSortListView;
-import com.mmt.widget.DragSortListView.DragSortListener;
-
 import android.content.Context;
 import android.database.Cursor;
 import android.support.v4.widget.CursorAdapter;
@@ -14,6 +8,11 @@ import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ListAdapter;
 
+import com.mmt.widget.DragSortListView;
+import com.mmt.widget.DragSortListView.DragSortListener;
+
+import java.util.ArrayList;
+
 /**
  * A subclass of {@link android.widget.CursorAdapter} that provides reordering
  * of the elements in the Cursor based on completed drag-sort operations. The
@@ -51,7 +50,7 @@ public abstract class DragSortCursorAdapter extends CursorAdapter implements Dra
 
     /**
      * Swaps Cursor and clears list-Cursor mapping.
-     * 
+     *
      * @see android.widget.CursorAdapter#swapCursor(android.database.Cursor)
      */
     @Override
@@ -63,7 +62,7 @@ public abstract class DragSortCursorAdapter extends CursorAdapter implements Dra
 
     /**
      * Changes Cursor and clears list-Cursor mapping.
-     * 
+     *
      * @see android.widget.CursorAdapter#changeCursor(android.database.Cursor)
      */
     @Override
@@ -109,7 +108,7 @@ public abstract class DragSortCursorAdapter extends CursorAdapter implements Dra
      * On drop, this updates the mapping between Cursor positions and ListView
      * positions. The Cursor is unchanged. Retrieve the current mapping with
      * {@link getCursorPositions()}.
-     * 
+     *
      * @see DragSortListView.DropListener#drop(int, int)
      */
     @Override
@@ -137,7 +136,7 @@ public abstract class DragSortCursorAdapter extends CursorAdapter implements Dra
      * On remove, this updates the mapping between Cursor positions and ListView
      * positions. The Cursor is unchanged. Retrieve the current mapping with
      * {@link getCursorPositions()}.
-     * 
+     *
      * @see DragSortListView.RemoveListener#remove(int)
      */
     @Override
@@ -193,7 +192,7 @@ public abstract class DragSortCursorAdapter extends CursorAdapter implements Dra
     /**
      * Get the Cursor position mapped to by the provided list position (given
      * all previously handled drag-sort operations).
-     * 
+     *
      * @param position List position
      * @return The mapped-to Cursor position
      */
@@ -218,7 +217,7 @@ public abstract class DragSortCursorAdapter extends CursorAdapter implements Dra
      * Get the list position mapped to by the provided Cursor position. If the
      * provided Cursor position has been removed by a drag-sort, this returns
      * {@link #REMOVED}.
-     * 
+     *
      * @param cursorPosition A Cursor position
      * @return The mapped-to list position or REMOVED
      */
diff --git a/qDict/src/main/java/com/mmt/widget/draglistview/DragSortItemView.java b/qDict/src/main/java/com/mmt/widget/draglistview/DragSortItemView.java
index 988a462..6dbebc5 100644
--- a/qDict/src/main/java/com/mmt/widget/draglistview/DragSortItemView.java
+++ b/qDict/src/main/java/com/mmt/widget/draglistview/DragSortItemView.java
@@ -1,4 +1,3 @@
-
 package com.mmt.widget.draglistview;
 
 import android.content.Context;
@@ -30,14 +29,14 @@ public class DragSortItemView extends ViewGroup {
         // setClipChildren(true);
     }
 
-    public void setGravity(int gravity) {
-        mGravity = gravity;
-    }
-
     public int getGravity() {
         return mGravity;
     }
 
+    public void setGravity(int gravity) {
+        mGravity = gravity;
+    }
+
     @Override
     protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
         final View child = getChildAt(0);
@@ -54,7 +53,7 @@ public class DragSortItemView extends ViewGroup {
     }
 
     /**
-     * 
+     *
      */
     @Override
     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
diff --git a/qDict/src/main/java/com/mmt/widget/draglistview/DragSortItemViewCheckable.java b/qDict/src/main/java/com/mmt/widget/draglistview/DragSortItemViewCheckable.java
index a586810..7ca33d6 100644
--- a/qDict/src/main/java/com/mmt/widget/draglistview/DragSortItemViewCheckable.java
+++ b/qDict/src/main/java/com/mmt/widget/draglistview/DragSortItemViewCheckable.java
@@ -1,4 +1,3 @@
-
 package com.mmt.widget.draglistview;
 
 import android.content.Context;
@@ -24,7 +23,7 @@ public class DragSortItemViewCheckable extends DragSortItemView implements Check
     public boolean isChecked() {
         View child = getChildAt(0);
         if (child instanceof Checkable)
-            return ((Checkable)child).isChecked();
+            return ((Checkable) child).isChecked();
         else
             return false;
     }
@@ -33,13 +32,13 @@ public class DragSortItemViewCheckable extends DragSortItemView implements Check
     public void setChecked(boolean checked) {
         View child = getChildAt(0);
         if (child instanceof Checkable)
-            ((Checkable)child).setChecked(checked);
+            ((Checkable) child).setChecked(checked);
     }
 
     @Override
     public void toggle() {
         View child = getChildAt(0);
         if (child instanceof Checkable)
-            ((Checkable)child).toggle();
+            ((Checkable) child).toggle();
     }
 }
diff --git a/qDict/src/main/java/com/mmt/widget/draglistview/ResourceDragSortCursorAdapter.java b/qDict/src/main/java/com/mmt/widget/draglistview/ResourceDragSortCursorAdapter.java
index c5a328b..217b635 100644
--- a/qDict/src/main/java/com/mmt/widget/draglistview/ResourceDragSortCursorAdapter.java
+++ b/qDict/src/main/java/com/mmt/widget/draglistview/ResourceDragSortCursorAdapter.java
@@ -40,24 +40,24 @@ public abstract class ResourceDragSortCursorAdapter extends DragSortCursorAdapte
 
     /**
      * Constructor the enables auto-requery.
-     * 
-     * @deprecated This option is discouraged, as it results in Cursor queries
-     *             being performed on the application's UI thread and thus can
-     *             cause poor responsiveness or even Application Not Responding
-     *             errors. As an alternative, use
-     *             {@link android.app.LoaderManager} with a
-     *             {@link android.content.CursorLoader}.
+     *
      * @param context The context where the ListView associated with this
-     *            adapter is running
-     * @param layout resource identifier of a layout file that defines the views
-     *            for this list item. Unless you override them later, this will
-     *            define both the item views and the drop down views.
+     *                adapter is running
+     * @param layout  resource identifier of a layout file that defines the views
+     *                for this list item. Unless you override them later, this will
+     *                define both the item views and the drop down views.
+     * @deprecated This option is discouraged, as it results in Cursor queries
+     * being performed on the application's UI thread and thus can
+     * cause poor responsiveness or even Application Not Responding
+     * errors. As an alternative, use
+     * {@link android.app.LoaderManager} with a
+     * {@link android.content.CursorLoader}.
      */
     @Deprecated
     public ResourceDragSortCursorAdapter(Context context, int layout, Cursor c) {
         super(context, c);
         mLayout = mDropDownLayout = layout;
-        mInflater = (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+        mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
     }
 
     /**
@@ -67,46 +67,46 @@ public abstract class ResourceDragSortCursorAdapter extends DragSortCursorAdapte
      * {@link #ResourceCursorAdapter(Context, int, Cursor, int)}. When using
      * this constructor, {@link #FLAG_REGISTER_CONTENT_OBSERVER} will always be
      * set.
-     * 
-     * @param context The context where the ListView associated with this
-     *            adapter is running
-     * @param layout resource identifier of a layout file that defines the views
-     *            for this list item. Unless you override them later, this will
-     *            define both the item views and the drop down views.
-     * @param c The cursor from which to get the data.
+     *
+     * @param context     The context where the ListView associated with this
+     *                    adapter is running
+     * @param layout      resource identifier of a layout file that defines the views
+     *                    for this list item. Unless you override them later, this will
+     *                    define both the item views and the drop down views.
+     * @param c           The cursor from which to get the data.
      * @param autoRequery If true the adapter will call requery() on the cursor
-     *            whenever it changes so the most recent data is always
-     *            displayed. Using true here is discouraged.
+     *                    whenever it changes so the most recent data is always
+     *                    displayed. Using true here is discouraged.
      */
     public ResourceDragSortCursorAdapter(Context context, int layout, Cursor c, boolean autoRequery) {
         super(context, c, autoRequery);
         mLayout = mDropDownLayout = layout;
-        mInflater = (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+        mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
     }
 
     /**
      * Standard constructor.
-     * 
+     *
      * @param context The context where the ListView associated with this
-     *            adapter is running
-     * @param layout Resource identifier of a layout file that defines the views
-     *            for this list item. Unless you override them later, this will
-     *            define both the item views and the drop down views.
-     * @param c The cursor from which to get the data.
-     * @param flags Flags used to determine the behavior of the adapter, as per
-     *            {@link CursorAdapter#CursorAdapter(Context, Cursor, int)}.
+     *                adapter is running
+     * @param layout  Resource identifier of a layout file that defines the views
+     *                for this list item. Unless you override them later, this will
+     *                define both the item views and the drop down views.
+     * @param c       The cursor from which to get the data.
+     * @param flags   Flags used to determine the behavior of the adapter, as per
+     *                {@link CursorAdapter#CursorAdapter(Context, Cursor, int)}.
      */
     public ResourceDragSortCursorAdapter(Context context, int layout, Cursor c, int flags) {
         super(context, c, flags);
         mLayout = mDropDownLayout = layout;
-        mInflater = (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+        mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
     }
 
     /**
      * Inflates view(s) from the specified XML file.
-     * 
+     *
      * @see android.widget.CursorAdapter#newView(android.content.Context,
-     *      android.database.Cursor, ViewGroup)
+     * android.database.Cursor, ViewGroup)
      */
     @Override
     public View newView(Context context, Cursor cursor, ViewGroup parent) {
@@ -122,7 +122,7 @@ public abstract class ResourceDragSortCursorAdapter extends DragSortCursorAdapte
      * <p>
      * Sets the layout resource of the item views.
      * </p>
-     * 
+     *
      * @param layout the layout resources used to create item views
      */
     public void setViewResource(int layout) {
@@ -133,7 +133,7 @@ public abstract class ResourceDragSortCursorAdapter extends DragSortCursorAdapte
      * <p>
      * Sets the layout resource of the drop down views.
      * </p>
-     * 
+     *
      * @param dropDownLayout the layout resources used to create drop down views
      */
     public void setDropDownViewResource(int dropDownLayout) {
diff --git a/qDict/src/main/java/com/mmt/widget/draglistview/SimpleDragSortCursorAdapter.java b/qDict/src/main/java/com/mmt/widget/draglistview/SimpleDragSortCursorAdapter.java
index d2afb00..f6c0e6e 100644
--- a/qDict/src/main/java/com/mmt/widget/draglistview/SimpleDragSortCursorAdapter.java
+++ b/qDict/src/main/java/com/mmt/widget/draglistview/SimpleDragSortCursorAdapter.java
@@ -59,24 +59,20 @@ public class SimpleDragSortCursorAdapter extends ResourceDragSortCursorAdapter {
      * {@hide}
      */
     protected int[] mTo;
-
+    String[] mOriginalFrom;
     private int mStringConversionColumn = -1;
-
     private CursorToStringConverter mCursorToStringConverter;
-
     private ViewBinder mViewBinder;
 
-    String[] mOriginalFrom;
-
     /**
      * Constructor the enables auto-requery.
-     * 
+     *
      * @deprecated This option is discouraged, as it results in Cursor queries
-     *             being performed on the application's UI thread and thus can
-     *             cause poor responsiveness or even Application Not Responding
-     *             errors. As an alternative, use
-     *             {@link android.app.LoaderManager} with a
-     *             {@link android.content.CursorLoader}.
+     * being performed on the application's UI thread and thus can
+     * cause poor responsiveness or even Application Not Responding
+     * errors. As an alternative, use
+     * {@link android.app.LoaderManager} with a
+     * {@link android.content.CursorLoader}.
      */
     @Deprecated
     public SimpleDragSortCursorAdapter(Context context, int layout, Cursor c, String[] from, int[] to) {
@@ -88,22 +84,22 @@ public class SimpleDragSortCursorAdapter extends ResourceDragSortCursorAdapter {
 
     /**
      * Standard constructor.
-     * 
+     *
      * @param context The context where the ListView associated with this
-     *            SimpleListItemFactory is running
-     * @param layout resource identifier of a layout file that defines the views
-     *            for this list item. The layout file should include at least
-     *            those named views defined in "to"
-     * @param c The database cursor. Can be null if the cursor is not available
-     *            yet.
-     * @param from A list of column names representing the data to bind to the
-     *            UI. Can be null if the cursor is not available yet.
-     * @param to The views that should display column in the "from" parameter.
-     *            These should all be TextViews. The first N views in this list
-     *            are given the values of the first N columns in the from
-     *            parameter. Can be null if the cursor is not available yet.
-     * @param flags Flags used to determine the behavior of the adapter, as per
-     *            {@link CursorAdapter#CursorAdapter(Context, Cursor, int)}.
+     *                SimpleListItemFactory is running
+     * @param layout  resource identifier of a layout file that defines the views
+     *                for this list item. The layout file should include at least
+     *                those named views defined in "to"
+     * @param c       The database cursor. Can be null if the cursor is not available
+     *                yet.
+     * @param from    A list of column names representing the data to bind to the
+     *                UI. Can be null if the cursor is not available yet.
+     * @param to      The views that should display column in the "from" parameter.
+     *                These should all be TextViews. The first N views in this list
+     *                are given the values of the first N columns in the from
+     *                parameter. Can be null if the cursor is not available yet.
+     * @param flags   Flags used to determine the behavior of the adapter, as per
+     *                {@link CursorAdapter#CursorAdapter(Context, Cursor, int)}.
      */
     public SimpleDragSortCursorAdapter(Context context, int layout, Cursor c, String[] from, int[] to, int flags) {
         super(context, layout, c, flags);
@@ -124,10 +120,10 @@ public class SimpleDragSortCursorAdapter extends ResourceDragSortCursorAdapter {
      * is false and the view to bind is an ImageView,
      * {@link #setViewImage(ImageView, String)} is invoked. If no appropriate
      * binding can be found, an {@link IllegalStateException} is thrown.
-     * 
+     *
      * @throws IllegalStateException if binding cannot occur
      * @see android.widget.CursorAdapter#bindView(android.view.View,
-     *      android.content.Context, android.database.Cursor)
+     * android.content.Context, android.database.Cursor)
      * @see #getViewBinder()
      * @see #setViewBinder(android.widget.SimpleCursorAdapter.ViewBinder)
      * @see #setViewImage(ImageView, String)
@@ -155,9 +151,9 @@ public class SimpleDragSortCursorAdapter extends ResourceDragSortCursorAdapter {
                     }
 
                     if (v instanceof TextView) {
-                        setViewText((TextView)v, text);
+                        setViewText((TextView) v, text);
                     } else if (v instanceof ImageView) {
-                        setViewImage((ImageView)v, text);
+                        setViewImage((ImageView) v, text);
                     } else {
                         throw new IllegalStateException(v.getClass().getName() + " is not a "
                                 + " view that can be bounds by this SimpleCursorAdapter");
@@ -169,10 +165,10 @@ public class SimpleDragSortCursorAdapter extends ResourceDragSortCursorAdapter {
 
     /**
      * Returns the {@link ViewBinder} used to bind data to views.
-     * 
+     *
      * @return a ViewBinder or null if the binder does not exist
      * @see #bindView(android.view.View, android.content.Context,
-     *      android.database.Cursor)
+     * android.database.Cursor)
      * @see #setViewBinder(android.widget.SimpleCursorAdapter.ViewBinder)
      */
     public ViewBinder getViewBinder() {
@@ -181,11 +177,11 @@ public class SimpleDragSortCursorAdapter extends ResourceDragSortCursorAdapter {
 
     /**
      * Sets the binder used to bind data to views.
-     * 
+     *
      * @param viewBinder the binder used to bind data to views, can be null to
-     *            remove the existing binder
+     *                   remove the existing binder
      * @see #bindView(android.view.View, android.content.Context,
-     *      android.database.Cursor)
+     * android.database.Cursor)
      * @see #getViewBinder()
      */
     public void setViewBinder(ViewBinder viewBinder) {
@@ -199,8 +195,8 @@ public class SimpleDragSortCursorAdapter extends ResourceDragSortCursorAdapter {
      * image resource. If the value cannot be used as an image resource, the
      * value is used as an image Uri. Intended to be overridden by Adapters that
      * need to filter strings retrieved from the database.
-     * 
-     * @param v ImageView to receive an image
+     *
+     * @param v     ImageView to receive an image
      * @param value the value retrieved from the cursor
      */
     public void setViewImage(ImageView v, String value) {
@@ -216,8 +212,8 @@ public class SimpleDragSortCursorAdapter extends ResourceDragSortCursorAdapter {
      * no existing ViewBinder or if the existing ViewBinder cannot handle
      * binding to a TextView. Intended to be overridden by Adapters that need to
      * filter strings retrieved from the database.
-     * 
-     * @param v TextView to receive text
+     *
+     * @param v    TextView to receive text
      * @param text the text to be set for the TextView
      */
     public void setViewText(TextView v, String text) {
@@ -227,7 +223,7 @@ public class SimpleDragSortCursorAdapter extends ResourceDragSortCursorAdapter {
     /**
      * Return the index of the column used to get a String representation of the
      * Cursor.
-     * 
+     *
      * @return a valid index in the current Cursor or -1
      * @see android.widget.CursorAdapter#convertToString(android.database.Cursor)
      * @see #setStringConversionColumn(int)
@@ -242,9 +238,9 @@ public class SimpleDragSortCursorAdapter extends ResourceDragSortCursorAdapter {
      * Defines the index of the column in the Cursor used to get a String
      * representation of that Cursor. The column is used to convert the Cursor
      * to a String only when the current CursorToStringConverter is null.
-     * 
+     *
      * @param stringConversionColumn a valid index in the current Cursor or -1
-     *            to use the default conversion mechanism
+     *                               to use the default conversion mechanism
      * @see android.widget.CursorAdapter#convertToString(android.database.Cursor)
      * @see #getStringConversionColumn()
      * @see #setCursorToStringConverter(android.widget.SimpleCursorAdapter.CursorToStringConverter)
@@ -256,9 +252,9 @@ public class SimpleDragSortCursorAdapter extends ResourceDragSortCursorAdapter {
 
     /**
      * Returns the converter used to convert the filtering Cursor into a String.
-     * 
+     *
      * @return null if the converter does not exist or an instance of
-     *         {@link android.widget.SimpleCursorAdapter.CursorToStringConverter}
+     * {@link android.widget.SimpleCursorAdapter.CursorToStringConverter}
      * @see #setCursorToStringConverter(android.widget.SimpleCursorAdapter.CursorToStringConverter)
      * @see #getStringConversionColumn()
      * @see #setStringConversionColumn(int)
@@ -270,9 +266,9 @@ public class SimpleDragSortCursorAdapter extends ResourceDragSortCursorAdapter {
 
     /**
      * Sets the converter used to convert the filtering Cursor into a String.
-     * 
+     *
      * @param cursorToStringConverter the Cursor to String converter, or null to
-     *            remove the converter
+     *                                remove the converter
      * @see #setCursorToStringConverter(android.widget.SimpleCursorAdapter.CursorToStringConverter)
      * @see #getStringConversionColumn()
      * @see #setStringConversionColumn(int)
@@ -288,7 +284,7 @@ public class SimpleDragSortCursorAdapter extends ResourceDragSortCursorAdapter {
      * been set, the String conversion column is used instead. If the conversion
      * column is -1, the returned String is empty if the cursor is null or
      * Cursor.toString().
-     * 
+     *
      * @param cursor the Cursor to convert to a CharSequence
      * @return a non-null CharSequence representing the cursor
      */
@@ -306,8 +302,8 @@ public class SimpleDragSortCursorAdapter extends ResourceDragSortCursorAdapter {
     /**
      * Create a map from an array of strings to an array of column-id integers
      * in cursor c. If c is null, the array will be discarded.
-     * 
-     * @param c the cursor to find the columns from
+     *
+     * @param c    the cursor to find the columns from
      * @param from the Strings naming the columns of interest
      */
     private void findColumns(Cursor c, String[] from) {
@@ -337,15 +333,15 @@ public class SimpleDragSortCursorAdapter extends ResourceDragSortCursorAdapter {
     /**
      * Change the cursor and change the column-to-view mappings at the same
      * time.
-     * 
-     * @param c The database cursor. Can be null if the cursor is not available
-     *            yet.
+     *
+     * @param c    The database cursor. Can be null if the cursor is not available
+     *             yet.
      * @param from A list of column names representing the data to bind to the
-     *            UI. Can be null if the cursor is not available yet.
-     * @param to The views that should display column in the "from" parameter.
-     *            These should all be TextViews. The first N views in this list
-     *            are given the values of the first N columns in the from
-     *            parameter. Can be null if the cursor is not available yet.
+     *             UI. Can be null if the cursor is not available yet.
+     * @param to   The views that should display column in the "from" parameter.
+     *             These should all be TextViews. The first N views in this list
+     *             are given the values of the first N columns in the from
+     *             parameter. Can be null if the cursor is not available yet.
      */
     public void changeCursorAndColumns(Cursor c, String[] from, int[] to) {
         mOriginalFrom = from;
@@ -363,9 +359,9 @@ public class SimpleDragSortCursorAdapter extends ResourceDragSortCursorAdapter {
      * from the Cursor to views that are not directly supported by
      * SimpleCursorAdapter or to change the way binding occurs for views
      * supported by SimpleCursorAdapter.
-     * 
+     *
      * @see SimpleCursorAdapter#bindView(android.view.View,
-     *      android.content.Context, android.database.Cursor)
+     * android.content.Context, android.database.Cursor)
      * @see SimpleCursorAdapter#setViewImage(ImageView, String)
      * @see SimpleCursorAdapter#setViewText(TextView, String)
      */
@@ -375,11 +371,11 @@ public class SimpleDragSortCursorAdapter extends ResourceDragSortCursorAdapter {
          * specified view. When binding is handled by this ViewBinder, this
          * method must return true. If this method returns false,
          * SimpleCursorAdapter will attempts to handle the binding on its own.
-         * 
-         * @param view the view to bind the data to
-         * @param cursor the cursor to get the data from
+         *
+         * @param view        the view to bind the data to
+         * @param cursor      the cursor to get the data from
          * @param columnIndex the column at which the data can be found in the
-         *            cursor
+         *                    cursor
          * @return true if the data was bound to the view, false otherwise
          */
         boolean setViewValue(View view, Cursor cursor, int columnIndex);
@@ -388,15 +384,15 @@ public class SimpleDragSortCursorAdapter extends ResourceDragSortCursorAdapter {
     /**
      * This class can be used by external clients of SimpleCursorAdapter to
      * define how the Cursor should be converted to a String.
-     * 
+     *
      * @see android.widget.CursorAdapter#convertToString(android.database.Cursor)
      */
     public static interface CursorToStringConverter {
         /**
          * Returns a CharSequence representing the specified Cursor.
-         * 
+         *
          * @param cursor the cursor for which a CharSequence representation is
-         *            requested
+         *               requested
          * @return a non-null CharSequence representing the cursor
          */
         CharSequence convertToString(Cursor cursor);
diff --git a/qDict/src/main/java/com/mmt/widget/draglistview/SimpleFloatViewManager.java b/qDict/src/main/java/com/mmt/widget/draglistview/SimpleFloatViewManager.java
index dacf1d7..33b6e2d 100644
--- a/qDict/src/main/java/com/mmt/widget/draglistview/SimpleFloatViewManager.java
+++ b/qDict/src/main/java/com/mmt/widget/draglistview/SimpleFloatViewManager.java
@@ -1,8 +1,5 @@
-
 package com.mmt.widget.draglistview;
 
-import com.mmt.widget.DragSortListView;
-
 import android.graphics.Bitmap;
 import android.graphics.Color;
 import android.graphics.Point;
@@ -11,6 +8,8 @@ import android.view.ViewGroup;
 import android.widget.ImageView;
 import android.widget.ListView;
 
+import com.mmt.widget.DragSortListView;
+
 /**
  * Simple implementation of the FloatViewManager class. Uses list items as they
  * appear in the ListView to create the floating View.
@@ -81,7 +80,7 @@ public class SimpleFloatViewManager implements DragSortListView.FloatViewManager
      */
     @Override
     public void onDestroyFloatView(View floatView) {
-        ((ImageView)floatView).setImageDrawable(null);
+        ((ImageView) floatView).setImageDrawable(null);
 
         mFloatBitmap.recycle();
         mFloatBitmap = null;
diff --git a/qDict/src/main/java/com/mmt/widget/slidemenu/CanvasTransformerBuilder.java b/qDict/src/main/java/com/mmt/widget/slidemenu/CanvasTransformerBuilder.java
index c5aae39..9f657b4 100644
--- a/qDict/src/main/java/com/mmt/widget/slidemenu/CanvasTransformerBuilder.java
+++ b/qDict/src/main/java/com/mmt/widget/slidemenu/CanvasTransformerBuilder.java
@@ -1,20 +1,18 @@
-
 package com.mmt.widget.slidemenu;
 
-import com.mmt.widget.slidemenu.SlidingMenu.CanvasTransformer;
-
 import android.graphics.Canvas;
 import android.view.animation.Interpolator;
 
-public class CanvasTransformerBuilder {
+import com.mmt.widget.slidemenu.SlidingMenu.CanvasTransformer;
 
-    private CanvasTransformer mTrans;
+public class CanvasTransformerBuilder {
 
     private static Interpolator lin = new Interpolator() {
         public float getInterpolation(float t) {
             return t;
         }
     };
+    private CanvasTransformer mTrans;
 
     private void initTransformer() {
         if (mTrans == null)
@@ -25,12 +23,12 @@ public class CanvasTransformerBuilder {
     }
 
     public CanvasTransformer zoom(final int openedX, final int closedX, final int openedY, final int closedY,
-            final int px, final int py) {
+                                  final int px, final int py) {
         return zoom(openedX, closedX, openedY, closedY, px, py, lin);
     }
 
     public CanvasTransformer zoom(final int openedX, final int closedX, final int openedY, final int closedY,
-            final int px, final int py, final Interpolator interp) {
+                                  final int px, final int py, final Interpolator interp) {
         initTransformer();
         mTrans = new CanvasTransformer() {
             public void transformCanvas(Canvas canvas, float percentOpen) {
@@ -47,7 +45,7 @@ public class CanvasTransformerBuilder {
     }
 
     public CanvasTransformer rotate(final int openedDeg, final int closedDeg, final int px, final int py,
-            final Interpolator interp) {
+                                    final Interpolator interp) {
         initTransformer();
         mTrans = new CanvasTransformer() {
             public void transformCanvas(Canvas canvas, float percentOpen) {
@@ -64,7 +62,7 @@ public class CanvasTransformerBuilder {
     }
 
     public CanvasTransformer translate(final int openedX, final int closedX, final int openedY, final int closedY,
-            final Interpolator interp) {
+                                       final Interpolator interp) {
         initTransformer();
         mTrans = new CanvasTransformer() {
             public void transformCanvas(Canvas canvas, float percentOpen) {
diff --git a/qDict/src/main/java/com/mmt/widget/slidemenu/CustomViewAbove.java b/qDict/src/main/java/com/mmt/widget/slidemenu/CustomViewAbove.java
index 87692d8..e951a78 100644
--- a/qDict/src/main/java/com/mmt/widget/slidemenu/CustomViewAbove.java
+++ b/qDict/src/main/java/com/mmt/widget/slidemenu/CustomViewAbove.java
@@ -1,12 +1,5 @@
-
 package com.mmt.widget.slidemenu;
 
-import java.util.ArrayList;
-import java.util.List;
-
-import com.mmt.widget.slidemenu.SlidingMenu.OnClosedListener;
-import com.mmt.widget.slidemenu.SlidingMenu.OnOpenedListener;
-
 import android.content.Context;
 import android.graphics.Canvas;
 import android.graphics.Rect;
@@ -29,6 +22,12 @@ import android.view.ViewGroup;
 import android.view.animation.Interpolator;
 import android.widget.Scroller;
 
+import com.mmt.widget.slidemenu.SlidingMenu.OnClosedListener;
+import com.mmt.widget.slidemenu.SlidingMenu.OnOpenedListener;
+
+import java.util.ArrayList;
+import java.util.List;
+
 public class CustomViewAbove extends ViewGroup {
 
     private static final String TAG = "CustomViewAbove";
@@ -47,124 +46,53 @@ public class CustomViewAbove extends ViewGroup {
             return t * t * t * t * t + 1.0f;
         }
     };
-
+    /**
+     * Sentinel value for no current active pointer. Used by
+     * {@link #mActivePointerId}.
+     */
+    private static final int INVALID_POINTER = -1;
+    /**
+     * ID of the active pointer. This is used to retain consistency during
+     * drags/flings if multiple pointers are used.
+     */
+    protected int mActivePointerId = INVALID_POINTER;
+    /**
+     * Determines speed during touch scrolling
+     */
+    protected VelocityTracker mVelocityTracker;
+    protected int mMaximumVelocity;
+    protected int mTouchMode = SlidingMenu.TOUCHMODE_MARGIN;
     private View mContent;
-
     private int mCurItem;
-
     private Scroller mScroller;
-
     private boolean mScrollingCacheEnabled;
-
     private boolean mScrolling;
-
     private boolean mIsBeingDragged;
-
     private boolean mIsUnableToDrag;
-
     private int mTouchSlop;
-
     private float mInitialMotionX;
-
     /**
      * Position of the last motion event.
      */
     private float mLastMotionX;
-
     private float mLastMotionY;
-
-    /**
-     * ID of the active pointer. This is used to retain consistency during
-     * drags/flings if multiple pointers are used.
-     */
-    protected int mActivePointerId = INVALID_POINTER;
-
-    /**
-     * Sentinel value for no current active pointer. Used by
-     * {@link #mActivePointerId}.
-     */
-    private static final int INVALID_POINTER = -1;
-
-    /**
-     * Determines speed during touch scrolling
-     */
-    protected VelocityTracker mVelocityTracker;
-
     private int mMinimumVelocity;
-
-    protected int mMaximumVelocity;
-
     private int mFlingDistance;
-
     private CustomViewBehind mViewBehind;
-
     // private int mMode;
     private boolean mEnabled = true;
-
     private OnPageChangeListener mOnPageChangeListener;
-
     private OnPageChangeListener mInternalPageChangeListener;
-
     // private OnCloseListener mCloseListener;
     // private OnOpenListener mOpenListener;
     private OnClosedListener mClosedListener;
-
     private OnOpenedListener mOpenedListener;
 
-    private List<View> mIgnoredViews = new ArrayList<View>();
-
     // private int mScrollState = SCROLL_STATE_IDLE;
-
-    /**
-     * Callback interface for responding to changing state of the selected page.
-     */
-    public interface OnPageChangeListener {
-
-        /**
-         * This method will be invoked when the current page is scrolled, either
-         * as part of a programmatically initiated smooth scroll or a user
-         * initiated touch scroll.
-         * 
-         * @param position Position index of the first page currently being
-         *            displayed. Page position+1 will be visible if
-         *            positionOffset is nonzero.
-         * @param positionOffset Value from [0, 1) indicating the offset from
-         *            the page at position.
-         * @param positionOffsetPixels Value in pixels indicating the offset
-         *            from position.
-         */
-        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels);
-
-        /**
-         * This method will be invoked when a new page becomes selected.
-         * Animation is not necessarily complete.
-         * 
-         * @param position Position index of the new selected page.
-         */
-        public void onPageSelected(int position);
-
-    }
-
-    /**
-     * Simple implementation of the {@link OnPageChangeListener} interface with
-     * stub implementations of each method. Extend this if you do not intend to
-     * override every method of {@link OnPageChangeListener}.
-     */
-    public static class SimpleOnPageChangeListener implements OnPageChangeListener {
-
-        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
-            // This space for rent
-        }
-
-        public void onPageSelected(int position) {
-            // This space for rent
-        }
-
-        public void onPageScrollStateChanged(int state) {
-            // This space for rent
-        }
-
-    }
+    private List<View> mIgnoredViews = new ArrayList<View>();
+    private boolean mQuickReturn = false;
+    // variables for drawing
+    private float mScrollX = 0.0f;
 
     public CustomViewAbove(Context context) {
         this(context, null);
@@ -202,26 +130,15 @@ public class CustomViewAbove extends ViewGroup {
         });
 
         final float density = context.getResources().getDisplayMetrics().density;
-        mFlingDistance = (int)(MIN_DISTANCE_FOR_FLING * density);
-    }
-
-    /**
-     * Set the currently selected page. If the CustomViewPager has already been
-     * through its first layout there will be a smooth animated transition
-     * between the current item and the specified item.
-     * 
-     * @param item Item index to select
-     */
-    public void setCurrentItem(int item) {
-        setCurrentItemInternal(item, true, false);
+        mFlingDistance = (int) (MIN_DISTANCE_FOR_FLING * density);
     }
 
     /**
      * Set the currently selected page.
-     * 
-     * @param item Item index to select
+     *
+     * @param item         Item index to select
      * @param smoothScroll True to smoothly scroll to the new item, false to
-     *            transition immediately
+     *                     transition immediately
      */
     public void setCurrentItem(int item, boolean smoothScroll) {
         setCurrentItemInternal(item, smoothScroll, false);
@@ -231,6 +148,17 @@ public class CustomViewAbove extends ViewGroup {
         return mCurItem;
     }
 
+    /**
+     * Set the currently selected page. If the CustomViewPager has already been
+     * through its first layout there will be a smooth animated transition
+     * between the current item and the specified item.
+     *
+     * @param item Item index to select
+     */
+    public void setCurrentItem(int item) {
+        setCurrentItemInternal(item, true, false);
+    }
+
     void setCurrentItemInternal(int item, boolean smoothScroll, boolean always) {
         setCurrentItemInternal(item, smoothScroll, always, 0);
     }
@@ -263,7 +191,7 @@ public class CustomViewAbove extends ViewGroup {
     /**
      * Set a listener that will be invoked whenever the page changes or is
      * incrementally scrolled. See {@link OnPageChangeListener}.
-     * 
+     *
      * @param listener Listener to set
      */
     public void setOnPageChangeListener(OnPageChangeListener listener) {
@@ -285,7 +213,7 @@ public class CustomViewAbove extends ViewGroup {
     /**
      * Set a separate OnPageChangeListener for internal use by the support
      * library.
-     * 
+     *
      * @param listener Listener to set
      * @return The old listener that was set, if any.
      */
@@ -319,7 +247,7 @@ public class CustomViewAbove extends ViewGroup {
     float distanceInfluenceForSnapDuration(float f) {
         f -= 0.5f; // center the values about 0.
         f *= 0.3f * Math.PI / 2.0f;
-        return (float)Math.sin(f);
+        return (float) Math.sin(f);
     }
 
     public int getDestScrollX(int page) {
@@ -353,7 +281,7 @@ public class CustomViewAbove extends ViewGroup {
         Rect rect = new Rect();
         for (View v : mIgnoredViews) {
             v.getHitRect(rect);
-            if (rect.contains((int)ev.getX(), (int)ev.getY()))
+            if (rect.contains((int) ev.getX(), (int) ev.getY()))
                 return true;
         }
         return false;
@@ -388,7 +316,7 @@ public class CustomViewAbove extends ViewGroup {
 
     /**
      * Like {@link View#scrollBy}, but scroll smoothly instead of immediately.
-     * 
+     *
      * @param x the number of pixels to scroll by on the X axis
      * @param y the number of pixels to scroll by on the Y axis
      */
@@ -398,11 +326,11 @@ public class CustomViewAbove extends ViewGroup {
 
     /**
      * Like {@link View#scrollBy}, but scroll smoothly instead of immediately.
-     * 
-     * @param x the number of pixels to scroll by on the X axis
-     * @param y the number of pixels to scroll by on the Y axis
+     *
+     * @param x        the number of pixels to scroll by on the X axis
+     * @param y        the number of pixels to scroll by on the Y axis
      * @param velocity the velocity associated with a fling, if applicable. (0
-     *            otherwise)
+     *                 otherwise)
      */
     void smoothScrollTo(int x, int y, int velocity) {
         if (getChildCount() == 0) {
@@ -439,8 +367,8 @@ public class CustomViewAbove extends ViewGroup {
         if (velocity > 0) {
             duration = 4 * Math.round(1000 * Math.abs(distance / velocity));
         } else {
-            final float pageDelta = (float)Math.abs(dx) / width;
-            duration = (int)((pageDelta + 1) * 100);
+            final float pageDelta = (float) Math.abs(dx) / width;
+            duration = (int) ((pageDelta + 1) * 100);
             duration = MAX_SETTLE_DURATION;
         }
         duration = Math.min(duration, MAX_SETTLE_DURATION);
@@ -449,6 +377,10 @@ public class CustomViewAbove extends ViewGroup {
         invalidate();
     }
 
+    public View getContent() {
+        return mContent;
+    }
+
     public void setContent(View v) {
         if (mContent != null)
             this.removeView(mContent);
@@ -456,10 +388,6 @@ public class CustomViewAbove extends ViewGroup {
         addView(mContent);
     }
 
-    public View getContent() {
-        return mContent;
-    }
-
     public void setCustomViewBehind(CustomViewBehind cvb) {
         mViewBehind = cvb;
     }
@@ -533,7 +461,7 @@ public class CustomViewAbove extends ViewGroup {
         final int widthWithMargin = getWidth();
         final int position = xpos / widthWithMargin;
         final int offsetPixels = xpos % widthWithMargin;
-        final float offset = (float)offsetPixels / widthWithMargin;
+        final float offset = (float) offsetPixels / widthWithMargin;
 
         onPageScrolled(position, offset, offsetPixels);
     }
@@ -544,12 +472,12 @@ public class CustomViewAbove extends ViewGroup {
      * touch scroll. If you override this method you must call through to the
      * superclass implementation (e.g. super.onPageScrolled(position, offset,
      * offsetPixels)) before onPageScrolled returns.
-     * 
-     * @param position Position index of the first page currently being
-     *            displayed. Page position+1 will be visible if positionOffset
-     *            is nonzero.
-     * @param offset Value from [0, 1) indicating the offset from the page at
-     *            position.
+     *
+     * @param position     Position index of the first page currently being
+     *                     displayed. Page position+1 will be visible if positionOffset
+     *                     is nonzero.
+     * @param offset       Value from [0, 1) indicating the offset from the page at
+     *                     position.
      * @param offsetPixels Value in pixels indicating the offset from position.
      */
     protected void onPageScrolled(int position, float offset, int offsetPixels) {
@@ -585,18 +513,16 @@ public class CustomViewAbove extends ViewGroup {
         mScrolling = false;
     }
 
-    protected int mTouchMode = SlidingMenu.TOUCHMODE_MARGIN;
+    public int getTouchMode() {
+        return mTouchMode;
+    }
 
     public void setTouchMode(int i) {
         mTouchMode = i;
     }
 
-    public int getTouchMode() {
-        return mTouchMode;
-    }
-
     private boolean thisTouchAllowed(MotionEvent ev) {
-        int x = (int)(ev.getX() + mScrollX);
+        int x = (int) (ev.getX() + mScrollX);
         if (isMenuOpen()) {
             return mViewBehind.menuOpenTouchAllowed(mContent, mCurItem, x);
         } else {
@@ -631,8 +557,6 @@ public class CustomViewAbove extends ViewGroup {
         return activePointerIndex;
     }
 
-    private boolean mQuickReturn = false;
-
     @Override
     public boolean onInterceptTouchEvent(MotionEvent ev) {
 
@@ -742,22 +666,22 @@ public class CustomViewAbove extends ViewGroup {
                         scrollX = rightBound;
                     }
                     // Don't lose the rounded component
-                    mLastMotionX += scrollX - (int)scrollX;
-                    scrollTo((int)scrollX, getScrollY());
-                    pageScrolled((int)scrollX);
+                    mLastMotionX += scrollX - (int) scrollX;
+                    scrollTo((int) scrollX, getScrollY());
+                    pageScrolled((int) scrollX);
                 }
                 break;
             case MotionEvent.ACTION_UP:
                 if (mIsBeingDragged) {
                     final VelocityTracker velocityTracker = mVelocityTracker;
                     velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
-                    int initialVelocity = (int)VelocityTrackerCompat.getXVelocity(velocityTracker, mActivePointerId);
+                    int initialVelocity = (int) VelocityTrackerCompat.getXVelocity(velocityTracker, mActivePointerId);
                     final int scrollX = getScrollX();
-                    final float pageOffset = (float)(scrollX - getDestScrollX(mCurItem)) / getBehindWidth();
+                    final float pageOffset = (float) (scrollX - getDestScrollX(mCurItem)) / getBehindWidth();
                     final int activePointerIndex = getPointerIndex(ev, mActivePointerId);
                     if (mActivePointerId != INVALID_POINTER) {
                         final float x = MotionEventCompat.getX(ev, activePointerIndex);
-                        final int totalDelta = (int)(x - mInitialMotionX);
+                        final int totalDelta = (int) (x - mInitialMotionX);
                         int nextPage = determineTargetPage(pageOffset, initialVelocity, totalDelta);
                         setCurrentItemInternal(nextPage, true, true, initialVelocity);
                     } else {
@@ -823,7 +747,7 @@ public class CustomViewAbove extends ViewGroup {
         super.scrollTo(x, y);
         mScrollX = x;
         mViewBehind.scrollBehindTo(mContent, x, y);
-        ((SlidingMenu)getParent()).manageLayers(getPercentOpen());
+        ((SlidingMenu) getParent()).manageLayers(getPercentOpen());
     }
 
     private int determineTargetPage(float pageOffset, int velocity, int deltaX) {
@@ -835,7 +759,7 @@ public class CustomViewAbove extends ViewGroup {
                 targetPage += 1;
             }
         } else {
-            targetPage = (int)Math.round(mCurItem + pageOffset);
+            targetPage = (int) Math.round(mCurItem + pageOffset);
         }
         return targetPage;
     }
@@ -853,9 +777,6 @@ public class CustomViewAbove extends ViewGroup {
         mViewBehind.drawSelector(mContent, canvas, getPercentOpen());
     }
 
-    // variables for drawing
-    private float mScrollX = 0.0f;
-
     private void onSecondaryPointerUp(MotionEvent ev) {
         if (DEBUG)
             Log.v(TAG, "onSecondaryPointerUp called");
@@ -907,18 +828,18 @@ public class CustomViewAbove extends ViewGroup {
 
     /**
      * Tests scrollability within child views of v given a delta of dx.
-     * 
-     * @param v View to test for horizontal scrollability
+     *
+     * @param v      View to test for horizontal scrollability
      * @param checkV Whether the view v passed should itself be checked for
-     *            scrollability (true), or just its children (false).
-     * @param dx Delta scrolled in pixels
-     * @param x X coordinate of the active touch point
-     * @param y Y coordinate of the active touch point
+     *               scrollability (true), or just its children (false).
+     * @param dx     Delta scrolled in pixels
+     * @param x      X coordinate of the active touch point
+     * @param y      Y coordinate of the active touch point
      * @return true if child views of v can be scrolled by delta of dx.
      */
     protected boolean canScroll(View v, boolean checkV, int dx, int x, int y) {
         if (v instanceof ViewGroup) {
-            final ViewGroup group = (ViewGroup)v;
+            final ViewGroup group = (ViewGroup) v;
             final int scrollX = v.getScrollX();
             final int scrollY = v.getScrollY();
             final int count = group.getChildCount();
@@ -947,7 +868,7 @@ public class CustomViewAbove extends ViewGroup {
      * You can call this function yourself to have the scroll view perform
      * scrolling from a key event, just as if the event had been dispatched to
      * it by the view hierarchy.
-     * 
+     *
      * @param event The key event to execute.
      * @return Return true if the event was handled, else false.
      */
@@ -1029,4 +950,55 @@ public class CustomViewAbove extends ViewGroup {
         return false;
     }
 
+    /**
+     * Callback interface for responding to changing state of the selected page.
+     */
+    public interface OnPageChangeListener {
+
+        /**
+         * This method will be invoked when the current page is scrolled, either
+         * as part of a programmatically initiated smooth scroll or a user
+         * initiated touch scroll.
+         *
+         * @param position             Position index of the first page currently being
+         *                             displayed. Page position+1 will be visible if
+         *                             positionOffset is nonzero.
+         * @param positionOffset       Value from [0, 1) indicating the offset from
+         *                             the page at position.
+         * @param positionOffsetPixels Value in pixels indicating the offset
+         *                             from position.
+         */
+        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels);
+
+        /**
+         * This method will be invoked when a new page becomes selected.
+         * Animation is not necessarily complete.
+         *
+         * @param position Position index of the new selected page.
+         */
+        public void onPageSelected(int position);
+
+    }
+
+    /**
+     * Simple implementation of the {@link OnPageChangeListener} interface with
+     * stub implementations of each method. Extend this if you do not intend to
+     * override every method of {@link OnPageChangeListener}.
+     */
+    public static class SimpleOnPageChangeListener implements OnPageChangeListener {
+
+        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
+            // This space for rent
+        }
+
+        public void onPageSelected(int position) {
+            // This space for rent
+        }
+
+        public void onPageScrollStateChanged(int state) {
+            // This space for rent
+        }
+
+    }
+
 }
diff --git a/qDict/src/main/java/com/mmt/widget/slidemenu/CustomViewBehind.java b/qDict/src/main/java/com/mmt/widget/slidemenu/CustomViewBehind.java
index d290c5e..17ee71e 100644
--- a/qDict/src/main/java/com/mmt/widget/slidemenu/CustomViewBehind.java
+++ b/qDict/src/main/java/com/mmt/widget/slidemenu/CustomViewBehind.java
@@ -1,9 +1,5 @@
-
 package com.mmt.widget.slidemenu;
 
-import com.annie.dictionary.R;
-import com.mmt.widget.slidemenu.SlidingMenu.CanvasTransformer;
-
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
@@ -17,27 +13,33 @@ import android.view.MotionEvent;
 import android.view.View;
 import android.view.ViewGroup;
 
+import com.annie.dictionary.R;
+import com.mmt.widget.slidemenu.SlidingMenu.CanvasTransformer;
+
 public class CustomViewBehind extends ViewGroup {
 
     private static final String TAG = "CustomViewBehind";
 
     private static final int MARGIN_THRESHOLD = 48; // dips
-
+    private final Paint mFadePaint = new Paint();
     private int mTouchMode = SlidingMenu.TOUCHMODE_MARGIN;
-
     private CustomViewAbove mViewAbove;
-
     private View mContent;
-
     private View mSecondaryContent;
-
     private int mMarginThreshold;
-
     private int mWidthOffset;
-
     private CanvasTransformer mTransformer;
-
     private boolean mChildrenEnabled;
+    private int mMode;
+    private boolean mFadeEnabled;
+    private float mScrollScale;
+    private Drawable mShadowDrawable;
+    private Drawable mSecondaryShadowDrawable;
+    private int mShadowWidth;
+    private float mFadeDegree;
+    private boolean mSelectorEnabled = true;
+    private Bitmap mSelectorDrawable;
+    private View mSelectedView;
 
     public CustomViewBehind(Context context) {
         this(context, null);
@@ -45,7 +47,7 @@ public class CustomViewBehind extends ViewGroup {
 
     public CustomViewBehind(Context context, AttributeSet attrs) {
         super(context, attrs);
-        mMarginThreshold = (int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, MARGIN_THRESHOLD,
+        mMarginThreshold = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, MARGIN_THRESHOLD,
                 getResources().getDisplayMetrics());
     }
 
@@ -62,18 +64,22 @@ public class CustomViewBehind extends ViewGroup {
         requestLayout();
     }
 
-    public void setMarginThreshold(int marginThreshold) {
-        mMarginThreshold = marginThreshold;
-    }
-
     public int getMarginThreshold() {
         return mMarginThreshold;
     }
 
+    public void setMarginThreshold(int marginThreshold) {
+        mMarginThreshold = marginThreshold;
+    }
+
     public int getBehindWidth() {
         return mContent.getWidth();
     }
 
+    public View getContent() {
+        return mContent;
+    }
+
     public void setContent(View v) {
         if (mContent != null)
             removeView(mContent);
@@ -81,14 +87,14 @@ public class CustomViewBehind extends ViewGroup {
         addView(mContent);
     }
 
-    public View getContent() {
-        return mContent;
+    public View getSecondaryContent() {
+        return mSecondaryContent;
     }
 
     /**
      * Sets the secondary (right) menu for use when setMode is called with
      * SlidingMenu.LEFT_RIGHT.
-     * 
+     *
      * @param v the right menu
      */
     public void setSecondaryContent(View v) {
@@ -98,10 +104,6 @@ public class CustomViewBehind extends ViewGroup {
         addView(mSecondaryContent);
     }
 
-    public View getSecondaryContent() {
-        return mSecondaryContent;
-    }
-
     public void setChildrenEnabled(boolean enabled) {
         mChildrenEnabled = enabled;
     }
@@ -155,21 +157,9 @@ public class CustomViewBehind extends ViewGroup {
             mSecondaryContent.measure(contentWidth, contentHeight);
     }
 
-    private int mMode;
-
-    private boolean mFadeEnabled;
-
-    private final Paint mFadePaint = new Paint();
-
-    private float mScrollScale;
-
-    private Drawable mShadowDrawable;
-
-    private Drawable mSecondaryShadowDrawable;
-
-    private int mShadowWidth;
-
-    private float mFadeDegree;
+    public int getMode() {
+        return mMode;
+    }
 
     public void setMode(int mode) {
         if (mode == SlidingMenu.LEFT || mode == SlidingMenu.RIGHT) {
@@ -181,18 +171,14 @@ public class CustomViewBehind extends ViewGroup {
         mMode = mode;
     }
 
-    public int getMode() {
-        return mMode;
+    public float getScrollScale() {
+        return mScrollScale;
     }
 
     public void setScrollScale(float scrollScale) {
         mScrollScale = scrollScale;
     }
 
-    public float getScrollScale() {
-        return mScrollScale;
-    }
-
     public void setShadowDrawable(Drawable shadow) {
         mShadowDrawable = shadow;
         invalidate();
@@ -234,19 +220,19 @@ public class CustomViewBehind extends ViewGroup {
         if (mMode == SlidingMenu.LEFT) {
             if (x >= content.getLeft())
                 vis = View.INVISIBLE;
-            scrollTo((int)((x + getBehindWidth()) * mScrollScale), y);
+            scrollTo((int) ((x + getBehindWidth()) * mScrollScale), y);
         } else if (mMode == SlidingMenu.RIGHT) {
             if (x <= content.getLeft())
                 vis = View.INVISIBLE;
-            scrollTo((int)(getBehindWidth() - getWidth() + (x - getBehindWidth()) * mScrollScale), y);
+            scrollTo((int) (getBehindWidth() - getWidth() + (x - getBehindWidth()) * mScrollScale), y);
         } else if (mMode == SlidingMenu.LEFT_RIGHT) {
             mContent.setVisibility(x >= content.getLeft() ? View.INVISIBLE : View.VISIBLE);
             mSecondaryContent.setVisibility(x <= content.getLeft() ? View.INVISIBLE : View.VISIBLE);
             vis = x == 0 ? View.INVISIBLE : View.VISIBLE;
             if (x <= content.getLeft()) {
-                scrollTo((int)((x + getBehindWidth()) * mScrollScale), y);
+                scrollTo((int) ((x + getBehindWidth()) * mScrollScale), y);
             } else {
-                scrollTo((int)(getBehindWidth() - getWidth() + (x - getBehindWidth()) * mScrollScale), y);
+                scrollTo((int) (getBehindWidth() - getWidth() + (x - getBehindWidth()) * mScrollScale), y);
             }
         }
         if (vis == View.INVISIBLE)
@@ -379,7 +365,7 @@ public class CustomViewBehind extends ViewGroup {
     public void drawFade(View content, Canvas canvas, float openPercent) {
         if (!mFadeEnabled)
             return;
-        final int alpha = (int)(mFadeDegree * 255 * Math.abs(1 - openPercent));
+        final int alpha = (int) (mFadeDegree * 255 * Math.abs(1 - openPercent));
         mFadePaint.setColor(Color.argb(alpha, 0, 0, 0));
         int left = 0;
         int right = 0;
@@ -399,21 +385,15 @@ public class CustomViewBehind extends ViewGroup {
         canvas.drawRect(left, 0, right, getHeight(), mFadePaint);
     }
 
-    private boolean mSelectorEnabled = true;
-
-    private Bitmap mSelectorDrawable;
-
-    private View mSelectedView;
-
     public void drawSelector(View content, Canvas canvas, float openPercent) {
         if (!mSelectorEnabled)
             return;
         if (mSelectorDrawable != null && mSelectedView != null) {
-            String tag = (String)mSelectedView.getTag(R.id.selected_view);
+            String tag = (String) mSelectedView.getTag(R.id.selected_view);
             if (tag.equals(TAG + "SelectedView")) {
                 canvas.save();
                 int left, right, offset;
-                offset = (int)(mSelectorDrawable.getWidth() * openPercent);
+                offset = (int) (mSelectorDrawable.getWidth() * openPercent);
                 if (mMode == SlidingMenu.LEFT) {
                     right = content.getLeft();
                     left = right - offset;
diff --git a/qDict/src/main/java/com/mmt/widget/slidemenu/MenuInterface.java b/qDict/src/main/java/com/mmt/widget/slidemenu/MenuInterface.java
index cc97b2b..d5ce02c 100644
--- a/qDict/src/main/java/com/mmt/widget/slidemenu/MenuInterface.java
+++ b/qDict/src/main/java/com/mmt/widget/slidemenu/MenuInterface.java
@@ -1,4 +1,3 @@
-
 package com.mmt.widget.slidemenu;
 
 import android.graphics.Canvas;
diff --git a/qDict/src/main/java/com/mmt/widget/slidemenu/SlidingMenu.java b/qDict/src/main/java/com/mmt/widget/slidemenu/SlidingMenu.java
index bb5a4ca..1a5ca36 100644
--- a/qDict/src/main/java/com/mmt/widget/slidemenu/SlidingMenu.java
+++ b/qDict/src/main/java/com/mmt/widget/slidemenu/SlidingMenu.java
@@ -1,12 +1,5 @@
-
 package com.mmt.widget.slidemenu;
 
-import java.lang.reflect.Method;
-
-import com.annie.dictionary.R;
-import com.annie.dictionary.utils.Utils;
-import com.mmt.widget.slidemenu.CustomViewAbove.OnPageChangeListener;
-
 import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.app.Activity;
@@ -33,1123 +26,1055 @@ import android.view.ViewGroup;
 import android.view.WindowManager;
 import android.widget.FrameLayout;
 import android.widget.RelativeLayout;
-import android.widget.Toast;
+
+import com.annie.dictionary.R;
+import com.annie.dictionary.utils.Utils;
+import com.mmt.widget.slidemenu.CustomViewAbove.OnPageChangeListener;
+
+import java.lang.reflect.Method;
 
 public class SlidingMenu extends RelativeLayout {
 
-	private static final String TAG = SlidingMenu.class.getSimpleName();
-
-	public static final int SLIDING_WINDOW = 0;
-
-	public static final int SLIDING_CONTENT = 1;
-
-	private boolean mActionbarOverlay = false;
-
-	/**
-	 * Constant value for use with setTouchModeAbove(). Allows the SlidingMenu
-	 * to be opened with a swipe gesture on the screen's margin
-	 */
-	public static final int TOUCHMODE_MARGIN = 0;
-
-	/**
-	 * Constant value for use with setTouchModeAbove(). Allows the SlidingMenu
-	 * to be opened with a swipe gesture anywhere on the screen
-	 */
-	public static final int TOUCHMODE_FULLSCREEN = 1;
-
-	/**
-	 * Constant value for use with setTouchModeAbove(). Denies the SlidingMenu
-	 * to be opened with a swipe gesture
-	 */
-	public static final int TOUCHMODE_NONE = 2;
-
-	/**
-	 * Constant value for use with setMode(). Puts the menu to the left of the
-	 * content.
-	 */
-	public static final int LEFT = 0;
-
-	/**
-	 * Constant value for use with setMode(). Puts the menu to the right of the
-	 * content.
-	 */
-	public static final int RIGHT = 1;
-
-	/**
-	 * Constant value for use with setMode(). Puts menus to the left and right
-	 * of the content.
-	 */
-	public static final int LEFT_RIGHT = 2;
-
-	private CustomViewAbove mViewAbove;
-
-	public CustomViewBehind mViewBehind;
-
-	private OnOpenListener mOpenListener;
-
-	private OnOpenListener mSecondaryOpenListner;
-
-	private OnCloseListener mCloseListener;
-
-	/**
-	 * The listener interface for receiving onOpen events. The class that is
-	 * interested in processing a onOpen event implements this interface, and
-	 * the object created with that class is registered with a component using
-	 * the component's <code>addOnOpenListener<code> method. When the onOpen
-	 * event occurs, that object's appropriate method is invoked
-	 */
-	public interface OnOpenListener {
-
-		/**
-		 * On open.
-		 */
-		public void onOpen();
-	}
-
-	/**
-	 * The listener interface for receiving onOpened events. The class that is
-	 * interested in processing a onOpened event implements this interface, and
-	 * the object created with that class is registered with a component using
-	 * the component's <code>addOnOpenedListener<code> method. When the onOpened
-	 * event occurs, that object's appropriate method is invoked.
-	 *
-	 */
-	public interface OnOpenedListener {
-
-		/**
-		 * On opened.
-		 */
-		public void onOpened();
-	}
-
-	/**
-	 * The listener interface for receiving onClose events. The class that is
-	 * interested in processing a onClose event implements this interface, and
-	 * the object created with that class is registered with a component using
-	 * the component's <code>addOnCloseListener<code> method. When the onClose
-	 * event occurs, that object's appropriate method is invoked.
-	 *
-	 */
-	public interface OnCloseListener {
-
-		/**
-		 * On close.
-		 */
-		public void onClose();
-	}
-
-	/**
-	 * The listener interface for receiving onClosed events. The class that is
-	 * interested in processing a onClosed event implements this interface, and
-	 * the object created with that class is registered with a component using
-	 * the component's <code>addOnClosedListener<code> method. When the onClosed
-	 * event occurs, that object's appropriate method is invoked.
-	 *
-	 */
-	public interface OnClosedListener {
-
-		/**
-		 * On closed.
-		 */
-		public void onClosed();
-	}
-
-	/**
-	 * The Interface CanvasTransformer.
-	 */
-	public interface CanvasTransformer {
-
-		/**
-		 * Transform canvas.
-		 * 
-		 * @param canvas
-		 *            the canvas
-		 * @param percentOpen
-		 *            the percent open
-		 */
-		public void transformCanvas(Canvas canvas, float percentOpen);
-	}
-
-	/**
-	 * Instantiates a new SlidingMenu.
-	 * 
-	 * @param context
-	 *            the associated Context
-	 */
-	public SlidingMenu(Context context) {
-		this(context, null);
-	}
-
-	/**
-	 * Instantiates a new SlidingMenu and attach to Activity.
-	 * 
-	 * @param activity
-	 *            the activity to attach slidingmenu
-	 * @param slideStyle
-	 *            the slidingmenu style
-	 */
-	public SlidingMenu(Activity activity, int slideStyle) {
-		this(activity, null);
-		this.attachToActivity(activity, slideStyle);
-	}
-
-	/**
-	 * Instantiates a new SlidingMenu.
-	 * 
-	 * @param context
-	 *            the associated Context
-	 * @param attrs
-	 *            the attrs
-	 */
-	public SlidingMenu(Context context, AttributeSet attrs) {
-		this(context, attrs, 0);
-	}
-
-	/**
-	 * Instantiates a new SlidingMenu.
-	 * 
-	 * @param context
-	 *            the associated Context
-	 * @param attrs
-	 *            the attrs
-	 * @param defStyle
-	 *            the def style
-	 */
-	public SlidingMenu(Context context, AttributeSet attrs, int defStyle) {
-		super(context, attrs, defStyle);
-
-		LayoutParams behindParams = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
-		mViewBehind = new CustomViewBehind(context);
-		addView(mViewBehind, behindParams);
-		LayoutParams aboveParams = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
-		mViewAbove = new CustomViewAbove(context);
-		addView(mViewAbove, aboveParams);
-		// register the CustomViewBehind with the CustomViewAbove
-		mViewAbove.setCustomViewBehind(mViewBehind);
-		mViewBehind.setCustomViewAbove(mViewAbove);
-		mViewAbove.setOnPageChangeListener(new OnPageChangeListener() {
-			public static final int POSITION_OPEN = 0;
-
-			public static final int POSITION_CLOSE = 1;
-
-			public static final int POSITION_SECONDARY_OPEN = 2;
-
-			public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
-			}
-
-			public void onPageSelected(int position) {
-				if (position == POSITION_OPEN && mOpenListener != null) {
-					mOpenListener.onOpen();
-				} else if (position == POSITION_CLOSE && mCloseListener != null) {
-					mCloseListener.onClose();
-				} else if (position == POSITION_SECONDARY_OPEN && mSecondaryOpenListner != null) {
-					mSecondaryOpenListner.onOpen();
-				}
-			}
-		});
-
-		// now style everything!
-		TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.SlidingMenu);
-		// set the above and behind views if defined in xml
-		int mode = ta.getInt(R.styleable.SlidingMenu_mode, LEFT);
-		setMode(mode);
-		int viewAbove = ta.getResourceId(R.styleable.SlidingMenu_viewAbove, -1);
-		if (viewAbove != -1) {
-			setContent(viewAbove);
-		} else {
-			setContent(new FrameLayout(context));
-		}
-		int viewBehind = ta.getResourceId(R.styleable.SlidingMenu_viewBehind, -1);
-		if (viewBehind != -1) {
-			setMenu(viewBehind);
-		} else {
-			setMenu(new FrameLayout(context));
-		}
-		int touchModeAbove = ta.getInt(R.styleable.SlidingMenu_touchModeAbove, TOUCHMODE_MARGIN);
-		setTouchModeAbove(touchModeAbove);
-		int touchModeBehind = ta.getInt(R.styleable.SlidingMenu_touchModeBehind, TOUCHMODE_MARGIN);
-		setTouchModeBehind(touchModeBehind);
-
-		int offsetBehind = (int) ta.getDimension(R.styleable.SlidingMenu_behindOffset, -1);
-		int widthBehind = (int) ta.getDimension(R.styleable.SlidingMenu_behindWidth, -1);
-		if (offsetBehind != -1 && widthBehind != -1)
-			throw new IllegalStateException("Cannot set both behindOffset and behindWidth for a SlidingMenu");
-		else if (offsetBehind != -1)
-			setBehindOffset(offsetBehind);
-		else if (widthBehind != -1)
-			setBehindWidth(widthBehind);
-		else
-			setBehindOffset(0);
-		float scrollOffsetBehind = ta.getFloat(R.styleable.SlidingMenu_behindScrollScale, 0.33f);
-		setBehindScrollScale(scrollOffsetBehind);
-		int shadowRes = ta.getResourceId(R.styleable.SlidingMenu_shadowDrawable, -1);
-		if (shadowRes != -1) {
-			setShadowDrawable(shadowRes);
-		}
-		int shadowWidth = (int) ta.getDimension(R.styleable.SlidingMenu_shadowWidth, 0);
-		setShadowWidth(shadowWidth);
-		boolean fadeEnabled = ta.getBoolean(R.styleable.SlidingMenu_fadeEnabled, true);
-		setFadeEnabled(fadeEnabled);
-		float fadeDeg = ta.getFloat(R.styleable.SlidingMenu_fadeDegree, 0.33f);
-		setFadeDegree(fadeDeg);
-		boolean selectorEnabled = ta.getBoolean(R.styleable.SlidingMenu_selectorEnabled, false);
-		setSelectorEnabled(selectorEnabled);
-		int selectorRes = ta.getResourceId(R.styleable.SlidingMenu_selectorDrawable, -1);
-		if (selectorRes != -1)
-			setSelectorDrawable(selectorRes);
-		ta.recycle();
-	}
-
-	/**
-	 * Attaches the SlidingMenu to an entire Activity
-	 * 
-	 * @param activity
-	 *            the Activity
-	 * @param slideStyle
-	 *            either SLIDING_CONTENT or SLIDING_WINDOW
-	 */
-	public void attachToActivity(Activity activity, int slideStyle) {
-		attachToActivity(activity, slideStyle, false);
-	}
-
-	/**
-	 * Attaches the SlidingMenu to an entire Activity
-	 * 
-	 * @param activity
-	 *            the Activity
-	 * @param slideStyle
-	 *            either SLIDING_CONTENT or SLIDING_WINDOW
-	 * @param actionbarOverlay
-	 *            whether or not the ActionBar is overlaid
-	 */
-	public void attachToActivity(Activity activity, int slideStyle, boolean actionbarOverlay) {
-		if (slideStyle != SLIDING_WINDOW && slideStyle != SLIDING_CONTENT)
-			throw new IllegalArgumentException("slideStyle must be either SLIDING_WINDOW or SLIDING_CONTENT");
-
-		if (getParent() != null)
-			throw new IllegalStateException("This SlidingMenu appears to already be attached");
-
-		// get the window background
-		TypedArray a = activity.getTheme().obtainStyledAttributes(new int[] { android.R.attr.windowBackground });
-		int background = a.getResourceId(0, 0);
-		a.recycle();
-
-		switch (slideStyle) {
-		case SLIDING_WINDOW:
-			mActionbarOverlay = false;
-			ViewGroup decor = (ViewGroup) activity.getWindow().getDecorView();
-			ViewGroup decorChild = (ViewGroup) decor.getChildAt(0);
-			// save ActionBar themes that have transparent assets
-			decorChild.setBackgroundResource(background);
-			decor.removeView(decorChild);
-			decor.addView(this);
-			setContent(decorChild);
-			break;
-		case SLIDING_CONTENT:
-			mActionbarOverlay = actionbarOverlay;
-			// take the above view out of
-			ViewGroup contentParent = (ViewGroup) activity.findViewById(android.R.id.content);
-			View content = contentParent.getChildAt(0);
-			contentParent.removeView(content);
-			contentParent.addView(this);
-			setContent(content);
-			// save people from having transparent backgrounds
-			if (content.getBackground() == null)
-				content.setBackgroundResource(background);
-			break;
-		}
-	}
-
-	/**
-	 * Set the above view content from a layout resource. The resource will be
-	 * inflated, adding all top-level views to the above view.
-	 * 
-	 * @param res
-	 *            the new content
-	 */
-	public void setContent(int res) {
-		setContent(LayoutInflater.from(getContext()).inflate(res, null));
-	}
-
-	/**
-	 * Set the above view content to the given View.
-	 * 
-	 * @param view
-	 *            The desired content to display.
-	 */
-	public void setContent(View view) {
-		mViewAbove.setContent(view);
-		showContent();
-	}
-
-	/**
-	 * Retrieves the current content.
-	 * 
-	 * @return the current content
-	 */
-	public View getContent() {
-		return mViewAbove.getContent();
-	}
-
-	/**
-	 * Set the behind view (menu) content from a layout resource. The resource
-	 * will be inflated, adding all top-level views to the behind view.
-	 * 
-	 * @param res
-	 *            the new content
-	 */
-	public void setMenu(int res) {
-		setMenu(LayoutInflater.from(getContext()).inflate(res, null));
-	}
-
-	/**
-	 * Set the behind view (menu) content to the given View.
-	 * 
-	 * @param v
-	 *            The desired content to display.
-	 */
-	public void setMenu(View v) {
-		mViewBehind.setContent(v);
-	}
-
-	/**
-	 * Retrieves the main menu.
-	 * 
-	 * @return the main menu
-	 */
-	public View getMenu() {
-		return mViewBehind.getContent();
-	}
-
-	/**
-	 * Set the secondary behind view (right menu) content from a layout
-	 * resource. The resource will be inflated, adding all top-level views to
-	 * the behind view.
-	 * 
-	 * @param res
-	 *            the new content
-	 */
-	public void setSecondaryMenu(int res) {
-		setSecondaryMenu(LayoutInflater.from(getContext()).inflate(res, null));
-	}
-
-	/**
-	 * Set the secondary behind view (right menu) content to the given View.
-	 * 
-	 * @param v
-	 *            The desired content to display.
-	 */
-	public void setSecondaryMenu(View v) {
-		mViewBehind.setSecondaryContent(v);
-		// mViewBehind.invalidate();
-	}
-
-	/**
-	 * Retrieves the current secondary menu (right).
-	 * 
-	 * @return the current menu
-	 */
-	public View getSecondaryMenu() {
-		return mViewBehind.getSecondaryContent();
-	}
-
-	/**
-	 * Sets the sliding enabled.
-	 * 
-	 * @param b
-	 *            true to enable sliding, false to disable it.
-	 */
-	public void setSlidingEnabled(boolean b) {
-		mViewAbove.setSlidingEnabled(b);
-	}
-
-	/**
-	 * Checks if is sliding enabled.
-	 * 
-	 * @return true, if is sliding enabled
-	 */
-	public boolean isSlidingEnabled() {
-		return mViewAbove.isSlidingEnabled();
-	}
-
-	/**
-	 * Sets which side the SlidingMenu should appear on.
-	 * 
-	 * @param mode
-	 *            must be either SlidingMenu.LEFT or SlidingMenu.RIGHT
-	 */
-	public void setMode(int mode) {
-		if (mode != LEFT && mode != RIGHT && mode != LEFT_RIGHT) {
-			throw new IllegalStateException("SlidingMenu mode must be LEFT, RIGHT, or LEFT_RIGHT");
-		}
-		mViewBehind.setMode(mode);
-	}
-
-	/**
-	 * Returns the current side that the SlidingMenu is on.
-	 * 
-	 * @return the current mode, either SlidingMenu.LEFT or SlidingMenu.RIGHT
-	 */
-	public int getMode() {
-		return mViewBehind.getMode();
-	}
-
-	/**
-	 * Sets whether or not the SlidingMenu is in static mode (i.e. nothing is
-	 * moving and everything is showing)
-	 * 
-	 * @param b
-	 *            true to set static mode, false to disable static mode.
-	 */
-	public void setStatic(boolean b) {
-		if (b) {
-			setSlidingEnabled(false);
-			mViewAbove.setCustomViewBehind(null);
-			mViewAbove.setCurrentItem(1);
-			// mViewBehind.setCurrentItem(0);
-		} else {
-			mViewAbove.setCurrentItem(1);
-			// mViewBehind.setCurrentItem(1);
-			mViewAbove.setCustomViewBehind(mViewBehind);
-			setSlidingEnabled(true);
-		}
-	}
-
-	/**
-	 * Opens the menu and shows the menu view.
-	 */
-	public void showMenu() {
-		showMenu(true);
-	}
-
-	/**
-	 * Opens the menu and shows the menu view.
-	 * 
-	 * @param animate
-	 *            true to animate the transition, false to ignore animation
-	 */
-	public void showMenu(boolean animate) {
-		mViewAbove.setCurrentItem(0, animate);
-	}
-
-	/**
-	 * Opens the menu and shows the secondary menu view. Will default to the
-	 * regular menu if there is only one.
-	 */
-	public void showSecondaryMenu() {
-		showSecondaryMenu(true);
-	}
-
-	/**
-	 * Opens the menu and shows the secondary (right) menu view. Will default to
-	 * the regular menu if there is only one.
-	 * 
-	 * @param animate
-	 *            true to animate the transition, false to ignore animation
-	 */
-	public void showSecondaryMenu(boolean animate) {
-		mViewAbove.setCurrentItem(2, animate);
-	}
-
-	/**
-	 * Closes the menu and shows the above view.
-	 */
-	public void showContent() {
-		showContent(true);
-	}
-
-	/**
-	 * Closes the menu and shows the above view.
-	 * 
-	 * @param animate
-	 *            true to animate the transition, false to ignore animation
-	 */
-	public void showContent(boolean animate) {
-		mViewAbove.setCurrentItem(1, animate);
-	}
-
-	/**
-	 * Toggle the SlidingMenu. If it is open, it will be closed, and vice versa.
-	 */
-	public boolean toggle() {
-		return toggle(true);
-	}
-
-	/**
-	 * Toggle the SlidingMenu. If it is open, it will be closed, and vice versa.
-	 * 
-	 * @param animate
-	 *            true to animate the transition, false to ignore animation
-	 */
-	public boolean toggle(boolean animate) {
-		if (isMenuShowing()) {
-			showContent(animate);
-			return true;
-		} else {
-			showMenu(animate);
-			return false;
-		}
-	}
-
-	/**
-	 * Checks if is the behind view showing.
-	 * 
-	 * @return Whether or not the behind view is showing
-	 */
-	public boolean isMenuShowing() {
-		return mViewAbove.getCurrentItem() == 0 || mViewAbove.getCurrentItem() == 2;
-	}
-
-	/**
-	 * Checks if is the behind view showing.
-	 * 
-	 * @return Whether or not the behind view is showing
-	 */
-	public boolean isSecondaryMenuShowing() {
-		return mViewAbove.getCurrentItem() == 2;
-	}
-
-	/**
-	 * Gets the behind offset.
-	 * 
-	 * @return The margin on the right of the screen that the behind view
-	 *         scrolls to
-	 */
-	public int getBehindOffset() {
-		return ((RelativeLayout.LayoutParams) mViewBehind.getLayoutParams()).rightMargin;
-	}
-
-	/**
-	 * Sets the behind offset.
-	 * 
-	 * @param i
-	 *            The margin, in pixels, on the right of the screen that the
-	 *            behind view scrolls to.
-	 */
-	public void setBehindOffset(int i) {
-		// RelativeLayout.LayoutParams params =
-		// ((RelativeLayout.LayoutParams)mViewBehind.getLayoutParams());
-		// int bottom = params.bottomMargin;
-		// int top = params.topMargin;
-		// int left = params.leftMargin;
-		// params.setMargins(left, top, i, bottom);
-		mViewBehind.setWidthOffset(i);
-	}
-
-	/**
-	 * Sets the behind offset.
-	 * 
-	 * @param resID
-	 *            The dimension resource id to be set as the behind offset. The
-	 *            menu, when open, will leave this width margin on the right of
-	 *            the screen.
-	 */
-	public void setBehindOffsetRes(int resID) {
-		int i = (int) getContext().getResources().getDimension(resID);
-		setBehindOffset(i);
-	}
-
-	/**
-	 * Sets the above offset.
-	 * 
-	 * @param i
-	 *            the new above offset, in pixels
-	 */
-	public void setAboveOffset(int i) {
-		mViewAbove.setAboveOffset(i);
-	}
-
-	/**
-	 * Sets the above offset.
-	 * 
-	 * @param resID
-	 *            The dimension resource id to be set as the above offset.
-	 */
-	public void setAboveOffsetRes(int resID) {
-		int i = (int) getContext().getResources().getDimension(resID);
-		setAboveOffset(i);
-	}
-
-	/**
-	 * Sets the behind width.
-	 * 
-	 * @param i
-	 *            The width the Sliding Menu will open to, in pixels
-	 */
-	@SuppressWarnings("deprecation")
-	public void setBehindWidth(int i) {
-		int width;
-		Display display = ((WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
-		try {
-			Class<?> cls = Display.class;
-			Class<?>[] parameterTypes = { Point.class };
-			Point parameter = new Point();
-			Method method = cls.getMethod("getSize", parameterTypes);
-			method.invoke(display, parameter);
-			width = parameter.x;
-		} catch (Exception e) {
-			width = display.getWidth();
-		}
-		setBehindOffset(width - i);
-	}
-
-	/**
-	 * Sets the behind width.
-	 * 
-	 * @param res
-	 *            The dimension resource id to be set as the behind width
-	 *            offset. The menu, when open, will open this wide.
-	 */
-	public void setBehindWidthRes(int res) {
-		int i = (int) getContext().getResources().getDimension(res);
-		setBehindWidth(i);
-	}
-
-	/**
-	 * Gets the behind scroll scale.
-	 * 
-	 * @return The scale of the parallax scroll
-	 */
-	public float getBehindScrollScale() {
-		return mViewBehind.getScrollScale();
-	}
-
-	/**
-	 * Gets the touch mode margin threshold
-	 * 
-	 * @return the touch mode margin threshold
-	 */
-	public int getTouchmodeMarginThreshold() {
-		return mViewBehind.getMarginThreshold();
-	}
-
-	/**
-	 * Set the touch mode margin threshold
-	 * 
-	 * @param touchmodeMarginThreshold
-	 */
-	public void setTouchmodeMarginThreshold(int touchmodeMarginThreshold) {
-		mViewBehind.setMarginThreshold(touchmodeMarginThreshold);
-	}
-
-	/**
-	 * Sets the behind scroll scale.
-	 * 
-	 * @param f
-	 *            The scale of the parallax scroll (i.e. 1.0f scrolls 1 pixel
-	 *            for every 1 pixel that the above view scrolls and 0.0f scrolls
-	 *            0 pixels)
-	 */
-	public void setBehindScrollScale(float f) {
-		if (f < 0 && f > 1)
-			throw new IllegalStateException("ScrollScale must be between 0 and 1");
-		mViewBehind.setScrollScale(f);
-	}
-
-	/**
-	 * Sets the behind canvas transformer.
-	 * 
-	 * @param t
-	 *            the new behind canvas transformer
-	 */
-	public void setBehindCanvasTransformer(CanvasTransformer t) {
-		mViewBehind.setCanvasTransformer(t);
-	}
-
-	/**
-	 * Gets the touch mode above.
-	 * 
-	 * @return the touch mode above
-	 */
-	public int getTouchModeAbove() {
-		return mViewAbove.getTouchMode();
-	}
-
-	/**
-	 * Controls whether the SlidingMenu can be opened with a swipe gesture.
-	 * Options are {@link #TOUCHMODE_MARGIN TOUCHMODE_MARGIN},
-	 * {@link #TOUCHMODE_FULLSCREEN TOUCHMODE_FULLSCREEN}, or
-	 * {@link #TOUCHMODE_NONE TOUCHMODE_NONE}
-	 * 
-	 * @param i
-	 *            the new touch mode
-	 */
-	public void setTouchModeAbove(int i) {
-		if (i != TOUCHMODE_FULLSCREEN && i != TOUCHMODE_MARGIN && i != TOUCHMODE_NONE) {
-			throw new IllegalStateException(
-					"TouchMode must be set to either" + "TOUCHMODE_FULLSCREEN or TOUCHMODE_MARGIN or TOUCHMODE_NONE.");
-		}
-		mViewAbove.setTouchMode(i);
-	}
-
-	/**
-	 * Controls whether the SlidingMenu can be opened with a swipe gesture.
-	 * Options are {@link #TOUCHMODE_MARGIN TOUCHMODE_MARGIN},
-	 * {@link #TOUCHMODE_FULLSCREEN TOUCHMODE_FULLSCREEN}, or
-	 * {@link #TOUCHMODE_NONE TOUCHMODE_NONE}
-	 * 
-	 * @param i
-	 *            the new touch mode
-	 */
-	public void setTouchModeBehind(int i) {
-		if (i != TOUCHMODE_FULLSCREEN && i != TOUCHMODE_MARGIN && i != TOUCHMODE_NONE) {
-			throw new IllegalStateException(
-					"TouchMode must be set to either" + "TOUCHMODE_FULLSCREEN or TOUCHMODE_MARGIN or TOUCHMODE_NONE.");
-		}
-		mViewBehind.setTouchMode(i);
-	}
-
-	/**
-	 * Sets the shadow drawable.
-	 * 
-	 * @param resId
-	 *            the resource ID of the new shadow drawable
-	 */
-	public void setShadowDrawable(int resId) {
-		setShadowDrawable(getDrawable(getContext(), resId));
-	}
-
-	/**
-	 * Sets the shadow drawable.
-	 * 
-	 * @param d
-	 *            the new shadow drawable
-	 */
-	public void setShadowDrawable(Drawable d) {
-		mViewBehind.setShadowDrawable(d);
-	}
-
-	/**
-	 * Sets the secondary (right) shadow drawable.
-	 * 
-	 * @param resId
-	 *            the resource ID of the new shadow drawable
-	 */
-	public void setSecondaryShadowDrawable(int resId) {
-		setSecondaryShadowDrawable(getDrawable(getContext(), resId));
-	}
-
-	/**
-	 * Sets the secondary (right) shadow drawable.
-	 * 
-	 * @param d
-	 *            the new shadow drawable
-	 */
-	public void setSecondaryShadowDrawable(Drawable d) {
-		mViewBehind.setSecondaryShadowDrawable(d);
-	}
-
-	/**
-	 * Sets the shadow width.
-	 * 
-	 * @param resId
-	 *            The dimension resource id to be set as the shadow width.
-	 */
-	public void setShadowWidthRes(int resId) {
-		setShadowWidth((int) getResources().getDimension(resId));
-	}
-
-	public static Drawable getDrawable(Context context, int resource) {
-		if (Build.VERSION.SDK_INT >= 21) {
-			return context.getResources().getDrawable(resource, null);
-		}
-
-		return context.getResources().getDrawable(resource);
-	}
-
-	/**
-	 * Sets the shadow width.
-	 * 
-	 * @param pixels
-	 *            the new shadow width, in pixels
-	 */
-	public void setShadowWidth(int pixels) {
-		mViewBehind.setShadowWidth(pixels);
-	}
-
-	/**
-	 * Enables or disables the SlidingMenu's fade in and out
-	 * 
-	 * @param b
-	 *            true to enable fade, false to disable it
-	 */
-	public void setFadeEnabled(boolean b) {
-		mViewBehind.setFadeEnabled(b);
-	}
-
-	/**
-	 * Sets how much the SlidingMenu fades in and out. Fade must be enabled, see
-	 * {@link #setFadeEnabled(boolean) setFadeEnabled(boolean)}
-	 * 
-	 * @param f
-	 *            the new fade degree, between 0.0f and 1.0f
-	 */
-	public void setFadeDegree(float f) {
-		mViewBehind.setFadeDegree(f);
-	}
-
-	/**
-	 * Enables or disables whether the selector is drawn
-	 * 
-	 * @param b
-	 *            true to draw the selector, false to not draw the selector
-	 */
-	public void setSelectorEnabled(boolean b) {
-		mViewBehind.setSelectorEnabled(true);
-	}
-
-	/**
-	 * Sets the selected view. The selector will be drawn here
-	 * 
-	 * @param v
-	 *            the new selected view
-	 */
-	public void setSelectedView(View v) {
-		mViewBehind.setSelectedView(v);
-	}
-
-	/**
-	 * Sets the selector drawable.
-	 * 
-	 * @param res
-	 *            a resource ID for the selector drawable
-	 */
-	public void setSelectorDrawable(int res) {
-		mViewBehind.setSelectorBitmap(BitmapFactory.decodeResource(getResources(), res));
-	}
-
-	/**
-	 * Sets the selector drawable.
-	 * 
-	 * @param b
-	 *            the new selector bitmap
-	 */
-	public void setSelectorBitmap(Bitmap b) {
-		mViewBehind.setSelectorBitmap(b);
-	}
-
-	/**
-	 * Add a View ignored by the Touch Down event when mode is Fullscreen
-	 * 
-	 * @param v
-	 *            a view to be ignored
-	 */
-	public void addIgnoredView(View v) {
-		mViewAbove.addIgnoredView(v);
-	}
-
-	/**
-	 * Remove a View ignored by the Touch Down event when mode is Fullscreen
-	 * 
-	 * @param v
-	 *            a view not wanted to be ignored anymore
-	 */
-	public void removeIgnoredView(View v) {
-		mViewAbove.removeIgnoredView(v);
-	}
-
-	/**
-	 * Clear the list of Views ignored by the Touch Down event when mode is
-	 * Fullscreen
-	 */
-	public void clearIgnoredViews() {
-		mViewAbove.clearIgnoredViews();
-	}
-
-	/**
-	 * Sets the OnOpenListener. {@link OnOpenListener#onOpen()
-	 * OnOpenListener.onOpen()} will be called when the SlidingMenu is opened
-	 * 
-	 * @param listener
-	 *            the new OnOpenListener
-	 */
-	public void setOnOpenListener(OnOpenListener listener) {
-		// mViewAbove.setOnOpenListener(listener);
-		mOpenListener = listener;
-	}
-
-	/**
-	 * Sets the OnOpenListner for secondary menu {@link OnOpenListener#onOpen()
-	 * OnOpenListener.onOpen()} will be called when the secondary SlidingMenu is
-	 * opened
-	 * 
-	 * @param listener
-	 *            the new OnOpenListener
-	 */
-
-	public void setSecondaryOnOpenListner(OnOpenListener listener) {
-		mSecondaryOpenListner = listener;
-	}
-
-	/**
-	 * Sets the OnCloseListener. {@link OnCloseListener#onClose()
-	 * OnCloseListener.onClose()} will be called when any one of the SlidingMenu
-	 * is closed
-	 * 
-	 * @param listener
-	 *            the new setOnCloseListener
-	 */
-	public void setOnCloseListener(OnCloseListener listener) {
-		// mViewAbove.setOnCloseListener(listener);
-		mCloseListener = listener;
-	}
-
-	/**
-	 * Sets the OnOpenedListener. {@link OnOpenedListener#onOpened()
-	 * OnOpenedListener.onOpened()} will be called after the SlidingMenu is
-	 * opened
-	 * 
-	 * @param listener
-	 *            the new OnOpenedListener
-	 */
-	public void setOnOpenedListener(OnOpenedListener listener) {
-		mViewAbove.setOnOpenedListener(listener);
-	}
-
-	/**
-	 * Sets the OnClosedListener. {@link OnClosedListener#onClosed()
-	 * OnClosedListener.onClosed()} will be called after the SlidingMenu is
-	 * closed
-	 * 
-	 * @param listener
-	 *            the new OnClosedListener
-	 */
-	public void setOnClosedListener(OnClosedListener listener) {
-		mViewAbove.setOnClosedListener(listener);
-	}
-
-	public static class SavedState extends BaseSavedState {
-
-		private final int mItem;
-
-		public SavedState(Parcelable superState, int item) {
-			super(superState);
-			mItem = item;
-		}
-
-		private SavedState(Parcel in) {
-			super(in);
-			mItem = in.readInt();
-		}
-
-		public int getItem() {
-			return mItem;
-		}
-
-		/*
-		 * (non-Javadoc)
-		 * 
-		 * @see android.view.AbsSavedState#writeToParcel(android.os.Parcel, int)
-		 */
-		public void writeToParcel(Parcel out, int flags) {
-			super.writeToParcel(out, flags);
-			out.writeInt(mItem);
-		}
-
-		public static final Parcelable.Creator<SavedState> CREATOR = new Parcelable.Creator<SavedState>() {
-			public SavedState createFromParcel(Parcel in) {
-				return new SavedState(in);
-			}
-
-			public SavedState[] newArray(int size) {
-				return new SavedState[size];
-			}
-		};
-
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see android.view.View#onSaveInstanceState()
-	 */
-	@Override
-	protected Parcelable onSaveInstanceState() {
-		Parcelable superState = super.onSaveInstanceState();
-		SavedState ss = new SavedState(superState, mViewAbove.getCurrentItem());
-		return ss;
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see android.view.View#onRestoreInstanceState(android.os.Parcelable)
-	 */
-	@Override
-	protected void onRestoreInstanceState(Parcelable state) {
-		SavedState ss = (SavedState) state;
-		super.onRestoreInstanceState(ss.getSuperState());
-		mViewAbove.setCurrentItem(ss.getItem());
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see android.view.ViewGroup#fitSystemWindows(android.graphics.Rect)
-	 */
-	@SuppressLint("NewApi")
-	@Override
-	protected boolean fitSystemWindows(Rect insets) {
-		int leftPadding = insets.left;
-		int rightPadding = insets.right;
-		int topPadding = insets.top;
-		int bottomPadding = insets.bottom;
-		String brand = android.os.Build.BRAND;
-		if (Utils.hasLlAbove() && !(brand.equalsIgnoreCase("Bkav") || brand.equalsIgnoreCase("Samsung") || brand.equalsIgnoreCase("Xiaomi"))) {
-
-			Resources resources = getContent().getResources();
-			boolean isBottom = isSystemBarOnBottom(resources);
-			Configuration cfg = resources.getConfiguration();
-			int orientation = cfg.orientation;
-			int resourceId = 0;
-			if (orientation == Configuration.ORIENTATION_LANDSCAPE) {
-				resourceId = resources.getIdentifier("navigation_bar_width", "dimen", "android");
-			} else {
-				resourceId = resources.getIdentifier("navigation_bar_height", "dimen", "android");
-			}
-			if (resourceId > 0) {
-				if (isBottom)
-					bottomPadding += resources.getDimensionPixelSize(resourceId);
-				else {
-					rightPadding += resources.getDimensionPixelSize(resourceId);
-				}
-			}
-		}
-
-		if (!mActionbarOverlay) {
-			setPadding(leftPadding, topPadding, rightPadding, bottomPadding);
-		}
-		return true;
-	}
-
-	private boolean isSystemBarOnBottom(Resources res) {
-		Configuration cfg = res.getConfiguration();
-		DisplayMetrics dm = res.getDisplayMetrics();
-		boolean canMove = (dm.widthPixels != dm.heightPixels && cfg.smallestScreenWidthDp < 600);
-
-		return (!canMove || dm.widthPixels < dm.heightPixels);
-	}
-
-	@TargetApi(11)
-	public void manageLayers(float percentOpen) {
-		if (!Utils.hasHcAbove())
-			return;
-
-		boolean layer = percentOpen > 0.0f && percentOpen < 1.0f;
-		final int layerType = layer ? View.LAYER_TYPE_HARDWARE : View.LAYER_TYPE_NONE;
-
-		if (layerType != getContent().getLayerType()) {
-			getHandler().post(new Runnable() {
-				public void run() {
-					Log.v(TAG, "changing layerType. hardware? " + (layerType == View.LAYER_TYPE_HARDWARE));
-					getContent().setLayerType(layerType, null);
-					getMenu().setLayerType(layerType, null);
-					if (getSecondaryMenu() != null) {
-						getSecondaryMenu().setLayerType(layerType, null);
-					}
-				}
-			});
-		}
-	}
+    public static final int SLIDING_WINDOW = 0;
+    public static final int SLIDING_CONTENT = 1;
+    /**
+     * Constant value for use with setTouchModeAbove(). Allows the SlidingMenu
+     * to be opened with a swipe gesture on the screen's margin
+     */
+    public static final int TOUCHMODE_MARGIN = 0;
+    /**
+     * Constant value for use with setTouchModeAbove(). Allows the SlidingMenu
+     * to be opened with a swipe gesture anywhere on the screen
+     */
+    public static final int TOUCHMODE_FULLSCREEN = 1;
+    /**
+     * Constant value for use with setTouchModeAbove(). Denies the SlidingMenu
+     * to be opened with a swipe gesture
+     */
+    public static final int TOUCHMODE_NONE = 2;
+    /**
+     * Constant value for use with setMode(). Puts the menu to the left of the
+     * content.
+     */
+    public static final int LEFT = 0;
+    /**
+     * Constant value for use with setMode(). Puts the menu to the right of the
+     * content.
+     */
+    public static final int RIGHT = 1;
+    /**
+     * Constant value for use with setMode(). Puts menus to the left and right
+     * of the content.
+     */
+    public static final int LEFT_RIGHT = 2;
+    private static final String TAG = SlidingMenu.class.getSimpleName();
+    public CustomViewBehind mViewBehind;
+    private boolean mActionbarOverlay = false;
+    private CustomViewAbove mViewAbove;
+    private OnOpenListener mOpenListener;
+
+    private OnOpenListener mSecondaryOpenListner;
+
+    private OnCloseListener mCloseListener;
+
+    /**
+     * Instantiates a new SlidingMenu.
+     *
+     * @param context the associated Context
+     */
+    public SlidingMenu(Context context) {
+        this(context, null);
+    }
+
+    /**
+     * Instantiates a new SlidingMenu and attach to Activity.
+     *
+     * @param activity   the activity to attach slidingmenu
+     * @param slideStyle the slidingmenu style
+     */
+    public SlidingMenu(Activity activity, int slideStyle) {
+        this(activity, null);
+        this.attachToActivity(activity, slideStyle);
+    }
+
+    /**
+     * Instantiates a new SlidingMenu.
+     *
+     * @param context the associated Context
+     * @param attrs   the attrs
+     */
+    public SlidingMenu(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    /**
+     * Instantiates a new SlidingMenu.
+     *
+     * @param context  the associated Context
+     * @param attrs    the attrs
+     * @param defStyle the def style
+     */
+    public SlidingMenu(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+
+        LayoutParams behindParams = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
+        mViewBehind = new CustomViewBehind(context);
+        addView(mViewBehind, behindParams);
+        LayoutParams aboveParams = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
+        mViewAbove = new CustomViewAbove(context);
+        addView(mViewAbove, aboveParams);
+        // register the CustomViewBehind with the CustomViewAbove
+        mViewAbove.setCustomViewBehind(mViewBehind);
+        mViewBehind.setCustomViewAbove(mViewAbove);
+        mViewAbove.setOnPageChangeListener(new OnPageChangeListener() {
+            public static final int POSITION_OPEN = 0;
+
+            public static final int POSITION_CLOSE = 1;
+
+            public static final int POSITION_SECONDARY_OPEN = 2;
+
+            public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
+            }
+
+            public void onPageSelected(int position) {
+                if (position == POSITION_OPEN && mOpenListener != null) {
+                    mOpenListener.onOpen();
+                } else if (position == POSITION_CLOSE && mCloseListener != null) {
+                    mCloseListener.onClose();
+                } else if (position == POSITION_SECONDARY_OPEN && mSecondaryOpenListner != null) {
+                    mSecondaryOpenListner.onOpen();
+                }
+            }
+        });
+
+        // now style everything!
+        TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.SlidingMenu);
+        // set the above and behind views if defined in xml
+        int mode = ta.getInt(R.styleable.SlidingMenu_mode, LEFT);
+        setMode(mode);
+        int viewAbove = ta.getResourceId(R.styleable.SlidingMenu_viewAbove, -1);
+        if (viewAbove != -1) {
+            setContent(viewAbove);
+        } else {
+            setContent(new FrameLayout(context));
+        }
+        int viewBehind = ta.getResourceId(R.styleable.SlidingMenu_viewBehind, -1);
+        if (viewBehind != -1) {
+            setMenu(viewBehind);
+        } else {
+            setMenu(new FrameLayout(context));
+        }
+        int touchModeAbove = ta.getInt(R.styleable.SlidingMenu_touchModeAbove, TOUCHMODE_MARGIN);
+        setTouchModeAbove(touchModeAbove);
+        int touchModeBehind = ta.getInt(R.styleable.SlidingMenu_touchModeBehind, TOUCHMODE_MARGIN);
+        setTouchModeBehind(touchModeBehind);
+
+        int offsetBehind = (int) ta.getDimension(R.styleable.SlidingMenu_behindOffset, -1);
+        int widthBehind = (int) ta.getDimension(R.styleable.SlidingMenu_behindWidth, -1);
+        if (offsetBehind != -1 && widthBehind != -1)
+            throw new IllegalStateException("Cannot set both behindOffset and behindWidth for a SlidingMenu");
+        else if (offsetBehind != -1)
+            setBehindOffset(offsetBehind);
+        else if (widthBehind != -1)
+            setBehindWidth(widthBehind);
+        else
+            setBehindOffset(0);
+        float scrollOffsetBehind = ta.getFloat(R.styleable.SlidingMenu_behindScrollScale, 0.33f);
+        setBehindScrollScale(scrollOffsetBehind);
+        int shadowRes = ta.getResourceId(R.styleable.SlidingMenu_shadowDrawable, -1);
+        if (shadowRes != -1) {
+            setShadowDrawable(shadowRes);
+        }
+        int shadowWidth = (int) ta.getDimension(R.styleable.SlidingMenu_shadowWidth, 0);
+        setShadowWidth(shadowWidth);
+        boolean fadeEnabled = ta.getBoolean(R.styleable.SlidingMenu_fadeEnabled, true);
+        setFadeEnabled(fadeEnabled);
+        float fadeDeg = ta.getFloat(R.styleable.SlidingMenu_fadeDegree, 0.33f);
+        setFadeDegree(fadeDeg);
+        boolean selectorEnabled = ta.getBoolean(R.styleable.SlidingMenu_selectorEnabled, false);
+        setSelectorEnabled(selectorEnabled);
+        int selectorRes = ta.getResourceId(R.styleable.SlidingMenu_selectorDrawable, -1);
+        if (selectorRes != -1)
+            setSelectorDrawable(selectorRes);
+        ta.recycle();
+    }
+
+    public static Drawable getDrawable(Context context, int resource) {
+        if (Build.VERSION.SDK_INT >= 21) {
+            return context.getResources().getDrawable(resource, null);
+        }
+
+        return context.getResources().getDrawable(resource);
+    }
+
+    /**
+     * Attaches the SlidingMenu to an entire Activity
+     *
+     * @param activity   the Activity
+     * @param slideStyle either SLIDING_CONTENT or SLIDING_WINDOW
+     */
+    public void attachToActivity(Activity activity, int slideStyle) {
+        attachToActivity(activity, slideStyle, false);
+    }
+
+    /**
+     * Attaches the SlidingMenu to an entire Activity
+     *
+     * @param activity         the Activity
+     * @param slideStyle       either SLIDING_CONTENT or SLIDING_WINDOW
+     * @param actionbarOverlay whether or not the ActionBar is overlaid
+     */
+    public void attachToActivity(Activity activity, int slideStyle, boolean actionbarOverlay) {
+        if (slideStyle != SLIDING_WINDOW && slideStyle != SLIDING_CONTENT)
+            throw new IllegalArgumentException("slideStyle must be either SLIDING_WINDOW or SLIDING_CONTENT");
+
+        if (getParent() != null)
+            throw new IllegalStateException("This SlidingMenu appears to already be attached");
+
+        // get the window background
+        TypedArray a = activity.getTheme().obtainStyledAttributes(new int[]{android.R.attr.windowBackground});
+        int background = a.getResourceId(0, 0);
+        a.recycle();
+
+        switch (slideStyle) {
+            case SLIDING_WINDOW:
+                mActionbarOverlay = false;
+                ViewGroup decor = (ViewGroup) activity.getWindow().getDecorView();
+                ViewGroup decorChild = (ViewGroup) decor.getChildAt(0);
+                // save ActionBar themes that have transparent assets
+                decorChild.setBackgroundResource(background);
+                decor.removeView(decorChild);
+                decor.addView(this);
+                setContent(decorChild);
+                break;
+            case SLIDING_CONTENT:
+                mActionbarOverlay = actionbarOverlay;
+                // take the above view out of
+                ViewGroup contentParent = (ViewGroup) activity.findViewById(android.R.id.content);
+                View content = contentParent.getChildAt(0);
+                contentParent.removeView(content);
+                contentParent.addView(this);
+                setContent(content);
+                // save people from having transparent backgrounds
+                if (content.getBackground() == null)
+                    content.setBackgroundResource(background);
+                break;
+        }
+    }
+
+    /**
+     * Set the above view content from a layout resource. The resource will be
+     * inflated, adding all top-level views to the above view.
+     *
+     * @param res the new content
+     */
+    public void setContent(int res) {
+        setContent(LayoutInflater.from(getContext()).inflate(res, null));
+    }
+
+    /**
+     * Retrieves the current content.
+     *
+     * @return the current content
+     */
+    public View getContent() {
+        return mViewAbove.getContent();
+    }
+
+    /**
+     * Set the above view content to the given View.
+     *
+     * @param view The desired content to display.
+     */
+    public void setContent(View view) {
+        mViewAbove.setContent(view);
+        showContent();
+    }
+
+    /**
+     * Set the behind view (menu) content from a layout resource. The resource
+     * will be inflated, adding all top-level views to the behind view.
+     *
+     * @param res the new content
+     */
+    public void setMenu(int res) {
+        setMenu(LayoutInflater.from(getContext()).inflate(res, null));
+    }
+
+    /**
+     * Retrieves the main menu.
+     *
+     * @return the main menu
+     */
+    public View getMenu() {
+        return mViewBehind.getContent();
+    }
+
+    /**
+     * Set the behind view (menu) content to the given View.
+     *
+     * @param v The desired content to display.
+     */
+    public void setMenu(View v) {
+        mViewBehind.setContent(v);
+    }
+
+    /**
+     * Set the secondary behind view (right menu) content from a layout
+     * resource. The resource will be inflated, adding all top-level views to
+     * the behind view.
+     *
+     * @param res the new content
+     */
+    public void setSecondaryMenu(int res) {
+        setSecondaryMenu(LayoutInflater.from(getContext()).inflate(res, null));
+    }
+
+    /**
+     * Retrieves the current secondary menu (right).
+     *
+     * @return the current menu
+     */
+    public View getSecondaryMenu() {
+        return mViewBehind.getSecondaryContent();
+    }
+
+    /**
+     * Set the secondary behind view (right menu) content to the given View.
+     *
+     * @param v The desired content to display.
+     */
+    public void setSecondaryMenu(View v) {
+        mViewBehind.setSecondaryContent(v);
+        // mViewBehind.invalidate();
+    }
+
+    /**
+     * Checks if is sliding enabled.
+     *
+     * @return true, if is sliding enabled
+     */
+    public boolean isSlidingEnabled() {
+        return mViewAbove.isSlidingEnabled();
+    }
+
+    /**
+     * Sets the sliding enabled.
+     *
+     * @param b true to enable sliding, false to disable it.
+     */
+    public void setSlidingEnabled(boolean b) {
+        mViewAbove.setSlidingEnabled(b);
+    }
+
+    /**
+     * Returns the current side that the SlidingMenu is on.
+     *
+     * @return the current mode, either SlidingMenu.LEFT or SlidingMenu.RIGHT
+     */
+    public int getMode() {
+        return mViewBehind.getMode();
+    }
+
+    /**
+     * Sets which side the SlidingMenu should appear on.
+     *
+     * @param mode must be either SlidingMenu.LEFT or SlidingMenu.RIGHT
+     */
+    public void setMode(int mode) {
+        if (mode != LEFT && mode != RIGHT && mode != LEFT_RIGHT) {
+            throw new IllegalStateException("SlidingMenu mode must be LEFT, RIGHT, or LEFT_RIGHT");
+        }
+        mViewBehind.setMode(mode);
+    }
+
+    /**
+     * Sets whether or not the SlidingMenu is in static mode (i.e. nothing is
+     * moving and everything is showing)
+     *
+     * @param b true to set static mode, false to disable static mode.
+     */
+    public void setStatic(boolean b) {
+        if (b) {
+            setSlidingEnabled(false);
+            mViewAbove.setCustomViewBehind(null);
+            mViewAbove.setCurrentItem(1);
+            // mViewBehind.setCurrentItem(0);
+        } else {
+            mViewAbove.setCurrentItem(1);
+            // mViewBehind.setCurrentItem(1);
+            mViewAbove.setCustomViewBehind(mViewBehind);
+            setSlidingEnabled(true);
+        }
+    }
+
+    /**
+     * Opens the menu and shows the menu view.
+     */
+    public void showMenu() {
+        showMenu(true);
+    }
+
+    /**
+     * Opens the menu and shows the menu view.
+     *
+     * @param animate true to animate the transition, false to ignore animation
+     */
+    public void showMenu(boolean animate) {
+        mViewAbove.setCurrentItem(0, animate);
+    }
+
+    /**
+     * Opens the menu and shows the secondary menu view. Will default to the
+     * regular menu if there is only one.
+     */
+    public void showSecondaryMenu() {
+        showSecondaryMenu(true);
+    }
+
+    /**
+     * Opens the menu and shows the secondary (right) menu view. Will default to
+     * the regular menu if there is only one.
+     *
+     * @param animate true to animate the transition, false to ignore animation
+     */
+    public void showSecondaryMenu(boolean animate) {
+        mViewAbove.setCurrentItem(2, animate);
+    }
+
+    /**
+     * Closes the menu and shows the above view.
+     */
+    public void showContent() {
+        showContent(true);
+    }
+
+    /**
+     * Closes the menu and shows the above view.
+     *
+     * @param animate true to animate the transition, false to ignore animation
+     */
+    public void showContent(boolean animate) {
+        mViewAbove.setCurrentItem(1, animate);
+    }
+
+    /**
+     * Toggle the SlidingMenu. If it is open, it will be closed, and vice versa.
+     */
+    public boolean toggle() {
+        return toggle(true);
+    }
+
+    /**
+     * Toggle the SlidingMenu. If it is open, it will be closed, and vice versa.
+     *
+     * @param animate true to animate the transition, false to ignore animation
+     */
+    public boolean toggle(boolean animate) {
+        if (isMenuShowing()) {
+            showContent(animate);
+            return true;
+        } else {
+            showMenu(animate);
+            return false;
+        }
+    }
+
+    /**
+     * Checks if is the behind view showing.
+     *
+     * @return Whether or not the behind view is showing
+     */
+    public boolean isMenuShowing() {
+        return mViewAbove.getCurrentItem() == 0 || mViewAbove.getCurrentItem() == 2;
+    }
+
+    /**
+     * Checks if is the behind view showing.
+     *
+     * @return Whether or not the behind view is showing
+     */
+    public boolean isSecondaryMenuShowing() {
+        return mViewAbove.getCurrentItem() == 2;
+    }
+
+    /**
+     * Gets the behind offset.
+     *
+     * @return The margin on the right of the screen that the behind view
+     * scrolls to
+     */
+    public int getBehindOffset() {
+        return ((RelativeLayout.LayoutParams) mViewBehind.getLayoutParams()).rightMargin;
+    }
+
+    /**
+     * Sets the behind offset.
+     *
+     * @param i The margin, in pixels, on the right of the screen that the
+     *          behind view scrolls to.
+     */
+    public void setBehindOffset(int i) {
+        // RelativeLayout.LayoutParams params =
+        // ((RelativeLayout.LayoutParams)mViewBehind.getLayoutParams());
+        // int bottom = params.bottomMargin;
+        // int top = params.topMargin;
+        // int left = params.leftMargin;
+        // params.setMargins(left, top, i, bottom);
+        mViewBehind.setWidthOffset(i);
+    }
+
+    /**
+     * Sets the behind offset.
+     *
+     * @param resID The dimension resource id to be set as the behind offset. The
+     *              menu, when open, will leave this width margin on the right of
+     *              the screen.
+     */
+    public void setBehindOffsetRes(int resID) {
+        int i = (int) getContext().getResources().getDimension(resID);
+        setBehindOffset(i);
+    }
+
+    /**
+     * Sets the above offset.
+     *
+     * @param i the new above offset, in pixels
+     */
+    public void setAboveOffset(int i) {
+        mViewAbove.setAboveOffset(i);
+    }
+
+    /**
+     * Sets the above offset.
+     *
+     * @param resID The dimension resource id to be set as the above offset.
+     */
+    public void setAboveOffsetRes(int resID) {
+        int i = (int) getContext().getResources().getDimension(resID);
+        setAboveOffset(i);
+    }
+
+    /**
+     * Sets the behind width.
+     *
+     * @param i The width the Sliding Menu will open to, in pixels
+     */
+    @SuppressWarnings("deprecation")
+    public void setBehindWidth(int i) {
+        int width;
+        Display display = ((WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        try {
+            Class<?> cls = Display.class;
+            Class<?>[] parameterTypes = {Point.class};
+            Point parameter = new Point();
+            Method method = cls.getMethod("getSize", parameterTypes);
+            method.invoke(display, parameter);
+            width = parameter.x;
+        } catch (Exception e) {
+            width = display.getWidth();
+        }
+        setBehindOffset(width - i);
+    }
+
+    /**
+     * Sets the behind width.
+     *
+     * @param res The dimension resource id to be set as the behind width
+     *            offset. The menu, when open, will open this wide.
+     */
+    public void setBehindWidthRes(int res) {
+        int i = (int) getContext().getResources().getDimension(res);
+        setBehindWidth(i);
+    }
+
+    /**
+     * Gets the behind scroll scale.
+     *
+     * @return The scale of the parallax scroll
+     */
+    public float getBehindScrollScale() {
+        return mViewBehind.getScrollScale();
+    }
+
+    /**
+     * Sets the behind scroll scale.
+     *
+     * @param f The scale of the parallax scroll (i.e. 1.0f scrolls 1 pixel
+     *          for every 1 pixel that the above view scrolls and 0.0f scrolls
+     *          0 pixels)
+     */
+    public void setBehindScrollScale(float f) {
+        if (f < 0 && f > 1)
+            throw new IllegalStateException("ScrollScale must be between 0 and 1");
+        mViewBehind.setScrollScale(f);
+    }
+
+    /**
+     * Gets the touch mode margin threshold
+     *
+     * @return the touch mode margin threshold
+     */
+    public int getTouchmodeMarginThreshold() {
+        return mViewBehind.getMarginThreshold();
+    }
+
+    /**
+     * Set the touch mode margin threshold
+     *
+     * @param touchmodeMarginThreshold
+     */
+    public void setTouchmodeMarginThreshold(int touchmodeMarginThreshold) {
+        mViewBehind.setMarginThreshold(touchmodeMarginThreshold);
+    }
+
+    /**
+     * Sets the behind canvas transformer.
+     *
+     * @param t the new behind canvas transformer
+     */
+    public void setBehindCanvasTransformer(CanvasTransformer t) {
+        mViewBehind.setCanvasTransformer(t);
+    }
+
+    /**
+     * Gets the touch mode above.
+     *
+     * @return the touch mode above
+     */
+    public int getTouchModeAbove() {
+        return mViewAbove.getTouchMode();
+    }
+
+    /**
+     * Controls whether the SlidingMenu can be opened with a swipe gesture.
+     * Options are {@link #TOUCHMODE_MARGIN TOUCHMODE_MARGIN},
+     * {@link #TOUCHMODE_FULLSCREEN TOUCHMODE_FULLSCREEN}, or
+     * {@link #TOUCHMODE_NONE TOUCHMODE_NONE}
+     *
+     * @param i the new touch mode
+     */
+    public void setTouchModeAbove(int i) {
+        if (i != TOUCHMODE_FULLSCREEN && i != TOUCHMODE_MARGIN && i != TOUCHMODE_NONE) {
+            throw new IllegalStateException(
+                    "TouchMode must be set to either" + "TOUCHMODE_FULLSCREEN or TOUCHMODE_MARGIN or TOUCHMODE_NONE.");
+        }
+        mViewAbove.setTouchMode(i);
+    }
+
+    /**
+     * Controls whether the SlidingMenu can be opened with a swipe gesture.
+     * Options are {@link #TOUCHMODE_MARGIN TOUCHMODE_MARGIN},
+     * {@link #TOUCHMODE_FULLSCREEN TOUCHMODE_FULLSCREEN}, or
+     * {@link #TOUCHMODE_NONE TOUCHMODE_NONE}
+     *
+     * @param i the new touch mode
+     */
+    public void setTouchModeBehind(int i) {
+        if (i != TOUCHMODE_FULLSCREEN && i != TOUCHMODE_MARGIN && i != TOUCHMODE_NONE) {
+            throw new IllegalStateException(
+                    "TouchMode must be set to either" + "TOUCHMODE_FULLSCREEN or TOUCHMODE_MARGIN or TOUCHMODE_NONE.");
+        }
+        mViewBehind.setTouchMode(i);
+    }
+
+    /**
+     * Sets the shadow drawable.
+     *
+     * @param resId the resource ID of the new shadow drawable
+     */
+    public void setShadowDrawable(int resId) {
+        setShadowDrawable(getDrawable(getContext(), resId));
+    }
+
+    /**
+     * Sets the shadow drawable.
+     *
+     * @param d the new shadow drawable
+     */
+    public void setShadowDrawable(Drawable d) {
+        mViewBehind.setShadowDrawable(d);
+    }
+
+    /**
+     * Sets the secondary (right) shadow drawable.
+     *
+     * @param resId the resource ID of the new shadow drawable
+     */
+    public void setSecondaryShadowDrawable(int resId) {
+        setSecondaryShadowDrawable(getDrawable(getContext(), resId));
+    }
+
+    /**
+     * Sets the secondary (right) shadow drawable.
+     *
+     * @param d the new shadow drawable
+     */
+    public void setSecondaryShadowDrawable(Drawable d) {
+        mViewBehind.setSecondaryShadowDrawable(d);
+    }
+
+    /**
+     * Sets the shadow width.
+     *
+     * @param resId The dimension resource id to be set as the shadow width.
+     */
+    public void setShadowWidthRes(int resId) {
+        setShadowWidth((int) getResources().getDimension(resId));
+    }
+
+    /**
+     * Sets the shadow width.
+     *
+     * @param pixels the new shadow width, in pixels
+     */
+    public void setShadowWidth(int pixels) {
+        mViewBehind.setShadowWidth(pixels);
+    }
+
+    /**
+     * Enables or disables the SlidingMenu's fade in and out
+     *
+     * @param b true to enable fade, false to disable it
+     */
+    public void setFadeEnabled(boolean b) {
+        mViewBehind.setFadeEnabled(b);
+    }
+
+    /**
+     * Sets how much the SlidingMenu fades in and out. Fade must be enabled, see
+     * {@link #setFadeEnabled(boolean) setFadeEnabled(boolean)}
+     *
+     * @param f the new fade degree, between 0.0f and 1.0f
+     */
+    public void setFadeDegree(float f) {
+        mViewBehind.setFadeDegree(f);
+    }
+
+    /**
+     * Enables or disables whether the selector is drawn
+     *
+     * @param b true to draw the selector, false to not draw the selector
+     */
+    public void setSelectorEnabled(boolean b) {
+        mViewBehind.setSelectorEnabled(true);
+    }
+
+    /**
+     * Sets the selected view. The selector will be drawn here
+     *
+     * @param v the new selected view
+     */
+    public void setSelectedView(View v) {
+        mViewBehind.setSelectedView(v);
+    }
+
+    /**
+     * Sets the selector drawable.
+     *
+     * @param res a resource ID for the selector drawable
+     */
+    public void setSelectorDrawable(int res) {
+        mViewBehind.setSelectorBitmap(BitmapFactory.decodeResource(getResources(), res));
+    }
+
+    /**
+     * Sets the selector drawable.
+     *
+     * @param b the new selector bitmap
+     */
+    public void setSelectorBitmap(Bitmap b) {
+        mViewBehind.setSelectorBitmap(b);
+    }
+
+    /**
+     * Add a View ignored by the Touch Down event when mode is Fullscreen
+     *
+     * @param v a view to be ignored
+     */
+    public void addIgnoredView(View v) {
+        mViewAbove.addIgnoredView(v);
+    }
+
+    /**
+     * Remove a View ignored by the Touch Down event when mode is Fullscreen
+     *
+     * @param v a view not wanted to be ignored anymore
+     */
+    public void removeIgnoredView(View v) {
+        mViewAbove.removeIgnoredView(v);
+    }
+
+    /**
+     * Clear the list of Views ignored by the Touch Down event when mode is
+     * Fullscreen
+     */
+    public void clearIgnoredViews() {
+        mViewAbove.clearIgnoredViews();
+    }
+
+    /**
+     * Sets the OnOpenListener. {@link OnOpenListener#onOpen()
+     * OnOpenListener.onOpen()} will be called when the SlidingMenu is opened
+     *
+     * @param listener the new OnOpenListener
+     */
+    public void setOnOpenListener(OnOpenListener listener) {
+        // mViewAbove.setOnOpenListener(listener);
+        mOpenListener = listener;
+    }
+
+    /**
+     * Sets the OnOpenListner for secondary menu {@link OnOpenListener#onOpen()
+     * OnOpenListener.onOpen()} will be called when the secondary SlidingMenu is
+     * opened
+     *
+     * @param listener the new OnOpenListener
+     */
+
+    public void setSecondaryOnOpenListner(OnOpenListener listener) {
+        mSecondaryOpenListner = listener;
+    }
+
+    /**
+     * Sets the OnCloseListener. {@link OnCloseListener#onClose()
+     * OnCloseListener.onClose()} will be called when any one of the SlidingMenu
+     * is closed
+     *
+     * @param listener the new setOnCloseListener
+     */
+    public void setOnCloseListener(OnCloseListener listener) {
+        // mViewAbove.setOnCloseListener(listener);
+        mCloseListener = listener;
+    }
+
+    /**
+     * Sets the OnOpenedListener. {@link OnOpenedListener#onOpened()
+     * OnOpenedListener.onOpened()} will be called after the SlidingMenu is
+     * opened
+     *
+     * @param listener the new OnOpenedListener
+     */
+    public void setOnOpenedListener(OnOpenedListener listener) {
+        mViewAbove.setOnOpenedListener(listener);
+    }
+
+    /**
+     * Sets the OnClosedListener. {@link OnClosedListener#onClosed()
+     * OnClosedListener.onClosed()} will be called after the SlidingMenu is
+     * closed
+     *
+     * @param listener the new OnClosedListener
+     */
+    public void setOnClosedListener(OnClosedListener listener) {
+        mViewAbove.setOnClosedListener(listener);
+    }
+
+    /*
+     * (non-Javadoc)
+     *
+     * @see android.view.View#onSaveInstanceState()
+     */
+    @Override
+    protected Parcelable onSaveInstanceState() {
+        Parcelable superState = super.onSaveInstanceState();
+        SavedState ss = new SavedState(superState, mViewAbove.getCurrentItem());
+        return ss;
+    }
+
+    /*
+     * (non-Javadoc)
+     *
+     * @see android.view.View#onRestoreInstanceState(android.os.Parcelable)
+     */
+    @Override
+    protected void onRestoreInstanceState(Parcelable state) {
+        SavedState ss = (SavedState) state;
+        super.onRestoreInstanceState(ss.getSuperState());
+        mViewAbove.setCurrentItem(ss.getItem());
+    }
+
+    /*
+     * (non-Javadoc)
+     *
+     * @see android.view.ViewGroup#fitSystemWindows(android.graphics.Rect)
+     */
+    @SuppressLint("NewApi")
+    @Override
+    protected boolean fitSystemWindows(Rect insets) {
+        int leftPadding = insets.left;
+        int rightPadding = insets.right;
+        int topPadding = insets.top;
+        int bottomPadding = insets.bottom;
+        String brand = android.os.Build.BRAND;
+        if (Utils.hasLlAbove() && !(brand.equalsIgnoreCase("Bkav") || brand.equalsIgnoreCase("Samsung") || brand.equalsIgnoreCase("Xiaomi"))) {
+
+            Resources resources = getContent().getResources();
+            boolean isBottom = isSystemBarOnBottom(resources);
+            Configuration cfg = resources.getConfiguration();
+            int orientation = cfg.orientation;
+            int resourceId = 0;
+            if (orientation == Configuration.ORIENTATION_LANDSCAPE) {
+                resourceId = resources.getIdentifier("navigation_bar_width", "dimen", "android");
+            } else {
+                resourceId = resources.getIdentifier("navigation_bar_height", "dimen", "android");
+            }
+            if (resourceId > 0) {
+                if (isBottom)
+                    bottomPadding += resources.getDimensionPixelSize(resourceId);
+                else {
+                    rightPadding += resources.getDimensionPixelSize(resourceId);
+                }
+            }
+        }
+
+        if (!mActionbarOverlay) {
+            setPadding(leftPadding, topPadding, rightPadding, bottomPadding);
+        }
+        return true;
+    }
+
+    private boolean isSystemBarOnBottom(Resources res) {
+        Configuration cfg = res.getConfiguration();
+        DisplayMetrics dm = res.getDisplayMetrics();
+        boolean canMove = (dm.widthPixels != dm.heightPixels && cfg.smallestScreenWidthDp < 600);
+
+        return (!canMove || dm.widthPixels < dm.heightPixels);
+    }
+
+    @TargetApi(11)
+    public void manageLayers(float percentOpen) {
+        if (!Utils.hasHcAbove())
+            return;
+
+        boolean layer = percentOpen > 0.0f && percentOpen < 1.0f;
+        final int layerType = layer ? View.LAYER_TYPE_HARDWARE : View.LAYER_TYPE_NONE;
+
+        if (layerType != getContent().getLayerType()) {
+            getHandler().post(new Runnable() {
+                public void run() {
+                    Log.v(TAG, "changing layerType. hardware? " + (layerType == View.LAYER_TYPE_HARDWARE));
+                    getContent().setLayerType(layerType, null);
+                    getMenu().setLayerType(layerType, null);
+                    if (getSecondaryMenu() != null) {
+                        getSecondaryMenu().setLayerType(layerType, null);
+                    }
+                }
+            });
+        }
+    }
+
+    /**
+     * The listener interface for receiving onOpen events. The class that is
+     * interested in processing a onOpen event implements this interface, and
+     * the object created with that class is registered with a component using
+     * the component's <code>addOnOpenListener<code> method. When the onOpen
+     * event occurs, that object's appropriate method is invoked
+     */
+    public interface OnOpenListener {
+
+        /**
+         * On open.
+         */
+        public void onOpen();
+    }
+
+    /**
+     * The listener interface for receiving onOpened events. The class that is
+     * interested in processing a onOpened event implements this interface, and
+     * the object created with that class is registered with a component using
+     * the component's <code>addOnOpenedListener<code> method. When the onOpened
+     * event occurs, that object's appropriate method is invoked.
+     */
+    public interface OnOpenedListener {
+
+        /**
+         * On opened.
+         */
+        public void onOpened();
+    }
+
+    /**
+     * The listener interface for receiving onClose events. The class that is
+     * interested in processing a onClose event implements this interface, and
+     * the object created with that class is registered with a component using
+     * the component's <code>addOnCloseListener<code> method. When the onClose
+     * event occurs, that object's appropriate method is invoked.
+     */
+    public interface OnCloseListener {
+
+        /**
+         * On close.
+         */
+        public void onClose();
+    }
+
+    /**
+     * The listener interface for receiving onClosed events. The class that is
+     * interested in processing a onClosed event implements this interface, and
+     * the object created with that class is registered with a component using
+     * the component's <code>addOnClosedListener<code> method. When the onClosed
+     * event occurs, that object's appropriate method is invoked.
+     */
+    public interface OnClosedListener {
+
+        /**
+         * On closed.
+         */
+        public void onClosed();
+    }
+
+    /**
+     * The Interface CanvasTransformer.
+     */
+    public interface CanvasTransformer {
+
+        /**
+         * Transform canvas.
+         *
+         * @param canvas      the canvas
+         * @param percentOpen the percent open
+         */
+        public void transformCanvas(Canvas canvas, float percentOpen);
+    }
+
+    public static class SavedState extends BaseSavedState {
+
+        public static final Parcelable.Creator<SavedState> CREATOR = new Parcelable.Creator<SavedState>() {
+            public SavedState createFromParcel(Parcel in) {
+                return new SavedState(in);
+            }
+
+            public SavedState[] newArray(int size) {
+                return new SavedState[size];
+            }
+        };
+        private final int mItem;
+
+        public SavedState(Parcelable superState, int item) {
+            super(superState);
+            mItem = item;
+        }
+
+        private SavedState(Parcel in) {
+            super(in);
+            mItem = in.readInt();
+        }
+
+        public int getItem() {
+            return mItem;
+        }
+
+        /*
+         * (non-Javadoc)
+         *
+         * @see android.view.AbsSavedState#writeToParcel(android.os.Parcel, int)
+         */
+        public void writeToParcel(Parcel out, int flags) {
+            super.writeToParcel(out, flags);
+            out.writeInt(mItem);
+        }
+
+    }
 
 }
