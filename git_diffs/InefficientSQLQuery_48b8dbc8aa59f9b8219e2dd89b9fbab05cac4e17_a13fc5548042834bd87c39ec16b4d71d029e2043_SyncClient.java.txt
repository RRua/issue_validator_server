diff --git a/src/com/ichi2/anim/ActivityTransitionAnimation.java b/src/com/ichi2/anim/ActivityTransitionAnimation.java
index ddc43575b8..c5c6d644dc 100644
--- a/src/com/ichi2/anim/ActivityTransitionAnimation.java
+++ b/src/com/ichi2/anim/ActivityTransitionAnimation.java
@@ -1,9 +1,9 @@
 package com.ichi2.anim;
 
 import com.ichi2.anki.R;
-import com.ichi2.anki.R.anim;
-
+import com.ichi2.anki.StudyOptions;
 import android.app.Activity;
+import android.util.Log;
 
 public class ActivityTransitionAnimation {
 	public static int LEFT = 0;
@@ -28,4 +28,4 @@ public class ActivityTransitionAnimation {
 		    activity.overridePendingTransition(R.anim.none, R.anim.none);
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/src/com/ichi2/anki/About.java b/src/com/ichi2/anki/About.java
index 907cd017e0..1686b8178b 100644
--- a/src/com/ichi2/anki/About.java
+++ b/src/com/ichi2/anki/About.java
@@ -21,7 +21,6 @@ import com.ichi2.themes.Themes;
 
 import android.app.Activity;
 import android.content.res.Resources;
-import android.graphics.Color;
 import android.os.Bundle;
 import android.webkit.WebView;
 
@@ -44,19 +43,16 @@ public class About extends Activity {
         WebView webview = (WebView) findViewById(R.id.about);
         webview.setBackgroundColor(res.getColor(Themes.getBackgroundColor()));        	
 
-        String text = String.format(res.getString(R.string.about_content) + "</p></body></html>", 
-                "<html><body><h2>" + res.getString(R.string.app_name) + ":<br/>", 
-                "<a href=\"" + res.getString(R.string.link_anki) + "\">", 
-        		"<a href=\"" + res.getString(R.string.link_issue_tracker) + "\">",
-        		"<a href=\"" + res.getString(R.string.link_wiki) + "\">", 
-        		"<a href=\"" + res.getString(R.string.link_forum) + "\">",
-        		"<a href=\"" + res.getString(R.string.link_wikipedia_open_source) + "\">", 
-        		"<a href=\"" + res.getString(R.string.link_contribution) + "\">",
-        		"<a href=\"" + res.getString(R.string.link_contribution_contributors) + "\">", 
-        		"<a href=\"" + res.getString(R.string.link_donation) + "\">",
-        		"<a href=\"" + res.getString(R.string.licence_wiki) + "\">",
-        		"<a href=\"" + res.getString(R.string.link_source) + "\">");
-        webview.loadDataWithBaseURL("", text, "text/html", "utf-8", null);
+	String[] content = res.getStringArray(R.array.about_content);
+	StringBuilder sb = new StringBuilder();
+	sb.append("<html><body>");
+	sb.append(String.format(content[0], res.getString(R.string.app_name), res.getString(R.string.link_anki))).append("<br/><br/>");
+	sb.append(String.format(content[1], res.getString(R.string.link_issue_tracker), res.getString(R.string.link_wiki), res.getString(R.string.link_forum))).append("<br/><br/>");
+	sb.append(String.format(content[2], res.getString(R.string.link_wikipedia_open_source), res.getString(R.string.link_contribution), res.getString(R.string.link_contribution_contributors))).append(" ");
+	sb.append(String.format(content[3], res.getString(R.string.link_translation), res.getString(R.string.link_donation))).append("<br/><br/>");
+	sb.append(String.format(content[4], res.getString(R.string.licence_wiki), res.getString(R.string.link_source))).append("<br/><br/>");
+	sb.append("</body></html>");
+        webview.loadDataWithBaseURL("", sb.toString(), "text/html", "utf-8", null);
     }
 
 
diff --git a/src/com/ichi2/anki/AnkiDb.java b/src/com/ichi2/anki/AnkiDb.java
index 4efb4068cb..2db4fcd673 100644
--- a/src/com/ichi2/anki/AnkiDb.java
+++ b/src/com/ichi2/anki/AnkiDb.java
@@ -29,6 +29,8 @@ import java.lang.reflect.InvocationTargetException;
 import java.util.ArrayList;
 
 import com.tomgibara.android.veecheck.util.PrefSettings;
+import com.ichi2.anki.Utils.SqlCommandType;
+import static com.ichi2.anki.Utils.SqlCommandType.*;
 
 /**
  * Database layer for AnkiDroid. Can read the native Anki format through Android's SQLite driver.
diff --git a/src/com/ichi2/anki/AnkiDroidApp.java b/src/com/ichi2/anki/AnkiDroidApp.java
index b0d4f0bae9..26c5e54d09 100644
--- a/src/com/ichi2/anki/AnkiDroidApp.java
+++ b/src/com/ichi2/anki/AnkiDroidApp.java
@@ -19,7 +19,6 @@ package com.ichi2.anki;
 
 import android.app.Application;
 import android.content.Context;
-import android.content.Intent;
 import android.content.SharedPreferences;
 import android.content.SharedPreferences.Editor;
 import android.content.pm.PackageInfo;
@@ -31,7 +30,6 @@ import android.view.Display;
 import android.view.WindowManager;
 
 import com.ichi2.async.Connection;
-import com.ichi2.libanki.Deck;
 import com.tomgibara.android.veecheck.Veecheck;
 import com.tomgibara.android.veecheck.util.PrefSettings;
 
@@ -58,11 +56,7 @@ public class AnkiDroidApp extends Application {
      */
     private static AnkiDroidApp sInstance;
 
-    /**
-     * Currently loaded Anki deck.
-     */
-    private Deck mLoadedDeck;
-    
+   
     private Controller mZeemoteController;
 
     /**
@@ -157,10 +151,6 @@ public class AnkiDroidApp extends Application {
     }
 
 
-    public static Deck deck() {
-        return sInstance.mLoadedDeck;
-    }
-
     public static Controller zeemoteController() {
     	return sInstance.mZeemoteController;
     }
@@ -168,10 +158,6 @@ public class AnkiDroidApp extends Application {
     public static void setZeemoteController(Controller controller) {
     	sInstance.mZeemoteController = controller;
     }
-    
-    public static void setDeck(Deck deck) {
-        sInstance.mLoadedDeck = deck;
-    }
 
 
     public static boolean isSdCardMounted() {
@@ -254,5 +240,8 @@ public class AnkiDroidApp extends Application {
         }
         return null;
     }
-    
+
+    public static void saveExceptionReportFile(Throwable e, String origin) {
+    	CustomExceptionHandler.getInstance().uncaughtException(null, e, origin);
+    }
 }
diff --git a/src/com/ichi2/anki/AnkiDroidProxy.java b/src/com/ichi2/anki/AnkiDroidProxy.java
index 0becff2b49..82aff838b4 100644
--- a/src/com/ichi2/anki/AnkiDroidProxy.java
+++ b/src/com/ichi2/anki/AnkiDroidProxy.java
@@ -72,6 +72,7 @@ public class AnkiDroidProxy {
     public static final int LOGIN_OLD_VERSION = 4;
     /** The server is too busy to serve the request. */
     public static final int LOGIN_TOO_BUSY = 5;
+    public static final int DB_ERROR = 6;
 
     /**
      * Shared deck's fields
@@ -175,9 +176,9 @@ public class AnkiDroidProxy {
     public boolean hasDeck(String name) {
         // We assume that gets have already been loading by doing a connect.
         if (mDecks == null) throw new IllegalStateException("Should have called connect first");
-        Iterator decksIterator = mDecks.keys();
+        @SuppressWarnings("unchecked") Iterator<String> decksIterator = (Iterator<String>) mDecks.keys();
         while (decksIterator.hasNext()) {
-            String serverDeckName = (String) decksIterator.next();
+            String serverDeckName = decksIterator.next();
             if (name.equalsIgnoreCase(serverDeckName)) {
                 return true;
             }
@@ -308,7 +309,7 @@ public class AnkiDroidProxy {
 
     public List<String> getPersonalDecks() {
         ArrayList<String> personalDecks = new ArrayList<String>();
-        Iterator decksIterator = mDecks.keys();
+        @SuppressWarnings("unchecked") Iterator<String> decksIterator = (Iterator<String>) mDecks.keys();
         while (decksIterator.hasNext()) {
             personalDecks.add((String) decksIterator.next());
         }
@@ -471,7 +472,7 @@ public class AnkiDroidProxy {
             Log.i(AnkiDroidApp.TAG, "Payload response = ");
             payloadReply = new JSONObject(contentString);
             Utils.printJSONObject(payloadReply, false);
-            Utils.saveJSONObject(payloadReply);
+            //Utils.saveJSONObject(payloadReply); //XXX: do we really want to append all JSON objects forever? I don't think so.
         } catch (UnsupportedEncodingException e) {
             Log.e(AnkiDroidApp.TAG, "UnsupportedEncodingException = " + e.getMessage());
             Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
diff --git a/src/com/ichi2/anki/BackupManager.java b/src/com/ichi2/anki/BackupManager.java
index 6766aea09f..1cbf782ca6 100644
--- a/src/com/ichi2/anki/BackupManager.java
+++ b/src/com/ichi2/anki/BackupManager.java
@@ -20,9 +20,12 @@ import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Date;
+import java.util.UnknownFormatConversionException;
 
 import com.tomgibara.android.veecheck.util.PrefSettings;
 
@@ -46,15 +49,34 @@ public class BackupManager {
 	public final static int RETURN_DECK_RESTORED = 5;
 	public final static int RETURN_NULL = 6;
 	public final static int RETURN_LOW_SYSTEM_SPACE = 7;
+	public final static int RETURN_BACKUP_NEEDED = 8;
 
 	public final static String BACKUP_SUFFIX = "/backup";
 	public final static String BROKEN_DECKS_SUFFIX = "/broken";
 
+	private static ArrayList<String> mDeckPickerDecks;
+	private static boolean mUseBackups = true;
+
+ 	/** Number of day, after which a backup is done on first non-studyoptions-opening (for safety reasons) */
+	public static final int SAFETY_BACKUP_THRESHOLD = 3;
+
+	
     /* Prevent class from being instantiated */
 	private BackupManager() {
 	}
 
 
+	public static void initBackup() {
+		mUseBackups = PrefSettings.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).getBoolean("useBackup", true);
+		mDeckPickerDecks = new ArrayList<String>();
+	}
+
+
+	public static boolean isActivated() {
+		return mUseBackups;
+	}
+
+
 	private static File getBackupDirectory() {
         if (mBackupDirectoryPath == null) {
         	SharedPreferences prefs = PrefSettings.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext());
@@ -82,7 +104,58 @@ public class BackupManager {
 	}
 
 
+	/** If deck has not been opened for a long time, we perform a backup here because Android deleted sometimes corrupted decks */
+	public static boolean safetyBackupNeeded(String deckpath, int days) {
+		if (mDeckPickerDecks == null) {
+			initBackup();
+		}
+		if (!mUseBackups || mDeckPickerDecks.contains(deckpath)) {
+			return false;
+		}
+	        File[] deckBackups = getDeckBackups(new File(deckpath));
+	        int len = deckBackups.length;
+		if (len == 0) {
+			// no backup available
+			return true;
+		}
+		String backupDateString = deckBackups[len - 1].getName().replaceAll("^.*-(\\d{4}-\\d{2}-\\d{2}).anki$", "$1");
+		Date backupDate;
+		try {
+			backupDate = new SimpleDateFormat("yyyy-MM-dd").parse(backupDateString);
+		} catch (ParseException e) {
+			Log.e(AnkiDroidApp.TAG, "BackupManager - safetyBackupNeeded - Error on parsing backups: " + e);
+			return true;
+		}
+        Date target = Utils.genToday(Utils.utcOffset() + (days * 86400));
+		if (backupDate.before(target)) {
+			return true;
+		} else {
+			mDeckPickerDecks.add(deckpath);
+			return false;
+		}
+	}
+
+
+	/** Restores the current deck from backup if Android deleted it */
+	public static void restoreDeckIfMissing(String deckpath) {
+		if (mUseBackups && !(new File(deckpath)).exists()) {
+			Log.e(AnkiDroidApp.TAG, "BackupManager: Deck " + deckpath + " has been deleted by Android. Restoring it:");
+			File[] fl = BackupManager.getDeckBackups(new File(deckpath));
+			if (fl.length > 0) {
+				Log.e(AnkiDroidApp.TAG, "BackupManager: Deck " + deckpath + " successfully restored");
+				BackupManager.restoreDeckBackup(deckpath, fl[fl.length - 1].getAbsolutePath());					
+			} else {
+				Log.e(AnkiDroidApp.TAG, "BackupManager: Deck " + deckpath + " could not be restored");
+			}
+		}
+	}
+
+
 	public static int backupDeck(String deckpath) {
+		if (mDeckPickerDecks == null) {
+			initBackup();
+		}
+		mDeckPickerDecks.add(deckpath);
 		mLastCreatedBackup = null;
 		mLastDeckBackups = null;
         File deckFile = new File(deckpath);
@@ -93,7 +166,14 @@ public class BackupManager {
         	return RETURN_DECK_NOT_CHANGED;
         }
         Date value = Utils.genToday(Utils.utcOffset());
-        String backupFilename = String.format(Utils.ENGLISH_LOCALE, deckFile.getName().replace(".anki", "") + "-%tF.anki", value);
+
+        String backupFilename;
+        try {
+        	backupFilename = String.format(Utils.ENGLISH_LOCALE, deckFile.getName().replace(".anki", "") + "-%tF.anki", value);        	
+        } catch (UnknownFormatConversionException e) {
+        	Log.e(AnkiDroidApp.TAG, "backupDeck: error on creating backup filename: " + e);
+        	return RETURN_ERROR;
+        }
 
         File backupFile = new File(getBackupDirectory().getPath(), backupFilename);
         if (backupFile.exists()) {
@@ -126,15 +206,15 @@ public class BackupManager {
 	}
 
 
-	public static long getFreeDiscSpace(File file) {
-		return getFreeDiscSpace(file.getPath());
-	}
 	public static long getFreeDiscSpace(String path) {
+		return getFreeDiscSpace(new File(path));
+	}
+	public static long getFreeDiscSpace(File file) {
 		try {
-		    	StatFs stat = new StatFs(path);
-		    	long blocks = stat.getAvailableBlocks();
-		    	long blocksize = stat.getBlockSize();
-		    	return blocks * blocksize;
+			StatFs stat = new StatFs(file.getParentFile().getPath());
+	    	long blocks = stat.getAvailableBlocks();
+	    	long blocksize = stat.getBlockSize();
+	    	return blocks * blocksize;
 		} catch (IllegalArgumentException e) {
 			Log.e(AnkiDroidApp.TAG, "Free space could not be retrieved: " + e);
 			return StudyOptions.MIN_FREE_SPACE * 1024 * 1024;
@@ -154,7 +234,7 @@ public class BackupManager {
 
 	public static int restoreDeckBackup(String deckpath, String backupPath) {
         // rename old file and move it to subdirectory
-    	if (!moveDeckToBrokenFolder(deckpath)) {
+    	if ((new File(deckpath)).exists() && !moveDeckToBrokenFolder(deckpath)) {
     		return RETURN_ERROR;
     	}
 
@@ -181,11 +261,52 @@ public class BackupManager {
 	}
 
 
+	public static boolean repairDeck(String deckPath) {
+		File deckFile = new File(deckPath);
+		AnkiDatabaseManager.closeDatabase(deckPath);
+
+    	// repair file
+    	String execString = "sqlite3 " + deckPath + " .dump | sqlite3 " + deckPath + ".tmp";
+    	Log.i(AnkiDroidApp.TAG, "repairDeck - Execute: " + execString);
+    	try {
+    		String[] cmd = {"/system/bin/sh", "-c", execString };
+    	    Process process = Runtime.getRuntime().exec(cmd);
+    	    process.waitFor();
+
+    		// move deck to broken folder
+    		String brokenDirectory = getBrokenDirectory().getPath();
+    		Date value = Utils.genToday(Utils.utcOffset());
+            String movedFilename = String.format(Utils.ENGLISH_LOCALE, deckFile.getName().replace(".anki", "") + "-corrupt-%tF.anki", value);
+            File movedFile = new File(brokenDirectory, movedFilename);
+            int i = 1;
+            while (movedFile.exists()) {
+            	movedFile = new File(brokenDirectory, movedFilename.replace(".anki", "-" + Integer.toString(i) + ".anki"));
+            	i++;
+            }
+            movedFilename = movedFile.getName();
+        	if (!deckFile.renameTo(movedFile)) {
+        		return false;
+        	}
+        	Log.i(AnkiDroidApp.TAG, "repairDeck - moved corrupt file to " + movedFile.getAbsolutePath());
+        	File repairedFile = new File(deckPath + ".tmp");
+        	if (!repairedFile.renameTo(deckFile)) {
+        		return false;
+        	}
+        	return true;
+    	} catch (IOException e) {
+    		Log.e("AnkiDroidApp.TAG", "repairDeck - error: " + e);
+    	} catch (InterruptedException e) {
+    		Log.e("AnkiDroidApp.TAG", "repairDeck - error: " + e);
+    	}
+    	return false;
+	}
+
+
 	public static boolean moveDeckToBrokenFolder(String deckPath) {
 		File deckFile = new File(deckPath);
 		AnkiDatabaseManager.closeDatabase(deckPath);
         Date value = Utils.genToday(Utils.utcOffset());
-        String movedFilename = String.format(Utils.ENGLISH_LOCALE, "to-repair-" + deckFile.getName().replace(".anki", "") + "-%tF.anki", value);
+        String movedFilename = String.format(Utils.ENGLISH_LOCALE, deckFile.getName().replace(".anki", "") + "-corrupt-%tF.anki", value);
         File movedFile = new File(getBrokenDirectory().getPath(), movedFilename);
         int i = 1;
         while (movedFile.exists()) {
@@ -215,7 +336,7 @@ public class BackupManager {
 		File[] files = getBackupDirectory().listFiles();
 		ArrayList<File> deckBackups = new ArrayList<File>();
 		for (File aktFile : files){
-			if (aktFile.getName().replaceAll("-\\d{4}-\\d{2}-\\d{2}.anki", ".anki").equals(deckFile.getName())) {
+			if (aktFile.getName().replaceAll("^(.*)-\\d{4}-\\d{2}-\\d{2}.anki$", "$1.anki").equals(deckFile.getName())) {
 				deckBackups.add(aktFile);
 			}
 		}
diff --git a/src/com/ichi2/anki/BroadcastMessages.java b/src/com/ichi2/anki/BroadcastMessages.java
index f043437757..c636339ccd 100644
--- a/src/com/ichi2/anki/BroadcastMessages.java
+++ b/src/com/ichi2/anki/BroadcastMessages.java
@@ -17,6 +17,7 @@ import com.ichi2.themes.StyledDialog;
 import com.ichi2.themes.Themes;
 import com.tomgibara.android.veecheck.util.PrefSettings;
 
+import android.app.Activity;
 import android.content.Context;
 import android.content.DialogInterface;
 import android.content.Intent;
@@ -54,9 +55,9 @@ public class BroadcastMessages {
 	}
 
 
-	public static void checkForNewMessages(Context context) {
+	public static void checkForNewMessages(Activity activity) {
 		Log.d(AnkiDroidApp.TAG, "BroadcastMessages: checkForNewMessages");
-		SharedPreferences prefs = PrefSettings.getSharedPrefs(context);
+		SharedPreferences prefs = PrefSettings.getSharedPrefs(activity);
 		// don't retrieve messages, if option in preferences is not set
 		if (!prefs.getBoolean("showBroadcastMessages", true)) {
 			return;
@@ -66,8 +67,8 @@ public class BroadcastMessages {
 			Log.d(AnkiDroidApp.TAG, "BroadcastMessages: already shown today");
 			return;
 		}
-        AsyncTask<Context,Void,Context> checkForNewMessage = new DownloadBroadcastMessage();
-        checkForNewMessage.execute(context);
+        AsyncTask<Activity,Void,Context> checkForNewMessage = new DownloadBroadcastMessage();
+        checkForNewMessage.execute(activity);
 	}
 
 
@@ -111,17 +112,19 @@ public class BroadcastMessages {
 			// workaround for the dialog content not showing when starting AnkiDroid with Deckpicker and open then Studyoptions
 			try {
 				mDialog.dismiss();
-				mDialog.show();			
+				mDialog.show();
 			} catch (BadTokenException e) {
 				Log.e(AnkiDroidApp.TAG, "Error on dismissing and showing new messages dialog: " + e);
 			} catch (IllegalArgumentException e) {
 				Log.e(AnkiDroidApp.TAG, "Error on dismissing and showing new messages dialog: " + e);
+			} catch (NullPointerException e) {
+				Log.e(AnkiDroidApp.TAG, "Error on dismissing and showing new messages dialog: " + e);
 			}
 		}
 	}
 
 
-    private static class DownloadBroadcastMessage extends AsyncTask<Context, Void, Context> {
+    private static class DownloadBroadcastMessage extends AsyncTask<Activity, Void, Context> {
 
     	private static int mNum;
     	private static String mMinVersion;
@@ -130,24 +133,24 @@ public class BroadcastMessages {
     	private static String mText;
     	private static String mUrl;
 
-    	private static Context mContext;
+    	private static Activity mActivity;
 
     	private static boolean mShowDialog = false;
 
         @Override
-        protected Context doInBackground(Context... params) {
+        protected Context doInBackground(Activity... params) {
             Log.d(AnkiDroidApp.TAG, "BroadcastMessage.DownloadBroadcastMessage.doInBackground()");
 
-            Context context = params[0];
-            mContext = context;
+            Activity activity = params[0];
+            mActivity = activity;
 
-    		SharedPreferences prefs = PrefSettings.getSharedPrefs(context);
+    		SharedPreferences prefs = PrefSettings.getSharedPrefs(activity);
     		int lastNum = prefs.getInt("lastMessageNum", -1);
 		if (lastNum == -1) {
 			// first start of AnkiDroid ever (or at least of a version which supports broadcast messages).
 			// do nothing yet but retrieve message the next time, AD is started
 			prefs.edit().putInt("lastMessageNum", 0).commit();
-			return context;
+			return activity;
 		}
     		try {
         		Log.i(AnkiDroidApp.TAG, "BroadcastMessage: download file " + FILE_URL);
@@ -176,12 +179,12 @@ public class BroadcastMessages {
     					// get message version info
     					mMinVersion = getXmlValue(el, MIN_VERSION);
     					if (mMinVersion != null && mMinVersion.length() > 0 && compareVersions(mMinVersion, currentVersion) > 0) {
-        			            Log.d(AnkiDroidApp.TAG, "BroadcastMessage - too low AnkiDroid version (" + currentVersion + "), message " + mNum + " only for > " + mMinVersion);
+        			            Log.d(AnkiDroidApp.TAG, "BroadcastMessage - too low AnkiDroid version (" + currentVersion + "), message " + mNum + " only for >= " + mMinVersion);
         			            continue;
     					}
     					mMaxVersion = getXmlValue(el, MAX_VERSION);
     					if (mMaxVersion != null && mMaxVersion.length() > 0 && compareVersions(mMaxVersion, currentVersion) < 0) {
-        			            Log.d(AnkiDroidApp.TAG, "BroadcastMessage - too high AnkiDroid version (" + currentVersion + "), message " + mNum + " only for > " + mMaxVersion);
+        			            Log.d(AnkiDroidApp.TAG, "BroadcastMessage - too high AnkiDroid version (" + currentVersion + "), message " + mNum + " only for <= " + mMaxVersion);
         			            continue;
     					}
 
@@ -191,7 +194,7 @@ public class BroadcastMessages {
     					mUrl = getXmlValue(el, URL);
     					if (mText != null && mText.length() > 0) {
         	    				mShowDialog = true;
-        	    				return context;
+        	    				return activity;
     					}
     				}
     				// no valid message left
@@ -201,18 +204,18 @@ public class BroadcastMessages {
     			}
     		} catch (IOException e) {
             	Log.e(AnkiDroidApp.TAG, "DownloadBroadcastMessage: IOException on reading file " + FILE_URL + ": " + e);
-				return context;
+				return activity;
         	} catch (NumberFormatException e) {
             	Log.e(AnkiDroidApp.TAG, "DownloadBroadcastMessage: Number of file " + FILE_URL + " could not be read: " + e);
-				return context;
+				return activity;
         	}catch(ParserConfigurationException e) {
             	Log.e(AnkiDroidApp.TAG, "DownloadBroadcastMessage: ParserConfigurationException: " + e);
-				return context;
+				return activity;
     		}catch(SAXException e) {
             	Log.e(AnkiDroidApp.TAG, "DownloadBroadcastMessage: SAXException: " + e);
-				return context;
+				return activity;
         	}
-            return context;
+            return activity;
         }
 
 
@@ -233,8 +236,8 @@ public class BroadcastMessages {
 	    		builder.setNegativeButton(res.getString(R.string.close),  new DialogInterface.OnClickListener() {
 						@Override
 						public void onClick(DialogInterface dialog, int which) {
-	    					setMessageRead(mContext, mNum);
-	    			        BroadcastMessages.checkForNewMessages(mContext);
+	    					setMessageRead(mActivity, mNum);
+	    			        BroadcastMessages.checkForNewMessages(mActivity);
 						}
 					});
 	    	} else {
@@ -247,11 +250,11 @@ public class BroadcastMessages {
     			builder.setPositiveButton(mUrl.substring(mUrl.length() - 4).equals(".apk") ? res.getString(R.string.download) : res.getString(R.string.visit), new DialogInterface.OnClickListener() {
     				@Override
     				public void onClick(DialogInterface dialog, int which) {
-    					setMessageRead(mContext, mNum);
+    					setMessageRead(mActivity, mNum);
     					String action = "android.intent.action.VIEW";
-    					if (Utils.isIntentAvailable(mContext, action)) {
+    					if (Utils.isIntentAvailable(mActivity, action)) {
     						Intent i = new Intent(action, Uri.parse(mUrl));
-    						mContext.startActivity(i);
+    						mActivity.startActivity(i);
     					}
     				}
     			});
@@ -259,7 +262,8 @@ public class BroadcastMessages {
     		}
     		try {
     			mDialog = builder.create();
-			Log.d(AnkiDroidApp.TAG, "BroadcastMessages: show dialog");
+    			Log.d(AnkiDroidApp.TAG, "BroadcastMessages: show dialog");
+    			mDialog.setOwnerActivity(mActivity);
     			mDialog.show();
     		} catch (BadTokenException e) {
                 Log.e(AnkiDroidApp.TAG, "BroadcastMessage - BadTokenException on showing dialog: " + e);
diff --git a/src/com/ichi2/anki/CardBrowser.java b/src/com/ichi2/anki/CardBrowser.java
index b0852411c1..8cb7bc333e 100644
--- a/src/com/ichi2/anki/CardBrowser.java
+++ b/src/com/ichi2/anki/CardBrowser.java
@@ -18,7 +18,6 @@ package com.ichi2.anki;
 
 import android.app.Activity;
 import android.app.Dialog;
-import android.app.ProgressDialog;
 import android.content.Context;
 import android.content.DialogInterface;
 import android.content.DialogInterface.OnCancelListener;
@@ -50,10 +49,10 @@ import android.widget.TextView;
 
 import com.ichi2.anim.ActivityTransitionAnimation;
 import com.ichi2.themes.StyledDialog;
+import com.ichi2.themes.StyledProgressDialog;
 import com.ichi2.themes.Themes;
 import com.tomgibara.android.veecheck.util.PrefSettings;
 
-import java.io.File;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Comparator;
@@ -72,7 +71,7 @@ public class CardBrowser extends Activity {
 	private SimpleAdapter mCardsAdapter;
 	private EditText mSearchEditText;
 
-	private ProgressDialog mProgressDialog;
+	private StyledProgressDialog mProgressDialog;
 	private boolean mUndoRedoDialogShowing = false;
 	private Card mSelectedCard;
 	private Card mUndoRedoCard;
@@ -95,6 +94,7 @@ public class CardBrowser extends Activity {
 
 	private static final int DIALOG_ORDER = 0;
 	private static final int DIALOG_CONTEXT_MENU = 1;
+	private static final int DIALOG_RELOAD_CARDS = 2;
 
 	private static final int BACKGROUND_NORMAL = 0;
 	private static final int BACKGROUND_MARKED = 1;
@@ -133,6 +133,10 @@ public class CardBrowser extends Activity {
 
 	private boolean mPrefFixArabic;
 
+	private boolean mPrefCacheCardBrowser;
+	private static ArrayList<HashMap<String, String>> sAllCardsCache;
+	private static String sCachedDeckPath;
+
     private Handler mTimerHandler = new Handler();
     private static final int WAIT_TIME_UNTIL_UPDATE = 500;
 
@@ -153,6 +157,9 @@ public class CardBrowser extends Activity {
 
 		@Override
 		public void onClick(DialogInterface dialog, int which) {
+			if (mSelectedCard == null) {
+				return;
+			}
 			switch (which) {
 			case CONTEXT_MENU_MARK:
 				DeckTask.launchDeckTask(DeckTask.TASK_TYPE_MARK_CARD,
@@ -205,7 +212,11 @@ public class CardBrowser extends Activity {
 		setContentView(mainView);
 		Themes.setContentStyle(mainView, Themes.CALLER_CARDBROWSER);
 
-		mDeck = AnkiDroidApp.deck();
+		mDeck = DeckManager.getMainDeck();
+		if (mDeck == null) {
+			finish();
+			return;
+		}
 		mDeck.resetUndo();
 
 		mBackground = Themes.getCardBrowserBackground();
@@ -215,6 +226,7 @@ public class CardBrowser extends Activity {
 		mrelativeBrowserFontSize = preferences.getInt(
 				"relativeCardBrowserFontSize", DEFAULT_FONT_SIZE_RATIO);
 		mPrefFixArabic = preferences.getBoolean("fixArabicText", false);
+		mPrefCacheCardBrowser = preferences.getBoolean("cardBrowserCache", false);
 
 		mCards = new ArrayList<HashMap<String, String>>();
 		mAllCards = new ArrayList<HashMap<String, String>>();
@@ -250,10 +262,15 @@ public class CardBrowser extends Activity {
 			public void onItemClick(AdapterView<?> parent, View view,
 					int position, long id) {
 				Intent editCard = new Intent(CardBrowser.this, CardEditor.class);
-				editCard.putExtra(CardEditor.CARD_EDITOR_ACTION, CardEditor.EDIT_BROWSER_CARD);
+	            editCard.putExtra(CardEditor.EXTRA_CALLER, CardEditor.CALLER_CARDBROWSER_EDIT);
+	            editCard.putExtra(CardEditor.EXTRA_DECKPATH, DeckManager.getMainDeckPath());
 				mPositionInCardsList = position;
 				mSelectedCard = mDeck.cardFromId(Long.parseLong(mCards.get(
 						mPositionInCardsList).get("id")));
+				if (mSelectedCard == null) {
+					deleteCard(mCards.get(mPositionInCardsList).get("id"), mPositionInCardsList);
+					return;
+				}
 				sEditorCard = mSelectedCard;
 				editCard.putExtra("callfromcardbrowser", true);
 				startActivityForResult(editCard, EDIT_CARD);
@@ -306,6 +323,11 @@ public class CardBrowser extends Activity {
 			Log.i(AnkiDroidApp.TAG, "CardBrowser - onBackPressed()");
 			if (mSearchEditText.getText().length() == 0 && !mShowOnlyMarSus
 					&& mSelectedTags.size() == 0) {
+				if (mPrefCacheCardBrowser) {
+					sCachedDeckPath = mDeck.getDeckPath();
+					sAllCardsCache = new ArrayList<HashMap<String, String>>();
+					sAllCardsCache.addAll(mAllCards);					
+				}
 				setResult(RESULT_OK);
 				finish();
 				if (Integer.valueOf(android.os.Build.VERSION.SDK) > 4) {
@@ -372,7 +394,8 @@ public class CardBrowser extends Activity {
 			return true;
 		case MENU_ADD_FACT:
 			Intent intent = new Intent(CardBrowser.this, CardEditor.class);
-			intent.putExtra(CardEditor.CARD_EDITOR_ACTION, CardEditor.ADD_CARD);
+			intent.putExtra(CardEditor.EXTRA_CALLER, CardEditor.CALLER_CARDBROWSER_ADD);
+			intent.putExtra(CardEditor.EXTRA_DECKPATH, DeckManager.getMainDeckPath());
 			startActivityForResult(intent, ADD_FACT);
 			if (Integer.valueOf(android.os.Build.VERSION.SDK) > 4) {
 				ActivityTransitionAnimation.slide(CardBrowser.this,
@@ -474,6 +497,42 @@ public class CardBrowser extends Activity {
 	        builder.setItems(entries, mContextMenuListener);
 	        dialog = builder.create();
 			break;
+		case DIALOG_RELOAD_CARDS:
+			builder.setTitle(res.getString(R.string.pref_cache_cardbrowser));
+			builder.setMessage(res.getString(R.string.pref_cache_cardbrowser_reload));
+			builder.setPositiveButton(res.getString(R.string.yes), new OnClickListener() {
+
+				@Override
+				public void onClick(DialogInterface arg0, int arg1) {
+					DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_CARDS,
+							mLoadCardsHandler,
+							new DeckTask.TaskData(mDeck, LOAD_CHUNK));	
+					}
+				
+			});
+			builder.setNegativeButton(res.getString(R.string.no), new OnClickListener() {
+
+				@Override
+				public void onClick(DialogInterface arg0, int arg1) {
+					mAllCards.addAll(sAllCardsCache);
+					mCards.addAll(mAllCards);
+					updateList();
+				}
+				
+			});
+			builder.setCancelable(true);
+			builder.setOnCancelListener(new OnCancelListener() {
+
+				@Override
+				public void onCancel(DialogInterface arg0) {
+					mAllCards.addAll(sAllCardsCache);
+					mCards.addAll(mAllCards);
+					updateList();
+				}
+				
+			});
+			dialog = builder.create();
+			break;
 		}
 		return dialog;
 	}
@@ -486,6 +545,11 @@ public class CardBrowser extends Activity {
 		switch (id) {
 		case DIALOG_CONTEXT_MENU:
 			mSelectedCard = mDeck.cardFromId(Long.parseLong(mCards.get(mPositionInCardsList).get("id")));
+			if (mSelectedCard == null) {
+				deleteCard(mCards.get(mPositionInCardsList).get("id"), mPositionInCardsList);
+				ad.setEnabled(false);
+				return;
+			}
 			if (mSelectedCard.isMarked()) {
 				ad.changeListItem(CONTEXT_MENU_MARK, res.getString(R.string.card_browser_unmark_card));
 				mIsMarked = true;
@@ -511,7 +575,7 @@ public class CardBrowser extends Activity {
 	private void recreateTagsDialog() {
 		Resources res = getResources();
 		if (allTags == null) {
-			String[] oldTags = AnkiDroidApp.deck().allTags_();
+			String[] oldTags = DeckManager.getMainDeck().allTags_();
 			Log.i(AnkiDroidApp.TAG, "all tags: " + Arrays.toString(oldTags));
 			allTags = new String[oldTags.length];
 			for (int i = 0; i < oldTags.length; i++) {
@@ -592,9 +656,17 @@ public class CardBrowser extends Activity {
 	}
 
 	private void getCards() {
-		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_CARDS,
-				mLoadCardsHandler,
-				new DeckTask.TaskData(mDeck, LOAD_CHUNK));
+		if ((sCachedDeckPath != null && !sCachedDeckPath.equals(mDeck.getDeckPath())) || !mPrefCacheCardBrowser) {
+			sCachedDeckPath = null;
+			sAllCardsCache = null;
+		}
+		if (mPrefCacheCardBrowser && sAllCardsCache != null && !sAllCardsCache.isEmpty()) {
+			showDialog(DIALOG_RELOAD_CARDS);
+		} else {
+			DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_CARDS,
+					mLoadCardsHandler,
+					new DeckTask.TaskData(mDeck, LOAD_CHUNK));
+		}
 	}
 
 	public static Card getEditorCard() {
@@ -707,9 +779,16 @@ public class CardBrowser extends Activity {
 		@Override
 		public void onPreExecute() {
 			if (!mUndoRedoDialogShowing) {
-				mProgressDialog = ProgressDialog.show(CardBrowser.this, "",
+				mProgressDialog = StyledProgressDialog.show(CardBrowser.this, "",
 						getResources().getString(R.string.card_browser_load),
-						true);
+						true, true, new OnCancelListener() {
+
+							@Override
+							public void onCancel(DialogInterface arg0) {
+								DeckTask.cancelTask();
+							}
+					
+				});
 			} else {
 				mProgressDialog.setMessage(getResources().getString(
 						R.string.card_browser_load));
@@ -784,7 +863,7 @@ public class CardBrowser extends Activity {
 		@Override
 		public void onPreExecute() {
 			Resources res = getResources();
-			mProgressDialog = ProgressDialog.show(CardBrowser.this, "", res
+			mProgressDialog = StyledProgressDialog.show(CardBrowser.this, "", res
 					.getString(R.string.saving_changes), true);
 		}
 
@@ -805,7 +884,7 @@ public class CardBrowser extends Activity {
 		@Override
 		public void onPreExecute() {
 			Resources res = getResources();
-			mProgressDialog = ProgressDialog.show(CardBrowser.this, "", res
+			mProgressDialog = StyledProgressDialog.show(CardBrowser.this, "", res
 					.getString(R.string.saving_changes), true);
 		}
 
@@ -824,7 +903,7 @@ public class CardBrowser extends Activity {
 		@Override
 		public void onPreExecute() {
 			Resources res = getResources();
-			mProgressDialog = ProgressDialog.show(CardBrowser.this, "", res
+			mProgressDialog = StyledProgressDialog.show(CardBrowser.this, "", res
 					.getString(R.string.saving_changes), true);
 		}
 
@@ -848,7 +927,7 @@ public class CardBrowser extends Activity {
 			if (mProgressDialog != null && mProgressDialog.isShowing()) {
 				mProgressDialog.setMessage(res.getString(R.string.card_browser_sorting_cards));
 			} else {
-				mProgressDialog = ProgressDialog.show(CardBrowser.this, "", res
+				mProgressDialog = StyledProgressDialog.show(CardBrowser.this, "", res
 						.getString(R.string.card_browser_sorting_cards), true);				
 			}
 		}
@@ -871,7 +950,7 @@ public class CardBrowser extends Activity {
 		@Override
 		public void onPreExecute() {
 			Resources res = getResources();
-			mProgressDialog = ProgressDialog.show(CardBrowser.this, "", res
+			mProgressDialog = StyledProgressDialog.show(CardBrowser.this, "", res
 					.getString(R.string.saving_changes), true);
 		}
 
@@ -934,7 +1013,7 @@ public class CardBrowser extends Activity {
 	private DeckTask.TaskListener mUpdateCardHandler = new DeckTask.TaskListener() {
 		@Override
 		public void onPreExecute() {
-			mProgressDialog = ProgressDialog.show(CardBrowser.this, "",
+			mProgressDialog = StyledProgressDialog.show(CardBrowser.this, "",
 					getResources().getString(R.string.saving_changes), true);
 		}
 
diff --git a/src/com/ichi2/anki/CardEditor.java b/src/com/ichi2/anki/CardEditor.java
index 414072f1f9..003616e2cd 100644
--- a/src/com/ichi2/anki/CardEditor.java
+++ b/src/com/ichi2/anki/CardEditor.java
@@ -16,7 +16,6 @@ package com.ichi2.anki;
 
 import android.app.Activity;
 import android.app.Dialog;
-import android.app.ProgressDialog;
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.DialogInterface;
@@ -41,22 +40,27 @@ import android.view.MenuItem;
 import android.view.View;
 import android.view.ViewGroup;
 import android.view.inputmethod.InputMethodManager;
+import android.widget.AdapterView;
 import android.widget.Button;
 import android.widget.EditText;
 import android.widget.FrameLayout;
 import android.widget.ImageView;
 import android.widget.LinearLayout;
+import android.widget.ListView;
+import android.widget.SimpleAdapter;
 import android.widget.TextView;
+import android.widget.AdapterView.OnItemClickListener;
 
 import com.ichi2.anim.ActivityTransitionAnimation;
 import com.ichi2.anim.ViewAnimation;
-import com.ichi2.anki.DeckPicker.AnkiFilter;
 import com.ichi2.anki.Fact.Field;
 import com.ichi2.themes.StyledDialog;
+import com.ichi2.themes.StyledDialog.Builder;
+import com.ichi2.themes.StyledProgressDialog;
 import com.ichi2.themes.Themes;
+import com.ichi2.widget.AnkiDroidWidgetBig;
 import com.tomgibara.android.veecheck.util.PrefSettings;
 
-import java.io.File;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
@@ -86,30 +90,41 @@ public class CardEditor extends Activity {
 	public static final String TARGET_LANGUAGE = "TARGET_LANGUAGE";
 	public static final String SOURCE_TEXT = "SOURCE_TEXT";
 	public static final String TARGET_TEXT = "TARGET_TEXT";
-	public static final String DECKPATH = "DECK_PATH";
-
-	public static final String CARD_EDITOR_ACTION = "cea";
-	public static final int EDIT_REVIEWER_CARD = 0;
-	public static final int EDIT_BROWSER_CARD = 1;
-	public static final int ADD_CARD = 2;
-	public static final int COPY_CARD = 3;
+	public static final String EXTRA_DECKPATH = "DECKPATH";
+	public static final String EXTRA_CALLER = "CALLER";
+	public static final String EXTRA_CONTENTS = "CONTENTS";
+	public static final String EXTRA_ID = "ID";
 
 	private static final int DIALOG_MODEL_SELECT = 0;
 	private static final int DIALOG_CARD_MODEL_SELECT = 1;
 	private static final int DIALOG_TAGS = 2;
 	private static final int DIALOG_DECK_SELECT = 3;
 	private static final int DIALOG_RESET_CARD = 4;
+	private static final int DIALOG_INTENT_INFORMATION = 5;
 
-	private static final String INTENT_CREATE_FLASHCARD = "org.openintents.indiclash.CREATE_FLASHCARD";
-	private static final String INTENT_CREATE_FLASHCARD_SEND = "android.intent.action.SEND";
+	private static final String ACTION_CREATE_FLASHCARD = "org.openintents.indiclash.CREATE_FLASHCARD";
+	private static final String ACTION_CREATE_FLASHCARD_SEND = "android.intent.action.SEND";
 
 	private static final int MENU_LOOKUP = 0;
 	private static final int MENU_RESET = 1;
 	private static final int MENU_COPY_CARD = 2;
 	private static final int MENU_ADD_CARD = 3;
 	private static final int MENU_RESET_CARD_PROGRESS = 4;
-
-	private static final int ACTION_ADD_CARD = 0;
+	private static final int MENU_SAVED_INTENT = 5;
+
+	public static final int CALLER_NOCALLER = 0;
+	public static final int CALLER_REVIEWER = 1;
+	public static final int CALLER_STUDYOPTIONS = 2;
+	public static final int CALLER_BIGWIDGET_EDIT = 3;
+	public static final int CALLER_BIGWIDGET_ADD = 4;
+	public static final int CALLER_CARDBROWSER_EDIT = 5;
+	public static final int CALLER_CARDBROWSER_ADD = 6;
+	public static final int CALLER_CARDEDITOR = 7;
+	public static final int CALLER_CARDEDITOR_INTENT_ADD = 8;
+	public static final int CALLER_INDICLASH = 9;
+
+	public static final int REQUEST_ADD = 0;
+	public static final int REQUEST_INTENT_ADD = 1;
 
 	/**
 	 * Broadcast that informs us when the sd card is about to be unmounted
@@ -130,9 +145,15 @@ public class CardEditor extends Activity {
 	private StyledDialog mCardModelDialog;
 
 	private Fact mEditorFact;
-	private boolean mAddFact = false;
-	private boolean mForCopy = false;
-	private boolean mIntentAdd = false;
+
+	/* indicates if a new fact is added or a card is edited */
+	private boolean mAddFact;
+	
+	private boolean mAedictIntent;
+
+	/* indicates which activity called card editor */
+	private int mCaller;
+
 	private String mDeckPath;
 
 	private boolean mCardReset = false;
@@ -147,20 +168,23 @@ public class CardEditor extends Activity {
 	private LinkedHashMap<Long, CardModel> mNewSelectedCardModels;
 	private ArrayList<Long> cardModelIds = new ArrayList<Long>();
 
+	private int mCardItemBackground;
+	private ArrayList<HashMap<String, String>> mIntentInformation;
+	private SimpleAdapter mIntentInformationAdapter;
+	private StyledDialog mIntentInformationDialog;
+
 	private boolean mModified;
 
 	private String[] allTags;
 	private HashSet<String> mSelectedTags;
-	private String mFactTags = "";
+	private String mFactTags;
 	private EditText mNewTagEditText;
 	private StyledDialog mTagsDialog;
 
-	private ProgressDialog mProgressDialog;
+	private StyledProgressDialog mProgressDialog;
 
-	private HashMap<String, String> mFullDeckPaths;
-	private String[] mDeckNames;
-	private String mSourceLanguage;
-	private String mTargetLanguage;
+//	private String mSourceLanguage;
+//	private String mTargetLanguage;
 	private String mSourceText;
 	private String mTargetText;
 	private int mSourcePosition = 0;
@@ -175,19 +199,25 @@ public class CardEditor extends Activity {
 		@Override
 		public void onPreExecute() {
 			Resources res = getResources();
-			mProgressDialog = ProgressDialog.show(CardEditor.this, "", res
+			mProgressDialog = StyledProgressDialog.show(CardEditor.this, "", res
 					.getString(R.string.saving_facts), true);
 		}
 
 		@Override
 		public void onProgressUpdate(DeckTask.TaskData... values) {
-			if (values[0].getBoolean()) {
+			int count = values[0].getInt();
+			if (mCaller == CALLER_BIGWIDGET_EDIT) {
+				AnkiDroidWidgetBig.setCard(values[0].getCard());
+				AnkiDroidWidgetBig.updateWidget(AnkiDroidWidgetBig.UpdateService.VIEW_NOT_SPECIFIED);
+			} else if (count > 0) {
 				mEditorFact = mDeck.newFact(mCurrentSelectedModelId);
 				populateEditFields();
 				mSave.setEnabled(false);
 				mSourceText = null;
 				mTargetText = null;
 				mSwapButton.setVisibility(View.GONE);
+				Themes.showThemedToast(CardEditor.this, getResources()
+						.getQuantityString(R.plurals.factadder_cards_added, count, count), true);
 			} else {
 				Themes.showThemedToast(CardEditor.this, getResources()
 						.getString(R.string.factadder_saving_error), true);
@@ -198,40 +228,24 @@ public class CardEditor extends Activity {
 				} catch (IllegalArgumentException e) {
 					Log.e(AnkiDroidApp.TAG, "Card Editor: Error on dismissing progress dialog: " + e);
 				}
-
+			}
+			if (!mAddFact || mCaller == CALLER_CARDEDITOR || mCaller == CALLER_BIGWIDGET_EDIT || mAedictIntent) {
+				closeCardEditor();
+			} else if (mCaller == CALLER_CARDEDITOR_INTENT_ADD) {
+				if (count > 0) {
+					Intent intent = new Intent();
+					intent.putExtra(EXTRA_ID, getIntent().getStringExtra(EXTRA_ID));
+					setResult(RESULT_OK, intent);
+					closeCardEditor();
+				}
 			}
 		}
 
 		@Override
 		public void onPostExecute(DeckTask.TaskData result) {
-			if (mForCopy) {
-				closeCardEditor();
-			}
 		}
 	};
 
-	DeckTask.TaskListener mCloseDeckHandler = new DeckTask.TaskListener() {
-
-        @Override
-        public void onPreExecute() {
-            mProgressDialog = ProgressDialog.show(CardEditor.this, "", getResources()
-                    .getString(R.string.close_deck), true);
-        }
-
-
-        @Override
-        public void onPostExecute(DeckTask.TaskData result) {
-        	if (mProgressDialog != null && mProgressDialog.isShowing()) {
-        		mProgressDialog.dismiss();
-        	}
-            CardEditor.this.finish();
-        }
-
-
-        @Override
-        public void onProgressUpdate(DeckTask.TaskData... values) {
-        }
-    };
 
 	// ----------------------------------------------------------------------------
 	// ANDROID METHODS
@@ -239,6 +253,7 @@ public class CardEditor extends Activity {
 
 	@Override
 	protected void onCreate(Bundle savedInstanceState) {
+		Log.i(AnkiDroidApp.TAG, "CardEditor: onCreate");
 		Themes.applyTheme(this);
 		super.onCreate(savedInstanceState);
 
@@ -247,9 +262,9 @@ public class CardEditor extends Activity {
 		View mainView = getLayoutInflater().inflate(R.layout.card_editor, null);
 		setContentView(mainView);
 		Themes.setWallpaper(mainView);
+		Themes.setContentStyle(mainView, Themes.CALLER_CARD_EDITOR);
 
 		mFieldsLayoutContainer = (LinearLayout) findViewById(R.id.CardEditorEditFieldsLayout);
-		Themes.setTextViewStyle(mFieldsLayoutContainer);
 
 		setTitle(R.string.cardeditor_title);
 		mSave = (Button) findViewById(R.id.CardEditorSaveButton);
@@ -262,73 +277,134 @@ public class CardEditor extends Activity {
 
 		mNewSelectedCardModels = new LinkedHashMap<Long, CardModel>();
 		cardModelIds = new ArrayList<Long>();
+		mAedictIntent = false;
 
 		Intent intent = getIntent();
-		String action = intent.getAction();
-		if (action != null && action.equals(INTENT_CREATE_FLASHCARD)) {
-			prepareForIntentAddition();
-			Bundle extras = intent.getExtras();
-			mSourceLanguage = extras.getString(SOURCE_LANGUAGE);
-			mTargetLanguage = extras.getString(TARGET_LANGUAGE);
-			mSourceText = extras.getString(SOURCE_TEXT);
-			mTargetText = extras.getString(TARGET_TEXT);
+		if (savedInstanceState != null) {
+			mDeckPath = savedInstanceState.getString("deckFilename");
+			mCaller = savedInstanceState.getInt("caller");
+			mAddFact = savedInstanceState.getBoolean("addFact");
+			Log.i(AnkiDroidApp.TAG, "onCreate - deckFilename from savedInstanceState: " + mDeckPath);
+			DeckManager.getDeck(mDeckPath, DeckManager.REQUESTING_ACTIVITY_CARDEDITOR);
+		} else {
+			mCaller = intent.getIntExtra(EXTRA_CALLER, CALLER_NOCALLER);
+			if (mCaller == CALLER_NOCALLER) {
+				String action = intent.getAction();
+				if (action != null && (ACTION_CREATE_FLASHCARD.equals(action) || ACTION_CREATE_FLASHCARD_SEND.equals(action))) {
+					mCaller = CALLER_INDICLASH;
+				}
+			}
+		}
+		Log.i(AnkiDroidApp.TAG, "Caller: " + mCaller);
+
+		switch (mCaller) {
+		case CALLER_NOCALLER:
+			Log.i(AnkiDroidApp.TAG, "CardEditor: no caller could be identified, closing");
+			finish();
+			return;
+
+		case CALLER_REVIEWER:
+			Card revCard = Reviewer.getEditorCard();
+			if (revCard == null) {
+				finish();
+				return;
+			}
+			mEditorFact = revCard.getFact();
+			mAddFact = false;
+			break;
+
+		case CALLER_STUDYOPTIONS:
 			mAddFact = true;
-			mIntentAdd = true;
-		} else if (action != null
-				&& action.equals(INTENT_CREATE_FLASHCARD_SEND)) {
+			break;
+
+		case CALLER_BIGWIDGET_EDIT:
+			Card widgetCard = AnkiDroidWidgetBig.getCard();
+			if (widgetCard == null) {
+				finish();
+				return;
+			}
+			mEditorFact = widgetCard.getFact();
+			mAddFact = false;
+			break;
+
+		case CALLER_BIGWIDGET_ADD:
+			mAddFact = true;
+			break;
+
+		case CALLER_CARDBROWSER_EDIT:
+			Card browCard = CardBrowser.getEditorCard();
+			if (browCard == null) {
+				finish();
+				return;
+			}
+			mEditorFact = browCard.getFact();
+			mAddFact = false;
+			break;
+
+		case CALLER_CARDBROWSER_ADD:
+			mAddFact = true;
+			break;
+
+		case CALLER_CARDEDITOR:
+			mAddFact = true;
+			break;
+
+		case CALLER_CARDEDITOR_INTENT_ADD:
 			prepareForIntentAddition();
-			Bundle extras = intent.getExtras();
-			mSourceText = extras.getString(Intent.EXTRA_SUBJECT);
-			mTargetText = extras.getString(Intent.EXTRA_TEXT);
 			mAddFact = true;
-			mIntentAdd = true;
-		} else {
-			mDeckPath = intent.getStringExtra(DECKPATH);
-			if (mDeckPath != null && mDeckPath.length() > 0) {
-				mDeck = Deck.openDeck(mDeckPath, false);
+			String[] fields = intent.getStringExtra(EXTRA_CONTENTS).split("\\x1f");
+			mSourceText = fields[0];
+			mTargetText = fields[1];
+			break;
+
+		case CALLER_INDICLASH:
+			Bundle extras = intent.getExtras();
+			if (ACTION_CREATE_FLASHCARD.equals(intent.getAction())) {
+//				mSourceLanguage = extras.getString(SOURCE_LANGUAGE);
+//				mTargetLanguage = extras.getString(TARGET_LANGUAGE);
+				mSourceText = extras.getString(SOURCE_TEXT);
+				mTargetText = extras.getString(TARGET_TEXT);
 			} else {
-				mDeck = AnkiDroidApp.deck();
+				mSourceText = extras.getString(Intent.EXTRA_SUBJECT);
+				mTargetText = extras.getString(Intent.EXTRA_TEXT);
 			}
-			switch (intent.getIntExtra(CARD_EDITOR_ACTION, ADD_CARD)) {
-			case EDIT_REVIEWER_CARD:
-				Card revCard = Reviewer.getEditorCard();
-				if (revCard == null) {
-					finish();
-					return;
-				}
-				mEditorFact = revCard.getFact();
-				break;
-			case EDIT_BROWSER_CARD:
-				Card browCard = CardBrowser.getEditorCard();
-				if (browCard == null) {
-					finish();
-					return;
-				}
-				mEditorFact = browCard.getFact();
-				break;
-			case COPY_CARD:
-				mForCopy = true;
-			case ADD_CARD:
-				mAddFact = true;
+			if (mSourceText == null && mTargetText == null) {
+				finish();
+				return;
+			}
+			if (mSourceText.equals("Aedict Notepad") && addFromAedict(mTargetText)) {
+		          finish();
+		          return;
+		        }
+			prepareForIntentAddition(); 
+			mAddFact = true;
+			break;
+		}
+
+		if (mCaller != CALLER_INDICLASH && mCaller != CALLER_CARDEDITOR_INTENT_ADD) {
+			mDeckPath = intent.getStringExtra(EXTRA_DECKPATH);
+			mDeck = DeckManager.getDeck(mDeckPath, DeckManager.REQUESTING_ACTIVITY_CARDEDITOR, false);
+			if (mDeck == null) {
+				finish();
+				return;
+			}
+		}
+
+		if (mAddFact) {
+			if (mCaller != CALLER_INDICLASH && mCaller != CALLER_CARDEDITOR_INTENT_ADD) {
 				loadContents();
 				modelChanged();
 				mSave.setEnabled(false);
-				if (mForCopy) {
-					String[] contents = intent.getStringExtra("contents").split("\\x1f");
-					for (int i = 0; i < mEditFields.size(); i++) {
-						if (i < contents.length) {
-							mEditFields.get(i).setText(contents[i]);
-							if (contents[i].length() > 0) {
-								mSave.setEnabled(true);								
-							}
-						}
-					}
-				}
-				break;
+				String contents = intent.getStringExtra(EXTRA_CONTENTS);
+				setEditFieldTexts(contents);				
+				mModelButtons.setVisibility(View.VISIBLE);
+			} else {
+				mSave.setVisibility(View.INVISIBLE);
+				mCancel.setVisibility(View.INVISIBLE);
+				mTags.setVisibility(View.INVISIBLE);
+				mFieldsLayoutContainer.setVisibility(View.INVISIBLE);
 			}
-		}
-		if (mAddFact) {
-			mModelButtons.setVisibility(View.VISIBLE);
+
 			mModelButton.setOnClickListener(new View.OnClickListener() {
 				public void onClick(View v) {
 					showDialog(DIALOG_MODEL_SELECT);
@@ -341,6 +417,7 @@ public class CardEditor extends Activity {
 			});
 			mSave.setText(getResources().getString(R.string.add));
 			mCancel.setText(getResources().getString(R.string.close));
+			mFactTags = "";
 		} else {
 			mFactTags = mEditorFact.getTags();
 		}
@@ -348,8 +425,7 @@ public class CardEditor extends Activity {
 		mTags.setText(getResources().getString(R.string.CardEditorTags, mFactTags));
 		mModified = false;
 
-		SharedPreferences preferences = PrefSettings
-				.getSharedPrefs(getBaseContext());
+		SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
 		mPrefFixArabic = preferences.getBoolean("fixArabicText", false);
 		// if Arabic reshaping is enabled, disable the Save button to avoid
 		// saving the reshaped string to the deck
@@ -401,16 +477,17 @@ public class CardEditor extends Activity {
 						mEditorFact.setTags(mFactTags);
 						mModified = true;
 					}
-					// Only send result to save if something was actually
-					// changed
-					if (!mCardReset) {
+					if (mCaller == CALLER_BIGWIDGET_EDIT) {
+						DeckTask.launchDeckTask(DeckTask.TASK_TYPE_UPDATE_FACT, mSaveFactHandler, new DeckTask.TaskData(Reviewer.UPDATE_CARD_SHOW_QUESTION, mDeck, AnkiDroidWidgetBig.getCard()));
+					} else if (!mCardReset) {
+						// Only send result to save if something was actually changed
 						if (mModified) {
 							setResult(RESULT_OK);
 						} else {
 							setResult(RESULT_CANCELED);
 						}						
+						closeCardEditor();
 					}
-					closeCardEditor();
 				}
 			}
 
@@ -434,6 +511,39 @@ public class CardEditor extends Activity {
 	}
 
 
+	private boolean addFromAedict(String extra_text) {
+		String category = "";
+		String[] notepad_lines = extra_text.split("\n");
+		for (int i=0;i<notepad_lines.length;i++){
+			if (notepad_lines[i].startsWith("[") && notepad_lines[i].endsWith("]")) {
+				category = notepad_lines[i].substring(1,notepad_lines[i].length()-1);
+				if (category.equals("default")) {
+					if (notepad_lines.length > i+1) {
+						String[] entry_lines = notepad_lines[i+1].split(":");
+						if (entry_lines.length > 1){
+							mSourceText = entry_lines[1];
+							mTargetText = entry_lines[0];
+							mAedictIntent = true;
+						} else {
+							Themes.showThemedToast(CardEditor.this, getResources().getString(
+									R.string.intent_aedict_empty), false);
+							return true;
+						}
+					} else {
+						Themes.showThemedToast(CardEditor.this, getResources().getString(
+								R.string.intent_aedict_empty), false);
+						return true;
+					}
+					return false;
+				}
+			}
+		}
+		Themes.showThemedToast(CardEditor.this, getResources().getString(
+				R.string.intent_aedict_category), false);
+		return true;
+	}
+
+
 	@Override
 	public boolean onKeyDown(int keyCode, KeyEvent event) {
 		if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
@@ -454,6 +564,22 @@ public class CardEditor extends Activity {
 	}
 
 
+	@Override
+    protected void onSaveInstanceState(Bundle outState) {
+		if (mDeck != null) {
+			String path = mDeck.getDeckPath();
+	        // Remember current deck's filename.
+	        if (path != null) {
+	            Log.i(AnkiDroidApp.TAG, "onSaveInstanceState: " + path);
+	            outState.putString("deckFilename", path);
+	            outState.putBoolean("addFact", mAddFact);
+	            outState.putInt("caller", mCaller);
+	            Log.i(AnkiDroidApp.TAG, "onSaveInstanceState - Ending");
+	        }			
+		}
+    }
+
+
 	@Override
 	public boolean onCreateOptionsMenu(Menu menu) {
 		MenuItem item;
@@ -472,7 +598,12 @@ public class CardEditor extends Activity {
 		item.setIcon(R.drawable.ic_menu_upload);
 		if (!mAddFact) {
 			item = menu.add(Menu.NONE, MENU_RESET_CARD_PROGRESS, Menu.NONE, res.getString(R.string.card_editor_reset_card));
-			item.setIcon(R.drawable.ic_menu_delete);			
+			item.setIcon(R.drawable.ic_menu_delete);
+		}
+		if (mCaller != CALLER_CARDEDITOR_INTENT_ADD) {
+			mIntentInformation = MetaDB.getIntentInformation(this);
+			item = menu.add(Menu.NONE, MENU_SAVED_INTENT, Menu.NONE, res.getString(R.string.intent_add_saved_information));
+			item.setIcon(R.drawable.ic_menu_archive);			
 		}
 		return true;
 	}
@@ -488,10 +619,15 @@ public class CardEditor extends Activity {
 		        menu.findItem(MENU_COPY_CARD).setEnabled(true);
 				break;
 			} else if (i == mEditFields.size() - 1) {
-		        menu.findItem(MENU_COPY_CARD).setEnabled(false);				
+		        menu.findItem(MENU_COPY_CARD).setEnabled(false);
 			}
 		}
-		return true;
+
+        if (mCaller != CALLER_CARDEDITOR_INTENT_ADD) {
+        	mIntentInformation = MetaDB.getIntentInformation(this);
+    		menu.findItem(MENU_SAVED_INTENT).setEnabled(mIntentInformation.size() > 0);        	
+        }
+        return true;
 	}
 
 
@@ -501,28 +637,25 @@ public class CardEditor extends Activity {
 		case MENU_COPY_CARD:
 		case MENU_ADD_CARD:
 			Intent intent = new Intent(CardEditor.this, CardEditor.class);
+			intent.putExtra(EXTRA_CALLER, CALLER_CARDEDITOR);
+			intent.putExtra(EXTRA_DECKPATH, mDeckPath);				
 			if (item.getItemId() == MENU_COPY_CARD) {
-				intent.putExtra(CardEditor.CARD_EDITOR_ACTION, CardEditor.COPY_CARD);
 				StringBuilder contents = new StringBuilder();
 				for (FieldEditText current : mEditFields) {
 					contents.append(current.getText().toString()).append("\u001f");
 				}
-				intent.putExtra("contents", contents.toString());
-				if (mDeckPath != null && mDeckPath.length() > 0) {
-					intent.putExtra(DECKPATH, mDeckPath);
-				}
-			} else {
-				intent.putExtra(CardEditor.CARD_EDITOR_ACTION, CardEditor.ADD_CARD);
+				intent.putExtra(EXTRA_CONTENTS, contents.toString());
 			}
-			startActivityForResult(intent, ACTION_ADD_CARD);
+			startActivityForResult(intent, REQUEST_ADD);
 			if (Integer.valueOf(android.os.Build.VERSION.SDK) > 4) {
 				ActivityTransitionAnimation.slide(CardEditor.this,
 						ActivityTransitionAnimation.LEFT);
 			}
 			return true;
+
 		case MENU_RESET:
 			if (mAddFact) {
-				if (mIntentAdd) {
+				if (mCaller == CALLER_INDICLASH  || mCaller == CALLER_CARDEDITOR_INTENT_ADD) {
 					if (mSourceText != null) {
 						mEditFields.get(0).setText(mSourceText);
 					}
@@ -530,9 +663,7 @@ public class CardEditor extends Activity {
 						mEditFields.get(1).setText(mTargetText);
 					}
 				} else {
-					for (FieldEditText current : mEditFields) {
-						current.setText("");
-					}
+					setEditFieldTexts(getIntent().getStringExtra(EXTRA_CONTENTS));
 					if (!mEditFields.isEmpty()) {
 						mEditFields.getFirst().requestFocus();
 					}
@@ -541,6 +672,7 @@ public class CardEditor extends Activity {
 				populateEditFields();
 			}
 			return true;
+
 		case MENU_LOOKUP:
 			View focus = this.getWindow().getCurrentFocus();
 			if (focus instanceof FieldEditText) {
@@ -551,9 +683,14 @@ public class CardEditor extends Activity {
 				Lookup.lookUp(field.getText().toString().substring(field.getSelectionStart(), field.getSelectionEnd()), null);
 			}
 			return true;
+
 		case MENU_RESET_CARD_PROGRESS:
 			showDialog(DIALOG_RESET_CARD);
 			return true;
+
+		case MENU_SAVED_INTENT:
+			showDialog(DIALOG_INTENT_INFORMATION);
+			return true;
 		}
 		return false;
 	}
@@ -588,10 +725,20 @@ public class CardEditor extends Activity {
 		mModels = Model.getModels(mDeck);
 		mCurrentSelectedModelId = mDeck.getCurrentModelId();
 		modelChanged();
+		mEditFields.get(0).setText(mSourceText);
+		if (mAedictIntent && (mEditFields.size() == 3) && mTargetText.contains("[")) {
+			String[] subfields = mTargetText.replaceFirst("\\[", "\u001f").split("\\x1f");
+			if (subfields.length > 1) {
+				mEditFields.get(1).setText(subfields[0]);
+				mEditFields.get(2).setText(subfields[1].substring(0,subfields[1].length()-1));
+			}
+		}
+		else {
+			mEditFields.get(1).setText(mTargetText);
+		}
 	}
 
 	private void prepareForIntentAddition() {
-		mSwapButton.setVisibility(View.VISIBLE);
 		mSwapButton.setOnClickListener(new View.OnClickListener() {
 
 			public void onClick(View v) {
@@ -607,14 +754,24 @@ public class CardEditor extends Activity {
 	}
 
 	private void closeCardEditor() {
-		if (mIntentAdd && mDeck != null) {
-			Deck deck = AnkiDroidApp.deck();
-			if (deck == null || !deck.getDeckPath().equals(mDeckPath)) {
-				DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CLOSE_DECK, mCloseDeckHandler, new DeckTask.TaskData(mDeck, 0));
-				return;
+		DeckManager.closeDeck(mDeck.getDeckPath(), DeckManager.REQUESTING_ACTIVITY_CARDEDITOR);
+		finish();
+		if (mCaller == CALLER_CARDEDITOR_INTENT_ADD || mCaller == CALLER_BIGWIDGET_EDIT || mCaller == CALLER_BIGWIDGET_ADD) {
+			if (Integer.valueOf(android.os.Build.VERSION.SDK) > 4) { 
+				ActivityTransitionAnimation.slide(CardEditor.this,
+						ActivityTransitionAnimation.FADE);
+			}
+		} else if (mCaller == CALLER_INDICLASH) {
+			if (Integer.valueOf(android.os.Build.VERSION.SDK) > 4) {
+				ActivityTransitionAnimation.slide(CardEditor.this,
+						ActivityTransitionAnimation.NONE);
+			}
+		} else {
+			if (Integer.valueOf(android.os.Build.VERSION.SDK) > 4) {
+				ActivityTransitionAnimation.slide(CardEditor.this,
+						ActivityTransitionAnimation.RIGHT);
 			}
 		}
-		finish();
 	}
 
 	@Override
@@ -625,173 +782,15 @@ public class CardEditor extends Activity {
 
 		switch (id) {
 		case DIALOG_TAGS:
-			builder.setTitle(R.string.studyoptions_limit_select_tags);
-			builder.setPositiveButton(res.getString(R.string.select),
-					new OnClickListener() {
-						@Override
-						public void onClick(DialogInterface dialog, int which) {
-							String tags = mSelectedTags.toString();
-							mFactTags = tags.substring(1, tags.length() - 1);
-							mTags.setText(getResources().getString(
-									R.string.CardEditorTags, mFactTags));
-						}
-					});
-			builder.setNegativeButton(res.getString(R.string.cancel), null);
-
-			mNewTagEditText = (EditText) new EditText(this);
-			mNewTagEditText.setHint(R.string.add_new_tag);
-
-			InputFilter filter = new InputFilter() {
-				public CharSequence filter(CharSequence source, int start,
-						int end, Spanned dest, int dstart, int dend) {
-					for (int i = start; i < end; i++) {
-						if (!(Character.isLetterOrDigit(source.charAt(i)))) {
-							return "";
-						}
-					}
-					return null;
-				}
-			};
-			mNewTagEditText.setFilters(new InputFilter[] { filter });
-
-			ImageView mAddTextButton = new ImageView(this);
-			mAddTextButton.setImageResource(R.drawable.ic_addtag);
-			mAddTextButton.setOnClickListener(new View.OnClickListener() {
-				@Override
-				public void onClick(View v) {
-					String tag = mNewTagEditText.getText().toString();
-					if (tag.length() != 0) {
-						for (int i = 0; i < allTags.length; i++) {
-							if (allTags[i].equalsIgnoreCase(tag)) {
-								mNewTagEditText.setText("");
-								return;
-							}
-						}
-						mSelectedTags.add(tag);
-						String[] oldTags = allTags;
-						allTags = new String[oldTags.length + 1];
-						allTags[0] = tag;
-						for (int j = 1; j < allTags.length; j++) {
-							allTags[j] = oldTags[j - 1];
-						}
-						mTagsDialog.addMultiChoiceItems(tag, true);
-						mNewTagEditText.setText("");
-					}
-				}
-			});
-
-			FrameLayout frame = new FrameLayout(this);
-			FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(
-					ViewGroup.LayoutParams.WRAP_CONTENT,
-					ViewGroup.LayoutParams.WRAP_CONTENT, Gravity.RIGHT
-							| Gravity.CENTER_VERTICAL);
-			params.rightMargin = 10;
-			mAddTextButton.setLayoutParams(params);
-			frame.addView(mNewTagEditText);
-			frame.addView(mAddTextButton);
-
-			builder.setView(frame, false, true);
-			dialog = builder.create();
-			mTagsDialog = dialog;
+		    dialog = createDialogTags(builder, res);
 			break;
 
 		case DIALOG_DECK_SELECT:
-			int len = 0;
-			File[] fileList;
-
-			File dir = new File(PrefSettings.getSharedPrefs(getBaseContext())
-					.getString("deckPath", AnkiDroidApp.getStorageDirectory()));
-			fileList = dir.listFiles(new AnkiFilter());
-
-			if (dir.exists() && dir.isDirectory() && fileList != null) {
-				len = fileList.length;
-			}
-
-			TreeSet<String> tree = new TreeSet<String>();
-			mFullDeckPaths = new HashMap<String, String>();
-
-			if (len > 0 && fileList != null) {
-				Log.i(AnkiDroidApp.TAG,
-						"CardEditor - populateDeckDialog, number of anki files = "
-								+ len);
-				for (File file : fileList) {
-					String name = file.getName().replaceAll(".anki", "");
-					tree.add(name);
-					mFullDeckPaths.put(name, file.getAbsolutePath());
-				}
-			}
-
-			builder.setTitle(R.string.fact_adder_select_deck);
-			// Convert to Array
-			mDeckNames = new String[tree.size()];
-			tree.toArray(mDeckNames);
-
-			builder.setItems(mDeckNames, new DialogInterface.OnClickListener() {
-				@Override
-				public void onClick(DialogInterface dialog, int item) {
-					loadDeck(item);
-				}
-			});
-			builder.setOnCancelListener(new OnCancelListener() {
-				@Override
-				public void onCancel(DialogInterface arg0) {
-					mCancelled = true;
-				}
-
-			});
-			builder.setOnDismissListener(new OnDismissListener() {
-				@Override
-				public void onDismiss(DialogInterface arg0) {
-					if (mCancelled == true) {
-						finish();
-					} else if (mDeck == null) {
-						showDialog(DIALOG_DECK_SELECT);
-					}
-				}
-			});
-			dialog = builder.create();
+		    dialog = createDialogDeckSelect(builder, res);
 			break;
+
 		case DIALOG_MODEL_SELECT:
-			ArrayList<CharSequence> dialogItems = new ArrayList<CharSequence>();
-			// Use this array to know which ID is associated with each
-			// Item(name)
-			final ArrayList<Long> dialogIds = new ArrayList<Long>();
-
-			Model mModel;
-			builder.setTitle(R.string.select_model);
-			for (Long i : mModels.keySet()) {
-				mModel = mModels.get(i);
-				dialogItems.add(mModel.getName());
-				dialogIds.add(i);
-			}
-			// Convert to Array
-			String[] items = new String[dialogItems.size()];
-			dialogItems.toArray(items);
-
-			builder.setItems(items, new DialogInterface.OnClickListener() {
-				public void onClick(DialogInterface dialog, int item) {
-					long oldModelId = mCurrentSelectedModelId;
-					mCurrentSelectedModelId = dialogIds.get(item);
-					if (oldModelId != mCurrentSelectedModelId) {
-						int size = mEditFields.size();
-						String[] oldValues = new String[size];
-						for (int i = 0; i < size; i++) {
-							oldValues[i] = mEditFields.get(i).getText()
-									.toString();
-						}
-						modelChanged();
-						if ((mSourceText == null || mSourceText.isEmpty())
-								&& (mTargetText == null || mTargetText
-										.isEmpty())) {
-							for (int i = 0; i < Math.min(size, mEditFields
-									.size()); i++) {
-								mEditFields.get(i).setText(oldValues[i]);
-							}
-						}
-					}
-				}
-			});
-			dialog = builder.create();
+		    dialog = createDialogModelSelect(builder, res);
 			break;
 		case DIALOG_CARD_MODEL_SELECT:
 			builder.setTitle(res.getString(R.string.select_card_model));
@@ -813,6 +812,7 @@ public class CardEditor extends Activity {
 			mCardModelDialog = builder.create();
 			dialog = mCardModelDialog;
 			break;
+
 		case DIALOG_RESET_CARD:
     		builder.setTitle(res.getString(R.string.reset_card_dialog_title));
     		builder.setMessage(res.getString(R.string.reset_card_dialog_message));
@@ -834,24 +834,234 @@ public class CardEditor extends Activity {
 			builder.setCancelable(true);
 			dialog = builder.create();
 			break;
+
+		case DIALOG_INTENT_INFORMATION:
+		    dialog = createDialogIntentInformation(builder, res);
 		}
 		return dialog;
 	}
 
+	private StyledDialog createDialogTags(Builder builder, Resources res) {
+	    StyledDialog dialog = null;
+		builder.setTitle(R.string.studyoptions_limit_select_tags);
+		builder.setPositiveButton(res.getString(R.string.select),
+				new OnClickListener() {
+					@Override
+					public void onClick(DialogInterface dialog, int which) {
+						String tags = mSelectedTags.toString();
+						mFactTags = tags.substring(1, tags.length() - 1);
+						mTags.setText(getResources().getString(
+								R.string.CardEditorTags, mFactTags));
+					}
+				});
+		builder.setNegativeButton(res.getString(R.string.cancel), null);
+
+		mNewTagEditText = (EditText) new EditText(this);
+		mNewTagEditText.setHint(R.string.add_new_tag);
+
+		InputFilter filter = new InputFilter() {
+			public CharSequence filter(CharSequence source, int start,
+					int end, Spanned dest, int dstart, int dend) {
+				for (int i = start; i < end; i++) {
+					if (!(Character.isLetterOrDigit(source.charAt(i)))) {
+						return "";
+					}
+				}
+				return null;
+			}
+		};
+		mNewTagEditText.setFilters(new InputFilter[] { filter });
+
+		ImageView mAddTextButton = new ImageView(this);
+		mAddTextButton.setImageResource(R.drawable.ic_addtag);
+		mAddTextButton.setOnClickListener(new View.OnClickListener() {
+			@Override
+			public void onClick(View v) {
+				String tag = mNewTagEditText.getText().toString();
+				if (tag.length() != 0) {
+					for (int i = 0; i < allTags.length; i++) {
+						if (allTags[i].equalsIgnoreCase(tag)) {
+							mNewTagEditText.setText("");
+							return;
+						}
+					}
+					mSelectedTags.add(tag);
+					String[] oldTags = allTags;
+					allTags = new String[oldTags.length + 1];
+					allTags[0] = tag;
+					for (int j = 1; j < allTags.length; j++) {
+						allTags[j] = oldTags[j - 1];
+					}
+					mTagsDialog.addMultiChoiceItems(tag, true);
+					mNewTagEditText.setText("");
+				}
+			}
+		});
+
+		FrameLayout frame = new FrameLayout(this);
+		FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(
+				ViewGroup.LayoutParams.WRAP_CONTENT,
+				ViewGroup.LayoutParams.WRAP_CONTENT, Gravity.RIGHT
+						| Gravity.CENTER_VERTICAL);
+		params.rightMargin = 10;
+		mAddTextButton.setLayoutParams(params);
+		frame.addView(mNewTagEditText);
+		frame.addView(mAddTextButton);
+
+		builder.setView(frame, false, true);
+		dialog = builder.create();
+		mTagsDialog = dialog;
+		return dialog;
+	}
+	
+	private StyledDialog createDialogDeckSelect(Builder builder, Resources res) {
+        StyledDialog dialog = DeckManager.getSelectDeckDialog(this, new DialogInterface.OnClickListener() {
+            @Override
+            public void onClick(DialogInterface dialog, int item) {
+                loadDeck(item);
+            }
+        }, new OnCancelListener() {
+            @Override
+            public void onCancel(DialogInterface arg0) {
+                mCancelled = true;
+            }
+
+        }, new OnDismissListener() {
+            @Override
+            public void onDismiss(DialogInterface arg0) {
+                if (mCancelled == true) {
+                    finish();
+                    if (Integer.valueOf(android.os.Build.VERSION.SDK) > 4) {
+                        ActivityTransitionAnimation.slide(CardEditor.this,
+                                ActivityTransitionAnimation.FADE);
+                    }           
+                } else if (mDeck == null) {
+                    showDialog(DIALOG_DECK_SELECT);
+                }
+            }
+        }, mCaller == CALLER_CARDEDITOR_INTENT_ADD ? null : res.getString(R.string.intent_add_save_for_later), mCaller == CALLER_CARDEDITOR_INTENT_ADD ? null : new View.OnClickListener() {
+
+            @Override
+            public void onClick(View v) {
+                MetaDB.saveIntentInformation(CardEditor.this, mSourceText, mTargetText);
+                mCancelled = true;
+                finish();
+            }               
+        });
+        return dialog;
+	}
+	
+    private StyledDialog createDialogModelSelect(Builder builder, Resources res) {
+        ArrayList<CharSequence> dialogItems = new ArrayList<CharSequence>();
+        // Use this array to know which ID is associated with each
+        // Item(name)
+        final ArrayList<Long> dialogIds = new ArrayList<Long>();
+    
+        Model mModel;
+        builder.setTitle(R.string.select_model);
+        for (Long i : mModels.keySet()) {
+            mModel = mModels.get(i);
+            dialogItems.add(mModel.getName());
+            dialogIds.add(i);
+        }
+        // Convert to Array
+        String[] items = new String[dialogItems.size()];
+        dialogItems.toArray(items);
+    
+        builder.setItems(items, new DialogInterface.OnClickListener() {
+            public void onClick(DialogInterface dialog, int item) {
+                long oldModelId = mCurrentSelectedModelId;
+                mCurrentSelectedModelId = dialogIds.get(item);
+                if (oldModelId != mCurrentSelectedModelId) {
+                    int size = mEditFields.size();
+                    String[] oldValues = new String[size];
+                    for (int i = 0; i < size; i++) {
+                        oldValues[i] = mEditFields.get(i).getText()
+                                .toString();
+                    }
+                    modelChanged();
+                    if ((mSourceText == null || mSourceText.length() == 0)
+                            && (mTargetText == null || mTargetText
+                                    .length() == 0)) {
+                        for (int i = 0; i < Math.min(size, mEditFields
+                                .size()); i++) {
+                            mEditFields.get(i).setText(oldValues[i]);
+                        }
+                    }
+                }
+            }
+        });
+        return builder.create();
+    }
+    
+    private StyledDialog createDialogIntentInformation(Builder builder, Resources res) {
+        builder.setTitle(res.getString(R.string.intent_add_saved_information));
+        ListView listView = new ListView(this);
+        
+        mIntentInformationAdapter = new SimpleAdapter(this, mIntentInformation, R.layout.card_item, new String[] { "source", "target", "id"}, new int[] { R.id.card_question, R.id.card_answer, R.id.card_item});
+        listView.setAdapter(mIntentInformationAdapter);
+        listView.setOnItemClickListener(new OnItemClickListener() {
+            @Override
+            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
+                Intent intent = new Intent(CardEditor.this, CardEditor.class);
+                intent.putExtra(EXTRA_CALLER, CALLER_CARDEDITOR_INTENT_ADD);
+                HashMap<String, String> map = mIntentInformation.get(position);
+                StringBuilder contents = new StringBuilder();
+                contents.append(map.get("source"))
+                    .append("\u001f")
+                    .append(map.get("target"));
+                intent.putExtra(EXTRA_CONTENTS, contents.toString());
+                intent.putExtra(EXTRA_ID, map.get("id"));
+                startActivityForResult(intent, REQUEST_INTENT_ADD);
+                if (Integer.valueOf(android.os.Build.VERSION.SDK) > 4) {
+                    ActivityTransitionAnimation.slide(CardEditor.this,
+                            ActivityTransitionAnimation.FADE);
+                }
+                mIntentInformationDialog.dismiss();
+            }
+        });
+        mCardItemBackground = Themes.getCardBrowserBackground()[0];
+        mIntentInformationAdapter.setViewBinder(new SimpleAdapter.ViewBinder() {
+            @Override
+            public boolean setViewValue(View view, Object arg1, String text) {
+                if (view.getId() == R.id.card_item) {
+                    view.setBackgroundResource(mCardItemBackground);
+                    return true;
+                }
+                return false;
+            }
+        });
+        listView.setBackgroundColor(android.R.attr.colorBackground);
+        listView.setDrawSelectorOnTop(true);
+        listView.setFastScrollEnabled(true);
+        Themes.setContentStyle(listView, Themes.CALLER_CARDEDITOR_INTENTDIALOG);
+        builder.setView(listView, false, true);
+        builder.setCancelable(true);
+        builder.setPositiveButton(res.getString(R.string.intent_add_clear_all), new OnClickListener() {
+            @Override
+            public void onClick(DialogInterface dialog, int arg1) {
+                MetaDB.resetIntentInformation(CardEditor.this);
+                mIntentInformation.clear();
+                dialog.dismiss();
+            }});
+        StyledDialog dialog = builder.create();
+        mIntentInformationDialog = dialog;
+        return dialog;
+    }
+
 	@Override
 	protected void onPrepareDialog(int id, Dialog dialog) {
 		StyledDialog ad = (StyledDialog) dialog;
 		switch (id) {
 		case DIALOG_TAGS:
 			if (allTags == null) {
-				String[] oldTags = AnkiDroidApp.deck().allUserTags();
+				String[] oldTags = mDeck.allUserTags();
 		        if (oldTags == null) {
 		        	Themes.showThemedToast(CardEditor.this, getResources().getString(R.string.error_insufficient_memory), false);
 		        	ad.setEnabled(false);
 		        	return;
 		        }
-				Log.i(AnkiDroidApp.TAG, "all tags: "
-								+ Arrays.toString(oldTags));
+				Log.i(AnkiDroidApp.TAG, "all tags: " + Arrays.toString(oldTags));
 				allTags = new String[oldTags.length];
 				for (int i = 0; i < oldTags.length; i++) {
 					allTags[i] = oldTags[i];
@@ -924,6 +1134,10 @@ public class CardEditor extends Activity {
 			ad.getButton(StyledDialog.BUTTON_POSITIVE).setEnabled(
 					!mNewSelectedCardModels.isEmpty());
 			break;
+
+		case DIALOG_INTENT_INFORMATION:
+			mIntentInformationAdapter.notifyDataSetChanged();
+			break;
 		}
 	}
 
@@ -931,9 +1145,32 @@ public class CardEditor extends Activity {
     @Override
     protected void onActivityResult(int requestCode, int resultCode, Intent data) {
         super.onActivityResult(requestCode, resultCode, data);
-        if (resultCode == Reviewer.RESULT_EDIT_CARD_RESET) {
-        	mCardReset = true;
-        	setResult(Reviewer.RESULT_EDIT_CARD_RESET);
+        switch (requestCode) {
+        case REQUEST_INTENT_ADD:
+            if (resultCode != RESULT_CANCELED) {
+            	String id = data.getStringExtra(EXTRA_ID);
+            	if (id != null) {
+                	for (int i = 0; i < mIntentInformation.size(); i++) {
+                		if (mIntentInformation.get(i).get("id").endsWith(id)) {
+                			if (MetaDB.removeIntentInformation(CardEditor.this, id)) {
+                    			mIntentInformation.remove(i);
+                            	mIntentInformationAdapter.notifyDataSetChanged();                				
+                			}
+                        	break;
+                		}
+                	}
+            	}
+            }
+			if (mIntentInformation.size() > 0) {
+				showDialog(DIALOG_INTENT_INFORMATION);
+			}
+        	break;
+        case REQUEST_ADD:
+            if (resultCode == Reviewer.RESULT_EDIT_CARD_RESET) {
+            	mCardReset = true;
+            	setResult(Reviewer.RESULT_EDIT_CARD_RESET);
+            }
+        	break;        	
         }
     }
 
@@ -949,33 +1186,41 @@ public class CardEditor extends Activity {
 		swapText(true);
 	}
 
+
 	private void loadDeck(int item) {
-		String deckName = mDeckNames[item];
-		mDeckPath = mFullDeckPaths.get(deckName);
-		Deck deck = AnkiDroidApp.deck();
-		if (deck != null && deck.getDeckPath().equals(mDeckPath)) {
-			mDeck = deck;
-		} else {
-			mDeck = Deck.openDeck(mDeckPath, false);
-			if (mDeck == null) {
-				Themes.showThemedToast(CardEditor.this, getResources().getString(
-						R.string.fact_adder_deck_not_loaded), true);
-				return;
-			}			
+		mDeckPath = DeckManager.getDeckPathAfterDeckSelectionDialog(item);
+		mDeck = DeckManager.getDeck(mDeckPath, DeckManager.REQUESTING_ACTIVITY_CARDEDITOR);
+		if (mDeck == null) {
+			Log.e(AnkiDroidApp.TAG, "CardEditor: error on opening deck");
+			Themes.showThemedToast(CardEditor.this, getResources().getString(
+					R.string.fact_adder_deck_not_loaded), true);
+			BackupManager.restoreDeckIfMissing(mDeckPath);
+			return;			
 		}
-		setTitle(deckName);
+		mModelButtons.setVisibility(View.VISIBLE);
+		mSave.setVisibility(View.VISIBLE);
+		mCancel.setVisibility(View.VISIBLE);
+		mTags.setVisibility(View.VISIBLE);
+		mFieldsLayoutContainer.setVisibility(View.VISIBLE);
+		mSwapButton.setVisibility(View.VISIBLE);
+		setTitle(mDeck.getDeckName());
 		loadContents();
 	}
 
+
 	private void swapText(boolean reset) {
-		String sourceText = mEditFields.get(mSourcePosition).getText().toString();
-		if (sourceText.length() == 0) {
-			sourceText = mSourceText;
-		}
-		String targetText = mEditFields.get(mTargetPosition).getText().toString();
-		if (targetText.length() == 0) {
-			targetText = mTargetText;
-		}
+		// get source text
+		FieldEditText field = mEditFields.get(mSourcePosition);
+		Editable sourceText = field.getText();
+		boolean sourceCutMode = field.getCutMode();
+		FieldEditText.WordRow[] sourceCutString = field.getCutString(); 
+
+		// get target text
+		field = mEditFields.get(mTargetPosition);
+		Editable targetText = field.getText();
+		boolean targetCutMode = field.getCutMode();
+		FieldEditText.WordRow[] targetCutString = field.getCutString(); 
+
 		if (mEditFields.size() > mSourcePosition) {
 			mEditFields.get(mSourcePosition).setText("");
 		}
@@ -1001,9 +1246,11 @@ public class CardEditor extends Activity {
 		}
 		if (sourceText != null) {
 			mEditFields.get(mSourcePosition).setText(sourceText);
+			mEditFields.get(mSourcePosition).setCutMode(sourceCutMode, sourceCutString);
 		}
 		if (targetText != null) {
 			mEditFields.get(mTargetPosition).setText(targetText);
+			mEditFields.get(mTargetPosition).setCutMode(targetCutMode, targetCutString);
 		}
 	}
 
@@ -1047,6 +1294,27 @@ public class CardEditor extends Activity {
 		}
 	}
 
+	private void setEditFieldTexts(String contents) {
+		String[] fields = null;
+		int len;
+		if (contents == null) {
+			len = 0;
+		} else {
+			fields = contents.split("\\x1f");
+			len = fields.length;
+		}
+		for (int i = 0; i < mEditFields.size(); i++) {
+			if (i < len) {
+				mEditFields.get(i).setText(fields[i]);
+				if (fields[i].length() > 0) {
+					mSave.setEnabled(true);
+				}					
+			} else {
+				mEditFields.get(i).setText("");
+			}
+		}
+	}
+
 	// ----------------------------------------------------------------------------
 	// INNER CLASSES
 	// ----------------------------------------------------------------------------
@@ -1137,26 +1405,16 @@ public class CardEditor extends Activity {
 		public ImageView getCircle() {
 			mCircle = new ImageView(this.getContext());
 			mCircle.setImageResource(R.drawable.ic_circle_normal);
+			mKeyListener = FieldEditText.this.getKeyListener();
 			mCircle.setOnClickListener(new View.OnClickListener() {
 				@Override
 				public void onClick(View v) {
-					ImageView view = ((ImageView) v);
 					Editable editText = FieldEditText.this.getText();
 					if (mCutMode) {
-						view.setImageResource(R.drawable.ic_circle_normal);
-						FieldEditText.this.setKeyListener(mKeyListener);
-						FieldEditText.this.setCursorVisible(true);
+						setCutMode(false, null);
 						updateContentAfterWordSelection(editText);
 					} else {
-						view.setImageResource(R.drawable.ic_circle_pressed);
-						InputMethodManager imm = (InputMethodManager) mContext
-								.getSystemService(Context.INPUT_METHOD_SERVICE);
-						imm.hideSoftInputFromWindow(FieldEditText.this
-								.getWindowToken(), 0);
-						mKeyListener = FieldEditText.this.getKeyListener();
-						FieldEditText.this.setKeyListener(null);
-						FieldEditText.this.setCursorVisible(false);
-						mCutMode = true;
+						setCutMode(true, null);
 						String text = editText.toString();
 						splitText(text);
 						int pos = 0;
@@ -1184,6 +1442,36 @@ public class CardEditor extends Activity {
 			return mCircle;
 		}
 
+
+		public boolean getCutMode() {
+			return mCutMode;
+		}
+
+
+		public WordRow[] getCutString() {
+			return mCutString;
+		}
+
+
+		public void setCutMode(boolean active, WordRow[] cutString) {
+			mCutMode = active;
+			if (mCutMode) {
+				mCircle.setImageResource(R.drawable.ic_circle_pressed);
+				InputMethodManager imm = (InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE);
+				imm.hideSoftInputFromWindow(FieldEditText.this.getWindowToken(), 0);
+				FieldEditText.this.setKeyListener(null);
+				FieldEditText.this.setCursorVisible(false);
+				if (cutString != null) {
+					mCutString = cutString;
+				}
+			} else {
+				mCircle.setImageResource(R.drawable.ic_circle_normal);
+				FieldEditText.this.setKeyListener(mKeyListener);
+				FieldEditText.this.setCursorVisible(true);
+			}
+		}
+
+
 		public boolean updateField() {
 			if (mCutMode) {
 				updateContentAfterWordSelection(FieldEditText.this.getText());
diff --git a/src/com/ichi2/anki/CustomExceptionHandler.java b/src/com/ichi2/anki/CustomExceptionHandler.java
index e31496f3c7..66472c7f25 100644
--- a/src/com/ichi2/anki/CustomExceptionHandler.java
+++ b/src/com/ichi2/anki/CustomExceptionHandler.java
@@ -118,6 +118,9 @@ public class CustomExceptionHandler implements Thread.UncaughtExceptionHandler {
 
     @Override
     public void uncaughtException(Thread t, Throwable e) {
+    	uncaughtException(t, e, null);
+    }
+    public void uncaughtException(Thread t, Throwable e, String origin) {
         Log.i(AnkiDroidApp.TAG, "uncaughtException");
 
         collectInformation();
@@ -139,14 +142,18 @@ public class CustomExceptionHandler implements Thread.UncaughtExceptionHandler {
         reportInformation.append(String.format("reportgeneratedutc=%s\n", reportgeneratedutc));
         reportInformation.append(String.format("reportgeneratedtzoffset=%s\n", reportgeneratedtzoffset));
         reportInformation.append(String.format("reportgeneratedtz=%s\n", reportgeneratedtz));
-        
+
+        if (origin != null && origin.length() > 0) {
+        	reportInformation.append(String.format("origin=%s\n", origin));
+        }
+
         for (String key : mInformation.keySet()) {
             String value = mInformation.get(key);
 
             reportInformation.append(String.format("%s=%s\n", key.toLowerCase(), value));
         }
 
-        reportInformation.append("stacktrace=\nBegin Stacktrace\n");
+        reportInformation.append("stacktrace=\nBegin Stacktrace\n");	
 
         // Stack trace
         final Writer result = new StringWriter();
@@ -170,7 +177,9 @@ public class CustomExceptionHandler implements Thread.UncaughtExceptionHandler {
         Log.i(AnkiDroidApp.TAG, "report infomation string created");
         saveReportToFile(reportInformation.toString());
 
-        mPreviousHandler.uncaughtException(t, e);
+        if (t != null) {
+            mPreviousHandler.uncaughtException(t, e);
+        }
     }
 
 
@@ -192,4 +201,4 @@ public class CustomExceptionHandler implements Thread.UncaughtExceptionHandler {
             Log.i(AnkiDroidApp.TAG, e.toString());
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/com/ichi2/anki/DeckManager.java b/src/com/ichi2/anki/DeckManager.java
new file mode 100644
index 0000000000..cc361978ec
--- /dev/null
+++ b/src/com/ichi2/anki/DeckManager.java
@@ -0,0 +1,493 @@
+package com.ichi2.anki;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.TreeSet;
+import java.util.concurrent.locks.ReentrantLock;
+
+import com.ichi2.anki.DeckPicker.AnkiFilter;
+import com.ichi2.themes.StyledDialog;
+import com.ichi2.widget.AnkiDroidWidgetBig;
+import com.ichi2.widget.WidgetStatus;
+import com.tomgibara.android.veecheck.util.PrefSettings;
+
+import android.content.Context;
+import android.content.DialogInterface.OnCancelListener;
+import android.content.DialogInterface.OnClickListener;
+import android.content.DialogInterface.OnDismissListener;
+import android.database.Cursor;
+import android.os.AsyncTask;
+import android.util.Log;
+import android.view.View;
+import android.widget.Button;
+
+public class DeckManager {
+
+	public static final int REQUESTING_ACTIVITY_STUDYOPTIONS = 0;
+	public static final int REQUESTING_ACTIVITY_DECKPICKER = 1;
+	public static final int REQUESTING_ACTIVITY_WIDGETSTATUS = 2;
+	public static final int REQUESTING_ACTIVITY_BIGWIDGET = 3;
+	public static final int REQUESTING_ACTIVITY_STATISTICS = 4;
+	public static final int REQUESTING_ACTIVITY_SYNCCLIENT = 5;
+	public static final int REQUESTING_ACTIVITY_CARDEDITOR = 6;
+	public static final int REQUESTING_ACTIVITY_DOWNLOADMANAGER = 7;
+
+	private static HashMap<String, DeckInformation> sLoadedDecks = new HashMap<String, DeckInformation>();
+	private static HashMap<String, ReentrantLock> sDeckLocks = new HashMap<String, ReentrantLock>();
+
+	private static HashMap<String, String> sDeckPaths;
+	private static String[] sDeckNames;
+
+	private static String sMainDeckPath;
+
+
+    /**
+     * Gets deck from its path. Opens it if needed.
+     *
+     * @param deckPath
+     * @param requestingActivity Code of the requesting Activity to be saved with the deck
+     * @return the loaded deck
+     */
+	public static Deck getDeck(String deckpath, int requestingActivity) {
+		return getDeck(deckpath, false, requestingActivity);
+	}
+    /**
+     * Gets deck from its path. Opens it if needed.
+     *
+     * @param deckPath
+     * @param setAsMainDeck set deck as main deck to be used by other activities
+     * @param requestingActivity Code of the requesting Activity to be saved with the deck
+     * @return the loaded deck
+     */
+	public static Deck getDeck(String deckpath, boolean setAsMainDeck, int requestingActivity) {
+		return getDeck(deckpath, setAsMainDeck, true, requestingActivity, true);
+	}
+    /**
+     * Gets deck from its path. Opens it if needed.
+     *
+     * @param deckPath
+     * @param requestingActivity Code of the requesting Activity to be saved with the deck
+     * @param rebuild full deck load (rebuilds and resets a lot)
+     * @return the loaded deck
+     */
+	public static Deck getDeck(String deckpath, int requestingActivity, boolean rebuild) {
+		return getDeck(deckpath, false, true, requestingActivity, rebuild);
+	}
+	public synchronized static Deck getDeck(String deckpath, boolean setAsMainDeck, boolean doSafetyBackupIfNeeded, int requestingActivity, boolean rebuild) {
+		Deck deck = null;
+		lockDeck(deckpath);
+		try {
+			if (sLoadedDecks.containsKey(deckpath)) {
+				// do not open deck if already loaded
+			        DeckInformation deckInformation = sLoadedDecks.get(deckpath);
+		        	try {
+		        		AsyncTask<CloseDeckInformation, Void, DeckInformation> closingTask = deckInformation.mClosingAsyncTask;
+		                if (closingTask != null && closingTask.getStatus() == AsyncTask.Status.RUNNING && !closingTask.isCancelled()) {
+		                	if (deckInformation.mWaitForDeckTaskToFinish) {
+			                	Log.i(AnkiDroidApp.TAG, "DeckManager: deck " + deckpath + " is closing now, cancelling this");
+			                	closingTask.cancel(true);
+			                	deckInformation.mOpenedBy = new ArrayList<Integer>();
+		                	} else {
+			                	Log.i(AnkiDroidApp.TAG, "DeckManager: deck " + deckpath + " is closing now, waiting for this to finish and reopening it");
+			                	while (closingTask.getStatus() == AsyncTask.Status.RUNNING) {
+				                	closingTask.get();			                		
+			                	}
+			                	return getDeck(deckpath, setAsMainDeck, doSafetyBackupIfNeeded, requestingActivity, rebuild);
+		                	}
+		                }
+		            } catch (Exception e) {
+		            	Log.i(AnkiDroidApp.TAG, "DeckManager: An exception occurred while waiting for closing task of deck " + deckpath);
+		            }
+		        ArrayList<Integer> openList = deckInformation.mOpenedBy;
+		        if (!openList.contains(requestingActivity)) {
+			        Log.i(AnkiDroidApp.TAG, "DeckManager: deck " + deckpath + " already loaded, adding requesting activity");
+		        	openList.add(requestingActivity);
+		        } else {
+			        Log.i(AnkiDroidApp.TAG, "DeckManager: deck " + deckpath + " already loaded by this activity!");
+		        }
+		        Log.i(AnkiDroidApp.TAG, "DeckManager: deck " + deckpath + " is now opened by " + openList.toString());
+	        	deck = deckInformation.mDeck;                	
+
+        		// check for correct journal mode prior to syncing
+                if (requestingActivity == REQUESTING_ACTIVITY_SYNCCLIENT) {
+                	// close other learning activities
+    				sendWidgetBigClosedNotification();
+    				deckInformation.mOpenedBy.remove(new Integer(REQUESTING_ACTIVITY_BIGWIDGET));
+    				if (!deckInformation.mDeleteJournalModeForced) {
+            			Cursor cur = null;
+                        try {
+                        	cur = deck.getDB().getDatabase().rawQuery("PRAGMA journal_mode", null);
+                			if (cur.moveToFirst()) {
+                				if (!cur.getString(0).equalsIgnoreCase("delete")) {
+                					Log.i(AnkiDroidApp.TAG, "DeckManager: Journal mode not set to delete, reloading deck");
+                					deck.closeDeck();
+                					deck = Deck.openDeck(deckpath, rebuild, true);
+                				}
+            					deckInformation.mDeleteJournalModeForced = true;
+                			}
+            			} finally {
+            				if (cur != null && !cur.isClosed()) {
+            					cur.close();
+                            }
+                        }    					
+    				} else if (deckInformation.mOpenedBy.contains(REQUESTING_ACTIVITY_SYNCCLIENT)) {
+                    	// do not allow deck opening by other activities during syncing
+                    	deck = null;
+    				}
+    			} else if (rebuild) {
+            		if (!deckInformation.mInitiallyRebuilt) {
+        					Log.i(AnkiDroidApp.TAG, "DeckManager: reopen deck in order to rebuild");
+        					if (deck != null) {
+            					deck.closeDeck(false);        						
+        					}
+        					deckInformation.mDeck = Deck.openDeck(deckpath, true, requestingActivity == REQUESTING_ACTIVITY_SYNCCLIENT);
+        					deckInformation.mInitiallyRebuilt = true;
+        					WidgetStatus.update(AnkiDroidApp.getInstance().getBaseContext(), WidgetStatus.getDeckStatus(deck));
+            		}
+                }
+			} else {
+		        try {
+		            Log.i(AnkiDroidApp.TAG, "DeckManager: try to load deck " + deckpath + " (" + requestingActivity + ")");
+		            if (doSafetyBackupIfNeeded) {
+		            	BackupManager.safetyBackupNeeded(deckpath, BackupManager.SAFETY_BACKUP_THRESHOLD);
+		            }
+		            deck = Deck.openDeck(deckpath, rebuild, requestingActivity == REQUESTING_ACTIVITY_SYNCCLIENT);
+		            Log.i(AnkiDroidApp.TAG, "DeckManager: Deck loaded!");
+		            sLoadedDecks.put(deckpath, new DeckInformation(deckpath, deck, requestingActivity, rebuild));
+				} catch (RuntimeException e) {
+		            Log.e(AnkiDroidApp.TAG, "DeckManager: deck " + deckpath + " could not be opened = " + e.getMessage());
+					BackupManager.restoreDeckIfMissing(deckpath);
+					deck = null;
+		        }
+			}
+		} finally {
+			if (setAsMainDeck && deck != null) {
+				sMainDeckPath = deckpath;
+			}
+			unlockDeck(deckpath);
+		}
+		return deck;
+	}
+
+
+	public static void lockDeck(String path) {
+		if (!sDeckLocks.containsKey(path)) {
+			sDeckLocks.put(path, new ReentrantLock(true));
+		}
+		sDeckLocks.get(path).lock();
+	}
+
+
+	public static void unlockDeck(String path) {
+		if (sDeckLocks.containsKey(path)) {
+			sDeckLocks.get(path).unlock();
+		}
+	}
+
+
+    /** get main deck path */
+	public static String getMainDeckPath() {
+		return sMainDeckPath;
+	}
+
+
+	/** get main deck, does not reloads the deck if it's not loaded anymore */
+	public static Deck getMainDeck() {
+		if (sMainDeckPath == null || !sLoadedDecks.containsKey(sMainDeckPath)) {
+			return null;
+		} else {
+			return sLoadedDecks.get(sMainDeckPath).mDeck;
+		}
+	}
+
+
+    /** get main deck, reloads the deck if it's not loaded anymore */
+	public static Deck getMainDeck(int requestingActivity) {
+		if (sMainDeckPath == null) {
+			return null;
+		} else {
+			return getDeck(sMainDeckPath, requestingActivity);
+		}
+	}
+
+
+	public static void waitForDeckClosingThread(String deckpath) {
+		DeckInformation deckInformation = sLoadedDecks.get(deckpath);
+    	try {
+            if ((deckInformation.mClosingAsyncTask != null) && deckInformation.mClosingAsyncTask.getStatus() == AsyncTask.Status.RUNNING && !deckInformation.mClosingAsyncTask.isCancelled()) {
+            	if (deckInformation.mWaitForDeckTaskToFinish) {
+                	Log.i(AnkiDroidApp.TAG, "DeckManager: deck " + deckpath + " is closing now, cancelling this");
+                	deckInformation.mClosingAsyncTask.cancel(true);
+                	deckInformation.mOpenedBy = new ArrayList<Integer>();
+            	} else {
+                	// wait for closing deck async task before resuming
+                	Log.e(AnkiDroidApp.TAG, "DeckManager: deck " + deckpath + " is closing now, waiting for this to finish and reopening it");
+                	deckInformation.mClosingAsyncTask.get();
+            	}
+            }
+        } catch (Exception e) {
+        	Log.i(AnkiDroidApp.TAG, "DeckManager: An exception occurred while waiting for closing task of deck " + deckpath);
+        }
+	}
+
+
+    /** closes main deck, regardless of openings by other activities */
+	public static void closeMainDeck() {
+		closeMainDeck(true);
+	}
+
+
+    /** checks if main deck is opened in big widget and closes it if yes */
+	public static boolean mainIsOpenedInBigWidget() {
+		if (sLoadedDecks.containsKey(sMainDeckPath) && sLoadedDecks.get(sMainDeckPath).mOpenedBy.contains(REQUESTING_ACTIVITY_BIGWIDGET)) {
+			DeckManager.closeDeck(sMainDeckPath, DeckManager.REQUESTING_ACTIVITY_BIGWIDGET);
+			return true;
+		} else {
+			return false;
+		}
+	}
+
+
+    /** checks if deck is opened in big widget */
+	public static boolean deckIsOpenedInBigWidget(String deckpath) {
+		if (sLoadedDecks.containsKey(deckpath) && sLoadedDecks.get(deckpath).mOpenedBy.contains(REQUESTING_ACTIVITY_BIGWIDGET)) {
+			return true;
+		} else {
+			return false;
+		}
+	}
+
+
+	/** closes main deck, regardless of openings by other activities */
+	public static void closeMainDeck(boolean waitToFinish) {
+		closeMainDeck(-1, waitToFinish);
+	}
+
+
+    /** closes main deck */
+	public static void closeMainDeck(int requestingActivity) {
+		closeMainDeck(requestingActivity, true);
+	}
+	public static void closeMainDeck(int requestingActivity, boolean waitToFinish) {
+		if (sMainDeckPath != null && sLoadedDecks.containsKey(sMainDeckPath)) {
+			closeDeck(sMainDeckPath, requestingActivity, waitToFinish);
+		}
+		sMainDeckPath = null;
+	}
+
+
+    /** set main deck*/
+	public static void setMainDeck(String deckPath) {
+		sMainDeckPath = deckPath;
+	}
+
+
+    /**
+     * Closes all deck unconditionally regardless of a possible usage by other activities
+     *
+     * @param deckPath
+     */
+	public static void closeAllDecks() {
+		for (String deckpath : sLoadedDecks.keySet()) {
+			closeDeck(deckpath);
+		}
+	}
+
+
+    /**
+     * Closes the deck unconditionally regardless of a possible usage by other activities
+     *
+     * @param deckPath
+     */
+	public static void closeDeck(String deckpath) {
+		closeDeck(deckpath, -1, true);
+	}
+	public static void closeDeck(String deckpath, boolean waitToFinish) {
+		closeDeck(deckpath, -1, waitToFinish);
+	}
+
+
+    /**
+     * Closes the deck if it is not used by any other activity
+     *
+     * @param deckPath
+     * @param requestingActivity Code of the requesting Activity to be saved with the deck
+     */
+	public static void closeDeck(String deckpath, int requestingActivity) {
+		closeDeck(deckpath, requestingActivity, true);
+	}
+	public static void closeDeck(String deckpath, int requestingActivity, boolean waitToFinish) {
+		lockDeck(deckpath);
+		try {
+			if (sLoadedDecks.containsKey(deckpath)) {
+				DeckInformation di = sLoadedDecks.get(deckpath);
+				if ((di.mClosingAsyncTask != null) && di.mClosingAsyncTask.getStatus() == AsyncTask.Status.RUNNING && !di.mClosingAsyncTask.isCancelled()) {
+					Log.i(AnkiDroidApp.TAG, "DeckManager: closeDeck - deck " + deckpath + " is already closing");
+	            	return;
+	            }
+				ArrayList<Integer> openList = sLoadedDecks.get(deckpath).mOpenedBy;
+				if (requestingActivity != -1 && !openList.contains(requestingActivity)) {
+					Log.e(AnkiDroidApp.TAG, "DeckManager: deck " + deckpath + " is not loaded by " + requestingActivity);
+				} else if (requestingActivity != -1 && openList.size() > 1) {
+					openList.remove(new Integer(requestingActivity));
+					Log.i(AnkiDroidApp.TAG, "DeckManager: deck " + deckpath + " used still by more activities (" + openList.toString() + "), removing only " + requestingActivity);
+					if (requestingActivity == REQUESTING_ACTIVITY_BIGWIDGET) {
+						//sendWidgetBigClosedNotification();
+					}
+				} else {
+					Log.i(AnkiDroidApp.TAG, "DeckManager: closing deck " + deckpath + " (" + requestingActivity + ")");
+					sLoadedDecks.get(deckpath).mClosingAsyncTask = new CloseDeckAsyncTask();
+					sLoadedDecks.get(deckpath).mClosingAsyncTask.execute(new CloseDeckInformation(deckpath, requestingActivity));
+
+					// close widget learning screen when deck is closed by other activity
+					if (openList.contains(REQUESTING_ACTIVITY_BIGWIDGET)) {
+						// TODO: close learned in big widget
+					//	sendWidgetBigClosedNotification();
+					}
+					if (sMainDeckPath != null && sMainDeckPath.equals(deckpath)) {
+						sMainDeckPath = null;
+					}
+				}
+			} else {
+				Log.e(AnkiDroidApp.TAG, "DeckManager: deck " + deckpath + " is not a loaded deck");
+			}			
+		} finally {
+    		unlockDeck(deckpath);
+		}
+	}
+
+
+	private static void sendWidgetBigClosedNotification() {
+		AnkiDroidWidgetBig.setDeck(null);
+    	AnkiDroidWidgetBig.updateWidget(AnkiDroidWidgetBig.UpdateService.VIEW_DECKS);
+	}
+
+
+	public static String getDeckPathAfterDeckSelectionDialog(int item) {
+		return getDeckPathAfterDeckSelectionDialog(sDeckNames[item]);
+	}
+	public static String getDeckPathAfterDeckSelectionDialog(String deckName) {
+		return sDeckPaths.get(deckName);
+	}
+
+
+	public static StyledDialog getSelectDeckDialog(Context context, OnClickListener itemClickListener, OnCancelListener cancelListener, OnDismissListener dismissListener) {
+		return getSelectDeckDialog(context, itemClickListener, cancelListener, dismissListener, null, null);
+	}
+	public static StyledDialog getSelectDeckDialog(Context context, OnClickListener itemClickListener, OnCancelListener cancelListener, OnDismissListener dismissListener, String buttonTitle, View.OnClickListener buttonClickListener) {
+		int len = 0;
+		File[] fileList;
+
+		File dir = new File(PrefSettings.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext())
+				.getString("deckPath", AnkiDroidApp.getStorageDirectory()));
+		fileList = dir.listFiles(new AnkiFilter());
+
+		if (dir.exists() && dir.isDirectory() && fileList != null) {
+			len = fileList.length;
+		}
+
+		TreeSet<String> tree = new TreeSet<String>();
+		sDeckPaths = new HashMap<String, String>();
+
+		if (len > 0 && fileList != null) {
+			Log.i(AnkiDroidApp.TAG,
+					"DeckManager - getSelectDeckDialog, number of anki files = " + len);
+			for (File file : fileList) {
+				String name = file.getName().replaceAll(".anki", "");
+				tree.add(name);
+				sDeckPaths.put(name, file.getAbsolutePath());
+			}
+		}
+
+		StyledDialog.Builder builder = new StyledDialog.Builder(context);
+		builder.setTitle(R.string.fact_adder_select_deck);
+		// Convert to Array
+		sDeckNames = new String[tree.size()];
+		tree.toArray(sDeckNames);
+
+		builder.setItems(sDeckNames, itemClickListener);
+		builder.setOnCancelListener(cancelListener);
+		builder.setOnDismissListener(dismissListener);
+
+		if (buttonTitle != null) {
+			Button button = new Button(context, null, android.R.attr.buttonStyleSmall);
+			button.setText(buttonTitle);
+			button.setOnClickListener(buttonClickListener);
+			builder.setView(button, false, true);
+		}
+
+		return builder.create();
+	}
+
+
+    private static class CloseDeckAsyncTask extends AsyncTask<CloseDeckInformation, Void, DeckInformation> {
+
+    	@Override
+        protected DeckInformation doInBackground(CloseDeckInformation... params) {
+            Log.d(AnkiDroidApp.TAG, "DeckManager.CloseDeckAsyncTask.doInBackground()");
+            String deckpath = params[0].mDeckPath;
+            int requestingActivity = params[0].mCaller;
+            DeckInformation di = sLoadedDecks.get(deckpath);
+            
+            if (di.mOpenedBy.contains(REQUESTING_ACTIVITY_STUDYOPTIONS) && requestingActivity != REQUESTING_ACTIVITY_STUDYOPTIONS) {
+            	// wait for any decktask operation
+            	di.mWaitForDeckTaskToFinish = true;
+            	DeckTask.waitToFinish();
+            	di.mWaitForDeckTaskToFinish = false;
+            	if (this.isCancelled()) {
+            		return null;
+            	}
+            }
+
+            try {
+                di.mDeck.closeDeck(false);
+                Log.e(AnkiDroidApp.TAG, "DeckManager.CloseDeckAsyncTask: deck " + deckpath + " successfully closed");
+            } catch (RuntimeException e) {
+            	Log.e(AnkiDroidApp.TAG, "DeckManager.CloseDeckAsyncTask: could not close deck " + deckpath + ": " + e);
+            }
+            return di;
+        }
+
+        @Override
+        protected void onPostExecute(DeckInformation deckInformation) {
+            Log.d(AnkiDroidApp.TAG, "DeckManager.CloseDeckAsyncTask.onPostExecute()");
+            if (this.isCancelled()) {
+            	return;
+            }
+            sLoadedDecks.remove(deckInformation.mKey);
+    		for (String dp : sLoadedDecks.keySet()) {
+        		Log.i(AnkiDroidApp.TAG, "DeckManager: still loaded: " + dp + ": " + sLoadedDecks.get(dp).mOpenedBy.toString());
+    		}
+        }
+    }
+
+
+	public static class DeckInformation {
+		public String mKey;
+		public Deck mDeck;
+		public boolean mInitiallyRebuilt = true;
+		public boolean mDeleteJournalModeForced = false;
+		public boolean mWaitForDeckTaskToFinish = false;
+		public ArrayList<Integer> mOpenedBy = new ArrayList<Integer>();
+		public AsyncTask<CloseDeckInformation, Void, DeckInformation> mClosingAsyncTask;
+
+		DeckInformation(String key, Deck deck, int openedBy, boolean initiallyRebuilt) {
+			this.mKey = key;
+			this.mDeck = deck;
+			this.mOpenedBy.add(openedBy);
+			this.mInitiallyRebuilt = initiallyRebuilt;
+		}
+	}
+
+
+	public static class CloseDeckInformation {
+		public String mDeckPath;
+		public int mCaller;
+
+		CloseDeckInformation(String deckpath, int caller) {
+			this.mDeckPath = deckpath;
+			this.mCaller = caller;
+		}
+	}
+}
diff --git a/src/com/ichi2/anki/DeckPicker.java b/src/com/ichi2/anki/DeckPicker.java
index cf01932175..70f2e32de7 100644
--- a/src/com/ichi2/anki/DeckPicker.java
+++ b/src/com/ichi2/anki/DeckPicker.java
@@ -32,11 +32,14 @@ import android.content.SharedPreferences;
 import android.content.DialogInterface.OnCancelListener;
 import android.content.res.Resources;
 import android.database.SQLException;
+import android.database.sqlite.SQLiteException;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.Message;
 import android.preference.PreferenceManager;
+import android.text.InputFilter;
 import android.text.SpannableStringBuilder;
+import android.text.Spanned;
 import android.text.style.StyleSpan;
 import android.text.style.UnderlineSpan;
 import android.util.Log;
@@ -54,6 +57,7 @@ import android.view.GestureDetector.SimpleOnGestureListener;
 import android.view.View.OnClickListener;
 import android.widget.AdapterView;
 import android.widget.Button;
+import android.widget.EditText;
 import android.widget.ListView;
 import android.widget.ProgressBar;
 import android.widget.SimpleAdapter;
@@ -64,7 +68,9 @@ import com.ichi2.anki.DeckTask.TaskData;
 import com.ichi2.async.Connection;
 import com.ichi2.async.Connection.Payload;
 import com.ichi2.themes.StyledDialog;
+import com.ichi2.themes.StyledProgressDialog;
 import com.ichi2.themes.Themes;
+import com.ichi2.widget.WidgetStatus;
 import com.tomgibara.android.veecheck.util.PrefSettings;
 
 import java.io.File;
@@ -101,6 +107,7 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
 	private static final int DIALOG_OPTIMIZE_DATABASE = 7;
 	private static final int DIALOG_DELETE_BACKUPS = 8;
 	private static final int DIALOG_CONTEXT_MENU = 9;
+	private static final int DIALOG_REPAIR_DECK = 10;
 
 	/**
 	 * Menus
@@ -117,21 +124,28 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
 	/**
 	 * Context Menus
 	 */
-    private static final int CONTEXT_MENU_OPTIMIZE = 0;
-    private static final int CONTEXT_MENU_CUSTOM_DICTIONARY = 1;
-    private static final int CONTEXT_MENU_DOWNLOAD_MEDIA = 2;
+    private static final int CONTEXT_MENU_DECK_SUMMARY = 0;
+    private static final int CONTEXT_MENU_OPTIMIZE = 1;
+    private static final int CONTEXT_MENU_CUSTOM_DICTIONARY = 2;
     private static final int CONTEXT_MENU_RESET_LANGUAGE = 3;
-//    private static final int CONTEXT_MENU_RESTORE_BACKUPS = 4;
     private static final int CONTEXT_MENU_REMOVE_BACKUPS = 4;
-    private static final int CONTEXT_MENU_DELETE_DECK = 5;
+    private static final int CONTEXT_MENU_RENAME_DECK = 5;
+    private static final int CONTEXT_MENU_REPAIR_DECK = 6;
+    private static final int CONTEXT_MENU_DELETE_DECK = 7;
+    private static final int CONTEXT_MENU_DOWNLOAD_MEDIA = 8;
+//  private static final int CONTEXT_MENU_RESTORE_BACKUPS = 9;
     
 	/**
 	 * Message types
 	 */
-	private static final int MSG_UPGRADE_NEEDED = 0;
-	private static final int MSG_UPGRADE_SUCCESS = 1;
-	private static final int MSG_UPGRADE_FAILURE = 2;
-	private static final int MSG_COULD_NOT_BE_LOADED = 3;
+	private static final int MSG_LOADING_DECK = 0;
+	private static final int MSG_UPGRADE_NEEDED = 1;
+	private static final int MSG_UPGRADE_SUCCESS = 2;
+	private static final int MSG_UPGRADE_FAILURE = 3;
+	private static final int MSG_COULD_NOT_BE_LOADED = 4;
+	private static final int MSG_CREATING_BACKUP = 5;
+	private static final int MSG_BACKUP_ERROR = 6;
+
     /** Zeemote messages */
     private static final int MSG_ZEEMOTE_BUTTON_A = 0x110;
     private static final int MSG_ZEEMOTE_BUTTON_B = MSG_ZEEMOTE_BUTTON_A+1;
@@ -165,7 +179,7 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
 
 	private DeckPicker mSelf;
 
-	private ProgressDialog mProgressDialog;
+	private StyledProgressDialog mProgressDialog;
 	private StyledDialog mSyncLogAlert;
 	private StyledDialog mUpgradeNotesAlert;
 	private StyledDialog mMissingMediaAlert;
@@ -204,6 +218,8 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
 	private int mTotalCards = 0;
 	private int mTotalTime = 0;
 
+	private EditText mRenameDeckEditText;
+
 	int mStatisticType;
 
 	boolean mCompletionBarRestrictToActive = false; // set this to true in order to calculate completion bar only for active cards
@@ -236,36 +252,12 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
 	};
 
 
-	DeckTask.TaskListener mCloseDeckHandler = new DeckTask.TaskListener() {
-
-        @Override
-        public void onPreExecute() {
-            mProgressDialog = ProgressDialog.show(DeckPicker.this, "", getResources()
-                    .getString(R.string.close_deck), true);
-        }
-
-
-        @Override
-        public void onPostExecute(DeckTask.TaskData result) {
-        	if (mProgressDialog != null && mProgressDialog.isShowing()) {
-        		mProgressDialog.dismiss();
-        	}
-        	DeckPicker.this.finish();
-        }
-
-
-        @Override
-        public void onProgressUpdate(DeckTask.TaskData... values) {
-        }
-    };
-
-
 	private DialogInterface.OnClickListener mContextMenuListener = new DialogInterface.OnClickListener() {
 		@Override
 		public void onClick(DialogInterface dialog, int item) {
 			waitForDeckLoaderThread();
 			Resources res = getResources();
-			
+
 			@SuppressWarnings("unchecked")
 			HashMap<String, String> data = (HashMap<String, String>) mDeckListAdapter.getItem(mContextMenuPosition);
 			String deckPath = null;
@@ -280,7 +272,7 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
 				return;
 			case CONTEXT_MENU_OPTIMIZE:
 				deckPath = data.get("filepath");
-				deck = getDeck(deckPath);
+				deck = DeckManager.getDeck(deckPath, DeckManager.REQUESTING_ACTIVITY_DECKPICKER, false);
 		    	DeckTask.launchDeckTask(DeckTask.TASK_TYPE_OPTIMIZE_DECK, mOptimizeDeckHandler, new DeckTask.TaskData(deck, 0));
 				return;
 			case CONTEXT_MENU_CUSTOM_DICTIONARY:
@@ -313,18 +305,69 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
 				return;
 			case CONTEXT_MENU_DOWNLOAD_MEDIA:
 			    deckPath = data.get("filepath");
-			    deck = getDeck(deckPath);
+				deck = DeckManager.getDeck(deckPath, DeckManager.REQUESTING_ACTIVITY_DECKPICKER);
 			    Reviewer.setupMedia(deck);
 			    Connection.downloadMissingMedia(mDownloadMediaListener, new Connection.Payload(new Object[] {deck}));
 				return;
+			case CONTEXT_MENU_RENAME_DECK:
+				StyledDialog.Builder builder2 = new StyledDialog.Builder(DeckPicker.this);
+				builder2.setTitle(res.getString(R.string.contextmenu_deckpicker_rename_deck));
+
+				mCurrentDeckPath = null;
+				mCurrentDeckPath = data.get("filepath");
+
+				mRenameDeckEditText = (EditText) new EditText(DeckPicker.this);
+				mRenameDeckEditText.setText(mCurrentDeckFilename.replace(".anki", ""));
+				InputFilter filter = new InputFilter() {
+					public CharSequence filter(CharSequence source, int start,
+							int end, Spanned dest, int dstart, int dend) {
+						for (int i = start; i < end; i++) {
+							if (!Character.isLetterOrDigit(source.charAt(i))) {
+								return "";
+							}
+						}
+						return null;
+					}
+				};
+				mRenameDeckEditText.setFilters(new InputFilter[] { filter });
+				builder2.setView(mRenameDeckEditText, false, true);
+				builder2.setPositiveButton(res.getString(R.string.rename),
+						new DialogInterface.OnClickListener() {
+
+							@Override
+							public void onClick(DialogInterface dialog, int which) {
+								Log.i(AnkiDroidApp.TAG, "Renaming file " + mCurrentDeckFilename + " to " + mRenameDeckEditText.getText().toString());
+								File file = new File(mCurrentDeckPath);
+								String newFilename = file.getParentFile().getAbsolutePath() + "/" + mRenameDeckEditText.getText().toString().replace("[:\\/]", "") + ".anki";
+								File newFile = new File(newFilename);
+								if (newFile.exists() || !file.renameTo(newFile)) {
+									Themes.showThemedToast(DeckPicker.this, getResources().getString(R.string.rename_error, mCurrentDeckFilename), true);
+								} else {
+									populateDeckList(mPrefDeckPath);
+								}
+								mCurrentDeckPath = null;
+							}
+						});
+				builder2.setNegativeButton(res.getString(R.string.cancel), null);
+				builder2.create().show();
+				return;
 			case CONTEXT_MENU_REMOVE_BACKUPS:
 				mCurrentDeckPath = null;
 				mCurrentDeckPath = data.get("filepath");
 				showDialog(DIALOG_DELETE_BACKUPS);
 				return;
+			case CONTEXT_MENU_REPAIR_DECK:
+				mCurrentDeckPath = null;
+				mCurrentDeckPath = data.get("filepath");
+				showDialog(DIALOG_REPAIR_DECK);
+				return;
 //			case CONTEXT_MENU_RESTORE_BACKUPS:
 //				BackupManager.restoreDeckBackup(DeckPicker.this, data.get("filepath"));
 //				return true;
+			case CONTEXT_MENU_DECK_SUMMARY:
+				mStatisticType = Statistics.TYPE_DECK_SUMMARY;
+				DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_STATISTICS, mLoadStatisticsHandler, new DeckTask.TaskData(DeckPicker.this, new String[]{data.get("filepath")}, mStatisticType, 0));
+				return;
 			}
 		}
 	};
@@ -350,24 +393,44 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
 			// TODO: set this correctly
 			double modified = data.getDouble("mod");
 
-			if (msgtype == DeckPicker.MSG_UPGRADE_NEEDED) {
+			switch (msgtype) {
+			case DeckPicker.MSG_LOADING_DECK:
+				dueString = res.getString(R.string.deckpicker_loaddeck);
+				newString = "";
+				showProgress = "true";
+				break;
+			case DeckPicker.MSG_UPGRADE_NEEDED:
 				dueString = res.getString(R.string.deckpicker_upgrading);
 				newString = "";
 				showProgress = "true";
-			} else if (msgtype == DeckPicker.MSG_UPGRADE_FAILURE) {
+				break;
+			case DeckPicker.MSG_UPGRADE_FAILURE:
 				dueString = "Upgrade failed!";
 				newString = "";
 				showProgress = "false";
-			} else if (msgtype == DeckPicker.MSG_UPGRADE_SUCCESS) {
+				break;
+			case DeckPicker.MSG_UPGRADE_SUCCESS:
 				dueString = res.getQuantityString(R.plurals.deckpicker_due, due, due, total);
 				newString = String
 						.format(res.getString(R.string.deckpicker_new), data
 								.getInt("new"));
 				showProgress = "false";
-			} else if (msgtype == DeckPicker.MSG_COULD_NOT_BE_LOADED) {
+				break;
+			case DeckPicker.MSG_COULD_NOT_BE_LOADED:
 				dueString = res.getString(R.string.deckpicker_loading_error);
 				newString = "";
-				showProgress = "false";				
+				showProgress = "false";
+				break;
+			case DeckPicker.MSG_CREATING_BACKUP:
+				dueString = res.getString(R.string.deckpicker_creating_backup);
+				newString = "";
+				showProgress = "true";
+				break;
+			case DeckPicker.MSG_BACKUP_ERROR:
+				dueString = res.getString(R.string.deckpicker_backup_error);
+				newString = "";
+				showProgress = "false";
+				break;
 			}
 
 			int count = mDeckListAdapter.getCount();
@@ -411,7 +474,7 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
 		@Override
 		public void onPreExecute() {
 			if (mProgressDialog == null || !mProgressDialog.isShowing()) {
-				mProgressDialog = ProgressDialog.show(DeckPicker.this, getResources().getString(R.string.sync_all_title), getResources().getString(R.string.sync_prepare_syncing), true);
+				mProgressDialog = StyledProgressDialog.show(DeckPicker.this, getResources().getString(R.string.sync_all_title), getResources().getString(R.string.sync_prepare_syncing), true);
 			}
 		}
 
@@ -502,7 +565,7 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
             mMissingMediaAlert.show();
             
             Deck deck = (Deck) data.result;
-            closeDeck(deck);
+			DeckManager.closeDeck(deck.getDeckPath(), DeckManager.REQUESTING_ACTIVITY_DECKPICKER);
          }
     };
 
@@ -673,12 +736,21 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
         	AnkiDroidApp.zeemoteController().removeJoystickListener(adapter);
     		adapter.removeButtonListener(this);
     		adapter = null;
-        }        
+        }
         
 		super.onPause();
 		waitForDeckLoaderThread();
 	}
 
+	@Override
+	protected void onStop() {
+		Log.i(AnkiDroidApp.TAG, "DeckPicker - onStop");
+		super.onStop();
+		if (!isFinishing() && mIsFinished) {
+			WidgetStatus.update(this);
+		}
+	}
+
 	@Override
 	protected void onDestroy() {
 		super.onDestroy();
@@ -753,7 +825,7 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
 		case DIALOG_DELETE_DECK:
 			builder.setTitle(res.getString(R.string.delete_deck_title));
 			builder.setIcon(android.R.drawable.ic_dialog_alert);
-			builder.setMessage(String.format(res.getString(R.string.delete_deck_message), mCurrentDeckFilename));
+			builder.setMessage(String.format(res.getString(R.string.delete_deck_message), "\'" + mCurrentDeckFilename + "\'"));
 			builder.setPositiveButton(res.getString(R.string.delete_deck_confirm),
 					new DialogInterface.OnClickListener() {
 
@@ -787,14 +859,14 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
 		case DIALOG_DELETE_BACKUPS:
 			builder.setTitle(res.getString(R.string.backup_manager_title));
 			builder.setIcon(android.R.drawable.ic_dialog_alert);
-			builder.setMessage(String.format(res.getString(R.string.backup_delete_deck_backups_alert), mCurrentDeckFilename));
+			builder.setMessage(String.format(res.getString(R.string.backup_delete_deck_backups_alert), "\'" + mCurrentDeckFilename + "\'"));
 			builder.setPositiveButton(res.getString(R.string.delete_deck_confirm),
 					new DialogInterface.OnClickListener() {
 
 						@Override
 						public void onClick(DialogInterface dialog, int which) {
 							if (BackupManager.deleteDeckBackups(mCurrentDeckPath, 0)) {
-								Themes.showThemedToast(DeckPicker.this, getResources().getString(R.string.backup_delete_deck_backups, mCurrentDeckFilename), true);
+								Themes.showThemedToast(DeckPicker.this, getResources().getString(R.string.backup_delete_deck_backups, "\'" + mCurrentDeckFilename + "\'"), true);
 							}
 							mCurrentDeckPath = null;
 							mCurrentDeckFilename = null;
@@ -844,22 +916,55 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
 				dialog = null;
 				break;
 			}
-			String[] entries = new String[6];
+			String[] entries = new String[9];
 			entries[CONTEXT_MENU_OPTIMIZE] = res.getString(R.string.contextmenu_deckpicker_optimize_deck);
 			entries[CONTEXT_MENU_CUSTOM_DICTIONARY] = res.getString(R.string.contextmenu_deckpicker_set_custom_dictionary);
 			entries[CONTEXT_MENU_DOWNLOAD_MEDIA] = res.getString(R.string.contextmenu_deckpicker_download_missing_media);
 			entries[CONTEXT_MENU_RESET_LANGUAGE] = res.getString(R.string.contextmenu_deckpicker_reset_language_assignments);
+			entries[CONTEXT_MENU_REPAIR_DECK] = res.getString(R.string.backup_repair_deck);
 //			entries[CONTEXT_MENU_RESTORE_BACKUPS] = res.getString(R.string.R.string.contextmenu_deckpicker_restore_backups);
 			entries[CONTEXT_MENU_REMOVE_BACKUPS] = res.getString(R.string.contextmenu_deckpicker_remove_backups);
+			entries[CONTEXT_MENU_RENAME_DECK] = res.getString(R.string.contextmenu_deckpicker_rename_deck);
 			entries[CONTEXT_MENU_DELETE_DECK] = res.getString(R.string.contextmenu_deckpicker_delete_deck);
-	        builder.setTitle("contextmenu");
+			entries[CONTEXT_MENU_DECK_SUMMARY] = res.getStringArray(R.array.statistics_type_labels)[Statistics.TYPE_DECK_SUMMARY];
+
+			builder.setTitle("Context Menu");
 	        builder.setIcon(R.drawable.ic_menu_manage);
 	        builder.setItems(entries, mContextMenuListener);
 	        dialog = builder.create();
 			break;
+		case DIALOG_REPAIR_DECK:
+    		builder.setTitle(res.getString(R.string.backup_repair_deck));
+			builder.setIcon(android.R.drawable.ic_dialog_alert);
+    		builder.setPositiveButton(res.getString(R.string.yes), new DialogInterface.OnClickListener() {
+				@Override
+				public void onClick(DialogInterface dialog, int which) {
+	            	DeckTask.launchDeckTask(DeckTask.TASK_TYPE_REPAIR_DECK, mRepairDeckHandler, new DeckTask.TaskData(mCurrentDeckPath));
+					mCurrentDeckPath = null;
+					mCurrentDeckFilename = null;
+				}
+    		});
+    		builder.setNegativeButton(res.getString(R.string.no), new DialogInterface.OnClickListener() {
+				@Override
+				public void onClick(DialogInterface dialog, int which) {
+					mCurrentDeckPath = null;
+					mCurrentDeckFilename = null;
+				}
+    		});
+    		builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
+				@Override
+				public void onCancel(DialogInterface dialog) {
+					mCurrentDeckPath = null;
+					mCurrentDeckFilename = null;
+				}
+    		});
+			dialog = builder.create();
+			break;
+
 		default:
 			dialog = null;
 		}
+		dialog.setOwnerActivity(DeckPicker.this);
 		return dialog;
 	}
 
@@ -871,17 +976,21 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
 		switch (id) {
 		case DIALOG_DELETE_DECK:
 			mCurrentDeckFilename = mDeckList.get(mContextMenuPosition).get("name");
-			ad.setMessage(String.format(res.getString(R.string.delete_deck_message), mCurrentDeckFilename));
+			ad.setMessage(String.format(res.getString(R.string.delete_deck_message), "\'" + mCurrentDeckFilename + "\'"));
 			break;
 		case DIALOG_DELETE_BACKUPS:
 			mCurrentDeckFilename = mDeckList.get(mContextMenuPosition).get("name");
-			ad.setMessage(String.format(res.getString(R.string.backup_delete_deck_backups_alert), mCurrentDeckFilename));
+			ad.setMessage(String.format(res.getString(R.string.backup_delete_deck_backups_alert), "\'" +mCurrentDeckFilename + "\'"));
 			break;
 		case DIALOG_CONTEXT_MENU:
 			mCurrentDeckFilename = mDeckList.get(mContextMenuPosition).get("name");
 			ad.setTitle(mCurrentDeckFilename);
 			break;
-		}		
+		case DIALOG_REPAIR_DECK:
+			mCurrentDeckFilename = mDeckList.get(mContextMenuPosition).get("name");
+			ad.setMessage(String.format(res.getString(R.string.repair_deck_dialog), mCurrentDeckFilename, BackupManager.BROKEN_DECKS_SUFFIX.replace("/", "")));
+			break;
+		}
 	}
 
 
@@ -945,18 +1054,16 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
 				public void onReceive(Context context, Intent intent) {
 					String action = intent.getAction();
 					if (action.equals(Intent.ACTION_MEDIA_UNMOUNTED)) {
-						Log.i(AnkiDroidApp.TAG,
-										"DeckPicker - mUnmountReceiver, Action = Media Unmounted");
-						SharedPreferences preferences = PreferenceManager
-								.getDefaultSharedPreferences(getBaseContext());
+						Log.i(AnkiDroidApp.TAG, "DeckPicker - mUnmountReceiver, Action = Media Unmounted");
+						SharedPreferences preferences = PrefSettings
+								.getSharedPrefs(getBaseContext());
 						String deckPath = preferences.getString("deckPath",
 								AnkiDroidApp.getStorageDirectory());
 						populateDeckList(deckPath);
 					} else if (action.equals(Intent.ACTION_MEDIA_MOUNTED)) {
-						Log.i(AnkiDroidApp.TAG,
-										"DeckPicker - mUnmountReceiver, Action = Media Mounted");
-						SharedPreferences preferences = PreferenceManager
-								.getDefaultSharedPreferences(getBaseContext());
+						Log.i(AnkiDroidApp.TAG, "DeckPicker - mUnmountReceiver, Action = Media Mounted");
+						SharedPreferences preferences = PrefSettings
+								.getSharedPrefs(getBaseContext());
 						String deckPath = preferences.getString("deckPath",
 								AnkiDroidApp.getStorageDirectory());
 						mDeckIsSelected = false;
@@ -979,18 +1086,13 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
 	}
 	private void closeDeckPicker(boolean backPressed) {
 		if (mPrefStartupDeckPicker && backPressed) {
-    		setResult(StudyOptions.RESULT_CLOSE);
-    		Deck deck = AnkiDroidApp.deck();
-    		if (deck != null) {
-    			DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CLOSE_DECK, mCloseDeckHandler, new DeckTask.TaskData(deck, 0));
-    		} else {
-    			finish();
-    		}
+			setResult(StudyOptions.RESULT_CLOSE);
+			finish();
 		} else {
 			finish();
-			if (StudyOptions.getApiLevel() > 4) {
-	    		ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.LEFT);
-	    	}
+			if (getIntent().getBooleanExtra("showAnimation", false) && StudyOptions.getApiLevel() > 4) {
+	    			ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.LEFT);
+    		}
 		}
 	}
 
@@ -1003,7 +1105,7 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
 					break;
 				}
 			}
-        	mDeckNotLoadedAlert.setMessage(getResources().getString(R.string.open_deck_failed, new File(mCurrentDeckPath).getName().replace(".anki", ""), BackupManager.BROKEN_DECKS_SUFFIX.replace("/", ""), getResources().getString(R.string.repair_deck)));
+        	mDeckNotLoadedAlert.setMessage(getResources().getString(R.string.open_deck_failed, "\'" + new File(mCurrentDeckPath).getName() + "\'", BackupManager.BROKEN_DECKS_SUFFIX.replace("/", ""), getResources().getString(R.string.repair_deck)));
 			mDeckNotLoadedAlert.show();
 		} else if (reloadIfEmpty) {
 			if (mRestoredOrDeleted) {
@@ -1048,6 +1150,7 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
 		builder.setTitle(res.getString(R.string.sync_log_title));
 		builder.setPositiveButton(res.getString(R.string.ok), null);
 		mSyncLogAlert = builder.create();
+		mSyncLogAlert.setOwnerActivity(DeckPicker.this);
 		// Upgrade notes dialog
 		builder = new StyledDialog.Builder(this);
 		builder.setTitle(res.getString(
@@ -1058,7 +1161,7 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
         builder.setTitle(res.getString(R.string.deckpicker_download_missing_title));
         builder.setPositiveButton(res.getString(R.string.ok), null);
         mMissingMediaAlert = builder.create();
-        mProgressDialog = new ProgressDialog(DeckPicker.this);
+        mProgressDialog = new StyledProgressDialog(DeckPicker.this);
         mProgressDialog.setTitle(R.string.deckpicker_download_missing_title);
         mProgressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
         mProgressDialog.setMax(100);
@@ -1122,6 +1225,13 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
         		}
             }
         });
+        builder.setNeutralButton(res.getString(R.string.backup_repair_deck), new Dialog.OnClickListener() {
+
+			@Override
+			public void onClick(DialogInterface arg0, int arg1) {
+	        	DeckTask.launchDeckTask(DeckTask.TASK_TYPE_REPAIR_DECK, mRepairDeckHandler, new DeckTask.TaskData(mCurrentDeckPath));
+			}
+        });
         builder.setNegativeButton(res.getString(R.string.delete_deck_title), new Dialog.OnClickListener() {
 
             @Override
@@ -1130,13 +1240,13 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
             	StyledDialog.Builder builder = new StyledDialog.Builder(DeckPicker.this);
             	builder.setCancelable(true).setTitle(res.getString(R.string.delete_deck_title))
             		.setIcon(android.R.drawable.ic_dialog_alert)
-            		.setMessage(String.format(res.getString(R.string.delete_deck_message), new File(mCurrentDeckPath).getName().replace(".anki", "")))
+            		.setMessage(String.format(res.getString(R.string.delete_deck_message), "\'" + new File(mCurrentDeckPath).getName().replace(".anki", "") + "\'"))
             		.setPositiveButton(res.getString(R.string.delete_deck_confirm), new DialogInterface.OnClickListener() {
 
 						@Override
 						public void onClick(DialogInterface dialog, int which) {
 							if (BackupManager.moveDeckToBrokenFolder(mCurrentDeckPath)) {
-								Themes.showThemedToast(DeckPicker.this, getResources().getString(R.string.delete_deck_success, new File(mCurrentDeckPath).getName().replace(".anki", ""), BackupManager.BROKEN_DECKS_SUFFIX.replace("/", "")), false);								
+								Themes.showThemedToast(DeckPicker.this, getResources().getString(R.string.delete_deck_success, "\'" + (new File(mCurrentDeckPath).getName().replace(".anki", "")) + "\'", "\'" + BackupManager.BROKEN_DECKS_SUFFIX.replace("/", "") + "\'"), false);								
 								mRestoredOrDeleted = true;
 								handleRestoreDecks(true);
 							}
@@ -1153,8 +1263,7 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
 						public void onCancel(DialogInterface dialog) {
 							mDeckNotLoadedAlert.show();
 						}
-					}).show();
-						
+					}).show();					
             }
         });
         builder.setCancelable(true);
@@ -1258,6 +1367,7 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
             	finish();
             } else {
             	SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
+				BackupManager.initBackup();
                 if (!mPrefDeckPath.equals(preferences.getString("deckPath", AnkiDroidApp.getStorageDirectory())) || mPrefDeckOrder != Integer.parseInt(preferences.getString("deckOrder", "0"))) {
                 	populateDeckList(preferences.getString("deckPath", AnkiDroidApp.getStorageDirectory()));
                 }
@@ -1381,6 +1491,34 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
 					String path = file.getAbsolutePath();
 					Deck deck;
 
+					Bundle data = new Bundle();
+					Message msg;
+
+					// See if a backup is needed (only done in deckpicker, if last backup is quite old or no backup at all is available)
+					// It is necessary to do it here, because retrieving deck information can already lead to a deck removal (Android bug)
+					if (BackupManager.isActivated() && BackupManager.safetyBackupNeeded(path, BackupManager.SAFETY_BACKUP_THRESHOLD)) {
+						Log.i(AnkiDroidApp.TAG, "DeckPicker - Safety backup for deck " + path + "needed");
+						data.putString("absPath", path);
+						data.putInt("msgtype", MSG_CREATING_BACKUP);
+						msg = Message.obtain();
+						msg.setData(data);
+						mHandler.sendMessage(msg);
+						if (BackupManager.backupDeck(path) == BackupManager.RETURN_BACKUP_CREATED) {
+							data.putString("absPath", path);
+							data.putInt("msgtype", MSG_LOADING_DECK);
+							msg = Message.obtain();
+							msg.setData(data);
+							mHandler.sendMessage(msg);
+						} else {
+							data.putString("absPath", path);
+							data.putInt("msgtype", MSG_BACKUP_ERROR);
+							msg = Message.obtain();
+							msg.setData(data);
+							mHandler.sendMessage(msg);
+							continue;
+						}
+					}
+
 					// See if we need to upgrade the deck
 					int version = 0;
 					try {
@@ -1388,53 +1526,48 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
 					} catch (Exception e) {
 						Log.w(AnkiDroidApp.TAG, "Could not open database "
 								+ path);
-						if (!mBrokenDecks.contains(path)) {
-							mBrokenDecks.add(path);
-						}
-						Bundle data = new Bundle();
+						addBrokenDeck(path);
 						data.putString("absPath", path);
 						data.putInt("msgtype", MSG_COULD_NOT_BE_LOADED);
-						Message msg = Message.obtain();
+						msg = Message.obtain();
 						msg.setData(data);
 						mHandler.sendMessage(msg);						
 						continue;
 					}
 
 					if (version < Deck.DECK_VERSION) {
-						Bundle data = new Bundle();
 						data.putString("absPath", path);
 						data.putInt("msgtype", MSG_UPGRADE_NEEDED);
 						data.putInt("version", version);
 						data.putString("notes", "");
-						Message msg = Message.obtain();
+						msg = Message.obtain();
 						msg.setData(data);
 						mHandler.sendMessage(msg);
 					}
-					deck = getDeck(path);
+					deck = DeckManager.getDeck(path, DeckManager.REQUESTING_ACTIVITY_DECKPICKER, false);
 					if (deck == null) {
-						Bundle data = new Bundle();
+						addBrokenDeck(path);
 						data.putString("absPath", path);
 						data.putInt("msgtype", MSG_COULD_NOT_BE_LOADED);
-						Message msg = Message.obtain();
+						msg = Message.obtain();
 						msg.setData(data);
 						mHandler.sendMessage(msg);
 						continue;
 					}
 					version = deck.getVersion();
 
-					Bundle data = new Bundle();
-					Message msg = Message.obtain();
-
 					// Check if the upgrade failed
 					if (false){//version < Deck.DECK_VERSION) {
 						data.putString("absPath", path);
 						data.putInt("msgtype", MSG_UPGRADE_FAILURE);
 						data.putInt("version", version);
 						data.putString("notes", Deck.upgradeNotesToMessages(deck, getResources()));
-						closeDeck(deck);
+						DeckManager.closeDeck(path, DeckManager.REQUESTING_ACTIVITY_DECKPICKER);
+						msg = Message.obtain();
 						msg.setData(data);
 						mHandler.sendMessage(msg);
 					} else {
+						try {
 						int[] counts = deck.getSched().allCounts();
 						int dueCards = counts[Scheduler.COUNTS_REV] + counts[Scheduler.COUNTS_LRN];
 						int totalCards = deck.cardCount();
@@ -1443,9 +1576,9 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
 						int eta = deck.getSched().eta() / 60;
 //						double modified = deck.getModified();
 
-						String upgradeNotes = Deck.upgradeNotesToMessages(deck, getResources());
-						
-						closeDeck(deck);
+							String upgradeNotes = Deck.upgradeNotesToMessages(deck, getResources());
+							
+							DeckManager.closeDeck(path, DeckManager.REQUESTING_ACTIVITY_DECKPICKER);
 
 						data.putString("absPath", path);
 						data.putInt("msgtype", MSG_UPGRADE_SUCCESS);
@@ -1501,7 +1634,6 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
 
     public void openPersonalDeckPicker() {
         if (AnkiDroidApp.isUserLoggedIn()) {
-            Intent i = getIntent();
             startActivityForResult(new Intent(this, PersonalDeckPicker.class), DOWNLOAD_PERSONAL_DECK);
             if (StudyOptions.getApiLevel() > 4) {
                 ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.RIGHT);
@@ -1542,45 +1674,24 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
 	}
 
 
-	public Deck getDeck(String filePath) {
-		Deck loadedDeck = AnkiDroidApp.deck();
-		if (loadedDeck != null && loadedDeck.getDeckPath().equals(filePath)) {
-			return loadedDeck;
-		} else {
-			Deck deck = null;
-			try {
-				deck = Deck.openDeck(filePath, false);
-			} catch (SQLException e) {
-				Log.w(AnkiDroidApp.TAG, "Could not open database " + filePath + ": " + e);
-				if (!mBrokenDecks.contains(filePath)) {
-					mBrokenDecks.add(filePath);
-				}
-			} catch (RuntimeException e) {
-				Log.w(AnkiDroidApp.TAG, "Could not open database " + filePath + ": " + e);
-				if (!mBrokenDecks.contains(filePath)) {
-					mBrokenDecks.add(filePath);
-				}
-			}
-			return deck;
-		}
-	}
-
-
-	public void closeDeck(Deck deck) {
-		Deck loadedDeck = AnkiDroidApp.deck();
-		if (!(loadedDeck != null && loadedDeck == deck)) {
-			deck.closeDeck(true);				
+	public void addBrokenDeck(String filePath) {
+		if (!mBrokenDecks.contains(filePath)) {
+			mBrokenDecks.add(filePath);
+			BackupManager.restoreDeckIfMissing(filePath);
 		}
+		DeckManager.closeDeck(filePath, DeckManager.REQUESTING_ACTIVITY_DECKPICKER);
 	}
 
 
 	private void removeDeck(String deckFilename) {
 		if (deckFilename != null) {
+			DeckManager.closeDeck(deckFilename);
 			File file = new File(deckFilename);
 			boolean deleted = BackupManager.removeDeck(file);
 			if (deleted) {
 				Log.i(AnkiDroidApp.TAG, "DeckPicker - " + deckFilename + " deleted");
 				mDeckIsSelected = false;
+				DeckManager.closeDeck(deckFilename);		
 				populateDeckList(mPrefDeckPath);
 			} else {
 				Log.e(AnkiDroidApp.TAG, "Error: Could not delete "
@@ -1591,8 +1702,7 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
 
 	private void waitForDeckLoaderThread() {
 		mDeckIsSelected = true;
-		Log.i(AnkiDroidApp.TAG,
-						"DeckPicker - waitForDeckLoaderThread(), mDeckIsSelected set to true");
+		Log.i(AnkiDroidApp.TAG, "DeckPicker - waitForDeckLoaderThread(), mDeckIsSelected set to true");
 		mLock.lock();
 		try {
 			while (!mIsFinished) {
@@ -1649,6 +1759,9 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
                     Log.e(AnkiDroidApp.TAG, "onPostExecute - Dialog dismiss Exception = " + e.getMessage());
                 }
             }
+            if (result == null) {
+            	return;
+            }
             if (result.getBoolean()) {
 		    	if (mStatisticType == Statistics.TYPE_DECK_SUMMARY) {
 		    		Statistics.showDeckSummary(DeckPicker.this);
@@ -1664,7 +1777,7 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
 
 		@Override
 		public void onPreExecute() {
-            mProgressDialog = ProgressDialog.show(DeckPicker.this, "", getResources()
+            mProgressDialog = StyledProgressDialog.show(DeckPicker.this, "", getResources()
                     .getString(R.string.calculating_statistics), true);
 		}
 
@@ -1675,11 +1788,39 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
     };
 
 
+    DeckTask.TaskListener mRepairDeckHandler = new DeckTask.TaskListener() {
+
+    	@Override
+        public void onPreExecute() {
+            mProgressDialog = StyledProgressDialog.show(DeckPicker.this, "", getResources()
+                    .getString(R.string.backup_repair_deck_progress), true);
+        }
+
+
+        @Override
+        public void onPostExecute(DeckTask.TaskData result) {
+        	if (result.getBoolean()) {
+        		populateDeckList(mPrefDeckPath);
+        	} else {
+        		Themes.showThemedToast(DeckPicker.this, getResources().getString(R.string.deck_repair_error), true);
+        	}
+        	if (mProgressDialog != null && mProgressDialog.isShowing()) {
+        		mProgressDialog.dismiss();
+        	}
+        }
+ 
+		@Override
+		public void onProgressUpdate(TaskData... values) {
+		}
+
+    };
+
+
     DeckTask.TaskListener mRestoreDeckHandler = new DeckTask.TaskListener() {
 
     	@Override
         public void onPreExecute() {
-            mProgressDialog = ProgressDialog.show(DeckPicker.this, "", getResources()
+            mProgressDialog = StyledProgressDialog.show(DeckPicker.this, "", getResources()
                     .getString(R.string.backup_restore_deck), true);
         }
 
@@ -1723,7 +1864,7 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
                     Log.e(AnkiDroidApp.TAG, "onPostExecute - Dialog dismiss Exception = " + e.getMessage());
                 }
             }
-            closeDeck(result.getDeck());
+			DeckManager.closeDeck(result.getDeck().getDeckPath(), DeckManager.REQUESTING_ACTIVITY_DECKPICKER);
     		StyledDialog dialog = (StyledDialog) onCreateDialog(DIALOG_OPTIMIZE_DATABASE);
     		dialog.setMessage(String.format(Utils.ENGLISH_LOCALE, getResources().getString(R.string.optimize_deck_message), Math.round(result.getLong() / 1024)));
     		dialog.show();
@@ -1731,7 +1872,7 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
 
 		@Override
 		public void onPreExecute() {
-            mProgressDialog = ProgressDialog.show(DeckPicker.this, "", getResources()
+            mProgressDialog = StyledProgressDialog.show(DeckPicker.this, "", getResources()
                     .getString(R.string.optimize_deck_dialog), true);
 		}
 
@@ -1748,8 +1889,6 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
 
 
     public class AlternatingAdapter extends SimpleAdapter {
-        private int[] colors;
-    	 
     	    public AlternatingAdapter(Context context, ArrayList<HashMap<String, String>> items, int resource, String[] from, int[] to) {
     	        super(context, items, resource, from, to);
     	    }
@@ -1866,6 +2005,14 @@ public class DeckPicker extends Activity implements Runnable, IButtonListener {
 	@Override
 	protected void onResume() {
 		super.onResume();
+		// workaround for hidden dialog when resuming
+		if (mSyncLogAlert != null && mSyncLogAlert.isShowing()) {
+			try {				
+				mSyncLogAlert.dismiss();
+				mSyncLogAlert.show();
+			} catch (Exception e) {
+			}
+		}
 	      if ((AnkiDroidApp.zeemoteController() != null) && (AnkiDroidApp.zeemoteController().isConnected())){
 	    	  Log.d("Zeemote","Adding listener in onResume");
 	    	  AnkiDroidApp.zeemoteController().addButtonListener(this);
diff --git a/src/com/ichi2/anki/DeckPreferences.java b/src/com/ichi2/anki/DeckPreferences.java
index cff8920da8..28ad391fe5 100644
--- a/src/com/ichi2/anki/DeckPreferences.java
+++ b/src/com/ichi2/anki/DeckPreferences.java
@@ -49,12 +49,12 @@ public class DeckPreferences extends PreferenceActivity implements OnSharedPrefe
 
         protected void cacheValues() {
             Log.i(AnkiDroidApp.TAG, "DeckPreferences - CacheValues");
-            mValues.put("newCardsPDay", String.valueOf(AnkiDroidApp.deck().getIntVar("newPerDay")));
-//            mValues.put("sessionQLimit", String.valueOf(AnkiDroidApp.deck().getSessionRepLimit()));
-//            mValues.put("sessionTLimit", String.valueOf(AnkiDroidApp.deck().getSessionTimeLimit() / 60));
-            mValues.put("newCardOrder", String.valueOf(AnkiDroidApp.deck().getIntVar("newOrder")));
-            mValues.put("newCardSpacing", String.valueOf(AnkiDroidApp.deck().getIntVar("newSpread")));
-            mValues.put("revCardOrder", String.valueOf(AnkiDroidApp.deck().getIntVar("revOrder")));
+            mValues.put("newCardsPDay", String.valueOf(DeckManager.getMainDeck().getNewCardsPerDay()));
+            mValues.put("sessionQLimit", String.valueOf(DeckManager.getMainDeck().getSessionRepLimit()));
+            mValues.put("sessionTLimit", String.valueOf(DeckManager.getMainDeck().getSessionTimeLimit() / 60));
+            mValues.put("newCardOrder", String.valueOf(DeckManager.getMainDeck().getNewCardOrder()));
+            mValues.put("newCardSpacing", String.valueOf(DeckManager.getMainDeck().getNewCardSpacing()));
+            mValues.put("revCardOrder", String.valueOf(DeckManager.getMainDeck().getRevCardOrder()));
         }
 
         public class Editor implements SharedPreferences.Editor {
@@ -79,17 +79,17 @@ public class DeckPreferences extends PreferenceActivity implements OnSharedPrefe
 
                 for (Entry<String, Object> entry : mUpdate.valueSet()) {
                     if (entry.getKey().equals("newCardsPDay")) {
-                        AnkiDroidApp.deck().setIntVar("newPerDay", Integer.parseInt(entry.getValue().toString()));
-//                    } else if (entry.getKey().equals("sessionQLimit")) {
-//                        AnkiDroidApp.deck().setSessionRepLimit(Long.parseLong(entry.getValue().toString()));
-//                    } else if (entry.getKey().equals("sessionTLimit")) {
-//                        AnkiDroidApp.deck().setSessionTimeLimit(60 * Long.parseLong(entry.getValue().toString()));
+                        DeckManager.getMainDeck().setNewCardsPerDay(Integer.parseInt(entry.getValue().toString()));
+                    } else if (entry.getKey().equals("sessionQLimit")) {
+                        DeckManager.getMainDeck().setSessionRepLimit(Long.parseLong(entry.getValue().toString()));
+                    } else if (entry.getKey().equals("sessionTLimit")) {
+                        DeckManager.getMainDeck().setSessionTimeLimit(60 * Long.parseLong(entry.getValue().toString()));
                     } else if (entry.getKey().equals("newCardOrder")) {
-                        AnkiDroidApp.deck().setIntVar("newOrder", Integer.parseInt(entry.getValue().toString()));
+                        DeckManager.getMainDeck().setNewCardOrder(Integer.parseInt(entry.getValue().toString()));
                     } else if (entry.getKey().equals("newCardSpacing")) {
-                        AnkiDroidApp.deck().setIntVar("newSpread", Integer.parseInt(entry.getValue().toString()));
+                        DeckManager.getMainDeck().setNewCardSpacing(Integer.parseInt(entry.getValue().toString()));
                     } else if (entry.getKey().equals("revCardOrder")) {
-                        AnkiDroidApp.deck().setIntVar("revOrder", Integer.parseInt(entry.getValue().toString()));
+                        DeckManager.getMainDeck().setRevCardOrder(Integer.parseInt(entry.getValue().toString()));
                     }
                 }
                 // make sure we refresh the parent cached values
@@ -149,7 +149,7 @@ public class DeckPreferences extends PreferenceActivity implements OnSharedPrefe
             }
 
 
-			@Override
+			// @Override  On Android 1.5 this is not Override
 			public android.content.SharedPreferences.Editor putStringSet(
 					String arg0, Set<String> arg1) {
 				// TODO Auto-generated method stub
@@ -226,7 +226,7 @@ public class DeckPreferences extends PreferenceActivity implements OnSharedPrefe
         }
 
 
-		@Override
+		// @Override  On Android 1.5 this is not Override
 		public Set<String> getStringSet(String arg0, Set<String> arg1) {
 			// TODO Auto-generated method stub
 			return null;
@@ -248,7 +248,7 @@ public class DeckPreferences extends PreferenceActivity implements OnSharedPrefe
     protected void onCreate(Bundle icicle) {
         super.onCreate(icicle);
 
-        if (AnkiDroidApp.deck() == null) {
+        if (DeckManager.getMainDeck() == null) {
             Log.i(AnkiDroidApp.TAG, "DeckPreferences - Selected Deck is NULL");
             finish();
         } else {
diff --git a/src/com/ichi2/anki/DeckTask.java b/src/com/ichi2/anki/DeckTask.java
index ff332ed773..8e6ca269f9 100644
--- a/src/com/ichi2/anki/DeckTask.java
+++ b/src/com/ichi2/anki/DeckTask.java
@@ -27,14 +27,12 @@ import java.util.HashMap;
 import java.util.LinkedHashMap;
 
 import com.ichi2.anki.DeckPicker.AnkiFilter;
+import com.ichi2.widget.AnkiDroidWidgetBig;
 import com.tomgibara.android.veecheck.util.PrefSettings;
 
 import android.content.Context;
 import android.content.res.Resources;
-import android.database.CursorIndexOutOfBoundsException;
-import android.database.SQLException;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteException;
+import android.database.sqlite.SQLiteDiskIOException;
 import android.os.AsyncTask;
 import android.util.Log;
 
@@ -59,11 +57,12 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
     public static final int TASK_TYPE_LOAD_STATISTICS = 13;
     public static final int TASK_TYPE_OPTIMIZE_DECK = 14;
     public static final int TASK_TYPE_SET_ALL_DECKS_JOURNAL_MODE = 15;
-    public static final int TASK_TYPE_CLOSE_DECK = 16;
-    public static final int TASK_TYPE_DELETE_BACKUPS = 17;
-    public static final int TASK_TYPE_RESTORE_DECK = 18;
-    public static final int TASK_TYPE_SORT_CARDS = 19;
-    public static final int TASK_TYPE_LOAD_TUTORIAL = 20;
+    public static final int TASK_TYPE_DELETE_BACKUPS = 16;
+    public static final int TASK_TYPE_RESTORE_DECK = 17;
+    public static final int TASK_TYPE_SORT_CARDS = 18;
+    public static final int TASK_TYPE_LOAD_TUTORIAL = 19;
+    public static final int TASK_TYPE_REPAIR_DECK = 20;
+    public static final int TASK_TYPE_CLOSE_DECK = 21;
 
 
     /**
@@ -79,8 +78,6 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
 
     private int mType;
     private TaskListener mListener;
-
-
     
     public static DeckTask launchDeckTask(int type, TaskListener listener, TaskData... params) {
         sOldInstance = sInstance;
@@ -89,7 +86,8 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
         sInstance.mListener = listener;
         sInstance.mType = type;
 
-        return (DeckTask) sInstance.execute(params);
+        sInstance.execute(params);
+        return sInstance;
     }
 
 
@@ -99,6 +97,7 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
     public static void waitToFinish() {
         try {
             if ((sInstance != null) && (sInstance.getStatus() != AsyncTask.Status.FINISHED)) {
+		Log.i(AnkiDroidApp.TAG, "DeckTask: wait to finish");
                 sInstance.get();
             }
         } catch (Exception e) {
@@ -107,6 +106,17 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
     }
 
 
+    public static void cancelTask() {
+        try {
+            if ((sInstance != null) && (sInstance.getStatus() != AsyncTask.Status.FINISHED)) {
+                sInstance.cancel(true);
+            }
+        } catch (Exception e) {
+            return;
+        }
+    }
+
+
     public static boolean taskIsRunning() {
         try {
             if ((sInstance != null) && (sInstance.getStatus() != AsyncTask.Status.FINISHED)) {
@@ -124,6 +134,7 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
         // Wait for previous thread (if any) to finish before continuing
         try {
             if ((sOldInstance != null) && (sOldInstance.getStatus() != AsyncTask.Status.FINISHED)) {
+            	Log.i(AnkiDroidApp.TAG, "Waiting for " + sOldInstance.mType + " to finish");
                 sOldInstance.get();
             }
         } catch (Exception e) {
@@ -185,11 +196,8 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
             case TASK_TYPE_SET_ALL_DECKS_JOURNAL_MODE:
                 return doInBackgroundSetJournalMode(params);
                 
-            case TASK_TYPE_CLOSE_DECK:
-                return doInBackgroundCloseDeck(params);
-                
             case TASK_TYPE_DELETE_BACKUPS:
-                return doInBackgroundDeleteBackups(params);
+                return doInBackgroundDeleteBackups();
                 
             case TASK_TYPE_RESTORE_DECK:
                 return doInBackgroundRestoreDeck(params);
@@ -200,6 +208,12 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
             case TASK_TYPE_LOAD_TUTORIAL:
                 return doInBackgroundLoadTutorial(params);
 
+            case TASK_TYPE_REPAIR_DECK:
+                return doInBackgroundRepairDeck(params);
+
+            case TASK_TYPE_CLOSE_DECK:
+                return doInBackgroundCloseDeck(params);
+            	
             default:
                 return null;
         }
@@ -233,7 +247,7 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
         AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
         ankiDB.getDatabase().beginTransaction();
         try {
-        	publishProgress(new TaskData(deck.addFact(editFact, cardModels, false) != null));
+        	publishProgress(new TaskData(deck.addFact(editFact, cardModels, false)));
             ankiDB.getDatabase().setTransactionSuccessful();
         } finally {
             ankiDB.getDatabase().endTransaction();
@@ -249,30 +263,43 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
         Fact editFact = editCard.getFact();
         int showQuestion = params[0].getInt();
 
-        // Start undo routine
-        String undoName = Deck.UNDO_TYPE_EDIT_CARD;
-        deck.setUndoStart(undoName, editCard.getId());
-
-        // Set modified also updates the text of cards and their modified flags
-        editFact.setModified(true, deck, false);
-        editFact.toDb();
-
-        deck.flushMod();
-
-        // Find all cards based on this fact and update them with the updateCard method.
-        // for (Card modifyCard : editFact.getUpdatedRelatedCards()) {
-        //     modifyCard.updateQAfields();
-        // }
-
-        // deck.reset();
-        deck.setUndoEnd(undoName);
-        if (showQuestion == Reviewer.UPDATE_CARD_NEW_CARD) {
-            publishProgress(new TaskData(showQuestion, null, deck.getCard()));
-        } else {
-            publishProgress(new TaskData(showQuestion, null, deck.cardFromId(editCard.getId())));        	
-        }
-
-        return null;
+        try {
+	        AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
+	        ankiDB.getDatabase().beginTransaction();
+	        try {
+	            // Start undo routine
+	            String undoName = Deck.UNDO_TYPE_EDIT_CARD;
+	            deck.setUndoStart(undoName, editCard.getId());
+
+	            // Set modified also updates the text of cards and their modified flags
+	            editFact.setModified(true, deck, false);
+	            editFact.toDb();
+
+	            deck.flushMod();
+
+	            // Find all cards based on this fact and update them with the updateCard method.
+	            // for (Card modifyCard : editFact.getUpdatedRelatedCards()) {
+	            //     modifyCard.updateQAfields();
+	            // }
+
+	            // deck.reset();
+	            deck.setUndoEnd(undoName);
+	            if (showQuestion == Reviewer.UPDATE_CARD_NEW_CARD) {
+	                publishProgress(new TaskData(showQuestion, null, deck.getCard()));
+	            } else {
+	                publishProgress(new TaskData(showQuestion, null, deck.cardFromId(editCard.getId())));        	
+	            }
+
+	        	ankiDB.getDatabase().setTransactionSuccessful();
+	        } finally {
+	            ankiDB.getDatabase().endTransaction();
+	        }
+		} catch (RuntimeException e) {
+			Log.e(AnkiDroidApp.TAG, "doInBackgroundUpdateFact - RuntimeException on updating fact: " + e);
+			AnkiDroidApp.saveExceptionReportFile(e, "doInBackgroundUpdateFact");
+			return new TaskData(false);
+		}
+        return new TaskData(true);
     }
 
 
@@ -280,39 +307,51 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
         Deck deck = params[0].getDeck();
         Card oldCard = params[0].getCard();
         int ease = params[0].getInt();
-        Card newCard;
-
-        AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
-        ankiDB.getDatabase().beginTransaction();
+        Card newCard = null;
         try {
-            if (oldCard != null) {
-                deck.getSched().answerCard(oldCard, ease);
-            }
-            newCard = deck.getSched().getCard();
-            if (oldCard != null) {
-                publishProgress(new TaskData(newCard, oldCard.getLeechFlag(), oldCard.getSuspendedFlag()));
-            } else {
-                publishProgress(new TaskData(newCard));
-            }
-
-            ankiDB.getDatabase().setTransactionSuccessful();
-        } finally {
-            ankiDB.getDatabase().endTransaction();
-        }
-
-        return null;
+	        AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
+	        ankiDB.getDatabase().beginTransaction();
+	        try {
+	            if (oldCard != null) {
+	                deck.answerCard(oldCard, ease);
+	                Log.i(AnkiDroidApp.TAG, "leech flag: " + oldCard.getLeechFlag());
+	            } else if (DeckManager.deckIsOpenedInBigWidget(deck.getDeckPath())) {
+	                // first card in reviewer is retrieved
+	            	Log.i(AnkiDroidApp.TAG, "doInBackgroundAnswerCard: get card from big widget");
+                	newCard = AnkiDroidWidgetBig.getCard();
+	            }
+	            if (newCard == null) {
+		            newCard = deck.getCard();	            	
+	            }
+	            if (oldCard != null) {
+	                publishProgress(new TaskData(newCard, oldCard.getLeechFlag(), oldCard.getSuspendedFlag()));
+	            } else {
+	                publishProgress(new TaskData(newCard));
+	            }
+	            ankiDB.getDatabase().setTransactionSuccessful();
+	        } finally {
+	            ankiDB.getDatabase().endTransaction();
+	        }
+		} catch (RuntimeException e) {
+			Log.e(AnkiDroidApp.TAG, "doInBackgroundAnswerCard - RuntimeException on answering card: " + e);
+			AnkiDroidApp.saveExceptionReportFile(e, "doInBackgroundAnswerCard");
+			return new TaskData(false);
+		}
+        return new TaskData(true);
     }
 
 
     private TaskData doInBackgroundLoadDeck(TaskData... params) {
         String deckFilename = params[0].getString();
-        Deck oldDeck = params[0].getDeck();
+        int requestingActivity = params[0].getInt();
+
+        Log.i(AnkiDroidApp.TAG, "doInBackgroundLoadDeck - deckFilename = " + deckFilename + ", requesting activity = " + requestingActivity);
 
         Resources res = AnkiDroidApp.getInstance().getBaseContext().getResources();
-        if (oldDeck != null) {
-        	publishProgress(new TaskData(res.getString(R.string.close_previous_deck)));
-        	oldDeck.closeDeck(false);
-        }
+
+        publishProgress(new TaskData(AnkiDroidApp.getInstance().getBaseContext().getResources().getString(R.string.finish_operation)));
+        DeckManager.waitForDeckClosingThread(deckFilename);
+
         int backupResult = BackupManager.RETURN_NULL;
         if (PrefSettings.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).getBoolean("useBackup", true)) {
         	publishProgress(new TaskData(res.getString(R.string.backup_deck)));
@@ -321,33 +360,23 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
         if (BackupManager.getFreeDiscSpace(deckFilename) < (StudyOptions.MIN_FREE_SPACE * 1024 * 1024)) {
         	backupResult = BackupManager.RETURN_LOW_SYSTEM_SPACE;
         }
-        Log.i(AnkiDroidApp.TAG, "doInBackgroundLoadDeck - deckFilename = " + deckFilename);
 
         Log.i(AnkiDroidApp.TAG, "loadDeck - SD card mounted and existent file -> Loading deck...");
-        try {
-            // Open the right deck.
-            Deck deck = Deck.openDeck(deckFilename);
-            // Start by getting the first card and displaying it.
-            // Card card = deck.getCard();
-            Log.i(AnkiDroidApp.TAG, "Deck loaded!");
-            if (deck == null) {
-                BackupManager.cleanUpAfterBackupCreation(false);
-                return new TaskData(DECK_NOT_LOADED);
-            }
-            BackupManager.cleanUpAfterBackupCreation(true);
-            publishProgress(new TaskData(backupResult));
-            return new TaskData(DECK_LOADED, deck, null);
-		} catch (SQLException e) {
-            Log.i(AnkiDroidApp.TAG, "The database " + deckFilename + " could not be opened = " + e.getMessage());
-            return new TaskData(DECK_NOT_LOADED);
-        } catch (CursorIndexOutOfBoundsException e) {
-            // XXX: Where is this exception thrown?
-            Log.i(AnkiDroidApp.TAG, "The deck has no cards = " + e.getMessage());
-            return new TaskData(DECK_EMPTY);
-		} catch (RuntimeException e) {
-            Log.i(AnkiDroidApp.TAG, "The database " + deckFilename + " could not be opened = " + e.getMessage());
-            return new TaskData(DECK_NOT_LOADED);
+
+    	// load deck and set it as main deck
+    	publishProgress(new TaskData(res.getString(R.string.loading_deck)));
+        Deck deck = DeckManager.getDeck(deckFilename, requestingActivity == DeckManager.REQUESTING_ACTIVITY_STUDYOPTIONS, requestingActivity);
+        if (deck == null) {
+            Log.i(AnkiDroidApp.TAG, "The database " + deckFilename + " could not be opened");
+            BackupManager.cleanUpAfterBackupCreation(false);
+            return new TaskData(DECK_NOT_LOADED, deckFilename);            	
+        }
+        BackupManager.cleanUpAfterBackupCreation(true);
+        if (deck.hasFinishScheduler()) {
+        	deck.finishScheduler();
         }
+        publishProgress(new TaskData(backupResult));
+        return new TaskData(DECK_LOADED, deck, null);
     }
 
 
@@ -355,103 +384,124 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
     	Deck deck = params[0].getDeck();
         Log.i(AnkiDroidApp.TAG, "doInBackgroundSaveAndResetDeck");
         if (deck != null) {
-            deck.commitToDB();
-//            deck.updateCutoff();
-//            if (AnkiDroidApp.deck().hasFinishScheduler()) {
-//                AnkiDroidApp.deck().finishScheduler();
-//            }
-            deck.reset();
+            try {
+            	deck.commitToDB();
+            	deck.updateCutoff();
+            	if (deck.hasFinishScheduler()) {
+            		deck.finishScheduler();
+            	}
+            	deck.reset();
+            } catch (SQLiteDiskIOException e) {
+            	Log.e(AnkiDroidApp.TAG, "Error on saving deck in background: " + e);
+            }
         }
         return null;
     }
 
 
     private TaskData doInBackgroundSuspendCard(TaskData... params) {
-//        Deck deck = params[0].getDeck();
-//        Card oldCard = params[0].getCard();
-//        Card newCard = null;
-//
-//        AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
-//        ankiDB.getDatabase().beginTransaction();
-//        try {
-//            if (oldCard != null) {
-//                String undoName = Deck.UNDO_TYPE_SUSPEND_CARD;
-//                deck.setUndoStart(undoName, oldCard.getId());
-//                if (oldCard.getSuspendedState()) {
-//                    oldCard.unsuspend();
-//                    newCard = oldCard;
-//                } else {
-//                    oldCard.suspend();
-//                    newCard = deck.getCard();
-//                }
-//                deck.setUndoEnd(undoName);
-//            }
-//            
-//            publishProgress(new TaskData(newCard));
-//            ankiDB.getDatabase().setTransactionSuccessful();
-//        } finally {
-//            ankiDB.getDatabase().endTransaction();
-//        }
+        Deck deck = params[0].getDeck();
+        Card oldCard = params[0].getCard();
+        Card newCard = null;
 
-        return null;
+        try {
+            AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
+            ankiDB.getDatabase().beginTransaction();
+            try {
+                if (oldCard != null) {
+                    String undoName = Deck.UNDO_TYPE_SUSPEND_CARD;
+                    deck.setUndoStart(undoName, oldCard.getId());
+                    if (oldCard.getSuspendedState()) {
+                        oldCard.unsuspend();
+                        newCard = oldCard;
+                    } else {
+                        oldCard.suspend();
+                        newCard = deck.getCard();
+                    }
+                    deck.setUndoEnd(undoName);
+                }
+                
+                publishProgress(new TaskData(newCard));
+                ankiDB.getDatabase().setTransactionSuccessful();
+            } finally {
+                ankiDB.getDatabase().endTransaction();
+            }
+    	} catch (RuntimeException e) {
+    		Log.e(AnkiDroidApp.TAG, "doInBackgroundSuspendCard - RuntimeException on suspending card: " + e);
+			AnkiDroidApp.saveExceptionReportFile(e, "doInBackgroundSuspendCard");
+    		return new TaskData(false);
+    	}
+        return new TaskData(true);
     }
+        	
 
 
     private TaskData doInBackgroundMarkCard(TaskData... params) {
-//        Deck deck = params[0].getDeck();
-//        Card currentCard = params[0].getCard();
-//
-//        AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
-//        ankiDB.getDatabase().beginTransaction();
-//        try {
-//            if (currentCard != null) {
-//                String undoName = Deck.UNDO_TYPE_MARK_CARD;
-//                deck.setUndoStart(undoName, currentCard.getId());
-//            	if (currentCard.isMarked()) {
-//                    deck.deleteTag(currentCard.getFactId(), Deck.TAG_MARKED);
-//                } else {
-//                    deck.addTag(currentCard.getFactId(), Deck.TAG_MARKED);
-//                }
-//            	deck.resetMarkedTagId();
-//            	deck.setUndoEnd(undoName);
-//            }
-//
-//            publishProgress(new TaskData(currentCard));
-//            ankiDB.getDatabase().setTransactionSuccessful();
-//        } finally {
-//            ankiDB.getDatabase().endTransaction();
-//        }
+        Deck deck = params[0].getDeck();
+        Card currentCard = params[0].getCard();
 
-        return null;
+        try {
+            AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
+            ankiDB.getDatabase().beginTransaction();
+            try {
+                if (currentCard != null) {
+                    String undoName = Deck.UNDO_TYPE_MARK_CARD;
+                    deck.setUndoStart(undoName, currentCard.getId());
+                	if (currentCard.isMarked()) {
+                        deck.deleteTag(currentCard.getFactId(), Deck.TAG_MARKED);
+                    } else {
+                        deck.addTag(currentCard.getFactId(), Deck.TAG_MARKED);
+                    }
+                	deck.resetMarkedTagId();
+                	deck.setUndoEnd(undoName);
+                }
+
+                publishProgress(new TaskData(currentCard));
+                ankiDB.getDatabase().setTransactionSuccessful();
+            } finally {
+                ankiDB.getDatabase().endTransaction();
+            }
+    	} catch (RuntimeException e) {
+    		Log.e(AnkiDroidApp.TAG, "doInBackgroundMarkCard - RuntimeException on marking card: " + e);
+			AnkiDroidApp.saveExceptionReportFile(e, "doInBackgroundMarkCard");
+    		return new TaskData(false);
+        }
+		return new TaskData(true);
     }
 
+
     private TaskData doInBackgroundUndo(TaskData... params) {
         Deck deck = params[0].getDeck();
         Card newCard;
         long currentCardId = params[0].getLong();
         boolean inReview = params[0].getBoolean();
         long oldCardId = 0;
-        String undoType;
-
-        AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
-        ankiDB.getDatabase().beginTransaction();
+        String undoType = null;
+        
         try {
-        	oldCardId = deck.undo(currentCardId, inReview);
-        	undoType = deck.getUndoType();
-        	if (undoType == Deck.UNDO_TYPE_SUSPEND_CARD) {
-        		oldCardId = currentCardId;
-        	}
-            newCard = deck.getCard();
-            if (oldCardId != 0 && newCard != null && oldCardId != newCard.getId()) {
-            	newCard = deck.cardFromId(oldCardId);
+            AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
+            ankiDB.getDatabase().beginTransaction();
+            try {
+            	oldCardId = deck.undo(currentCardId, inReview);
+            	undoType = deck.getUndoType();
+            	if (undoType == Deck.UNDO_TYPE_SUSPEND_CARD) {
+            		oldCardId = currentCardId;
+            	}
+                newCard = deck.getCard();
+                if (oldCardId != 0 && newCard != null && oldCardId != newCard.getId()) {
+                	newCard = deck.cardFromId(oldCardId);
+                }
+                publishProgress(new TaskData(newCard));
+                ankiDB.getDatabase().setTransactionSuccessful();
+            } finally {
+                ankiDB.getDatabase().endTransaction();
             }
-            publishProgress(new TaskData(newCard));
-            ankiDB.getDatabase().setTransactionSuccessful();
-        } finally {
-            ankiDB.getDatabase().endTransaction();
+    	} catch (RuntimeException e) {
+    		Log.e(AnkiDroidApp.TAG, "doInBackgroundUndo - RuntimeException on undoing: " + e);
+			AnkiDroidApp.saveExceptionReportFile(e, "doInBackgroundUndo");
+            return new TaskData(undoType, oldCardId, false);
         }
-
-        return new TaskData(undoType, oldCardId);
+        return new TaskData(undoType, oldCardId, true);
     }
 
 
@@ -461,25 +511,32 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
         long currentCardId = params[0].getLong();
         boolean inReview = params[0].getBoolean();
         long oldCardId = 0;
+        String undoType = null;
 
-        AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
-        ankiDB.getDatabase().beginTransaction();
         try {
-        	oldCardId = deck.redo(currentCardId, inReview);
-            newCard = deck.getCard();
-            if (oldCardId != 0 && newCard != null && oldCardId != newCard.getId()) {
-            	newCard = deck.cardFromId(oldCardId);
+            AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
+            ankiDB.getDatabase().beginTransaction();
+            try {
+            	oldCardId = deck.redo(currentCardId, inReview);
+                newCard = deck.getCard();
+                if (oldCardId != 0 && newCard != null && oldCardId != newCard.getId()) {
+                	newCard = deck.cardFromId(oldCardId);
+                }
+                publishProgress(new TaskData(newCard));
+                ankiDB.getDatabase().setTransactionSuccessful();
+            } finally {
+                ankiDB.getDatabase().endTransaction();
             }
-            publishProgress(new TaskData(newCard));
-            ankiDB.getDatabase().setTransactionSuccessful();
-        } finally {
-            ankiDB.getDatabase().endTransaction();
-        }
-        String undoType = deck.getUndoType();
-        if (undoType == Deck.UNDO_TYPE_SUSPEND_CARD) {
-        	undoType = "redo suspend";
+            undoType = deck.getUndoType();
+            if (undoType == Deck.UNDO_TYPE_SUSPEND_CARD) {
+            	undoType = "redo suspend";
+            }
+    	} catch (RuntimeException e) {
+    		Log.e(AnkiDroidApp.TAG, "doInBackgroundRedo - RuntimeException on redoing: " + e);
+			AnkiDroidApp.saveExceptionReportFile(e, "doInBackgroundRedo");
+            return new TaskData(undoType, oldCardId, false);
         }
-        return new TaskData(undoType, oldCardId);
+        return new TaskData(undoType, oldCardId, true);
     }
 
 
@@ -488,39 +545,45 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
         int chunk = params[0].getInt();
     	Log.i(AnkiDroidApp.TAG, "doInBackgroundLoadCards");
     	String startId = "";
-    	while (true) {
+    	while (!this.isCancelled()) {
     		ArrayList<HashMap<String, String>> cards = deck.getCards(chunk, startId);
     		if (cards.size() == 0) {
-    			return null;	
+    			break;
     		} else {
                	publishProgress(new TaskData(cards));
                	startId = cards.get(cards.size() - 1).get("id");    			
     		}
     	}
+    	return null;
     }
 
 
     private TaskData doInBackgroundDeleteCard(TaskData... params) {
-//        Deck deck = params[0].getDeck();
-//        Card card = params[0].getCard();
-//        Card newCard = null;
-//        Long id = 0l;
-//        Log.i(AnkiDroidApp.TAG, "doInBackgroundDeleteCard");
-//
-//        AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
-//        ankiDB.getDatabase().beginTransaction();
-//        try {
-//            id = card.getId();
-//            card.delete();
-//            deck.reset();
-//            newCard = deck.getCard();
-//            publishProgress(new TaskData(newCard));
-//            ankiDB.getDatabase().setTransactionSuccessful();
-//        } finally {
-//            ankiDB.getDatabase().endTransaction();
-//        }
-//        return new TaskData(String.valueOf(id));
-    	return null;
+        Deck deck = params[0].getDeck();
+        Card card = params[0].getCard();
+        Card newCard = null;
+        Long id = 0l;
+        Log.i(AnkiDroidApp.TAG, "doInBackgroundDeleteCard");
+
+        try {
+            AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
+            ankiDB.getDatabase().beginTransaction();
+            try {
+                id = card.getId();
+                card.delete();
+                deck.reset();
+                newCard = deck.getCard();
+                publishProgress(new TaskData(newCard));
+                ankiDB.getDatabase().setTransactionSuccessful();
+            } finally {
+                ankiDB.getDatabase().endTransaction();
+            }
+    	} catch (RuntimeException e) {
+    		Log.e(AnkiDroidApp.TAG, "doInBackgroundDeleteCard - RuntimeException on deleting card: " + e);
+			AnkiDroidApp.saveExceptionReportFile(e, "doInBackgroundDeleteCard");
+            return new TaskData(String.valueOf(id), 0, false);
+    	}
+        return new TaskData(String.valueOf(id), 0, true);
     }
 
 
@@ -529,21 +592,27 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
 //        Card card = params[0].getCard();
 //        Card newCard = null;
         Long id = 0l;
-//        Log.i(AnkiDroidApp.TAG, "doInBackgroundBuryCard");
-//
-//        AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
-//        ankiDB.getDatabase().beginTransaction();
-//        try {
-//            id = card.getId();
-//            deck.buryFact(card.getFactId(), id);
-//            deck.reset();
-//            newCard = deck.getCard();
-//            publishProgress(new TaskData(newCard));
-//            ankiDB.getDatabase().setTransactionSuccessful();
-//        } finally {
-//            ankiDB.getDatabase().endTransaction();
-//        }
-        return new TaskData(String.valueOf(id));
+        Log.i(AnkiDroidApp.TAG, "doInBackgroundBuryCard");
+
+        try {
+            AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
+            ankiDB.getDatabase().beginTransaction();
+            try {
+                id = card.getId();
+                deck.buryFact(card.getFactId(), id);
+                deck.reset();
+                newCard = deck.getCard();
+                publishProgress(new TaskData(newCard));
+                ankiDB.getDatabase().setTransactionSuccessful();
+            } finally {
+                ankiDB.getDatabase().endTransaction();
+            }
+    	} catch (RuntimeException e) {
+    		Log.e(AnkiDroidApp.TAG, "doInBackgroundSuspendCard - RuntimeException on suspending card: " + e);
+			AnkiDroidApp.saveExceptionReportFile(e, "doInBackgroundBuryCard");
+            return new TaskData(String.valueOf(id), 0, false);
+    	}
+        return new TaskData(String.valueOf(id), 0, true);
     }
 
 
@@ -556,8 +625,10 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
         boolean result = false;
 
         Resources res = context.getResources();
-        if (deckList.length == 1 && deckList[0].equals("") && AnkiDroidApp.deck() != null) {
-        	result = Statistics.refreshDeckStatistics(context, AnkiDroidApp.deck(), type, Integer.parseInt(res.getStringArray(R.array.statistics_period_values)[period]), res.getStringArray(R.array.statistics_type_labels)[type]);        	
+        if (deckList.length == 1) {
+        	if (deckList[0].length() == 0) {
+            	result = Statistics.refreshDeckStatistics(context, DeckManager.getMainDeck(DeckManager.REQUESTING_ACTIVITY_STUDYOPTIONS), type, Integer.parseInt(res.getStringArray(R.array.statistics_period_values)[period]), res.getStringArray(R.array.statistics_type_labels)[type]);        		
+        	}
         } else {
         	result = Statistics.refreshAllDeckStatistics(context, deckList, type, Integer.parseInt(res.getStringArray(R.array.statistics_period_values)[period]), res.getStringArray(R.array.statistics_type_labels)[type] + " " + res.getString(R.string.statistics_all_decks));        	
         }
@@ -575,13 +646,25 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
     }
 
 
+    private TaskData doInBackgroundRepairDeck(TaskData... params) {
+    	Log.i(AnkiDroidApp.TAG, "doInBackgroundRepairDeck");
+    	String deckPath = params[0].getString();
+    	DeckManager.closeDeck(deckPath, false);
+    	return new TaskData(BackupManager.repairDeck(deckPath));
+    }
+
+
+    private TaskData doInBackgroundCloseDeck(TaskData... params) {
+    	Log.i(AnkiDroidApp.TAG, "doInBackgroundCloseDeck");
+    	String deckPath = params[0].getString();
+    	DeckManager.closeDeck(deckPath, false);
+    	return null;
+    }
+
+
     private TaskData doInBackgroundSetJournalMode(TaskData... params) {
         Log.i(AnkiDroidApp.TAG, "doInBackgroundSetJournalMode");
         String path = params[0].getString();
-        Deck currentDeck = params[0].getDeck();
-        if (currentDeck != null) {
-        	currentDeck.closeDeck(false);
-        }
 
         int len = 0;
 		File[] fileList;
@@ -598,35 +681,17 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
 		if (len > 0 && fileList != null) {
 			Log.i(AnkiDroidApp.TAG, "Set journal mode: number of anki files = " + len);
 			for (File file : fileList) {
-				// on deck open, journal mode will be automatically set
+				// on deck open, journal mode will be automatically set, set requesting activity to syncclient to force delete journal mode
 				String filePath = file.getAbsolutePath();
-				Deck deck = Deck.openDeck(filePath, false);
-				if (deck != null) {
-					Log.i(AnkiDroidApp.TAG, "Journal mode of file " + filePath + " set");
-					deck.closeDeck(false);					
-				}
+				DeckManager.getDeck(filePath, DeckManager.REQUESTING_ACTIVITY_SYNCCLIENT);
+				DeckManager.closeDeck(filePath, false);
 			}
 		}
         return null;
     }
 
     
-    private TaskData doInBackgroundCloseDeck(TaskData... params) {
-        Log.i(AnkiDroidApp.TAG, "doInBackgroundCloseDeck");
-    	Deck deck = params[0].getDeck();
-    	boolean wait = params[0].getBoolean();
-    	if (deck != null) {
-    		try {
-    			deck.closeDeck(wait);
-    		} catch (SQLiteException e) {
-    			Log.e(AnkiDroidApp.TAG, "Error on closing deck: " + e);
-    		}
-    	}
-    	return null;
-    }
-
-
-    private TaskData doInBackgroundDeleteBackups(TaskData... params) {
+    private TaskData doInBackgroundDeleteBackups() {
         Log.i(AnkiDroidApp.TAG, "doInBackgroundDeleteBackups");
     	return new TaskData(BackupManager.deleteAllBackups());
     }
@@ -641,7 +706,8 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
 
     private TaskData doInBackgroundSortCards(TaskData... params) {
         Log.i(AnkiDroidApp.TAG, "doInBackgroundSortCards");
-		Collections.sort(params[0].getCards(), params[0].getComparator());
+        Comparator<? super HashMap<String, String>> comparator = params[0].getComparator();
+		Collections.sort(params[0].getCards(), comparator);
 		return null;
     }
 
@@ -653,7 +719,14 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
     	publishProgress(new TaskData(res.getString(R.string.tutorial_load)));
     	AnkiDb ankiDB = null;
     	try{
-    		// Copy the empty deck from the assets to the SD card.
+    		// close open deck
+    		DeckManager.closeMainDeck(false);
+
+    		// delete any existing tutorial file
+            if (!sampleDeckFile.exists()) {
+            	sampleDeckFile.delete();
+            }
+    		// copy the empty deck from the assets to the SD card.
     		InputStream stream = res.getAssets().open(DeckCreator.EMPTY_DECK_NAME);
     		Utils.writeToFile(stream, sampleDeckFile.getAbsolutePath());
     		stream.close();
@@ -662,13 +735,13 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
     		String[] answers = res.getStringArray(R.array.tutorial_answers);
     		String[] sampleQuestions = res.getStringArray(R.array.tutorial_capitals_questions);
     		String[] sampleAnswers = res.getStringArray(R.array.tutorial_capitals_answers);
-    		Deck deck = Deck.openDeck(sampleDeckFile.getAbsolutePath(), false);
+    		Deck deck = DeckManager.getDeck(sampleDeckFile.getAbsolutePath(), DeckManager.REQUESTING_ACTIVITY_STUDYOPTIONS, true);
             ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
             ankiDB.getDatabase().beginTransaction();
             try {
             	CardModel cardModel = null;
             	int len = Math.min(questions.length, answers.length);
-            	for (int i = 0; i < len - 1 + Math.min(sampleQuestions.length, sampleAnswers.length); i++) {
+            	for (int i = 0; i < len + Math.min(sampleQuestions.length, sampleAnswers.length); i++) {
             		Fact fact = deck.newFact();
             		if (cardModel == null) {
             			cardModel = deck.activeCardModels(fact).entrySet().iterator().next().getValue();
@@ -676,9 +749,9 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
             		int fidx = 0;
             		for (Fact.Field f : fact.getFields()) {
             			if (fidx == 0) {
-            				f.setValue((i < len - 1) ? questions[i] : sampleQuestions[i - len + 1]);
+            				f.setValue((i < len) ? questions[i] : sampleQuestions[i - len]);
             			} else if (fidx == 1) {
-            				f.setValue((i < len - 1) ? answers[i] : sampleAnswers[i - len + 1]);
+            				f.setValue((i < len) ? answers[i] : sampleAnswers[i - len]);
             			}
             			fidx++;
             		}
@@ -690,19 +763,20 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
             	deck.setSessionTimeLimit(0);
             	deck.flushMod();
             	deck.reset();
-            	AnkiDroidApp.setDeck(deck);
             	ankiDB.getDatabase().setTransactionSuccessful();
-            	return new TaskData(DECK_LOADED, deck, null);
             } finally {
         		ankiDB.getDatabase().endTransaction();
         	}
+        	return new TaskData(DECK_LOADED, deck, null);
         } catch (IOException e) {
         	Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
         	Log.e(AnkiDroidApp.TAG, "Empty deck could not be copied to the sd card.");
+        	DeckManager.closeMainDeck(false);
         	sampleDeckFile.delete();
         	return new TaskData(TUTORIAL_NOT_CREATED);
     	} catch (RuntimeException e) {
         	Log.e(AnkiDroidApp.TAG, "Error on creating tutorial deck: " + e);
+        	DeckManager.closeMainDeck(false);
         	sampleDeckFile.delete();
         	return new TaskData(TUTORIAL_NOT_CREATED);
     	}
@@ -735,6 +809,7 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
         private String[] mDeckList;
         private LinkedHashMap<Long, CardModel> mCardModels;
         private Comparator<? super HashMap<String, String>> mComparator;
+        private int[] mIntList;
 
 
         public TaskData(int value, Deck deck, Card card) {
@@ -825,9 +900,21 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
         }
 
 
-        public TaskData(String msg, long cardId) {
+        public TaskData(int value, String msg) {
+            mMsg = msg;
+            mInteger = value;
+        }
+
+
+        public TaskData(String msg, long cardId, boolean bool) {
             mMsg = msg;
             mLong = cardId;
+            mBool = bool;
+        }
+
+
+        public TaskData(int[] intlist) {
+            mIntList = intlist;
         }
 
 
@@ -904,6 +991,11 @@ public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, De
         public String[] getDeckList() {
             return mDeckList;
         }
+
+
+        public int[] getIntList() {
+            return mIntList;
+        }
     }
 
 }
diff --git a/src/com/ichi2/anki/Feedback.java b/src/com/ichi2/anki/Feedback.java
index 4a42a23dfe..fe9cf5708a 100644
--- a/src/com/ichi2/anki/Feedback.java
+++ b/src/com/ichi2/anki/Feedback.java
@@ -22,18 +22,19 @@ import android.content.SharedPreferences;
 import android.content.res.Resources;
 import android.os.Bundle;
 import android.util.Log;
+import android.view.KeyEvent;
 import android.view.View;
 import android.view.View.OnClickListener;
-import android.view.inputmethod.InputMethodManager;
 import android.view.WindowManager;
+import android.view.inputmethod.InputMethodManager;
 import android.widget.Button;
 import android.widget.EditText;
 import android.widget.LinearLayout;
 import android.widget.ListView;
 import android.widget.ProgressBar;
 import android.widget.SimpleAdapter;
-import android.widget.Toast;
 
+import com.ichi2.anim.ActivityTransitionAnimation;
 import com.ichi2.async.Connection;
 import com.ichi2.async.Connection.Payload;
 import com.ichi2.themes.StyledDialog;
@@ -63,9 +64,9 @@ import java.util.TimeZone;
 import java.util.UUID;
 
 public class Feedback extends Activity {
-    protected static String REPORT_ASK = "2";
-    protected static String REPORT_NEVER = "1";
-    protected static String REPORT_ALWAYS = "0";
+    public static String REPORT_ASK = "2";
+    public static String REPORT_NEVER = "1";
+    public static String REPORT_ALWAYS = "0";
 
     public static String STATE_WAITING = "0";
     public static String STATE_UPLOADING = "1";
@@ -98,13 +99,17 @@ public class Feedback extends Activity {
 
     private boolean mErrorsSent = false;
 
+
     @Override
-    public void onBackPressed() {
-        deleteFiles(true, false);
-        setResult(RESULT_OK);
-        finish();
+    public boolean onKeyDown(int keyCode, KeyEvent event)  {
+        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
+        	deleteFiles(true, false);
+	        closeFeedback();
+        }
+        return super.onKeyDown(keyCode, event);
     }
 
+
     /**
      * Create AlertDialogs used on all the activity
      */
@@ -126,6 +131,16 @@ public class Feedback extends Activity {
         mNoConnectionAlert = builder.create();
     }
 
+
+	private void closeFeedback() {
+	        setResult(RESULT_OK);
+			finish();
+                if (StudyOptions.getApiLevel() > 4) {
+                    ActivityTransitionAnimation.slide(Feedback.this, ActivityTransitionAnimation.FADE);
+                }
+	}
+
+
     private void refreshInterface() {
         if (mReportErrorMode.equals(REPORT_ASK)) {
             Resources res = getResources();
@@ -196,7 +211,7 @@ public class Feedback extends Activity {
             try {
                 String feedback = "Automatically sent";
                 Connection.sendFeedback(mSendListener, new Payload(new Object[] {
-                        mFeedbackUrl, mErrorUrl, feedback, mErrorReports, mNonce, getApplication()}));
+                        mFeedbackUrl, mErrorUrl, feedback, mErrorReports, mNonce, getApplication(), true}));
                 if (mErrorReports.size() > 0) {
                     mPostingFeedback = true;
                 }
@@ -206,16 +221,11 @@ public class Feedback extends Activity {
             } catch (Exception e) {
                 Log.e(AnkiDroidApp.TAG, e.toString());
             }
-
-            deleteFiles(true, false);
-            setResult(RESULT_OK);
-            finish();
-
+            closeFeedback();
             return;
         } else if (mReportErrorMode.equals(REPORT_NEVER)) { // Never report
             deleteFiles(false, false);
-            setResult(RESULT_OK);
-            finish();
+            closeFeedback();
         }
 
         View mainView = getLayoutInflater().inflate(R.layout.feedback, null);
@@ -274,7 +284,7 @@ public class Feedback extends Activity {
                 if (!mPostingFeedback) {
                     String feedback = mEtFeedbackText.getText().toString();
                     Connection.sendFeedback(mSendListener, new Payload(new Object[] {
-                            mFeedbackUrl, mErrorUrl, feedback, mErrorReports, mNonce, getApplication()}));
+                            mFeedbackUrl, mErrorUrl, feedback, mErrorReports, mNonce, getApplication(), false}));
                     if (mErrorReports.size() > 0) {
                         mPostingFeedback = true;
                     }
diff --git a/src/com/ichi2/anki/Lookup.java b/src/com/ichi2/anki/Lookup.java
index cc013aed5c..3c0c67a39b 100644
--- a/src/com/ichi2/anki/Lookup.java
+++ b/src/com/ichi2/anki/Lookup.java
@@ -170,13 +170,13 @@ public class Lookup {
     	if (mCurrentCard == null) {
     		return "";
     	} else {
-        	return MetaDB.getLanguage(mContext, mDeckFilename, Model.getModel(AnkiDroidApp.deck(), mCurrentCard.getCardModelId(), false).getId(), mCurrentCard.getCardModelId(), questionAnswer);    		
+        	return MetaDB.getLanguage(mContext, mDeckFilename, Model.getModel(DeckManager.getMainDeck(), mCurrentCard.getCardModelId(), false).getId(), mCurrentCard.getCardModelId(), questionAnswer);    		
     	}
     }
     
     private static void storeLanguage(String language, int questionAnswer) {
     	if (mCurrentCard != null) {
-        	MetaDB.storeLanguage(mContext, mDeckFilename,  Model.getModel(AnkiDroidApp.deck(), mCurrentCard.getCardModelId(), false).getId(), mCurrentCard.getCardModelId(), questionAnswer, language);    		
+        	MetaDB.storeLanguage(mContext, mDeckFilename,  Model.getModel(DeckManager.getMainDeck(), mCurrentCard.getCardModelId(), false).getId(), mCurrentCard.getCardModelId(), questionAnswer, language);    		
     	}
     }
 
diff --git a/src/com/ichi2/anki/MetaDB.java b/src/com/ichi2/anki/MetaDB.java
index 43957f5076..b0c20868ce 100644
--- a/src/com/ichi2/anki/MetaDB.java
+++ b/src/com/ichi2/anki/MetaDB.java
@@ -1,10 +1,10 @@
 package com.ichi2.anki;
 
+import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import com.tomgibara.android.veecheck.util.PrefSettings;
-
 import android.content.Context;
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
@@ -79,7 +79,12 @@ public class MetaDB {
                     + "failedCards INTEGER NOT NULL, "
             		+ "eta INTEGER NOT NULL, "
             		+ "time INTEGER NOT NULL)");
-        Log.i(AnkiDroidApp.TAG, "Opening MetaDB");
+            mMetaDb.execSQL(
+                    "CREATE TABLE IF NOT EXISTS intentInformation ("
+                    + "id INTEGER PRIMARY KEY AUTOINCREMENT, "
+                    + "source TEXT NOT NULL, "
+                    + "target INTEGER NOT NULL)");
+            Log.i(AnkiDroidApp.TAG, "Opening MetaDB");
         } catch(Exception e) {
             Log.e("Error", "Error opening MetaDB ", e);
         }
@@ -116,6 +121,8 @@ public class MetaDB {
             Log.i(AnkiDroidApp.TAG, "Resetting custom Dictionary");
             mMetaDb.execSQL("DROP TABLE IF EXISTS widgetStatus;");
             Log.i(AnkiDroidApp.TAG, "Resetting widget status");
+            mMetaDb.execSQL("DROP TABLE IF EXISTS intentInformation;");
+            Log.i(AnkiDroidApp.TAG, "Resetting intentInformation");
             return true;
         } catch(Exception e) {
             Log.e("Error", "Error resetting MetaDB ", e);
@@ -152,7 +159,24 @@ public class MetaDB {
             openDB(context);
             return true;
         } catch(Exception e) {
-            Log.e("Error", "Error resetting MetaDB ", e);
+            Log.e("Error", "Error resetting widgetStatus ", e);
+        }
+        return false;
+    }
+
+
+    /** Reset the intent information. */
+    public static boolean resetIntentInformation(Context context) {
+        if (mMetaDb == null || !mMetaDb.isOpen()) {
+            openDB(context);
+        }
+        try {
+            Log.i(AnkiDroidApp.TAG, "Resetting intent information");
+            mMetaDb.execSQL("DROP TABLE IF EXISTS intentInformation;");
+            openDB(context);
+            return true;
+        } catch(Exception e) {
+            Log.e("Error", "Error resetting intentInformation ", e);
         }
         return false;
     }
@@ -416,21 +440,18 @@ public class MetaDB {
         Cursor cursor = null;
         int due = 0;
         int eta = 0;
-        int currentDeckdue = 0;
         int time = 0;
-        String currentDeck = PrefSettings.getSharedPrefs(context).getString("deckFilename", "");
+        boolean noDeck = true;
         try {
             cursor = mMetaDb.query("widgetStatus",
-                    new String[]{"dueCards", "failedCards", "newCards", "time", "eta", "deckPath"},
+                    new String[]{"dueCards", "failedCards", "newCards", "time", "eta"},
                     null, null, null, null, null);
             while (cursor.moveToNext()) {
+            	noDeck = false;
             	int d = cursor.getInt(0) + cursor.getInt(1) + cursor.getInt(2);
             	due += d;
             	time += cursor.getInt(3);
             	eta += cursor.getInt(4);
-            	if (currentDeck.equals(cursor.getString(5))) {
-            		currentDeckdue = d;
-            	}
             }
         } catch (SQLiteException e) {
             Log.e(AnkiDroidApp.TAG, "Error while querying widgetStatus", e);
@@ -439,7 +460,29 @@ public class MetaDB {
                 cursor.close();
             }
         }
-        return new int[]{due, time, eta, currentDeckdue};
+        return new int[]{noDeck ? -1 : due, time, eta};
+    }
+
+
+    public static int getNotificationStatus(Context context) {
+        openDBIfClosed(context);
+        Cursor cursor = null;
+        int due = 0;
+        try {
+            cursor = mMetaDb.query("widgetStatus",
+                    new String[]{"dueCards", "failedCards", "newCards"},
+                    null, null, null, null, null);
+            while (cursor.moveToNext()) {
+            	due += cursor.getInt(0) + cursor.getInt(1) + cursor.getInt(2);
+            }
+        } catch (SQLiteException e) {
+            Log.e(AnkiDroidApp.TAG, "Error while querying widgetStatus", e);
+        } finally {
+            if (cursor != null && !cursor.isClosed()) {
+                cursor.close();
+            }
+        }
+        return due;
     }
 
 
@@ -472,4 +515,58 @@ public class MetaDB {
             Log.i(AnkiDroidApp.TAG, "Trying to reset Widget: " + resetWidget(context));
         }
     }
+
+
+    public static ArrayList<HashMap<String, String>> getIntentInformation(Context context) {
+        openDBIfClosed(context);
+        Cursor cursor = null;
+        ArrayList<HashMap<String, String>> list = new ArrayList<HashMap<String, String>>();
+        try {
+            cursor = mMetaDb.query("intentInformation",
+                    new String[]{"id", "source", "target"},
+                    null, null, null, null, "id");
+            while (cursor.moveToNext()) {
+            	HashMap<String, String> item = new HashMap<String, String>();
+            	item.put("id", Integer.toString(cursor.getInt(0)));
+            	item.put("source", cursor.getString(1));
+            	item.put("target", cursor.getString(2));
+            	list.add(item);
+            }
+        } catch (SQLiteException e) {
+            Log.e(AnkiDroidApp.TAG, "Error while querying intentInformation", e);
+        } finally {
+            if (cursor != null && !cursor.isClosed()) {
+                cursor.close();
+            }
+        }
+        return list;
+    }
+
+
+    public static void saveIntentInformation(Context context, String source, String target) {
+        openDBIfClosed(context);
+        try {
+            mMetaDb.execSQL("INSERT INTO intentInformation (source, target) "
+                            + " VALUES (?, ?);",
+                            new Object[]{source, target});
+            Log.i(AnkiDroidApp.TAG, "Store intentInformation: " + source + " - " + target);
+        } catch(Exception e) {
+            Log.e("Error", "Error storing intentInformation in MetaDB ", e);
+        }
+    }
+
+
+    public static boolean removeIntentInformation(Context context, String id) {
+        if (mMetaDb == null || !mMetaDb.isOpen()) {
+            openDB(context);
+        }
+        try {
+            Log.i(AnkiDroidApp.TAG, "Deleting intent information " + id);
+            mMetaDb.execSQL("DELETE FROM intentInformation WHERE id = " + id + ";");
+            return true;
+        } catch(Exception e) {
+            Log.e("Error", "Error deleting intentInformation " + id + ": ", e);
+        }
+        return false;
+    }
 }
diff --git a/src/com/ichi2/anki/MyAccount.java b/src/com/ichi2/anki/MyAccount.java
index 08505422d5..311561e2de 100644
--- a/src/com/ichi2/anki/MyAccount.java
+++ b/src/com/ichi2/anki/MyAccount.java
@@ -15,7 +15,6 @@
 package com.ichi2.anki;
 
 import android.app.Activity;
-import android.app.ProgressDialog;
 import android.content.Context;
 import android.content.DialogInterface;
 import android.content.Intent;
@@ -36,6 +35,7 @@ import com.ichi2.anim.ActivityTransitionAnimation;
 import com.ichi2.async.Connection;
 import com.ichi2.async.Connection.Payload;
 import com.ichi2.themes.StyledDialog;
+import com.ichi2.themes.StyledProgressDialog;
 import com.ichi2.themes.Themes;
 import com.tomgibara.android.veecheck.util.PrefSettings;
 
@@ -49,7 +49,7 @@ public class MyAccount extends Activity {
 
     private TextView mUsernameLoggedIn;
 
-    private ProgressDialog mProgressDialog;
+    private StyledProgressDialog mProgressDialog;
     private StyledDialog mNoConnectionAlert;
     private StyledDialog mConnectionErrorAlert;
     private StyledDialog mInvalidUserPassAlert;
@@ -232,7 +232,7 @@ public class MyAccount extends Activity {
         public void onPreExecute() {
             Log.i(AnkiDroidApp.TAG, "onPreExcecute");
             if (mProgressDialog == null || !mProgressDialog.isShowing()) {
-                mProgressDialog = ProgressDialog.show(MyAccount.this, "",
+                mProgressDialog = StyledProgressDialog.show(MyAccount.this, "",
                         getResources().getString(R.string.alert_logging_message), true);
             }
         }
diff --git a/src/com/ichi2/anki/PersonalDeckPicker.java b/src/com/ichi2/anki/PersonalDeckPicker.java
index 32afaae969..5023efeab9 100644
--- a/src/com/ichi2/anki/PersonalDeckPicker.java
+++ b/src/com/ichi2/anki/PersonalDeckPicker.java
@@ -15,7 +15,6 @@
 package com.ichi2.anki;
 
 import android.app.Activity;
-import android.app.ProgressDialog;
 import android.content.BroadcastReceiver;
 import android.content.ComponentName;
 import android.content.Context;
@@ -51,6 +50,7 @@ import com.ichi2.anki.services.IPersonalDeckServiceCallback;
 import com.ichi2.async.Connection;
 import com.ichi2.async.Connection.Payload;
 import com.ichi2.themes.StyledDialog;
+import com.ichi2.themes.StyledProgressDialog;
 import com.ichi2.themes.Themes;
 import com.tomgibara.android.veecheck.util.PrefSettings;
 
@@ -65,7 +65,7 @@ public class PersonalDeckPicker extends Activity {
      */
     private BroadcastReceiver mUnmountReceiver = null;
 
-    private ProgressDialog mProgressDialog;
+    private StyledProgressDialog mProgressDialog;
     private StyledDialog mNoConnectionAlert;
     private StyledDialog mConnectionErrorAlert;
     private StyledDialog mDownloadOverwriteAlert;
@@ -481,7 +481,7 @@ public class PersonalDeckPicker extends Activity {
         @Override
         public void onPreExecute() {
             if (mProgressDialog == null || !mProgressDialog.isShowing()) {
-                mProgressDialog = ProgressDialog.show(PersonalDeckPicker.this, "",
+                mProgressDialog = StyledProgressDialog.show(PersonalDeckPicker.this, "",
                         getResources().getString(R.string.loading_personal_decks), true, true, new DialogInterface.OnCancelListener() {
                 	@Override
                 	public void onCancel(DialogInterface dialog) {
diff --git a/src/com/ichi2/anki/Preferences.java b/src/com/ichi2/anki/Preferences.java
index fa9f453be0..d92dad399b 100644
--- a/src/com/ichi2/anki/Preferences.java
+++ b/src/com/ichi2/anki/Preferences.java
@@ -26,7 +26,6 @@ import java.util.TreeMap;
 
 import android.app.AlertDialog;
 import android.app.Dialog;
-import android.app.ProgressDialog;
 import android.content.DialogInterface;
 import android.content.Intent;
 import android.content.SharedPreferences;
@@ -44,8 +43,8 @@ import android.util.Log;
 import android.view.WindowManager.BadTokenException;
 
 import com.hlidskialf.android.preference.SeekBarPreference;
+import com.ichi2.themes.StyledProgressDialog;
 import com.ichi2.themes.Themes;
-import com.tomgibara.android.veecheck.Veecheck;
 import com.tomgibara.android.veecheck.util.PrefSettings;
 
 /**
@@ -61,6 +60,8 @@ public class Preferences extends PreferenceActivity implements OnSharedPreferenc
 //    private boolean mVeecheckStatus;
     private PreferenceManager mPrefMan;
     private CheckBoxPreference zoomCheckboxPreference;
+    private CheckBoxPreference keepScreenOnCheckBoxPreference;
+    private CheckBoxPreference showAnswerCheckBoxPreference;
     private CheckBoxPreference swipeCheckboxPreference;
     private CheckBoxPreference animationsCheckboxPreference;
     private CheckBoxPreference walModePreference;
@@ -69,11 +70,11 @@ public class Preferences extends PreferenceActivity implements OnSharedPreferenc
     private ListPreference mLanguageSelection;
     private CharSequence[] mLanguageDialogLabels;
     private CharSequence[] mLanguageDialogValues;
-    private static String[] mAppLanguages = {"ar", "ca", "cs", "de", "el", "es_ES", "fi", "fr", "hu", "id", "it", "ja", "ko", "pl", "pt_PT", "ro", "ru", "sr", "sv-SE", "tr", "vi", "zh-CN", "zh-TW", "en"};
+    private static String[] mAppLanguages = {"ar", "ca", "cs", "de", "el", "es_ES", "fi", "fr", "hu", "id", "it", "ja", "ko", "nl", "no", "pl", "pt_PT", "ro", "ru", "sr", "sv-SE", "th", "tr", "vi", "zh-CN", "zh-TW", "en"};
     private static String[] mShowValueInSummList = {"language", "startup_mode", "hideQuestionInAnswer", "dictionary", "reportErrorMode", "minimumCardsDueForNotification", "deckOrder", "gestureShake", "gestureSwipeUp", "gestureSwipeDown", "gestureSwipeLeft", "gestureSwipeRight", "gestureDoubleTap", "gestureTapTop", "gestureTapBottom", "gestureTapRight", "gestureTapLeft", "theme"};
     private static String[] mShowValueInSummSeek = {"relativeDisplayFontSize", "relativeCardBrowserFontSize", "answerButtonSize", "whiteBoardStrokeWidth", "minShakeIntensity", "swipeSensibility", "timeoutAnswerSeconds", "timeoutQuestionSeconds", "animationDuration", "backupMax"};
     private TreeMap<String, String> mListsToUpdate = new TreeMap<String, String>();
-    private ProgressDialog mProgressDialog;
+    private StyledProgressDialog mProgressDialog;
     private boolean lockCheckAction = false;
     private boolean walModeInitiallySet = false;
     private String dialogMessage;
@@ -92,6 +93,8 @@ public class Preferences extends PreferenceActivity implements OnSharedPreferenc
         getPreferenceScreen().getSharedPreferences().registerOnSharedPreferenceChangeListener(this);
         swipeCheckboxPreference = (CheckBoxPreference) getPreferenceScreen().findPreference("swipe");
         zoomCheckboxPreference = (CheckBoxPreference) getPreferenceScreen().findPreference("zoom");
+        keepScreenOnCheckBoxPreference = (CheckBoxPreference) getPreferenceScreen().findPreference("keepScreenOn");
+        showAnswerCheckBoxPreference = (CheckBoxPreference) getPreferenceScreen().findPreference("timeoutAnswer");
         animationsCheckboxPreference = (CheckBoxPreference) getPreferenceScreen().findPreference("themeAnimations");
         walModePreference = (CheckBoxPreference) getPreferenceScreen().findPreference("walMode");
         useBackupPreference = (CheckBoxPreference) getPreferenceScreen().findPreference("useBackup");
@@ -239,6 +242,8 @@ public class Preferences extends PreferenceActivity implements OnSharedPreferenc
             if (key.equals("swipe")) {
             	zoomCheckboxPreference.setChecked(false);
             	zoomCheckboxPreference.setEnabled(!swipeCheckboxPreference.isChecked());
+            } else if (key.equals("timeoutAnswer")) {
+            	keepScreenOnCheckBoxPreference.setChecked(showAnswerCheckBoxPreference.isChecked());
             } else if (key.equals("language")) {
     			Intent intent = this.getIntent();
     			setResult(StudyOptions.RESULT_RESTART, intent);
@@ -248,13 +253,26 @@ public class Preferences extends PreferenceActivity implements OnSharedPreferenc
     			setResult(StudyOptions.RESULT_RESTART, intent);
     			finish();
             } else if (key.equals("theme")) {
-            	if (!sharedPreferences.getString("theme", "0").equals("2")) {
+            	if (!sharedPreferences.getString("theme", "2").equals("2")) {
             		animationsCheckboxPreference.setChecked(false);
             		animationsCheckboxPreference.setEnabled(false);
             	} else {
             		animationsCheckboxPreference.setEnabled(true);
             	}
             	Themes.loadTheme();
+            	switch (Integer.parseInt(sharedPreferences.getString("theme", "2"))) {
+            	case Themes.THEME_ANDROID_DARK:
+            	case Themes.THEME_ANDROID_LIGHT:
+            	case Themes.THEME_BLUE:
+            		sharedPreferences.edit().putString("defaultFont", "").commit();
+            		break;
+            	case Themes.THEME_FLAT:
+            		sharedPreferences.edit().putString("defaultFont", "OpenSans-Regular").commit();
+            		break;
+            	case Themes.THEME_WHITE:
+            		sharedPreferences.edit().putString("defaultFont", "OpenSans-Regular").commit();
+            		break;
+            	}
     			Intent intent = this.getIntent();
     			setResult(StudyOptions.RESULT_RESTART, intent);
     			finish();
@@ -271,7 +289,7 @@ public class Preferences extends PreferenceActivity implements OnSharedPreferenc
             	} else if (walModeInitiallySet) {
             		walModeInitiallySet = false;
             		dialogMessage = getResources().getString(R.string.wal_mode_set_message);
-                	DeckTask.launchDeckTask(DeckTask.TASK_TYPE_SET_ALL_DECKS_JOURNAL_MODE, mDeckOperationHandler, new DeckTask.TaskData(AnkiDroidApp.deck(), PrefSettings.getSharedPrefs(getBaseContext()).getString("deckPath", AnkiDroidApp.getStorageDirectory())));
+                	DeckTask.launchDeckTask(DeckTask.TASK_TYPE_SET_ALL_DECKS_JOURNAL_MODE, mDeckOperationHandler, new DeckTask.TaskData(DeckManager.getMainDeck(), PrefSettings.getSharedPrefs(getBaseContext()).getString("deckPath", AnkiDroidApp.getStorageDirectory())));
             	} else {
             		lockCheckAction = false;        		
             	}
@@ -309,22 +327,21 @@ public class Preferences extends PreferenceActivity implements OnSharedPreferenc
 
     /** Returns a list of the names of the installed custom fonts. */
     private String[] getCustomFonts(String defaultValue) {
-        File[] files = Utils.getCustomFonts(this);
+        String[] files = Utils.getCustomFonts(this);
         int count = files.length;
         Log.d(AnkiDroidApp.TAG, "There are " + count + " custom fonts");
         String[] names = new String[count + 1];
-        for (int index = 0; index < count; ++index) {
-            names[index] = Utils.removeExtension(files[index].getName());
+        names[0] = defaultValue;
+        for (int index = 1; index < count + 1; ++index) {
+            names[index] =  Utils.removeExtension((new File(files[index - 1])).getName());
             Log.d(AnkiDroidApp.TAG, "Adding custom font: " + names[index]);
         }
-        names[count] = defaultValue;
         return names;
     }
 
 
     private void setReloadDeck() {
-    	dialogMessage = getResources().getString(R.string.close_deck);
-    	DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CLOSE_DECK, mDeckOperationHandler, new DeckTask.TaskData(0, AnkiDroidApp.deck(), 0l, false));
+    	DeckManager.closeMainDeck();
 		setResult(StudyOptions.RESULT_RELOAD_DECK, getIntent());
     }
 
@@ -367,7 +384,7 @@ public class Preferences extends PreferenceActivity implements OnSharedPreferenc
     				lockCheckAction = true;
     				useBackupPreference.setChecked(false);
     				dialogMessage = getResources().getString(R.string.backup_delete);
-    				DeckTask.launchDeckTask(DeckTask.TASK_TYPE_DELETE_BACKUPS, mDeckOperationHandler, null);
+    				DeckTask.launchDeckTask(DeckTask.TASK_TYPE_DELETE_BACKUPS, mDeckOperationHandler, (DeckTask.TaskData[]) null);
     			}
     		});
     		builder.setNegativeButton(res.getString(R.string.no), null);
@@ -401,7 +418,7 @@ public class Preferences extends PreferenceActivity implements OnSharedPreferenc
     private DeckTask.TaskListener mDeckOperationHandler = new DeckTask.TaskListener() {
         @Override
         public void onPreExecute() {
-        	mProgressDialog = ProgressDialog.show(Preferences.this, "", dialogMessage, true);
+        	mProgressDialog = StyledProgressDialog.show(Preferences.this, "", dialogMessage, true);
         }
 
 
diff --git a/src/com/ichi2/anki/Reviewer.java b/src/com/ichi2/anki/Reviewer.java
index 6cfd8074df..943e4e7211 100644
--- a/src/com/ichi2/anki/Reviewer.java
+++ b/src/com/ichi2/anki/Reviewer.java
@@ -19,6 +19,8 @@ import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.text.DecimalFormat;
 import java.text.DecimalFormatSymbols;
 import java.text.ParseException;
@@ -30,7 +32,6 @@ import org.json.JSONException;
 
 import android.app.Activity;
 import android.app.Dialog;
-import android.app.ProgressDialog;
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.DialogInterface;
@@ -42,6 +43,7 @@ import android.content.pm.ActivityInfo;
 import android.content.res.Configuration;
 import android.content.res.Resources;
 import android.graphics.Color;
+import android.graphics.Typeface;
 import android.graphics.drawable.Drawable;
 import android.hardware.Sensor;
 import android.hardware.SensorEvent;
@@ -54,11 +56,18 @@ import android.os.Message;
 import android.os.SystemClock;
 import android.os.Vibrator;
 import android.text.ClipboardManager;
+import android.text.Html;
 import android.text.SpannableString;
+import android.text.SpannableStringBuilder;
+import android.text.Spanned;
+import android.text.SpannedString;
+import android.text.style.ForegroundColorSpan;
+import android.text.style.StyleSpan;
 import android.text.style.UnderlineSpan;
 import android.util.Log;
 import android.view.GestureDetector;
 import android.view.GestureDetector.SimpleOnGestureListener;
+import android.view.Gravity;
 import android.view.KeyEvent;
 import android.view.Menu;
 import android.view.MenuItem;
@@ -87,9 +96,12 @@ import com.ichi2.anim.ActivityTransitionAnimation;
 import com.ichi2.anim.Animation3D;
 import com.ichi2.anim.ViewAnimation;
 import com.ichi2.themes.StyledDialog;
+import com.ichi2.themes.StyledProgressDialog;
 import com.ichi2.themes.Themes;
 import com.ichi2.utils.DiffEngine;
 import com.ichi2.utils.RubyParser;
+import com.ichi2.widget.AnkiDroidWidgetBig;
+import com.ichi2.widget.WidgetStatus;
 import com.tomgibara.android.veecheck.util.PrefSettings;
 
 import org.amr.arabic.ArabicUtilities;
@@ -103,9 +115,12 @@ public class Reviewer extends Activity implements IButtonListener{
     /**
      * Result codes that are returned when this activity finishes.
      */
-    public static final int RESULT_SESSION_COMPLETED = 1;
-    public static final int RESULT_NO_MORE_CARDS = 2;
-    public static final int RESULT_EDIT_CARD_RESET = 3;
+    public static final int RESULT_DEFAULT = 50;
+    public static final int RESULT_SESSION_COMPLETED = 51;
+    public static final int RESULT_NO_MORE_CARDS = 52;
+    public static final int RESULT_EDIT_CARD_RESET = 53;
+    public static final int RESULT_ANSWERING_ERROR = 54;
+    public static final int RESULT_DECK_CLOSED = 55;
 
     /**
      * Possible values for update card handler
@@ -216,6 +231,8 @@ public class Reviewer extends Activity implements IButtonListener{
      */
     private BroadcastReceiver mUnmountReceiver = null;
 
+    private boolean mInBackground = false;
+
     /**
      * Variables to hold preferences
      */
@@ -227,8 +244,8 @@ public class Reviewer extends Activity implements IButtonListener{
     private boolean mLongClickWorkaround;
     private boolean mPrefFullscreenReview;
     private boolean mshowNextReviewTime;
-    private boolean mZoomEnabled;
-    private boolean mZeemoteEnabled;    
+    private boolean mZoomEnabled;    
+//    private boolean mZeemoteEnabled;    
     private boolean mPrefUseRubySupport; // Parse for ruby annotations
     private String mDeckFilename;
     private int mPrefHideQuestionInAnswer; // Hide the question when showing the
@@ -253,20 +270,22 @@ public class Reviewer extends Activity implements IButtonListener{
     private boolean mIsLastCard = false;
     private boolean mShowProgressBars;
     private boolean mPrefUseTimer;
-    private boolean mShowAnimations = true;
+    private boolean mShowAnimations = false;
+    private boolean mSimpleInterface = false;
     private String mLocale;
 
     private boolean mIsSelecting = false;
     private boolean mTouchStarted = false;
     private boolean mIsAnswering = false;
 
-    @SuppressWarnings("unused")
+//    @SuppressWarnings("unused")
 //    private boolean mUpdateNotifications; // TODO use Veecheck only if this is true
 
     private String mCardTemplate;
 
     private String mMediaDir;
 
+    private boolean mInEditor = false;
     
     /**
      * Variables to hold layout objects that we need to update or handle events for
@@ -275,14 +294,14 @@ public class Reviewer extends Activity implements IButtonListener{
     private View mLookUpIcon;
     private FrameLayout mCardContainer;
     private WebView mCard;
+    private TextView mSimpleCard;
     private WebView mNextCard;
-    private FrameLayout mCardFrame;
+    private LinearLayout mCardFrame;
     private FrameLayout mTouchLayer;
     private TextView mTextBarRed;
     private TextView mTextBarBlack;
     private TextView mTextBarBlue;
     private TextView mChosenAnswer;
-    private Drawable[] mDefaultButtonDrawable;
     private LinearLayout mProgressBars;
     private View mSessionYesBar;
     private View mSessionProgressBar;
@@ -296,10 +315,15 @@ public class Reviewer extends Activity implements IButtonListener{
     private Button mEase2;
     private Button mEase3;
     private Button mEase4;
+    private LinearLayout mFlipCardLayout;
+    private LinearLayout mEase1Layout;
+    private LinearLayout mEase2Layout;
+    private LinearLayout mEase3Layout;
+    private LinearLayout mEase4Layout;
     private Chronometer mCardTimer;
     private Whiteboard mWhiteboard;
 	private ClipboardManager mClipboard;
-    private ProgressDialog mProgressDialog;
+    private StyledProgressDialog mProgressDialog;
 
     private Card mCurrentCard;
     private int mCurrentEase;
@@ -331,12 +355,12 @@ public class Reviewer extends Activity implements IButtonListener{
     private int mStatisticsMatureNoCount;
     private boolean mReloadStatistics = true;
 
-    private boolean mClosing = false;
-
     private long mSavedTimer = 0;
 
-    private File[] mCustomFontFiles;
+    private boolean mRefreshWebview = false;
+    private String[] mCustomFontFiles;
     private String mCustomDefaultFontCss;
+    private String mCustomFontStyle;
 
 	/** 
 	 * Shake Detection
@@ -355,36 +379,37 @@ public class Reviewer extends Activity implements IButtonListener{
     /**
      * Gesture Allocation
      */
-    private int mGestureSwipeUp;
-    private int mGestureSwipeDown;
-    private int mGestureSwipeLeft;
-    private int mGestureSwipeRight;
-    private int mGestureShake;
-    private int mGestureDoubleTap;
-    private int mGestureTapLeft;
-    private int mGestureTapRight;
-    private int mGestureTapTop;
-    private int mGestureTapBottom;
-
-    private static final int GESTURE_NOTHING = 0;
-    private static final int GESTURE_ANSWER_EASE1 = 1;
-    private static final int GESTURE_ANSWER_EASE2 = 2;
-    private static final int GESTURE_ANSWER_EASE3 = 3;
-    private static final int GESTURE_ANSWER_EASE4 = 4;
-    private static final int GESTURE_ANSWER_RECOMMENDED = 5;
-    private static final int GESTURE_ANSWER_BETTER_THAN_RECOMMENDED = 6;
-    private static final int GESTURE_UNDO = 7;
-    private static final int GESTURE_REDO = 8;
-    private static final int GESTURE_EDIT = 9;
-    private static final int GESTURE_MARK = 10;
-    private static final int GESTURE_LOOKUP = 11;
-    private static final int GESTURE_BURY = 12;
-    private static final int GESTURE_SUSPEND = 13;
-    private static final int GESTURE_DELETE = 14;
-    private static final int GESTURE_CLEAR_WHITEBOARD = 15;
-    private static final int GESTURE_EXIT = 16;
-
- 	private String mCardContent;
+ 	private int mGestureSwipeUp;
+ 	private int mGestureSwipeDown;
+ 	private int mGestureSwipeLeft;
+ 	private int mGestureSwipeRight;
+ 	private int mGestureShake;
+ 	private int mGestureDoubleTap;
+ 	private int mGestureTapLeft;
+ 	private int mGestureTapRight;
+ 	private int mGestureTapTop;
+ 	private int mGestureTapBottom;
+ 	private int mGestureLongclick;
+
+ 	private static final int GESTURE_NOTHING = 0;
+ 	private static final int GESTURE_ANSWER_EASE1 = 1;
+ 	private static final int GESTURE_ANSWER_EASE2 = 2;
+ 	private static final int GESTURE_ANSWER_EASE3 = 3;
+ 	private static final int GESTURE_ANSWER_EASE4 = 4;
+ 	private static final int GESTURE_ANSWER_RECOMMENDED = 5;
+ 	private static final int GESTURE_ANSWER_BETTER_THAN_RECOMMENDED = 6;
+ 	private static final int GESTURE_UNDO = 7;
+ 	private static final int GESTURE_REDO = 8;
+ 	private static final int GESTURE_EDIT = 9;
+ 	private static final int GESTURE_MARK = 10;
+ 	private static final int GESTURE_LOOKUP = 11;
+ 	private static final int GESTURE_BURY= 12;
+ 	private static final int GESTURE_SUSPEND = 13;
+ 	private static final int GESTURE_DELETE = 14;
+ 	private static final int GESTURE_CLEAR_WHITEBOARD = 15;
+ 	private static final int GESTURE_EXIT = 16;
+
+ 	private Spanned mCardContent;
  	private String mBaseUrl;
 
  	private static final int ANIMATION_NO_ANIMATION = 0;
@@ -402,13 +427,15 @@ public class Reviewer extends Activity implements IButtonListener{
 
     private int mFadeDuration = 300;
 
+	private Method mSetScrollbarBarFading = null;
+	private Method mSetTextIsSelectable = null;
 
  	/**
  	 * Zeemote controller
  	 */
 	protected JoystickToButtonAdapter adapter;
 
-    private int zEase;
+//    private int zEase;
     
     /**
      * The answer in the compare to field for the current card if answer should be given by learner.
@@ -464,12 +491,12 @@ public class Reviewer extends Activity implements IButtonListener{
     		Log.i(AnkiDroidApp.TAG, "onEmulatedLongClick");
         	Vibrator vibratorManager = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
             vibratorManager.vibrate(50);
-            longClickHandler.postDelayed(startSelection, 300);
+            longClickHandler.postDelayed(startLongClickAction, 300);
         }
     };
-    private final Runnable startSelection = new Runnable() {
+    private final Runnable startLongClickAction = new Runnable() {
         public void run() {
-            selectAndCopyText();
+            executeCommand(mGestureLongclick);
         }
     };
 
@@ -513,17 +540,17 @@ public class Reviewer extends Activity implements IButtonListener{
         		return;
         	}
             switch (view.getId()) {
-                case R.id.ease1:
-                    answerCard(EASE_FAILED);
+                case R.id.flashcard_layout_ease1:
+                    answerCard(Card.EASE_FAILED);
                     break;
-                case R.id.ease2:
-                    answerCard(EASE_HARD);
+                case R.id.flashcard_layout_ease2:
+                	answerCard(Card.EASE_HARD);
                     break;
-                case R.id.ease3:
-                    answerCard(EASE_MID);
+                case R.id.flashcard_layout_ease3:
+                	answerCard(Card.EASE_MID);
                     break;
-                case R.id.ease4:
-                    answerCard(EASE_EASY);
+                case R.id.flashcard_layout_ease4:
+                	answerCard(Card.EASE_EASY);
                     break;
                 default:
                     mCurrentEase = 0;
@@ -559,7 +586,11 @@ public class Reviewer extends Activity implements IButtonListener{
             }
             try {
                 if (event != null) {
-    	            mCard.dispatchTouchEvent(event);
+                	if (mSimpleInterface) {
+                		mSimpleCard.dispatchTouchEvent(event);
+                	} else {
+        	            mCard.dispatchTouchEvent(event);	
+                	}   	            
                 }            	
             } catch (NullPointerException e) {
             	Log.e(AnkiDroidApp.TAG, "Error on dispatching touch event: " + e);
@@ -584,7 +615,7 @@ public class Reviewer extends Activity implements IButtonListener{
     		Log.i(AnkiDroidApp.TAG, "onLongClick");
     		Vibrator vibratorManager = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
     		vibratorManager.vibrate(50);
-            longClickHandler.postDelayed(startSelection, 300);
+            longClickHandler.postDelayed(startLongClickAction, 300);
     		return true;
     	}
     };
@@ -593,8 +624,8 @@ public class Reviewer extends Activity implements IButtonListener{
     private DeckTask.TaskListener mMarkCardHandler = new DeckTask.TaskListener() {
         @Override
         public void onPreExecute() {
-            Resources res = getResources();
-            mProgressDialog = ProgressDialog.show(Reviewer.this, "", res.getString(R.string.saving_changes), true);
+        	Resources res = getResources();
+            mProgressDialog = StyledProgressDialog.show(Reviewer.this, "", res.getString(R.string.saving_changes), true);
         }
 
 
@@ -606,6 +637,10 @@ public class Reviewer extends Activity implements IButtonListener{
 
         @Override
         public void onPostExecute(DeckTask.TaskData result) {
+            if (!result.getBoolean()) {
+            	// RuntimeException occured on marking cards
+                closeReviewer(RESULT_ANSWERING_ERROR, true);
+            }
             mProgressDialog.dismiss();
         }
     };
@@ -629,15 +664,19 @@ public class Reviewer extends Activity implements IButtonListener{
 
         @Override
         public void onPostExecute(DeckTask.TaskData result) {
+            if (!result.getBoolean()) {
+            	// RuntimeException occured on dismissing cards
+                Reviewer.this.setResult(RESULT_ANSWERING_ERROR);
+                closeReviewer(RESULT_ANSWERING_ERROR, true);
+                return;
+            }
             // Check for no more cards before session complete. If they are both true,
             // no more cards will take precedence when returning to study options.
             if (mNoMoreCards) {
-                Reviewer.this.setResult(RESULT_NO_MORE_CARDS);
                 mShowCongrats = true;
-                closeReviewer();
+                closeReviewer(RESULT_NO_MORE_CARDS, true);
             } else if (mSessionComplete) {
-                Reviewer.this.setResult(RESULT_SESSION_COMPLETED);
-                closeReviewer();
+                closeReviewer(RESULT_SESSION_COMPLETED, true);
             }
         }
     };
@@ -645,8 +684,12 @@ public class Reviewer extends Activity implements IButtonListener{
     private DeckTask.TaskListener mUpdateCardHandler = new DeckTask.TaskListener() {
         @Override
         public void onPreExecute() {
-            Resources res = getResources();
-            mProgressDialog = ProgressDialog.show(Reviewer.this, "", res.getString(R.string.saving_changes), true);
+        	Resources res = getResources();
+		try {
+	        	mProgressDialog = StyledProgressDialog.show(Reviewer.this, "", res.getString(R.string.saving_changes), true);
+		} catch (IllegalArgumentException e) {
+			Log.e(AnkiDroidApp.TAG, "Reviewer: Error on showing progress dialog: " + e);
+		}
         }
 
 
@@ -667,23 +710,34 @@ public class Reviewer extends Activity implements IButtonListener{
             } else {
                 displayCardQuestion();
             }
-            if (mProgressDialog != null && mProgressDialog.isShowing()) {
-                mProgressDialog.dismiss();            	
+            try {
+                if (mProgressDialog != null && mProgressDialog.isShowing()) {
+			mProgressDialog.dismiss();
+                }
+            } catch (IllegalArgumentException e) {
+                Log.e(AnkiDroidApp.TAG, "Reviewer: Error on dismissing progress dialog: " + e);
+                mProgressDialog = null;
             }
         }
 
 
         @Override
         public void onPostExecute(DeckTask.TaskData result) {
+            if (!result.getBoolean()) {
+            	// RuntimeException occured on update cards
+                closeReviewer(RESULT_ANSWERING_ERROR, true);
+                return;
+            }
             mShakeActionStarted = false;
-            if (result != null) {
-                String str = result.getString();
-                if (str != null && str.equals(Deck.UNDO_TYPE_SUSPEND_CARD)) {
+            String str = result.getString();
+            if (str != null) {
+                if (str.equals(Deck.UNDO_TYPE_SUSPEND_CARD)) {
                 	Themes.showThemedToast(Reviewer.this, getResources().getString(R.string.card_unsuspended), true);
-                } else if (result.getString().equals("redo suspend")) {
+                } else if (str.equals("redo suspend")) {
                 	Themes.showThemedToast(Reviewer.this, getResources().getString(R.string.card_suspended), true);           	
                 }            	
             }
+            mInEditor = false;
         }
     };
 
@@ -712,15 +766,18 @@ public class Reviewer extends Activity implements IButtonListener{
 
         @Override
         public void onPostExecute(DeckTask.TaskData result) {
+            if (!result.getBoolean()) {
+            	// RuntimeException occured on answering cards
+                closeReviewer(RESULT_ANSWERING_ERROR, true);
+                return;
+            }
             // Check for no more cards before session complete. If they are both true,
             // no more cards will take precedence when returning to study options.
             if (mNoMoreCards) {
-                Reviewer.this.setResult(RESULT_NO_MORE_CARDS);
                 mShowCongrats = true;
-                closeReviewer();
+                closeReviewer(RESULT_NO_MORE_CARDS, true);
             } else if (mSessionComplete) {
-                Reviewer.this.setResult(RESULT_SESSION_COMPLETED);
-                closeReviewer();
+                closeReviewer(RESULT_SESSION_COMPLETED, true);
             }
         }
     };
@@ -728,12 +785,12 @@ public class Reviewer extends Activity implements IButtonListener{
     DeckTask.TaskListener mSaveAndResetDeckHandler = new DeckTask.TaskListener() {
         @Override
         public void onPreExecute() {
-            if (mProgressDialog != null && mProgressDialog.isShowing()) {
-                mProgressDialog.setMessage(getResources().getString(R.string.saving_changes));
-            } else {
-                mProgressDialog = ProgressDialog.show(Reviewer.this, "", getResources().getString(
-                        R.string.saving_changes), true);
-            }
+        	if (mProgressDialog != null && mProgressDialog.isShowing()) {
+        		mProgressDialog.setMessage(getResources().getString(R.string.saving_changes));
+        	} else {
+                mProgressDialog = StyledProgressDialog.show(Reviewer.this, "", getResources()
+                        .getString(R.string.saving_changes), true);
+        	}
         }
 
 
@@ -814,13 +871,13 @@ public class Reviewer extends Activity implements IButtonListener{
 	            }
 				break;
 			case MSG_ZEEMOTE_BUTTON_B:
-				closeReviewer();
+				closeReviewer(RESULT_DEFAULT, false);
 				break;
 			case MSG_ZEEMOTE_BUTTON_C:
-				if (AnkiDroidApp.deck().undoAvailable()){
+				if (DeckManager.getMainDeck().undoAvailable()){
             	setNextCardAnimation(true);
             	DeckTask.launchDeckTask(DeckTask.TASK_TYPE_UNDO, mUpdateCardHandler, new DeckTask.TaskData(UPDATE_CARD_SHOW_QUESTION,
-                        AnkiDroidApp.deck(), mCurrentCard.getId(), false));
+                        DeckManager.getMainDeck(), mCurrentCard.getId(), false));
 				}
 				break;
 			case MSG_ZEEMOTE_BUTTON_D:
@@ -846,16 +903,16 @@ public class Reviewer extends Activity implements IButtonListener{
         super.onCreate(savedInstanceState);
         Log.i(AnkiDroidApp.TAG, "Reviewer - onCreate");
 
-        mChangeBorderStyle = Themes.getTheme() != Themes.THEME_BLUE;
+        mChangeBorderStyle = Themes.getTheme() == Themes.THEME_ANDROID_LIGHT || Themes.getTheme() == Themes.THEME_ANDROID_DARK;
 
         // The hardware buttons should control the music volume while reviewing.
         setVolumeControlStream(AudioManager.STREAM_MUSIC);
 
         // Make sure a deck is loaded before continuing.
-        Deck deck = AnkiDroidApp.deck();
+        Deck deck = DeckManager.getMainDeck();
         if (deck == null) {
-            setResult(StudyOptions.CONTENT_NO_EXTERNAL_STORAGE);
-			finish();
+        	finishNoStorageAvailable();
+			return;
         } else {
             mCurrentScheduler = deck.getSched();
             mMediaDir = setupMedia(deck);
@@ -882,10 +939,11 @@ public class Reviewer extends Activity implements IButtonListener{
             	mCurrentBackgroundColor = Color.WHITE;
             }
 
-      	  	mCustomFontFiles = Utils.getCustomFonts(getBaseContext());
+            mRefreshWebview = getRefreshWebviewAndInitializeWebviewVariables();
+
             initLayout(R.layout.flashcard);
             if (mPrefTextSelection) {
-                mClipboard.setText("");
+                clipboardSetText("");
                 Lookup.initialize(this, mDeckFilename);
             }
 
@@ -918,7 +976,6 @@ public class Reviewer extends Activity implements IButtonListener{
             // Load the first card and start reviewing. Uses the answer card
             // task to load a card, but since we send null
             // as the card to answer, no card will be answered.
-
             DeckTask.launchDeckTask(DeckTask.TASK_TYPE_ANSWER_CARD, mAnswerCardHandler, new DeckTask.TaskData(0,
                     deck, null));
         }
@@ -931,16 +988,12 @@ public class Reviewer extends Activity implements IButtonListener{
         super.onPause();
         Log.i(AnkiDroidApp.TAG, "Reviewer - onPause()");
 
+    	mTimeoutHandler.removeCallbacks(mShowAnswerTask);
+    	mTimeoutHandler.removeCallbacks(mShowQuestionTask);
+    	longClickHandler.removeCallbacks(longClickTestRunnable);
+    	longClickHandler.removeCallbacks(startLongClickAction);
+
         stopTimer();
-        if (!mClosing) {
-            // Save changes
-            Deck deck = AnkiDroidApp.deck();
-            if (deck != null) {
-	            DeckTask.waitToFinish();
-	            deck.commitToDB();
-            }
-            WidgetStatus.update(getBaseContext());
-        }
 
         if (mShakeEnabled) {
             mSensorManager.unregisterListener(mSensorListener);
@@ -961,14 +1014,28 @@ public class Reviewer extends Activity implements IButtonListener{
 
     @Override
     protected void onResume() {
+    	mInBackground = false;
       super.onResume();
-      if (AnkiDroidApp.deck() == null) {
-    	  finish();
+      Deck deck = DeckManager.getMainDeck();
+      if (deck == null) {
+    	  Log.e(AnkiDroidApp.TAG, "Reviewer: Deck already closed, returning to study options");
+    	  closeReviewer(RESULT_DECK_CLOSED, false);
+    	  return;
       }
+
+      // check if deck is already opened in big widget. If yes, reload card (to make sure it's not answered yet)
+      if (DeckManager.deckIsOpenedInBigWidget(deck.getDeckPath()) && mCurrentCard != null && !mInEditor) {
+    	  Log.i(AnkiDroidApp.TAG, "Reviewer: onResume: get card from big widget");
+    	  blockControls();
+    	  AnkiDroidWidgetBig.updateWidget(AnkiDroidWidgetBig.UpdateService.VIEW_NOT_SPECIFIED, true);
+    	  DeckTask.launchDeckTask(DeckTask.TASK_TYPE_ANSWER_CARD, mAnswerCardHandler, new DeckTask.TaskData(0, deck, null));
+      } else {
+    	  restartTimer();
+      }
+
       if (mShakeEnabled) {
           mSensorManager.registerListener(mSensorListener, mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER), SensorManager.SENSOR_DELAY_NORMAL);    	  
       }
-      restartTimer();
       if ((AnkiDroidApp.zeemoteController() != null) && (AnkiDroidApp.zeemoteController().isConnected())){
     	  Log.d("Zeemote","Adding listener in onResume");
     	  AnkiDroidApp.zeemoteController().addButtonListener(this);
@@ -982,10 +1049,21 @@ public class Reviewer extends Activity implements IButtonListener{
 
     @Override
     protected void onStop() {
+    	mInBackground = true;
       if (mShakeEnabled) {
-          mSensorManager.unregisterListener(mSensorListener);    	  
+          mSensorManager.unregisterListener(mSensorListener);
       }
       super.onStop();
+      Deck deck = DeckManager.getMainDeck();
+      if (!isFinishing()) {
+          // Save changes
+          updateBigWidget(!mCardFrame.isEnabled());
+          DeckTask.waitToFinish();
+          if (deck != null) {
+	         	deck.commitToDB();
+          }
+      }
+    WidgetStatus.update(this, WidgetStatus.getDeckStatus(deck));
     }
 
 
@@ -1005,38 +1083,40 @@ public class Reviewer extends Activity implements IButtonListener{
     @Override
     public boolean onKeyDown(int keyCode, KeyEvent event) {
         if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
-            Log.i(AnkiDroidApp.TAG, "Reviewer - onBackPressed()");
-            closeReviewer();
-            return true;
-        }
-         /** Enhancement 722: Hardware buttons for scrolling, I.Z. */
-        if (keyCode == 92)  {
-        	mCard.pageUp(false);
-        	if (mDoubleScrolling)  {
-        		mCard.pageUp(false);
-        	}
-        	return true;
-        }
-        if (keyCode == 93)  {
-        	mCard.pageDown(false);
-        	if (mDoubleScrolling)  {
-        		mCard.pageDown(false);
-        	}
-        	return true;
-        }
-        if (mScrollingButtons && keyCode == 94)  {
-        	mCard.pageUp(false);
-        	if (mDoubleScrolling)  {
-        		mCard.pageUp(false);
-        	}
+        	Log.i(AnkiDroidApp.TAG, "Reviewer - onBackPressed()");
+        	closeReviewer(RESULT_DEFAULT, false);
         	return true;
         }
-        if (mScrollingButtons && keyCode == 95)  {
-        	mCard.pageDown(false);
-        	if (mDoubleScrolling)  {
-        		mCard.pageDown(false);
-        	}
-        	return true;
+         /** Enhancement 722: Hardware buttons for scrolling, I.Z. */
+        if (!mSimpleInterface) {
+            if (keyCode == 92)  {
+            	mCard.pageUp(false);
+            	if (mDoubleScrolling)  {
+            		mCard.pageUp(false);
+            	}
+            	return true;
+            }
+            if (keyCode == 93)  {
+            	mCard.pageDown(false);
+            	if (mDoubleScrolling)  {
+            		mCard.pageDown(false);
+            	}
+            	return true;
+            }
+            if (mScrollingButtons && keyCode == 94)  {
+            	mCard.pageUp(false);
+            	if (mDoubleScrolling)  {
+            		mCard.pageUp(false);
+            	}
+            	return true;
+            }
+            if (mScrollingButtons && keyCode == 95)  {
+            	mCard.pageDown(false);
+            	if (mDoubleScrolling)  {
+            		mCard.pageDown(false);
+            	}
+            	return true;
+            }        	
         }
 
         return super.onKeyDown(keyCode, event);
@@ -1141,6 +1221,28 @@ public class Reviewer extends Activity implements IButtonListener{
     }
 
 
+    private void updateBigWidget(boolean showProgressDialog) {
+    	if (DeckManager.deckIsOpenedInBigWidget(DeckManager.getMainDeckPath())) {
+      	  	Log.i(AnkiDroidApp.TAG, "Reviewer: updateBigWidget");
+      	  	AnkiDroidWidgetBig.setCard(mCurrentCard);
+      	  	AnkiDroidWidgetBig.updateWidget(AnkiDroidWidgetBig.UpdateService.VIEW_SHOW_QUESTION, showProgressDialog);
+    	}
+    }
+
+
+    //These three methods use a deprecated API - they should be updated to possibly use its more modern version.
+    private boolean clipboardHasText() {
+        return mClipboard.hasText();
+    }
+
+    private void clipboardSetText(CharSequence text) {
+        mClipboard.setText(text);
+    }
+
+    private CharSequence clipboardGetText() {
+        return mClipboard.getText();
+    }
+
     @Override
     public boolean onPrepareOptionsMenu(Menu menu) {
         MenuItem item = menu.findItem(MENU_MARK);
@@ -1156,7 +1258,7 @@ public class Reviewer extends Activity implements IButtonListener{
         // }
         if (mPrefTextSelection) {
             item = menu.findItem(MENU_SEARCH);
-            if (mClipboard.hasText()) {
+            if (clipboardHasText()) {
             	item.setTitle(Lookup.getSearchStringTitle());
         		item.setEnabled(Lookup.isAvailable());
             } else {
@@ -1179,8 +1281,8 @@ public class Reviewer extends Activity implements IButtonListener{
 
             getWindow().setFlags(0, WindowManager.LayoutParams.FLAG_FULLSCREEN);
         }
-        menu.findItem(MENU_UNDO).setEnabled(AnkiDroidApp.deck().undoAvailable());
-        menu.findItem(MENU_REDO).setEnabled(AnkiDroidApp.deck().redoAvailable());
+        menu.findItem(MENU_UNDO).setEnabled(DeckManager.getMainDeck().undoAvailable());
+        menu.findItem(MENU_REDO).setEnabled(DeckManager.getMainDeck().redoAvailable());
         return true;
     }
 
@@ -1237,13 +1339,13 @@ public class Reviewer extends Activity implements IButtonListener{
             case MENU_REMOVE_BURY:
             	setNextCardAnimation(false);
                 DeckTask.launchDeckTask(DeckTask.TASK_TYPE_BURY_CARD, mDismissCardHandler, new DeckTask.TaskData(0,
-                        AnkiDroidApp.deck(), mCurrentCard));
+                        DeckManager.getMainDeck(), mCurrentCard));
                 return true;
 
             case MENU_REMOVE_SUSPEND:
             	setNextCardAnimation(false);
                 DeckTask.launchDeckTask(DeckTask.TASK_TYPE_SUSPEND_CARD, mDismissCardHandler, new DeckTask.TaskData(0,
-                        AnkiDroidApp.deck(), mCurrentCard));
+                        DeckManager.getMainDeck(), mCurrentCard));
                 return true;
 
             case MENU_REMOVE_DELETE:
@@ -1256,18 +1358,18 @@ public class Reviewer extends Activity implements IButtonListener{
 
             case MENU_MARK:
                 DeckTask.launchDeckTask(DeckTask.TASK_TYPE_MARK_CARD, mMarkCardHandler, new DeckTask.TaskData(0,
-                        AnkiDroidApp.deck(), mCurrentCard));
+                        DeckManager.getMainDeck(), mCurrentCard));
                 return true;
 
             case MENU_UNDO:
             	setNextCardAnimation(true);
             	DeckTask.launchDeckTask(DeckTask.TASK_TYPE_UNDO, mUpdateCardHandler, new DeckTask.TaskData(UPDATE_CARD_SHOW_QUESTION,
-                        AnkiDroidApp.deck(), mCurrentCard.getId(), false));
+                        DeckManager.getMainDeck(), mCurrentCard.getId(), false));
                 return true;
 
             case MENU_REDO:
                 DeckTask.launchDeckTask(DeckTask.TASK_TYPE_REDO, mUpdateCardHandler, new DeckTask.TaskData(UPDATE_CARD_SHOW_QUESTION,
-                        AnkiDroidApp.deck(), mCurrentCard.getId(), false));
+                        DeckManager.getMainDeck(), mCurrentCard.getId(), false));
                 return true;
         }
         return false;
@@ -1287,23 +1389,22 @@ public class Reviewer extends Activity implements IButtonListener{
                 	showQuestion = UPDATE_CARD_NEW_CARD;
                 }
                 DeckTask.launchDeckTask(DeckTask.TASK_TYPE_UPDATE_FACT, mUpdateCardHandler, new DeckTask.TaskData(showQuestion,
-                        AnkiDroidApp.deck(), mCurrentCard));
+                        DeckManager.getMainDeck(), mCurrentCard));
             } else if (resultCode == StudyOptions.CONTENT_NO_EXTERNAL_STORAGE) {
                 finishNoStorageAvailable();
             } else {
+            	mInEditor = false;
             	fillFlashcard(mShowAnimations);
             }
         }
         if (mPrefTextSelection) {
-        	mClipboard.setText("");
+        	clipboardSetText("");
         }
     }
 
 
     private boolean isCramming() {
-        // return (AnkiDroidApp.deck() != null) &&
-        // (AnkiDroidApp.deck().name().compareTo("cram") == 0);
-        return false;
+        return (DeckManager.getMainDeck() != null) && (DeckManager.getMainDeck().name().compareTo("cram") == 0);
     }
 
 
@@ -1350,19 +1451,19 @@ public class Reviewer extends Activity implements IButtonListener{
 
     private void restartTimer() {
         if (mCurrentCard != null) {
-            mCurrentCard.resumeTimer();          
+            mCurrentCard.resumeTimer();
         }
         if (mPrefTimer && mSavedTimer != 0) {
             mCardTimer.setBase(SystemClock.elapsedRealtime() - mSavedTimer);
             mCardTimer.start();
-        }    	
+        }
     }
 
 
     private void setLanguage(String language) {
     	Locale locale;
     	if (language.equals("")) {
-        	return;
+        	locale = Locale.getDefault();
     	} else {
         	locale = new Locale(language);
     	}
@@ -1373,8 +1474,7 @@ public class Reviewer extends Activity implements IButtonListener{
 
 
     private void finishNoStorageAvailable() {
-        setResult(StudyOptions.CONTENT_NO_EXTERNAL_STORAGE);
-        closeReviewer();
+        closeReviewer(StudyOptions.CONTENT_NO_EXTERNAL_STORAGE, false);
     }
 
 
@@ -1383,8 +1483,10 @@ public class Reviewer extends Activity implements IButtonListener{
         	Themes.showThemedToast(Reviewer.this, getResources().getString(R.string.cram_edit_warning), true);
             return false;
         } else {
+        	mInEditor = true;
             Intent editCard = new Intent(Reviewer.this, CardEditor.class);
-            editCard.putExtra(CardEditor.CARD_EDITOR_ACTION, CardEditor.EDIT_REVIEWER_CARD);
+            editCard.putExtra(CardEditor.EXTRA_CALLER, CardEditor.CALLER_REVIEWER);
+            editCard.putExtra(CardEditor.EXTRA_DECKPATH, DeckManager.getMainDeckPath());
         	sEditorCard = mCurrentCard;
         	setOutAnimation(true);
             startActivityForResult(editCard, EDIT_CURRENT_CARD);
@@ -1397,8 +1499,8 @@ public class Reviewer extends Activity implements IButtonListener{
 
 
     private void lookUpOrSelectText() {
-        if (mClipboard.hasText()) {
-            Log.i(AnkiDroidApp.TAG, "Clipboard has text = " + mClipboard.hasText());
+        if (clipboardHasText()) {
+            Log.i(AnkiDroidApp.TAG, "Clipboard has text = " + clipboardHasText());
             lookUp();
     	} else {
         	selectAndCopyText();
@@ -1409,8 +1511,8 @@ public class Reviewer extends Activity implements IButtonListener{
     private boolean lookUp() {
     	mLookUpIcon.setVisibility(View.GONE);
 	    mIsSelecting = false;
-	    if (Lookup.lookUp(mClipboard.getText().toString(), mCurrentCard)) {
-	        mClipboard.setText("");
+	    if (Lookup.lookUp(clipboardGetText().toString(), mCurrentCard)) {
+	        clipboardSetText("");
 	    }
 	    return true;
     }
@@ -1428,7 +1530,7 @@ public class Reviewer extends Activity implements IButtonListener{
                     @Override
                     public void onClick(DialogInterface dialog, int which) {
                     	setNextCardAnimation(false);
-                        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_DELETE_CARD, mDismissCardHandler, new DeckTask.TaskData(0, AnkiDroidApp.deck(), mCurrentCard));
+                        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_DELETE_CARD, mDismissCardHandler, new DeckTask.TaskData(0, DeckManager.getMainDeck(), mCurrentCard));
                     }
                 });
         builder.setNegativeButton(res.getString(R.string.no), null);
@@ -1441,13 +1543,13 @@ public class Reviewer extends Activity implements IButtonListener{
         mIsSelecting = false;
         mIsAnswering = true;
         if (mPrefTextSelection) {
-            mClipboard.setText("");
+            clipboardSetText("");
             if (mLookUpIcon.getVisibility() == View.VISIBLE) {
                 mLookUpIcon.setVisibility(View.GONE);
                 mLookUpIcon.setAnimation(ViewAnimation.fade(ViewAnimation.FADE_OUT, mFadeDuration, 0));        	
             }        	
         }
-        Deck deck = AnkiDroidApp.deck();
+        Deck deck = DeckManager.getMainDeck();
     	switch (ease) {
     		case Card.EASE_FAILED:
     		    mChosenAnswer.setText("\u2022");
@@ -1492,12 +1594,11 @@ public class Reviewer extends Activity implements IButtonListener{
         Themes.setContentStyle(mMainLayout, Themes.CALLER_REVIEWER);
 
         mCardContainer = (FrameLayout) findViewById(R.id.flashcard_frame);
-        mCardContainer.setVisibility(mConfigurationChanged ? View.VISIBLE : View.INVISIBLE);
 		setInAnimation(false);
 
         findViewById(R.id.top_bar).setOnClickListener(mCardStatisticsListener);
 
-        mCardFrame = (FrameLayout) findViewById(R.id.flashcard);
+        mCardFrame = (LinearLayout) findViewById(R.id.flashcard);
         mTouchLayer = (FrameLayout) findViewById(R.id.touch_layer);
         mTouchLayer.setOnTouchListener(mGestureListener);
     	if (mPrefTextSelection && mLongClickWorkaround) {
@@ -1507,20 +1608,44 @@ public class Reviewer extends Activity implements IButtonListener{
             mClipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);
         }
         mCardFrame.removeAllViews();
-        mCard = createWebView();
-        mCardFrame.addView(mCard);
+        if (mSimpleInterface) {
+        	mSimpleCard = new TextView(this);
+        	Themes.setRegularFont(mSimpleCard);
+        	mSimpleCard.setTextSize(mSimpleCard.getTextSize() * mDisplayFontSize / 100);
+        	mSimpleCard.setGravity(Gravity.CENTER);
+	        try {
+	        	mSetTextIsSelectable = TextView.class.getMethod("setTextIsSelectable", boolean.class);
+	        } catch (Throwable e) {
+	        	Log.i(AnkiDroidApp.TAG, "mSetTextIsSelectable could not be found due to a too low Android version (< 3.0)");
+	        	mSetTextIsSelectable = null;
+	        }
+        	if (mSetTextIsSelectable != null) {
+	            	try {
+						mSetTextIsSelectable.invoke(mSimpleCard, true);
+					} catch (Exception e) {
+						Log.e(AnkiDroidApp.TAG, e.toString());
+					}
+        	}
+        	mSimpleCard.setClickable(true);
+        	mCardFrame.addView(mSimpleCard);
+        } else {
+            mCard = createWebView();
+            mCardFrame.addView(mCard);
+        }
         if (!mChangeBorderStyle) {
             ((View)findViewById(R.id.flashcard_border)).setVisibility(View.VISIBLE);        	
         }
         
-        if (mCustomFontFiles.length != 0) {
+        if (mRefreshWebview && !mSimpleInterface) {
             mNextCard = createWebView();
             mNextCard.setVisibility(View.GONE);
-            mCardFrame.addView(mNextCard, 0);        	
+            mCardFrame.addView(mNextCard, 0);
+
+            mCustomFontStyle = getCustomFontsStyle() + getDefaultFontStyle();
         }
 
         // hunt for input issue 720, like android issue 3341
-        if (Integer.parseInt(android.os.Build.VERSION.SDK) < 8) {
+        if (Integer.parseInt(android.os.Build.VERSION.SDK) < 8 && !mSimpleInterface) {
             mCard.setFocusableInTouchMode(true);
         }
         
@@ -1537,24 +1662,36 @@ public class Reviewer extends Activity implements IButtonListener{
             mAccelLast = SensorManager.GRAVITY_EARTH;
         }
 
+        Resources res = getResources();
+
         mEase1 = (Button) findViewById(R.id.ease1);
-        mEase1.setOnClickListener(mSelectEaseHandler);
+        mEase1.setTextColor(res.getColor(R.color.next_time_failed_color));
+        mEase1Layout = (LinearLayout) findViewById(R.id.flashcard_layout_ease1);
+        mEase1Layout.setOnClickListener(mSelectEaseHandler);
 
         mEase2 = (Button) findViewById(R.id.ease2);
-        mEase2.setOnClickListener(mSelectEaseHandler);
+        mEase2.setTextColor(res.getColor(R.color.next_time_usual_color));
+        mEase2Layout = (LinearLayout) findViewById(R.id.flashcard_layout_ease2);
+        mEase2Layout.setOnClickListener(mSelectEaseHandler);
 
         mEase3 = (Button) findViewById(R.id.ease3);
-        mEase3.setOnClickListener(mSelectEaseHandler);
+        mEase3Layout = (LinearLayout) findViewById(R.id.flashcard_layout_ease3);
+        mEase3Layout.setOnClickListener(mSelectEaseHandler);
 
         mEase4 = (Button) findViewById(R.id.ease4);
-        mEase4.setOnClickListener(mSelectEaseHandler);
+        mEase4Layout = (LinearLayout) findViewById(R.id.flashcard_layout_ease4);
+        mEase4Layout.setOnClickListener(mSelectEaseHandler);
 
         mNext1 = (TextView) findViewById(R.id.nextTime1);
         mNext2 = (TextView) findViewById(R.id.nextTime2);
         mNext3 = (TextView) findViewById(R.id.nextTime3);
         mNext4 = (TextView) findViewById(R.id.nextTime4);
 
+        mNext1.setTextColor(res.getColor(R.color.next_time_failed_color));
+        mNext2.setTextColor(res.getColor(R.color.next_time_usual_color));
+
         if (!mshowNextReviewTime) {
+        	((TextView)findViewById(R.id.nextTimeflip)).setVisibility(View.GONE);
             mNext1.setVisibility(View.GONE);
             mNext2.setVisibility(View.GONE);
             mNext3.setVisibility(View.GONE);
@@ -1562,9 +1699,9 @@ public class Reviewer extends Activity implements IButtonListener{
         }
 
         mFlipCard = (Button) findViewById(R.id.flip_card);
-        mFlipCard.setOnClickListener(mFlipCardListener);
-        mFlipCard.setText(getResources().getString(R.string.show_answer));
-    	mDefaultButtonDrawable = new Drawable[]{mFlipCard.getBackground(), mEase1.getBackground(), mEase2.getBackground(), mEase3.getBackground(), mEase4.getBackground()};
+        mFlipCardLayout = (LinearLayout) findViewById(R.id.flashcard_layout_flip);
+        mFlipCardLayout.setOnClickListener(mFlipCardListener);
+
 
         mTextBarRed = (TextView) findViewById(R.id.red_number);
         mTextBarBlack = (TextView) findViewById(R.id.black_number);
@@ -1621,7 +1758,7 @@ public class Reviewer extends Activity implements IButtonListener{
 
 			@Override
 			public void onClick(View arg0) {
-				if (mClipboard.hasText()) {
+				if (clipboardHasText()) {
 					lookUp();
 				}
 			}
@@ -1645,7 +1782,14 @@ public class Reviewer extends Activity implements IButtonListener{
             webView.setFocusableInTouchMode(false);
         }
         Log.i(AnkiDroidApp.TAG, "Focusable = " + webView.isFocusable() + ", Focusable in touch mode = " + webView.isFocusableInTouchMode());
-
+        if (mSetScrollbarBarFading != null) {
+            try {
+            	mSetScrollbarBarFading.invoke(webView, false);
+            } catch (Throwable e) {
+            	Log.i(AnkiDroidApp.TAG, "setScrollbarFadingEnabled could not be set due to a too low Android version (< 2.1)");
+            	mSetScrollbarBarFading = null;
+            }
+        }
         mScaleInPercent = webView.getScale();
         return webView;
     }
@@ -1653,47 +1797,33 @@ public class Reviewer extends Activity implements IButtonListener{
 
     private void invertColors(boolean invert) {
         Resources res = getResources();        
-        int fgColor = invert ? res.getColor(R.color.foreground_color_inv) : res.getColor(R.color.black);
-        mCard.setBackgroundColor(mCurrentBackgroundColor);
-
-        if (mChangeBorderStyle) {
-            mMainLayout.setBackgroundColor(mCurrentBackgroundColor);
-            mFlipCard.setBackgroundDrawable(invert ? res.getDrawable(R.drawable.btn_keyboard_key_fulltrans_normal) : mDefaultButtonDrawable[0]);
-            mEase1.setBackgroundDrawable(invert ? res.getDrawable(R.drawable.btn_keyboard_key_fulltrans_normal) : mDefaultButtonDrawable[1]);
-            mEase2.setBackgroundDrawable(invert ? res.getDrawable(R.drawable.btn_keyboard_key_fulltrans_normal) : mDefaultButtonDrawable[2]);
-            mEase3.setBackgroundDrawable(invert ? res.getDrawable(R.drawable.btn_keyboard_key_fulltrans_normal) : mDefaultButtonDrawable[3]);
-            mEase4.setBackgroundDrawable(invert ? res.getDrawable(R.drawable.btn_keyboard_key_fulltrans_normal) : mDefaultButtonDrawable[4]);
+
+        int[] colors = Themes.setNightMode(this, mMainLayout, invert);
+        mForegroundColor = colors[0];
+        mNextTimeTextColor = mForegroundColor;
+        mNextTimeTextRecomColor = colors[1];
+
+        mFlipCard.setTextColor(mForegroundColor);
+        mNext4.setTextColor(mNextTimeTextColor);
+        mEase4.setTextColor(mNextTimeTextColor);
+        mCardTimer.setTextColor(mForegroundColor);
+        mTextBarBlack.setTextColor(mForegroundColor);
+        mTextBarBlue.setTextColor(invert ? res.getColor(R.color.textbar_blue_color_inv) : res.getColor(R.color.textbar_blue_color));
+
+        if (mSimpleInterface) {
+            mSimpleCard.setBackgroundColor(mCurrentBackgroundColor);
+            mSimpleCard.setTextColor(mForegroundColor);
         } else {
-            mMainLayout.setBackgroundResource(invert ? R.color.reviewer_background_night : R.color.reviewer_background);
-        	findViewById(R.id.flashcard_border).setBackgroundResource(invert ? R.drawable.blue_bg_webview_night : R.drawable.blue_bg_webview);
-            mFlipCard.setBackgroundDrawable(invert ? res.getDrawable(R.drawable.blue_btn_night) : mDefaultButtonDrawable[0]);
-            mEase1.setBackgroundDrawable(invert ? res.getDrawable(R.drawable.blue_btn_night) : mDefaultButtonDrawable[1]);
-            mEase2.setBackgroundDrawable(invert ? res.getDrawable(R.drawable.blue_btn_night) : mDefaultButtonDrawable[2]);
-            mEase3.setBackgroundDrawable(invert ? res.getDrawable(R.drawable.blue_btn_night) : mDefaultButtonDrawable[3]);
-            mEase4.setBackgroundDrawable(invert ? res.getDrawable(R.drawable.blue_btn_night) : mDefaultButtonDrawable[4]);
-        }
-        if (invert || mChangeBorderStyle) {
-            mNextTimeTextColor = invert ? res.getColor(R.color.next_time_usual_color_inv) : res.getColor(R.color.next_time_usual_color);
-            mNextTimeTextRecomColor = invert ? res.getColor(R.color.next_time_recommended_color_inv) : res.getColor(R.color.next_time_recommended_color);
-            mNext4.setTextColor(mNextTimeTextColor);
-            mCardTimer.setTextColor(fgColor);
-            mForegroundColor = fgColor;
-            mTextBarBlack.setTextColor(fgColor);
-            mTextBarBlue.setTextColor(invert ? res.getColor(R.color.textbar_blue_color_inv) : res.getColor(R.color.textbar_blue_color));
-
-            mFlipCard.setTextColor(fgColor);
-            mEase1.setTextColor(fgColor);
-            mEase2.setTextColor(fgColor);
-            mEase3.setTextColor(fgColor);
-            mEase4.setTextColor(fgColor);
-
-            fgColor = R.color.studyoptions_progressbar_frame_light;
-            int bgColor = R.color.studyoptions_progressbar_background_nightmode;
-            findViewById(R.id.progress_bars_border1).setBackgroundResource(fgColor);
-            findViewById(R.id.progress_bars_border2).setBackgroundResource(fgColor);
-            findViewById(R.id.progress_bars_back1).setBackgroundResource(bgColor);
-            findViewById(R.id.progress_bars_back2).setBackgroundResource(bgColor);
+            mCard.setBackgroundColor(mCurrentBackgroundColor);        	
         }
+
+        int fgColor = R.color.studyoptions_progressbar_frame_light;
+        int bgColor = R.color.studyoptions_progressbar_background_nightmode;
+        findViewById(R.id.progress_bars_border1).setBackgroundResource(fgColor);
+        findViewById(R.id.progress_bars_border2).setBackgroundResource(fgColor);
+        findViewById(R.id.progress_bars_back1).setBackgroundResource(bgColor);
+        findViewById(R.id.progress_bars_back2).setBackgroundResource(bgColor);
+
     }
 
 
@@ -1701,8 +1831,17 @@ public class Reviewer extends Activity implements IButtonListener{
         Resources res = getResources();
         boolean sessionComplete = false;
         boolean noMoreCards = false;
+
+        // if in background, actualise widget
+    	if (mInBackground) {
+    		updateBigWidget(false);
+        }
+
         // Check to see if session rep or time limit has been reached
-        Deck deck = AnkiDroidApp.deck();
+        Deck deck = DeckManager.getMainDeck();
+        if (deck == null) {
+        	return new boolean[] {false, false};
+        }
         long sessionRepLimit = deck.getSessionRepLimit();
         long sessionTime = deck.getSessionTimeLimit();
         String sessionMessage = null;
@@ -1727,24 +1866,23 @@ public class Reviewer extends Activity implements IButtonListener{
             sessionMessage = res.getString(R.string.session_time_limit_reached);
         } else if (mIsLastCard) {
         	noMoreCards = true;
-            mProgressDialog = ProgressDialog.show(Reviewer.this, "", getResources()
+            mProgressDialog = StyledProgressDialog.show(Reviewer.this, "", getResources()
                     .getString(R.string.saving_changes), true);
             setOutAnimation(true);
         } else {
             // session limits not reached, show next card
-            Card newCard = values[0].getCard();
+        	mCurrentCard = values[0].getCard();
 
             // If the card is null means that there are no more cards scheduled for review.
-            if (newCard == null) {
+            if (mCurrentCard == null) {
             	noMoreCards = true;
-                mProgressDialog = ProgressDialog.show(Reviewer.this, "", getResources()
+                mProgressDialog = StyledProgressDialog.show(Reviewer.this, "", getResources()
                         .getString(R.string.saving_changes), true);
                 setOutAnimation(false);
                 return new boolean[] {sessionComplete, noMoreCards};
             }
 
             // Start reviewing next card
-            mCurrentCard = newCard;
             if (mPrefWriteAnswers) { //only bother query deck if needed
             	String[] answer = mCurrentCard.getComparedFieldAnswer();
             	comparedFieldAnswer = answer[0];
@@ -1772,7 +1910,7 @@ public class Reviewer extends Activity implements IButtonListener{
         Resources res = getResources();
 
         // hide flipcard button
-        switchVisibility(mFlipCard, View.GONE);
+        switchVisibility(mFlipCardLayout, View.GONE);
 
         // Set correct label for each button
         if (mCurrentCard.isRev()) {
@@ -1788,16 +1926,24 @@ public class Reviewer extends Activity implements IButtonListener{
         }
 
         // Show buttons
-        switchVisibility(mEase1, View.VISIBLE);
-        switchVisibility(mEase2, View.VISIBLE);
-        switchVisibility(mEase3, View.VISIBLE);
-        switchVisibility(mEase4, View.VISIBLE);
+        switchVisibility(mEase1Layout, View.VISIBLE);
+        switchVisibility(mEase2Layout, View.VISIBLE);
+        switchVisibility(mEase3Layout, View.VISIBLE);
+        switchVisibility(mEase4Layout, View.VISIBLE);
         
         // Focus default button
         if (mCurrentCard.isRev()) {
-            mEase3.requestFocus();
+            mEase3Layout.requestFocus();
             mNext2.setTextColor(mNextTimeTextColor);
+            mEase2.setTextColor(mNextTimeTextColor);
             mNext3.setTextColor(mNextTimeTextRecomColor);
+            mEase3.setTextColor(mNextTimeTextRecomColor);
+        } else {
+            mEase2Layout.requestFocus();
+            mNext2.setTextColor(mNextTimeTextRecomColor);
+            mEase2.setTextColor(mNextTimeTextRecomColor);
+            mNext3.setTextColor(mNextTimeTextColor);
+            mEase3.setTextColor(mNextTimeTextColor);
         }
 
         // Show next review time
@@ -1815,10 +1961,10 @@ public class Reviewer extends Activity implements IButtonListener{
 
 
     private void hideEaseButtons() {
-    	switchVisibility(mEase1, View.GONE);
-    	switchVisibility(mEase2, View.GONE);
-    	switchVisibility(mEase3, View.GONE);
-    	switchVisibility(mEase4, View.GONE);
+    	switchVisibility(mEase1Layout, View.GONE);
+    	switchVisibility(mEase2Layout, View.GONE);
+    	switchVisibility(mEase3Layout, View.GONE);
+    	switchVisibility(mEase4Layout, View.GONE);
     	if (mshowNextReviewTime) {
     		int visibility = typeAnswer() ? View.GONE : View.INVISIBLE;
     		switchVisibility(mNext1, visibility);
@@ -1826,9 +1972,9 @@ public class Reviewer extends Activity implements IButtonListener{
     		switchVisibility(mNext3, visibility);
     		switchVisibility(mNext4, visibility);
     	}
-    	if (mFlipCard.getVisibility() != View.VISIBLE) {
-    		switchVisibility(mFlipCard, View.VISIBLE);
-        	mFlipCard.requestFocus();
+    	if (mFlipCardLayout.getVisibility() != View.VISIBLE) {
+    		switchVisibility(mFlipCardLayout, View.VISIBLE);
+    		mFlipCardLayout.requestFocus();
     	} else if (typeAnswer()) {
             mAnswerField.requestFocus();
 
@@ -1875,7 +2021,7 @@ public class Reviewer extends Activity implements IButtonListener{
         mTextBarBlack.setVisibility(View.VISIBLE);
         mTextBarBlue.setVisibility(View.VISIBLE);
         mChosenAnswer.setVisibility(View.VISIBLE);
-        mFlipCard.setVisibility(View.VISIBLE);
+        mFlipCardLayout.setVisibility(View.VISIBLE);
         
         if (mPrefWhiteboard) {
             mWhiteboard.setVisibility(mShowWhiteboard ? View.VISIBLE : View.GONE);
@@ -1900,7 +2046,7 @@ public class Reviewer extends Activity implements IButtonListener{
         mPrefFullscreenReview = preferences.getBoolean("fullscreenReview", true);
         mshowNextReviewTime = preferences.getBoolean("showNextReviewTime", true);
         mZoomEnabled = preferences.getBoolean("zoom", false);
-        mZeemoteEnabled = preferences.getBoolean("zeemote", false);
+//        mZeemoteEnabled = preferences.getBoolean("zeemote", false);
         mDisplayFontSize = preferences.getInt("relativeDisplayFontSize", CardModel.DEFAULT_FONT_SIZE_RATIO);
         mRelativeButtonSize = preferences.getInt("answerButtonSize", 100);
         mPrefHideQuestionInAnswer = Integer.parseInt(preferences.getString("hideQuestionInAnswer",
@@ -1925,14 +2071,15 @@ public class Reviewer extends Activity implements IButtonListener{
             mShakeIntensity = preferences.getInt("minShakeIntensity", 70);
 
             mGestureSwipeUp = Integer.parseInt(preferences.getString("gestureSwipeUp", "0"));
-            mGestureSwipeDown = Integer.parseInt(preferences.getString("gestureSwipeDown", "0"));
-            mGestureSwipeLeft = Integer.parseInt(preferences.getString("gestureSwipeLeft", "13"));
-            mGestureSwipeRight = Integer.parseInt(preferences.getString("gestureSwipeRight", "0"));
-            mGestureDoubleTap = Integer.parseInt(preferences.getString("gestureDoubleTap", "0"));
-            mGestureTapLeft = Integer.parseInt(preferences.getString("gestureTapLeft", "0"));
-            mGestureTapRight = Integer.parseInt(preferences.getString("gestureTapRight", "0"));
-            mGestureTapTop = Integer.parseInt(preferences.getString("gestureTapTop", "0"));
-            mGestureTapBottom = Integer.parseInt(preferences.getString("gestureTapBottom", "0"));
+         	mGestureSwipeDown = Integer.parseInt(preferences.getString("gestureSwipeDown", "0"));
+         	mGestureSwipeLeft = Integer.parseInt(preferences.getString("gestureSwipeLeft", "13"));
+         	mGestureSwipeRight = Integer.parseInt(preferences.getString("gestureSwipeRight", "0"));
+         	mGestureDoubleTap = Integer.parseInt(preferences.getString("gestureDoubleTap", "0"));
+         	mGestureTapLeft = Integer.parseInt(preferences.getString("gestureTapLeft", "0"));
+         	mGestureTapRight = Integer.parseInt(preferences.getString("gestureTapRight", "0"));
+         	mGestureTapTop = Integer.parseInt(preferences.getString("gestureTapTop", "0"));
+         	mGestureTapBottom = Integer.parseInt(preferences.getString("gestureTapBottom", "0"));
+         	mGestureLongclick = Integer.parseInt(preferences.getString("gestureLongclick", "0"));
         }
         mShowAnimations = preferences.getBoolean("themeAnimations", false);
         if (mShowAnimations) {
@@ -1950,13 +2097,19 @@ public class Reviewer extends Activity implements IButtonListener{
                 setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
             }
         }
-        
+
+        if (preferences.getBoolean("keepScreenOn", false)) {
+        	this.getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
+        }
+
+        mSimpleInterface = preferences.getBoolean("simpleInterface", false);
+
         return preferences;
     }
 
 
     private void setDueMessage() {
-    	Deck deck = AnkiDroidApp.deck();
+    	Deck deck = DeckManager.getMainDeck();
 		if (mCurrentCard != null && deck != null && deck.getScheduler().equals("reviewEarly") && mCurrentCard.getType() != Card.TYPE_FAILED) {
     		mChosenAnswer.setTextColor(mForegroundColor);
     		mChosenAnswer.setText(Utils.fmtTimeSpan(mCurrentCard.getCombinedDue() - Utils.now(), Utils.TIME_FORMAT_IN));				
@@ -1987,11 +2140,12 @@ public class Reviewer extends Activity implements IButtonListener{
 
 
     private void updateScreenCounts() {
-    	
-        Deck deck = AnkiDroidApp.deck();
-
+    	if (mCurrentCard == null) {
+    		return;
+    	}
+        Deck deck = DeckManager.getMainDeck();
         int eta = mCurrentScheduler.eta() / 60;
-        if (eta < 1) {
+        if (deck.hasFinishScheduler() || eta < 1) {
             setTitle(deck.getDeckName());
         } else {
             setTitle(getResources().getQuantityString(R.plurals.reviewer_window_title, eta, deck.getDeckName(), eta));
@@ -2034,7 +2188,7 @@ public class Reviewer extends Activity implements IButtonListener{
             mStatisticBarsMax = view.getWidth();
             mStatisticBarsHeight = view.getHeight();
         }
-        Deck deck = AnkiDroidApp.deck();
+        Deck deck = DeckManager.getMainDeck();
         Utils.updateProgressBars(this, mSessionProgressBar, deck.getSessionProgress(), mStatisticBarsMax, mStatisticBarsHeight, true, false);
         Utils.updateProgressBars(this, mSessionYesBar, deck.getProgress(false), mStatisticBarsMax, mStatisticBarsHeight, true);
     }
@@ -2048,8 +2202,8 @@ public class Reviewer extends Activity implements IButtonListener{
     private Runnable mShowQuestionTask = new Runnable() {
         public void run() {
             //Assume hitting the "Again" button when auto next question
-            if (mEase1.isEnabled() == true && mEase1.getVisibility() == View.VISIBLE) {
-		mEase1.performClick();
+            if (mEase1Layout.isEnabled() == true && mEase1Layout.getVisibility() == View.VISIBLE) {
+		mEase1Layout.performClick();
             }
         }
     };
@@ -2059,8 +2213,8 @@ public class Reviewer extends Activity implements IButtonListener{
             if (mPrefTimer) {
                 mCardTimer.stop();
             }
-            if (mFlipCard.isEnabled() == true && mFlipCard.getVisibility() == View.VISIBLE && !mIsAnswering) {
-		mFlipCard.performClick();
+            if (mFlipCardLayout.isEnabled() == true && mFlipCardLayout.getVisibility() == View.VISIBLE && !mIsAnswering) {
+		mFlipCardLayout.performClick();
             }
         }
     };
@@ -2078,15 +2232,6 @@ public class Reviewer extends Activity implements IButtonListener{
             mEase4.setHeight(mButtonHeight);
         }
 
-        // If the user wants to write the answer
-        if (typeAnswer()) {
-            mAnswerField.setVisibility(View.VISIBLE);
-
-            // Show soft keyboard
-            InputMethodManager inputMethodManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
-            inputMethodManager.showSoftInput(mAnswerField, InputMethodManager.SHOW_FORCED);
-        }
-
         String question = getQuestion();
 
         if(mPrefFixArabic) {
@@ -2094,14 +2239,34 @@ public class Reviewer extends Activity implements IButtonListener{
         }
         Log.i(AnkiDroidApp.TAG, "question: '" + question + "'");
 
-        String displayString = enrichWithQADiv(question, false);
-        // Show an horizontal line as separation when question is shown in answer
-        if (isQuestionDisplayed()) {
-            displayString = displayString + "<hr/>";
-        }
+        String displayString = "";
 
-        if (mSpeakText && Integer.valueOf(android.os.Build.VERSION.SDK) > 3) {
-            ReadText.setLanguageInformation(mCurrentCard.getOrd(), mCurrentCard.getOrd());
+        if (mSimpleInterface) {
+        	mCardContent = Html.fromHtml(question);
+        	if (mCardContent.length() == 0) {
+        		SpannableString hint = new SpannableString(getResources().getString(R.string.simple_interface_hint, R.string.card_details_question));
+        		hint.setSpan(new StyleSpan(Typeface.ITALIC), 0, mCardContent.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        		mCardContent = hint;
+        	}
+        } else {
+            // If the user wants to write the answer
+            if (typeAnswer()) {
+                mAnswerField.setVisibility(View.VISIBLE);
+
+                // Show soft keyboard
+                InputMethodManager inputMethodManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
+                inputMethodManager.showSoftInput(mAnswerField, InputMethodManager.SHOW_FORCED);
+            }
+
+            displayString = enrichWithQADiv(question, false);
+            // Show an horizontal line as separation when question is shown in answer
+            if (isQuestionDisplayed()) {
+                displayString = displayString + "<hr/>";
+            }
+
+            if (mSpeakText && Integer.valueOf(android.os.Build.VERSION.SDK) > 3) {
+                ReadText.setLanguageInformation(Model.getModel(DeckManager.getMainDeck(), mCurrentCard.getCardModelId(), false).getId(), mCurrentCard.getCardModelId());          
+            }
         }
 
         updateCard(displayString);
@@ -2125,59 +2290,82 @@ public class Reviewer extends Activity implements IButtonListener{
 
         sDisplayAnswer = true;
         setFlipCardAnimation();
-        
-        Sound.stopSounds();
+
+        String answer = getAnswer(), question = getQuestion();
 
         String displayString = "";
         
-        String answer = getAnswer(), question = getQuestion();
-        if(mPrefFixArabic) {
-        	// reshape
-        	answer = ArabicUtilities.reshapeSentence(answer, true);
-        	question = ArabicUtilities.reshapeSentence(question, true);
-        }
+        if (mSimpleInterface) {
+        	SpannableStringBuilder sb = new SpannableStringBuilder();
+		if (isQuestionDisplayed()) {
+	        	Spanned ques = Html.fromHtml(question);
+	        	if (ques.length() == 0) {
+	        		ques = new SpannableString(getResources().getString(R.string.simple_interface_hint, R.string.card_details_question));
+	        		((SpannableString)ques).setSpan(new StyleSpan(Typeface.ITALIC), 0, mCardContent.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+			}
+	        	sb.append(ques);
+	        	sb.append("\n─────\n");
+        	}
 
-        // If the user wrote an answer
-        if (typeAnswer()) {
-            mAnswerField.setVisibility(View.GONE);
-            if (mCurrentCard != null) {
-                // Obtain the user answer and the correct answer
-                String userAnswer = mAnswerField.getText().toString();         
-                Matcher matcher = sSpanPattern.matcher(Utils.stripHTMLMedia(ArabicUtilities.reshapeSentence(comparedFieldAnswer, true)));
-                String correctAnswer = matcher.replaceAll("");
-                matcher = sBrPattern.matcher(correctAnswer);
-                correctAnswer = matcher.replaceAll("\n");
-                matcher = Sound.sSoundPattern.matcher(correctAnswer);
-                correctAnswer = matcher.replaceAll("");
-                matcher = Image.sImagePattern.matcher(correctAnswer);
-                correctAnswer = matcher.replaceAll("");
-                Log.i(AnkiDroidApp.TAG, "correct answer = " + correctAnswer);
-
-                // Obtain the diff and send it to updateCard
-                DiffEngine diff = new DiffEngine();
-
-                StringBuffer span = new StringBuffer();
-                span.append("<span class=\"").append(comparedFieldClass).append("\">");
-                span.append(diff.diff_prettyHtml(diff.diff_main(userAnswer, correctAnswer)));
-                span.append("</span>");
-                span.append("<br/>").append(answer);
-                displayString = enrichWithQADiv(span.toString(), true);
+        	Spanned ans = Html.fromHtml(answer);
+        	if (ans.length() == 0) {
+        		SpannableString hint = new SpannableString(getResources().getString(R.string.simple_interface_hint, R.string.card_details_answer));
+        		hint.setSpan(new StyleSpan(Typeface.ITALIC), 0, hint.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        		ans = hint;
+        	}
+        	sb.append(ans);
+        	mCardContent = sb;
+        } else {
+            Sound.stopSounds();
+
+            if(mPrefFixArabic) {
+            	// reshape
+            	answer = ArabicUtilities.reshapeSentence(answer, true);
+            	question = ArabicUtilities.reshapeSentence(question, true);
             }
 
-            // Hide soft keyboard
-            InputMethodManager inputMethodManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
-            inputMethodManager.hideSoftInputFromWindow(mAnswerField.getWindowToken(), 0);
-        } else {
-            displayString = enrichWithQADiv(answer, true);
-        }
+            // If the user wrote an answer
+            if (typeAnswer()) {
+                mAnswerField.setVisibility(View.GONE);
+                if (mCurrentCard != null) {
+                    // Obtain the user answer and the correct answer
+                    String userAnswer = mAnswerField.getText().toString();         
+                    Matcher matcher = sSpanPattern.matcher(Utils.stripHTMLMedia(ArabicUtilities.reshapeSentence(comparedFieldAnswer, true)));
+                    String correctAnswer = matcher.replaceAll("");
+                    matcher = sBrPattern.matcher(correctAnswer);
+                    correctAnswer = matcher.replaceAll("\n");
+                    matcher = Sound.sSoundPattern.matcher(correctAnswer);
+                    correctAnswer = matcher.replaceAll("");
+                    matcher = Image.sImagePattern.matcher(correctAnswer);
+                    correctAnswer = matcher.replaceAll("");
+                    Log.i(AnkiDroidApp.TAG, "correct answer = " + correctAnswer);
+
+                    // Obtain the diff and send it to updateCard
+                    DiffEngine diff = new DiffEngine();
+
+                    StringBuffer span = new StringBuffer();
+                    span.append("<span class=\"").append(comparedFieldClass).append("\">");
+                    span.append(diff.diff_prettyHtml(diff.diff_main(userAnswer, correctAnswer)));
+                    span.append("</span>");
+                    span.append("<br/>").append(answer);
+                    displayString = enrichWithQADiv(span.toString(), true);
+                }
 
-        // Depending on preferences do or do not show the question
-        if (isQuestionDisplayed()) {
-            StringBuffer sb = new StringBuffer();
-            sb.append(enrichWithQADiv(question, false));
-            sb.append("<a name=\"question\"></a><hr/>");
-            sb.append(displayString);
-            displayString = sb.toString();
+                // Hide soft keyboard
+                InputMethodManager inputMethodManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
+                inputMethodManager.hideSoftInputFromWindow(mAnswerField.getWindowToken(), 0);
+            } else {
+                displayString = enrichWithQADiv(answer, true);
+            }
+
+            // Depending on preferences do or do not show the question
+            if (isQuestionDisplayed()) {
+                StringBuffer sb = new StringBuffer();
+                sb.append(enrichWithQADiv(question, false));
+                sb.append("<a name=\"question\"></a><hr/>");
+                sb.append(displayString);
+                displayString = sb.toString();
+            }
         }
 
         mIsSelecting = false;
@@ -2195,6 +2383,11 @@ public class Reviewer extends Activity implements IButtonListener{
     private void updateCard(String content) {
         Log.i(AnkiDroidApp.TAG, "updateCard");
 
+        if (mSimpleInterface) {
+        	fillFlashcard(mShowAnimations);
+        	return;
+        }
+
         mBaseUrl = "";
         Boolean isJapaneseModel = false;
         
@@ -2204,10 +2397,14 @@ public class Reviewer extends Activity implements IButtonListener{
         
         // Add CSS for font color and font size
         if (mCurrentCard != null) {
-            final String japaneseModelTag = "Japanese";
-
-            Deck currentDeck = AnkiDroidApp.deck();
+        	final String japaneseModelTag = "Japanese";
+        	
+            Deck currentDeck = DeckManager.getMainDeck();
             Model myModel = Model.getModel(currentDeck, mCurrentCard.getCardModelId(), false);
+		if (myModel == null) {
+			Log.e(AnkiDroidApp.TAG, "updateCard - no Model could be fetched. Closing Reviewer and showing db-error dialog");
+	                closeReviewer(RESULT_ANSWERING_ERROR, true);			
+		}
             mBaseUrl = Utils.getBaseUrl(mMediaDir, myModel, currentDeck);
             int nightBackground = Themes.getNightModeCardBackground(this);
             content = myModel.getCSSForFontColorSize(mCurrentCard.getCardModelId(), mDisplayFontSize, mNightMode, nightBackground) + Model.invertColors(content, mNightMode);
@@ -2243,8 +2440,8 @@ public class Reviewer extends Activity implements IButtonListener{
         }
 
         // Parse out the LaTeX images
-//        question = LaTeX.parseLaTeX(AnkiDroidApp.deck(), question);
-//        answer = LaTeX.parseLaTeX(AnkiDroidApp.deck(), answer);
+        question = LaTeX.parseLaTeX(DeckManager.getMainDeck(), question);
+        answer = LaTeX.parseLaTeX(DeckManager.getMainDeck(), answer);
 
         // If ruby annotation support is activated, then parse and handle:
         // Strip kanji in question, add furigana in answer
@@ -2265,12 +2462,10 @@ public class Reviewer extends Activity implements IButtonListener{
 		
         Log.i(AnkiDroidApp.TAG, "content card = \n" + content);
         StringBuilder style = new StringBuilder();
-        style.append(getCustomFontsStyle());
-        style.append(getDefaultFontStyle());
-        style.append(getDeckStyle(AnkiDroidApp.deck().getDeckPath()));
+        style.append(mCustomFontStyle);
+        style.append(getDeckStyle(mCurrentCard.mDeck.getDeckPath()));
         Log.i(AnkiDroidApp.TAG, "::style::" + style);
-        mCardContent =
-            mCardTemplate.replace("::content::", content).replace("::style::", style.toString());
+        mCardContent = new SpannedString(mCardTemplate.replace("::content::", content).replace("::style::", style.toString()));
         // Log.i(AnkiDroidApp.TAG, "card html = \n" + card);
         Log.i(AnkiDroidApp.TAG, "base url = " + mBaseUrl );
 
@@ -2312,9 +2507,11 @@ public class Reviewer extends Activity implements IButtonListener{
     public void fillFlashcard(boolean flip) {
     	if (!flip) {
 	        Log.i(AnkiDroidApp.TAG, "base url = " + mBaseUrl);
-	        if (mCustomFontFiles.length != 0) {
+        	if (mSimpleInterface) {
+        		mSimpleCard.setText(mCardContent);
+        	} else if (mRefreshWebview) {
 	            mNextCard.setBackgroundColor(mCurrentBackgroundColor);
-	            mNextCard.loadDataWithBaseURL(mBaseUrl, mCardContent, "text/html", "utf-8", null);
+	            mNextCard.loadDataWithBaseURL(mBaseUrl, mCardContent.toString(), "text/html", "utf-8", null);
 	            mNextCard.setVisibility(View.VISIBLE);
 	            mCardFrame.removeView(mCard);
 	            mCard.destroy();
@@ -2327,7 +2524,7 @@ public class Reviewer extends Activity implements IButtonListener{
 	            	mCard.setFocusableInTouchMode(true);
 	            }
 	        } else {
-	            mCard.loadDataWithBaseURL(mBaseUrl, mCardContent, "text/html", "utf-8", null);
+	            mCard.loadDataWithBaseURL(mBaseUrl, mCardContent.toString(), "text/html", "utf-8", null);
 	            mCard.setBackgroundColor(mCurrentBackgroundColor);
 	        }
 	        if (mChangeBorderStyle) {
@@ -2354,10 +2551,8 @@ public class Reviewer extends Activity implements IButtonListener{
 	            	}
 		        }	        	
 	        }
-	        if (!mShowAnimations && mCardContainer.getVisibility() == View.INVISIBLE) {
+	        if (!mShowAnimations && mCardTimer.getVisibility() == View.INVISIBLE) {
     	    	switchTopBarVisibility(View.VISIBLE);
-				mCardContainer.setVisibility(View.VISIBLE);
-				mCardContainer.setAnimation(ViewAnimation.fade(ViewAnimation.FADE_IN, mFadeDuration, 0));
 	        }
     		if (!sDisplayAnswer) {
         		updateForNewCard();
@@ -2371,14 +2566,14 @@ public class Reviewer extends Activity implements IButtonListener{
     		boolean directionToLeft = true;
     		switch (mNextAnimation) {
     		case ANIMATION_TURN:
-    			rotation = new Animation3D(mCard.getWidth(), mCard.getHeight(), 9, Animation3D.ANIMATION_TURN, true, true, this);
+    			rotation = new Animation3D(mCardContainer.getWidth(), mCardContainer.getHeight(), 9, Animation3D.ANIMATION_TURN, true, true, this);
     			rotation.setDuration(mAnimationDurationTurn);
     			rotation.setInterpolator(new AccelerateDecelerateInterpolator());
     			break;
     		case ANIMATION_NEXT_CARD_FROM_LEFT:
     			directionToLeft = false;
     		case ANIMATION_NEXT_CARD_FROM_RIGHT:
-    			rotation = new Animation3D(mCard.getWidth(), mCard.getHeight(), 0, Animation3D.ANIMATION_EXCHANGE_CARD, directionToLeft, true, this);
+    			rotation = new Animation3D(mCardContainer.getWidth(), mCardContainer.getHeight(), 0, Animation3D.ANIMATION_EXCHANGE_CARD, directionToLeft, true, this);
     			rotation.setDuration(mAnimationDurationMove);
     			rotation.setInterpolator(new AccelerateDecelerateInterpolator());
     			break;
@@ -2386,7 +2581,7 @@ public class Reviewer extends Activity implements IButtonListener{
     			directionToLeft = false;
     		case ANIMATION_SLIDE_OUT_TO_LEFT:
         		fillFlashcard(false);
-    			rotation = new Animation3D(mCard.getWidth(), mCard.getHeight(), 0, Animation3D.ANIMATION_SLIDE_OUT_CARD, directionToLeft, true, this);
+    			rotation = new Animation3D(mCardContainer.getWidth(), mCardContainer.getHeight(), 0, Animation3D.ANIMATION_SLIDE_OUT_CARD, directionToLeft, true, this);
     			rotation.setDuration(mAnimationDurationMove);
     			rotation.setInterpolator(new AccelerateInterpolator());
     	    	switchTopBarVisibility(View.INVISIBLE);
@@ -2395,7 +2590,7 @@ public class Reviewer extends Activity implements IButtonListener{
     			directionToLeft = false;
     		case ANIMATION_SLIDE_IN_FROM_RIGHT:
         		fillFlashcard(false);
-    			rotation = new Animation3D(mCard.getWidth(), mCard.getHeight(), 0, Animation3D.ANIMATION_SLIDE_IN_CARD, directionToLeft, true, this);
+    			rotation = new Animation3D(mCardContainer.getWidth(), mCardContainer.getHeight(), 0, Animation3D.ANIMATION_SLIDE_IN_CARD, directionToLeft, true, this);
     			rotation.setDuration(mAnimationDurationMove);
     			rotation.setInterpolator(new DecelerateInterpolator());
     	    	switchTopBarVisibility(View.VISIBLE);
@@ -2471,10 +2666,10 @@ public class Reviewer extends Activity implements IButtonListener{
      */
     private String getCustomFontsStyle() {
       StringBuilder builder = new StringBuilder();
-      for (File fontFile : mCustomFontFiles) {
+      for (String fontPath : mCustomFontFiles) {
         String fontFace = String.format(
             "@font-face {font-family: \"%s\"; src: url(\"file://%s\");}",
-            Utils.removeExtension(fontFile.getName()), fontFile.getAbsolutePath());
+            Utils.removeExtension((new File(fontPath)).getName()), fontPath);
         Log.d(AnkiDroidApp.TAG, "adding to style: " + fontFace);
         builder.append(fontFace);
         builder.append('\n');
@@ -2507,11 +2702,8 @@ public class Reviewer extends Activity implements IButtonListener{
                 return true;
 
             case HQIA_CARD_MODEL:
-                try {
-                    return !mCurrentCard.getTemplate().getString("hideQ").equals("True");
-                } catch (JSONException e) {
-                    throw new RuntimeException(e);
-                }
+                return (Model.getModel(DeckManager.getMainDeck(), mCurrentCard.getCardModelId(), false).getCardModel(
+                        mCurrentCard.getCardModelId()).isQuestionInAnswer());
 
             default:
                 return true;
@@ -2683,42 +2875,42 @@ public class Reviewer extends Activity implements IButtonListener{
 
     private void unblockControls() {
         mCardFrame.setEnabled(true);
-        mFlipCard.setEnabled(true);
+        mFlipCardLayout.setEnabled(true);
 
         switch (mCurrentEase) {
-            case EASE_FAILED:
-                mEase1.setClickable(true);
-                mEase2.setEnabled(true);
-                mEase3.setEnabled(true);
-                mEase4.setEnabled(true);
+            case Card.EASE_FAILED:
+                mEase1Layout.setClickable(true);
+                mEase2Layout.setEnabled(true);
+                mEase3Layout.setEnabled(true);
+                mEase4Layout.setEnabled(true);
                 break;
 
-            case EASE_HARD:
-                mEase1.setEnabled(true);
-                mEase2.setClickable(true);
-                mEase3.setEnabled(true);
-                mEase4.setEnabled(true);
+            case Card.EASE_HARD:
+                mEase1Layout.setEnabled(true);
+                mEase2Layout.setClickable(true);
+                mEase3Layout.setEnabled(true);
+                mEase4Layout.setEnabled(true);
                 break;
 
-            case EASE_MID:
-                mEase1.setEnabled(true);
-                mEase2.setEnabled(true);
-                mEase3.setClickable(true);
-                mEase4.setEnabled(true);
+            case Card.EASE_MID:
+                mEase1Layout.setEnabled(true);
+                mEase2Layout.setEnabled(true);
+                mEase3Layout.setClickable(true);
+                mEase4Layout.setEnabled(true);
                 break;
 
-            case EASE_EASY:
-                mEase1.setEnabled(true);
-                mEase2.setEnabled(true);
-                mEase3.setEnabled(true);
-                mEase4.setClickable(true);
+            case Card.EASE_EASY:
+                mEase1Layout.setEnabled(true);
+                mEase2Layout.setEnabled(true);
+                mEase3Layout.setEnabled(true);
+                mEase4Layout.setClickable(true);
                 break;
 
             default:
-                mEase1.setEnabled(true);
-                mEase2.setEnabled(true);
-                mEase3.setEnabled(true);
-                mEase4.setEnabled(true);
+                mEase1Layout.setEnabled(true);
+                mEase2Layout.setEnabled(true);
+                mEase3Layout.setEnabled(true);
+                mEase4Layout.setEnabled(true);
                 break;
         }
 
@@ -2739,43 +2931,43 @@ public class Reviewer extends Activity implements IButtonListener{
 
     private void blockControls() {
         mCardFrame.setEnabled(false);
-        mFlipCard.setEnabled(false);
+        mFlipCardLayout.setEnabled(false);
         mTouchLayer.setVisibility(View.INVISIBLE);
 
         switch (mCurrentEase) {
-            case EASE_FAILED:
-                mEase1.setClickable(false);
-                mEase2.setEnabled(false);
-                mEase3.setEnabled(false);
-                mEase4.setEnabled(false);
+            case Card.EASE_FAILED:
+                mEase1Layout.setClickable(false);
+                mEase2Layout.setEnabled(false);
+                mEase3Layout.setEnabled(false);
+                mEase4Layout.setEnabled(false);
                 break;
 
-            case EASE_HARD:
-                mEase1.setEnabled(false);
-                mEase2.setClickable(false);
-                mEase3.setEnabled(false);
-                mEase4.setEnabled(false);
+            case Card.EASE_HARD:
+                mEase1Layout.setEnabled(false);
+                mEase2Layout.setClickable(false);
+                mEase3Layout.setEnabled(false);
+                mEase4Layout.setEnabled(false);
                 break;
 
-            case EASE_MID:
-                mEase1.setEnabled(false);
-                mEase2.setEnabled(false);
-                mEase3.setClickable(false);
-                mEase4.setEnabled(false);
+            case Card.EASE_MID:
+                mEase1Layout.setEnabled(false);
+                mEase2Layout.setEnabled(false);
+                mEase3Layout.setClickable(false);
+                mEase4Layout.setEnabled(false);
                 break;
 
-            case EASE_EASY:
-                mEase1.setEnabled(false);
-                mEase2.setEnabled(false);
-                mEase3.setEnabled(false);
-                mEase4.setClickable(false);
+            case Card.EASE_EASY:
+                mEase1Layout.setEnabled(false);
+                mEase2Layout.setEnabled(false);
+                mEase3Layout.setEnabled(false);
+                mEase4Layout.setClickable(false);
                 break;
 
             default:
-                mEase1.setEnabled(false);
-                mEase2.setEnabled(false);
-                mEase3.setEnabled(false);
-                mEase4.setEnabled(false);
+                mEase1Layout.setEnabled(false);
+                mEase2Layout.setEnabled(false);
+                mEase3Layout.setEnabled(false);
+                mEase4Layout.setEnabled(false);
                 break;
         }
 
@@ -2812,7 +3004,11 @@ public class Reviewer extends Activity implements IButtonListener{
     private void selectAndCopyText() {
         try {
             KeyEvent shiftPressEvent = new KeyEvent(0, 0, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_SHIFT_LEFT, 0, 0);
-            shiftPressEvent.dispatch(mCard);
+            if (mSimpleInterface) {
+            	shiftPressEvent.dispatch(mSimpleCard);
+            } else {            	
+                shiftPressEvent.dispatch(mCard);
+            }
             shiftPressEvent.isShiftPressed();
             mIsSelecting = true;
         } catch (Exception e) {
@@ -2821,6 +3017,26 @@ public class Reviewer extends Activity implements IButtonListener{
     }
 
 
+    public boolean getRefreshWebviewAndInitializeWebviewVariables() {
+    	mCustomFontFiles = Utils.getCustomFonts(getBaseContext());
+		for (String s : new String[] {"nook"}) {
+			if  (android.os.Build.DEVICE.toLowerCase().indexOf(s) != -1 || android.os.Build.MODEL.toLowerCase().indexOf(s) != -1) {
+				return true;
+			}
+		}
+        try {
+        	// this must not be executed on nook (causes fc)
+        	mSetScrollbarBarFading = WebView.class.getMethod("setScrollbarFadingEnabled", boolean.class);
+        } catch (Throwable e) {
+        	Log.i(AnkiDroidApp.TAG, "setScrollbarFadingEnabled could not be found due to a too low Android version (< 2.1)");
+        }
+		if (mCustomFontFiles.length != 0) {
+			return true;
+		}
+		return false;
+    }
+
+
     /**
      * Setup media. Try to detect if we're using dropbox and set the mediaPrefix accordingly. Then set the media
      * directory.
@@ -2946,19 +3162,19 @@ public class Reviewer extends Activity implements IButtonListener{
 			}
     		break;
     	case GESTURE_EXIT:
-       	 	closeReviewer();
+       	 	closeReviewer(RESULT_DEFAULT, false);
     		break;
     	case GESTURE_UNDO:
-    		if (AnkiDroidApp.deck().undoAvailable()) {
+    		if (DeckManager.getMainDeck().undoAvailable()) {
     			setNextCardAnimation(true);
         		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_UNDO, mUpdateCardHandler, new DeckTask.TaskData(UPDATE_CARD_SHOW_QUESTION,
-                        AnkiDroidApp.deck(), mCurrentCard.getId(), false));    			
+                        DeckManager.getMainDeck(), mCurrentCard.getId(), false));    			
     		}
     		break;
     	case GESTURE_REDO:
-    		if (AnkiDroidApp.deck().redoAvailable()) {
+    		if (DeckManager.getMainDeck().redoAvailable()) {
                 DeckTask.launchDeckTask(DeckTask.TASK_TYPE_REDO, mUpdateCardHandler, new DeckTask.TaskData(UPDATE_CARD_SHOW_QUESTION,
-                        AnkiDroidApp.deck(), mCurrentCard.getId(), false));    			
+                        DeckManager.getMainDeck(), mCurrentCard.getId(), false));    			
     		}
     		break;
     	case GESTURE_EDIT:
@@ -2966,7 +3182,7 @@ public class Reviewer extends Activity implements IButtonListener{
     		break;
     	case GESTURE_MARK:
             DeckTask.launchDeckTask(DeckTask.TASK_TYPE_MARK_CARD, mMarkCardHandler, new DeckTask.TaskData(0,
-                    AnkiDroidApp.deck(), mCurrentCard));
+                    DeckManager.getMainDeck(), mCurrentCard));
     		break;
     	case GESTURE_LOOKUP:
     		lookUpOrSelectText();
@@ -2974,12 +3190,12 @@ public class Reviewer extends Activity implements IButtonListener{
     	case GESTURE_BURY:
         	setNextCardAnimation(false);
             DeckTask.launchDeckTask(DeckTask.TASK_TYPE_BURY_CARD, mAnswerCardHandler, new DeckTask.TaskData(0,
-                    AnkiDroidApp.deck(), mCurrentCard));
+                    DeckManager.getMainDeck(), mCurrentCard));
     		break;
     	case GESTURE_SUSPEND:
         	setNextCardAnimation(false);
     		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_SUSPEND_CARD, mAnswerCardHandler, new DeckTask.TaskData(0,
-                    AnkiDroidApp.deck(), mCurrentCard));
+                    DeckManager.getMainDeck(), mCurrentCard));
     		break;
     	case GESTURE_DELETE:
     		showDeleteCardDialog();
@@ -3025,18 +3241,38 @@ public class Reviewer extends Activity implements IButtonListener{
     }
 
 
-    private void closeReviewer() {
-	mTimeoutHandler.removeCallbacks(mShowAnswerTask);
-	mTimeoutHandler.removeCallbacks(mShowQuestionTask);
-	mTimerHandler.removeCallbacks(removeChosenAnswerText);
-	longClickHandler.removeCallbacks(longClickTestRunnable);
-	longClickHandler.removeCallbacks(startSelection);
+    private String nextInterval(int ease) {
+        Resources res = getResources();
 
-    	setOutAnimation(true);    		
-    	mClosing = true;
-        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_SAVE_DECK, mSaveAndResetDeckHandler, new DeckTask.TaskData(AnkiDroidApp.deck(), 0));
+        if (ease == 1){
+        	return res.getString(R.string.soon);
+        } else {
+        	return Utils.fmtTimeSpan(mCurrentCard.nextInterval(mCurrentCard, ease) * 86400, Utils.TIME_FORMAT_DEFAULT);
+        }
     }
-    
+
+
+    private void closeReviewer(int result, boolean saveDeck) {
+    	mTimeoutHandler.removeCallbacks(mShowAnswerTask);
+		mTimeoutHandler.removeCallbacks(mShowQuestionTask);
+		mTimerHandler.removeCallbacks(removeChosenAnswerText);
+		longClickHandler.removeCallbacks(longClickTestRunnable);
+		longClickHandler.removeCallbacks(startLongClickAction);
+
+		Reviewer.this.setResult(result);
+
+		setOutAnimation(true);    		
+
+		updateBigWidget(!mCardFrame.isEnabled());
+
+        if (saveDeck) {
+            DeckTask.launchDeckTask(DeckTask.TASK_TYPE_SAVE_DECK, mSaveAndResetDeckHandler, new DeckTask.TaskData(DeckManager.getMainDeck(), 0));
+    	} else {
+    		finish();
+    		ActivityTransitionAnimation.slide(Reviewer.this, ActivityTransitionAnimation.RIGHT);
+    	}
+    }
+
     /** Fixing bug 720: <input> focus, thanks to pablomouzo on android issue 7189*/
     class MyWebView extends WebView {
 
@@ -3117,8 +3353,8 @@ public class Reviewer extends Activity implements IButtonListener{
     	@Override
     	public boolean onSingleTapConfirmed(MotionEvent e) {
     		if (mGesturesEnabled && !mIsSelecting) {
-    			int height = mCard.getHeight();
-    			int width = mCard.getWidth();
+    			int height = mTouchLayer.getHeight();
+    			int width = mTouchLayer.getWidth();
     			float posX = e.getX();
     			float posY = e.getY();
     			if (posX > posY / height * width) {
@@ -3137,7 +3373,7 @@ public class Reviewer extends Activity implements IButtonListener{
  			}
     		mIsSelecting = false;
     		if (mPrefTextSelection && mClipboard != null) {
-                if (mClipboard.getText().length() != 0 && Lookup.isAvailable()) {
+                if (clipboardGetText().length() != 0 && Lookup.isAvailable()) {
                 	if (mLookUpIcon.getVisibility() != View.VISIBLE) {
             			mLookUpIcon.setVisibility(View.VISIBLE);
                         mLookUpIcon.setAnimation(ViewAnimation.fade(ViewAnimation.FADE_IN, mFadeDuration, 0));                		
@@ -3154,12 +3390,14 @@ public class Reviewer extends Activity implements IButtonListener{
     	
         @Override
         public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
-            if (mCard.getScrollY() != 0) {
-                mIsYScrolling = true;
-            }
-            if (mCard.getScrollX() != 0) {
-                mIsXScrolling = true;
-            }
+        	if (!mSimpleInterface) {
+            	if (mCard.getScrollY() != 0) {
+            		mIsYScrolling = true;        		
+            	}
+            	if (mCard.getScrollX() != 0) {
+            		mIsXScrolling = true;
+            	}        		
+        	}
             return super.onScroll(e1, e2, distanceX, distanceY);
         }
 
diff --git a/src/com/ichi2/anki/SharedDeckPicker.java b/src/com/ichi2/anki/SharedDeckPicker.java
index e6778d729a..eaf3abbb46 100644
--- a/src/com/ichi2/anki/SharedDeckPicker.java
+++ b/src/com/ichi2/anki/SharedDeckPicker.java
@@ -15,7 +15,6 @@
 package com.ichi2.anki;
 
 import android.app.Activity;
-import android.app.ProgressDialog;
 import android.content.BroadcastReceiver;
 import android.content.ComponentName;
 import android.content.Context;
@@ -55,6 +54,7 @@ import com.ichi2.anki.services.ISharedDeckServiceCallback;
 import com.ichi2.async.Connection;
 import com.ichi2.async.Connection.Payload;
 import com.ichi2.themes.StyledDialog;
+import com.ichi2.themes.StyledProgressDialog;
 import com.ichi2.themes.Themes;
 
 import java.util.ArrayList;
@@ -72,7 +72,7 @@ public class SharedDeckPicker extends Activity {
      */
     private BroadcastReceiver mUnmountReceiver = null;
 
-    private ProgressDialog mProgressDialog;
+    private StyledProgressDialog mProgressDialog;
     private StyledDialog mNoConnectionAlert;
     private StyledDialog mConnectionErrorAlert;
 
@@ -510,7 +510,7 @@ public class SharedDeckPicker extends Activity {
         @Override
         public void onPreExecute() {
             if (mProgressDialog == null || !mProgressDialog.isShowing()) {
-                mProgressDialog = ProgressDialog.show(SharedDeckPicker.this, "",
+                mProgressDialog = StyledProgressDialog.show(SharedDeckPicker.this, "",
                         getResources().getString(R.string.loading_shared_decks), true, true, new DialogInterface.OnCancelListener() {
                     @Override
                     public void onCancel(DialogInterface dialog) {
diff --git a/src/com/ichi2/anki/Statistics.java b/src/com/ichi2/anki/Statistics.java
index 2eae059d0e..5f7b80c329 100644
--- a/src/com/ichi2/anki/Statistics.java
+++ b/src/com/ichi2/anki/Statistics.java
@@ -132,17 +132,8 @@ public class Statistics {
     public static boolean refreshAllDeckStatistics(Context context, String[] deckPaths, int type, int period,
             String title) {
         initVariables(context, type, period, title);
-        Deck currentDeck = AnkiDroidApp.deck();
-        String currentDeckPath = null;
-        if (currentDeck != null) {
-        	currentDeckPath = currentDeck.getDeckPath();
-        }
-    	for (String dp : deckPaths) {
-    		if (currentDeckPath != null && dp.equals(currentDeckPath)) {
-    			sDeck = currentDeck;
-    		} else {
-                sDeck = Deck.openDeck(dp);    			
-    		}
+     	for (String dp : deckPaths) {
+    		sDeck = DeckManager.getDeck(dp, DeckManager.REQUESTING_ACTIVITY_STATISTICS);
             if (sDeck == null) {
                 continue;
             }
@@ -170,16 +161,16 @@ public class Statistics {
     		} else {
                 double[][] seriesList;
                 seriesList = getSeriesList(context, type, period);
-                sDeck.closeDeck(false);
                 for (int i = 0; i < sSeriesList.length; i++) {
                     for (int j = 0; j < period; j++) {
                     	sSeriesList[i][j] += seriesList[i][j];
                     }        	
                 }    			
     		}
+            DeckManager.closeDeck(dp, DeckManager.REQUESTING_ACTIVITY_STATISTICS, false);
     	}
         if (type == TYPE_DECK_SUMMARY) {
-        	return sDeckSummaryValues != null ? true : false;
+        	return (sDeckSummaryValues != null && sDeckSummaryValues.size() > 0) ? true : false;
         } else {
         	return sSeriesList != null ? true : false;        	
         }
@@ -329,6 +320,7 @@ public class Statistics {
        	builder.append(res.getString(R.string.deck_summary_news)).append(" ").append(res.getString(R.string.deck_summary_cards_per_day, getFraction(newsLastYear, Math.min((double)deckAge, 365.0d)))).append("<br>");
        	builder.append("<br><b>").append(res.getString(R.string.deck_summary_average_total)).append("</b><br>");
        	builder.append(res.getString(R.string.deck_summary_reviews)).append(" ").append(res.getString(R.string.deck_summary_cards_per_day, getFraction(repsMatCount + repsYoungCount + repsFirstCount, deckAge))).append("<br>");
+       	builder.append(res.getString(R.string.deck_summary_news)).append(" ").append(res.getString(R.string.deck_summary_cards_per_day, getFraction(matureCount + youngCount, deckAge))).append("<br>");
        	builder.append("</body></html>");
        	return builder.toString();
     }
diff --git a/src/com/ichi2/anki/StudyOptions.java b/src/com/ichi2/anki/StudyOptions.java
index 4d6009d88c..082f57f788 100644
--- a/src/com/ichi2/anki/StudyOptions.java
+++ b/src/com/ichi2/anki/StudyOptions.java
@@ -16,7 +16,6 @@ package com.ichi2.anki;
 
 import android.app.Activity;
 import android.app.Dialog;
-import android.app.ProgressDialog;
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.DialogInterface;
@@ -30,20 +29,21 @@ import android.content.pm.ActivityInfo;
 import android.content.pm.PackageManager.NameNotFoundException;
 import android.content.res.Configuration;
 import android.content.res.Resources;
+import android.database.sqlite.SQLiteException;
 import android.net.Uri;
 import android.os.Build;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.Message;
 import android.util.Log;
+import android.view.GestureDetector;
+import android.view.GestureDetector.SimpleOnGestureListener;
 import android.view.KeyEvent;
 import android.view.Menu;
 import android.view.MenuItem;
 import android.view.MotionEvent;
 import android.view.View;
 import android.view.ViewTreeObserver;
-import android.view.GestureDetector;
-import android.view.GestureDetector.SimpleOnGestureListener;
 import android.view.ViewTreeObserver.OnGlobalLayoutListener;
 import android.view.inputmethod.InputMethodManager;
 import android.webkit.WebView;
@@ -54,7 +54,6 @@ import android.widget.CheckBox;
 import android.widget.CompoundButton;
 import android.widget.EditText;
 import android.widget.LinearLayout;
-import android.widget.ListView;
 import android.widget.Spinner;
 import android.widget.TextView;
 import android.widget.ToggleButton;
@@ -68,12 +67,15 @@ import com.ichi2.compat.Compat;
 import com.ichi2.compat.CompatV11;
 import com.ichi2.compat.CompatV3;
 import com.ichi2.themes.StyledDialog;
+import com.ichi2.themes.StyledProgressDialog;
 import com.ichi2.themes.Themes;
+import com.ichi2.widget.AnkiDroidWidgetBig;
+import com.ichi2.widget.WidgetStatus;
 import com.tomgibara.android.veecheck.util.PrefSettings;
 import com.zeemote.zc.Controller;
-import com.zeemote.zc.ui.android.ControllerAndroidUi;
 import com.zeemote.zc.event.ButtonEvent;
 import com.zeemote.zc.event.IButtonListener;
+import com.zeemote.zc.ui.android.ControllerAndroidUi;
 import com.zeemote.zc.util.JoystickToButtonAdapter;
 
 import java.io.File;
@@ -100,13 +102,14 @@ public class StudyOptions extends Activity implements IButtonListener {
     /**
 * Menus
 */
+    private static final int MENU_HELP = 0;
     private static final int MENU_OPEN = 1;
-    private static final int MENU_SYNC = 3;
-    private static final int MENU_PREFERENCES = 5;
-    private static final int MENU_ADD_FACT = 6;
-    private static final int MENU_MORE_OPTIONS = 7;
-    private static final int MENU_ROTATE = 8;
-    private static final int MENU_ZEEMOTE = 9;
+    private static final int MENU_SYNC = 2;
+    private static final int MENU_PREFERENCES = 3;
+    private static final int MENU_ADD_FACT = 4;
+    private static final int MENU_MORE_OPTIONS = 5;
+    private static final int MENU_ROTATE = 6;
+    private static final int MENU_ZEEMOTE = 7;
 
     /**
 * Available options performed by other activities
@@ -122,7 +125,7 @@ public class StudyOptions extends Activity implements IButtonListener {
     private static final int STATISTICS = 8;
     private static final int GROUP_SELECTOR = 9;
     private static final int LOG_IN = 10;
-    
+
     public static final int RESULT_RESTART = 100;
     public static final int RESULT_CLOSE = 101;
     public static final int RESULT_RELOAD_DECK = 102;
@@ -146,6 +149,11 @@ public class StudyOptions extends Activity implements IButtonListener {
 
 
     public static final String EXTRA_DECK = "deck";
+    public static final String EXTRA_START = "start";
+    public static final int EXTRA_START_NOTHING = 0;
+    public static final int EXTRA_START_REVIEWER = 1;
+    public static final int EXTRA_START_DECKPICKER = 2;
+    public static final int EXTRA_DB_ERROR = 3;
 
     private static final int DIALOG_NO_CONNECTION = 0;
     private static final int DIALOG_USER_NOT_LOGGED_IN = 1;
@@ -165,6 +173,8 @@ public class StudyOptions extends Activity implements IButtonListener {
     private static final int DIALOG_DOWNLOAD_SELECTOR = 15;
     private static final int DIALOG_CRAM = 16;
     private static final int DIALOG_BACKUP_NO_SPACE_LEFT = 17;
+    private static final int DIALOG_DB_ERROR = 18;
+    private static final int DIALOG_SELECT_HELP = 19;
 
     private String mCurrentDialogMessage;
 
@@ -201,6 +211,8 @@ public class StudyOptions extends Activity implements IButtonListener {
     private boolean mPrefStudyOptions;
     // private boolean deckSelected;
     private boolean mInDeckPicker;
+    private boolean mInReviewer;
+    private int mStartedByBigWidget;
     private String mDeckFilename;
     private int mStartupMode;
     private boolean mSwipeEnabled;
@@ -214,10 +226,12 @@ public class StudyOptions extends Activity implements IButtonListener {
     String mLocale;
     private boolean mZeemoteEnabled;
 
+    private String mRepairFileName;
+
     /**
 * Alerts to inform the user about different situations
 */
-    private ProgressDialog mProgressDialog;
+    private StyledProgressDialog mProgressDialog;
 
 	/*
 	* Limit session dialog
@@ -253,7 +267,7 @@ public class StudyOptions extends Activity implements IButtonListener {
     /*
 * Cram related
 */
-    private StyledDialog mCramTagsDialog;
+//    private StyledDialog mCramTagsDialog;
     private String allCramTags[];
     private HashSet<String> activeCramTags;
     private String cramOrder;
@@ -268,12 +282,11 @@ public class StudyOptions extends Activity implements IButtonListener {
     private ToggleButton mToggleCram;
     private ToggleButton mToggleLimit;
     private TextView mTextDeckName;
-    private LinearLayout mStatisticsField;
+    private LinearLayout mDeckInformation;
     private TextView mTextReviewsDue;
     private TextView mTextNewToday;
     private TextView mTextETA;
     private TextView mTextNewTotal;
-    private TextView mHelp;
     private CheckBox mNightMode;
     private CheckBox mSwapQA;
     private Button mCardBrowser;
@@ -318,8 +331,8 @@ public class StudyOptions extends Activity implements IButtonListener {
     /**
 * UI elements for "Cram Tags" view
 */
-    private ListView mCramTagsListView;
-    private Spinner mSpinnerCramOrder;
+//    private ListView mCramTagsListView;
+//    private Spinner mSpinnerCramOrder;
 
     /**
     * Swipe Detection
@@ -363,6 +376,7 @@ public class StudyOptions extends Activity implements IButtonListener {
     private double mProgressAll;
 
     private boolean mIsClosing = false;
+    private boolean mDeckNotAvailable = false;
 
     /** Used to perform operation in a platform specific way. */
     private Compat mCompat;
@@ -372,8 +386,8 @@ public class StudyOptions extends Activity implements IButtonListener {
  	 */
 	protected JoystickToButtonAdapter adapter;
  	ControllerAndroidUi controllerUi;
- 	
 
+	private boolean mShowRepairDialog = false;
 
     /**
 * Callbacks for UI events
@@ -449,12 +463,10 @@ public class StudyOptions extends Activity implements IButtonListener {
                     	}
                 	}
                 	return;
-                case R.id.studyoptions_help:
-                    if (Utils.isIntentAvailable(StudyOptions.this, "android.intent.action.VIEW")) {
-                        Intent intent = new Intent("android.intent.action.VIEW", Uri.parse(getResources().getString(R.string.link_help)));
-                        startActivity(intent);
-                    } else {
-                        startActivity(new Intent(StudyOptions.this, About.class));
+                case R.id.studyoptions_limit_tag_tv2:
+                    if (mLimitTagNewActiveCheckBox.isChecked()) {
+                        mSelectedLimitTagText = LIMIT_NEW_ACTIVE;
+                        showDialog(DIALOG_TAGS);
                     }
                     return;
                 default:
@@ -523,10 +535,17 @@ public class StudyOptions extends Activity implements IButtonListener {
     private DialogInterface.OnClickListener mDialogSaveListener = new DialogInterface.OnClickListener() {
         @Override
         public void onClick(DialogInterface dialog, int which) {
+<<<<<<< HEAD
             Deck deck = AnkiDroidApp.deck();
             deck.setIntVar("newOrder", mSpinnerNewCardOrder.getSelectedItemPosition());
             deck.setIntVar("newSpread", mSpinnerNewCardSchedule.getSelectedItemPosition());
             deck.setIntVar("revOrder", mSpinnerRevCardOrder.getSelectedItemPosition());
+=======
+        	Deck deck = DeckManager.getMainDeck();
+            deck.setNewCardOrder(mSpinnerNewCardOrder.getSelectedItemPosition());
+            deck.setNewCardSpacing(mSpinnerNewCardSchedule.getSelectedItemPosition());
+            deck.setRevCardOrder(mSpinnerRevCardOrder.getSelectedItemPosition());
+>>>>>>> master
             // TODO: mSpinnerFailCardOption
             // FIXME: invalid entries set to zero(unlimited) for now, better to set to default?
             String maxFailText = mEditMaxFailCard.getText().toString();
@@ -564,17 +583,32 @@ public class StudyOptions extends Activity implements IButtonListener {
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
+		if (!isTaskRoot()) {
+			Log.i(AnkiDroidApp.TAG, "StudyOptions - onCreate: Detected multiple instance of this activity, closing it and return to root activity");
+	        Intent reloadIntent = new Intent(StudyOptions.this, StudyOptions.class);
+	        reloadIntent.setAction(Intent.ACTION_MAIN);
+	        reloadIntent.putExtras(getIntent().getExtras());
+	        reloadIntent.addCategory(Intent.CATEGORY_LAUNCHER);
+	        reloadIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+			finish();
+			startActivityIfNeeded(reloadIntent, 0);
+		}
+
         Themes.applyTheme(this);
         super.onCreate(savedInstanceState);
 
         Log.i(AnkiDroidApp.TAG, "StudyOptions - OnCreate()");
 
-        if (hasErrorFiles()) {
+        Intent intent = getIntent();
+        mStartedByBigWidget = intent.getIntExtra(EXTRA_START, EXTRA_START_NOTHING);
+
+        if (hasErrorFiles() && mStartedByBigWidget == EXTRA_START_NOTHING) {
             Intent i = new Intent(this, Feedback.class);
             startActivityForResult(i, REPORT_ERROR);
         }
 
         SharedPreferences preferences = restorePreferences();
+        BackupManager.initBackup();
         registerExternalStorageListener();
 
         activeCramTags = new HashSet<String>();
@@ -582,17 +616,24 @@ public class StudyOptions extends Activity implements IButtonListener {
 
         initAllContentViews();
 
-        if ((AnkiDroidApp.deck() != null) && (AnkiDroidApp.deck().hasFinishScheduler())) {
-            AnkiDroidApp.deck().finishScheduler();
-        }
-
-        Intent intent = getIntent();
         if (Intent.ACTION_VIEW.equalsIgnoreCase(intent.getAction())
                 && intent.getDataString() != null) {
             mDeckFilename = Uri.parse(intent.getDataString()).getPath();
             Log.i(AnkiDroidApp.TAG, "onCreate - deckFilename from VIEW intent: " + mDeckFilename);
-        } else if (Intent.ACTION_MAIN.equalsIgnoreCase(intent.getAction())
-                && intent.hasExtra(EXTRA_DECK)) {
+        } else if (Intent.ACTION_MAIN.equalsIgnoreCase(intent.getAction()) && mStartedByBigWidget != EXTRA_START_NOTHING) {
+        		switch (intent.getIntExtra(EXTRA_START, EXTRA_START_NOTHING)) {
+        		case EXTRA_START_REVIEWER:
+                	openReviewer();
+                	break;
+        		case EXTRA_START_DECKPICKER:
+        			openDeckPicker(false);
+                	break;
+        		case EXTRA_DB_ERROR:
+        			mRepairFileName = intent.getStringExtra(EXTRA_DECK);
+        			onActivityResult(REQUEST_REVIEW, Reviewer.RESULT_ANSWERING_ERROR, null);
+        			break;
+        		}
+        } else if (Intent.ACTION_MAIN.equalsIgnoreCase(intent.getAction()) && intent.hasExtra(EXTRA_DECK)) {
             mDeckFilename = intent.getStringExtra(EXTRA_DECK);
             Log.i(AnkiDroidApp.TAG, "onCreate - deckFilename from MAIN intent: " + mDeckFilename);
         } else if (savedInstanceState != null) {
@@ -604,13 +645,17 @@ public class StudyOptions extends Activity implements IButtonListener {
             mDeckFilename = preferences.getString("deckFilename", null);
             Log.i(AnkiDroidApp.TAG, "onCreate - deckFilename from preferences: " + mDeckFilename);
         }
+
         if (!mSdCardAvailable) {
             showContentView(CONTENT_NO_EXTERNAL_STORAGE);
         } else {
-            if (mDeckFilename == null || !new File(mDeckFilename).exists()) {
+        	if (mStartedByBigWidget == EXTRA_START_DECKPICKER || mStartedByBigWidget == EXTRA_START_REVIEWER) {
+        		showContentView(CONTENT_STUDY_OPTIONS);
+            	showDeckInformation(false);
+        	} else if (mDeckFilename == null || !new File(mDeckFilename).exists()) {
                 showContentView(CONTENT_NO_DECK);
-            } else {
-            	if ((showDeckPickerOnStartup() || getIntent().getBooleanExtra("startDeckpicker", false)) && !hasErrorFiles()) {
+            } else if (mStartedByBigWidget == EXTRA_START_NOTHING) {
+            	if ((showDeckPickerOnStartup()) && (!hasErrorFiles())) {
             		openDeckPicker();
             	} else {
             		// Load previous deck.
@@ -670,7 +715,7 @@ public class StudyOptions extends Activity implements IButtonListener {
     public void onConfigurationChanged(Configuration newConfig){
     	super.onConfigurationChanged(newConfig);
        	setLanguage(mLocale);
-    	hideDeckInformation();
+    	hideDeckInformation(false);
         boolean cramChecked = mToggleCram.isChecked();
         boolean limitChecked = mToggleLimit.isChecked();
         boolean limitEnabled = mToggleLimit.isEnabled();
@@ -710,7 +755,7 @@ public class StudyOptions extends Activity implements IButtonListener {
                     String action = intent.getAction();
                     if (action.equals(Intent.ACTION_MEDIA_EJECT)) {
                         Log.i(AnkiDroidApp.TAG, "mUnmountReceiver - Action = Media Eject");
-                        closeOpenedDeck();
+                        DeckManager.closeAllDecks();
                         showContentView(CONTENT_NO_EXTERNAL_STORAGE);
                         mSdCardAvailable = false;
                     } else if (action.equals(Intent.ACTION_MEDIA_MOUNTED)) {
@@ -735,8 +780,11 @@ public class StudyOptions extends Activity implements IButtonListener {
     protected void onDestroy() {
     	super.onDestroy();
         Log.i(AnkiDroidApp.TAG, "StudyOptions - onDestroy()");
-        closeOpenedDeck();
-        MetaDB.closeDB();
+		if (!isFinishing()) {
+            DeckManager.closeMainDeck(DeckManager.REQUESTING_ACTIVITY_STUDYOPTIONS);
+            mCompat.invalidateOptionsMenu(StudyOptions.this);
+	        MetaDB.closeDB();
+		}
         if (mUnmountReceiver != null) {
             unregisterReceiver(mUnmountReceiver);
         }
@@ -753,22 +801,32 @@ public class StudyOptions extends Activity implements IButtonListener {
     }
 
 
-     @Override
-     protected void onPause() {
-         if ((AnkiDroidApp.zeemoteController() != null) && (AnkiDroidApp.zeemoteController().isConnected())){ 
-         	Log.d("Zeemote","Removing listener in onPause");
-         	AnkiDroidApp.zeemoteController().removeButtonListener(this);
-         	AnkiDroidApp.zeemoteController().removeJoystickListener(adapter);
-     		adapter.removeButtonListener(this);
-     		adapter = null;
-         }        
-    	 
-         super.onPause();
-         // Update the widget when pausing this activity.
-         if (!mInDeckPicker) {
-             WidgetStatus.update(getBaseContext());
-         }
-     }
+    @Override
+    protected void onPause() {
+        if ((AnkiDroidApp.zeemoteController() != null) && (AnkiDroidApp.zeemoteController().isConnected())){ 
+        	Log.d("Zeemote","Removing listener in onPause");
+        	AnkiDroidApp.zeemoteController().removeButtonListener(this);
+        	AnkiDroidApp.zeemoteController().removeJoystickListener(adapter);
+    		adapter.removeButtonListener(this);
+    		adapter = null;
+        }
+   	 
+        super.onPause();
+    }
+
+
+    @Override
+    protected void onStop() {
+        super.onStop();
+        // Update the widget when stopping this activity (all when closing, only current when pressing home).
+        if (!mInDeckPicker && !mInReviewer) {
+        	if (isFinishing()) {
+        		WidgetStatus.update(this, null);
+        	} else {
+        		WidgetStatus.update(this, WidgetStatus.getDeckStatus(DeckManager.getMainDeck()));
+        	}
+        }
+    }
 
 
     @Override
@@ -781,11 +839,16 @@ public class StudyOptions extends Activity implements IButtonListener {
 	      	  AnkiDroidApp.zeemoteController().addJoystickListener(adapter);
 	      	  adapter.addButtonListener(this);
 	      }
-	      if ((mCurrentContentView == CONTENT_STUDY_OPTIONS || mCurrentContentView == CONTENT_SESSION_COMPLETE) && mTextDeckName.getVisibility() != View.VISIBLE && (mProgressDialog == null || !mProgressDialog.isShowing())) {
-		      showDeckInformation(true);
+	      if ((mCurrentContentView == CONTENT_STUDY_OPTIONS || mCurrentContentView == CONTENT_SESSION_COMPLETE) && (mProgressDialog == null || !mProgressDialog.isShowing())) {
+	    	  if (mTextDeckName.getVisibility() != View.VISIBLE) {
+			      showDeckInformation(true);
+	    	  } else {
+	    	      updateValuesFromDeck();
+	    	  }
 	      }
 	      // check for new day and reset deck if yes
 	      if (Utils.isNewDay(PrefSettings.getSharedPrefs(getBaseContext()).getLong("lastTimeOpened", 0)) && (mCurrentContentView == CONTENT_STUDY_OPTIONS || mCurrentContentView == CONTENT_SESSION_COMPLETE)) {
+	    	  BackupManager.initBackup();
 	    	  if (!DeckTask.taskIsRunning()) {
 		    	  displayProgressDialogAndLoadDeck();
 	    	  }
@@ -815,24 +878,17 @@ public class StudyOptions extends Activity implements IButtonListener {
     	closeStudyOptions(true);
     }
     private void closeStudyOptions(boolean closeDeck) {
+		mIsClosing = true;
         MetaDB.closeDB();
-        if (closeDeck && AnkiDroidApp.deck() != null && mSdCardAvailable) {
-        	DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CLOSE_DECK, mCloseDeckHandler, new DeckTask.TaskData(AnkiDroidApp.deck(), 0));
-        } else {
-        	AnkiDroidApp.setDeck(null);
-            mCompat.invalidateOptionsMenu(this);
-            StudyOptions.this.finish();
-        }
+        DeckManager.closeMainDeck(DeckManager.REQUESTING_ACTIVITY_STUDYOPTIONS);
+        mCompat.invalidateOptionsMenu(this);
+        StudyOptions.this.finish();
     }
 
 
     private void restartApp() {
     	// restarts application in order to apply new themes or localisations
     	Intent i = getBaseContext().getPackageManager().getLaunchIntentForPackage(getBaseContext().getPackageName());
-        if (AnkiDroidApp.deck() != null && mSdCardAvailable) {
-        	AnkiDroidApp.deck().closeDeck();
-        }
-    	AnkiDroidApp.setDeck(null);
         mCompat.invalidateOptionsMenu(this);
         MetaDB.closeDB();
         StudyOptions.this.finish();
@@ -841,11 +897,12 @@ public class StudyOptions extends Activity implements IButtonListener {
 
 
     private void openReviewer() {
-    	if (mCurrentContentView == CONTENT_STUDY_OPTIONS || mCurrentContentView == CONTENT_SESSION_COMPLETE) {
+    	if (mStartedByBigWidget != EXTRA_START_NOTHING || mCurrentContentView == CONTENT_STUDY_OPTIONS || mCurrentContentView == CONTENT_SESSION_COMPLETE) {
+    		mInReviewer = true;
     		Intent reviewer = new Intent(StudyOptions.this, Reviewer.class);
             reviewer.putExtra("deckFilename", mDeckFilename);
     		startActivityForResult(reviewer, REQUEST_REVIEW);
-        	if (getApiLevel() > 4) {
+        	if (getApiLevel() > 4 && mStartedByBigWidget == EXTRA_START_NOTHING) {
        			ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.LEFT);
         	}
     	} else if (mCurrentContentView == CONTENT_CONGRATS) {
@@ -855,32 +912,34 @@ public class StudyOptions extends Activity implements IButtonListener {
 
 
     private void startEarlyReview() {
-//		Deck deck = AnkiDroidApp.deck();
-//        if (deck != null) {
-//            deck.setupReviewEarlyScheduler();
-//            deck.reset();
-//    		Intent reviewer = new Intent(StudyOptions.this, Reviewer.class);
-//            reviewer.putExtra("deckFilename", mDeckFilename);
-//            startActivityForResult(reviewer, REQUEST_REVIEW);
-//        	if (Integer.valueOf(android.os.Build.VERSION.SDK) > 4) {
-//       			MyAnimation.slide(this, MyAnimation.LEFT);
-//        	}
-//        }
+		Deck deck = DeckManager.getMainDeck();
+        if (deck != null) {
+    		mInReviewer = true;
+            deck.setupReviewEarlyScheduler();
+            deck.reset();
+    		Intent reviewer = new Intent(StudyOptions.this, Reviewer.class);
+            reviewer.putExtra("deckFilename", mDeckFilename);
+            startActivityForResult(reviewer, REQUEST_REVIEW);
+        	if (getApiLevel() > 4) {
+       			ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.LEFT);
+        	}
+        }
     }
 
 
     private void startLearnMore() {
-//		Deck deck = AnkiDroidApp.deck();
-//        if (deck != null) {
-//            deck.setupLearnMoreScheduler();
-//            deck.reset();
-//    		Intent reviewer = new Intent(StudyOptions.this, Reviewer.class);
-//    		reviewer.putExtra("deckFilename", mDeckFilename);
-//        	startActivityForResult(reviewer, REQUEST_REVIEW);
-//    		if (Integer.valueOf(android.os.Build.VERSION.SDK) > 4) {
-//    			MyAnimation.slide(this, MyAnimation.LEFT);
-//    		}
-//        }
+		Deck deck = DeckManager.getMainDeck();
+        if (deck != null) {
+    		mInReviewer = true;
+            deck.setupLearnMoreScheduler();
+            deck.reset();
+    		Intent reviewer = new Intent(StudyOptions.this, Reviewer.class);
+    		reviewer.putExtra("deckFilename", mDeckFilename);
+        	startActivityForResult(reviewer, REQUEST_REVIEW);
+    		if (getApiLevel() > 4) {
+    			ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.LEFT);
+    		}
+        }
     }
 
 
@@ -891,15 +950,6 @@ public class StudyOptions extends Activity implements IButtonListener {
     }
 
 
-    private void closeOpenedDeck() {
-        if (AnkiDroidApp.deck() != null && mSdCardAvailable) {
-            AnkiDroidApp.deck().closeDeck();
-            AnkiDroidApp.setDeck(null);
-            mCompat.invalidateOptionsMenu(this);
-        }
-    }
-
-
     private boolean hasErrorFiles() {
         for (String file : this.fileList()) {
             if (file.endsWith(".stacktrace")) {
@@ -922,10 +972,7 @@ public class StudyOptions extends Activity implements IButtonListener {
         mTextDeckName = (TextView) mStudyOptionsView.findViewById(R.id.studyoptions_deck_name);
         Themes.setTitleStyle(mTextDeckName);
 
-        mStatisticsField = (LinearLayout) mStudyOptionsView.findViewById(R.id.studyoptions_statistic_field);
-        Themes.setTextViewStyle(mStatisticsField);
-
-        Themes.setTitleStyle(mStudyOptionsView.findViewById(R.id.studyoptions_bottom));
+        mDeckInformation = (LinearLayout) mStudyOptionsView.findViewById(R.id.studyoptions_deckinformation);
 
         mButtonStart = (Button) mStudyOptionsView.findViewById(R.id.studyoptions_start);
         mToggleCram = (ToggleButton) mStudyOptionsView.findViewById(R.id.studyoptions_cram);
@@ -986,9 +1033,6 @@ public class StudyOptions extends Activity implements IButtonListener {
             }
         });
         
-        mHelp = (TextView) mStudyOptionsView.findViewById(R.id.studyoptions_help);
-        mHelp.setOnClickListener(mButtonClickListener);
-
         mButtonStart.setOnClickListener(mButtonClickListener);
         mToggleCram.setOnClickListener(mButtonClickListener);
         mToggleLimit.setOnClickListener(mButtonClickListener);
@@ -1206,7 +1250,7 @@ public class StudyOptions extends Activity implements IButtonListener {
 	                displayProgressDialogAndLoadDeck();
 	            }
 	        });
-	        builder.setNeutralButton(res.getString(R.string.backup_restore), new OnClickListener() {
+	        builder.setNegativeButton(res.getString(R.string.backup_restore), new OnClickListener() {
 
 	            @Override
 	            public void onClick(DialogInterface dialog, int which) {
@@ -1255,48 +1299,14 @@ public class StudyOptions extends Activity implements IButtonListener {
 	        		}
 	            }
 	        });
-	        builder.setNegativeButton(res.getString(R.string.delete_deck_title), new OnClickListener() {
+	        builder.setNeutralButton(res.getString(R.string.backup_repair_deck), new OnClickListener() {
 
 	            @Override
 	            public void onClick(DialogInterface dialog, int which) {
-	            	Resources res = getResources();
-	            	StyledDialog.Builder builder = new StyledDialog.Builder(StudyOptions.this);
-	            	builder.setCancelable(true).setTitle(res.getString(R.string.delete_deck_title))
-	            		.setIcon(android.R.drawable.ic_dialog_alert)
-	            		.setMessage(String.format(res.getString(R.string.delete_deck_message), new File(mDeckFilename).getName().replace(".anki", "")))
-	            		.setPositiveButton(res.getString(R.string.delete_deck_confirm), new DialogInterface.OnClickListener() {
-
-							@Override
-							public void onClick(DialogInterface dialog, int which) {
-								if (BackupManager.moveDeckToBrokenFolder(mDeckFilename)) {
-									Themes.showThemedToast(StudyOptions.this, getResources().getString(R.string.delete_deck_success, new File(mDeckFilename).getName().replace(".anki", ""), BackupManager.BROKEN_DECKS_SUFFIX.replace("/", "")), false);
-								}
-								showContentView(CONTENT_NO_DECK);
-							}
-						}).setNegativeButton(res.getString(R.string.cancel), new DialogInterface.OnClickListener() {
-
-							@Override
-							public void onClick(DialogInterface dialog, int which) {
-								showDialog(DIALOG_DECK_NOT_LOADED);
-							}
-						}).setOnCancelListener(new DialogInterface.OnCancelListener() {
-
-							@Override
-							public void onCancel(DialogInterface dialog) {
-								showDialog(DIALOG_DECK_NOT_LOADED);
-							}
-						}).show();
-							
+	            	DeckTask.launchDeckTask(DeckTask.TASK_TYPE_REPAIR_DECK, mRepairDeckHandler, new DeckTask.TaskData(mDeckFilename));
 	            }
 	        });
 	        builder.setCancelable(true);
-	        builder.setOnCancelListener(new OnCancelListener() {
-
-				@Override
-				public void onCancel(DialogInterface arg0) {
-					showContentView(CONTENT_DECK_NOT_LOADED);
-				}
-	        });
 	        dialog = builder.create();
 			break;
 		case DIALOG_MORE:
@@ -1409,7 +1419,7 @@ public class StudyOptions extends Activity implements IButtonListener {
 
 	            @Override
 	            public void onClick(DialogInterface dialog, int which) {
-	                Deck deck = AnkiDroidApp.deck();
+	                Deck deck = DeckManager.getMainDeck();
 	                boolean changed = false;
 	                String textTime = mEditSessionTime.getText().toString();
 	                if (!textTime.equals(Long.toString(deck.getSessionTimeLimit() / 60))) {
@@ -1492,7 +1502,7 @@ public class StudyOptions extends Activity implements IButtonListener {
 
 	        Spinner spinner = new Spinner(this);
 	        
-	        ArrayAdapter adapter = ArrayAdapter.createFromResource(this, R.array.cram_review_order_labels, android.R.layout.simple_spinner_item);
+	        ArrayAdapter<CharSequence> adapter = ArrayAdapter.createFromResource(this, R.array.cram_review_order_labels, android.R.layout.simple_spinner_item);
 	        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
 	        spinner.setAdapter(adapter);
 	        spinner.setSelection(0);
@@ -1552,10 +1562,60 @@ public class StudyOptions extends Activity implements IButtonListener {
 	        mWelcomeAlert = dialog;
 			break;
 
+		case DIALOG_DB_ERROR:
+			builder.setTitle(R.string.answering_error_title);
+	        builder.setIcon(android.R.drawable.ic_dialog_alert);
+			builder.setMessage(R.string.answering_error_message);
+	        builder.setPositiveButton(res.getString(R.string.backup_repair_deck), new OnClickListener() {
+	            @Override
+	            public void onClick(DialogInterface dialog, int which) {
+	            	DeckTask.launchDeckTask(DeckTask.TASK_TYPE_REPAIR_DECK, mRepairDeckHandler, new DeckTask.TaskData(mDeckFilename != null ? mDeckFilename : mRepairFileName));
+	            }
+	        });
+	        builder.setNeutralButton(res.getString(R.string.answering_error_report), new OnClickListener() {
+	            @Override
+	            public void onClick(DialogInterface dialog, int which) {
+	                mShowRepairDialog = true;
+	                Intent i = new Intent(StudyOptions.this, Feedback.class);
+	                dialog.dismiss();
+	                startActivityForResult(i, REPORT_ERROR);
+	                if (getApiLevel() > 4) {
+	                	ActivityTransitionAnimation.slide(StudyOptions.this, ActivityTransitionAnimation.FADE);
+		        	}
+	            }
+	        });	        	
+			builder.setNegativeButton(res.getString(R.string.close), null);
+	        builder.setCancelable(true);
+		    dialog = builder.create();
+			break;
+
+		case DIALOG_SELECT_HELP:
+	        builder.setTitle(res.getString(R.string.help_title));
+	        builder.setItems(new String[] {res.getString(R.string.help_tutorial), res.getString(R.string.help_online), res.getString(R.string.help_faq)}, new OnClickListener() {
+
+				@Override
+				public void onClick(DialogInterface arg0, int arg1) {
+					if (arg1 == 0) {
+						loadSampleDeck();
+					} else {
+			            if (Utils.isIntentAvailable(StudyOptions.this, "android.intent.action.VIEW")) {
+			                Intent intent = new Intent("android.intent.action.VIEW", Uri.parse(getResources().getString(arg1 == 0 ? R.string.link_help : R.string.link_faq)));
+			                startActivity(intent);
+			            } else {
+			                startActivity(new Intent(StudyOptions.this, About.class));
+			            }						
+					}
+				}
+	        	
+	        });
+			dialog = builder.create();
+			break;
+
 		default:
 			dialog = null;
 		}
 
+		dialog.setOwnerActivity(StudyOptions.this);
 		return dialog;
 	}
 
@@ -1563,6 +1623,10 @@ public class StudyOptions extends Activity implements IButtonListener {
 	@Override
 	protected void onPrepareDialog(int id, Dialog dialog) {
 		StyledDialog ad = (StyledDialog)dialog;
+
+		// wait for deck loading thread (to avoid problems with resuming destroyed activities)
+		DeckTask.waitToFinish();
+
 		switch (id) {
 		case DIALOG_SYNC_CONFLICT_RESOLUTION:
 		case DIALOG_NO_SPACE_LEFT:
@@ -1573,26 +1637,20 @@ public class StudyOptions extends Activity implements IButtonListener {
 
 		case DIALOG_MORE:
 	        // Update spinner selections from deck prior to showing the dialog.
-	        Deck deck = AnkiDroidApp.deck();
-	        if (deck != null) {
-		        mSpinnerNewCardOrder.setSelection(deck.getNewCardOrder());
-		        mSpinnerNewCardSchedule.setSelection(deck.getNewCardSpacing());
-		        mSpinnerRevCardOrder.setSelection(deck.getRevCardOrder());
-		        mSpinnerFailCardOption.setVisibility(View.GONE); // TODO: Not implemented yet.
-		        mEditMaxFailCard.setText(String.valueOf(deck.getFailedCardMax()));
-		        mEditNewPerDay.setText(String.valueOf(deck.getNewCardsPerDay()));
-		        mCheckBoxPerDay.setChecked(deck.getPerDay());
-		        mCheckBoxSuspendLeeches.setChecked(deck.getSuspendLeeches());	        	
-	        }
+	        Deck deck = DeckManager.getMainDeck();
+	        mSpinnerNewCardOrder.setSelection(deck.getNewCardOrder());
+	        mSpinnerNewCardSchedule.setSelection(deck.getNewCardSpacing());
+	        mSpinnerRevCardOrder.setSelection(deck.getRevCardOrder());
+	        mSpinnerFailCardOption.setVisibility(View.GONE); // TODO: Not implemented yet.
+	        mEditMaxFailCard.setText(String.valueOf(deck.getFailedCardMax()));
+	        mEditNewPerDay.setText(String.valueOf(deck.getNewCardsPerDay()));
+	        mCheckBoxPerDay.setChecked(deck.getPerDay());
+	        mCheckBoxSuspendLeeches.setChecked(deck.getSuspendLeeches());	        	
 			break;
 			
 		case DIALOG_LIMIT_SESSION:
 	        // Update spinner selections from deck prior to showing the dialog.
-	        Deck deck2 = AnkiDroidApp.deck();
-		if (deck2 == null) {
-			ad.setEnabled(false);
-			return;
-		}
+	        Deck deck2 = DeckManager.getMainDeck();
 	        long timeLimit = deck2.getSessionTimeLimit() / 60;
 	        long repLimit = deck2.getSessionRepLimit();
 	        mSessionLimitCheckBox.setChecked(timeLimit + repLimit > 0);
@@ -1610,16 +1668,12 @@ public class StudyOptions extends Activity implements IButtonListener {
 
 	        mLimitTagsCheckBox.setChecked(mLimitTagNewActiveCheckBox.isChecked() || mLimitTagNewInactiveCheckBox.isChecked()
 	                || mLimitTagRevActiveCheckBox.isChecked() || mLimitTagRevInactiveCheckBox.isChecked());
+	        allTags = null;
 	        break;
 
 		case DIALOG_TAGS:
-			Deck deck3 = AnkiDroidApp.deck();
-			if (deck3 == null) {
-				ad.setEnabled(false);
-				return;
-			}
 	        if (allTags == null) {
-	            allTags = deck3.allTags_();
+	            allTags = DeckManager.getMainDeck().allTags_();
 	            Log.i(AnkiDroidApp.TAG, "all tags: " + Arrays.toString(allTags));
 		        if (allTags == null) {
 		        	Themes.showThemedToast(StudyOptions.this, getResources().getString(R.string.error_insufficient_memory), false);
@@ -1642,6 +1696,10 @@ public class StudyOptions extends Activity implements IButtonListener {
 	                new DialogInterface.OnClickListener() {
 						@Override
 						public void onClick(DialogInterface dialog, int which) {
+				if (allTags == null) {
+					dialog.dismiss();
+					return;
+				}
 	                        String tag = allTags[which];
 	                        if (mSelectedTags.contains(tag)) {
 	                            Log.i(AnkiDroidApp.TAG, "unchecked tag: " + tag);
@@ -1655,8 +1713,7 @@ public class StudyOptions extends Activity implements IButtonListener {
 	        break;
 
 		case DIALOG_CRAM:
-	        activeCramTags.clear();
-	        allCramTags = AnkiDroidApp.deck().allTags_();
+	        allCramTags = DeckManager.getMainDeck().allTags_();
 	        if (allCramTags == null) {
 	        	Themes.showThemedToast(StudyOptions.this, getResources().getString(R.string.error_insufficient_memory), false);
 	        	ad.setEnabled(false);
@@ -1677,6 +1734,9 @@ public class StudyOptions extends Activity implements IButtonListener {
 				}
 	        });
 			break;
+		case DIALOG_DB_ERROR:
+			ad.getButton(Dialog.BUTTON_NEUTRAL).setEnabled(hasErrorFiles() && !PrefSettings.getSharedPrefs(StudyOptions.this).getString("reportErrorMode", Feedback.REPORT_ASK).equals(Feedback.REPORT_NEVER));
+			break;
 		}
 	}
 
@@ -1712,24 +1772,36 @@ public class StudyOptions extends Activity implements IButtonListener {
                 mTextNoDeckTitle.setText(R.string.studyoptions_deck_not_loaded_title);
                 mTextNoDeckMessage.setText(R.string.studyoptions_deck_not_loaded_message);
                 setContentView(mNoDeckView);
+            	mCurrentDialogMessage = getResources().getString(R.string.open_deck_failed, "\'" + new File(mDeckFilename).getName() + "\'", BackupManager.BROKEN_DECKS_SUFFIX.replace("/", ""), getResources().getString(R.string.repair_deck));
+    			showDialog(DIALOG_DECK_NOT_LOADED);
                 break;
             case CONTENT_STUDY_OPTIONS:
             case CONTENT_SESSION_COMPLETE:
                 // Enable timeboxing in case it was disabled from the previous deck
-//                if ((AnkiDroidApp.deck() != null) && (AnkiDroidApp.deck().name().equals("cram"))) {
-//                    mToggleCram.setChecked(false);
-//                    mToggleLimit.setEnabled(true);
-//                }
+                if ((DeckManager.getMainDeck() != null) && (DeckManager.getMainDeck().name().equals("cram"))) {
+                    mToggleCram.setChecked(false);
+                    mToggleLimit.setEnabled(true);
+                }
                 if (mCurrentContentView == CONTENT_STUDY_OPTIONS) {
                     mButtonStart.setText(R.string.studyoptions_start);
                 } else {
                     mButtonStart.setText(R.string.studyoptions_continue);
                 }
-                updateValuesFromDeck();
-                setContentView(mStudyOptionsView);
+                if (updateValuesFromDeck()) {
+                    setContentView(mStudyOptionsView);
+                } else {
+                	showContentView(CONTENT_DECK_NOT_LOADED);
+                }
                 break;
             case CONTENT_CONGRATS:
-                setCongratsMessage();
+            	Deck deck = DeckManager.getMainDeck();
+                if (deck != null) {
+            		int failedCards = deck.getFailedDelayedCount();
+                    int revCards = deck.getNextDueCards(1);
+                    int newCards = deck.getNextNewCards();
+                    int eta = deck.getETA(failedCards, revCards, newCards, true);
+                	mTextCongratsMessage.setText(getCongratsMessage(this, failedCards, revCards, newCards, eta));
+                }
                 updateValuesFromDeck();
                 setContentView(mCongratsView);
                 break;
@@ -1756,8 +1828,8 @@ public class StudyOptions extends Activity implements IButtonListener {
 
 
     private void resetAndUpdateValuesFromDeck() {
-        Deck deck = AnkiDroidApp.deck();
-        DeckTask.waitToFinish();
+        Deck deck = DeckManager.getMainDeck();
+//        DeckTask.waitToFinish();
         if (deck != null) {
             deck.reset();
         	updateValuesFromDeck();        	
@@ -1765,27 +1837,26 @@ public class StudyOptions extends Activity implements IButtonListener {
     }
 
 
-    private void hideDeckInformation() {
+    private void hideDeckInformation(boolean fade) {
     	setTitle(getResources().getString(R.string.app_name));
-        mTextDeckName.setVisibility(View.INVISIBLE);
-        mStatisticsField.setVisibility(View.INVISIBLE);
+        mDeckInformation.setVisibility(View.INVISIBLE);
+        if (fade) {
+        	mDeckInformation.setAnimation(ViewAnimation.fade(ViewAnimation.FADE_OUT, 500, 0));        	
+        }
     }
 
 
     private void showDeckInformation(boolean fade) {
         mTextDeckName.setVisibility(View.VISIBLE);
+        mDeckInformation.setVisibility(View.VISIBLE);
         if (fade) {
-            mTextDeckName.setAnimation(ViewAnimation.fade(ViewAnimation.FADE_IN, 500, 0));        	
-        }
-        mStatisticsField.setVisibility(View.VISIBLE);
-        if (fade) {
-        	mStatisticsField.setAnimation(ViewAnimation.fade(ViewAnimation.FADE_IN, 500, 0));
+        	mDeckInformation.setAnimation(ViewAnimation.fade(ViewAnimation.FADE_IN, 500, 0));
         }
     }
 
 
-    private void updateValuesFromDeck() {
-        Deck deck = AnkiDroidApp.deck();
+    private boolean updateValuesFromDeck() {
+        Deck deck = DeckManager.getMainDeck();
         Resources res = getResources();
         if (deck != null) {
         	int[] counts = deck.getSched().counts();
@@ -1831,6 +1902,7 @@ public class StudyOptions extends Activity implements IButtonListener {
                 updateStatisticBars();
             }
         }
+        return true;
     }
 
 
@@ -1852,6 +1924,8 @@ public class StudyOptions extends Activity implements IButtonListener {
 * Switch schedulers
 */
 
+    //UNUSED and never used, introduced in commit e44130abcd84928a288ddb0f3512e984ada190e7
+    /*
     private void reset() {
         reset(false);
     }
@@ -1861,6 +1935,7 @@ public class StudyOptions extends Activity implements IButtonListener {
         }
         AnkiDroidApp.deck().reset();
     }
+    */
 
 
     /**
@@ -1895,27 +1970,28 @@ public class StudyOptions extends Activity implements IButtonListener {
 
     @Override
     public boolean onCreateOptionsMenu(Menu menu) {
-        Utils.addMenuItemInActionBar(menu, Menu.NONE, MENU_OPEN, Menu.NONE, R.string.menu_open_deck,
+    	Utils.addMenuItemInActionBar(menu, Menu.NONE, MENU_OPEN, Menu.NONE, R.string.menu_open_deck,
                 R.drawable.ic_menu_manage);
         Utils.addMenuItemInActionBar(menu, Menu.NONE, MENU_SYNC, Menu.NONE, R.string.menu_sync,
                 R.drawable.ic_menu_refresh);        	
         Utils.addMenuItem(menu, Menu.NONE, MENU_ADD_FACT, Menu.NONE, R.string.menu_add_card,
                 R.drawable.ic_menu_add);
-        Utils.addMenuItem(menu, Menu.NONE, MENU_MORE_OPTIONS, Menu.NONE, R.string.studyoptions_more,
-                R.drawable.ic_menu_archive);
         Utils.addMenuItem(menu, Menu.NONE, MENU_PREFERENCES, Menu.NONE, R.string.menu_preferences,
                 R.drawable.ic_menu_preferences);
+        Utils.addMenuItem(menu, Menu.NONE, MENU_MORE_OPTIONS, Menu.NONE, R.string.studyoptions_more,
+                R.drawable.ic_menu_archive);
         Utils.addMenuItem(menu, Menu.NONE, MENU_ROTATE, Menu.NONE, R.string.menu_rotate,
                 android.R.drawable.ic_menu_always_landscape_portrait);        
         Utils.addMenuItem(menu, Menu.NONE, MENU_ZEEMOTE, Menu.NONE, R.string.menu_zeemote,
                 R.drawable.ic_menu_zeemote);
+    	Utils.addMenuItemInActionBar(menu, Menu.NONE, MENU_HELP, Menu.NONE, R.string.help_title, 0);
         return true;
     }
 
 
     @Override
     public boolean onPrepareOptionsMenu(Menu menu) {
-        boolean deckChangeable = (AnkiDroidApp.deck() != null) && mSdCardAvailable && !mToggleCram.isChecked();
+        boolean deckChangeable = (DeckManager.getMainDeck() != null) && mSdCardAvailable && !mToggleCram.isChecked();
         menu.findItem(MENU_OPEN).setEnabled(mSdCardAvailable);
         menu.findItem(MENU_ADD_FACT).setEnabled(deckChangeable);
         menu.findItem(MENU_MORE_OPTIONS).setEnabled(deckChangeable);
@@ -1928,6 +2004,10 @@ public class StudyOptions extends Activity implements IButtonListener {
     @Override
     public boolean onOptionsItemSelected(MenuItem item) {
         switch (item.getItemId()) {
+        	case MENU_HELP:
+        		showDialog(DIALOG_SELECT_HELP);
+        		return true;
+ 
             case MENU_OPEN:
                 openDeckPicker();
                 return true;
@@ -1948,7 +2028,8 @@ public class StudyOptions extends Activity implements IButtonListener {
 
             case MENU_ADD_FACT:
             	Intent intent = new Intent(StudyOptions.this, CardEditor.class);
-            	intent.putExtra(CardEditor.CARD_EDITOR_ACTION, CardEditor.ADD_CARD);
+            	intent.putExtra(CardEditor.EXTRA_CALLER, CardEditor.CALLER_STUDYOPTIONS);
+            	intent.putExtra(CardEditor.EXTRA_DECKPATH, DeckManager.getMainDeckPath());
             	startActivityForResult(intent, ADD_FACT);
                 if (getApiLevel() > 4) {
                     ActivityTransitionAnimation.slide(StudyOptions.this, ActivityTransitionAnimation.LEFT);
@@ -1977,12 +2058,14 @@ public class StudyOptions extends Activity implements IButtonListener {
 
 
     private void openDeckPicker() {
-//        closeOpenedDeck();
-        // deckLoaded = false;
+    	openDeckPicker(true);
+    }
+    private void openDeckPicker(boolean showAnimation) {
         Intent decksPicker = new Intent(StudyOptions.this, DeckPicker.class);
         mInDeckPicker = true;
+    	decksPicker.putExtra("showAnimation", showAnimation);
         startActivityForResult(decksPicker, PICK_DECK_REQUEST);
-    	if (getApiLevel() > 4) {
+    	if (showAnimation && getApiLevel() > 4) {
     		ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.RIGHT);
     	}
         // Log.i(AnkiDroidApp.TAG, "openDeckPicker - Ending");
@@ -2010,7 +2093,7 @@ public class StudyOptions extends Activity implements IButtonListener {
 
 
     private void openStatistics(int period) {
-        if (AnkiDroidApp.deck() != null) {
+        if (DeckManager.getMainDeck() != null) {
             DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_STATISTICS, mLoadStatisticsHandler, new DeckTask.TaskData(this, new String[]{""}, mStatisticType, period));
         }
     }
@@ -2028,12 +2111,7 @@ public class StudyOptions extends Activity implements IButtonListener {
 
     public void openPersonalDeckPicker() {
         if (AnkiDroidApp.isUserLoggedIn()) {
-            if (AnkiDroidApp.deck() != null)// && sdCardAvailable)
-            {
-                AnkiDroidApp.deck().closeDeck();
-                AnkiDroidApp.setDeck(null);
-                mCompat.invalidateOptionsMenu(this);
-            }
+            mCompat.invalidateOptionsMenu(this);
             startActivityForResult(
                     new Intent(StudyOptions.this, PersonalDeckPicker.class), DOWNLOAD_PERSONAL_DECK);
         	if (getApiLevel() > 4) {
@@ -2046,12 +2124,7 @@ public class StudyOptions extends Activity implements IButtonListener {
 
 
     public void openSharedDeckPicker() {
-        if (AnkiDroidApp.deck() != null)// && sdCardAvailable)
-        {
-            AnkiDroidApp.deck().closeDeck();
-            AnkiDroidApp.setDeck(null);
-            mCompat.invalidateOptionsMenu(this);
-        }
+        mCompat.invalidateOptionsMenu(this);
         // deckLoaded = false;
         startActivityForResult(new Intent(StudyOptions.this, SharedDeckPicker.class), DOWNLOAD_SHARED_DECK);
     	if (getApiLevel() > 4) {
@@ -2064,21 +2137,15 @@ public class StudyOptions extends Activity implements IButtonListener {
         // If decks directory does not exist, create it.
         File decksDirectory = new File(mPrefDeckPath);
         AnkiDroidApp.createDecksDirectoryIfMissing(decksDirectory);
-
-        File sampleDeckFile = new File(mPrefDeckPath, SAMPLE_DECK_NAME);
-        if (!sampleDeckFile.exists()) {
-            mDeckFilename = sampleDeckFile.getAbsolutePath();
-        	DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_TUTORIAL, mLoadDeckHandler, new DeckTask.TaskData(sampleDeckFile.getAbsolutePath()));
-        } else {
-        	Intent deckLoadIntent = new Intent();
-        	deckLoadIntent.putExtra(OPT_DB, sampleDeckFile.getAbsolutePath());
-        	onActivityResult(PICK_DECK_REQUEST, RESULT_OK, deckLoadIntent);
-    	}
+        mDeckFilename = mPrefDeckPath + "/" + SAMPLE_DECK_NAME;
+        savePreferences("deckFilename");
+        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_TUTORIAL, mLoadDeckHandler, new DeckTask.TaskData(mDeckFilename));        	
     }
 
+
     private void syncDeckWithPrompt() {
         if (AnkiDroidApp.isUserLoggedIn()) {
-            Deck deck = AnkiDroidApp.deck();
+            Deck deck = DeckManager.getMainDeck();
             if (deck != null) {
                 // Close existing sync progress dialog
                 if (mProgressDialog != null && mProgressDialog.isShowing()) {
@@ -2101,18 +2168,12 @@ public class StudyOptions extends Activity implements IButtonListener {
         String password = preferences.getString("password", "");
 
         if (AnkiDroidApp.isUserLoggedIn()) {
-            Deck deck = AnkiDroidApp.deck();
+            Deck deck = DeckManager.getMainDeck();
             if (deck != null) {
                 Log.i(AnkiDroidApp.TAG, "Synchronizing deck " + mDeckFilename + ", conflict resolution: " + conflictResolution);
-                Log.i(AnkiDroidApp.TAG, String.format(Utils.ENGLISH_LOCALE, "Before syncing - mod: %f, last sync: %f", deck.getModified(), deck.getLastSync()));            	
-            } else {
-            	return;
+                Log.i(AnkiDroidApp.TAG, String.format(Utils.ENGLISH_LOCALE, "Before syncing - mod: %f, last sync: %f", deck.getModified(), deck.getLastSync()));
+                Connection.syncDeck(mSyncListener, new Connection.Payload(new Object[] { username, password, deck, conflictResolution, true }));
             }
-        	if (Deck.isWalEnabled(deck.getDeckPath())) {
-        		deck = null;
-        	}
-            Connection.syncDeck(mSyncListener, new Connection.Payload(new Object[] { username, password, deck,
-                    mDeckFilename, conflictResolution }));
         } else {
         	showDialog(DIALOG_USER_NOT_LOGGED_IN);
         }
@@ -2123,12 +2184,22 @@ public class StudyOptions extends Activity implements IButtonListener {
     protected void onActivityResult(int requestCode, int resultCode, Intent intent) {
         super.onActivityResult(requestCode, resultCode, intent);
 
+        if (mStartedByBigWidget != EXTRA_START_NOTHING && ((requestCode == REQUEST_REVIEW && resultCode == Reviewer.RESULT_DEFAULT) || (requestCode == PICK_DECK_REQUEST && resultCode != RESULT_OK))) {
+        	DeckManager.closeMainDeck(DeckManager.REQUESTING_ACTIVITY_STUDYOPTIONS);
+        	finish();
+        	return;
+        } else {
+        	mStartedByBigWidget = EXTRA_START_NOTHING;
+        }
+
         if (resultCode == CONTENT_NO_EXTERNAL_STORAGE) {
             showContentView(CONTENT_NO_EXTERNAL_STORAGE);
         } else if (requestCode == PICK_DECK_REQUEST || requestCode == DOWNLOAD_PERSONAL_DECK
                 || requestCode == DOWNLOAD_SHARED_DECK) {
+            mInDeckPicker = false;
         	if (requestCode == PICK_DECK_REQUEST && resultCode == RESULT_CLOSE) {
-        		closeStudyOptions(false);
+        		closeStudyOptions(true);
+        		return;
         	} else if (requestCode == PICK_DECK_REQUEST && resultCode == RESULT_RESTART) {
         		restartApp();
         	}
@@ -2137,7 +2208,6 @@ public class StudyOptions extends Activity implements IButtonListener {
             // updateCard("");
             // hideSdError();
             // hideDeckErrors();
-            mInDeckPicker = false;
 
             if (requestCode == PICK_DECK_REQUEST && resultCode == RESULT_OK) {
                 showContentView(CONTENT_STUDY_OPTIONS);
@@ -2146,17 +2216,16 @@ public class StudyOptions extends Activity implements IButtonListener {
             	return;
             }
             if (resultCode != RESULT_OK) {
-                Log.e(AnkiDroidApp.TAG, "onActivityResult - Deck browser returned with error");
+                Log.i(AnkiDroidApp.TAG, "onActivityResult - Deck browser returned without picking new deck");
                 // Make sure we open the database again in onResume() if user pressed "back"
                 // deckSelected = false;
-                boolean fileNotDeleted = mDeckFilename != null && new File(mDeckFilename).exists();
-            	if (!fileNotDeleted) {
-                    AnkiDroidApp.setDeck(null);
+            	if (mDeckFilename == null || !(new File(mDeckFilename).exists())) {
+                    DeckManager.closeMainDeck();
                     mCompat.invalidateOptionsMenu(this);
                     showContentView(CONTENT_NO_DECK);
             	} else {
                 	showContentView(CONTENT_STUDY_OPTIONS);
-                    if (AnkiDroidApp.deck() == null || !AnkiDroidApp.deck().getDeckPath().equals(mDeckFilename)) {
+                    if (DeckManager.getMainDeck() == null || !DeckManager.getMainDeckPath().equals(mDeckFilename)) {
                     	if (resultCode != RESULT_DONT_RELOAD_DECK) {
                             displayProgressDialogAndLoadDeck();
                         }
@@ -2180,12 +2249,13 @@ public class StudyOptions extends Activity implements IButtonListener {
             	showContentView(CONTENT_NO_DECK);
             }
             // Log.i(AnkiDroidApp.TAG, "onActivityResult - deckSelected = " + deckSelected);
-            if (AnkiDroidApp.deck() == null || !AnkiDroidApp.deck().getDeckPath().equals(mDeckFilename)) {
+            if (DeckManager.getMainDeck() == null || !DeckManager.getMainDeckPath().equals(mDeckFilename)) {
                 boolean updateAllCards = (requestCode == DOWNLOAD_SHARED_DECK);
-                displayProgressDialogAndLoadDeck(updateAllCards);	
+                displayProgressDialogAndLoadDeck(updateAllCards);
             }
         } else if (requestCode == PREFERENCES_UPDATE) {
             restorePreferences();
+            BackupManager.initBackup();
             showContentView();
             if (resultCode == RESULT_RESTART) {
             	restartApp();
@@ -2201,6 +2271,8 @@ public class StudyOptions extends Activity implements IButtonListener {
         } else if (requestCode == REQUEST_REVIEW) {
             Log.i(AnkiDroidApp.TAG, "Result code = " + resultCode);
             // Return to standard scheduler
+    		mInReviewer = false;
+        	AnkiDroidWidgetBig.updateWidget(AnkiDroidWidgetBig.UpdateService.VIEW_NOT_SPECIFIED, false);
             switch (resultCode) {
                 case Reviewer.RESULT_SESSION_COMPLETED:
                 	showContentView(CONTENT_SESSION_COMPLETE);
@@ -2208,11 +2280,21 @@ public class StudyOptions extends Activity implements IButtonListener {
                 case Reviewer.RESULT_NO_MORE_CARDS:
                 	showContentView(CONTENT_CONGRATS);
                     break;
-                default:
+                case Reviewer.RESULT_ANSWERING_ERROR:
+                	showContentView(CONTENT_STUDY_OPTIONS);
+                	showDialog(DIALOG_DB_ERROR);
+                    break;
+                case Reviewer.RESULT_DECK_CLOSED:
+                	showContentView(CONTENT_STUDY_OPTIONS);
+                	mDeckFilename = PrefSettings.getSharedPrefs(getBaseContext()).getString("deckFilename", null);
+                	displayProgressDialogAndLoadDeck();
+                	break;
+                case Reviewer.RESULT_DEFAULT:
+                    DeckTask.launchDeckTask(DeckTask.TASK_TYPE_SAVE_DECK, mSaveAndResetDeckHandler, new DeckTask.TaskData(DeckManager.getMainDeck(), 0));
                 	showContentView(CONTENT_STUDY_OPTIONS);
                     break;
             }
-        } else if (requestCode == ADD_FACT && resultCode == RESULT_OK) {
+        } else if (requestCode == ADD_FACT && resultCode != RESULT_CANCELED) {
         	resetAndUpdateValuesFromDeck();
         } else if (requestCode == BROWSE_CARDS && resultCode == RESULT_OK) {
         	resetAndUpdateValuesFromDeck();
@@ -2228,18 +2310,25 @@ public class StudyOptions extends Activity implements IButtonListener {
         	}
     		resetAndUpdateValuesFromDeck();
         } else if (requestCode == REPORT_ERROR) {
-  	      // workaround for dialog problems when returning from error reporter
-  	      	try {
-  	      		if (mWelcomeAlert != null && mWelcomeAlert.isShowing()) {
-  	      			mWelcomeAlert.dismiss();
-      				mWelcomeAlert.show();
-  	      		} else if (mNewVersionAlert != null && mNewVersionAlert.isShowing()) {
-  	      			mNewVersionAlert.dismiss();
-  	      			mNewVersionAlert.show();
-  	      		}
-  	      	} catch (IllegalArgumentException e) {
-  	      		Log.e(AnkiDroidApp.TAG, "Error on dismissing and showing dialog: " + e);
-  	      	}
+  	      	if (mShowRepairDialog) {
+  	      		showDialog(DIALOG_DB_ERROR);
+  	      		mShowRepairDialog = false;
+  	      	} else if (showDeckPickerOnStartup()) {
+        		openDeckPicker();
+        	} else {
+        		// workaround for dialog problems when returning from error reporter
+        		try {
+      	      		if (mWelcomeAlert != null && mWelcomeAlert.isShowing()) {
+      	      			mWelcomeAlert.dismiss();
+          				mWelcomeAlert.show();
+      	      		} else if (mNewVersionAlert != null && mNewVersionAlert.isShowing()) {
+      	      			mNewVersionAlert.dismiss();
+      	      			mNewVersionAlert.show();
+      	      		}
+      	      	} catch (IllegalArgumentException e) {
+      	      		Log.e(AnkiDroidApp.TAG, "Error on dismissing and showing dialog: " + e);
+      	      	}
+        	}
         }
     }
 
@@ -2361,7 +2450,7 @@ public class StudyOptions extends Activity implements IButtonListener {
     private void setLanguage(String language) {
     	Locale locale;
     	if (language.equals("")) {
-        	return;
+        	locale = Locale.getDefault();
     	} else {
         	locale = new Locale(language);
     	}
@@ -2390,12 +2479,14 @@ public class StudyOptions extends Activity implements IButtonListener {
         	mToggleCram.setChecked(false);
         	mToggleLimit.setEnabled(true);
 
+        	// close previous deck
+        	DeckManager.closeMainDeck(DeckManager.REQUESTING_ACTIVITY_STUDYOPTIONS);
+
             if (updateAllCards) {
                 DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_DECK_AND_UPDATE_CARDS, mLoadDeckHandler,
-                        new DeckTask.TaskData(AnkiDroidApp.deck(), mDeckFilename));
+                        new DeckTask.TaskData(DeckManager.REQUESTING_ACTIVITY_STUDYOPTIONS, mDeckFilename));
             } else {
-                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_DECK, mLoadDeckHandler, new DeckTask.TaskData(
-                		AnkiDroidApp.deck(), mDeckFilename));
+                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_DECK, mLoadDeckHandler, new DeckTask.TaskData(DeckManager.REQUESTING_ACTIVITY_STUDYOPTIONS, mDeckFilename));
             }
         } else {
             if (mDeckFilename == null) {
@@ -2417,11 +2508,43 @@ public class StudyOptions extends Activity implements IButtonListener {
     }
 
 
+    DeckTask.TaskListener mRepairDeckHandler = new DeckTask.TaskListener() {
+
+    	@Override
+        public void onPreExecute() {
+            mProgressDialog = StyledProgressDialog.show(StudyOptions.this, "", getResources()
+                    .getString(R.string.backup_repair_deck_progress), true);
+        }
+
+
+        @Override
+        public void onPostExecute(DeckTask.TaskData result) {
+        	if (result.getBoolean()) {
+        		displayProgressDialogAndLoadDeck();
+        	} else {
+        		Themes.showThemedToast(StudyOptions.this, getResources().getString(R.string.deck_repair_error), true);
+        	}
+        	if (mProgressDialog != null && mProgressDialog.isShowing()) {
+        		mProgressDialog.dismiss();
+        	}
+        	if (mRepairFileName != null) {
+            	mRepairFileName = null;
+        		finish();
+        	}
+        }
+ 
+		@Override
+		public void onProgressUpdate(TaskData... values) {
+		}
+
+    };
+
+
     DeckTask.TaskListener mRestoreDeckHandler = new DeckTask.TaskListener() {
 
     	@Override
         public void onPreExecute() {
-            mProgressDialog = ProgressDialog.show(StudyOptions.this, "", getResources()
+            mProgressDialog = StyledProgressDialog.show(StudyOptions.this, "", getResources()
                     .getString(R.string.backup_restore_deck), true);
         }
 
@@ -2457,24 +2580,27 @@ public class StudyOptions extends Activity implements IButtonListener {
 
         @Override
         public void onPreExecute() {
+            setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_NOSENSOR);
             // if(updateDialog == null || !updateDialog.isShowing())
             // {
         	if (mProgressDialog != null && mProgressDialog.isShowing()) {
         		mProgressDialog.setMessage(getResources().getString(R.string.loading_deck));
         	} else {
-                mProgressDialog = ProgressDialog.show(StudyOptions.this, "", getResources()
+                mProgressDialog = StyledProgressDialog.show(StudyOptions.this, "", getResources()
                         .getString(R.string.loading_deck), true, true, new OnCancelListener() {
 
     						@Override
     						public void onCancel(DialogInterface dialog) {
     							mNewVersionAlert = null;
-    				            closeOpenedDeck();
+    							DeckTask.cancelTask();
+    				            DeckManager.closeMainDeck(DeckManager.REQUESTING_ACTIVITY_STUDYOPTIONS);
+    				            mCompat.invalidateOptionsMenu(StudyOptions.this);
     				            MetaDB.closeDB();
     				            finish();
     						}
                 });
         	}
-	    	hideDeckInformation();
+	    	hideDeckInformation(false);
             // }
         }
 
@@ -2482,26 +2608,23 @@ public class StudyOptions extends Activity implements IButtonListener {
         @Override
         public void onPostExecute(DeckTask.TaskData result) {
 
-            // Close the previously opened deck.
-            // if (AnkidroidApp.deck() != null)
-            // {
-            // AnkidroidApp.deck().closeDeck();
-            // AnkidroidApp.setDeck(null);
             // mCompat.invalidateOptionsMenu(StudyOptions.this);
             // }
+            setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR);
+
+            allTags = null;
 
             switch (result.getInt()) {
                 case DeckTask.DECK_LOADED:
                     // Set the deck in the application instance, so other activities
                     // can access the loaded deck.
-                    AnkiDroidApp.setDeck(result.getDeck());
                     mCompat.invalidateOptionsMenu(StudyOptions.this);
 
-                    updateValuesFromDeck();
                     showContentView(CONTENT_STUDY_OPTIONS);
                     showDeckInformation(true);
 
                     if (!mPrefStudyOptions) {
+                		mInReviewer = true;
                         startActivityForResult(new Intent(StudyOptions.this, Reviewer.class), REQUEST_REVIEW);
                     }
                     int lim;
@@ -2514,9 +2637,8 @@ public class StudyOptions extends Activity implements IButtonListener {
                     break;
 
                 case DeckTask.DECK_NOT_LOADED:
+                	BackupManager.restoreDeckIfMissing(mDeckFilename);
                 	showContentView(CONTENT_DECK_NOT_LOADED);
-                	mCurrentDialogMessage = getResources().getString(R.string.open_deck_failed, new File(mDeckFilename).getName().replace(".anki", ""), BackupManager.BROKEN_DECKS_SUFFIX.replace("/", ""), getResources().getString(R.string.repair_deck));
-        			showDialog(DIALOG_DECK_NOT_LOADED);
                     break;
 
                 case DeckTask.DECK_EMPTY:
@@ -2543,7 +2665,7 @@ public class StudyOptions extends Activity implements IButtonListener {
                 	}
                 }
             }
-            Deck deck = AnkiDroidApp.deck();
+            Deck deck = DeckManager.getMainDeck();
             if (deck != null) {
 //                mToggleLimit.setChecked(deck.isLimitedByTag() || deck.getSessionRepLimit() + deck.getSessionTimeLimit() > 0);
             }
@@ -2585,34 +2707,6 @@ public class StudyOptions extends Activity implements IButtonListener {
     };
 
 
-    DeckTask.TaskListener mCloseDeckHandler = new DeckTask.TaskListener() {
-
-        @Override
-        public void onPreExecute() {
-        	mIsClosing = true;
-            mProgressDialog = ProgressDialog.show(StudyOptions.this, "", getResources()
-                    .getString(R.string.close_deck), true);
-        }
-
-
-        @Override
-        public void onPostExecute(DeckTask.TaskData result) {
-        	mIsClosing = false;
-        	if (mProgressDialog != null && mProgressDialog.isShowing()) {
-        		mProgressDialog.dismiss();
-        	}
-        	AnkiDroidApp.setDeck(null);
-            mCompat.invalidateOptionsMenu(StudyOptions.this);
-            StudyOptions.this.finish();
-        }
-
-
-        @Override
-        public void onProgressUpdate(DeckTask.TaskData... values) {
-        }
-    };
-
-
     Connection.TaskListener mSyncListener = new Connection.TaskListener() {
 
         @Override
@@ -2624,17 +2718,19 @@ public class StudyOptions extends Activity implements IButtonListener {
         @Override
         public void onPostExecute(Payload data) {
             Log.i(AnkiDroidApp.TAG, "onPostExecute");
-            if (mProgressDialog != null) {
+            if (mProgressDialog != null && mProgressDialog.isShowing()) {
                 mProgressDialog.dismiss();
                 setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR);
             }
             if (data.success) {
             	mCurrentDialogMessage = ((HashMap<String, String>) data.result).get("message");
-                AnkiDroidApp.deck().updateCutoff();
+            	DeckManager.getMainDeck().updateCutoff();
                 resetAndUpdateValuesFromDeck();
                 showDialog(DIALOG_SYNC_LOG);
             } else {
-                if (data.returnType == AnkiDroidProxy.SYNC_CONFLICT_RESOLUTION) {
+                if (data.returnType == AnkiDroidProxy.DB_ERROR) {
+                	showDialog(DIALOG_DB_ERROR);
+                } else if (data.returnType == AnkiDroidProxy.SYNC_CONFLICT_RESOLUTION) {
                     // Need to ask user for conflict resolution direction and re-run sync
                     syncDeckWithPrompt();
                 } else {
@@ -2665,7 +2761,7 @@ public class StudyOptions extends Activity implements IButtonListener {
                 values[1] = res.getString(R.string.sync_downloading_media, done, total);
             }
             if (mProgressDialog == null || !mProgressDialog.isShowing()) {
-                mProgressDialog = ProgressDialog.show(StudyOptions.this, (String) values[0], (String) values[1]);
+                mProgressDialog = StyledProgressDialog.show(StudyOptions.this, (String) values[0], (String) values[1]);
                 // Forbid orientation changes as long as progress dialog is shown
                 setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_NOSENSOR);
             } else {
@@ -2703,7 +2799,7 @@ public class StudyOptions extends Activity implements IButtonListener {
 
 		@Override
 		public void onPreExecute() {
-            mProgressDialog = ProgressDialog.show(StudyOptions.this, "", getResources()
+            mProgressDialog = StyledProgressDialog.show(StudyOptions.this, "", getResources()
                     .getString(R.string.calculating_statistics), true);
 		}
 
@@ -2714,6 +2810,22 @@ public class StudyOptions extends Activity implements IButtonListener {
     };
 
 
+    DeckTask.TaskListener mSaveAndResetDeckHandler = new DeckTask.TaskListener() {
+        @Override
+        public void onPreExecute() {
+        	mDeckNotAvailable = true;
+        }
+        @Override
+        public void onPostExecute(DeckTask.TaskData result) {
+        	mDeckNotAvailable = false;
+        	updateValuesFromDeck();
+        }
+        @Override
+        public void onProgressUpdate(DeckTask.TaskData... values) {
+        }
+    };
+
+
     class MyGestureDetector extends SimpleOnGestureListener {
     	@Override
         public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
@@ -2774,7 +2886,7 @@ public class StudyOptions extends Activity implements IButtonListener {
         Intent loadDeckIntent = new Intent(context, StudyOptions.class);
         loadDeckIntent.setAction(Intent.ACTION_MAIN);
         loadDeckIntent.addCategory(Intent.CATEGORY_LAUNCHER);
-        loadDeckIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        loadDeckIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
         loadDeckIntent.putExtra(StudyOptions.EXTRA_DECK, deckPath);
         return loadDeckIntent;
     }
diff --git a/src/com/ichi2/anki/Whiteboard.java b/src/com/ichi2/anki/Whiteboard.java
index 272c76fe2f..0f0771ce95 100644
--- a/src/com/ichi2/anki/Whiteboard.java
+++ b/src/com/ichi2/anki/Whiteboard.java
@@ -24,7 +24,6 @@ import android.graphics.Canvas;
 import android.graphics.Color;
 import android.graphics.Paint;
 import android.graphics.Path;
-import android.util.AttributeSet;
 import android.view.MotionEvent;
 import android.view.View;
 
diff --git a/src/com/ichi2/anki/WidgetStatus.java b/src/com/ichi2/anki/WidgetStatus.java
deleted file mode 100644
index a0987d7dc4..0000000000
--- a/src/com/ichi2/anki/WidgetStatus.java
+++ /dev/null
@@ -1,202 +0,0 @@
-/***************************************************************************************
- * This program is free software; you can redistribute it and/or modify it under        *
- * the terms of the GNU General Public License as published by the Free Software        *
- * Foundation; either version 3 of the License, or (at your option) any later           *
- * version.                                                                             *
- *                                                                                      *
- * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
- * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
- *                                                                                      *
- * You should have received a copy of the GNU General Public License along with         *
- * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
- ****************************************************************************************/
-
-package com.ichi2.anki;
-
-import com.ichi2.libanki.Deck;
-import com.ichi2.libanki.Scheduler;
-import com.tomgibara.android.veecheck.util.PrefSettings;
-
-import android.content.Context;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.database.SQLException;
-import android.os.AsyncTask;
-import android.util.Log;
-
-import java.io.File;
-import java.io.FileFilter;
-import java.util.ArrayList;
-import java.util.Collections;
-
-/**
- * The status of the widget.
- * <p>
- * It contains the status of each of the decks.
- */
-public final class WidgetStatus {
-
-	static boolean mediumWidget = false;
-	static boolean smallWidget = false;
-
-    /** This class should not be instantiated. */
-    private WidgetStatus() {}
-
-    /** Request the widget to update its status. */
-    public static void update(Context context) {
-        // Only update the widget if it is enabled.
-        // TODO(flerda): Split widget from notifications.
-        SharedPreferences preferences = PrefSettings.getSharedPrefs(context);
-        if (preferences.getBoolean("widgetEnabled", false)) {
-            mediumWidget = true;
-        } else {
-            mediumWidget = false;
-        }
-        if (preferences.getBoolean("widgetSmallEnabled", false)) {
-            smallWidget = true;
-        } else {
-            smallWidget = false;
-        }
-	if (mediumWidget || smallWidget) {
-            Log.d(AnkiDroidApp.TAG, "WidgetStatus.update(): updating");
-            AsyncTask<Context,Void,Context> updateDeckStatusAsyncTask =
-                    new UpdateDeckStatusAsyncTask();
-            updateDeckStatusAsyncTask.execute(context);
-        } else {
-            Log.d(AnkiDroidApp.TAG, "WidgetStatus.update(): not enabled");
-        }
-    }
-
-    /** Returns the status of each of the decks. */
-    public static DeckStatus[] fetch(Context context) {
-        return MetaDB.getWidgetStatus(context);
-    }
-
-    /** Returns the status of each of the decks. */
-    public static int[] fetchSmall(Context context) {
-        return MetaDB.getWidgetSmallStatus(context);
-    }
-
-    private static class UpdateDeckStatusAsyncTask extends AsyncTask<Context, Void, Context> {
-        private static final DeckStatus[] EMPTY_DECK_STATUS = new DeckStatus[0];
-
-        private static DeckStatus[] mDecks = EMPTY_DECK_STATUS;
-
-        @Override
-        protected Context doInBackground(Context... params) {
-            Log.d(AnkiDroidApp.TAG, "WidgetStatus.UpdateDeckStatusAsyncTask.doInBackground()");
-
-            Context context = params[0];
-
-            SharedPreferences preferences = PrefSettings.getSharedPrefs(context);
-            String deckPath = preferences.getString("deckPath",
-                    AnkiDroidApp.getStorageDirectory() + "/AnkiDroid");
-
-            File dir = new File(deckPath);
-
-            File[] fileList = dir.listFiles(new AnkiFileFilter());
-
-            if (fileList == null || fileList.length == 0) {
-                mDecks = EMPTY_DECK_STATUS;
-                return context;
-            }
-
-            // For the deck information
-            ArrayList<DeckStatus> decks = new ArrayList<DeckStatus>(fileList.length);
-
-            for (File file : fileList) {
-                try {
-                    // Run through the decks and get the information
-                    String absPath = file.getAbsolutePath();
-                    String deckName = file.getName().replaceAll(".anki", "");
-
-                    Log.i(AnkiDroidApp.TAG, "Found deck: " + absPath);
-
-                    Deck deck;
-                    Deck currentDeck = AnkiDroidApp.deck();
-                    if (currentDeck != null && currentDeck.getDeckPath().equals(deckName)) {
-                    	deck = currentDeck;
-                    } else {
-                    	try {
-                        	deck = Deck.openDeck(absPath, false);                    		
-            			} catch (RuntimeException e) {
-            				Log.w(AnkiDroidApp.TAG, "Widget: Could not open database " + absPath + ": " + e);
-            				deck = null;
-            			}
-                    }
-                    if (deck == null) {
-                        Log.e(AnkiDroidApp.TAG, "Skipping null deck: " + absPath);
-                        // Use the data from the last time we updated the deck, if available.
-                        for (DeckStatus deckStatus : mDecks) {
-                            if (absPath.equals(deckStatus.mDeckPath)) {
-                                Log.d(AnkiDroidApp.TAG, "Using previous value");
-                                decks.add(deckStatus);
-                                break;
-                            }
-                        }
-                        continue;
-                    }
-                    int[] counts = deck.getSched().counts();
-                    // Close the database connection, but only if this is not the current database.
-                    // Probably we need to make this atomic to be sure it will not cause a failure.
-                    if (currentDeck != null && currentDeck.getDB() != deck.getDB()) {
-                        deck.closeDeck();
-                    }
-
-                    // Add the information about the deck
-                    decks.add(new DeckStatus(absPath, deckName, counts[Scheduler.COUNTS_NEW], counts[Scheduler.COUNTS_REV], counts[Scheduler.COUNTS_LRN], eta, reps));
-                } catch (SQLException e) {
-                    Log.i(AnkiDroidApp.TAG, "Could not open deck");
-                    Log.e(AnkiDroidApp.TAG, e.toString());
-                }
-            }
-
-            if (!decks.isEmpty() && decks.size() > 1) {
-                // Sort and reverse the list if there are decks
-                Log.i(AnkiDroidApp.TAG, "Sorting deck");
-
-                // Ordered by reverse due cards number
-                Collections.sort(decks, new ByDueComparator());
-            }
-
-            mDecks = decks.toArray(EMPTY_DECK_STATUS);
-            return context;
-        }
-
-        @Override
-        protected void onPostExecute(Context context) {
-            Log.d(AnkiDroidApp.TAG, "WidgetStatus.UpdateDeckStatusAsyncTask.onPostExecute()");
-            MetaDB.storeWidgetStatus(context, mDecks);
-	    if (mediumWidget) {
-	        Intent intent;
-                intent = new Intent(context, AnkiDroidWidgetMedium.UpdateService.class);
-                intent.setAction(AnkiDroidWidgetMedium.UpdateService.ACTION_UPDATE);
-                context.startService(intent);
-            }
-            if (smallWidget) {
-	        Intent intent;
-                intent = new Intent(context, AnkiDroidWidgetSmall.UpdateService.class);
-                intent.setAction(AnkiDroidWidgetSmall.UpdateService.ACTION_UPDATE);            	
-                context.startService(intent);
-            } 
-        }
-
-        /** Comparator that sorts instances of {@link DeckStatus} based on number of due cards. */
-        private static class ByDueComparator implements java.util.Comparator<DeckStatus> {
-            @Override
-            public int compare(DeckStatus deck1, DeckStatus deck2) {
-                // Reverse due cards number order
-                return deck2.mDueCards - deck1.mDueCards;
-            }
-        }
-
-        /** Filter for Anki files. */
-        private static final class AnkiFileFilter implements FileFilter {
-            @Override
-            public boolean accept(File pathname) {
-                return pathname.isFile() && pathname.getName().endsWith(".anki");
-            }
-        }
-    }
-}
diff --git a/src/com/ichi2/anki/services/DownloadManagerService.java b/src/com/ichi2/anki/services/DownloadManagerService.java
index 3a01d60b0a..58bdee9cea 100644
--- a/src/com/ichi2/anki/services/DownloadManagerService.java
+++ b/src/com/ichi2/anki/services/DownloadManagerService.java
@@ -25,7 +25,6 @@ import android.content.SharedPreferences.Editor;
 import android.content.res.Resources;
 import android.database.CursorIndexOutOfBoundsException;
 import android.database.SQLException;
-import android.net.Uri;
 import android.os.AsyncTask;
 import android.os.IBinder;
 import android.os.RemoteCallbackList;
@@ -34,6 +33,7 @@ import android.util.Log;
 
 import com.ichi2.anki.AnkiDroidApp;
 import com.ichi2.anki.AnkiDroidProxy;
+import com.ichi2.anki.DeckManager;
 import com.ichi2.anki.DeckTask;
 import com.ichi2.anki.Download;
 import com.ichi2.anki.R;
@@ -232,7 +232,7 @@ public class DownloadManagerService extends Service {
 
         File dir = new File(mDestination + "/tmp/");
         File[] fileList = dir.listFiles(new IncompleteDownloadsFilter());
-        HashSet<String> filenames = new HashSet();
+        HashSet<String> filenames = new HashSet<String>();
 
         // Get all incomplete downloads filenames
         if (fileList != null) {
@@ -935,7 +935,6 @@ public class DownloadManagerService extends Service {
 
             Payload data = doInBackgroundLoadDeck(args);
             if (data.returnType == DeckTask.DECK_LOADED) {
-                double now = System.currentTimeMillis();
                 HashMap<String, Object> results = (HashMap<String, Object>) data.result;
                 Deck deck = (Deck) results.get("deck");
 //                if (!deck.isUnpackNeeded()) {
@@ -1021,7 +1020,7 @@ public class DownloadManagerService extends Service {
             Log.i(AnkiDroidApp.TAG, "loadDeck - SD card mounted and existent file -> Loading deck...");
             try {
                 // Open the right deck.
-                Deck deck = Deck.openDeck(deckFilename);
+                Deck deck = DeckManager.getDeck(deckFilename, DeckManager.REQUESTING_ACTIVITY_DOWNLOADMANAGER);
                 // Start by getting the first card and displaying it.
 //                Card card = deck.getCard();
                 Log.i(AnkiDroidApp.TAG, "Deck loaded!");
@@ -1057,9 +1056,8 @@ public class DownloadManagerService extends Service {
             HashMap<String, Object> results = (HashMap<String, Object>) result.result;
             Deck deck = (Deck) results.get("deck");
             // Close the previously opened deck.
-            if (deck != null) {
-                deck.closeDeck();
-            }
+            DeckManager.closeDeck(deck.getDeckPath());
+
             SharedDeckDownload download = (SharedDeckDownload) result.data[0];
             SharedPreferences pref = PrefSettings.getSharedPrefs(getBaseContext());
             Editor editor = pref.edit();
diff --git a/src/com/ichi2/anki/services/NotificationService.java b/src/com/ichi2/anki/services/NotificationService.java
new file mode 100644
index 0000000000..8cd8e0cd11
--- /dev/null
+++ b/src/com/ichi2/anki/services/NotificationService.java
@@ -0,0 +1,96 @@
+/***************************************************************************************
+ * This program is free software; you can redistribute it and/or modify it under        *
+ * the terms of the GNU General Public License as published by the Free Software        *
+ * Foundation; either version 3 of the License, or (at your option) any later           *
+ * version.                                                                             *
+ *                                                                                      *
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
+ *                                                                                      *
+ * You should have received a copy of the GNU General Public License along with         *
+ * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
+ ****************************************************************************************/
+
+package com.ichi2.anki.services;
+
+import com.ichi2.anki.AnkiDroidApp;
+import com.ichi2.anki.R;
+import com.ichi2.anki.StudyOptions;
+import com.ichi2.widget.WidgetStatus;
+import com.tomgibara.android.veecheck.util.PrefSettings;
+
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.app.Service;
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.os.IBinder;
+
+import android.util.Log;
+
+public class NotificationService extends Service {
+
+    /** The notification service to show notifications of due cards. */
+    private NotificationManager mNotificationManager;
+
+    /** The id of the notification for due cards. */
+    private static final int WIDGET_NOTIFY_ID = 1;
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        mNotificationManager =
+            (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
+    }
+
+
+    @Override
+    public void onStart(Intent intent, int startId) {
+        Log.i(AnkiDroidApp.TAG, "NotificationService: OnStart");
+
+        Context context = AnkiDroidApp.getInstance().getBaseContext();
+        SharedPreferences preferences = PrefSettings.getSharedPrefs(context);
+        int minimumCardsDueForNotification = Integer.parseInt(preferences.getString("minimumCardsDueForNotification", "25"));
+        int dueCardsCount = WidgetStatus.fetchDue(context);
+        if (dueCardsCount >= minimumCardsDueForNotification) {
+            // Show a notification
+            int icon = R.drawable.anki;
+            CharSequence tickerText = String.format(
+                    getString(R.string.widget_minimum_cards_due_notification_ticker_text),
+                    dueCardsCount);
+            long when = System.currentTimeMillis();
+
+            Notification notification = new Notification(icon, tickerText, when);
+
+            if (preferences.getBoolean("widgetVibrate", false)) {
+                notification.defaults |= Notification.DEFAULT_VIBRATE;
+            }
+            if (preferences.getBoolean("widgetBlink", false)) {
+                notification.defaults |= Notification.DEFAULT_LIGHTS;
+            }
+
+            Context appContext = getApplicationContext();
+            CharSequence contentTitle = getText(R.string.widget_minimum_cards_due_notification_ticker_title);
+
+            Intent ankiDroidIntent = new Intent(context, StudyOptions.class);
+            ankiDroidIntent.setAction(Intent.ACTION_MAIN);
+            ankiDroidIntent.addCategory(Intent.CATEGORY_LAUNCHER);
+            PendingIntent pendingAnkiDroidIntent = PendingIntent.getActivity(context, 0, ankiDroidIntent, PendingIntent.FLAG_UPDATE_CURRENT);
+            notification.setLatestEventInfo(appContext, contentTitle, tickerText, pendingAnkiDroidIntent);
+
+            mNotificationManager.notify(WIDGET_NOTIFY_ID, notification);
+        } else {
+            // Cancel the existing notification, if any.
+            mNotificationManager.cancel(WIDGET_NOTIFY_ID);
+        }
+    }
+
+
+	@Override
+	public IBinder onBind(Intent arg0) {
+		return null;
+	}
+}
\ No newline at end of file
diff --git a/src/com/ichi2/async/Connection.java b/src/com/ichi2/async/Connection.java
index 44759b3c26..ec131c6a29 100644
--- a/src/com/ichi2/async/Connection.java
+++ b/src/com/ichi2/async/Connection.java
@@ -21,6 +21,7 @@ import android.content.Context;
 import android.content.SharedPreferences;
 import android.content.res.Resources;
 import android.database.Cursor;
+import android.database.SQLException;
 import android.net.ConnectivityManager;
 import android.net.Uri;
 import android.os.AsyncTask;
@@ -30,6 +31,7 @@ import com.ichi2.anki.AnkiDatabaseManager;
 import com.ichi2.anki.AnkiDb;
 import com.ichi2.anki.AnkiDroidApp;
 import com.ichi2.anki.AnkiDroidProxy;
+import com.ichi2.anki.DeckManager;
 import com.ichi2.anki.Feedback;
 import com.ichi2.anki.R;
 import com.ichi2.anki.Reviewer;
@@ -98,7 +100,8 @@ public class Connection extends AsyncTask<Connection.Payload, Object, Connection
         sInstance = new Connection();
         sInstance.mListener = listener;
 
-        return (Connection) sInstance.execute(data);
+        sInstance.execute(data);
+        return sInstance;
     }
 
 
@@ -182,11 +185,14 @@ public class Connection extends AsyncTask<Connection.Payload, Object, Connection
         return launchConnectionTask(listener, data);
     }
 
-    
     @Override
     protected Payload doInBackground(Payload... params) {
-        Payload data = params[0];
-
+    	if (params.length != 1)
+    		throw new IllegalArgumentException();
+    	return doOneInBackground(params[0]);
+    }
+    
+    private Payload doOneInBackground(Payload data) {
         switch (data.taskType) {
             case TASK_TYPE_LOGIN:
                 return doInBackgroundLogin(data);
@@ -245,10 +251,7 @@ public class Connection extends AsyncTask<Connection.Payload, Object, Connection
 
 
     private Payload doInBackgroundGetSharedDecks(Payload data) {
-        if (AnkiDroidApp.deck() != null) {
-            AnkiDroidApp.deck().closeDeck();
-            AnkiDroidApp.setDeck(null);
-        }
+    	DeckManager.closeMainDeck();
         try {
             data.result = AnkiDroidProxy.getSharedDecks();
         } catch (OutOfMemoryError e) {
@@ -267,10 +270,7 @@ public class Connection extends AsyncTask<Connection.Payload, Object, Connection
 
     private Payload doInBackgroundGetPersonalDecks(Payload data) {
         Resources res = sContext.getResources();
-        if (AnkiDroidApp.deck() != null) {
-            AnkiDroidApp.deck().closeDeck();
-            AnkiDroidApp.setDeck(null);
-        }
+    	DeckManager.closeMainDeck();
         try {
             String username = (String) data.data[0];
             String password = (String) data.data[1];
@@ -312,21 +312,20 @@ public class Connection extends AsyncTask<Connection.Payload, Object, Connection
         //Log.i(AnkiDroidApp.TAG, "username = " + username);
         //Log.i(AnkiDroidApp.TAG, "password = " + password);
 
-        Deck currentDeck = AnkiDroidApp.deck();
-        if (currentDeck != null) {
-        	currentDeck.closeDeck();
-        }
+        DeckManager.closeAllDecks();
 
         ArrayList<HashMap<String, String>> decksToSync = (ArrayList<HashMap<String, String>>) data.data[2];
         for (HashMap<String, String> deckToSync : decksToSync) {
             Log.i(AnkiDroidApp.TAG, "Synchronizing deck");
             String deckPath = deckToSync.get("filepath");
             try {
-            	boolean forceDeleteJournalMode =  Deck.isWalEnabled(deckPath);
-                Deck deck = Deck.openDeck(deckPath, true, forceDeleteJournalMode);
+                Deck deck = DeckManager.getDeck(deckPath, DeckManager.REQUESTING_ACTIVITY_SYNCCLIENT, true);
 
-                Payload syncDeckData = new Payload(new Object[] { username, password, deck, deckPath, null });
+                Payload syncDeckData = new Payload(new Object[] { username, password, deck, null, false });
                 syncDeckData = doInBackgroundSyncDeck(syncDeckData);
+
+                DeckManager.closeDeck(deckPath);
+
                 decksChangelogs.add((HashMap<String, String>) syncDeckData.result);
             } catch (Exception e) {
                 Log.e(AnkiDroidApp.TAG, "Exception e = " + e.getMessage());
@@ -355,241 +354,256 @@ public class Connection extends AsyncTask<Connection.Payload, Object, Connection
         String username = (String) data.data[0];
         String password = (String) data.data[1];
         Deck deck = (Deck) data.data[2];
-        String deckPath = (String) data.data[3];
+        String deckPath = deck.getDeckPath();
         String syncName = deckPath.substring(deckPath.lastIndexOf("/") + 1, deckPath.length() - 5);
-        String conflictResolution = (String) data.data[4];
+        String conflictResolution = (String) data.data[3];
+        boolean singleDeckSync = (Boolean) data.data[4];
 
-        if (deck == null) {
-        	// if syncing in study options screen, deck is set to null if wal mode is enabled
-        	publishProgress(syncName, res.getString(R.string.sync_set_journal_mode));
-        	deck = Deck.openDeck(deckPath, true, true);
-        }
+        try {
+            syncChangelog.put("deckName", syncName);
 
-        syncChangelog.put("deckName", syncName);
+            if (singleDeckSync) {
+            	// if syncing in study options screen, deck must be reloaded in order to set delete journal mode
+            	publishProgress(syncName, res.getString(R.string.sync_set_journal_mode));
+            	DeckManager.getDeck(deckPath, true, true, DeckManager.REQUESTING_ACTIVITY_SYNCCLIENT, true);
+            }
 
-        AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deckPath);
-        ankiDB.getDatabase().beginTransaction();
-        try {
-            AnkiDroidProxy server = new AnkiDroidProxy(username, password);
 
-            publishProgress(syncName, res.getString(R.string.sync_connecting_message));
-            int connectResult = server.connect(true);
-            if (connectResult != AnkiDroidProxy.LOGIN_OK) {
-                if (connectResult == AnkiDroidProxy.LOGIN_INVALID_USER_PASS) {
-                    syncChangelog.put("message", res.getString(R.string.invalid_username_password));
-                } else if (connectResult == AnkiDroidProxy.LOGIN_CLOCKS_UNSYNCED) {
-                    double diff = server.getTimediff();
-                    if (Math.abs(diff) >= 86400.0) {
-                        // The difference if more than a day
-                        syncChangelog.put("message", res.getString(R.string.sync_log_clocks_unsynchronized,
-                                ((long) diff), res.getString(R.string.sync_log_clocks_unsynchronized_date)));
-                    } else if (Math.abs((Math.abs(diff) % 3600.0) - 1800.0) >= 1500.0) {
-                        // The difference would be within limit if we adjusted the time by few hours
-                        // It doesn't work for all timezones, but it covers most and it's a guess anyway
-                        syncChangelog.put("message", res.getString(R.string.sync_log_clocks_unsynchronized,
-                                ((long) diff), res.getString(R.string.sync_log_clocks_unsynchronized_tz)));
+            AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deckPath);
+            ankiDB.getDatabase().beginTransaction();
+
+            try {
+                AnkiDroidProxy server = new AnkiDroidProxy(username, password);
+
+                publishProgress(syncName, res.getString(R.string.sync_connecting_message));
+                int connectResult = server.connect(true);
+                if (connectResult != AnkiDroidProxy.LOGIN_OK) {
+                    if (connectResult == AnkiDroidProxy.LOGIN_INVALID_USER_PASS) {
+                        syncChangelog.put("message", res.getString(R.string.invalid_username_password));
+                    } else if (connectResult == AnkiDroidProxy.LOGIN_CLOCKS_UNSYNCED) {
+                        double diff = server.getTimediff();
+                        if (Math.abs(diff) >= 86400.0) {
+                            // The difference if more than a day
+                            syncChangelog.put("message", res.getString(R.string.sync_log_clocks_unsynchronized,
+                                    ((long) diff), res.getString(R.string.sync_log_clocks_unsynchronized_date)));
+                        } else if (Math.abs((Math.abs(diff) % 3600.0) - 1800.0) >= 1500.0) {
+                            // The difference would be within limit if we adjusted the time by few hours
+                            // It doesn't work for all timezones, but it covers most and it's a guess anyway
+                            syncChangelog.put("message", res.getString(R.string.sync_log_clocks_unsynchronized,
+                                    ((long) diff), res.getString(R.string.sync_log_clocks_unsynchronized_tz)));
+                        } else {
+                            syncChangelog.put("message", res.getString(R.string.sync_log_clocks_unsynchronized,
+                                    ((long) diff), ""));
+                        }
+                    } else if (connectResult == AnkiDroidProxy.LOGIN_OLD_VERSION) {
+                        syncChangelog.put("message", String.format(res.getString(R.string.sync_log_old_version), res.getString(R.string.link_ankidroid)));
+                    } else if (connectResult == AnkiDroidProxy.LOGIN_TOO_BUSY) {
+                        syncChangelog.put("message", res.getString(R.string.sync_too_busy));
                     } else {
-                        syncChangelog.put("message", res.getString(R.string.sync_log_clocks_unsynchronized,
-                                ((long) diff), ""));
+                        syncChangelog.put("message", res.getString(R.string.login_generic_error));
                     }
-                } else if (connectResult == AnkiDroidProxy.LOGIN_OLD_VERSION) {
-                    syncChangelog.put("message", String.format(res.getString(R.string.sync_log_old_version), res.getString(R.string.link_ankidroid)));
-                } else if (connectResult == AnkiDroidProxy.LOGIN_TOO_BUSY) {
-                    syncChangelog.put("message", res.getString(R.string.sync_too_busy));
-                } else {
-                    syncChangelog.put("message", res.getString(R.string.login_generic_error));
+                    data.result = syncChangelog;
+                    data.success = false;
+                    ankiDB.getDatabase().endTransaction();
+                    return data;
                 }
-                data.result = syncChangelog;
-                data.success = false;
-                ankiDB.getDatabase().endTransaction();
-                return data;
-            }
 
-            // Exists on server?
-            if (!server.hasDeck(syncName)) {
-                Log.i(AnkiDroidApp.TAG, "AnkiOnline does not have this deck: Creating it...");
-                Payload result = server.createDeck(syncName);
-                if (result.success != true) {
-                    syncChangelog.put("message", res.getString(R.string.sync_log_create_deck_failed,
-                            ((String)result.result)));
-                    result.result = syncChangelog;
-                    ankiDB.getDatabase().endTransaction();
-                    return result;
+                // Exists on server?
+                if (!server.hasDeck(syncName)) {
+                    Log.i(AnkiDroidApp.TAG, "AnkiOnline does not have this deck: Creating it...");
+                    Payload result = server.createDeck(syncName);
+                    if (result.success != true) {
+                        syncChangelog.put("message", res.getString(R.string.sync_log_create_deck_failed,
+                                ((String)result.result)));
+                        result.result = syncChangelog;
+                        ankiDB.getDatabase().endTransaction();
+                        return result;
+                    }
                 }
-            }
-            publishProgress(syncName, res.getString(R.string.sync_syncing_message, new Object[] { syncName }));
-            SyncClient client = new SyncClient(deck);
-            client.setServer(server);
-            server.setDeckName(syncName);
-            
-            // Check conflicts
-            double localMod = deck.getModified();
-            double localSync = deck.getLastSync();
-            double remoteMod = server.modified();
-            double remoteSync = server.lastSync();
-            if (remoteMod < 0 || remoteSync < 0) {
-                data.success = false;
-                syncChangelog.put("message", res.getString(R.string.sync_log_error_message));
-                data.result = syncChangelog;
-                ankiDB.getDatabase().endTransaction();
-                return data;
-            }
-            double minSync = Math.min(localSync, remoteSync);
-            if ((localMod != remoteMod) && (minSync > 0) &&
-                    (localMod > minSync) && (remoteMod > minSync)) {
-                if (conflictResolution == null) {
-                    Log.i(AnkiDroidApp.TAG, "Syncing needs conflict resolution user input...");
+                publishProgress(syncName, res.getString(R.string.sync_syncing_message, new Object[] { syncName }));
+                SyncClient client = new SyncClient(deck);
+                client.setServer(server);
+                server.setDeckName(syncName);
+                
+                // Check conflicts
+                double localMod = deck.getModified();
+                double localSync = deck.getLastSync();
+                double remoteMod = server.modified();
+                double remoteSync = server.lastSync();
+                if (remoteMod < 0 || remoteSync < 0) {
                     data.success = false;
-                    data.returnType = AnkiDroidProxy.SYNC_CONFLICT_RESOLUTION;
-                    syncChangelog.put("message", res.getString(R.string.sync_log_conflict_resolution_required));
+                    syncChangelog.put("message", res.getString(R.string.sync_log_error_message));
                     data.result = syncChangelog;
+                    ankiDB.getDatabase().endTransaction();
                     return data;
                 }
-            }
-            if (client.prepareSync(server.getTimediff())) {
-                if (deck.getLastSync() <= 0) {
-                    if (client.getRemoteTime() > client.getLocalTime()) {
-                        conflictResolution = "keepRemote";
-                    } else {
-                        conflictResolution = "keepLocal";
-                    }
-                }
-
-                // summary
-                JSONArray sums = null;
-                if (conflictResolution == null) {
-                    publishProgress(syncName, res.getString(R.string.sync_summary_from_server_message));
-                    sums = client.summaries();
-                    if (sums == null) {
+                double minSync = Math.min(localSync, remoteSync);
+                if ((localMod != remoteMod) && (minSync > 0) &&
+                        (localMod > minSync) && (remoteMod > minSync)) {
+                    if (conflictResolution == null) {
+                        Log.i(AnkiDroidApp.TAG, "Syncing needs conflict resolution user input...");
                         data.success = false;
-                        syncChangelog.put("message", res.getString(R.string.sync_log_error_message));
+                        data.returnType = AnkiDroidProxy.SYNC_CONFLICT_RESOLUTION;
+                        syncChangelog.put("message", res.getString(R.string.sync_log_conflict_resolution_required));
                         data.result = syncChangelog;
-                        ankiDB.getDatabase().endTransaction();
                         return data;
                     }
                 }
+                if (client.prepareSync(server.getTimediff())) {
+                    if (deck.getLastSync() <= 0) {
+                        if (client.getRemoteTime() > client.getLocalTime()) {
+                            conflictResolution = "keepRemote";
+                        } else {
+                            conflictResolution = "keepLocal";
+                        }
+                    }
+
+                    // summary
+                    JSONArray sums = null;
+                    if (conflictResolution == null) {
+                        publishProgress(syncName, res.getString(R.string.sync_summary_from_server_message));
+                        sums = client.summaries();
+                        if (sums == null) {
+                            data.success = false;
+                            syncChangelog.put("message", res.getString(R.string.sync_log_error_message));
+                            data.result = syncChangelog;
+                            ankiDB.getDatabase().endTransaction();
+                            return data;
+                        }
+                    }
 
-                if ((conflictResolution != null) || client.needFullSync(sums)) {
-                    Log.i(AnkiDroidApp.TAG, "DECK NEEDS FULL SYNC");
+                    if ((conflictResolution != null) || client.needFullSync(sums)) {
+                        Log.i(AnkiDroidApp.TAG, "DECK NEEDS FULL SYNC");
 
-                    publishProgress(syncName, res.getString(R.string.sync_preparing_full_sync_message));
+                        publishProgress(syncName, res.getString(R.string.sync_preparing_full_sync_message));
 
-                    if (conflictResolution != null) {
-                        if (conflictResolution.equals("keepLocal")) {
-                            client.setRemoteTime(0.0);
-                        } else if (conflictResolution.equals("keepRemote")) {
-                            client.setLocalTime(0.0);
+                        if (conflictResolution != null) {
+                            if (conflictResolution.equals("keepLocal")) {
+                                client.setRemoteTime(0.0);
+                            } else if (conflictResolution.equals("keepRemote")) {
+                                client.setLocalTime(0.0);
+                            }
                         }
-                    }
-                    
-                    String syncFrom = client.prepareFullSync();
-
-                    HashMap<String, String> result = new HashMap<String, String>();
-                    if ("fromLocal".equalsIgnoreCase(syncFrom)) {
-                        publishProgress(syncName, res.getString(R.string.sync_uploading_message));
-                        result = SyncClient.fullSyncFromLocal(password, username, deck, syncName);
-                        if (result.containsKey("code") && result.get("code").equals("200")) {
-                            syncChangelog.put("message", res.getString(R.string.sync_log_uploading_message));
+                        
+                        String syncFrom = client.prepareFullSync();
+
+                        HashMap<String, String> result = new HashMap<String, String>();
+                        if ("fromLocal".equalsIgnoreCase(syncFrom)) {
+                            publishProgress(syncName, res.getString(R.string.sync_uploading_message));
+                            result = SyncClient.fullSyncFromLocal(password, username, deck, syncName);
+                            if (result.containsKey("code") && result.get("code").equals("200")) {
+                                syncChangelog.put("message", res.getString(R.string.sync_log_uploading_message));
+                            }
+                            ankiDB.getDatabase().setTransactionSuccessful();
+                            ankiDB.getDatabase().endTransaction();
+                        } else if ("fromServer".equalsIgnoreCase(syncFrom)) {
+                            publishProgress(syncName, res.getString(R.string.sync_downloading_message));
+                            ankiDB.getDatabase().endTransaction();
+                            DeckManager.closeDeck(deckPath);
+                            result = SyncClient.fullSyncFromServer(password, username, syncName, deckPath);
+                            if (result.containsKey("code") && result.get("code").equals("200")) {
+                                syncChangelog.put("message", res.getString(R.string.sync_log_downloading_message));
+                            }
                         }
-                        ankiDB.getDatabase().setTransactionSuccessful();
-                        ankiDB.getDatabase().endTransaction();
-                    } else if ("fromServer".equalsIgnoreCase(syncFrom)) {
-                        publishProgress(syncName, res.getString(R.string.sync_downloading_message));
-                        ankiDB.getDatabase().endTransaction();
-                        if (deck != null) {
-                            deck.closeDeck();
+
+                        publishProgress(syncName, res.getString(R.string.sync_complete_message));
+                        // Pass error (if any) to UI
+                        if (!result.containsKey("code") || !result.get("code").equals("200")) {
+                            if (result.containsKey("message")) {
+                            syncChangelog.put("message", String.format(
+                                    res.getString(R.string.sync_log_error_specific),
+                                    result.get("code"), result.get("message")));
+                            } else {
+                                syncChangelog.put("message", res.getString(R.string.sync_log_error_message));
+                            }
                         }
-                        result = SyncClient.fullSyncFromServer(password, username, syncName, deckPath);
-                        if (result.containsKey("code") && result.get("code").equals("200")) {
-                            syncChangelog.put("message", res.getString(R.string.sync_log_downloading_message));
+                    } else {
+                        Log.i(AnkiDroidApp.TAG, "DECK DOES NOT NEED FULL SYNC");
+
+                        publishProgress(syncName, res.getString(R.string.sync_determining_differences_message));
+
+                        JSONObject payload = client.genPayload(sums);
+                        int factsAddedOnLocal = payload.getJSONArray("added-cards").length();
+                        if (factsAddedOnLocal > 0) {
+                            syncChangelog.put("message", res.getQuantityString(R.plurals.sync_log_facts_to_server_message,
+                                    factsAddedOnLocal, factsAddedOnLocal));
                         }
-                    }
 
-                    publishProgress(syncName, res.getString(R.string.sync_complete_message));
-                    // Pass error (if any) to UI
-                    if (!result.containsKey("code") || !result.get("code").equals("200")) {
-                        if (result.containsKey("message")) {
-                        syncChangelog.put("message", String.format(
-                                res.getString(R.string.sync_log_error_specific),
-                                result.get("code"), result.get("message")));
-                        } else {
+                        publishProgress(syncName, res.getString(R.string.sync_transferring_payload_message));
+                        JSONObject payloadReply = client.getServer().applyPayload(payload);
+                        if (payloadReply == null) {
+                            data.success = false;
                             syncChangelog.put("message", res.getString(R.string.sync_log_error_message));
+                            data.result = syncChangelog;
+                            ankiDB.getDatabase().endTransaction();
+                            return data;
+                        }
+                        int factsAddedOnServer = payloadReply.getJSONArray("added-cards").length();
+                        if (factsAddedOnLocal == 0 && factsAddedOnServer == 0) {
+                            syncChangelog.put("message", res.getString(R.string.sync_log_zero_facts));
+                        } else if (factsAddedOnServer > 0) {
+                            syncChangelog.put("message", res.getQuantityString(R.plurals.sync_log_facts_from_server_message,
+                                    factsAddedOnServer, factsAddedOnServer));
                         }
-                    }
-                } else {
-                    Log.i(AnkiDroidApp.TAG, "DECK DOES NOT NEED FULL SYNC");
 
-                    publishProgress(syncName, res.getString(R.string.sync_determining_differences_message));
+                        publishProgress(syncName, res.getString(R.string.sync_applying_reply_message));
+                        client.applyPayloadReply(payloadReply);
+                        deck.initDeckvarsCache();
+                        
+                        Reviewer.setupMedia(deck); // FIXME: setupMedia should be part of Deck?
+                        SharedPreferences preferences = PrefSettings.getSharedPrefs(sContext);
+                        if (preferences.getBoolean("syncFetchMedia", true)) {
+                            doInBackgroundDownloadMissingMedia(new Payload(new Object[] {deck}));
+                        }
 
-                    JSONObject payload = client.genPayload(sums);
-                    int factsAddedOnLocal = payload.getJSONArray("added-cards").length();
-                    if (factsAddedOnLocal > 0) {
-                        syncChangelog.put("message", res.getQuantityString(R.plurals.sync_log_facts_to_server_message,
-                                factsAddedOnLocal, factsAddedOnLocal));
-                    }
+                        if (!client.getServer().finish()) {
+                            data.success = false;
+                            syncChangelog.put("message", res.getString(R.string.sync_log_finish_error));
+                            data.result = syncChangelog;
+                            ankiDB.getDatabase().endTransaction();
+                            return data;
+                        }
+                        deck.reset();
 
-                    publishProgress(syncName, res.getString(R.string.sync_transferring_payload_message));
-                    JSONObject payloadReply = client.getServer().applyPayload(payload);
-                    if (payloadReply == null) {
-                        data.success = false;
-                        syncChangelog.put("message", res.getString(R.string.sync_log_error_message));
-                        data.result = syncChangelog;
-                        ankiDB.getDatabase().endTransaction();
-                        return data;
-                    }
-                    int factsAddedOnServer = payloadReply.getJSONArray("added-cards").length();
-                    if (factsAddedOnLocal == 0 && factsAddedOnServer == 0) {
-                        syncChangelog.put("message", res.getString(R.string.sync_log_zero_facts));
-                    } else if (factsAddedOnServer > 0) {
-                        syncChangelog.put("message", res.getQuantityString(R.plurals.sync_log_facts_from_server_message,
-                                factsAddedOnServer, factsAddedOnServer));
-                    }
+                        deck.setLastLoaded(deck.getModified());
+                        deck.commitToDB();
+                        Log.i(AnkiDroidApp.TAG, String.format(Utils.ENGLISH_LOCALE, "Modified: %f, LastSync: %f, LastLoaded: %f", deck.getModified(), deck.getLastSync(), deck.getLastLoaded()));
 
-                    publishProgress(syncName, res.getString(R.string.sync_applying_reply_message));
-                    client.applyPayloadReply(payloadReply);
-//                    deck.initDeckvarsCache();
-                    
-                    Reviewer.setupMedia(deck); // FIXME: setupMedia should be part of Deck?
-                    SharedPreferences preferences = PrefSettings.getSharedPrefs(sContext);
-                    if (preferences.getBoolean("syncFetchMedia", true)) {
-                        doInBackgroundDownloadMissingMedia(new Payload(new Object[] {deck}));
-                    }
-                    
-                    if (!client.getServer().finish()) {
-                        data.success = false;
-                        syncChangelog.put("message", res.getString(R.string.sync_log_finish_error));
-                        data.result = syncChangelog;
-                        ankiDB.getDatabase().endTransaction();
-                        return data;
+                        ankiDB.getDatabase().setTransactionSuccessful();
+                        publishProgress(syncName, res.getString(R.string.sync_complete_message));
                     }
-                    deck.reset();
-
-                    deck.setLastLoaded(deck.getModified());
-                    deck.commitToDB();
-//                    Log.i(AnkiDroidApp.TAG, String.format(Utils.ENGLISH_LOCALE, "Modified: %f, LastSync: %f, LastLoaded: %f", deck.getModified(), deck.getLastSync(), deck.getLastLoaded()));
-
-                    ankiDB.getDatabase().setTransactionSuccessful();
-                    publishProgress(syncName, res.getString(R.string.sync_complete_message));
+                } else {
+                    Log.i(AnkiDroidApp.TAG, "NO CHANGES.");
+                    publishProgress(syncName, res.getString(R.string.sync_no_changes_message));
+                    syncChangelog.put("message", res.getString(R.string.sync_log_no_changes_message));
+                }
+                if (singleDeckSync) {
+                    DeckManager.getDeck(deckPath, DeckManager.REQUESTING_ACTIVITY_STUDYOPTIONS);                	
+                }
+            } finally {
+                if (ankiDB.getDatabase() != null && ankiDB.getDatabase().isOpen() && ankiDB.getDatabase().inTransaction()) {
+                    ankiDB.getDatabase().endTransaction();
                 }
-            } else {
-                Log.i(AnkiDroidApp.TAG, "NO CHANGES.");
-                publishProgress(syncName, res.getString(R.string.sync_no_changes_message));
-                syncChangelog.put("message", res.getString(R.string.sync_log_no_changes_message));
             }
+        } catch (OutOfMemoryError e) {
+            Log.e(AnkiDroidApp.TAG, "doInBackgroundSyncDeck - JSONException: " + e.getMessage());
+            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
+            syncChangelog.put("message", res.getString(R.string.sync_log_error_message));
+            data.success = false;
         } catch (JSONException e) {
             Log.e(AnkiDroidApp.TAG, "doInBackgroundSyncDeck - JSONException: " + e.getMessage());
             Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
             syncChangelog.put("message", res.getString(R.string.sync_log_error_message));
             data.success = false;
             data.exception = e;
-        } finally {
-            if (ankiDB.getDatabase() != null && ankiDB.getDatabase().inTransaction()) {
-                ankiDB.getDatabase().endTransaction();
-            }
-
-            if (deck != null) {
-                deck.closeDeck();
-            }
+		} catch (SQLException e) {
+            AnkiDroidApp.saveExceptionReportFile(e, "doInBackgroundSyncDeck");
+			Log.w(AnkiDroidApp.TAG, "doInBackgroundSyncDeck - Error on " + deckPath + ": " + e);
+            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
+            data.returnType = AnkiDroidProxy.DB_ERROR;
+            syncChangelog.put("message", res.getString(R.string.sync_log_db_error));
+            data.success = false;
+            data.exception = e;
         }
 
         data.result = syncChangelog;
@@ -629,6 +643,7 @@ public class Connection extends AsyncTask<Connection.Payload, Object, Connection
         ArrayList<HashMap<String, String>> errors  = (ArrayList<HashMap<String, String>>) data.data[3];
         String groupId  = ((Long) data.data[4]).toString();
         Application app  = (Application) data.data[5];
+        boolean deleteAfterSending = (Boolean) data.data[6];
 
         String postType = null;
         if (feedback.length() > 0) {
@@ -657,6 +672,10 @@ public class Connection extends AsyncTask<Connection.Payload, Object, Connection
                 } else {
                     publishProgress(postType, i, Feedback.STATE_FAILED, reply.returnType, reply.result);
                 }
+                if (deleteAfterSending && (reply.success || reply.returnType == 200)) {
+                	File file = new File(app.getFilesDir() + "/" + error.get("filename"));
+                	file.delete();
+                }
             }
         }
 
@@ -736,7 +755,7 @@ public class Connection extends AsyncTask<Connection.Payload, Object, Connection
         for (String file : missingPaths.keySet()) {
             
             try {
-                android.net.Uri uri = android.net.Uri.parse(urlbase + Uri.encode(file));
+                android.net.Uri uri = android.net.Uri.parse(Uri.encode(urlbase, ":/@%") + Uri.encode(file));
                 url = new URI(uri.toString()).toURL();
                 connection = (HttpURLConnection) url.openConnection();
                 connection.connect();
diff --git a/src/com/ichi2/charts/ChartBuilder.java b/src/com/ichi2/charts/ChartBuilder.java
index ff8fba1dbf..6837e72c1f 100644
--- a/src/com/ichi2/charts/ChartBuilder.java
+++ b/src/com/ichi2/charts/ChartBuilder.java
@@ -1,379 +1,340 @@
-/**
- * Copyright (C) 2009, 2010 SC 4ViewSoft SRL
- * Copyright (C) 2011 Norbert Nagold <norbert.nagold@gmail.com>
- *  
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *  
- *      http://www.apache.org/licenses/LICENSE-2.0
- *  
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.ichi2.charts;
-
-import org.achartengine.ChartFactory;
-import org.achartengine.GraphicalView;
-import org.achartengine.chart.BarChart;
-import org.achartengine.chart.LineChart;
-import org.achartengine.model.XYMultipleSeriesDataset;
-import org.achartengine.model.XYSeries;
-import org.achartengine.renderer.XYMultipleSeriesRenderer;
-import org.achartengine.renderer.XYSeriesRenderer;
-
-import android.app.Activity;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.content.SharedPreferences.Editor;
-import android.content.res.Resources;
-import android.graphics.Paint.Align;
-import android.os.Bundle;
-import android.util.Log;
-import android.view.GestureDetector;
-import android.view.KeyEvent;
-import android.view.Menu;
-import android.view.MenuItem;
-import android.view.MotionEvent;
-import android.view.View;
-import android.view.Window;
-import android.view.WindowManager;
-import android.view.GestureDetector.SimpleOnGestureListener;
-import android.view.ViewGroup.LayoutParams;
-import android.widget.LinearLayout;
-import android.widget.TextView;
-
-import com.ichi2.anim.ActivityTransitionAnimation;
-import com.ichi2.anki.AnkiDroidApp;
-import com.ichi2.anki.R;
-import com.ichi2.anki.Statistics;
-import com.ichi2.anki.StudyOptions;
-import com.ichi2.themes.Themes;
-import com.tomgibara.android.veecheck.util.PrefSettings;
-
-public class ChartBuilder extends Activity {
-    public static final String TYPE = "type";
-    public static final int ZOOM_MAX = 20;
-
-    private XYMultipleSeriesDataset mDataset = new XYMultipleSeriesDataset();
-    private XYMultipleSeriesRenderer mRenderer = new XYMultipleSeriesRenderer();
-
-    private GraphicalView mChartView;
-    private TextView mTitle;
-    private double[] mPan;
-    private int zoom = 0;
-
-    private boolean mFullScreen;
-
-    private static final int MENU_FULLSCREEN = 0;
-    private static final int MENU_ZOOM_IN = 1;
-    private static final int MENU_ZOOM_OUT = 2;
-
-	/**
-     * Swipe Detection
-     */    
- 	private GestureDetector gestureDetector;
- 	View.OnTouchListener gestureListener;
- 	private boolean mSwipeEnabled;
-
-    @Override
-    protected void onRestoreInstanceState(Bundle savedState) {
-        super.onRestoreInstanceState(savedState);
-        mDataset = (XYMultipleSeriesDataset) savedState.getSerializable("dataset");
-        mRenderer = (XYMultipleSeriesRenderer) savedState.getSerializable("renderer");
-    }
-
-
-    @Override
-    protected void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-        outState.putSerializable("dataset", mDataset);
-        outState.putSerializable("renderer", mRenderer);
-    }
-
-
-    public void setDataset(int row) {
-        XYSeries series = new XYSeries(Statistics.Titles[row]);
-        for (int i = 0; i < Statistics.xAxisData.length; i++) {
-            series.add(Statistics.xAxisData[i], Statistics.sSeriesList[row][i]);
-        }
-        mDataset.addSeries(series);
-    }
-
-
-    public void setRenderer(int type, int row) {
-        Resources res = getResources();
-        XYSeriesRenderer renderer = new XYSeriesRenderer();
-        if (type <= Statistics.TYPE_CUMULATIVE_DUE) {
-            switch (row) {
-                case 0:
-                    renderer.setColor(res.getColor(R.color.statistics_due_young_cards));
-                    break;
-                case 1:
-                    renderer.setColor(res.getColor(R.color.statistics_due_mature_cards));
-                    break;
-                case 2:
-                    renderer.setColor(res.getColor(R.color.statistics_due_learn_cards));
-                    break;
-                case 3:
-                    renderer.setColor(res.getColor(R.color.statistics_due_average_line));
-                    renderer.setLineWidth(2f);
-                    break;
-            }
-        } else if (type <= Statistics.TYPE_REVIEWING_TIME) {
-            switch (row) {
-                case 0:
-                    renderer.setColor(res.getColor(R.color.statistics_reps_cram_cards));
-                    break;
-                case 1:
-                    renderer.setColor(res.getColor(R.color.statistics_reps_learn_cards));
-                    break;
-                case 2:
-                    renderer.setColor(res.getColor(R.color.statistics_reps_relearn_cards));
-                    break;
-                case 3:
-                    renderer.setColor(res.getColor(R.color.statistics_reps_young_cards));
-                    break;
-                case 4:
-                    renderer.setColor(res.getColor(R.color.statistics_reps_mature_cards));
-                    break;
-                case 5:
-                    renderer.setColor(res.getColor(R.color.statistics_due_average_line));
-                    break;
-            }
-        } else {
-            renderer.setColor(res.getColor(R.color.statistics_default));
-        }
-        mRenderer.addSeriesRenderer(renderer);
-    }
-
-
-    private void zoom() {
-        if (mChartView != null) {
-            if (zoom > 0) {
-                mRenderer.setXAxisMin(mPan[0] / (zoom + 1));
-                mRenderer.setXAxisMax(mPan[1] / (zoom + 1));
-            } else {
-                mRenderer.setXAxisMin(mPan[0]);
-                mRenderer.setXAxisMax(mPan[1]);
-            }
-            // mChartView = ChartFactory.getBarChartView(this, mDataset, mRenderer, BarChart.Type.STACKED);
-            // mChartView = ChartFactory.getCombinedXYChartView(this, mDataset, mRenderer, new String[] {BarChart.TYPE,
-            // BarChart.TYPE, LineChart.TYPE});
-            LinearLayout layout = (LinearLayout) findViewById(R.id.chart);
-            layout.addView(mChartView, new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));
-        }
-    }
-
-
-    public void closeChartBuilder() {
-        finish();
-        if (Integer.valueOf(android.os.Build.VERSION.SDK) > 4) {
-            ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.UP);
-        }
-    }
-
-
-    private SharedPreferences restorePreferences() {
-        SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
-        mFullScreen = preferences.getBoolean("fullScreen", false);
-        mSwipeEnabled = preferences.getBoolean("swipe", false);
-        return preferences;
-    }
-
-
-    @Override
-    public boolean onCreateOptionsMenu(Menu menu) {
-        MenuItem item;
-        item = menu.add(Menu.NONE, MENU_FULLSCREEN, Menu.NONE, R.string.statistics_fullscreen);
-        item.setIcon(R.drawable.ic_menu_manage);
-        item = menu.add(Menu.NONE, MENU_ZOOM_IN, Menu.NONE, R.string.statistics_zoom_in);
-        item.setIcon(R.drawable.ic_menu_zoom_in);
-        item = menu.add(Menu.NONE, MENU_ZOOM_OUT, Menu.NONE, R.string.statistics_zoom_out);
-        item.setIcon(R.drawable.ic_menu_zoom_out);
-        return true;
-    }
-
-
-    @Override
-    public boolean onPrepareOptionsMenu(Menu menu) {
-        menu.findItem(MENU_ZOOM_IN).setEnabled(zoom < ZOOM_MAX);
-        menu.findItem(MENU_ZOOM_OUT).setEnabled(zoom > 0);
-        return true;
-    }
-
-
-    @Override
-    public boolean onOptionsItemSelected(MenuItem item) {
-        switch (item.getItemId()) {
-            case MENU_FULLSCREEN:
-                SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
-                Editor editor = preferences.edit();
-                editor.putBoolean("fullScreen", !mFullScreen);
-                Statistics.sZoom = zoom;
-                editor.commit();
-                finish();
-                Intent intent = new Intent(this, com.ichi2.charts.ChartBuilder.class);
-                startActivity(intent);
-                if (Integer.valueOf(android.os.Build.VERSION.SDK) > 4) {
-                    ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.FADE);
-                }
-                return true;
-            case MENU_ZOOM_IN:
-                zoom += 1;
-                zoom();
-                return true;
-            case MENU_ZOOM_OUT:
-                if (zoom > 0) {
-                    zoom -= 1;
-                }
-                zoom();
-                return true;
-            default:
-                return super.onOptionsItemSelected(item);
-        }
-    }
-
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-    	Themes.applyTheme(this);
-        super.onCreate(savedInstanceState);
-        restorePreferences();
-        if (Statistics.sSeriesList == null) {
-            Log.i(AnkiDroidApp.TAG, "ChartBuilder - Data variable empty, closing chartbuilder");
-        	finish();
-        	return;
-        }
-        if (mFullScreen) {
-            getWindow()
-                    .setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
-            requestWindowFeature(Window.FEATURE_NO_TITLE);
-        }
-        View mainView = getLayoutInflater().inflate(R.layout.statistics, null);
-        setContentView(mainView);
-        int[] colors = Themes.getChartColors();
-        mainView.setBackgroundColor(colors[1]);
-        mTitle = (TextView) findViewById(R.id.statistics_title);
-        if (mChartView == null) {
-            if (mFullScreen) {
-                mTitle.setText(Statistics.sTitle);
-                mTitle.setTextColor(colors[0]);
-            } else {
-                setTitle(Statistics.sTitle);
-                mTitle.setVisibility(View.GONE);
-            }
-            for (int i = 0; i < Statistics.sSeriesList.length; i++) {
-                setDataset(i);
-                setRenderer(Statistics.sType, i);
-            }
-            if (Statistics.sSeriesList.length == 1) {
-                mRenderer.setShowLegend(false);
-            }
-            mPan = new double[] { Statistics.sStart - 1, Statistics.sEnd + 1 };
-            mRenderer.setLegendTextSize(17);
-            mRenderer.setLegendHeight(60);
-            mRenderer.setAxisTitleTextSize(17);
-            mRenderer.setLabelsTextSize(17);
-            mRenderer.setXAxisMin(mPan[0]);
-            mRenderer.setXAxisMax(mPan[1]);
-            mRenderer.setYAxisMin(0);
-            mRenderer.setXTitle(Statistics.axisLabels[0]);
-            mRenderer.setYTitle(Statistics.axisLabels[1]);
-            mRenderer.setBackgroundColor(colors[1]);
-            mRenderer.setMarginsColor(colors[1]);
-            mRenderer.setAxesColor(colors[0]);
-            mRenderer.setLabelsColor(colors[0]);
-            mRenderer.setZoomEnabled(false, false);
-            // if (Statistics.sSeriesList[0][0] > 100 || Statistics.sSeriesList[0][1] > 100 ||
-            // Statistics.sSeriesList[0][Statistics.sSeriesList[0].length - 1] > 100) {
-            // mRenderer.setMargins(new int[] { 15, 50, 25, 0 });
-            // } else {
-            mRenderer.setMargins(new int[] { 15, 42, 25, 0 });
-            // }
-            mRenderer.setPanEnabled(true, false);
-            mRenderer.setPanLimits(mPan);
-            mRenderer.setXLabelsAlign(Align.CENTER);
-            mRenderer.setYLabelsAlign(Align.RIGHT);
-
-            switch (Statistics.sType) {
-                case Statistics.TYPE_DUE:
-                    mChartView = ChartFactory.getCombinedXYChartView(this, mDataset, mRenderer, new String[] {
-                            BarChart.TYPE, BarChart.TYPE, BarChart.TYPE, LineChart.TYPE });
-                    break;
-                case Statistics.TYPE_CUMULATIVE_DUE:
-                    mChartView = ChartFactory.getCombinedXYChartView(this, mDataset, mRenderer, new String[] {
-                            BarChart.TYPE, BarChart.TYPE, BarChart.TYPE });
-                    break;
-                case Statistics.TYPE_INTERVALS:
-                    mChartView = ChartFactory.getBarChartView(this, mDataset, mRenderer, BarChart.Type.STACKED);
-                    break;
-                case Statistics.TYPE_REVIEWS:
-                case Statistics.TYPE_REVIEWING_TIME:
-                    mChartView = ChartFactory
-                            .getCombinedXYChartView(this, mDataset, mRenderer, new String[] { BarChart.TYPE,
-                                    BarChart.TYPE, BarChart.TYPE, BarChart.TYPE, BarChart.TYPE, LineChart.TYPE });
-                    break;
-            }
-
-            LinearLayout layout = (LinearLayout) findViewById(R.id.chart);
-            layout.addView(mChartView, new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));
-        } else {
-            mChartView.repaint();
-        }
-        gestureDetector = new GestureDetector(new MyGestureDetector());
-        mChartView.setOnTouchListener(new View.OnTouchListener() {
-        	public boolean onTouch(View v, MotionEvent event) {
-        		if (gestureDetector.onTouchEvent(event)) {
-        			return true;
-        		}
-        		return false;
-        		}
-        	});
-		zoom = Statistics.sZoom;
-        if (zoom > 0) {
-            zoom();
-        }
-    }
-
-
-    @Override
-    public boolean onKeyDown(int keyCode, KeyEvent event) {
-        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
-            Log.i(AnkiDroidApp.TAG, "ChartBuilder - onBackPressed()");
-            closeChartBuilder();
-        }
-        return super.onKeyDown(keyCode, event);
-    }
-
-    class MyGestureDetector extends SimpleOnGestureListener {
-        @Override
-        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
-            if (mSwipeEnabled) {
-                try {
-                    if (e1.getY() - e2.getY() > StudyOptions.sSwipeMinDistance
-                            && Math.abs(velocityY) > StudyOptions.sSwipeThresholdVelocity
-                            && Math.abs(e1.getX() - e2.getX()) < StudyOptions.sSwipeMaxOffPath) {
-                        closeChartBuilder();
-                    }
-                } catch (Exception e) {
-                    Log.e(AnkiDroidApp.TAG, "onFling Exception = " + e.getMessage());
-                }
-            }
-            return false;
-        }
-    }
-
-
-    @Override
-    public boolean onTouchEvent(MotionEvent event) {
-        if (gestureDetector.onTouchEvent(event))
-            return true;
-        else
-            return false;
-    }
-}
+/**
+ * Copyright (C) 2009, 2010 SC 4ViewSoft SRL
+ * Copyright (C) 2011 Norbert Nagold <norbert.nagold@gmail.com>
+ *  
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *  
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *  
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.ichi2.charts;
+
+import org.achartengine.ChartFactory;
+import org.achartengine.GraphicalView;
+import org.achartengine.chart.BarChart;
+import org.achartengine.model.XYMultipleSeriesDataset;
+import org.achartengine.model.XYSeries;
+import org.achartengine.renderer.XYMultipleSeriesRenderer;
+import org.achartengine.renderer.XYSeriesRenderer;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.content.SharedPreferences.Editor;
+import android.content.res.Resources;
+import android.graphics.Paint.Align;
+import android.os.Bundle;
+import android.util.Log;
+import android.view.GestureDetector;
+import android.view.KeyEvent;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.Window;
+import android.view.WindowManager;
+import android.view.GestureDetector.SimpleOnGestureListener;
+import android.view.ViewGroup.LayoutParams;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+import com.ichi2.anim.ActivityTransitionAnimation;
+import com.ichi2.anki.AnkiDroidApp;
+import com.ichi2.anki.R;
+import com.ichi2.anki.Statistics;
+import com.ichi2.anki.StudyOptions;
+import com.ichi2.themes.Themes;
+import com.tomgibara.android.veecheck.util.PrefSettings;
+
+public class ChartBuilder extends Activity {
+    public static final String TYPE = "type";
+    public static final int ZOOM_MAX = 20;
+
+    private XYMultipleSeriesDataset mDataset = new XYMultipleSeriesDataset();
+    private XYMultipleSeriesRenderer mRenderer = new XYMultipleSeriesRenderer();
+
+    private GraphicalView mChartView;
+    private TextView mTitle;
+    private double[] mPan;
+    private int zoom = 0;
+
+    private boolean mFullScreen;
+
+    private static final int MENU_FULLSCREEN = 0;
+    private static final int MENU_ZOOM_IN = 1;
+    private static final int MENU_ZOOM_OUT = 2;
+
+	/**
+     * Swipe Detection
+     */    
+ 	private GestureDetector gestureDetector;
+ 	View.OnTouchListener gestureListener;
+ 	private boolean mSwipeEnabled;
+
+    @Override
+    protected void onRestoreInstanceState(Bundle savedState) {
+        super.onRestoreInstanceState(savedState);
+        mDataset = (XYMultipleSeriesDataset) savedState.getSerializable("dataset");
+        mRenderer = (XYMultipleSeriesRenderer) savedState.getSerializable("renderer");
+    }
+
+
+    @Override
+    protected void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+        outState.putSerializable("dataset", mDataset);
+        outState.putSerializable("renderer", mRenderer);
+    }
+
+
+    public void setDataset(int row) {
+        XYSeries series = new XYSeries(Statistics.Titles[row]);
+        for (int i = 0; i < Statistics.xAxisData.length; i++) {
+            series.add(Statistics.xAxisData[i], Statistics.sSeriesList[row][i]);
+        }
+        mDataset.addSeries(series);
+    }
+
+
+    public void setRenderer(int type, int row) {
+        Resources res = getResources();
+        XYSeriesRenderer renderer = new XYSeriesRenderer();
+        if (type <= Statistics.TYPE_CUMULATIVE_DUE) {
+        	switch (row) {
+        	case 0: 
+                renderer.setColor(res.getColor(R.color.statistics_due_young_cards));
+        		break;
+        	case 1:
+                renderer.setColor(res.getColor(R.color.statistics_due_mature_cards));
+                break;
+        	case 2:
+                renderer.setColor(res.getColor(R.color.statistics_due_failed_cards));
+        		break;
+        	}
+        } else if (type == Statistics.TYPE_REVIEWS) {
+        	switch (row) {
+        	case 0: 
+                renderer.setColor(res.getColor(R.color.statistics_reps_new_cards));
+        		break;
+        	case 1:
+                renderer.setColor(res.getColor(R.color.statistics_reps_young_cards));
+                break;
+        	case 2:
+                renderer.setColor(res.getColor(R.color.statistics_reps_mature_cards));
+        		break;
+        	}
+        } else {
+            renderer.setColor(res.getColor(R.color.statistics_default));        	
+        }
+        mRenderer.addSeriesRenderer(renderer);
+    }
+
+
+    private void zoom() {
+        if (mChartView != null) {
+            if (zoom > 0) {
+                mRenderer.setXAxisMin(mPan[0] / (zoom + 1));
+                mRenderer.setXAxisMax(mPan[1] / (zoom + 1));
+            } else {
+                mRenderer.setXAxisMin(mPan[0]);
+                mRenderer.setXAxisMax(mPan[1]);
+            }
+            mChartView = ChartFactory.getBarChartView(this, mDataset, mRenderer, BarChart.Type.STACKED);
+            LinearLayout layout = (LinearLayout) findViewById(R.id.chart);
+            layout.addView(mChartView, new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));
+        }
+    }
+
+
+    public void closeChartBuilder() {
+        finish();
+        if (Integer.valueOf(android.os.Build.VERSION.SDK) > 4) {
+            ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.UP);
+        }
+    }
+
+
+    private SharedPreferences restorePreferences() {
+        SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
+        mFullScreen = preferences.getBoolean("fullScreen", false);
+		mSwipeEnabled = preferences.getBoolean("swipe", false);
+        return preferences;
+    }
+
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        MenuItem item;
+        item = menu.add(Menu.NONE, MENU_FULLSCREEN, Menu.NONE, R.string.statistics_fullscreen);
+        item.setIcon(R.drawable.ic_menu_manage);
+        item = menu.add(Menu.NONE, MENU_ZOOM_IN, Menu.NONE, R.string.statistics_zoom_in);
+        item.setIcon(R.drawable.ic_menu_zoom_in);
+        item = menu.add(Menu.NONE, MENU_ZOOM_OUT, Menu.NONE, R.string.statistics_zoom_out);
+        item.setIcon(R.drawable.ic_menu_zoom_out);
+        return true;
+    }
+
+
+    @Override
+    public boolean onPrepareOptionsMenu(Menu menu) {
+        menu.findItem(MENU_ZOOM_IN).setEnabled(zoom < ZOOM_MAX);
+        menu.findItem(MENU_ZOOM_OUT).setEnabled(zoom > 0);
+        return true;
+    }
+
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        switch (item.getItemId()) {
+            case MENU_FULLSCREEN:
+                SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
+                Editor editor = preferences.edit();
+                editor.putBoolean("fullScreen", !mFullScreen);
+                Statistics.sZoom = zoom;
+                editor.commit();
+                finish();
+                Intent intent = new Intent(this, com.ichi2.charts.ChartBuilder.class);
+                startActivity(intent);
+                if (Integer.valueOf(android.os.Build.VERSION.SDK) > 4) {
+                    ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.FADE);
+                }
+                return true;
+            case MENU_ZOOM_IN:
+                zoom += 1;
+                zoom();
+                return true;
+            case MENU_ZOOM_OUT:
+                if (zoom > 0) {
+                    zoom -= 1;
+                }
+                zoom();
+                return true;
+            default:
+                return super.onOptionsItemSelected(item);
+        }
+    }
+
+    
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+    	Themes.applyTheme(this);
+        super.onCreate(savedInstanceState);
+        restorePreferences();
+        if (Statistics.sSeriesList == null) {
+            Log.i(AnkiDroidApp.TAG, "ChartBuilder - Data variable empty, closing chartbuilder");
+        	finish();
+        	return;
+        }
+        if (mFullScreen) {
+            getWindow()
+                    .setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
+            requestWindowFeature(Window.FEATURE_NO_TITLE);
+        }
+        View mainView = getLayoutInflater().inflate(R.layout.statistics, null);
+        setContentView(mainView);
+        int[] colors = Themes.getChartColors();
+        mainView.setBackgroundColor(colors[1]);
+        mTitle = (TextView) findViewById(R.id.statistics_title);
+        if (mChartView == null) {
+            if (mFullScreen) {
+                mTitle.setText(Statistics.sTitle);
+                mTitle.setTextColor(colors[0]);
+            } else {
+                setTitle(Statistics.sTitle);
+                mTitle.setVisibility(View.GONE);
+            }
+            for (int i = 0; i < Statistics.sSeriesList.length; i++) {
+                setDataset(i);
+                setRenderer(Statistics.sType, i);
+            }
+            if (Statistics.sSeriesList.length == 1) {
+                mRenderer.setShowLegend(false);
+            }
+            mPan = new double[] { Statistics.xAxisData[0] - 1,
+                    Statistics.xAxisData[Statistics.xAxisData.length - 1] + 1 };
+            mRenderer.setLegendTextSize(17);
+            mRenderer.setLegendHeight(60);
+            mRenderer.setAxisTitleTextSize(17);
+            mRenderer.setLabelsTextSize(17);
+            mRenderer.setXAxisMin(mPan[0]);
+            mRenderer.setXAxisMax(mPan[1]);
+            mRenderer.setYAxisMin(0);
+            mRenderer.setXTitle(Statistics.axisLabels[0]);
+            mRenderer.setYTitle(Statistics.axisLabels[1]);
+            mRenderer.setBackgroundColor(colors[1]);
+            mRenderer.setMarginsColor(colors[1]);
+            mRenderer.setAxesColor(colors[0]);
+            mRenderer.setLabelsColor(colors[0]);
+            mRenderer.setZoomEnabled(false, false);
+            if (Statistics.sSeriesList[0][0] > 100 || Statistics.sSeriesList[0][1] > 100 || Statistics.sSeriesList[0][Statistics.sSeriesList[0].length - 1] > 100) {
+                mRenderer.setMargins(new int[] { 15, 50, 25, 0 });
+            } else {
+                mRenderer.setMargins(new int[] { 15, 42, 25, 0 });
+            }
+            mRenderer.setPanEnabled(true, false);
+            mRenderer.setPanLimits(mPan);
+            mRenderer.setXLabelsAlign(Align.CENTER);
+            mRenderer.setYLabelsAlign(Align.RIGHT);
+            mChartView = ChartFactory.getBarChartView(this, mDataset, mRenderer, BarChart.Type.STACKED);
+            LinearLayout layout = (LinearLayout) findViewById(R.id.chart);
+            layout.addView(mChartView, new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));
+        } else {
+            mChartView.repaint();
+        }
+		gestureDetector = new GestureDetector(new MyGestureDetector());
+        mChartView.setOnTouchListener(new View.OnTouchListener() {
+        	public boolean onTouch(View v, MotionEvent event) {
+        		if (gestureDetector.onTouchEvent(event)) {
+        			return true;
+        		}
+        		return false;
+        		}
+        	});
+		zoom = Statistics.sZoom;
+        if (zoom > 0) {
+        	zoom();
+        }
+    }
+
+
+    @Override
+    public boolean onKeyDown(int keyCode, KeyEvent event) {
+        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
+            Log.i(AnkiDroidApp.TAG, "ChartBuilder - onBackPressed()");
+            closeChartBuilder();
+        }
+        return super.onKeyDown(keyCode, event);
+    }
+
+    class MyGestureDetector extends SimpleOnGestureListener {	
+    	@Override
+        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
+            if (mSwipeEnabled) {
+                try {
+                	if (e1.getY() - e2.getY() > StudyOptions.sSwipeMinDistance && Math.abs(velocityY) > StudyOptions.sSwipeThresholdVelocity && Math.abs(e1.getX() - e2.getX()) < StudyOptions.sSwipeMaxOffPath) {
+                		closeChartBuilder();
+                    }
+       			}
+                catch (Exception e) {
+                  	Log.e(AnkiDroidApp.TAG, "onFling Exception = " + e.getMessage());
+                }
+            }	            	
+            return false;
+    	}
+    }
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+        if (gestureDetector.onTouchEvent(event))
+	        return true;
+	    else
+	    	return false;
+    }
+}
diff --git a/src/com/ichi2/libanki/Media.java b/src/com/ichi2/libanki/Media.java
index 899bac92ef..201d8808a1 100644
--- a/src/com/ichi2/libanki/Media.java
+++ b/src/com/ichi2/libanki/Media.java
@@ -133,7 +133,6 @@ public class Media {
         updateMediaCount(deck, file, 1);
     }
     public static void updateMediaCount(Deck deck, String file, int count) {
-        String mdir = deck.mediaDir();
         if (deck.getDB().queryScalar("SELECT 1 FROM media WHERE filename = '" + file + "'") == 1l) {
             deck.getDB().getDatabase().execSQL(String.format(Utils.ENGLISH_LOCALE,
                         "UPDATE media SET size = size + %d, created = %f WHERE filename = '%s'",
diff --git a/src/com/ichi2/libanki/Sound.java b/src/com/ichi2/libanki/Sound.java
index 42294c559f..0e6c605ddf 100644
--- a/src/com/ichi2/libanki/Sound.java
+++ b/src/com/ichi2/libanki/Sound.java
@@ -25,8 +25,6 @@ import android.media.MediaPlayer.OnCompletionListener;
 import android.net.Uri;
 import android.util.Log;
 
-import java.io.File;
-import java.net.URI;
 import java.util.ArrayList;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
diff --git a/src/com/ichi2/libanki/SyncClient.java b/src/com/ichi2/libanki/SyncClient.java
index d2b2a4f20f..5a612bf7e9 100644
--- a/src/com/ichi2/libanki/SyncClient.java
+++ b/src/com/ichi2/libanki/SyncClient.java
@@ -279,7 +279,7 @@ public class SyncClient {
         }
 
         Log.i(AnkiDroidApp.TAG, "Payload =");
-        Utils.printJSONObject(payload, true);
+        Utils.printJSONObject(payload, true); //XXX: Why writeToFile = true?
 
         return payload;
     }
@@ -1435,10 +1435,13 @@ public class SyncClient {
         bundledDeck = mDeck.bundleJson(bundledDeck);
 
         // AnkiDroid Deck.java does not have:
-        // css, forceMediaDir, lastSessionStart, lastTags, needLock, newCardOrder, newCardSpacing, newCardsPerDay,
+        // css, forceMediaDir, lastSessionStart, lastTags, needLock,
         // progressHandlerCalled,
-        // progressHandlerEnabled, revCardOrder, sessionRepLimit, sessionStartReps, sessionStartTime,
-        // sessionTimeLimit, tmpMediaDir
+        // progressHandlerEnabled, revCardOrder, sessionStartReps, sessionStartTime,
+        // tmpMediaDir
+
+        // XXX: this implies that they are not synched toward the server, I guess (tested on 0.7).
+        // However, the ones left are not persisted by libanki on the DB, so it's a libanki bug that they are sync'ed at all.
 
         // Our bundleDeck also doesn't need all those fields that store the scheduler Methods
 
@@ -1677,7 +1680,6 @@ public class SyncClient {
      * @return
      * @throws JSONException
      */
-    @SuppressWarnings("unchecked")
     public boolean needFullSync(JSONArray sums) throws JSONException {
         Log.i(AnkiDroidApp.TAG, "needFullSync - lastSync = " + mDeck.getLastSync());
 
@@ -1690,9 +1692,9 @@ public class SyncClient {
         for (int i = 0; i < len; i++) {
 
             JSONObject summary = sums.getJSONObject(i);
-            Iterator keys = summary.keys();
+            @SuppressWarnings("unchecked") Iterator<String> keys = (Iterator<String>) summary.keys();
             while (keys.hasNext()) {
-                String key = (String) keys.next();
+                String key = keys.next();
                 JSONArray l = (JSONArray) summary.get(key);
                 Log.i(AnkiDroidApp.TAG, "Key " + key + ", length = " + l.length());
                 if (l.length() > 500) {
@@ -1727,7 +1729,6 @@ public class SyncClient {
         mDeck.setModified(Math.min(mDeck.getModified(), mServer.getTimestamp()));
         mDeck.commitToDB();
         // The deck is closed after the full sync is completed
-        // mDeck.closeDeck();
 
         if (mLocalTime > mRemoteTime) {
             return "fromLocal";
diff --git a/src/com/ichi2/libanki/Utils.java b/src/com/ichi2/libanki/Utils.java
index ae1972c6a7..569a61587b 100644
--- a/src/com/ichi2/libanki/Utils.java
+++ b/src/com/ichi2/libanki/Utils.java
@@ -86,6 +86,7 @@ import java.util.zip.Deflater;
  * TODO comments
  */
 public class Utils {
+    enum SqlCommandType { SQL_INS, SQL_UPD, SQL_DEL };
 
     // Used to format doubles with English's decimal separator system
     public static final Locale ENGLISH_LOCALE = new Locale("en_US");
@@ -770,22 +771,30 @@ public class Utils {
 
     // Print methods
     public static void printJSONObject(JSONObject jsonObject) {
-        printJSONObject(jsonObject, "-", false);
+        printJSONObject(jsonObject, "-", null);
     }
 
 
     public static void printJSONObject(JSONObject jsonObject, boolean writeToFile) {
-        if (writeToFile) {
-            new File("/sdcard/payloadAndroid.txt").delete();
+        BufferedWriter buff;
+        try {
+            buff = writeToFile ?  
+                    new BufferedWriter(new FileWriter("/sdcard/payloadAndroid.txt"), 8192) : null;
+            try {
+                printJSONObject(jsonObject, "-", buff);
+            } finally {
+                if (buff != null)
+                    buff.close();
+            }
+        } catch (IOException ioe) {
+            Log.e(AnkiDroidApp.TAG, "IOException = " + ioe.getMessage());
         }
-        printJSONObject(jsonObject, "-", writeToFile);
     }
 
 
-    public static void printJSONObject(JSONObject jsonObject, String indentation, boolean writeToFile) {
+    private static void printJSONObject(JSONObject jsonObject, String indentation, BufferedWriter buff) {
         try {
-
-            Iterator<String> keys = jsonObject.keys();
+            @SuppressWarnings("unchecked") Iterator<String> keys = (Iterator<String>) jsonObject.keys();
             TreeSet<String> orderedKeysSet = new TreeSet<String>();
             while (keys.hasNext()) {
                 orderedKeysSet.add(keys.next());
@@ -798,20 +807,16 @@ public class Utils {
                 try {
                     Object value = jsonObject.get(key);
                     if (value instanceof JSONObject) {
-                        if (writeToFile) {
-                            BufferedWriter buff = new BufferedWriter(new FileWriter("/sdcard/payloadAndroid.txt", true));
+                        if (buff != null) {
                             buff.write(indentation + " " + key + " : ");
                             buff.newLine();
-                            buff.close();
                         }
                         Log.i(AnkiDroidApp.TAG, "	" + indentation + key + " : ");
-                        printJSONObject((JSONObject) value, indentation + "-", writeToFile);
+                        printJSONObject((JSONObject) value, indentation + "-", buff);
                     } else {
-                        if (writeToFile) {
-                            BufferedWriter buff = new BufferedWriter(new FileWriter("/sdcard/payloadAndroid.txt", true));
+                        if (buff != null) {
                             buff.write(indentation + " " + key + " = " + jsonObject.get(key).toString());
                             buff.newLine();
-                            buff.close();
                         }
                         Log.i(AnkiDroidApp.TAG, "	" + indentation + key + " = " + jsonObject.get(key).toString());
                     }
@@ -819,20 +824,20 @@ public class Utils {
                     Log.e(AnkiDroidApp.TAG, "JSONException = " + e.getMessage());
                 }
             }
-
         } catch (IOException e1) {
             Log.e(AnkiDroidApp.TAG, "IOException = " + e1.getMessage());
         }
-
     }
 
 
+    /*
     public static void saveJSONObject(JSONObject jsonObject) throws IOException {
         Log.i(AnkiDroidApp.TAG, "saveJSONObject");
         BufferedWriter buff = new BufferedWriter(new FileWriter("/sdcard/jsonObjectAndroid.txt", true));
         buff.write(jsonObject.toString());
         buff.close();
     }
+    */
 
 
     /**
@@ -867,6 +872,15 @@ public class Utils {
     }
 
 
+    public static void printDate(String name, double date) {
+    	SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH-mm-ss");
+    	df.setTimeZone(TimeZone.getTimeZone("GMT"));
+    	Calendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT"));
+    	cal.setTimeInMillis((long)date * 1000);
+    	Log.d(AnkiDroidApp.TAG, "Value of " + name + ": " + cal.getTime().toGMTString());
+	}
+
+
     public static String doubleToTime(double value) {
     	int time = (int) Math.round(value);
     	int seconds = time % 60;
@@ -939,7 +953,7 @@ public class Utils {
             if (mediaDir != null) {                              
                 base = urlEncodeMediaDir(mediaDir);
             }
-        }
+      //  }
         return base;
     }
 
@@ -1081,15 +1095,39 @@ public class Utils {
     }
 
     /** Returns a list of files for the installed custom fonts. */
-    public static File[] getCustomFonts(Context context) {
+    public static String[] getCustomFonts(Context context) {
         SharedPreferences preferences = PrefSettings.getSharedPrefs(context);
         String deckPath = preferences.getString("deckPath",
                 AnkiDroidApp.getStorageDirectory() + "/AnkiDroid");
         String fontsPath = deckPath + "/fonts/";
         File fontsDir = new File(fontsPath);
-        if (!fontsDir.exists() || !fontsDir.isDirectory()) {
-          return new File[0];
+        int fontsCount = 0;
+        File[] fontsList = null;
+        if (fontsDir.exists() && fontsDir.isDirectory()) {
+        	fontsCount = fontsDir.listFiles().length;
+        	fontsList = fontsDir.listFiles();
+        }
+        String[] ankiDroidFonts = null;
+        String assetPath = "/android_asset/fonts/";
+        int adFontsCount = 0;
+		try {
+			ankiDroidFonts = context.getAssets().list("fonts");
+			adFontsCount = ankiDroidFonts.length;
+		} catch (IOException e) {
+			Log.e(AnkiDroidApp.TAG, "Error on retrieving ankidroid fonts: " + e);
+		}
+		String[] fonts = new String[fontsCount + adFontsCount];
+        for (int i = 0; i < fontsCount; i++) {
+        	fonts[i] = fontsList[i].getAbsolutePath();
+        }
+        for (int i = fontsCount; i < fonts.length; i++) {
+        	fonts[i] = assetPath + ankiDroidFonts[i - fontsCount];        	
+        }
+
+        if (fonts.length > 0) {
+        	return fonts;
+        } else {
+        	return new String[0];
         }
-        return fontsDir.listFiles();
     }
 }
diff --git a/src/com/ichi2/themes/StyledDialog.java b/src/com/ichi2/themes/StyledDialog.java
index 637950e932..0fcc3bf10b 100644
--- a/src/com/ichi2/themes/StyledDialog.java
+++ b/src/com/ichi2/themes/StyledDialog.java
@@ -21,9 +21,11 @@ package com.ichi2.themes;
 import android.app.Dialog;
 import android.content.Context;
 import android.content.DialogInterface;
+import android.util.Log;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup.LayoutParams;
+import android.view.WindowManager.BadTokenException;
 import android.widget.AdapterView;
 import android.widget.AdapterView.OnItemClickListener;
 import android.widget.ArrayAdapter;
@@ -34,9 +36,9 @@ import android.widget.LinearLayout;
 import android.widget.ListView;
 import android.widget.TextView;
 
+import com.ichi2.anki.AnkiDroidApp;
 import com.ichi2.anki.R;
-import com.ichi2.anki.StudyOptions;
-
+import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.List;
  
@@ -46,12 +48,11 @@ public class StyledDialog extends Dialog {
 	private Context mContext;
 	private List<String> mItemList;
 	private boolean[] mCheckedItems;
-	private ArrayAdapter mListAdapter;
+	private ArrayAdapter<String> mListAdapter;
 	private OnClickListener mListener;
 	private ListView mListView;
 	private boolean mDoNotShow = false;
 
-
     public StyledDialog(Context context) {
         super(context, R.style.StyledDialog);
         mContext = context;
@@ -59,6 +60,16 @@ public class StyledDialog extends Dialog {
 
 
     @Override
+    public void show() {
+    	try {
+    		super.show();
+    	} catch (BadTokenException e) {
+    		Log.e(AnkiDroidApp.TAG, "Could not show dialog: " + e);
+    	}
+    }
+
+
+    // @Override  On Android 1.5 this is not Override
     public void onAttachedToWindow() {
     	if (mDoNotShow) {
         	this.dismiss();
@@ -107,27 +118,27 @@ public class StyledDialog extends Dialog {
 			    });
     	} else {
 	        mListView.setOnItemClickListener(new OnItemClickListener() {
-    				@Override    
+    				@Override
     				public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
     						mListener.onClick(StyledDialog.this, position);
-						StyledDialog.this.dismiss();
+    						StyledDialog.this.dismiss();
     			    	}
 			    });
     	}
     	switch (type) {
     	case 1:
-    		mListAdapter = new ArrayAdapter(mContext, R.layout.select_dialog_nochoice, 0, mItemList);
+    		mListAdapter = new ArrayAdapter<String>(mContext, R.layout.select_dialog_nochoice, 0, mItemList);
     		mListView.setAdapter(mListAdapter);
     		mListView.setChoiceMode(ListView.CHOICE_MODE_NONE);
 	    	break;
     	case 2:
-    		mListAdapter = new ArrayAdapter(mContext, R.layout.select_dialog_singlechoice, 0, mItemList);
+    		mListAdapter = new ArrayAdapter<String>(mContext, R.layout.select_dialog_singlechoice, 0, mItemList);
     		mListView.setAdapter(mListAdapter);
     		mListView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
     		mListView.setItemChecked(checkedItem, true);
         	break;
     	case 3:
-    		mListAdapter = new ArrayAdapter(mContext, R.layout.select_dialog_multichoice, 0, mItemList);
+    		mListAdapter = new ArrayAdapter<String>(mContext, R.layout.select_dialog_multichoice, 0, mItemList);
     		mListView.setAdapter(mListAdapter);
     		mListView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
 	    	for (int i = 0; i < checked.length; i++) {
@@ -187,6 +198,7 @@ public class StyledDialog extends Dialog {
         private Context context;
         private String title;
         private String message;
+        private int messageSize = 0;
         private String positiveButtonText;
         private String negativeButtonText;
         private String neutralButtonText;
@@ -223,6 +235,11 @@ public class StyledDialog extends Dialog {
             this.message = message;
             return this;
         }
+        public Builder setMessage(String message, int size) {
+            this.message = message;
+            this.messageSize = size;
+            return this;
+        }
 
 
         /**
@@ -442,6 +459,7 @@ public class StyledDialog extends Dialog {
                 }
             } else {
             	layout.findViewById(R.id.topPanel).setVisibility(View.GONE);
+            	layout.findViewById(R.id.titleDivider).setVisibility(View.GONE);
             }
 
             // set buttons
@@ -484,7 +502,11 @@ public class StyledDialog extends Dialog {
 
             // set the message
             if (message != null) {
-                ((TextView) layout.findViewById(R.id.message)).setText(message);
+                TextView tv = (TextView) layout.findViewById(R.id.message);
+                tv.setText(message);
+                if (messageSize != 0) {
+                    tv.setTextSize(messageSize * context.getResources().getDisplayMetrics().scaledDensity);
+                }
             } else {
             	((LinearLayout) layout.findViewById(R.id.contentPanel)).setVisibility(View.GONE);
             }
@@ -509,7 +531,13 @@ public class StyledDialog extends Dialog {
             }
 
             // set background
-            Themes.setStyledDialogBackgrounds(layout, numberOfButtons, brightViewBackground);
+            try {
+            	Themes.setStyledDialogBackgrounds(layout, numberOfButtons, brightViewBackground);
+            } catch (OutOfMemoryError e) {
+            	Log.e(AnkiDroidApp.TAG, "StyledDialog - Dialog could not be created: " + e);
+            	Themes.showThemedToast(context, context.getResources().getString(R.string.error_insufficient_memory), false);
+            	return null;
+            }
 
             dialog.setContentView(layout);
             return dialog;
diff --git a/src/com/ichi2/themes/StyledProgressDialog.java b/src/com/ichi2/themes/StyledProgressDialog.java
new file mode 100644
index 0000000000..134ed1efa8
--- /dev/null
+++ b/src/com/ichi2/themes/StyledProgressDialog.java
@@ -0,0 +1,141 @@
+/****************************************************************************************
+ * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *
+ *                                                                                      *
+ * based on custom Dialog windows by antoine vianey                                     *
+ *                                                                                      *
+ * This program is free software; you can redistribute it and/or modify it under        *
+ * the terms of the GNU General Public License as published by the Free Software        *
+ * Foundation; either version 3 of the License, or (at your option) any later           *
+ * version.                                                                             *
+ *                                                                                      *
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
+ *                                                                                      *
+ * You should have received a copy of the GNU General Public License along with         *
+ * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
+ ****************************************************************************************/
+
+package com.ichi2.themes;
+
+import android.app.Dialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup.LayoutParams;
+import android.view.WindowManager.BadTokenException;
+import android.widget.TextView;
+
+import com.ichi2.anki.AnkiDroidApp;
+import com.ichi2.anki.R;
+ 
+
+public class StyledProgressDialog extends Dialog {
+
+	private Context mContext;
+
+    public StyledProgressDialog(Context context) {
+        super(context, R.style.StyledDialog);
+        mContext = context;
+    }
+
+
+    @Override
+    public void show() {
+    	try {
+    		super.show();
+    	} catch (BadTokenException e) {
+    		Log.e(AnkiDroidApp.TAG, "Could not show dialog: " + e);
+    	}
+    }
+
+
+	public static StyledProgressDialog show(Context context, CharSequence title, CharSequence message) {
+		return show(context, title, message, true, false, null);
+	}
+	public static StyledProgressDialog show(Context context, CharSequence title, CharSequence message, boolean indeterminable) {
+		return show(context, title, message, indeterminable, false, null);
+	}
+	public static StyledProgressDialog show(Context context, CharSequence title, CharSequence message, boolean indeterminable, boolean cancelable) {
+		return show(context, title, message, indeterminable, cancelable, null);
+	}
+    	public static StyledProgressDialog show(Context context, CharSequence title, CharSequence message, boolean indeterminable, boolean cancelable, DialogInterface.OnCancelListener cancelListener) {
+            final StyledProgressDialog dialog = new StyledProgressDialog(context);
+            LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+
+            View layout = inflater.inflate(R.layout.styled_progress_dialog, null);
+            dialog.addContentView(layout, new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT));
+
+            // set title
+            if (title != null && title.length() > 0) {
+                ((TextView) layout.findViewById(R.id.alertTitle)).setText(title);            	
+//                if (icon != 0) {
+//                    ((ImageView) layout.findViewById(R.id.icon)).setImageResource(icon);            	
+//                } else {
+//                	layout.findViewById(R.id.icon).setVisibility(View.GONE);
+//                }
+            } else {
+            	layout.findViewById(R.id.topPanel).setVisibility(View.GONE);
+            	layout.findViewById(R.id.titleDivider).setVisibility(View.GONE);
+            }
+
+            // set the message
+            if (message != null) {
+                TextView tv = (TextView) layout.findViewById(R.id.message);
+                tv.setText(message);
+//                if (messageSize != 0) {
+//                    tv.setTextSize(messageSize * context.getResources().getDisplayMetrics().scaledDensity);
+//                }
+            }
+
+            // set background
+            try {
+            	Themes.setStyledProgressDialogDialogBackgrounds(layout);
+            } catch (OutOfMemoryError e) {
+            	Log.e(AnkiDroidApp.TAG, "StyledDialog - Dialog could not be created: " + e);
+            	Themes.showThemedToast(context, context.getResources().getString(R.string.error_insufficient_memory), false);
+            	return null;
+            }
+
+            dialog.setContentView(layout);
+            dialog.show();
+            return dialog;
+
+    }
+
+
+    public void setMessage(CharSequence message) {
+    	View main = super.getWindow().getDecorView();
+    	((TextView) main.findViewById(R.id.message)).setText(message);
+        ((View) main.findViewById(R.id.contentPanel)).setVisibility(View.VISIBLE);
+    }
+
+
+    public void setTitle(String message) {
+    	View main = super.getWindow().getDecorView();
+    	((TextView) main.findViewById(R.id.alertTitle)).setText(message);
+    }
+
+
+    public void setMessage(String message) {
+    	View main = super.getWindow().getDecorView();
+    	((TextView) main.findViewById(R.id.message)).setText(message);
+        ((View) main.findViewById(R.id.contentPanel)).setVisibility(View.VISIBLE);
+    }
+
+    
+    public void setMax(int max) {
+    	// TODO
+    }
+
+    public void setProgress(int progress) {
+    	// TODO
+    }
+
+    public void setProgressStyle(int style) {
+    	// TODO
+    }
+
+}
diff --git a/src/com/ichi2/themes/Themes.java b/src/com/ichi2/themes/Themes.java
index 4a2eeab924..87d37c5b6f 100644
--- a/src/com/ichi2/themes/Themes.java
+++ b/src/com/ichi2/themes/Themes.java
@@ -24,12 +24,20 @@ import android.content.Context;
 import android.content.SharedPreferences;
 import android.content.DialogInterface.OnCancelListener;
 import android.content.DialogInterface.OnClickListener;
+import android.content.res.Resources;
 import android.graphics.Color;
+import android.graphics.Typeface;
+import android.graphics.drawable.Drawable;
 import android.util.Log;
 import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewGroup.MarginLayoutParams;
 import android.webkit.WebView;
+import android.widget.FrameLayout;
 import android.widget.LinearLayout;
+import android.widget.LinearLayout.LayoutParams;
 import android.widget.ListView;
+import android.widget.RelativeLayout;
 import android.widget.TextView;
 import android.widget.Toast;
 
@@ -38,6 +46,9 @@ public class Themes {
 	public final static int THEME_ANDROID_DARK = 0;
 	public final static int THEME_ANDROID_LIGHT = 1;
 	public final static int THEME_BLUE = 2;
+	public final static int THEME_WHITE = 3;
+	public final static int THEME_FLAT = 4;
+	public final static int THEME_NO_THEME = 100;
 
 	public final static int CALLER_STUDYOPTIONS = 1;
 	public final static int CALLER_DECKPICKER_DECK = 3;
@@ -46,6 +57,8 @@ public class Themes {
 	public final static int CALLER_DOWNLOAD_DECK= 6;
 	public final static int CALLER_DECKPICKER = 7;
 	public final static int CALLER_CARDBROWSER = 8;
+	public final static int CALLER_CARDEDITOR_INTENTDIALOG = 9;
+	public final static int CALLER_CARD_EDITOR = 10;
 
 	private static int mCurrentTheme = -1;
 	private static int mProgressbarsBackgroundColor;
@@ -58,6 +71,7 @@ public class Themes {
 	private static int mFlashcardBorder = 0;
 	private static int mDeckpickerItemBorder = 0;
 	private static int mTitleStyle = 0;
+	private static int mTitleTextColor;
 	private static int mTextViewStyle= 0;
 	private static int mWallpaper = 0;
 	private static int mBackgroundColor;
@@ -79,15 +93,23 @@ public class Themes {
 	private static int mPopupFullMedium;
 	private static int mPopupFullBright;
 	private static int mDividerHorizontalBright;
+	private static Typeface mLightFont;
+	private static Typeface mRegularFont;
+	private static Typeface mBoldFont;
+	private static int mProgressDialogFontColor;
+	private static int mNightModeButton;
 
 	private static Context mContext;
 
 	public static void applyTheme(Context context) {
+		applyTheme(context, -1);
+	}
+	public static void applyTheme(Context context, int theme) {
 		mContext = context;
 		if (mCurrentTheme == -1) {
 			loadTheme();
 		}
-		switch (mCurrentTheme) {
+		switch (theme == -1 ? mCurrentTheme : theme) {
 		case THEME_ANDROID_DARK:
 			context.setTheme(R.style.Theme_Black);
 			Log.i(AnkiDroidApp.TAG, "Set theme: dark");
@@ -100,14 +122,22 @@ public class Themes {
 			context.setTheme(R.style.Theme_Blue);
 			Log.i(AnkiDroidApp.TAG, "Set theme: blue");
 			break;
+		case THEME_FLAT:
+			context.setTheme(R.style.Theme_Flat);
+			Log.i(AnkiDroidApp.TAG, "Set theme: flat");
+			break;
+		case THEME_WHITE:
+			context.setTheme(R.style.Theme_White);
+			Log.i(AnkiDroidApp.TAG, "Set theme: white");
+			break;
+		case -1:
+			break;
 		}
 	}
 
 
 	public static void setContentStyle(View view, int caller) {
-		if (mCurrentTheme == THEME_ANDROID_DARK) {
-			return;
-		}
+		setFont(view);
 		switch (caller) {
 		case CALLER_STUDYOPTIONS:
 			((View) view.findViewById(R.id.studyoptions_progressbar1_border)).setBackgroundResource(mProgressbarsFrameColor);
@@ -125,17 +155,86 @@ public class Themes {
 
 			((View) view.findViewById(R.id.studyoptions_global_limit_bar)).setBackgroundResource(mProgressbarsYoungColor);
 			((View) view.findViewById(R.id.studyoptions_global_bar)).setBackgroundResource(mProgressbarsYoungColor);
+
+			if (mCurrentTheme == THEME_WHITE) {
+		        setMargins(view.findViewById(R.id.studyoptions_mainframe), LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT, 4f, 4f, 4f, 4f);
+				setMargins(view.findViewById(R.id.studyoptions_deck_name), LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT, 0, 6f, 0, 2f);
+		        setMargins(view.findViewById(R.id.studyoptions_statistic_field), LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT, 0, 2f, 0, 12f);
+				setMargins(view.findViewById(R.id.studyoptions_bottom), LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT, 0, 0, 0, 8f);
+				((View) view.findViewById(R.id.studyoptions_deckinformation)).setBackgroundResource(R.drawable.white_textview);
+				((View) view.findViewById(R.id.studyoptions_statistic_field)).setBackgroundResource(R.color.transparent);
+				((View) view.findViewById(R.id.studyoptions_deckinformation)).setBackgroundResource(mTextViewStyle);
+				((View) view.findViewById(R.id.studyoptions_bottom)).setBackgroundResource(mTextViewStyle);
+			} else {
+				((View) view.findViewById(R.id.studyoptions_statistic_field)).setBackgroundResource(mTextViewStyle);
+			}
 			break;
+
 		case CALLER_DECKPICKER:
-			if (mCurrentTheme == THEME_BLUE) {
-				((ListView)view.findViewById(R.id.files)).setSelector(R.drawable.blue_deckpicker_list_selector);
+			ListView lv = (ListView) view.findViewById(R.id.files);
+			switch (mCurrentTheme) {
+			case THEME_BLUE:
+				lv.setSelector(R.drawable.blue_deckpicker_list_selector);
+				lv.setDividerHeight(0);
+				break;
+			case THEME_FLAT:
+				lv.setSelector(R.drawable.blue_deckpicker_list_selector);
+				lv.setDividerHeight(0);
+				break;
+			case THEME_WHITE:
+				lv.setBackgroundResource(R.drawable.white_textview);
+				lv.setSelector(R.drawable.white_deckpicker_list_selector);
+				lv.setDivider(mContext.getResources().getDrawable(R.drawable.white_listdivider));
+		        setMargins(view, LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT, 4f, 4f, 4f, 4f);
+				break;
+			default:
+				break;
 			}
 			break;
+
 		case CALLER_CARDBROWSER:
-			if (mCurrentTheme == THEME_BLUE) {
-				((ListView)view.findViewById(R.id.card_browser_list)).setSelector(R.drawable.blue_cardbrowser_list_selector);
+			ListView lv2 = (ListView) view.findViewById(R.id.card_browser_list);
+			switch (mCurrentTheme) {
+			case THEME_BLUE:
+				lv2.setSelector(R.drawable.blue_cardbrowser_list_selector);
+				lv2.setDividerHeight(0);
+				break;
+			case THEME_FLAT:
+				lv2.setSelector(R.drawable.blue_cardbrowser_list_selector);
+				lv2.setDividerHeight(0);
+				break;
+			case THEME_WHITE:
+				lv2.setBackgroundResource(R.drawable.white_textview);
+				lv2.setSelector(R.drawable.white_deckpicker_list_selector);
+				lv2.setDivider(mContext.getResources().getDrawable(R.drawable.white_listdivider));
+//				setFont(view);
+		        setMargins(view, LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT, 4f, 4f, 4f, 4f);
+				break;
+			default:
+				break;
+			}
+			break;
+			
+		case CALLER_CARDEDITOR_INTENTDIALOG:
+			ListView lv3 = (ListView) view;
+			switch (mCurrentTheme) {
+			case THEME_BLUE:
+				lv3.setSelector(R.drawable.blue_cardbrowser_list_selector);
+				lv3.setDividerHeight(0);
+				break;
+			case THEME_FLAT:
+				lv3.setSelector(R.drawable.blue_cardbrowser_list_selector);
+				lv3.setDividerHeight(0);
+				break;
+			case THEME_WHITE:
+				lv3.setSelector(R.drawable.blue_cardbrowser_list_selector);
+				lv3.setDividerHeight(0);
+				break;
+			default:
+				break;
 			}
 			break;
+
 		case CALLER_DECKPICKER_DECK:
 			if (view.getId() == R.id.DeckPickerCompletionMat) {
 				view.setBackgroundResource(mProgressbarsFrameColor);
@@ -145,14 +244,45 @@ public class Themes {
 				view.setBackgroundResource(mDeckpickerItemBorder);
 			}
 			break;
+
 		case CALLER_REVIEWER:
-	        ((View)view.findViewById(R.id.main_layout)).setBackgroundResource(mReviewerBackground);
-	        ((View)view.findViewById(R.id.flashcard_border)).setBackgroundResource(mFlashcardBorder);
+		        ((View)view.findViewById(R.id.main_layout)).setBackgroundResource(mReviewerBackground);
+		        ((View)view.findViewById(R.id.flashcard_border)).setBackgroundResource(mFlashcardBorder);
+			switch (mCurrentTheme) {
+			case THEME_ANDROID_DARK:
+			case THEME_ANDROID_LIGHT:
+			        ((View)view.findViewById(R.id.flashcard_frame)).setBackgroundResource(PrefSettings.getSharedPrefs(mContext).getBoolean("invertedColors", false) ? R.color.black : R.color.white);
+				break;
+			case THEME_BLUE:
+			        ((View)view.findViewById(R.id.flashcard_frame)).setBackgroundResource(PrefSettings.getSharedPrefs(mContext).getBoolean("invertedColors", false) ? R.color.reviewer_night_card_background : R.color.white);
+				break;
+			case THEME_FLAT:
+			        ((View)view.findViewById(R.id.flashcard_frame)).setBackgroundResource(PrefSettings.getSharedPrefs(mContext).getBoolean("invertedColors", false) ? R.color.reviewer_night_card_background : R.color.white);
+				break;
+			case THEME_WHITE:
+		        ((View)view.findViewById(R.id.flashcard_frame)).setBackgroundResource(PrefSettings.getSharedPrefs(mContext).getBoolean("invertedColors", false) ? R.color.black : R.color.white);
+		        
+		        setMargins(view.findViewById(R.id.main_layout), LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT, 4f, 0, 4f, 4f);
+			        
+			        //			        ((View)view.findViewById(R.id.nextTime1)).setBackgroundResource(R.drawable.white_next_time_separator);
+//			        ((View)view.findViewById(R.id.nextTime2)).setBackgroundResource(R.drawable.white_next_time_separator);
+//			        ((View)view.findViewById(R.id.nextTime3)).setBackgroundResource(R.drawable.white_next_time_separator);
+//			        ((View)view.findViewById(R.id.nextTime4)).setBackgroundResource(R.drawable.white_next_time_separator);
+				break;
+			}
 	        ((View)view.findViewById(R.id.session_progress)).setBackgroundResource(mReviewerProgressbar);
 			break;
+
 		case CALLER_FEEDBACK:
 			((TextView)view).setTextColor(mProgressbarsFrameColor);
 			break;
+
+		case CALLER_CARD_EDITOR:
+			view.findViewById(R.id.CardEditorEditFieldsLayout).setBackgroundResource(mTextViewStyle);
+			int padding = (int) (4 * mContext.getResources().getDisplayMetrics().density);
+			view.findViewById(R.id.CardEditorScroll).setPadding(padding, padding, padding, padding);
+			break;
+
 		case CALLER_DOWNLOAD_DECK:
 			view.setBackgroundResource(mDeckpickerItemBorder);
 			break;
@@ -175,6 +305,7 @@ public class Themes {
 				mFlashcardBorder = 0;
 				mDeckpickerItemBorder = 0;
 				mTitleStyle = 0;
+				mTitleTextColor = mContext.getResources().getColor(R.color.white);
 				mTextViewStyle = 0;
 				mWallpaper = 0;
 				mToastBackground = 0;
@@ -196,7 +327,10 @@ public class Themes {
 				mPopupFullMedium = R.drawable.popup_full_bright;
 				mDividerHorizontalBright = R.drawable.blue_divider_horizontal_bright;
 				mBackgroundColor = R.color.white;
+				mProgressDialogFontColor = mContext.getResources().getColor(R.color.white);
+				mNightModeButton = R.drawable.btn_keyboard_key_fulltrans_normal;
 				break;
+
 			case THEME_ANDROID_LIGHT:
 				mProgressbarsBackgroundColor = R.color.studyoptions_progressbar_background_light;
 				mProgressbarsFrameColor = R.color.studyoptions_progressbar_frame_light;
@@ -207,6 +341,7 @@ public class Themes {
 				mFlashcardBorder = 0;
 				mDeckpickerItemBorder = 0;
 				mTitleStyle = 0;
+				mTitleTextColor = mContext.getResources().getColor(R.color.black);
 				mTextViewStyle = 0;
 				mWallpaper = 0;
 				mToastBackground = 0;
@@ -229,7 +364,10 @@ public class Themes {
 				mPopupFullDark = R.drawable.popup_full_dark;
 				mDividerHorizontalBright = R.drawable.blue_divider_horizontal_bright;
 				mBackgroundColor = R.color.white;
-				break;				
+				mProgressDialogFontColor = mContext.getResources().getColor(R.color.white);
+				mNightModeButton = R.drawable.btn_keyboard_key_fulltrans_normal;
+				break;
+
 			case THEME_BLUE:
 				mProgressbarsBackgroundColor = R.color.studyoptions_progressbar_background_blue;
 				mProgressbarsFrameColor = R.color.studyoptions_progressbar_frame_light;
@@ -240,6 +378,7 @@ public class Themes {
 				mFlashcardBorder = R.drawable.blue_bg_webview;
 				mDeckpickerItemBorder = R.drawable.blue_bg_deckpicker;
 				mTitleStyle = R.drawable.blue_title;
+				mTitleTextColor = mContext.getResources().getColor(R.color.black);
 				mTextViewStyle = R.drawable.blue_textview;
 				mWallpaper = R.drawable.blue_background;
 				mBackgroundColor = R.color.background_blue;
@@ -262,11 +401,141 @@ public class Themes {
 				mPopupFullMedium = R.drawable.blue_popup_full_medium;
 				mPopupFullDark = R.drawable.blue_popup_full_dark;
 				mDividerHorizontalBright = R.drawable.blue_divider_horizontal_bright;
+				mProgressDialogFontColor = mContext.getResources().getColor(R.color.white);
+				mNightModeButton = R.drawable.blue_btn_night;
+				break;
+
+			case THEME_FLAT:
+				mProgressbarsBackgroundColor = R.color.studyoptions_progressbar_background_blue;
+				mProgressbarsFrameColor = R.color.studyoptions_progressbar_frame_light;
+				mProgressbarsMatureColor = R.color.studyoptions_progressbar_mature_light;
+				mProgressbarsYoungColor = R.color.studyoptions_progressbar_young_blue;
+				mProgressbarsDeckpickerYoungColor = R.color.deckpicker_progressbar_young_light;
+				mReviewerBackground = R.color.reviewer_background;
+				mFlashcardBorder = R.drawable.blue_bg_webview;
+				mDeckpickerItemBorder = R.drawable.blue_bg_deckpicker;
+				mTitleStyle = R.drawable.flat_title;
+				mTitleTextColor = mContext.getResources().getColor(R.color.flat_title_color);
+				mTextViewStyle = R.drawable.flat_textview;
+				mWallpaper = R.drawable.flat_background;
+				mBackgroundColor = R.color.background_blue;
+				mToastBackground = R.drawable.blue_toast_frame;
+				mDialogBackgroundColor = R.color.background_dialog_blue;
+				mBackgroundDarkColor = R.color.background_dark_blue;
+				mReviewerProgressbar = R.color.reviewer_progressbar_session_blue;
+				mCardbrowserItemBorder = new int[] {R.drawable.blue_bg_cardbrowser, R.drawable.blue_bg_cardbrowser_marked, R.drawable.blue_bg_cardbrowser_suspended, R.drawable.blue_bg_cardbrowser_marked_suspended};
+				mChartColors = new int[] {Color.BLACK, Color.WHITE};
+				mPopupTopDark = R.drawable.blue_popup_top_dark;
+				mPopupTopBright = R.drawable.blue_popup_top_bright;
+				mPopupTopMedium = R.drawable.blue_popup_top_medium;
+				mPopupCenterDark = R.drawable.blue_popup_center_dark;
+				mPopupCenterBright = R.drawable.blue_popup_center_bright;
+				mPopupCenterMedium = R.drawable.blue_popup_center_medium;
+				mPopupBottomDark = R.drawable.blue_popup_bottom_dark;
+				mPopupBottomBright = R.drawable.blue_popup_bottom_bright;
+				mPopupBottomMedium = R.drawable.blue_popup_bottom_medium;
+				mPopupFullBright = R.drawable.blue_popup_full_bright;
+				mPopupFullMedium = R.drawable.blue_popup_full_medium;
+				mPopupFullDark = R.drawable.blue_popup_full_dark;
+				mDividerHorizontalBright = R.drawable.blue_divider_horizontal_bright;
+				mLightFont = Typeface.createFromAsset(mContext.getAssets(), "fonts/OpenSans-Light.ttf");
+				mRegularFont = Typeface.createFromAsset(mContext.getAssets(), "fonts/OpenSans-Regular.ttf");
+				mBoldFont = Typeface.createFromAsset(mContext.getAssets(), "fonts/OpenSans-Bold.ttf");
+				mProgressDialogFontColor = mContext.getResources().getColor(R.color.white);
+				mNightModeButton = R.drawable.blue_btn_night;
+				break;
+
+			case THEME_WHITE:
+			mProgressbarsBackgroundColor = R.color.studyoptions_progressbar_background_blue;
+			mProgressbarsFrameColor = R.color.studyoptions_progressbar_frame_light;
+			mProgressbarsMatureColor = R.color.studyoptions_progressbar_mature_light;
+			mProgressbarsYoungColor = R.color.studyoptions_progressbar_young_blue;
+			mProgressbarsDeckpickerYoungColor = R.color.deckpicker_progressbar_young_light;
+				mReviewerBackground = R.color.white_background;
+				mFlashcardBorder = R.drawable.white_bg_webview;
+				mDeckpickerItemBorder = R.drawable.white_bg_deckpicker;
+			mTitleStyle = R.drawable.flat_title;
+				mTitleTextColor = mContext.getResources().getColor(R.color.black);
+				mTextViewStyle = R.drawable.white_textview_padding;
+				mWallpaper = R.color.white_background;
+				mBackgroundColor = R.color.white_background;
+				mToastBackground = R.drawable.white_toast_frame;
+				mDialogBackgroundColor = mBackgroundColor;
+			mBackgroundDarkColor = R.color.background_dark_blue;
+			mReviewerProgressbar = R.color.reviewer_progressbar_session_blue;
+				mCardbrowserItemBorder = new int[] {R.drawable.white_bg_cardbrowser, R.drawable.white_bg_cardbrowser_marked, R.drawable.white_bg_cardbrowser_suspended, R.drawable.white_bg_cardbrowser_marked_suspended};
+			mChartColors = new int[] {Color.BLACK, Color.WHITE};
+				mPopupTopBright = R.drawable.white_popup_top_bright;
+				mPopupTopMedium = R.drawable.white_popup_top_medium;
+				mPopupTopDark = mPopupTopMedium;
+				mPopupCenterDark = R.drawable.white_popup_center_bright;
+				mPopupCenterBright = R.drawable.white_popup_center_bright;
+				mPopupCenterMedium = R.drawable.white_popup_center_medium;
+				mPopupBottomBright = R.drawable.white_popup_bottom_bright;
+				mPopupBottomDark = mPopupBottomBright;
+				mPopupBottomMedium = R.drawable.white_popup_bottom_medium;
+				mPopupFullBright = R.drawable.white_popup_full_bright;
+				mPopupFullMedium = R.drawable.white_popup_full_medium;
+				mPopupFullDark = mPopupFullBright;
+				mDividerHorizontalBright = R.drawable.white_dialog_divider;
+				mLightFont = Typeface.createFromAsset(mContext.getAssets(), "fonts/OpenSans-Light.ttf");
+				mRegularFont = Typeface.createFromAsset(mContext.getAssets(), "fonts/OpenSans-Regular.ttf");
+				mBoldFont = Typeface.createFromAsset(mContext.getAssets(), "fonts/OpenSans-Bold.ttf");
+				mProgressDialogFontColor = mContext.getResources().getColor(R.color.black);
+				mNightModeButton = R.drawable.white_btn_night;
 				break;
 			}
 	}
 
 
+	public static void setLightFont(TextView view) {
+		if (mLightFont != null) {
+			view.setTypeface(mLightFont);
+		}
+	}
+	public static void setRegularFont(TextView view) {
+		if (mRegularFont != null) {
+			view.setTypeface(mRegularFont);
+		}
+	}
+	public static void setBoldFont(TextView view) {
+		if (mBoldFont != null) {
+			view.setTypeface(mBoldFont);
+		}
+	}
+
+	public static void setFont(View view) {
+		if (view instanceof ViewGroup) {
+			ViewGroup vg = (ViewGroup) view;
+			for (int i = 0; i < vg.getChildCount(); i++) {
+				View child = vg.getChildAt(i);
+				if (child instanceof TextView) {
+					TextView tv = (TextView) child;
+					if (tv.getTypeface() != null && tv.getTypeface().getStyle() == Typeface.BOLD) {
+						setBoldFont((TextView) child);
+					} else {
+						setRegularFont((TextView) child);
+					}
+				}
+				setFont(child);
+			}
+		}
+	}
+
+	public static void setTextColor(View view, int color) {
+		if (view instanceof ViewGroup) {
+			ViewGroup vg = (ViewGroup) view;
+			for (int i = 0; i < vg.getChildCount(); i++) {
+				View child = vg.getChildAt(i);
+				if (child instanceof TextView) {
+					TextView tv = (TextView) child;
+					tv.setTextColor(color);
+				}
+				setTextColor(child, color);
+			}
+		}
+	}
+
 	public static void setWallpaper(View view) {
 		setWallpaper(view, false);
 	}
@@ -292,6 +561,42 @@ public class Themes {
 
 	public static void setTitleStyle(View view) {
 		view.setBackgroundResource(mTitleStyle);
+		if (view instanceof TextView) {
+			TextView tv = (TextView) view;
+			tv.setTextColor(mTitleTextColor);
+			if (mCurrentTheme == THEME_FLAT) {
+				tv.setMinLines(1);
+				tv.setMaxLines(2);
+				int height = (int) (tv.getLineHeight() / 2);
+				LinearLayout.LayoutParams llp = new LinearLayout.LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT);
+				MarginLayoutParams mlp = (MarginLayoutParams) tv.getLayoutParams();
+				height += mlp.bottomMargin;
+				llp.setMargins(0, height, 0, height);
+				tv.setLayoutParams(llp);
+				setBoldFont(tv);
+			}
+		}
+	}
+
+
+	public static void setMargins(View view, int width, int height, float dipLeft, float dipTop, float dipRight, float dipBottom) {
+		View parent = (View) view.getParent();
+		parent.setBackgroundResource(mBackgroundColor);
+		Class c = view.getParent().getClass();
+    	float factor = mContext.getResources().getDisplayMetrics().density;
+		if (c == LinearLayout.class) {
+			LinearLayout.LayoutParams llp = new LinearLayout.LayoutParams(width, height);
+			llp.setMargins((int)(dipLeft * factor), (int)(dipTop * factor), (int)(dipRight * factor), (int)(dipBottom * factor));
+			view.setLayoutParams(llp);
+		} else if (c == FrameLayout.class) {
+			FrameLayout.LayoutParams llp = new FrameLayout.LayoutParams(width, height);
+			llp.setMargins((int)(dipLeft * factor), (int)(dipTop * factor), (int)(dipRight * factor), (int)(dipBottom * factor));
+			view.setLayoutParams(llp);
+		} else if (c == RelativeLayout.class) {
+			RelativeLayout.LayoutParams llp = new RelativeLayout.LayoutParams(width, height);
+			llp.setMargins((int)(dipLeft * factor), (int)(dipTop * factor), (int)(dipRight * factor), (int)(dipBottom * factor));
+			view.setLayoutParams(llp);
+		}
 	}
 
 
@@ -322,10 +627,20 @@ public class Themes {
 
 	public static void showThemedToast(Context context, String text, boolean shortLength) {
 		Toast result = Toast.makeText(context, text, shortLength ? Toast.LENGTH_SHORT : Toast.LENGTH_LONG);
-		if (mCurrentTheme >= THEME_BLUE) {
-			result.getView().setBackgroundResource(mToastBackground);
+		try {
+			if (mCurrentTheme >= THEME_BLUE) {
+				TextView tv = new TextView(context);
+				tv.setBackgroundResource(mToastBackground);
+				tv.setTextColor(mProgressDialogFontColor);
+				tv.setText(text);
+				result.setView(tv);
+			}
+        	result.show();
+		} catch (OutOfMemoryError e) {
+			Log.e(AnkiDroidApp.TAG, "showThemedToast - OutOfMemoryError occured: " + e);
+			result.getView().setBackgroundResource(R.color.black);
+			result.show();
 		}
-        result.show();
 	}
 
 
@@ -352,10 +667,40 @@ public class Themes {
 	}
 
 
+	public static void setStyledProgressDialogDialogBackgrounds(View main) {
+		View topPanel = ((View) main.findViewById(R.id.topPanel));
+		View contentPanel = ((View) main.findViewById(R.id.contentPanel));
+		if (topPanel.getVisibility() == View.VISIBLE) {
+			try {
+				topPanel.setBackgroundResource(mPopupTopDark);
+				((View) main.findViewById(R.id.titleDivider)).setBackgroundResource(mDividerHorizontalBright);
+				contentPanel.setBackgroundResource(mPopupBottomMedium);
+			} catch (OutOfMemoryError e) {
+				Log.e(AnkiDroidApp.TAG, "setStyledDialogBackgrounds - OutOfMemoryError occured: " + e);
+				topPanel.setBackgroundResource(R.color.black);
+				contentPanel.setBackgroundResource(R.color.white);
+			}			
+		} else {
+			try {
+				contentPanel.setBackgroundResource(mPopupFullMedium);
+			} catch (OutOfMemoryError e) {
+				Log.e(AnkiDroidApp.TAG, "setStyledDialogBackgrounds - OutOfMemoryError occured: " + e);
+				contentPanel.setBackgroundResource(R.color.white);
+			}
+		}
+		((TextView) main.findViewById(R.id.alertTitle)).setTextColor(mProgressDialogFontColor);
+		((TextView) main.findViewById(R.id.message)).setTextColor(mProgressDialogFontColor);
+	}
+
+
 	public static void setStyledDialogBackgrounds(View main, int buttonNumbers) {
 		setStyledDialogBackgrounds(main, buttonNumbers, false);
 	}
 	public static void setStyledDialogBackgrounds(View main, int buttonNumbers, boolean brightCustomPanelBackground) {
+		setFont(main);
+		if (mCurrentTheme == THEME_WHITE) {
+			setTextColor(main, mContext.getResources().getColor(R.color.black));
+		}
 		// order of styled dialog elements:
 		// 1. top panel (title)
 		// 2. content panel
@@ -366,8 +711,13 @@ public class Themes {
 		boolean[] visibility = new boolean[5];
 
 		if (topPanel.getVisibility() == View.VISIBLE) {
-			topPanel.setBackgroundResource(mPopupTopDark);
-			((View) main.findViewById(R.id.titleDivider)).setBackgroundResource(mDividerHorizontalBright);
+			try {
+				topPanel.setBackgroundResource(mPopupTopDark);
+				((View) main.findViewById(R.id.titleDivider)).setBackgroundResource(mDividerHorizontalBright);
+			} catch (OutOfMemoryError e) {
+				Log.e(AnkiDroidApp.TAG, "setStyledDialogBackgrounds - OutOfMemoryError occured: " + e);
+				topPanel.setBackgroundResource(R.color.black);
+			}
 			visibility[0] = true;
 		}
 		View contentPanel = ((View) main.findViewById(R.id.contentPanel));
@@ -384,7 +734,12 @@ public class Themes {
 		}
 		if (buttonNumbers > 0) {
         	LinearLayout buttonPanel = (LinearLayout) main.findViewById(R.id.buttonPanel);
-        	buttonPanel.setBackgroundResource(mPopupBottomMedium);
+			try {
+	        	buttonPanel.setBackgroundResource(mPopupBottomMedium);
+			} catch (OutOfMemoryError e) {
+				Log.e(AnkiDroidApp.TAG, "setStyledDialogBackgrounds - OutOfMemoryError occured: " + e);
+				buttonPanel.setBackgroundResource(R.color.white);
+			}
     		if (buttonNumbers > 1) {
     			main.findViewById(R.id.rightSpacer).setVisibility(View.GONE);
     			main.findViewById(R.id.leftSpacer).setVisibility(View.GONE);
@@ -413,7 +768,12 @@ public class Themes {
 				res = mPopupFullDark;
 			}
 		}
-		contentPanel.setBackgroundResource(res);
+		try {
+			contentPanel.setBackgroundResource(res);
+		} catch (OutOfMemoryError e) {
+			Log.e(AnkiDroidApp.TAG, "setStyledDialogBackgrounds - OutOfMemoryError occured: " + e);
+			contentPanel.setBackgroundResource(R.color.black);
+		}
 
 		res = mPopupCenterBright;
 		if (first == 2) {
@@ -425,7 +785,12 @@ public class Themes {
 				res = mPopupFullBright;
 			}
 		}
-		listViewPanel.setBackgroundResource(res);
+		try {
+			listViewPanel.setBackgroundResource(res);
+		} catch (OutOfMemoryError e) {
+			Log.e(AnkiDroidApp.TAG, "setStyledDialogBackgrounds - OutOfMemoryError occured: " + e);
+			listViewPanel.setBackgroundResource(R.color.white);
+		}
 
 		res = brightCustomPanelBackground ? mPopupCenterMedium : mPopupCenterDark;
 		if (first == 3) {
@@ -437,7 +802,12 @@ public class Themes {
 				res = brightCustomPanelBackground ? mPopupFullMedium : mPopupFullDark;;
 			}
 		}
-		customPanel.setBackgroundResource(res);
+		try {
+			customPanel.setBackgroundResource(res);
+		} catch (OutOfMemoryError e) {
+			Log.e(AnkiDroidApp.TAG, "setStyledDialogBackgrounds - OutOfMemoryError occured: " + e);
+			customPanel.setBackgroundResource(brightCustomPanelBackground ? R.color.white : R.color.black);
+		}
 	}
 
 
@@ -450,8 +820,64 @@ public class Themes {
 		switch (mCurrentTheme) {
 		case THEME_BLUE:
 			return context.getResources().getColor(R.color.reviewer_night_card_background);
+		case THEME_FLAT:
+			return context.getResources().getColor(R.color.reviewer_night_card_background);
+		case THEME_WHITE:
 		default:
-			return Color.BLACK;
+			return context.getResources().getColor(R.color.black);
+		}
+	}
+
+
+	public static int[] setNightMode(Context context, View view, boolean nightMode) {
+		Resources res = context.getResources();
+		View flipCard = view.findViewById(R.id.flashcard_layout_flip);
+		View ease1 = view.findViewById(R.id.flashcard_layout_ease1);
+		View ease2 = view.findViewById(R.id.flashcard_layout_ease2);
+		View ease3 = view.findViewById(R.id.flashcard_layout_ease3);
+		View ease4 = view.findViewById(R.id.flashcard_layout_ease4);
+		View border = view.findViewById(R.id.flashcard_border);
+		final Drawable[] defaultButtons = new Drawable[]{flipCard.getBackground(), ease1.getBackground(), ease2.getBackground(), ease3.getBackground(), ease4.getBackground()};
+
+		int foregroundColor;
+		int nextTimeRecommendedColor;
+
+		if (nightMode) {
+			flipCard.setBackgroundResource(mNightModeButton);
+			ease1.setBackgroundResource(mNightModeButton);
+			ease2.setBackgroundResource(mNightModeButton);
+			ease3.setBackgroundResource(mNightModeButton);
+			ease4.setBackgroundResource(mNightModeButton);
+
+			foregroundColor = Color.WHITE;
+			nextTimeRecommendedColor = res.getColor(R.color.next_time_recommended_color_inv);
+
+			switch (mCurrentTheme) {
+			case THEME_BLUE:
+				border.setBackgroundResource(R.drawable.blue_bg_webview_night);
+				view.setBackgroundColor(res.getColor(R.color.background_dark_blue));
+				break;
+			case THEME_WHITE:
+				border.setBackgroundResource(R.drawable.white_bg_webview_night);
+				view.setBackgroundColor(res.getColor(R.color.white_background_night));
+				((View)view.getParent()).setBackgroundColor(res.getColor(R.color.white_background_night));
+				break;
+			case THEME_FLAT:
+			default:
+				view.setBackgroundColor(res.getColor(R.color.black));
+				break;
+			}
+		} else {
+			foregroundColor = Color.BLACK;
+			nextTimeRecommendedColor = res.getColor(R.color.next_time_recommended_color);
+			flipCard.setBackgroundDrawable(defaultButtons[0]);
+			ease1.setBackgroundDrawable(defaultButtons[1]);
+			ease2.setBackgroundDrawable(defaultButtons[2]);
+			ease3.setBackgroundDrawable(defaultButtons[3]);
+			ease4.setBackgroundDrawable(defaultButtons[4]);
+			border.setBackgroundResource(mFlashcardBorder);
 		}
+		
+    	return new int[]{foregroundColor, nextTimeRecommendedColor}; 
 	}
 }
diff --git a/src/com/ichi2/utils/Base64.java b/src/com/ichi2/utils/Base64.java
index 406d4a6f07..bf264aa7d4 100755
--- a/src/com/ichi2/utils/Base64.java
+++ b/src/com/ichi2/utils/Base64.java
@@ -1185,7 +1185,7 @@ public class Base64 extends Object {
                     @Override
                     public Class<?> resolveClass(java.io.ObjectStreamClass streamClass) throws java.io.IOException,
                             ClassNotFoundException {
-                        Class c = Class.forName(streamClass.getName(), false, loader);
+                        Class<?> c = Class.forName(streamClass.getName(), false, loader);
                         if (c == null) {
                             return super.resolveClass(streamClass);
                         } else {
diff --git a/src/com/ichi2/utils/RubyParser.java b/src/com/ichi2/utils/RubyParser.java
index e16b9679b7..540e62c2f4 100644
--- a/src/com/ichi2/utils/RubyParser.java
+++ b/src/com/ichi2/utils/RubyParser.java
@@ -25,12 +25,12 @@ package com.ichi2.utils;
  */
 public class RubyParser {
 
-    private static final char RUBY_SPACER_JAP_SPACE = ' ';
-    private static final char RUBY_SPACER_JAP_COMMA = '\u3001';
-    private static final char RUBY_TEXT_START = '[';
-    private static final char RUBY_TEXT_END = ']';
-    private static final char HTML_TAG_START = '<';
-    private static final char HTML_TAG_END = '>';
+//    private static final char RUBY_SPACER_JAP_SPACE = ' ';
+//    private static final char RUBY_SPACER_JAP_COMMA = '\u3001';
+//    private static final char RUBY_TEXT_START = '[';
+//    private static final char RUBY_TEXT_END = ']';
+//    private static final char HTML_TAG_START = '<';
+//    private static final char HTML_TAG_END = '>';
 
 
     /**
@@ -115,7 +115,9 @@ public class RubyParser {
     	return sourceText.replaceAll(" ?([^ >]+?)\\[([^(sound:)].*?)\\]", "$2");
     }
     
+    /*
     private static String newRubyPair(String baseText, String rubyText) {
         return "<ruby><rb>" + baseText + "</rb><rt>" + rubyText + "</rt></ruby>";
     }
+    */
 }
diff --git a/src/com/ichi2/widget/AnkiDroidWidgetBig.java b/src/com/ichi2/widget/AnkiDroidWidgetBig.java
new file mode 100644
index 0000000000..53d39f01a9
--- /dev/null
+++ b/src/com/ichi2/widget/AnkiDroidWidgetBig.java
@@ -0,0 +1,1035 @@
+/***************************************************************************************
+ * This program is free software; you can redistribute it and/or modify it under        *
+ * the terms of the GNU General Public License as published by the Free Software        *
+ * Foundation; either version 3 of the License, or (at your option) any later           *
+ * version.                                                                             *
+ *                                                                                      *
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
+ *                                                                                      *
+ * You should have received a copy of the GNU General Public License along with         *
+ * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
+ ****************************************************************************************/
+
+package com.ichi2.widget;
+
+import java.io.File;
+import java.util.ArrayList;
+
+import com.ichi2.anki.AnkiDroidApp;
+import com.ichi2.anki.BackupManager;
+import com.ichi2.anki.Card;
+import com.ichi2.anki.CardEditor;
+import com.ichi2.anki.Deck;
+import com.ichi2.anki.DeckManager;
+import com.ichi2.anki.DeckStatus;
+import com.ichi2.anki.DeckTask;
+import com.ichi2.anki.R;
+import com.ichi2.anki.StudyOptions;
+import com.ichi2.anki.Utils;
+import com.tomgibara.android.veecheck.util.PrefSettings;
+
+import android.app.PendingIntent;
+import android.app.Service;
+import android.appwidget.AppWidgetManager;
+import android.appwidget.AppWidgetProvider;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.content.SharedPreferences;
+import android.content.res.Resources;
+import android.os.AsyncTask;
+import android.os.IBinder;
+import android.text.Html;
+import android.text.SpannableString;
+import android.text.SpannableStringBuilder;
+import android.text.Spanned;
+import android.text.style.ForegroundColorSpan;
+import android.text.style.UnderlineSpan;
+import android.util.Log;
+import android.view.View;
+import android.widget.RemoteViews;
+
+public class AnkiDroidWidgetBig extends AppWidgetProvider {
+
+    private static BroadcastReceiver mMountReceiver = null;
+    private static boolean remounted = false;
+
+    private static Context sContext;
+
+    private static WidgetContentService contentService = null;
+    private static WidgetContentService.WidgetContentBinder contentServiceBinder;
+    private static Intent tempIntent;
+
+    private static ServiceConnection localServiceConnection = new ServiceConnection() {
+
+    	@Override
+    	public void onServiceConnected(ComponentName className, IBinder binder) {
+		Log.i(AnkiDroidApp.TAG, "binding content service - success");
+    		contentServiceBinder = (WidgetContentService.WidgetContentBinder) binder;
+    		contentService = contentServiceBinder.getService();
+		// check, if card is still the same after reloading the deck. If not, show question instead of answering
+		if (tempIntent.getAction().startsWith(UpdateService.ACTION_ANSWER) && contentService.mCurrentCard != null && PrefSettings.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).getLong("lastWidgetCard", 0) != contentService.mCurrentCard.getId()) {
+			tempIntent.setAction(UpdateService.ACTION_UPDATE);
+			tempIntent.putExtra(UpdateService.EXTRA_VIEW, UpdateService.VIEW_SHOW_QUESTION);
+		}
+       		sContext.startService(tempIntent);
+       		tempIntent = null;
+    	}
+
+		@Override
+		public void onServiceDisconnected(ComponentName arg0) {
+			contentService = null;
+		}
+    };
+
+    @Override
+    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
+        Log.i(AnkiDroidApp.TAG, "BigWidget: onUpdate");
+        WidgetStatus.update(context);
+    }
+
+    @Override
+    public void onEnabled(Context context) {
+        super.onEnabled(context);
+        Log.i(AnkiDroidApp.TAG, "BigWidget: Widget enabled");
+        SharedPreferences preferences = PrefSettings.getSharedPrefs(context);
+        if (!preferences.getBoolean("widgetBigEnabled", false)) {
+            // show info dialog
+            Intent intent;
+            intent = new Intent(context, AnkiDroidWidgetBig.UpdateService.class);
+            intent.setAction(UpdateService.ACTION_SHOW_RESTRICTIONS_DIALOG);
+            context.startService(intent);
+        }
+        preferences.edit().putBoolean("widgetBigEnabled", true).commit();
+        if (contentService != null) {
+    		contentService.mBigCurrentView = UpdateService.VIEW_NOT_SPECIFIED;
+    		contentService.mLoadedDeck = null;
+		PrefSettings.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit().putString("lastWidgetDeck", "").commit();
+    		contentService.setCard(null);
+    		contentService.mBigCurrentMessage = null;
+    		contentService.mBigShowProgressDialog = false;
+    		contentService.mTomorrowDues = null;
+    		contentService.mWaitForAsyncTask = false;
+        }
+    }
+    
+    @Override
+    public void onDisabled(Context context) {
+        super.onDisabled(context);
+        Log.i(AnkiDroidApp.TAG, "BigWidget: Widget disabled");
+        SharedPreferences preferences = PrefSettings.getSharedPrefs(context);
+        preferences.edit().putBoolean("widgetBigEnabled", false).commit();
+    }
+
+
+    public static void setDeck(Deck deck) {
+    	if (contentService != null) {
+    		contentService.mLoadedDeck = deck;
+    	}
+    	updateWidget(UpdateService.VIEW_NOT_SPECIFIED);
+    }
+
+
+    public static void setCard(Card card) {
+    	if (contentService != null && contentService.mLoadedDeck != null) {
+    		contentService.setCard(card);
+    	}
+    }
+
+    public static Card getCard() {
+    	if (contentService != null) {
+    		return contentService.mCurrentCard;
+    	} else {
+    		return null;
+    	}
+    }
+
+
+    public static void updateWidget(int view) {
+    	updateWidget(view, false);
+    }
+    public static void updateWidget(int view, boolean showProgressDialog) {
+    	AnkiDroidApp.getInstance().getApplicationContext().startService(getUpdateIntent(AnkiDroidApp.getInstance().getApplicationContext(), view, showProgressDialog));
+    }
+
+
+    public static Intent getUpdateIntent(Context context, int view, boolean showProgressDialog) {
+        Intent intent = new Intent(context, AnkiDroidWidgetBig.UpdateService.class);            	
+        intent.putExtra(UpdateService.EXTRA_VIEW, view);
+        intent.putExtra(UpdateService.EXTRA_PROGRESSDIALOG, showProgressDialog);
+        return intent.setAction(UpdateService.ACTION_UPDATE);
+    }
+
+
+    public static class UpdateService extends Service {
+    	public static final String ACTION_NOTHING = "org.ichi2.anki.AnkiDroidWidgetBig.NOTHING";
+    	public static final String ACTION_OPENDECK = "org.ichi2.anki.AnkiDroidWidgetBig.OPENDECK";
+        public static final String ACTION_CLOSEDECK = "org.ichi2.anki.AnkiDroidWidgetBig.CLOSEDECK";
+        public static final String ACTION_ANSWER = "org.ichi2.anki.AnkiDroidWidgetBig.ANSWER";
+        public static final String ACTION_OPEN = "org.ichi2.anki.AnkiDroidWidgetBig.OPEN";
+        public static final String ACTION_UPDATE = "org.ichi2.anki.AnkiDroidWidgetBig.UPDATE";
+        public static final String ACTION_BURY_CARD = "org.ichi2.anki.AnkiDroidWidgetBig.BURYCARD";
+        public static final String ACTION_UNDO = "org.ichi2.anki.AnkiDroidWidgetBig.UNDO";
+        public static final String ACTION_CARDEDITOR = "org.ichi2.anki.AnkiDroidWidgetBig.CARDEDITOR";
+        public static final String ACTION_FACTADDER = "org.ichi2.anki.AnkiDroidWidgetBig.FACTADDER";
+        public static final String ACTION_HELP = "org.ichi2.anki.AnkiDroidWidgetBig.HELP";
+        public static final String ACTION_SHOW_RESTRICTIONS_DIALOG = "org.ichi2.anki.AnkiDroidWidgetBig.SHOWRESTRICTIONSDIALOG";
+        public static final String ACTION_LEARN_MORE = "org.ichi2.anki.AnkiDroidWidgetBig.LEARNMORE";
+        public static final String ACTION_REVIEW_EARLY = "org.ichi2.anki.AnkiDroidWidgetBig.REVIEWEARLY";
+        public static final String ACTION_SHOW_TOMORROW_DUES = "org.ichi2.anki.AnkiDroidWidgetBig.TOMORROWDUES";
+
+
+        public static final String EXTRA_DECK_PATH = "deckPath";
+        public static final String EXTRA_EASE = "ease";
+        public static final String EXTRA_VIEW = "view";
+        public static final String EXTRA_PROGRESSDIALOG = "progressDialog";
+
+
+        public static final int VIEW_ACTION_DEFAULT = 0;
+        public static final int VIEW_ACTION_SHOW_PROGRESS_DIALOG = 1;
+        public static final int VIEW_ACTION_HIDE_BUTTONS = 2;
+
+        public static final int VIEW_NOT_SPECIFIED = 0;
+        public static final int VIEW_DECKS = 1;
+        public static final int VIEW_CONGRATS = 2;
+        public static final int VIEW_SHOW_QUESTION = 3;
+        public static final int VIEW_SHOW_ANSWER = 4;
+        public static final int VIEW_NOTHING_DUE = 5;
+        public static final int VIEW_SHOW_HELP = 6;
+        
+
+        private CharSequence getDeckStatusString(Deck deck, Card card) {
+        	return getDeckStatusString(deck.getFailedSoonCount(), deck.getRevCount(), deck.getNewCountToday(), card);
+        }
+    	private CharSequence getDeckStatusString(int failed, int rev, int newCount, Card card) {
+            SpannableStringBuilder sb = new SpannableStringBuilder();
+
+            SpannableString red = new SpannableString(Integer.toString(failed));
+            red.setSpan(new ForegroundColorSpan(getResources().getColor(R.color.widget_big_font_color_red)), 0, red.length(),
+                    Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+            if (card != null && card.getType() == Card.TYPE_FAILED) {
+            	red.setSpan(new UnderlineSpan(), 0, red.length(), 0);
+            }
+
+            SpannableString black = new SpannableString(Integer.toString(rev));
+            black.setSpan(new ForegroundColorSpan(getResources().getColor(R.color.widget_big_font_color)), 0, black.length(),
+                    Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+            if (card != null && card.getType() == Card.TYPE_REV) {
+            	black.setSpan(new UnderlineSpan(), 0, black.length(), 0);
+            }
+
+            SpannableString blue = new SpannableString(Integer.toString(newCount));
+            blue.setSpan(new ForegroundColorSpan(getResources().getColor(R.color.widget_big_font_color_blue)), 0, blue.length(),
+                    Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+            if (card != null && card.getType() == Card.TYPE_NEW) {
+            	blue.setSpan(new UnderlineSpan(), 0, blue.length(), 0);
+            }
+
+            sb.append(red);
+            sb.append(" ");
+            sb.append(black);
+            sb.append(" ");
+            sb.append(blue);
+
+            return sb;
+        }
+
+
+    	private CharSequence getNextTimeString(Card card) {
+            SpannableStringBuilder sb = new SpannableStringBuilder();
+
+            SpannableString hard = new SpannableString(Utils.fmtTimeSpan(card.nextInterval(card, 2) * 86400, Utils.TIME_FORMAT_DEFAULT));
+            hard.setSpan(new ForegroundColorSpan(getResources().getColor(card.isRev() ? R.color.widget_big_font_color : R.color.widget_big_font_color_green)), 0, hard.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+
+            SpannableString easy = new SpannableString(Utils.fmtTimeSpan(card.nextInterval(card, 3) * 86400, Utils.TIME_FORMAT_DEFAULT));
+            easy.setSpan(new ForegroundColorSpan(getResources().getColor(card.isRev() ? R.color.widget_big_font_color_green : R.color.widget_big_font_color)), 0, easy.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+
+            SpannableString veryEasy = new SpannableString(Utils.fmtTimeSpan(card.nextInterval(card, 4) * 86400, Utils.TIME_FORMAT_DEFAULT));
+            veryEasy.setSpan(new ForegroundColorSpan(getResources().getColor(R.color.widget_big_font_color)), 0, veryEasy.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+
+            sb.append(hard);
+            sb.append(" \u2027 ");
+            sb.append(easy);
+            sb.append(" \u2027 ");
+            sb.append(veryEasy);
+
+            return sb;
+        }
+
+
+        private DeckTask.TaskListener mOpenDeckHandler = new DeckTask.TaskListener() {
+            @Override
+            public void onPreExecute() {
+            	showProgressDialog();
+            }
+            @Override
+            public void onProgressUpdate(DeckTask.TaskData... values) {
+            	Resources res = getResources();
+            	String message = values[0].getString();
+            	if (message == null) {
+    				switch (values[0].getInt()) {
+            		case BackupManager.RETURN_BACKUP_CREATED:
+                		contentService.mBigCurrentMessage = res.getString(R.string.backup_deck_success);
+                		break;
+            		case BackupManager.RETURN_TODAY_ALREADY_BACKUP_DONE:
+            		case BackupManager.RETURN_DECK_NOT_CHANGED:
+            			contentService.mBigCurrentMessage = res.getString(R.string.loading_deck);
+            			break;
+            		case BackupManager.RETURN_ERROR:
+            			contentService.mBigCurrentMessage = "backup error";
+            			break;
+            		case BackupManager.RETURN_NOT_ENOUGH_SPACE:
+            			contentService.mBigCurrentMessage = "not enough space";
+            			break;
+            		case BackupManager.RETURN_LOW_SYSTEM_SPACE:
+            			contentService.mBigCurrentMessage = "low system space";
+            			break;
+            		}
+            	} else {
+            		contentService.mBigCurrentMessage = message;
+            	}
+            	updateViews();
+            }
+
+            @Override
+            public void onPostExecute(DeckTask.TaskData result) {
+            	if (result.getInt() == DeckTask.DECK_LOADED) {
+                	contentService.mLoadedDeck = result.getDeck();
+                	if (contentService.mLoadedDeck != null) {
+						PrefSettings.getSharedPrefs(UpdateService.this.getBaseContext()).edit().putString("lastWidgetDeck", contentService.mLoadedDeck.getDeckPath()).commit();
+                    	contentService.setCard();
+                	}
+                	contentService.mBigShowProgressDialog = false;
+                	contentService.mBigCurrentMessage = null;
+                	updateViews(VIEW_SHOW_QUESTION);            		
+            	} else {
+            		handleError(result.getString());
+            	}
+            }
+        };
+
+
+        private DeckTask.TaskListener mAnswerCardHandler = new DeckTask.TaskListener() {
+            @Override
+            public void onPreExecute() {
+            	showProgressDialog();
+            }
+            @Override
+            public void onProgressUpdate(DeckTask.TaskData... values) {
+            	contentService.setCard(values[0].getCard());
+                if (values[0].isPreviousCardLeech()) {
+                    if (values[0].isPreviousCardSuspended()) {
+                    	contentService.mBigCurrentMessage = getResources().getString(R.string.leech_suspend_notification);
+                    } else {
+                    	contentService.mBigCurrentMessage = getResources().getString(R.string.leech_notification);
+                    }
+                } else {
+                	contentService.mBigCurrentMessage = null;
+                }
+            	contentService.mBigShowProgressDialog = false;
+            	updateViews(VIEW_SHOW_QUESTION);
+            	WidgetStatus.update(UpdateService.this, WidgetStatus.getDeckStatus(contentService.mLoadedDeck), false);
+            }
+            @Override
+            public void onPostExecute(DeckTask.TaskData result) {
+            	if (!result.getBoolean()) {
+            		handleError(contentService.mLoadedDeck.getDeckPath());
+            	}
+            }
+        };
+
+
+        private DeckTask.TaskListener mUpdateCardHandler = new DeckTask.TaskListener() {
+            @Override
+            public void onPreExecute() {
+            	showProgressDialog();
+            }
+            @Override
+            public void onProgressUpdate(DeckTask.TaskData... values) {
+            	contentService.setCard(values[0].getCard());
+            	contentService.mBigShowProgressDialog = false;
+            	contentService.mBigCurrentMessage = null;
+            	updateViews(VIEW_SHOW_QUESTION);
+            }
+            @Override
+            public void onPostExecute(DeckTask.TaskData result) {
+            	if (!result.getBoolean()) {
+            		handleError(contentService.mLoadedDeck.getDeckPath());
+            		return;
+            	}
+                String str = result.getString();
+                if (str != null) {
+                    if (str.equals(Deck.UNDO_TYPE_SUSPEND_CARD)) {
+                    	contentService.mBigCurrentMessage = getResources().getString(R.string.card_unsuspended);
+                    } else if (str.equals("redo suspend")) {
+                    	contentService.mBigCurrentMessage = getResources().getString(R.string.card_suspended);
+                    }
+                }
+                updateViews();
+                WidgetStatus.update(UpdateService.this, WidgetStatus.getDeckStatus(contentService.mLoadedDeck), false);
+            }
+        };
+
+
+        private DeckTask.TaskListener mCloseDeckHandler = new DeckTask.TaskListener() {
+            @Override
+            public void onPreExecute() {
+            	showProgressDialog();
+            }
+            @Override
+            public void onProgressUpdate(DeckTask.TaskData... values) {
+            }
+            @Override
+            public void onPostExecute(DeckTask.TaskData result) {
+            	contentService.mLoadedDeck = null;
+				PrefSettings.getSharedPrefs(UpdateService.this.getBaseContext()).edit().putString("lastWidgetDeck", "").commit();
+            	contentService.setCard(null);
+            	contentService.mBigShowProgressDialog = false;
+            	contentService.mBigCurrentMessage = null;
+            	updateViews(VIEW_DECKS);
+            }
+        };
+
+
+        @Override
+        public void onStart(Intent intent, int startId) {
+            Log.i(AnkiDroidApp.TAG, "BigWidget: OnStart");
+
+            if (intent == null) {
+		// do nothing
+            } else if (contentService == null) {
+            	Log.i(AnkiDroidApp.TAG, "binding content service");
+		updateViews();
+            	tempIntent = intent;
+            	sContext = this;
+                Intent contentIntent = new Intent(this,	WidgetContentService.class);
+                this.bindService(contentIntent, localServiceConnection, Context.BIND_AUTO_CREATE);
+            } else if (intent.getAction() != null) {
+            	String action = intent.getAction();
+            	if (ACTION_NOTHING.equals(action)) {
+            		// do nothing
+            	} else if (ACTION_UPDATE.equals(action)) {
+            		if (!contentService.mWaitForAsyncTask) {
+            			if (!intent.getBooleanExtra(EXTRA_PROGRESSDIALOG, false)) {
+                			contentService.mBigShowProgressDialog = false;
+                			updateViews(intent.getIntExtra(EXTRA_VIEW, VIEW_NOT_SPECIFIED));            				
+            			} else if (!contentService.mBigShowProgressDialog) {
+            				showProgressDialog();
+            			}
+            		}
+            	} else if (ACTION_OPENDECK.equals(action)) {
+            		showProgressDialog();
+            		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_DECK, mOpenDeckHandler, new DeckTask.TaskData(DeckManager.REQUESTING_ACTIVITY_BIGWIDGET, intent.getStringExtra(EXTRA_DECK_PATH)));
+                } else if (ACTION_CLOSEDECK.equals(action)) {
+                	if (contentService.mLoadedDeck != null) {
+                		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CLOSE_DECK, mCloseDeckHandler, new DeckTask.TaskData(contentService.mLoadedDeck.getDeckPath()));                		
+                	} else {
+                		updateViews(VIEW_DECKS);
+                	}
+                } else if (ACTION_UNDO.equals(action)) {
+                	if (contentService.mLoadedDeck != null) {
+                    	if (contentService.mLoadedDeck.undoAvailable()) {
+                    		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_UNDO, mUpdateCardHandler, new DeckTask.TaskData(0, contentService.mLoadedDeck, contentService.mCurrentCard != null ? contentService.mCurrentCard.getId() : 0, true));                		
+                    	}
+                	} else {
+                		updateViews(VIEW_DECKS);
+                	}
+                } else if (ACTION_BURY_CARD.equals(action)) {
+                	if (contentService.mLoadedDeck != null) {
+                		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_BURY_CARD, mUpdateCardHandler, new DeckTask.TaskData(0, contentService.mLoadedDeck, contentService.mCurrentCard));                		
+                	} else {
+                		updateViews(VIEW_DECKS);
+                	}
+                } else if (action.startsWith(ACTION_ANSWER)) {
+                	int ease = intent.getIntExtra(EXTRA_EASE, 0);
+                	if (ease == 0) {
+                		updateViews(VIEW_SHOW_ANSWER);
+                	} else {
+                    	if (contentService.mLoadedDeck != null) {
+                    		if (contentService.mCurrentCard.thinkingTime() > 12) {
+                    			// assume, user was not learning
+                    			contentService.mCurrentCard.setTimerStart(Utils.now() - 6);
+                    		}
+                    		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_ANSWER_CARD, mAnswerCardHandler, new DeckTask.TaskData(ease, contentService.mLoadedDeck, contentService.mCurrentCard));
+                    	} else {
+                    		updateViews(VIEW_DECKS);
+                    	}
+                	}
+                } else if (ACTION_SHOW_RESTRICTIONS_DIALOG.equals(action)) {
+                	Intent dialogIntent = new Intent(this, WidgetDialog.class);
+                    dialogIntent.setAction(WidgetDialog.ACTION_SHOW_RESTRICTIONS_DIALOG);
+                    dialogIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+                    this.startActivity(dialogIntent);
+                } else if (ACTION_OPEN.equals(action)) {
+                	String deckpath = intent.getStringExtra(EXTRA_DECK_PATH);
+                	Intent newIntent = StudyOptions.getLoadDeckIntent(this, deckpath);
+                	if (deckpath != null) {
+                    	DeckManager.getDeck(deckpath, true, DeckManager.REQUESTING_ACTIVITY_STUDYOPTIONS);                			
+                		if (contentService.mBigCurrentView != VIEW_NOTHING_DUE) {
+                        	newIntent.putExtra(StudyOptions.EXTRA_START, StudyOptions.EXTRA_START_REVIEWER);
+                        	startActivity(newIntent);
+                    		showProgressDialog();
+                		} else {
+                        	startActivity(newIntent);                			
+                		}
+                	} else {
+                		newIntent.putExtra(StudyOptions.EXTRA_START, StudyOptions.EXTRA_START_DECKPICKER);                		
+                    	startActivity(newIntent);
+                	}
+                } else if (ACTION_CARDEDITOR.equals(action)) {
+                    Intent editIntent = new Intent(this, CardEditor.class);
+                    editIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+                    editIntent.putExtra(CardEditor.EXTRA_CALLER, CardEditor.CALLER_BIGWIDGET_EDIT);
+                    editIntent.putExtra(CardEditor.EXTRA_DECKPATH, contentService.mLoadedDeck.getDeckPath());
+                    this.startActivity(editIntent);
+                } else if (ACTION_FACTADDER.equals(action)) {
+                    Intent editIntent = new Intent(this, CardEditor.class);
+                    editIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+                    editIntent.putExtra(CardEditor.EXTRA_CALLER, CardEditor.CALLER_BIGWIDGET_ADD);
+                    editIntent.putExtra(CardEditor.EXTRA_DECKPATH, contentService.mLoadedDeck.getDeckPath());
+                    this.startActivity(editIntent);
+                } else if (ACTION_HELP.equals(action)) {
+                	if (contentService.mBigShowProgressDialog) {
+                		contentService.mBigShowProgressDialog = false;
+                    	updateViews(VIEW_SHOW_HELP);
+                    	contentService.mBigShowProgressDialog = true;
+                	} else {
+                    	updateViews(VIEW_SHOW_HELP);                		
+                	}
+                } else if (ACTION_LEARN_MORE.equals(action)) {
+                	if (contentService.mLoadedDeck != null) {
+                		contentService.mLoadedDeck.setupLearnMoreScheduler();
+                		contentService.mLoadedDeck.reset();
+	                    contentService.setCard();
+	                	contentService.mBigShowProgressDialog = false;
+	                	contentService.mBigCurrentMessage = null;
+        	        	updateViews(VIEW_SHOW_QUESTION); 
+                	} else {
+                		updateViews(VIEW_DECKS);
+                	}
+                } else if (ACTION_REVIEW_EARLY.equals(action)) {
+                	if (contentService.mLoadedDeck != null) {
+                		contentService.mLoadedDeck.setupReviewEarlyScheduler();
+                		contentService.mLoadedDeck.reset();
+	                    contentService.setCard();
+	                	contentService.mBigShowProgressDialog = false;
+	                	contentService.mBigCurrentMessage = null;
+        	        	updateViews(VIEW_SHOW_QUESTION); 
+                	} else {
+                		updateViews(VIEW_DECKS);
+                	}			
+                } else if (ACTION_SHOW_TOMORROW_DUES.equals(action)) {
+                	if (contentService.mTomorrowDues == null) {
+                		showProgressDialog();
+                		contentService.mWaitForAsyncTask = true;
+                		AsyncTask<String, Void, DeckStatus[]> getTomorrowDuesAsyncTask = new GetTomorrowDueAsyncTask();
+                		getTomorrowDuesAsyncTask.execute(PrefSettings.getSharedPrefs(AnkiDroidWidgetBig.UpdateService.this).getString("deckPath", AnkiDroidApp.getStorageDirectory() + "/AnkiDroid"));
+    				} else {
+        	        	updateViews(VIEW_CONGRATS);
+    				}
+                }
+            }
+        }
+
+
+        private void handleError(String deckPath) {
+        	Intent newIntent = StudyOptions.getLoadDeckIntent(AnkiDroidWidgetBig.UpdateService.this, deckPath);
+        	newIntent.putExtra(StudyOptions.EXTRA_START, StudyOptions.EXTRA_DB_ERROR);
+        	startActivity(newIntent);
+    		contentService.mBigCurrentMessage = null;
+    		DeckManager.closeDeck(deckPath);    			
+    		contentService.mLoadedDeck = null;
+            contentService.setCard(null);
+    		contentService.mBigShowProgressDialog = false;
+    		updateViews(VIEW_DECKS);
+        }
+
+
+        private void showProgressDialog() {
+        	Log.i(AnkiDroidApp.TAG, "BigWidget: show progress dialog");
+        	contentService.mBigShowProgressDialog = true;
+        	updateViews();
+        }
+        private void updateViews(int view) {
+        	if (view != VIEW_NOT_SPECIFIED) {
+        		contentService.mBigCurrentView = view;
+        	}
+        	updateViews();
+        }
+    	private void updateViews() {
+            RemoteViews updateViews = buildUpdate(this);
+
+            ComponentName thisWidget = new ComponentName(this, AnkiDroidWidgetBig.class);
+            AppWidgetManager manager = AppWidgetManager.getInstance(this);
+            manager.updateAppWidget(thisWidget, updateViews);
+        }
+
+    	private synchronized RemoteViews buildUpdate(Context context) {
+            Resources res = getResources();
+            RemoteViews updateViews = new RemoteViews(context.getPackageName(), R.layout.widget_big);
+
+            if (contentService == null) {
+            	updateViews.setViewVisibility(R.id.widget_big_progressbar, View.VISIBLE);
+            	updateViews.setViewVisibility(R.id.widget_big_noclicks, View.VISIBLE);
+            	return updateViews;
+            }
+
+            if (contentService.mBigCurrentView == VIEW_NOT_SPECIFIED) {
+            	contentService.mBigCurrentView = VIEW_DECKS;
+            }
+
+            Log.i(AnkiDroidApp.TAG, "BigWidget: buildUpdate (" + contentService.mBigCurrentView + ")");
+
+            if (contentService.mBigCurrentView == VIEW_DECKS || contentService.mBigCurrentView == VIEW_SHOW_HELP || contentService.mBigCurrentView == VIEW_CONGRATS) {
+            } else if (contentService.mLoadedDeck == null) {
+            	contentService.mBigCurrentView = VIEW_DECKS;
+            } else if (contentService.mCurrentCard == null) {
+            	contentService.mBigCurrentView = VIEW_NOTHING_DUE;
+            }
+
+            if (contentService.mBigCurrentMessage != null) {
+            	updateViews.setTextViewText(R.id.widget_big_message, contentService.mBigCurrentMessage);				
+            } else {
+            	updateViews.setTextViewText(R.id.widget_big_message, "");				
+            }
+
+            if (contentService.mBigShowProgressDialog) {
+            	updateViews.setViewVisibility(R.id.widget_big_progressbar, View.VISIBLE);
+            	updateViews.setViewVisibility(R.id.widget_big_noclicks, View.VISIBLE);
+            	return updateViews;
+            } else {
+            	updateViews.setViewVisibility(R.id.widget_big_progressbar, View.INVISIBLE);            	
+            	updateViews.setViewVisibility(R.id.widget_big_noclicks, View.INVISIBLE);
+            }
+
+            switch (contentService.mBigCurrentView) {
+            case VIEW_CONGRATS:
+            case VIEW_DECKS:
+            	updateViews.setTextViewText(R.id.widget_big_deckname, "");
+            	updateCounts(updateViews, contentService.mBigCurrentView);
+
+            	updateViews.setOnClickPendingIntent(R.id.widget_big_deckfield, contentService.mBigCurrentView == VIEW_DECKS ? getTomorrowDuePendingIntent(context) : getUpdatePendingIntent(context, VIEW_DECKS));
+            	
+            	updateViews.setOnClickPendingIntent(R.id.widget_big_openclose, getShowDeckSelectionPendingIntent(context));
+            	updateViews.setViewVisibility(R.id.widget_big_open, View.VISIBLE);
+            	updateViews.setViewVisibility(R.id.widget_big_close, View.INVISIBLE);
+
+				updateViews.setViewVisibility(R.id.widget_big_empty, View.VISIBLE);
+				updateViews.setViewVisibility(R.id.widget_big_help, View.VISIBLE);
+       			updateViews.setViewVisibility(R.id.widget_big_flipcard, View.INVISIBLE);
+       			updateViews.setOnClickPendingIntent(R.id.widget_big_empty, getHelpPendingIntent(this));
+
+       			updateViews.setViewVisibility(R.id.widget_big_cardbackgroundstar, View.VISIBLE);
+       			updateViews.setTextViewText(R.id.widget_big_cardcontent, "");
+       			updateViews.setViewVisibility(R.id.widget_big_card_areas, View.INVISIBLE);
+       			emptyCardAreaTexts(updateViews);
+       			removeAreaListeners(this, true);
+
+       			updateViews.setViewVisibility(R.id.widget_big_add, View.INVISIBLE);
+       			updateViews.setViewVisibility(R.id.widget_big_star, View.VISIBLE);
+       			updateViews.setOnClickPendingIntent(R.id.widget_big_bottom_right, getOpenPendingIntent(this, null));
+       			break;
+
+            case VIEW_SHOW_HELP:
+            	updateViews.setOnClickPendingIntent(R.id.widget_big_empty, getUpdatePendingIntent(this, VIEW_DECKS));
+
+            	updateViews.setViewVisibility(R.id.widget_big_cardbackgroundstar, View.INVISIBLE);
+            	updateViews.setViewVisibility(R.id.widget_big_nothing_due, View.INVISIBLE);
+            	updateViews.setViewVisibility(R.id.widget_big_deckfield, View.INVISIBLE);
+
+            	updateViews.setViewVisibility(R.id.widget_big_card_areas, View.VISIBLE);
+            	String[] values = res.getStringArray(R.array.gestures_labels);
+            	updateViews.setTextViewText(R.id.widget_big_topleft, res.getString(R.string.open_in_reviewer));
+            	updateViews.setTextViewText(R.id.widget_big_middleleft, values[12]);
+				updateViews.setTextViewText(R.id.widget_big_bottomleft, values[1]);
+				updateViews.setTextViewText(R.id.widget_big_topright, values[9]);
+				updateViews.setTextViewText(R.id.widget_big_middleright, values[7]);
+				updateViews.setTextViewText(R.id.widget_big_bottomright, values[5]);
+				break;
+
+            case VIEW_SHOW_QUESTION:
+        		updateViews.setTextViewText(R.id.widget_big_deckname, contentService.mLoadedDeck.getDeckName());
+        		updateCounts(updateViews, contentService.mBigCurrentView);
+
+        		updateViews.setOnClickPendingIntent(R.id.widget_big_openclose, getCloseDeckPendingIntent(context));
+        		updateViews.setViewVisibility(R.id.widget_big_open, View.INVISIBLE);
+        		updateViews.setViewVisibility(R.id.widget_big_close, View.VISIBLE);
+
+        		updateViews.setViewVisibility(R.id.widget_big_empty, View.VISIBLE);
+        		updateViews.setViewVisibility(R.id.widget_big_help, View.INVISIBLE);
+        		updateViews.setViewVisibility(R.id.widget_big_flipcard, View.VISIBLE);
+        		updateViews.setOnClickPendingIntent(R.id.widget_big_empty, getAnswerPendingIntent(context, 0));
+
+        		updateViews.setViewVisibility(R.id.widget_big_card_areas, View.VISIBLE);
+        		updateViews.setOnClickPendingIntent(R.id.widget_big_topleft, getOpenPendingIntent(this, contentService.mLoadedDeck.getDeckPath()));
+        		updateViews.setOnClickPendingIntent(R.id.widget_big_middleleft, getBuryCardPendingIntent(this));
+        		updateViews.setOnClickPendingIntent(R.id.widget_big_bottomleft, getAnswerPendingIntent(this, 0));
+        		updateViews.setOnClickPendingIntent(R.id.widget_big_topright, getCardEditorPendingIntent(this));
+        		updateViews.setOnClickPendingIntent(R.id.widget_big_middleright, getUndoPendingIntent(this));
+        		updateViews.setOnClickPendingIntent(R.id.widget_big_bottomright, getAnswerPendingIntent(this, 0));
+        		emptyCardAreaTexts(updateViews);
+
+        		updateViews.setViewVisibility(R.id.widget_big_nothing_due, View.INVISIBLE);
+        		updateViews.setViewVisibility(R.id.widget_big_deckfield, View.INVISIBLE);
+        		updateViews.setViewVisibility(R.id.widget_big_cardbackgroundstar, View.INVISIBLE);
+
+        		updateViews.setTextViewText(R.id.widget_big_cardcontent,  Html.fromHtml(contentService.mCurrentCard.getQuestion())); 
+
+        		updateViews.setViewVisibility(R.id.widget_big_add, View.VISIBLE);
+       			updateViews.setViewVisibility(R.id.widget_big_star, View.INVISIBLE);
+        		updateViews.setOnClickPendingIntent(R.id.widget_big_bottom_right, getFactAdderPendingIntent(context));
+        		break;
+
+            case VIEW_SHOW_ANSWER:
+            	updateViews.setViewVisibility(R.id.widget_big_empty, View.INVISIBLE);
+            	updateViews.setOnClickPendingIntent(R.id.widget_big_ease1, getAnswerPendingIntent(context, 1));
+				updateViews.setOnClickPendingIntent(R.id.widget_big_ease2, getAnswerPendingIntent(context, 2));
+				updateViews.setOnClickPendingIntent(R.id.widget_big_ease3, getAnswerPendingIntent(context, 3));
+				updateViews.setOnClickPendingIntent(R.id.widget_big_ease4, getAnswerPendingIntent(context, 4));            		
+
+				updateViews.setTextViewText(R.id.widget_big_message, getNextTimeString(contentService.mCurrentCard));
+
+				updateViews.setOnClickPendingIntent(R.id.widget_big_bottomleft, getAnswerPendingIntent(this, 1));
+
+				if (contentService.mCurrentCard.isRev()) {
+					updateViews.setViewVisibility(R.id.widget_big_ease2_normal, View.INVISIBLE);
+					updateViews.setViewVisibility(R.id.widget_big_ease2_rec, View.VISIBLE);
+					updateViews.setViewVisibility(R.id.widget_big_ease3_normal, View.INVISIBLE);
+					updateViews.setViewVisibility(R.id.widget_big_ease3_rec, View.VISIBLE);
+					updateViews.setOnClickPendingIntent(R.id.widget_big_bottomright, getAnswerPendingIntent(this, 3));
+				} else {
+					updateViews.setViewVisibility(R.id.widget_big_ease2_normal, View.VISIBLE);
+					updateViews.setViewVisibility(R.id.widget_big_ease2_rec, View.INVISIBLE);
+					updateViews.setViewVisibility(R.id.widget_big_ease3_normal, View.VISIBLE);
+					updateViews.setViewVisibility(R.id.widget_big_ease3_rec, View.INVISIBLE);            			
+					updateViews.setOnClickPendingIntent(R.id.widget_big_bottomright, getAnswerPendingIntent(this, 2));
+				}
+
+				updateViews.setTextViewText(R.id.widget_big_cardcontent,  Html.fromHtml(contentService.mCurrentCard.getQuestion() 
+            			+ "<br>─────<br>" 
+            			+ contentService.mCurrentCard.getAnswer()));
+				break;
+
+            case VIEW_NOTHING_DUE:
+        		updateViews.setTextViewText(R.id.widget_big_deckname, contentService.mLoadedDeck.getDeckName());
+            	updateCounts(updateViews, contentService.mBigCurrentView);
+
+            	updateViews.setOnClickPendingIntent(R.id.widget_big_openclose, getCloseDeckPendingIntent(context));
+            	updateViews.setViewVisibility(R.id.widget_big_open, View.INVISIBLE);
+            	updateViews.setViewVisibility(R.id.widget_big_close, View.VISIBLE);
+
+            	updateViews.setViewVisibility(R.id.widget_big_empty, View.VISIBLE);
+            	updateViews.setViewVisibility(R.id.widget_big_flipcard, View.INVISIBLE);
+            	updateViews.setViewVisibility(R.id.widget_big_help, View.INVISIBLE);
+            	getHelpPendingIntent(this).cancel();
+            	getUpdatePendingIntent(this, VIEW_DECKS).cancel();
+
+            	updateViews.setViewVisibility(R.id.widget_big_card_areas, View.VISIBLE);
+            	updateViews.setOnClickPendingIntent(R.id.widget_big_topleft, getOpenPendingIntent(this, contentService.mLoadedDeck.getDeckPath()));
+            	removeAreaListeners(this, false);
+            	updateViews.setOnClickPendingIntent(R.id.widget_big_middleright, getUndoPendingIntent(this));
+            	emptyCardAreaTexts(updateViews);
+
+       			updateViews.setViewVisibility(R.id.widget_big_cardbackgroundstar, View.VISIBLE);
+       			updateViews.setTextViewText(R.id.widget_big_cardcontent, "");
+       			updateViews.setViewVisibility(R.id.widget_big_nothing_due, View.VISIBLE);
+       			updateViews.setViewVisibility(R.id.widget_big_deckfield, View.INVISIBLE);
+
+       			int failedCards = contentService.mLoadedDeck.getFailedDelayedCount();
+       			int revCards = contentService.mLoadedDeck.getNextDueCards(1);
+       			int newCards = contentService.mLoadedDeck.getNextNewCards();
+       			int eta = contentService.mLoadedDeck.getETA(failedCards, revCards, newCards, true);
+       			updateViews.setTextViewText(R.id.widget_big_congrats, StudyOptions.getCongratsMessage(this, failedCards, revCards, newCards, eta));
+
+       			updateViews.setOnClickPendingIntent(R.id.widget_big_review_early, getReviewEarlyPendingIntent(context));
+       			updateViews.setOnClickPendingIntent(R.id.widget_big_learn_more, getLearnMorePendingIntent(context));
+
+       			updateViews.setViewVisibility(R.id.widget_big_add, View.VISIBLE);
+       			updateViews.setViewVisibility(R.id.widget_big_star, View.INVISIBLE);
+       			updateViews.setOnClickPendingIntent(R.id.widget_big_bottom_right, getFactAdderPendingIntent(context));
+       			break;
+            }
+            return updateViews;
+
+//        		WebView webView = new WebView(this);
+//        		webView.setDrawingCacheEnabled(true);
+//        		webView.layout(0, 0, 500, 500); 
+//        		webView.loadDataWithBaseURL("", "asdf", "text/html", "utf-8", null);
+//        		webView.buildDrawingCache(true);
+//        		Bitmap b = Bitmap.createBitmap(webView.getDrawingCache());
+//        		webView.setDrawingCacheEnabled(false); // clear drawing cache
+//
+//        		FileOutputStream out;
+//				try {
+//					out = new FileOutputStream("/emmc/test.png");
+//	        	       b.compress(Bitmap.CompressFormat.PNG, 90, out);
+//	        	       File f = new File("/emmc/test.png");
+//	        	       Uri uri = Uri.fromFile(f);
+//	        	       updateViews.setImageViewUri(R.id.widget_big_cardcontent, uri);
+//				} catch (FileNotFoundException e) {
+//					// TODO Auto-generated catch block
+//					e.printStackTrace();
+//				}
+        }
+
+
+
+
+    	private void updateCounts(RemoteViews updateViews, int view) {
+    		DeckStatus[] decks = WidgetStatus.fetch(this);
+        	int eta = 0;
+        	int reps = 0;
+        	int due = 0;
+
+        	// determine total progress
+        	for (DeckStatus d : decks) {
+        		eta += d.mEta;
+        		reps += d.mTime;
+        		due += d.mFailedCards + d.mNewCards + d.mDueCards;
+        	}
+        	int totalreps = reps + due;
+        	int progressTotal = 0;
+        	if (totalreps != 0) {
+        		progressTotal = (int) Math.round((100.0d * reps) / totalreps);
+        	}
+    		updateViews.setProgressBar(R.id.widget_big_progress_total, 100, progressTotal, false);
+    		if (eta == 0) {
+    			updateViews.setViewVisibility(R.id.widget_big_eta, View.INVISIBLE);
+    		} else {
+    			updateViews.setViewVisibility(R.id.widget_big_eta, View.VISIBLE);
+        		updateViews.setTextViewText(R.id.widget_big_eta, eta > 99 ? "\u2027\u2027\u2027" : Integer.toString(eta));
+    		}
+
+    		switch (view) {
+    		case VIEW_SHOW_QUESTION:
+    		case VIEW_NOTHING_DUE:
+    			updateViews.setTextViewText(R.id.widget_big_counts, getDeckStatusString(contentService.mLoadedDeck, contentService.mCurrentCard));
+    			double sessionProgress = contentService.mLoadedDeck.getSessionProgress(true);
+    			if (sessionProgress == -1) {
+	        		updateViews.setViewVisibility(R.id.widget_big_progress_frame_deck, View.INVISIBLE);
+    			} else {
+	        		updateViews.setProgressBar(R.id.widget_big_progress_deck, 100, (int) (sessionProgress * 100), false);
+	        		updateViews.setViewVisibility(R.id.widget_big_progress_frame_deck, View.VISIBLE);
+    			}
+				contentService.mTomorrowDues = null;
+        		break;
+
+    		case VIEW_CONGRATS:
+    			if (contentService.mTomorrowDues != null && contentService.mTomorrowDues.length > 0) {
+            		updateViews.setViewVisibility(R.id.widget_big_totalcongrats, View.VISIBLE);
+					setDeckCounts(updateViews, contentService.mTomorrowDues);
+    			}
+    			break;
+
+    		case VIEW_DECKS:
+        		updateViews.setTextViewText(R.id.widget_big_counts, "");
+        		updateViews.setViewVisibility(R.id.widget_big_progress_frame_deck, View.INVISIBLE);
+
+				updateViews.setViewVisibility(R.id.widget_big_deckfield, View.VISIBLE);
+				updateViews.setViewVisibility(R.id.widget_big_nothing_due, View.INVISIBLE);
+
+				setDeckCounts(updateViews, decks);
+
+				updateViews.setViewVisibility(R.id.widget_big_totalcongrats, View.GONE);
+    			updateViews.setViewVisibility(R.id.widget_big_decketa, View.VISIBLE);
+	    		updateViews.setTextViewText(R.id.widget_big_decketa, "─────\n" + getResources().getQuantityString(R.plurals.widget_big_eta, eta, eta));
+        		break;
+    		}
+    	}
+
+	private void emptyCardAreaTexts(RemoteViews updateViews) {
+		updateViews.setTextViewText(R.id.widget_big_topleft, "");
+		updateViews.setTextViewText(R.id.widget_big_middleleft, "");
+		updateViews.setTextViewText(R.id.widget_big_bottomleft, "");
+		updateViews.setTextViewText(R.id.widget_big_topright, "");
+		updateViews.setTextViewText(R.id.widget_big_middleright, "");
+		updateViews.setTextViewText(R.id.widget_big_bottomright, "");
+	}
+
+
+	private void removeAreaListeners(Context context, boolean all) {
+		getBuryCardPendingIntent(context).cancel();
+		getAnswerPendingIntent(context, 0).cancel();
+		getAnswerPendingIntent(context, 1).cancel();
+		getAnswerPendingIntent(context, 2).cancel();
+		getAnswerPendingIntent(context, 3).cancel();
+		getCardEditorPendingIntent(context).cancel();
+		if (all) {
+			getOpenPendingIntent(context, null).cancel();
+			getUndoPendingIntent(context).cancel();
+		}
+	}
+
+
+	private void setDeckCounts(RemoteViews updateViews, DeckStatus[] decks) {
+    	StringBuilder namesSb = new StringBuilder();
+       	SpannableStringBuilder duesSb = new SpannableStringBuilder();
+       	int eta = 0;
+       	for (DeckStatus d : decks) {
+       		namesSb.append(d.mDeckName).append("  \n");
+       		duesSb.append(getDeckStatusString(d.mFailedCards, d.mDueCards, d.mNewCards, null)).append("\n");
+       		eta += d.mEta;
+       	}
+       	int pos = namesSb.length() - 1;
+       	if (pos != -1) {
+       		namesSb.delete(pos, pos + 1);
+       	}
+       	pos = duesSb.length() - 1;
+       	if (pos != -1) {
+       		duesSb.delete(pos, pos + 1);
+       	}
+       	if (namesSb.length() == 0 || duesSb.length() == 0) {
+       		updateViews.setViewVisibility(R.id.widget_big_deckfield, View.INVISIBLE);
+//       		if (!sUpdateStarted) {
+//       			sUpdateStarted = true;
+//       			WidgetStatus.update(sContext);
+//       		}
+       	} else {
+//       		sUpdateStarted = false;
+       	}
+   		updateViews.setTextViewText(R.id.widget_big_decknames, namesSb);
+   		updateViews.setTextViewText(R.id.widget_big_deckdues, duesSb);
+		updateViews.setTextViewText(R.id.widget_big_decketa, "─────\n" + getResources().getQuantityString(R.plurals.widget_big_eta, eta, eta));
+	}
+
+
+        private PendingIntent getAnswerPendingIntent(Context context, int ease) {
+            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
+            ankiDroidIntent.setAction(ACTION_ANSWER + Integer.toString(ease));
+            ankiDroidIntent.putExtra(EXTRA_EASE, ease);
+            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
+        }
+
+        private PendingIntent getShowDeckSelectionPendingIntent(Context context) {
+            Intent ankiDroidIntent = new Intent(context, WidgetDialog.class);
+            ankiDroidIntent.setAction(WidgetDialog.ACTION_SHOW_DECK_SELECTION_DIALOG);
+            ankiDroidIntent.setFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
+            return PendingIntent.getActivity(context, 0, ankiDroidIntent, 0);
+        }
+
+        private PendingIntent getCloseDeckPendingIntent(Context context) {
+            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
+            ankiDroidIntent.setAction(ACTION_CLOSEDECK);
+            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
+        }
+
+        private PendingIntent getUndoPendingIntent(Context context) {
+            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
+            ankiDroidIntent.setAction(ACTION_UNDO);
+            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
+        }
+
+        private PendingIntent getBuryCardPendingIntent(Context context) {
+            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
+            ankiDroidIntent.setAction(ACTION_BURY_CARD);
+            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
+        }
+
+        private PendingIntent getOpenPendingIntent(Context context, String deckPath) {
+            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
+            ankiDroidIntent.setAction(ACTION_OPEN);
+            ankiDroidIntent.putExtra(EXTRA_DECK_PATH, deckPath);
+            return PendingIntent.getService(context, 0, ankiDroidIntent, PendingIntent.FLAG_CANCEL_CURRENT);
+        }
+
+        private PendingIntent getLearnMorePendingIntent(Context context) {
+            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
+            ankiDroidIntent.setAction(ACTION_LEARN_MORE);
+            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
+        }
+
+        private PendingIntent getReviewEarlyPendingIntent(Context context) {
+            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
+            ankiDroidIntent.setAction(ACTION_REVIEW_EARLY);
+            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
+        }
+
+        private PendingIntent getCardEditorPendingIntent(Context context) {
+            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
+            ankiDroidIntent.setAction(ACTION_CARDEDITOR);
+            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
+        }
+
+        private PendingIntent getFactAdderPendingIntent(Context context) {
+            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
+            ankiDroidIntent.setAction(ACTION_FACTADDER);
+            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
+        }
+
+        private PendingIntent getHelpPendingIntent(Context context) {
+            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
+            ankiDroidIntent.setAction(ACTION_HELP);
+            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
+        }
+
+        private PendingIntent getTomorrowDuePendingIntent(Context context) {
+            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
+            ankiDroidIntent.setAction(ACTION_SHOW_TOMORROW_DUES);
+            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
+        }
+
+        private PendingIntent getUpdatePendingIntent(Context context, int view) {
+            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
+            ankiDroidIntent.setAction(ACTION_UPDATE);
+            ankiDroidIntent.putExtra(EXTRA_VIEW, view);
+            return PendingIntent.getService(context, 0, ankiDroidIntent, PendingIntent.FLAG_CANCEL_CURRENT);
+        }
+
+        @Override
+        public IBinder onBind(Intent arg0) {
+            Log.i(AnkiDroidApp.TAG, "onBind");
+            return null;
+        }
+
+
+        private static class GetTomorrowDueAsyncTask extends AsyncTask<String, Void, DeckStatus[]> {
+
+        	@Override
+            protected DeckStatus[] doInBackground(String... params) {
+                Log.i(AnkiDroidApp.TAG, "doInBackgroundGetTomorrowDue");
+
+                File dir = new File(params[0]);
+                File[] fileList = dir.listFiles(new WidgetStatus.AnkiFileFilter());
+
+                DeckStatus[] todayDues = WidgetStatus.fetch(sContext);
+
+                ArrayList<DeckStatus> decks = new ArrayList<DeckStatus>(fileList.length);
+
+                for (DeckStatus s : todayDues) {
+                	try {
+                		Deck deck = DeckManager.getDeck(s.mDeckPath, DeckManager.REQUESTING_ACTIVITY_BIGWIDGET, false);
+                		if (deck != null) {
+                			int failedCards = deck.getFailedDelayedCount() + s.mFailedCards;
+                			int dueCards = deck.getNextDueCards(1) + s.mDueCards;
+                			int newCards = deck.getNextNewCards() + s.mNewCards;
+                			decks.add(new DeckStatus(null, deck.getDeckName(), newCards, dueCards, failedCards, deck.getETA(failedCards, dueCards, newCards, true), 0));
+                		}
+                		DeckManager.closeDeck(s.mDeckPath, DeckManager.REQUESTING_ACTIVITY_BIGWIDGET);
+                	} catch (RuntimeException e) {
+                		Log.e(AnkiDroidApp.TAG, "doInBackgroundGetTomorrowDue: an error occurred: " + e);
+                	}
+                }
+                return decks.toArray(new DeckStatus[0]);
+            }
+
+            @Override
+            protected void onPostExecute(DeckStatus[] status) {
+                Log.d(AnkiDroidApp.TAG, "DeckManager.CloseDeckAsyncTask.onPostExecute()");
+                contentService.mLoadedDeck = null;
+                contentService.mCurrentCard = null;
+                contentService.mBigCurrentMessage = null;
+                contentService.mWaitForAsyncTask = false;
+                contentService.mTomorrowDues = status;
+            	if (contentService.mBigShowProgressDialog) {
+            		contentService.mBigShowProgressDialog = false;
+                	updateWidget(VIEW_CONGRATS);
+            	}
+            	contentService.mBigShowProgressDialog = false;
+            }
+        }        
+    }
+}
diff --git a/src/com/ichi2/anki/AnkiDroidWidgetMedium.java b/src/com/ichi2/widget/AnkiDroidWidgetMedium.java
similarity index 86%
rename from src/com/ichi2/anki/AnkiDroidWidgetMedium.java
rename to src/com/ichi2/widget/AnkiDroidWidgetMedium.java
index 4c7ff66096..258e25ab09 100644
--- a/src/com/ichi2/anki/AnkiDroidWidgetMedium.java
+++ b/src/com/ichi2/widget/AnkiDroidWidgetMedium.java
@@ -12,12 +12,19 @@
  * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
  ****************************************************************************************/
 
-package com.ichi2.anki;
-
+package com.ichi2.widget;
+
+import com.ichi2.anki.AnkiDroidApp;
+import com.ichi2.anki.DeckStatus;
+import com.ichi2.anki.R;
+import com.ichi2.anki.StudyOptions;
+import com.ichi2.anki.R.drawable;
+import com.ichi2.anki.R.id;
+import com.ichi2.anki.R.layout;
+import com.ichi2.anki.R.plurals;
+import com.ichi2.anki.R.string;
 import com.tomgibara.android.veecheck.util.PrefSettings;
 
-import android.app.Notification;
-import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.app.Service;
 import android.appwidget.AppWidgetManager;
@@ -50,23 +57,24 @@ public class AnkiDroidWidgetMedium extends AppWidgetProvider {
 
     @Override
     public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
-        Log.i(AnkiDroidApp.TAG, "onUpdate");
+        Log.i(AnkiDroidApp.TAG, "MediumWidget: onUpdate");
         WidgetStatus.update(context);
     }
 
     @Override
     public void onEnabled(Context context) {
         super.onEnabled(context);
+        Log.i(AnkiDroidApp.TAG, "MediumWidget: Widget enabled");
         SharedPreferences preferences = PrefSettings.getSharedPrefs(context);
-        preferences.edit().putBoolean("widgetEnabled", true).commit();
+        preferences.edit().putBoolean("widgetMediumEnabled", true).commit();
     }
 
     @Override
     public void onDisabled(Context context) {
         super.onDisabled(context);
-        Log.d(AnkiDroidApp.TAG, "Widget disabled");
+        Log.i(AnkiDroidApp.TAG, "MediumWidget: Widget disabled");
         SharedPreferences preferences = PrefSettings.getSharedPrefs(context);
-        preferences.edit().putBoolean("widgetEnabled", false).commit();
+        preferences.edit().putBoolean("widgetMediumEnabled", false).commit();
     }
 
     public static class UpdateService extends Service {
@@ -110,12 +118,6 @@ public class AnkiDroidWidgetMedium extends AppWidgetProvider {
         /** The cached number of total due cards. */
         private int dueCardsCount;
 
-        /** The id of the notification for due cards. */
-        private static final int WIDGET_NOTIFY_ID = 1;
-
-        /** The notification service to show notifications of due cards. */
-        private NotificationManager mNotificationManager;
-
         private CharSequence getDeckStatusString(DeckStatus deck) {
             SpannableStringBuilder sb = new SpannableStringBuilder();
 
@@ -141,17 +143,9 @@ public class AnkiDroidWidgetMedium extends AppWidgetProvider {
         }
 
 
-        @Override
-        public void onCreate() {
-            super.onCreate();
-            mNotificationManager =
-                (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
-        }
-
-
         @Override
         public void onStart(Intent intent, int startId) {
-            Log.i(AnkiDroidApp.TAG, "OnStart");
+            Log.i(AnkiDroidApp.TAG, "MediumWidget: OnStart");
 
             boolean updateDueDecksNow = true;
             if (intent != null) {
@@ -212,7 +206,7 @@ public class AnkiDroidWidgetMedium extends AppWidgetProvider {
                         	if (action.equals(Intent.ACTION_MEDIA_MOUNTED)) {
                                 Log.i(AnkiDroidApp.TAG, "mMountReceiver - Action = Media Mounted");
                                 if (remounted) {
-                                    WidgetStatus.update(getBaseContext());                                	
+                                    WidgetStatus.update(getBaseContext());
                                 	remounted = false;
                                     if (mMountReceiver != null) {
                                         unregisterReceiver(mMountReceiver);
@@ -289,38 +283,6 @@ public class AnkiDroidWidgetMedium extends AppWidgetProvider {
                 updateViews.setViewVisibility(R.id.anki_droid_prev, View.INVISIBLE);
             }
 
-            SharedPreferences preferences = PrefSettings.getSharedPrefs(context);
-            int minimumCardsDueForNotification = Integer.parseInt(preferences.getString(
-                    "minimumCardsDueForNotification", "25"));
-
-            if (dueCardsCount >= minimumCardsDueForNotification) {
-                // Show a notification
-                int icon = R.drawable.anki;
-                CharSequence tickerText = String.format(
-                        getString(R.string.widget_minimum_cards_due_notification_ticker_text),
-                        dueCardsCount);
-                long when = System.currentTimeMillis();
-
-                Notification notification = new Notification(icon, tickerText, when);
-
-                if (preferences.getBoolean("widgetVibrate", false)) {
-                    notification.defaults |= Notification.DEFAULT_VIBRATE;
-                }
-                if (preferences.getBoolean("widgetBlink", false)) {
-                    notification.defaults |= Notification.DEFAULT_LIGHTS;
-                }
-
-                Context appContext = getApplicationContext();
-                CharSequence contentTitle = getText(R.string.widget_minimum_cards_due_notification_ticker_title);
-
-                notification.setLatestEventInfo(appContext, contentTitle, tickerText, pendingAnkiDroidIntent);
-
-                mNotificationManager.notify(WIDGET_NOTIFY_ID, notification);
-            } else {
-                // Cancel the existing notification, if any.
-                mNotificationManager.cancel(WIDGET_NOTIFY_ID);
-            }
-
             return updateViews;
         }
 
diff --git a/src/com/ichi2/anki/AnkiDroidWidgetSmall.java b/src/com/ichi2/widget/AnkiDroidWidgetSmall.java
similarity index 72%
rename from src/com/ichi2/anki/AnkiDroidWidgetSmall.java
rename to src/com/ichi2/widget/AnkiDroidWidgetSmall.java
index 6fcb669ee4..962dff615e 100644
--- a/src/com/ichi2/anki/AnkiDroidWidgetSmall.java
+++ b/src/com/ichi2/widget/AnkiDroidWidgetSmall.java
@@ -12,12 +12,13 @@
  * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
  ****************************************************************************************/
 
-package com.ichi2.anki;
+package com.ichi2.widget;
 
+import com.ichi2.anki.AnkiDroidApp;
+import com.ichi2.anki.R;
+import com.ichi2.anki.StudyOptions;
 import com.tomgibara.android.veecheck.util.PrefSettings;
 
-import android.app.Notification;
-import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.app.Service;
 import android.appwidget.AppWidgetManager;
@@ -28,13 +29,11 @@ import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.SharedPreferences;
-import android.os.Bundle;
 import android.os.IBinder;
 import android.util.Log;
 import android.view.View;
 import android.widget.RemoteViews;
 
-
 public class AnkiDroidWidgetSmall extends AppWidgetProvider {
 	
     private static BroadcastReceiver mMountReceiver = null;
@@ -42,13 +41,14 @@ public class AnkiDroidWidgetSmall extends AppWidgetProvider {
 
     @Override
     public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
-        Log.i(AnkiDroidApp.TAG, "onUpdate");
+        Log.i(AnkiDroidApp.TAG, "SmallWidget: onUpdate");
         WidgetStatus.update(context);
     }
 
     @Override
     public void onEnabled(Context context) {
         super.onEnabled(context);
+        Log.i(AnkiDroidApp.TAG, "SmallWidget: Widget enabled");
         SharedPreferences preferences = PrefSettings.getSharedPrefs(context);
         preferences.edit().putBoolean("widgetSmallEnabled", true).commit();
     }
@@ -56,18 +56,13 @@ public class AnkiDroidWidgetSmall extends AppWidgetProvider {
     @Override
     public void onDisabled(Context context) {
         super.onDisabled(context);
-        Log.d(AnkiDroidApp.TAG, "Widget disabled");
+        Log.i(AnkiDroidApp.TAG, "SmallWidget: Widget disabled");
         SharedPreferences preferences = PrefSettings.getSharedPrefs(context);
         preferences.edit().putBoolean("widgetSmallEnabled", false).commit();
     }
 
     public static class UpdateService extends Service {
 
-        /**
-         * Update the state of the widget.
-         */
-        public static final String ACTION_UPDATE = "org.ichi2.anki.AnkiDroidWidgetSmall.UPDATE";
-
         /** The cached number of total due cards. */
         private int dueCardsCount;
 
@@ -77,25 +72,9 @@ public class AnkiDroidWidgetSmall extends AppWidgetProvider {
         /** The cached estimated reviewing time. */
         private int eta;
 
-        private boolean startDeckPicker = false;
-
-        /** The id of the notification for due cards. */
-        private static final int WIDGET_NOTIFY_ID = 1;
-
-        /** The notification service to show notifications of due cards. */
-        private NotificationManager mNotificationManager;
-
-        @Override
-        public void onCreate() {
-            super.onCreate();
-            mNotificationManager =
-                (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
-        }
-
-
         @Override
         public void onStart(Intent intent, int startId) {
-            Log.i(AnkiDroidApp.TAG, "OnStart");
+            Log.i(AnkiDroidApp.TAG, "SmallWidget: OnStart");
 
             RemoteViews updateViews = buildUpdate(this, true);
 
@@ -111,12 +90,21 @@ public class AnkiDroidWidgetSmall extends AppWidgetProvider {
             // Resources res = context.getResources();
             RemoteViews updateViews = new RemoteViews(context.getPackageName(), R.layout.widget_small);
 
+            // Add a click listener to open Anki from the icon.
+            // This should be always there, whether there are due cards or not.
+            Intent ankiDroidIntent = new Intent(context, StudyOptions.class);
+            ankiDroidIntent.setAction(Intent.ACTION_MAIN);
+            ankiDroidIntent.addCategory(Intent.CATEGORY_LAUNCHER);
+            PendingIntent pendingAnkiDroidIntent = PendingIntent.getActivity(context, 0, ankiDroidIntent, PendingIntent.FLAG_UPDATE_CURRENT);
+            updateViews.setOnClickPendingIntent(R.id.ankidroid_widget_small_layout, pendingAnkiDroidIntent);
+
             boolean mounted = AnkiDroidApp.isSdCardMounted();
             if (!mounted) {
-                updateViews.setViewVisibility(R.id.widget_due, View.VISIBLE);
-                updateViews.setTextViewText(R.id.widget_due, "-");
+                updateViews.setViewVisibility(R.id.widget_due, View.INVISIBLE);
                 updateViews.setViewVisibility(R.id.widget_eta, View.INVISIBLE);
                 updateViews.setViewVisibility(R.id.widget_progress_frame, View.INVISIBLE);
+                updateViews.setViewVisibility(R.id.ankidroid_widget_small_finish_layout, View.GONE);
+
                 if (mMountReceiver == null) {
                 	mMountReceiver = new BroadcastReceiver() {
                         @Override
@@ -156,17 +144,22 @@ public class AnkiDroidWidgetSmall extends AppWidgetProvider {
                 	if (totalreps != 0) {
                 		progress = (int) Math.round((100.0d * reps) / totalreps);
                 	}
-                	startDeckPicker = counts[3] == 0;
-        			if (dueCardsCount == 0) {
+        			if (dueCardsCount <= 0) {
+        				if (dueCardsCount == 0) {
+    		                updateViews.setViewVisibility(R.id.ankidroid_widget_small_finish_layout, View.VISIBLE);        					
+        				} else {
+    		                updateViews.setViewVisibility(R.id.ankidroid_widget_small_finish_layout, View.INVISIBLE);        					
+        				}
 		                updateViews.setViewVisibility(R.id.widget_due, View.INVISIBLE);
 		                updateViews.setViewVisibility(R.id.widget_progress_frame, View.INVISIBLE);
         			} else {
+		                updateViews.setViewVisibility(R.id.ankidroid_widget_small_finish_layout, View.INVISIBLE);
 		                updateViews.setViewVisibility(R.id.widget_due, View.VISIBLE);
 		                updateViews.setViewVisibility(R.id.widget_progress_frame, View.VISIBLE);
 	                    updateViews.setTextViewText(R.id.widget_due, Integer.toString(dueCardsCount));
 	                    updateViews.setProgressBar(R.id.widget_progress, 100, progress, false);
 					}
-        			if (eta <= 0 || dueCardsCount == 0) {
+        			if (eta <= 0 || dueCardsCount <= 0) {
 		                updateViews.setViewVisibility(R.id.widget_eta, View.INVISIBLE);        				
         			} else {
 		                updateViews.setViewVisibility(R.id.widget_eta, View.VISIBLE);        				
@@ -174,46 +167,6 @@ public class AnkiDroidWidgetSmall extends AppWidgetProvider {
         			}
                 }
             }
-            // Add a click listener to open Anki from the icon.
-            // This should be always there, whether there are due cards or not.
-            Intent ankiDroidIntent = new Intent(context, StudyOptions.class);
-            ankiDroidIntent.setAction(Intent.ACTION_MAIN);
-            ankiDroidIntent.addCategory(Intent.CATEGORY_LAUNCHER);
-            ankiDroidIntent.putExtra("startDeckpicker", startDeckPicker);
-            PendingIntent pendingAnkiDroidIntent = PendingIntent.getActivity(context, 0, ankiDroidIntent, PendingIntent.FLAG_UPDATE_CURRENT);
-            updateViews.setOnClickPendingIntent(R.id.ankidroid_widget_small_layout, pendingAnkiDroidIntent);
-
-            SharedPreferences preferences = PrefSettings.getSharedPrefs(context);
-            int minimumCardsDueForNotification = Integer.parseInt(preferences.getString(
-                    "minimumCardsDueForNotification", "25"));
-
-            if (mounted && dueCardsCount >= minimumCardsDueForNotification) {
-                // Show a notification
-                int icon = R.drawable.anki;
-                CharSequence tickerText = String.format(
-                        getString(R.string.widget_minimum_cards_due_notification_ticker_text),
-                        dueCardsCount);
-                long when = System.currentTimeMillis();
-
-                Notification notification = new Notification(icon, tickerText, when);
-
-                if (preferences.getBoolean("widgetVibrate", false)) {
-                    notification.defaults |= Notification.DEFAULT_VIBRATE;
-                }
-                if (preferences.getBoolean("widgetBlink", false)) {
-                    notification.defaults |= Notification.DEFAULT_LIGHTS;
-                }
-
-                Context appContext = getApplicationContext();
-                CharSequence contentTitle = getText(R.string.widget_minimum_cards_due_notification_ticker_title);
-
-                notification.setLatestEventInfo(appContext, contentTitle, tickerText, pendingAnkiDroidIntent);
-
-                mNotificationManager.notify(WIDGET_NOTIFY_ID, notification);
-            } else {
-                // Cancel the existing notification, if any.
-                mNotificationManager.cancel(WIDGET_NOTIFY_ID);
-            }            	
 
             return updateViews;
         }
diff --git a/src/com/ichi2/widget/WidgetContentService.java b/src/com/ichi2/widget/WidgetContentService.java
new file mode 100644
index 0000000000..dad53a2186
--- /dev/null
+++ b/src/com/ichi2/widget/WidgetContentService.java
@@ -0,0 +1,86 @@
+package com.ichi2.widget;
+
+import com.ichi2.anki.AnkiDroidApp;
+import com.ichi2.anki.Card;
+import com.ichi2.anki.Deck;
+import com.ichi2.anki.DeckStatus;
+import com.ichi2.anki.DeckManager;
+
+import com.tomgibara.android.veecheck.util.PrefSettings;
+
+import android.app.Service;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.os.Binder;
+import android.os.IBinder;
+import android.util.Log;
+
+public class WidgetContentService extends Service{
+	private final IBinder widgetContentBinder = new WidgetContentBinder();
+
+    public Deck mLoadedDeck;
+    public Card mCurrentCard;
+    public boolean mBigShowProgressDialog = false;
+    public int mBigCurrentView = AnkiDroidWidgetBig.UpdateService.VIEW_NOT_SPECIFIED;
+    public String mBigCurrentMessage;
+    public DeckStatus[] mTomorrowDues;
+    public boolean mWaitForAsyncTask = false;
+    public boolean mUpdateStarted = false;
+
+	@Override
+	public void onCreate() {
+		super.onCreate();
+		SharedPreferences prefs = PrefSettings.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext());
+		String path = prefs.getString("lastWidgetDeck", "");
+		if (path != null && path.length() > 0 && AnkiDroidApp.isSdCardMounted()) {
+			Log.i(AnkiDroidApp.TAG, "BigWidget: reloading deck " + path);
+			mLoadedDeck = DeckManager.getDeck(path, DeckManager.REQUESTING_ACTIVITY_BIGWIDGET, true);
+			if (mLoadedDeck != null) {
+				mCurrentCard = mLoadedDeck.getCard();				
+			}
+		}
+	}
+
+
+	@Override
+	public void onDestroy() {
+		// TODO: this does not seem to be reliably called
+		String path = "";
+		long cardId = 0l;
+		if (mLoadedDeck != null) {
+			path = mLoadedDeck.getDeckPath();
+			DeckManager.closeDeck(path, DeckManager.REQUESTING_ACTIVITY_BIGWIDGET);
+			if (mCurrentCard != null) {
+				cardId = mCurrentCard.getId();
+			}
+		}
+		PrefSettings.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit().putString("lastWidgetDeck", path).commit();
+		PrefSettings.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit().putLong("lastWidgetCard", cardId).commit();
+	}
+
+	public void setCard() {
+		if (mLoadedDeck != null) {
+			setCard(mLoadedDeck.getCard());
+		}
+	}
+	public void setCard(Card card) {
+		mCurrentCard = card;
+		Long cardId = 0l;
+		if (card != null) {
+			cardId = card.getId();
+		}
+		PrefSettings.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit().putLong("lastWidgetCard", cardId).commit();
+	}
+
+	@Override
+	public IBinder onBind(Intent arg0) {
+		return widgetContentBinder;
+	}
+
+	public class WidgetContentBinder extends Binder {
+		
+		WidgetContentService getService() {
+			return WidgetContentService.this;
+		}
+	}
+}
diff --git a/src/com/ichi2/widget/WidgetDialog.java b/src/com/ichi2/widget/WidgetDialog.java
new file mode 100644
index 0000000000..76824a2c79
--- /dev/null
+++ b/src/com/ichi2/widget/WidgetDialog.java
@@ -0,0 +1,81 @@
+/***************************************************************************************
+ * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
+ * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
+ *                                                                                      *
+ * This program is free software; you can redistribute it and/or modify it under        *
+ * the terms of the GNU General Public License as published by the Free Software        *
+ * Foundation; either version 3 of the License, or (at your option) any later           *
+ * version.                                                                             *
+ *                                                                                      *
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
+ *                                                                                      *
+ * You should have received a copy of the GNU General Public License along with         *
+ * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
+ ****************************************************************************************/
+
+package com.ichi2.widget;
+
+import com.ichi2.anki.DeckManager;
+import com.ichi2.anki.R;
+import com.ichi2.themes.StyledDialog;
+import com.ichi2.themes.Themes;
+
+import android.app.Activity;
+import android.content.DialogInterface;
+import android.content.DialogInterface.OnClickListener;
+import android.content.DialogInterface.OnDismissListener;
+import android.content.res.Resources;
+import android.content.Intent;
+import android.os.Bundle;
+
+public class WidgetDialog extends Activity {
+
+	public static final String ACTION_SHOW_DECK_SELECTION_DIALOG = "org.ichi2.WidgetDialog.SHOWDECKSELECTIONDIALOG";
+	public static final String ACTION_SHOW_RESTRICTIONS_DIALOG = "org.ichi2.WidgetDialog.SHOWRESTRICTIONSDIALOG";
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+    	Themes.applyTheme(this, Themes.THEME_NO_THEME);
+    	super.onCreate(savedInstanceState);
+    	Intent intent = getIntent();
+    	if (intent != null) {
+    		String action = intent.getAction();
+    		if (action != null) {
+    			if (ACTION_SHOW_DECK_SELECTION_DIALOG.equals(action)) {
+    				DeckManager.getSelectDeckDialog(this, new OnClickListener() {
+
+						@Override
+						public void onClick(DialogInterface dialog, int which) {
+		            		Intent newIntent = new Intent(WidgetDialog.this, AnkiDroidWidgetBig.UpdateService.class);
+		            		newIntent.setAction(AnkiDroidWidgetBig.UpdateService.ACTION_OPENDECK);
+		            		newIntent.putExtra(AnkiDroidWidgetBig.UpdateService.EXTRA_DECK_PATH, DeckManager.getDeckPathAfterDeckSelectionDialog(which));
+		            		startService(newIntent);
+						}
+    				}, null, new OnDismissListener() {
+
+						@Override
+						public void onDismiss(DialogInterface arg0) {
+		            		WidgetDialog.this.finish();
+						}
+    					
+    				}).show();
+    			} else if (ACTION_SHOW_RESTRICTIONS_DIALOG.equals(action)) {
+    				Resources res = getResources();
+    				StyledDialog.Builder builder = new StyledDialog.Builder(this);
+    				builder.setTitle(res.getString(R.string.widget_big)).
+    					setMessage(R.string.widget_big_restrictions_dialog).
+    					setOnDismissListener(new OnDismissListener() {
+
+    						@Override
+    						public void onDismiss(DialogInterface arg0) {
+    							WidgetDialog.this.finish();
+    						}
+    					}).setPositiveButton(res.getString(R.string.ok), null);
+					builder.show();
+    			}
+    		}
+    	}
+    }
+}
diff --git a/src/com/ichi2/widget/WidgetStatus.java b/src/com/ichi2/widget/WidgetStatus.java
new file mode 100644
index 0000000000..dbf879aab1
--- /dev/null
+++ b/src/com/ichi2/widget/WidgetStatus.java
@@ -0,0 +1,289 @@
+/***************************************************************************************
+ * This program is free software; you can redistribute it and/or modify it under        *
+ * the terms of the GNU General Public License as published by the Free Software        *
+ * Foundation; either version 3 of the License, or (at your option) any later           *
+ * version.                                                                             *
+ *                                                                                      *
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
+ *                                                                                      *
+ * You should have received a copy of the GNU General Public License along with         *
+ * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
+ ****************************************************************************************/
+
+package com.ichi2.widget;
+
+import com.ichi2.anki.AnkiDroidApp;
+import com.ichi2.anki.BackupManager;
+import com.ichi2.anki.Deck;
+import com.ichi2.anki.DeckManager;
+import com.ichi2.anki.DeckStatus;
+import com.ichi2.anki.MetaDB;
+import com.ichi2.anki.services.NotificationService;
+import com.tomgibara.android.veecheck.util.PrefSettings;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.database.SQLException;
+import android.os.AsyncTask;
+import android.util.Log;
+
+import java.io.File;
+import java.io.FileFilter;
+import java.util.ArrayList;
+import java.util.Collections;
+
+/**
+ * The status of the widget.
+ * <p>
+ * It contains the status of each of the decks.
+ */
+public final class WidgetStatus {
+
+	private static boolean mediumWidget = false;
+	private static boolean smallWidget = false;
+	private static boolean bigWidget = false;
+	private static boolean notification = false;
+	private static DeckStatus sDeckStatus;
+	private static AsyncTask<Context,Void,Context> sUpdateDeckStatusAsyncTask;
+
+    /** This class should not be instantiated. */
+    private WidgetStatus() {}
+
+    /** Request the widget to update its status. */
+    public static void update(Context context) {
+    	update(context, null);
+    }
+    /** Request the widget to update its status. */
+    public static void update(Context context, DeckStatus deckStatus) {
+    	update(context, deckStatus, true);
+    }
+    public static void update(Context context, DeckStatus deckStatus, boolean updateBigWidget) {
+    	sDeckStatus = deckStatus;
+        SharedPreferences preferences = PrefSettings.getSharedPrefs(context);
+        if (preferences.getBoolean("widgetMediumEnabled", false)) {
+            mediumWidget = true;
+        } else {
+            mediumWidget = false;
+        }
+        if (preferences.getBoolean("widgetSmallEnabled", false)) {
+            smallWidget = true;
+        } else {
+            smallWidget = false;
+        }
+        if (updateBigWidget && preferences.getBoolean("widgetBigEnabled", false)) {
+            bigWidget = true;
+        } else {
+            bigWidget = false;
+        }
+        if (Integer.parseInt(preferences.getString("minimumCardsDueForNotification", "25")) < 1000000 && sDeckStatus == null) {
+        	notification = true;
+        } else {
+        	notification = false;
+        }
+        if ((mediumWidget || smallWidget || bigWidget || notification) && ((sUpdateDeckStatusAsyncTask == null) || (sUpdateDeckStatusAsyncTask.getStatus() == AsyncTask.Status.FINISHED))) {
+            Log.d(AnkiDroidApp.TAG, "WidgetStatus.update(): updating");
+            sUpdateDeckStatusAsyncTask = new UpdateDeckStatusAsyncTask();
+            sUpdateDeckStatusAsyncTask.execute(context);
+        } else {
+            Log.d(AnkiDroidApp.TAG, "WidgetStatus.update(): not enabled");
+        }
+    }
+
+
+    /** Returns the status of each of the decks. */
+    public static DeckStatus[] fetch(Context context) {
+        return MetaDB.getWidgetStatus(context);
+    }
+
+    /** Returns the status of each of the decks. */
+    public static int[] fetchSmall(Context context) {
+        return MetaDB.getWidgetSmallStatus(context);
+    }
+
+    public static int fetchDue(Context context) {
+        return MetaDB.getNotificationStatus(context);
+    }
+
+    public static DeckStatus getDeckStatus(Deck deck) {
+		if (deck == null) {
+			return null;
+		}
+        int dueCards = 0;
+        int newCards = 0;
+        int failedCards = deck.getFailedSoonCount();
+        int eta = 0;
+        int reps = deck.getSessionFinishedCards();
+
+
+        if(!deck.hasFinishScheduler()) {
+            dueCards = deck.getRevCount();
+            newCards = deck.getNewCountToday();
+            eta = deck.getETA();
+        }
+        return new DeckStatus(deck.getDeckPath(), deck.getDeckName(), newCards, dueCards, failedCards, eta, reps);
+    }
+
+
+    private static class UpdateDeckStatusAsyncTask extends AsyncTask<Context, Void, Context> {
+        private static final DeckStatus[] EMPTY_DECK_STATUS = new DeckStatus[0];
+
+        private static DeckStatus[] mDecks = EMPTY_DECK_STATUS;
+
+        @Override
+        protected Context doInBackground(Context... params) {
+            Log.d(AnkiDroidApp.TAG, "WidgetStatus.UpdateDeckStatusAsyncTask.doInBackground()");
+            Context context = params[0];
+
+            if (!AnkiDroidApp.isSdCardMounted()) {
+            	return context;
+            }
+
+            // For the deck information
+            ArrayList<DeckStatus> decks;
+
+            if (sDeckStatus != null && mDecks != null && mDecks.length > 0) {
+            	decks = new ArrayList<DeckStatus>(mDecks.length);
+            		for (DeckStatus m : mDecks) {
+            			if (m.mDeckPath.equals(sDeckStatus.mDeckPath)) {
+            				Log.i(AnkiDroidApp.TAG, "UpdateWidget - update information for deck " + sDeckStatus.mDeckPath);
+            				decks.add(sDeckStatus);
+            			} else {
+            				Log.i(AnkiDroidApp.TAG, "UpdateWidget - copy information for deck " + m.mDeckPath);
+            				decks.add(m);
+            			}
+            		}
+            } else {
+                SharedPreferences preferences = PrefSettings.getSharedPrefs(context);
+                String deckPath = preferences.getString("deckPath",
+                        AnkiDroidApp.getStorageDirectory() + "/AnkiDroid");
+
+                File dir = new File(deckPath);
+
+                File[] fileList = dir.listFiles(new AnkiFileFilter());
+                if (fileList == null || fileList.length == 0) {
+                    mDecks = EMPTY_DECK_STATUS;
+                    return context;
+                }
+
+                decks = new ArrayList<DeckStatus>(fileList.length);
+
+                for (File file : fileList) {
+                	String absPath = null;
+                    try {
+                        // Run through the decks and get the information
+                        absPath = file.getAbsolutePath();
+                        String deckName = file.getName().replaceAll(".anki", "");
+
+                        Log.i(AnkiDroidApp.TAG, "WidgetStatus: Found deck: " + absPath);
+
+                        Deck deck = DeckManager.getDeck(absPath, DeckManager.REQUESTING_ACTIVITY_WIDGETSTATUS, false);
+                        if (deck == null) {
+                            Log.e(AnkiDroidApp.TAG, "Widget: Skipping null deck: " + absPath);
+                            // Use the data from the last time we updated the deck, if available.
+//                            for (DeckStatus deckStatus : mDecks) {
+//                                if (absPath.equals(deckStatus.mDeckPath)) {
+//                                    Log.d(AnkiDroidApp.TAG, "Using previous value");
+//                                    decks.add(deckStatus);
+//                                    break;
+//                                }
+//                            }
+                            continue;
+                        }
+                        int dueCards = 0;
+                        int newCards = 0;
+                        int failedCards = deck.getFailedSoonCount();
+                        int eta = 0;
+                        int reps = deck.getSessionFinishedCards();
+
+
+                        if(!deck.hasFinishScheduler()) {
+        	                dueCards = deck.getRevCount();
+        	                newCards = deck.getNewCountToday();
+        	                eta = deck.getETA();
+                        }
+
+                        DeckManager.closeDeck(absPath, DeckManager.REQUESTING_ACTIVITY_WIDGETSTATUS);
+
+                        // Add the information about the deck
+                        decks.add(new DeckStatus(absPath, deckName, newCards, dueCards, failedCards, eta, reps));
+                    } catch (SQLException e) {
+                        Log.i(AnkiDroidApp.TAG, "Widget: Problems on retrieving deck information");
+                        Log.e(AnkiDroidApp.TAG, e.toString());
+                        if (absPath != null) {
+                            BackupManager.restoreDeckIfMissing(absPath);                    	
+                        }
+                    }
+                }
+            }
+
+            if (!decks.isEmpty() && decks.size() > 1) {
+                // Sort and reverse the list if there are decks
+                Log.i(AnkiDroidApp.TAG, "Sorting deck");
+
+                // Ordered by deck name
+                Collections.sort(decks, new ByNameComparator());
+            }
+
+            mDecks = decks.toArray(EMPTY_DECK_STATUS);
+            return context;
+        }
+
+        @Override
+        protected void onPostExecute(Context context) {
+            Log.d(AnkiDroidApp.TAG, "WidgetStatus.UpdateDeckStatusAsyncTask.onPostExecute()");
+            MetaDB.storeWidgetStatus(context, mDecks);
+            if (mediumWidget) {
+            	Intent intent;
+                intent = new Intent(context, AnkiDroidWidgetMedium.UpdateService.class);
+                intent.setAction(AnkiDroidWidgetMedium.UpdateService.ACTION_UPDATE);
+                context.startService(intent);
+            }
+            if (smallWidget) {
+            	Intent intent;
+                intent = new Intent(context, AnkiDroidWidgetSmall.UpdateService.class);            	
+                context.startService(intent);
+            }
+            if (bigWidget) {
+            	Intent intent;
+                intent = new Intent(context, AnkiDroidWidgetBig.UpdateService.class);            	
+                intent.setAction(AnkiDroidWidgetBig.UpdateService.ACTION_UPDATE);
+                context.startService(intent);
+            }
+            if (notification) {
+            	Intent intent;
+                intent = new Intent(context, NotificationService.class);
+                context.startService(intent);
+            }
+        }
+
+    }
+
+    /** Comparator that sorts instances of {@link DeckStatus} based on number of due cards. */
+    public static class ByDueComparator implements java.util.Comparator<DeckStatus> {
+        @Override
+        public int compare(DeckStatus deck1, DeckStatus deck2) {
+            // Reverse due cards number order
+            return deck2.mDueCards - deck1.mDueCards;
+        }
+    }
+
+
+    /** Comparator that sorts instances of {@link DeckStatus} based on number of due cards. */
+    public static class ByNameComparator implements java.util.Comparator<DeckStatus> {
+        @Override
+        public int compare(DeckStatus deck1, DeckStatus deck2) {
+            return - deck2.mDeckName.compareTo(deck1.mDeckName);
+        }
+    }
+
+    /** Filter for Anki files. */
+    public static final class AnkiFileFilter implements FileFilter {
+        @Override
+        public boolean accept(File pathname) {
+            return pathname.isFile() && pathname.getName().endsWith(".anki");
+        }
+    }
+}
diff --git a/src/com/mindprod/common11/BigDate.java b/src/com/mindprod/common11/BigDate.java
index 7bdb24e97c..10d00b7652 100644
--- a/src/com/mindprod/common11/BigDate.java
+++ b/src/com/mindprod/common11/BigDate.java
@@ -171,7 +171,7 @@ import java.util.TimeZone;
  * @noinspection WeakerAccess,UnusedDeclaration
  * @since 1997-05-03
  */
-public final class BigDate implements Cloneable, Serializable, Comparable {
+public final class BigDate implements Cloneable, Serializable, Comparable<BigDate> {
     // ------------------------------ CONSTANTS ------------------------------
 
     /**
@@ -1352,8 +1352,8 @@ public final class BigDate implements Cloneable, Serializable, Comparable {
      * @return +ve if this&gt;other, 0 if this==other, -ve if this&lt;other
      */
     @Override
-    public final int compareTo(Object other) {
-        return ordinal - ((BigDate) other).ordinal;
+    public final int compareTo(BigDate other) {
+        return ordinal - other.ordinal;
     }
 
 
diff --git a/src/com/mindprod/common11/StringTools.java b/src/com/mindprod/common11/StringTools.java
index 998512b6d7..7b08644fd5 100644
--- a/src/com/mindprod/common11/StringTools.java
+++ b/src/com/mindprod/common11/StringTools.java
@@ -33,8 +33,8 @@ package com.mindprod.common11;
 
 import android.graphics.Color;
 
+import java.util.ArrayList;
 import java.util.BitSet;
-import java.util.Vector;
 
 /**
  * Miscellaneous static methods for dealing with Strings in JDK 1.1+.
@@ -693,7 +693,7 @@ public class StringTools {
 
         // collapse blank lines in the middle chunk
 
-        Vector keep = new Vector(lastNonBlankLine - firstNonBlankLine + 1);
+        ArrayList<String> keep = new ArrayList<String>(lastNonBlankLine - firstNonBlankLine + 1);
         int pendingBlankLines = 0;
         for (int i = firstNonBlankLine; i <= lastNonBlankLine; i++) {
             if (lines[i].trim().length() == 0) {
@@ -706,7 +706,7 @@ public class StringTools {
                 pendingBlankLines = 0;
             }
         }
-        return (String[]) keep.toArray(new String[keep.size()]);
+        return keep.toArray(new String[keep.size()]);
     }
 
 
diff --git a/src/com/samskivert/mustache/MustacheException.java b/src/com/samskivert/mustache/MustacheException.java
index 65cfeb9027..bfd149b262 100644
--- a/src/com/samskivert/mustache/MustacheException.java
+++ b/src/com/samskivert/mustache/MustacheException.java
@@ -7,6 +7,7 @@ package com.samskivert.mustache;
 /**
  * An exception thrown when an error occurs parsing or executing a Mustache template.
  */
+@SuppressWarnings("serial")
 public class MustacheException extends RuntimeException
 {
     public MustacheException (String message) {
diff --git a/src/org/amr/arabic/ArabicUtilities.java b/src/org/amr/arabic/ArabicUtilities.java
index 07b35ad69a..45aba50b01 100755
--- a/src/org/amr/arabic/ArabicUtilities.java
+++ b/src/org/amr/arabic/ArabicUtilities.java
@@ -137,7 +137,7 @@ public class ArabicUtilities {
 	private static String[] getWordsFromMixedWord(String word){
 
 		//The return result of words
-		ArrayList finalWords=new ArrayList();
+		ArrayList<String> finalWords=new ArrayList<String>();
 
 		//Temp word to hold the current word
 		String tempWord="";
diff --git a/test/com/ichi2/anki/ReviewingTest.java b/test/com/ichi2/anki/ReviewingTest.java
new file mode 100644
index 0000000000..f5526f19b5
--- /dev/null
+++ b/test/com/ichi2/anki/ReviewingTest.java
@@ -0,0 +1,141 @@
+package com.ichi2.anki;
+
+
+import java.util.Random;
+
+import android.test.ActivityInstrumentationTestCase2;
+import android.util.Log;
+
+import com.jayway.android.robotium.solo.Solo;
+
+/**
+ * @author An Thanh Nguyen
+ * 
+ * This is a test class for AnkiDroid using Robotium.
+ * It starts the StudyOptions activity, click on "Start Reviewing"
+ * and then automatically answers all questions.
+ *
+ * To use this test:
+ *   1. Load the deck you want to test in the emulator/device 
+ *   2. Run this class as a Android JUnit Test
+ *   
+ * Pre-conditions:
+ *   - Run AnkiDroid a first time to make sure no welcome/changelog/etc popups will appear
+ *   - Set your locale to English as those tests rely on window title name
+ *   
+ */
+public class ReviewingTest extends
+		ActivityInstrumentationTestCase2<StudyOptions> {
+
+	private static final int SHORT_SLEEP_TIME = 100;
+	private static final String STUDY_OPTIONS_CLASS = "StudyOptions";
+	private static final String REVIEWER_CLASS = "Reviewer";
+	private Solo solo;
+	private static int SLEEP_TIME = 250;// the time paused between actions.
+	private Random rd;
+	
+	/**
+	 * Constructor
+	 */
+	public ReviewingTest() {
+		super("com.ichi2.anki", StudyOptions.class);
+		// TODO Auto-generated constructor stub
+	}
+
+
+	public void setUp() throws Exception{
+		solo = new Solo(getInstrumentation(), getActivity());
+		rd = new Random();
+	}
+	
+	/**
+	 * @param pre prefix to add to the log
+	 */
+	private void logCurrentActivity(String pre){
+		android.app.Activity activity = solo.getCurrentActivity();
+		Log.d("Test Activity Title",  pre + ": " + (String) activity.getTitle() );
+		Log.d("Test Activity Class",  pre + ": " + (String) activity.getLocalClassName() );
+	}
+	
+
+	private void answerACard(){
+		solo.sendKey(solo.DOWN);
+		solo.sendKey(solo.ENTER);
+		solo.sleep(SLEEP_TIME);
+		
+		if (finished())
+			return;
+		
+		//Randomly select a answer
+		//Assume that the current pointer is at the second button from the left
+		int r = rd.nextInt(4);
+		if (  r == 0)
+			solo.sendKey(solo.LEFT);
+		else 
+			for (int i = 0; i < (r-1); i++)
+				solo.sendKey(solo.RIGHT);
+		
+		solo.sendKey(solo.ENTER);
+	}
+	
+	/**
+	 * @return true if the current activity is not Reviewer
+	 */
+	private boolean finished(){
+		
+//		ArrayList<TextView> ArrayT = solo.getCurrentTextViews(null);
+//		for ( TextView t : ArrayT ){
+//			CharSequence chS = t.getText();
+//			String s = chS.toString();
+//			//Log.d("Test TextView", s);
+//			String congrats = getActivity().getString(R.string.studyoptions_congrats_title);
+//			if (s.equals(congrats) ) return true;
+//		}
+//		
+//		return false;
+		
+		return (!solo.getCurrentActivity().getLocalClassName().equals(REVIEWER_CLASS));
+	}
+	
+	/**
+	 * Main test method
+	 * Simulate the reviewing action
+	 */
+	public void testReviewingCards() {
+		logCurrentActivity("Start");
+		// Wait for the program to load
+		while ( solo.getCurrentActivity().getTitle().toString().equals("AnkiDroid") )
+			solo.sleep(SHORT_SLEEP_TIME);
+		
+		logCurrentActivity("After loaded");
+		
+		// Select "Start reviewing"
+		solo.sendKey(solo.ENTER);
+		solo.sleep(SLEEP_TIME);
+		
+		//Wait for the Reviewer to load
+		while (solo.getCurrentActivity().getLocalClassName().equals(STUDY_OPTIONS_CLASS))
+			solo.sleep(SHORT_SLEEP_TIME);
+		
+		logCurrentActivity("Before answer cards");
+		
+		while (true){
+			if ( finished() ) break;
+			answerACard();
+			logCurrentActivity("Answered a card");
+			solo.sleep(SLEEP_TIME);
+		}
+		
+		// The test is passed if it can run to here
+		assertTrue(true);
+	}
+	
+	
+	public void tearDown() throws Exception {
+		try {
+			solo.finalize();
+		} catch (Throwable e) {
+			e.printStackTrace();
+		}
+	}
+}
