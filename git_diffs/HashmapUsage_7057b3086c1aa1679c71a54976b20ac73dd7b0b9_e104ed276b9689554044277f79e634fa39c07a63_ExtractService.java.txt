diff --git a/src/main/java/com/amaze/filemanager/filesystem/FileUtil.java b/src/main/java/com/amaze/filemanager/filesystem/FileUtil.java
index 2cad9f805..1d6e59b64 100644
--- a/src/main/java/com/amaze/filemanager/filesystem/FileUtil.java
+++ b/src/main/java/com/amaze/filemanager/filesystem/FileUtil.java
@@ -136,7 +136,7 @@ public abstract class FileUtil {
         return true;
     }
 
-    public static OutputStream getOutputStream(@NonNull final File target,Context context,long s)throws Exception {
+    public static OutputStream getOutputStream(final File target, Context context, long s) throws Exception {
 
         OutputStream outStream = null;
         try {
@@ -144,23 +144,20 @@ public abstract class FileUtil {
             if (isWritable(target)) {
                 // standard way
                 outStream = new FileOutputStream(target);
-            }
-            else {
+            } else {
                 if (Build.VERSION.SDK_INT>=Build.VERSION_CODES.LOLLIPOP) {
                     // Storage Access Framework
                     DocumentFile targetDocument = getDocumentFile(target, false,context);
-                    outStream =
-                            context.getContentResolver().openOutputStream(targetDocument.getUri());
-                }
-                else if (Build.VERSION.SDK_INT==Build.VERSION_CODES.KITKAT) {
+                    outStream = context.getContentResolver().openOutputStream(targetDocument.getUri());
+                } else if (Build.VERSION.SDK_INT==Build.VERSION_CODES.KITKAT) {
                     // Workaround for Kitkat ext SD card
                     return MediaStoreHack.getOutputStream(context,target.getPath());
                 }
             }
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
             Log.e("AmazeFileUtils",
                     "Error when copying file from " +  target.getAbsolutePath(), e);
+            throw new Exception();
         }
         return outStream;
     }
@@ -187,7 +184,7 @@ public abstract class FileUtil {
 
         // Try the Kitkat workaround.
         if (Build.VERSION.SDK_INT==Build.VERSION_CODES.KITKAT) {
-            ContentResolver resolver = context.getContentResolver();
+             ContentResolver resolver = context.getContentResolver();
 
             try {
                 Uri uri = MediaStoreHack.getUriFromFile(file.getAbsolutePath(),context);
diff --git a/src/main/java/com/amaze/filemanager/filesystem/HFile.java b/src/main/java/com/amaze/filemanager/filesystem/HFile.java
index 2881a0911..8096ddaf4 100644
--- a/src/main/java/com/amaze/filemanager/filesystem/HFile.java
+++ b/src/main/java/com/amaze/filemanager/filesystem/HFile.java
@@ -127,6 +127,7 @@ public class HFile {
         }
         return new File("/").lastModified();
     }
+
     public long length() {
         long s = 0l;
         switch (mode){
@@ -143,12 +144,21 @@ public class HFile {
                 return s;
             case ROOT:
                 BaseFile baseFile=generateBaseFileFromParent();
-                if(baseFile!=null)
-                    return baseFile.getSize();
+                if(baseFile!=null) return baseFile.getSize();
+                break;
         }
         return s;
     }
 
+    /**
+     * Helper method to find length of file under otg
+     * @param context
+     * @return
+     */
+    public long length(Context context) {
+        return RootHelper.getDocumentFile(path, context).length();
+    }
+
     public String getPath() {
         return path;
     }
@@ -279,18 +289,39 @@ public class HFile {
 
     public long folderSize() {
         long size = 0l;
-        if (isSmb()) {
-            try {
-                size = Futils.folderSize(new SmbFile(path));
-            } catch (MalformedURLException e) {
-                size = 0l;
-                e.printStackTrace();
-            }
-        } else
-            size = Futils.folderSize(new File(path));
+
+        switch (mode){
+            case SMB:
+                try {
+                    size = Futils.folderSize(new SmbFile(path));
+                } catch (MalformedURLException e) {
+                    size = 0l;
+                    e.printStackTrace();
+                }
+                break;
+            case FILE:
+                size = Futils.folderSize(new File(path));
+                break;
+            case ROOT:
+                BaseFile baseFile=generateBaseFileFromParent();
+                if(baseFile!=null) size = baseFile.getSize();
+                break;
+            default:
+                return 0l;
+        }
         return size;
     }
 
+    /**
+     * Helper method to get length of folder in an otg
+     * @param context
+     * @return
+     */
+    public long folderSize(Context context) {
+        return Futils.folderSize(path, context);
+    }
+
+
     public long getUsableSpace() {
         long size = 0l;
         if (isSmb()) {
diff --git a/src/main/java/com/amaze/filemanager/fragments/ProcessViewer.java b/src/main/java/com/amaze/filemanager/fragments/ProcessViewer.java
index 0687aabd2..cba857965 100644
--- a/src/main/java/com/amaze/filemanager/fragments/ProcessViewer.java
+++ b/src/main/java/com/amaze/filemanager/fragments/ProcessViewer.java
@@ -59,6 +59,7 @@ import com.github.mikephil.charting.data.LineDataSet;
 import com.github.mikephil.charting.interfaces.datasets.ILineDataSet;
 
 import java.util.ArrayList;
+import java.util.ConcurrentModificationException;
 
 public class ProcessViewer extends Fragment {
 
@@ -123,7 +124,7 @@ public class ProcessViewer extends Fragment {
 
             public void onClick(View p1) {
                 Toast.makeText(getActivity(), getResources().getString(R.string.stopping), Toast.LENGTH_LONG).show();
-                Intent i = new Intent(CopyService.TAG_COPY_CANCEL_BROADCAST);
+                Intent i = new Intent(CopyService.TAG_BROADCAST_COPY_CANCEL);
                 getActivity().sendBroadcast(i);
                 mProgressTextView.setText(getString(R.string.cancel));
             }
@@ -142,7 +143,16 @@ public class ProcessViewer extends Fragment {
             CopyService.LocalBinder localBinder = (CopyService.LocalBinder) service;
             CopyService copyService = localBinder.getService();
 
-            for (final DataPackage dataPackage : copyService.getDataPackageList()) {
+            ArrayList<DataPackage> dataPackages;
+            try {
+                dataPackages = copyService.getDataPackageList();
+            } catch (ConcurrentModificationException e) {
+                // array list was being modified while fetching (even after synchronization) :/
+                // return for now
+                return;
+            }
+
+            for (final DataPackage dataPackage : dataPackages) {
                 getActivity().runOnUiThread(new Runnable() {
                     @Override
                     public void run() {
@@ -186,20 +196,47 @@ public class ProcessViewer extends Fragment {
         public void onServiceConnected(ComponentName className,
                                        IBinder service) {
             // We've bound to LocalService, cast the IBinder and get LocalService instance
-            ExtractService.LocalBinder binder = (ExtractService.LocalBinder) service;
-            ExtractService mService = binder.getService();
-            for (int i : mService.hash1.keySet()) {
-                //processExtractResults(mService.hash1.get(i));
+            ExtractService.LocalBinder localBinder = (ExtractService.LocalBinder) service;
+            ExtractService extractService = localBinder.getService();
+
+            ArrayList<DataPackage> dataPackages;
+            try {
+                dataPackages = extractService.getDataPackageList();
+            } catch (ConcurrentModificationException e) {
+                // array list was being modified while fetching (even after synchronization) :/
+                // return for now
+                return;
+            }
+
+            for (final DataPackage dataPackage : dataPackages) {
+                getActivity().runOnUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+
+                        processResults(dataPackage);
+                    }
+                });
             }
-            mService.setProgressListener(new ExtractService.ProgressListener() {
+
+            extractService.setProgressListener(new ExtractService.ProgressListener() {
                 @Override
-                public void onUpdate(DataPackage dataPackage) {
-                    //processExtractResults(dataPackage);
+                public void onUpdate(final DataPackage dataPackage) {
+                    if (getActivity()==null) {
+                        // callback called when we're not inside the app
+                        return;
+                    }
+                    getActivity().runOnUiThread(new Runnable() {
+                        @Override
+                        public void run() {
+
+                            processResults(dataPackage);
+                        }
+                    });
                 }
 
                 @Override
                 public void refresh() {
-                    //clear();
+
                 }
             });
         }
diff --git a/src/main/java/com/amaze/filemanager/fragments/ZipViewer.java b/src/main/java/com/amaze/filemanager/fragments/ZipViewer.java
index f49e07579..e9995ffad 100644
--- a/src/main/java/com/amaze/filemanager/fragments/ZipViewer.java
+++ b/src/main/java/com/amaze/filemanager/fragments/ZipViewer.java
@@ -63,7 +63,6 @@ import com.amaze.filemanager.ui.ZipObj;
 import com.amaze.filemanager.ui.views.DividerItemDecoration;
 import com.amaze.filemanager.ui.views.FastScroller;
 import com.amaze.filemanager.utils.OpenMode;
-import com.amaze.filemanager.utils.PreferenceUtils;
 import com.amaze.filemanager.utils.UtilitiesProviderInterface;
 import com.amaze.filemanager.utils.color.ColorUsage;
 import com.amaze.filemanager.utils.theme.AppTheme;
@@ -77,6 +76,7 @@ import java.util.ArrayList;
 import java.util.Calendar;
 
 public class ZipViewer extends Fragment {
+
     private UtilitiesProviderInterface utilsProvider;
     public String s;
     public File f;
@@ -417,9 +417,8 @@ public class ZipViewer extends Fragment {
                 for (int i : rarAdapter.getCheckedItemPositions()) {
                     a.add(elements.get(i).getName());
                 }
-                intent.putExtra("zip", f.getPath());
-                intent.putExtra("entries1", true);
-                intent.putExtra("entries", a);
+                intent.putExtra(ExtractService.KEY_PATH_ZIP, f.getPath());
+                intent.putExtra(ExtractService.KEY_ENTRIES_ZIP, a);
                 getActivity().startService(intent);
             } catch (Exception e) {
                 e.printStackTrace();
diff --git a/src/main/java/com/amaze/filemanager/services/CopyService.java b/src/main/java/com/amaze/filemanager/services/CopyService.java
index 3d0495f48..c73e36db9 100644
--- a/src/main/java/com/amaze/filemanager/services/CopyService.java
+++ b/src/main/java/com/amaze/filemanager/services/CopyService.java
@@ -57,7 +57,8 @@ import java.util.ArrayList;
 
 public class CopyService extends Service {
 
-    public ArrayList<DataPackage> dataPackages = new ArrayList<>();
+    // list of data packages, to initiate chart in process viewer fragment
+    private ArrayList<DataPackage> dataPackages = new ArrayList<>();
     NotificationManager mNotifyManager;
     NotificationCompat.Builder mBuilder;
     Context c;
@@ -66,8 +67,6 @@ public class CopyService extends Service {
     private final IBinder mBinder = new LocalBinder();
     private ProgressHandler progressHandler;
 
-    boolean foreground=true;
-
     long totalSize = 0l;
     int totalSourceFiles = 0;
     int sourceProgress = 0;
@@ -78,13 +77,13 @@ public class CopyService extends Service {
     private static final String TAG_COPY_MOVE = "move";
     private static final String TAG_COPY_START_ID = "id";
 
-    public static final String TAG_COPY_CANCEL_BROADCAST = "copycancel";
+    public static final String TAG_BROADCAST_COPY_CANCEL = "copycancel";
 
     @Override
     public void onCreate() {
         c = getApplicationContext();
 
-        registerReceiver(receiver3, new IntentFilter(TAG_COPY_CANCEL_BROADCAST));
+        registerReceiver(receiver3, new IntentFilter(TAG_BROADCAST_COPY_CANCEL));
     }
 
     @Override
@@ -94,7 +93,8 @@ public class CopyService extends Service {
         ArrayList<BaseFile> files = intent.getParcelableArrayListExtra(TAG_COPY_SOURCES);
         String targetPath = intent.getStringExtra(TAG_COPY_TARGET);
         int mode=intent.getIntExtra(TAG_COPY_OPEN_MODE, 0);
-        totalSize = getTotalBytes(files);
+        totalSize = OpenMode.getOpenMode(mode)==OpenMode.OTG ?
+                getTotalBytes(files, getApplicationContext()) : getTotalBytes(files);
         totalSourceFiles = files.size();
         progressHandler = new ProgressHandler(totalSourceFiles, totalSize);
         mNotifyManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
@@ -102,21 +102,19 @@ public class CopyService extends Service {
         Intent notificationIntent = new Intent(this, MainActivity.class);
         notificationIntent.setAction(Intent.ACTION_MAIN);
         notificationIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-        notificationIntent.putExtra("openprocesses",true);
+        notificationIntent.putExtra(MainActivity.KEY_INTENT_PROCESS_VIEWER, true);
         PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);
         mBuilder = new NotificationCompat.Builder(c);
         mBuilder.setContentIntent(pendingIntent);
         mBuilder.setContentTitle(getResources().getString(R.string.copying))
                 .setSmallIcon(R.drawable.ic_content_copy_white_36dp);
-        if(foreground){
-            startForeground(Integer.parseInt("456"+startId), mBuilder.build());
-            foreground=false;
-        }
+
+        startForeground(Integer.parseInt("456"+startId), mBuilder.build());
+
         b.putBoolean(TAG_COPY_MOVE, intent.getBooleanExtra(TAG_COPY_MOVE, false));
         b.putString(TAG_COPY_TARGET, targetPath);
         b.putInt(TAG_COPY_OPEN_MODE, mode);
         b.putParcelableArrayList(TAG_COPY_SOURCES, files);
-        //hash.put(startId, true);
 
         DataPackage intent1 = new DataPackage();
         intent1.setName(files.get(0).getName());
@@ -124,7 +122,6 @@ public class CopyService extends Service {
         intent1.setSourceProgress(0);
         intent1.setTotal(totalSize);
         intent1.setByteProgress(0);
-        intent1.setId(startId);
         intent1.setSpeedRaw(0);
         intent1.setMove(intent.getBooleanExtra(TAG_COPY_MOVE, false));
         intent1.setCompleted(false);
@@ -158,6 +155,21 @@ public class CopyService extends Service {
         return totalBytes;
     }
 
+    /**
+     * Helper method to calculate source files size in an otg device
+     * @param files
+     * @param context
+     * @return
+     */
+    long getTotalBytes(ArrayList<BaseFile> files, Context context) {
+        long totalBytes = 0;
+        for (BaseFile file : files) {
+            if (file.isDirectory()) totalBytes += file.folderSize(context);
+            else totalBytes += file.length(context);
+        }
+        return totalBytes;
+    }
+
     public void onDestroy() {
         this.unregisterReceiver(receiver3);
     }
@@ -262,7 +274,7 @@ public class CopyService extends Service {
                                     copyRoot(f1, hFile, move);
                                     continue;
                                 }
-                                copyFiles((f1),hFile, copyThread, progressHandler, watcherUtil, id);
+                                copyFiles((f1),hFile, copyThread, progressHandler, watcherUtil);
                                 progressHandler.setSourceFilesCopied(sourceProgress + 1);
                             }
                             else{
@@ -331,11 +343,10 @@ public class CopyService extends Service {
             private void copyFiles(final BaseFile sourceFile, final HFile targetFile,
                                    GenericCopyThread copyThread,
                                    ProgressHandler progressHandler,
-                                   ServiceWatcherUtil watcherUtil,
-                                   final int id) throws IOException {
+                                   ServiceWatcherUtil watcherUtil) throws IOException {
                 Log.e("Copy",sourceFile.getPath());
                 if (sourceFile.isDirectory()) {
-                    if(progressHandler.getCancelled())return;
+                    if(progressHandler.getCancelled()) return;
 
                     if (!targetFile.exists()) targetFile.mkdir(c);
 
@@ -353,7 +364,7 @@ public class CopyService extends Service {
                     for (BaseFile file : filePaths) {
                         HFile destFile = new HFile(targetFile.getMode(),targetFile.getPath(),
                                 file.getName(),file.isDirectory());
-                        copyFiles(file, destFile, copyThread, progressHandler, watcherUtil, id);
+                        copyFiles(file, destFile, copyThread, progressHandler, watcherUtil);
                     }
                     if(progressHandler.getCancelled())return;
                 } else {
@@ -461,7 +472,6 @@ public class CopyService extends Service {
             intent.setSourceProgress(sourceProgress);
             intent.setTotal(totalSize);
             intent.setByteProgress(writtenSize);
-            intent.setId(id);
             intent.setSpeedRaw(speed);
             intent.setMove(move);
             intent.setCompleted(isComplete);
@@ -532,7 +542,6 @@ public class CopyService extends Service {
         @Override
         public void onReceive(Context context, Intent intent) {
             //cancel operation
-            //hash.put(intent.getIntExtra("id", 1), false);
             progressHandler.setCancelled(true);
         }
     };
diff --git a/src/main/java/com/amaze/filemanager/services/ExtractService.java b/src/main/java/com/amaze/filemanager/services/ExtractService.java
index 1e662697a..47ea2fa30 100644
--- a/src/main/java/com/amaze/filemanager/services/ExtractService.java
+++ b/src/main/java/com/amaze/filemanager/services/ExtractService.java
@@ -37,8 +37,11 @@ import android.util.Log;
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.MainActivity;
 import com.amaze.filemanager.filesystem.FileUtil;
+import com.amaze.filemanager.utils.AppConfig;
 import com.amaze.filemanager.utils.DataPackage;
 import com.amaze.filemanager.utils.Futils;
+import com.amaze.filemanager.utils.GenericCopyThread;
+import com.amaze.filemanager.utils.ServiceWatcherUtil;
 import com.github.junrar.Archive;
 import com.github.junrar.rarfile.FileHeader;
 
@@ -51,73 +54,94 @@ import java.io.File;
 import java.io.FileInputStream;
 import java.util.ArrayList;
 import java.util.Enumeration;
-import java.util.HashMap;
 import java.util.zip.GZIPInputStream;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 public class ExtractService extends Service {
 
-    public final String EXTRACT_CONDITION = "EXTRACT_CONDITION";
-
     Context cd;
-    // Binder given to clients
-    HashMap<Integer, Boolean> hash = new HashMap<Integer, Boolean>();
-    public HashMap<Integer, DataPackage> hash1 = new HashMap<Integer, DataPackage>();
-    NotificationManager mNotifyManager;
-    NotificationCompat.Builder mBuilder;
-    ArrayList<String> entries=new ArrayList<String>();
-    boolean eentries;
-    String epath;
+
+    // list of data packages, to initiate chart in process viewer fragment
+    private ArrayList<DataPackage> dataPackages = new ArrayList<>();
+    long totalSize = 0l;    // total size of file, can change later
+
+    private NotificationManager mNotifyManager;
+    private NotificationCompat.Builder mBuilder;
+    private ArrayList<String> entries=new ArrayList<String>();  // names of entries to be extracted
+    private String epath;
+    private ProgressHandler progressHandler;
+
+
+    public static final String KEY_PATH_ZIP = "zip";
+    public static final String KEY_PATH_EXTRACT = "extractpath";
+    public static final String TAG_BROADCAST_EXTRACT_CANCEL = "excancel";
+    public static final String KEY_ENTRIES_ZIP = "entries";
 
     @Override
     public void onCreate() {
-        registerReceiver(receiver1, new IntentFilter("excancel"));
+        registerReceiver(receiver1, new IntentFilter(TAG_BROADCAST_EXTRACT_CANCEL));
         cd=getApplicationContext();
     }
 
-    boolean foreground=true;
-
     @Override
-    public int onStartCommand(Intent intent, int flags, int startId) {
+    public int onStartCommand(Intent intent, int flags, final int startId) {
         Bundle b = new Bundle();
-        b.putInt("id", startId);
-        epath= PreferenceManager.getDefaultSharedPreferences(this).getString("extractpath", "");
-        mNotifyManager =
-                (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
-        String file = intent.getStringExtra("zip");
-        eentries=intent.getBooleanExtra("entries1",false);
-        if(eentries){
-            entries=intent.getStringArrayListExtra("entries");
-        }
-        b.putString("file", file);
+        String file = intent.getStringExtra(KEY_PATH_ZIP);
+        epath = PreferenceManager.getDefaultSharedPreferences(this).getString(KEY_PATH_EXTRACT, file);
+        mNotifyManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
+
+        entries=intent.getStringArrayListExtra(KEY_ENTRIES_ZIP);
+
+        b.putString(KEY_PATH_ZIP, file);
 
-        DataPackage intent1 = new DataPackage();
+        totalSize = getTotalSize(file);
+        progressHandler = new ProgressHandler(1, totalSize);
+
+        progressHandler.setProgressListener(new ProgressHandler.ProgressListener() {
+            @Override
+            public void onProgressed(String fileName, int sourceFiles, int sourceProgress, long totalSize,
+                                     long writtenSize, int speed) {
+                publishResults(startId, fileName, sourceFiles, sourceProgress, totalSize, writtenSize, speed, false);
+            }
+        });
+
+        /*DataPackage intent1 = new DataPackage();
         intent1.setName(file);
-        intent1.setSourceFiles(1);
+        intent1.setSourceFiles(entries==null ? 1 : entries.size());
         intent1.setSourceProgress(0);
-        intent1.setTotal(new File(file).length());
+        intent1.setTotal(totalSize);
         intent1.setByteProgress(0);
-        intent1.setId(startId);
         intent1.setSpeedRaw(0);
         intent1.setMove(false);
         intent1.setCompleted(false);
+        putDataPackage(intent1);*/
 
-        hash1.put(startId, intent1);
         Intent notificationIntent = new Intent(this, MainActivity.class);
         notificationIntent.setAction(Intent.ACTION_MAIN);
-        notificationIntent.putExtra("openprocesses", true);
+        notificationIntent.putExtra(MainActivity.KEY_INTENT_PROCESS_VIEWER, true);
         PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);
         mBuilder = new NotificationCompat.Builder(cd);
         mBuilder.setContentIntent(pendingIntent);
         mBuilder.setContentTitle(getResources().getString(R.string.extracting))
                 .setContentText(new File(file).getName())
                 .setSmallIcon(R.drawable.ic_doc_compressed);
-        hash.put(startId, true);
+        startForeground(Integer.parseInt("123" + startId), mBuilder.build());
 
-        new Doback().execute(b);
+        new DoWork().execute(b);
         return START_STICKY;
     }
 
+    /**
+     * Method calculates zip file size to initiate progress
+     * Supporting local file extraction progress for now
+     * @param filePath
+     * @return
+     */
+    private long getTotalSize(String filePath) {
+
+        return new File(filePath).length();
+    }
+
     private final IBinder mBinder = new LocalBinder();
 
     public class LocalBinder extends Binder {
@@ -138,21 +162,22 @@ public class ExtractService extends Service {
         void refresh();
     }
 
-    private void publishResults(String fileName, int id, long total, long done, boolean isCompleted) {
-        if(hash.get(id)){
+    private void publishResults(int id, String fileName, int sourceFiles, int sourceProgress, long total, long done,
+                                int speed, boolean isCompleted) {
+        if(!progressHandler.getCancelled()) {
             mBuilder.setContentTitle(getResources().getString(R.string.extracting));
 
-            int progressPercent = (int) ((done / total) * 100);
-            mBuilder.setProgress(100, progressPercent, false);
+            float progressPercent = ((float) (done / total) * 100);
+            mBuilder.setProgress(100, Math.round(progressPercent), false);
             mBuilder.setOngoing(true);
             mBuilder.setContentText(fileName + " " + Futils.readableFileSize(done) + "/"
                     + Futils.readableFileSize(total));
             int id1=Integer.parseInt("123"+id);
             mNotifyManager.notify(id1, mBuilder.build());
-            if(progressPercent==100){
-                mBuilder.setContentTitle("Extract completed");
+            if(progressPercent==100 || total == 0){
+                mBuilder.setContentTitle(getString(R.string.extract_complete));
                 mBuilder.setContentText(fileName + " " + Futils.readableFileSize(total));
-                mBuilder.setProgress(0, 0, false);
+                mBuilder.setProgress(100, 100, false);
                 mBuilder.setOngoing(false);
                 mNotifyManager.notify(id1, mBuilder.build());
                 publishCompletedResult("", id1);
@@ -160,22 +185,22 @@ public class ExtractService extends Service {
 
             DataPackage intent = new DataPackage();
             intent.setName(fileName);
-            intent.setSourceFiles(1);
-            intent.setSourceProgress(1);
+            intent.setSourceFiles(sourceFiles);
+            intent.setSourceProgress(sourceProgress);
             intent.setTotal(total);
             intent.setByteProgress(done);
-            intent.setId(id);
-            intent.setSpeedRaw(0);
+            intent.setSpeedRaw(speed);
             intent.setMove(false);
             intent.setCompleted(isCompleted);
+            putDataPackage(intent);
 
-            hash1.put(id,intent);
             if(progressListener!=null){
                 progressListener.onUpdate(intent);
-                if(isCompleted)progressListener.refresh();
+                if(isCompleted) progressListener.refresh();
             }
         } else publishCompletedResult(fileName, Integer.parseInt("123"+id));
     }
+
     public void publishCompletedResult(String a,int id1){
         try {
             mNotifyManager.cancel(id1);
@@ -184,95 +209,61 @@ public class ExtractService extends Service {
         }
     }
 
-    public class Doback extends AsyncTask<Bundle, Void, Integer> {
+    public class DoWork extends AsyncTask<Bundle, Void, Integer> {
 
-        long copiedbytes=0,totalbytes=0;
-        //int lastpercent=0;
+        long totalBytes = 0l;
+        private ServiceWatcherUtil watcherUtil;
 
         private void createDir(File dir) {
-            FileUtil.mkdir(dir,cd);
-        }
-
-        AsyncTask asyncTask;
-        void calculateProgress(final String name, final int id, final boolean completed) {
-            calculateProgress(name,id,completed, copiedbytes, totalbytes);
-        }
-
-        void calculateProgress(final String name,final int id, final boolean completed,final long
-                copiedbytes,final long totalbytes) {
-
-            if(asyncTask!=null && asyncTask.getStatus()==Status.RUNNING)asyncTask.cancel(true);
-
-            asyncTask=new AsyncTask<Void,Void,Void>(){
-                int progressPercent,p2;
-                @Override
-                protected Void doInBackground(Void... voids) {
-                    if(isCancelled()) return null;
-
-                    progressPercent = (int) ((copiedbytes / totalbytes) * 100);
-                    if(isCancelled())return null;
-                    return null;
-                }@Override
-                public void onPostExecute(Void v){
-                    publishResults(name, id, totalbytes, copiedbytes, completed);
-                }
-            }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
-
-        }
-
-        long time=System.nanoTime()/500000000;
-
-        void stop(int b){
-            hash.put(b,false);
-            boolean stop=true;
-            for(int a:hash.keySet()){
-                if(hash.get(a))stop=false;
-            }
-            if(stop)
-                stopSelf(b);
+            FileUtil.mkdir(dir, cd);
         }
 
-        private void unzipEntry(int id, ZipFile zipfile, ZipEntry entry, String outputDir)
+        /**
+         * Method extracts {@link ZipEntry} from {@link ZipFile}
+         * @param zipFile zip file from which entries are to be extracted
+         * @param entry zip entry that is to be extracted
+         * @param outputDir output directory
+         * @throws Exception
+         */
+        private void unzipEntry(ZipFile zipFile, ZipEntry entry, String outputDir)
                 throws Exception {
+
             if (entry.isDirectory()) {
+                // zip entry is a directory, return after creating new directory
                 createDir(new File(outputDir, entry.getName()));
                 return;
             }
-            File outputFile = new File(outputDir, entry.getName());
+
+            final File outputFile = new File(outputDir, entry.getName());
+
             if (!outputFile.getParentFile().exists()) {
+                // creating directory if not already exists
+
                 createDir(outputFile.getParentFile());
             }
-            //	Log.i("Amaze", "Extracting: " + entry);
+
             BufferedInputStream inputStream = new BufferedInputStream(
-                    zipfile.getInputStream(entry));
+                    zipFile.getInputStream(entry));
             BufferedOutputStream outputStream = new BufferedOutputStream(
-                    FileUtil.getOutputStream(outputFile,cd,0));
+                    FileUtil.getOutputStream(outputFile, cd, 0));
             try {
                 int len;
-                byte buf[] = new byte[20480];
+                byte buf[] = new byte[GenericCopyThread.DEFAULT_BUFFER_SIZE];
                 while ((len = inputStream.read(buf)) > 0) {
-                    //System.out.println(id + " " + hash.get(id));
-                    if (hash.get(id)) {
-                        outputStream.write(buf, 0, len);
-                        copiedbytes=copiedbytes+len;
-
-                        long time1=System.nanoTime()/500000000;
-                        if(((int)time1)>((int)(time))){
-                            calculateProgress(zipfile.getName(),id,false);
-                            time=System.nanoTime()/500000000;
-                        }
-                    } else {
 
-                        calculateProgress(zipfile.getName(), id,true, copiedbytes, totalbytes);
-                        cancel(true);
-                    }
+                    outputStream.write(buf, 0, len);
+                    ServiceWatcherUtil.POSITION+=len;
                 }
+            } catch (Exception e) {
+
+                throw new Exception();
             } finally {
                 outputStream.close();
                 inputStream.close();
             }
         }
-        private void unzipRAREntry(int id,String a, Archive zipfile, FileHeader entry, String outputDir)
+
+        private void unzipRAREntry(Archive zipFile, FileHeader entry, String outputDir)
                 throws Exception {
             String name=entry.getFileNameString();
             name=name.replaceAll("\\\\","/");
@@ -286,35 +277,28 @@ public class ExtractService extends Service {
             }
             //	Log.i("Amaze", "Extracting: " + entry);
             BufferedInputStream inputStream = new BufferedInputStream(
-                    zipfile.getInputStream(entry));
+                    zipFile.getInputStream(entry));
             BufferedOutputStream outputStream = new BufferedOutputStream(
                     FileUtil.getOutputStream(outputFile, cd,entry.getFullUnpackSize()));
             try {
                 int len;
-                byte buf[] = new byte[20480];
+                byte buf[] = new byte[GenericCopyThread.DEFAULT_BUFFER_SIZE];
                 while ((len = inputStream.read(buf)) > 0) {
-                    //System.out.println(id + " " + hash.get(id));
-                    if (hash.get(id)) {
-                        outputStream.write(buf, 0, len);
-                        copiedbytes=copiedbytes+len;
-                        long time1=System.nanoTime()/500000000;
-                        if(((int)time1)>((int)(time))){
-                            calculateProgress(a,id,false);
-                            time=System.nanoTime()/500000000;
-                        }
-                    } else {
-                        calculateProgress(a,id,true);
-                        cancel(true);
-                        stop(id);
-                    }
+
+                    outputStream.write(buf, 0, len);
+                    ServiceWatcherUtil.POSITION+=len;
                 }
-            }finally {
+            } catch (Exception e) {
+
+                throw new Exception();
+            } finally {
                 outputStream.close();
                 inputStream.close();
             }
         }
-        private void unzipTAREntry(int id, TarArchiveInputStream zipfile, TarArchiveEntry entry, String outputDir,String string)
-                throws Exception {
+
+        private void unzipTAREntry(TarArchiveInputStream zipFileStream, TarArchiveEntry entry,
+                                   String outputDir) throws Exception {
             String name=entry.getName();
             if (entry.isDirectory()) {
                 createDir(new File(outputDir, name));
@@ -324,209 +308,242 @@ public class ExtractService extends Service {
             if (!outputFile.getParentFile().exists()) {
                 createDir(outputFile.getParentFile());
             }
-            //	Log.i("Amaze", "Extracting: " + entry);
 
             BufferedOutputStream outputStream = new BufferedOutputStream(
                     FileUtil.getOutputStream(outputFile,cd,entry.getRealSize()));
             try {
                 int len;
                 byte buf[] = new byte[20480];
-                while ((len = zipfile.read(buf)) > 0) {
-                    //System.out.println(id + " " + hash.get(id));
-                    if (hash.get(id)) {
-                        outputStream.write(buf, 0, len);
-                        copiedbytes=copiedbytes+len;
-                        long time1=System.nanoTime()/500000000;
-                        if(((int)time1)>((int)(time))){
-                            calculateProgress(string,id,false);
-                            time=System.nanoTime()/500000000;
-                        }
-                    } else {
-                        calculateProgress(string, id, true);
-                        cancel(true);
-                        stop(id);
-                    }
+                while ((len = zipFileStream.read(buf)) > 0) {
+
+                    outputStream.write(buf, 0, len);
+                    ServiceWatcherUtil.POSITION += len;
                 }
-            }finally {
-                outputStream.close();
+            } catch (Exception e) {
 
+                throw new Exception();
+            } finally {
+                outputStream.close();
             }
         }
-        public boolean extract(int id, File archive, String destinationPath,ArrayList<String> x) {
-            int i = 0;
+
+        /**
+         * Helper method to initiate extraction of zip/jar files.
+         * @param archive the file pointing to archive
+         * @param destinationPath the where to extract
+         * @param entryNamesList names of files to be extracted from the archive
+         * @return
+         */
+        public boolean extract(File archive, String destinationPath,
+                               ArrayList<String> entryNamesList) {
+
             ArrayList<ZipEntry> entry1=new ArrayList<ZipEntry>();
             try {
                 ZipFile zipfile = new ZipFile(archive);
-                calculateProgress(archive.getName(), id,false, copiedbytes, totalbytes);
+
+                // iterating archive elements to find file names that are to be extracted
                 for (Enumeration e = zipfile.entries(); e.hasMoreElements(); ) {
-                    if (hash.get(id)) {
-                        ZipEntry entry = (ZipEntry) e.nextElement();
-                        for(String y:x){
-                            if(y.endsWith("/")){
-                                if(entry.getName().contains(y))entry1.add(entry);}
-                            else {if(entry.getName().equals(y) || ("/"+entry.getName()).equals(y)){entry1.add(entry);}}
-                        }
-                        i++;
-                    } else {
-                        cancel(true);
-                        stop(id);
 
+                    ZipEntry entry = (ZipEntry) e.nextElement();
+                    for(String y:entryNamesList){
+                        if(y.endsWith("/")){
+                            if(entry.getName().contains(y))
+                                entry1.add(entry);
+                        } else {
+                            if(entry.getName().equals(y) || ("/"+entry.getName()).equals(y)) {
+                                entry1.add(entry);
+                            }
+                        }
                     }
                 }
-                for (ZipEntry entry:entry1){totalbytes=totalbytes+entry.getSize();}
-                for(ZipEntry entry:entry1){
-                    unzipEntry(id, zipfile, entry, destinationPath);}
+
+                // get the total size of elements to be extracted
+                for (ZipEntry entry:entry1) {
+                    totalBytes+=entry.getSize();
+                }
+
+                // setting total bytes calculated from zip entries
+                progressHandler.setTotalSize(totalBytes);
+
+                watcherUtil = new ServiceWatcherUtil(progressHandler, totalBytes);
+                watcherUtil.watch();
+
+                int sourceProgress = 0;
+                for(ZipEntry entry:entry1) {
+                    progressHandler.setFileName(entry.getName());
+                    unzipEntry(zipfile, entry, destinationPath);
+                    progressHandler.setSourceFilesCopied(++sourceProgress);
+                }
+
                 Intent intent = new Intent("loadlist");
                 sendBroadcast(intent);
-                calculateProgress(archive.getName(), id,true, copiedbytes, totalbytes);
                 return true;
             } catch (Exception e) {
                 Log.e("amaze", "Error while extracting file " + archive, e);
-                Intent intent = new Intent("loadlist");
-                sendBroadcast(intent);
-                calculateProgress(archive.getName(), id,true, copiedbytes, totalbytes);
+                AppConfig.toast(getApplicationContext(), getString(R.string.error));
                 return false;
             }
 
         }
-        public boolean extract(int id, File archive, String destinationPath) {
-            int i = 0;
-            try {ArrayList<ZipEntry> arrayList=new ArrayList<ZipEntry>();
+
+        public boolean extract(File archive, String destinationPath) {
+
+            try {
+                ArrayList<ZipEntry> arrayList=new ArrayList<ZipEntry>();
                 ZipFile zipfile = new ZipFile(archive);
-                calculateProgress(archive.getName(), id, false, copiedbytes, totalbytes);
-                for (Enumeration e = zipfile.entries(); e.hasMoreElements(); ) {
-                    //Log.i("Amaze", id + " " + hash.get(id));
-                    if (hash.get(id)) {
+                for (Enumeration e = zipfile.entries(); e.hasMoreElements();) {
 
-                        ZipEntry entry = (ZipEntry) e.nextElement();
-                        arrayList.add(entry);
-                    } else {
-                        stop(id);
+                    // adding all the elements to be extracted to an array list
+                    ZipEntry entry = (ZipEntry) e.nextElement();
+                    arrayList.add(entry);
+                }
 
-                    }
-                }for(ZipEntry entry:arrayList){totalbytes=totalbytes+entry.getSize();}
-                for (ZipEntry entry : arrayList) {
-                    if (hash.get(id)) {
-                        unzipEntry(id, zipfile, entry, destinationPath);
+                for(ZipEntry entry:arrayList) {
+                    // calculating size of compressed items
+                    totalBytes += entry.getSize();
+                }
 
-                    } else {
-                        stop(id);
+                // setting total bytes calculated from zip entries
+                progressHandler.setTotalSize(totalBytes);
 
-                    }
+                watcherUtil = new ServiceWatcherUtil(progressHandler, totalBytes);
+                watcherUtil.watch();
+
+                for (ZipEntry entry : arrayList) {
+                    progressHandler.setFileName(entry.getName());
+                    unzipEntry(zipfile, entry, destinationPath);
                 }
+
+                // operating finished
+                progressHandler.setSourceFilesCopied(1);
                 Intent intent = new Intent("loadlist");
                 sendBroadcast(intent);
-                calculateProgress(archive.getName(), id, true, copiedbytes, totalbytes);
                 return true;
             } catch (Exception e) {
                 Log.e("amaze", "Error while extracting file " + archive, e);
-                Intent intent = new Intent("loadlist");
-                sendBroadcast(intent);
-                publishResults(archive.getName(), id, totalbytes, 0, true);
+                AppConfig.toast(getApplicationContext(), getString(R.string.error));
                 return false;
             }
 
         }
-        public boolean extractTar(int id, File archive, String destinationPath) {
-            int i = 0;
-            try {ArrayList<TarArchiveEntry> archiveEntries=new ArrayList<TarArchiveEntry>();
+
+        public boolean extractTar(File archive, String destinationPath) {
+
+            try {
+
+                ArrayList<TarArchiveEntry> archiveEntries=new ArrayList<TarArchiveEntry>();
+
                 TarArchiveInputStream inputStream;
+
                 if(archive.getName().endsWith(".tar"))
-                    inputStream=new TarArchiveInputStream(new BufferedInputStream(new FileInputStream(archive)));
-                else inputStream=new TarArchiveInputStream(new GZIPInputStream(new FileInputStream(archive)));
-                publishResults(archive.getName(), id, totalbytes, 0, false);
+                    inputStream =new TarArchiveInputStream(new BufferedInputStream(new FileInputStream(archive)));
+                else inputStream = new TarArchiveInputStream(new GZIPInputStream(new FileInputStream(archive)));
+
                 TarArchiveEntry tarArchiveEntry=inputStream.getNextTarEntry();
+
                 while(tarArchiveEntry != null){
-                    if (hash.get(id)) {
+                    archiveEntries.add(tarArchiveEntry);
+                    tarArchiveEntry=inputStream.getNextTarEntry();
+                }
 
-                        archiveEntries.add(tarArchiveEntry);
-                        tarArchiveEntry=inputStream.getNextTarEntry();
-                    } else {
-                        stop(id);
+                for(TarArchiveEntry entry : archiveEntries) {
+                    totalBytes += entry.getSize();
+                }
 
-                    }
-                }for(TarArchiveEntry entry:archiveEntries){totalbytes=totalbytes+entry.getSize();}
-                for(TarArchiveEntry entry:archiveEntries){
-                    if (hash.get(id)) {
-                        unzipTAREntry(id, inputStream, entry, destinationPath, archive.getName());
-                    } else {
-                        stop(id);
+                // setting total bytes calculated from zip entries
+                progressHandler.setTotalSize(totalBytes);
+
+                watcherUtil = new ServiceWatcherUtil(progressHandler, totalBytes);
+                watcherUtil.watch();
 
-                    }}
+                for(TarArchiveEntry entry : archiveEntries){
+
+                    progressHandler.setFileName(entry.getName());
+                    unzipTAREntry(inputStream, entry, destinationPath);
+                }
 
+                // operating finished
+                progressHandler.setSourceFilesCopied(1);
                 inputStream.close();
 
                 Intent intent = new Intent("loadlist");
                 sendBroadcast(intent);
-                publishResults(archive.getName(), id, totalbytes, copiedbytes, true);
                 return true;
             } catch (Exception e) {
                 Log.e("amaze", "Error while extracting file " + archive, e);
-                Intent intent = new Intent("loadlist");
-                sendBroadcast(intent);
-                publishResults(archive.getName(), id, totalbytes, 0,true);
+                AppConfig.toast(getApplicationContext(), getString(R.string.error));
                 return false;
             }
 
         }
-        public boolean extractRar(int id, File archive, String destinationPath) {
-            int i = 0;
-            try {ArrayList<FileHeader> arrayList=new ArrayList<FileHeader>();
-                Archive zipfile = new Archive(archive);
-                FileHeader fh = zipfile.nextFileHeader();
-                publishResults(archive.getName(), id, totalbytes, 0,false);
+        public boolean extractRar(File archive, String destinationPath) {
+
+            try {
+                ArrayList<FileHeader> arrayList=new ArrayList<FileHeader>();
+                Archive zipFile = new Archive(archive);
+                FileHeader fh = zipFile.nextFileHeader();
+
                 while(fh != null){
-                    if (hash.get(id)) {
+                    arrayList.add(fh);
+                    fh=zipFile.nextFileHeader();
 
-                        arrayList.add(fh);
-                        fh=zipfile.nextFileHeader();
-                    } else {
-                        stop(id);
+                }
 
-                    }
+                for (FileHeader header:arrayList) {
+                    totalBytes += header.getFullUnpackSize();
                 }
-                for (FileHeader header:arrayList){totalbytes=totalbytes+header.getFullUnpackSize();}
+
+                // setting total bytes calculated from zip entries
+                progressHandler.setTotalSize(totalBytes);
+
+                watcherUtil = new ServiceWatcherUtil(progressHandler, totalBytes);
+                watcherUtil.watch();
+
                 for (FileHeader header:arrayList){
-                    if (hash.get(id)) {
-                        unzipRAREntry(id, archive.getName(), zipfile, header, destinationPath);
-                    } else {
-                        stop(id);
 
-                    }
+                    progressHandler.setFileName(header.getFileNameString());
+                    unzipRAREntry(zipFile, header, destinationPath);
                 }
+
+                progressHandler.setSourceFilesCopied(1);
                 Intent intent = new Intent("loadlist");
                 sendBroadcast(intent);
-                calculateProgress(archive.getName(), id, true, copiedbytes, totalbytes);
                 return true;
             } catch (Exception e) {
                 Log.e("amaze", "Error while extracting file " + archive, e);
-                Intent intent = new Intent("loadlist");
-                sendBroadcast(intent);
-                calculateProgress(archive.getName(), id,true, copiedbytes, totalbytes);
+                AppConfig.toast(getApplicationContext(), getString(R.string.error));
                 return false;
             }
         }
 
         protected Integer doInBackground(Bundle... p1) {
-            String file = p1[0].getString("file");
 
+            String file = p1[0].getString(KEY_PATH_ZIP);
 
             File f = new File(file);
+
             String path;
-            if(epath.length()==0){
+            if(epath.equals(file)){
+
+                // custom extraction path not set, extract at default path
                 path=f.getParent()+"/"+f.getName().substring(0,f.getName().lastIndexOf("."));
-            }else{
-                if(epath.endsWith("/")){path=epath+f.getName().substring(0,f.getName().lastIndexOf("."));}
-                else {path=epath+"/"+f.getName().substring(0,f.getName().lastIndexOf("."));}
+            } else{
+
+                if(epath.endsWith("/")) {
+                    path=epath+f.getName().substring(0,f.getName().lastIndexOf("."));
+                } else {
+                    path=epath+"/"+f.getName().substring(0,f.getName().lastIndexOf("."));
+                }
             }
-            if(eentries) {
-                extract(p1[0].getInt("id"), f,path, entries);
-            }else if(f.getName().toLowerCase().endsWith(".zip") || f.getName().toLowerCase().endsWith(".jar") || f.getName().toLowerCase().endsWith(".apk"))
-                extract(p1[0].getInt("id"), f,path);
+
+            if(entries!=null && entries.size()!=0) {
+                extract(f, path, entries);
+            } else if(f.getName().toLowerCase().endsWith(".zip") || f.getName().toLowerCase().endsWith(".jar") || f.getName().toLowerCase().endsWith(".apk"))
+                extract(f, path);
             else if(f.getName().toLowerCase().endsWith(".rar"))
-                extractRar(p1[0].getInt("id"), f, path);
+                extractRar(f, path);
             else if(f.getName().toLowerCase().endsWith(".tar") || f.getName().toLowerCase().endsWith(".tar.gz"))
-                extractTar(p1[0].getInt("id"), f, path);
+                extractTar(f, path);
             Log.i("Amaze", "Almost Completed");
             // TODO: Implement this method
             return p1[0].getInt("id");
@@ -534,7 +551,7 @@ public class ExtractService extends Service {
 
         @Override
         public void onPostExecute(Integer b) {
-            stop(b);
+            stopSelf();
         }
 
 
@@ -554,8 +571,7 @@ public class ExtractService extends Service {
 
         @Override
         public void onReceive(Context context, Intent intent) {
-            Log.i("Amaze", "" + intent.getIntExtra("id", 1));
-            hash.put(intent.getIntExtra("id", 1), false);
+            progressHandler.setCancelled(true);
         }
     };
 
@@ -563,5 +579,29 @@ public class ExtractService extends Service {
     public IBinder onBind(Intent arg0) {
         // TODO Auto-generated method stub
         return mBinder;
-    }}
+    }
+
+    /**
+     * Returns the {@link #dataPackages} list which contains
+     * data to be transferred to {@link com.amaze.filemanager.fragments.ProcessViewer}
+     * Method call is synchronized so as to avoid modifying the list
+     * by {@link ServiceWatcherUtil#handlerThread} while {@link MainActivity#runOnUiThread(Runnable)}
+     * is executing the callbacks in {@link com.amaze.filemanager.fragments.ProcessViewer}
+     * @return
+     */
+    public synchronized ArrayList<DataPackage> getDataPackageList() {
+        return this.dataPackages;
+    }
+
+    /**
+     * Puts a {@link DataPackage} into a list
+     * Method call is synchronized so as to avoid modifying the list
+     * by {@link ServiceWatcherUtil#handlerThread} while {@link MainActivity#runOnUiThread(Runnable)}
+     * is executing the callbacks in {@link com.amaze.filemanager.fragments.ProcessViewer}
+     * @param dataPackage
+     */
+    private synchronized void putDataPackage(DataPackage dataPackage) {
+        this.dataPackages.add(dataPackage);
+    }
+}
 
diff --git a/src/main/java/com/amaze/filemanager/services/ProgressHandler.java b/src/main/java/com/amaze/filemanager/services/ProgressHandler.java
index 8f43c26dd..14027a314 100644
--- a/src/main/java/com/amaze/filemanager/services/ProgressHandler.java
+++ b/src/main/java/com/amaze/filemanager/services/ProgressHandler.java
@@ -70,6 +70,11 @@ public class ProgressHandler {
         this.sourceFilesCopied = sourceFilesCopied;
     }
 
+    // dynamically setting total size, useful in case files are compressed
+    public synchronized void setTotalSize(long totalSize) {
+        this.totalSize = totalSize;
+    }
+
     public synchronized void setCancelled(boolean isCancelled) {
         this.isCancelled = isCancelled;
     }
diff --git a/src/main/java/com/amaze/filemanager/services/ZipTask.java b/src/main/java/com/amaze/filemanager/services/ZipTask.java
index 5d4cb1de2..9822e0bee 100644
--- a/src/main/java/com/amaze/filemanager/services/ZipTask.java
+++ b/src/main/java/com/amaze/filemanager/services/ZipTask.java
@@ -97,7 +97,7 @@ public class ZipTask extends Service {
         intent1.setSourceProgress(0);
         intent1.setTotal(new File(zpath).length());
         intent1.setByteProgress(0);
-        intent1.setId(startId);
+        //intent1.setId(startId);
         intent1.setSpeedRaw(0);
         intent1.setMove(false);
         intent1.setCompleted(false);
@@ -210,7 +210,7 @@ public class ZipTask extends Service {
             intent.setSourceProgress(1);
             intent.setTotal(total);
             intent.setByteProgress(done);
-            intent.setId(id);
+            //intent.setId(id);
             intent.setSpeedRaw(0);
             intent.setMove(false);
             intent.setCompleted(isCompleted);
diff --git a/src/main/java/com/amaze/filemanager/utils/AppConfig.java b/src/main/java/com/amaze/filemanager/utils/AppConfig.java
index 5a35deeb1..31f8de3e5 100644
--- a/src/main/java/com/amaze/filemanager/utils/AppConfig.java
+++ b/src/main/java/com/amaze/filemanager/utils/AppConfig.java
@@ -1,8 +1,11 @@
 package com.amaze.filemanager.utils;
 
 import android.app.Application;
+import android.content.Context;
+import android.os.Handler;
 import android.os.StrictMode;
 import android.text.TextUtils;
+import android.widget.Toast;
 
 import com.android.volley.Request;
 import com.android.volley.RequestQueue;
@@ -19,6 +22,7 @@ public class AppConfig extends Application {
 
     private RequestQueue mRequestQueue;
     private ImageLoader mImageLoader;
+    private static Handler mApplicationHandler = new Handler();
 
     private static AppConfig mInstance;
 
@@ -32,6 +36,44 @@ public class AppConfig extends Application {
         StrictMode.setVmPolicy(builder.build());
     }
 
+    /**
+     * Shows a toast message
+     *
+     * @param context Any context belonging to this application
+     * @param message The message to show
+     */
+    public static void toast(Context context, String message) {
+        // this is a static method so it is easier to call,
+        // as the context checking and casting is done for you
+
+        if (context == null) return;
+
+        if (!(context instanceof Application)) {
+            context = context.getApplicationContext();
+        }
+
+        if (context instanceof Application) {
+            final Context c = context;
+            final String m = message;
+
+            ((AppConfig) context).runInApplicationThread(new Runnable() {
+                @Override
+                public void run() {
+                    Toast.makeText(c, m, Toast.LENGTH_LONG).show();
+                }
+            });
+        }
+    }
+
+    /**
+     * Run a runnable in the main application thread
+     *
+     * @param r Runnable to run
+     */
+    public void runInApplicationThread(Runnable r) {
+        mApplicationHandler.post(r);
+    }
+
     public static synchronized AppConfig getInstance() {
         return mInstance;
     }
diff --git a/src/main/java/com/amaze/filemanager/utils/DataPackage.java b/src/main/java/com/amaze/filemanager/utils/DataPackage.java
index 07f3503a5..62f1c3d94 100644
--- a/src/main/java/com/amaze/filemanager/utils/DataPackage.java
+++ b/src/main/java/com/amaze/filemanager/utils/DataPackage.java
@@ -12,8 +12,6 @@ import android.os.Parcelable;
  */
 public class DataPackage implements Parcelable {
 
-    int id;
-
     // which file is being copied from total number of files
     int sourceProgress;
 
@@ -37,7 +35,6 @@ public class DataPackage implements Parcelable {
     public DataPackage(){}
 
     protected DataPackage(Parcel in) {
-        id = in.readInt();
         sourceProgress = in.readInt();
         byteProgress = in.readLong();
         sourceFiles = in.readInt();
@@ -60,14 +57,6 @@ public class DataPackage implements Parcelable {
         }
     };
 
-    public int getId() {
-        return id;
-    }
-
-    public void setId(int id) {
-        this.id = id;
-    }
-
     public String getName() {
         return name;
     }
@@ -139,7 +128,6 @@ public class DataPackage implements Parcelable {
 
     @Override
     public void writeToParcel(Parcel dest, int flags) {
-        dest.writeInt(id);
         dest.writeInt(sourceProgress);
         dest.writeLong(byteProgress);
         dest.writeInt(sourceFiles);
diff --git a/src/main/java/com/amaze/filemanager/utils/Futils.java b/src/main/java/com/amaze/filemanager/utils/Futils.java
index 5c4eb22e1..bd03f1c03 100644
--- a/src/main/java/com/amaze/filemanager/utils/Futils.java
+++ b/src/main/java/com/amaze/filemanager/utils/Futils.java
@@ -186,6 +186,22 @@ public class Futils {
         return length;
     }
 
+    /**
+     * Helper method to get size of an otg folder
+     * @param path
+     * @param context
+     * @return
+     */
+    public static long folderSize(String path, Context context) {
+        long length = 0l;
+        for (BaseFile baseFile : RootHelper.getDocumentFilesList(path, context)) {
+            if (baseFile.isDirectory()) length += folderSize(baseFile.getPath(), context);
+            else length += baseFile.length();
+
+        }
+        return length;
+    }
+
     public static void setTint(CheckBox box, int color) {
         if(Build.VERSION.SDK_INT>=21)return;
         ColorStateList sl = new ColorStateList(new int[][]{
diff --git a/src/main/java/com/amaze/filemanager/utils/GenericCopyThread.java b/src/main/java/com/amaze/filemanager/utils/GenericCopyThread.java
index cc931307f..58c6e4296 100644
--- a/src/main/java/com/amaze/filemanager/utils/GenericCopyThread.java
+++ b/src/main/java/com/amaze/filemanager/utils/GenericCopyThread.java
@@ -16,6 +16,7 @@ import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.RandomAccessFile;
+import java.nio.ByteBuffer;
 import java.nio.MappedByteBuffer;
 import java.nio.channels.FileChannel;
 
@@ -33,6 +34,8 @@ public class GenericCopyThread implements Runnable {
 
     public Thread thread;
 
+    public static final int DEFAULT_BUFFER_SIZE =  8192;
+
     public GenericCopyThread(Context context) {
         this.mContext = context;
     }
@@ -58,7 +61,7 @@ public class GenericCopyThread implements Runnable {
             } else if (mSourceFile.isSmb()) {
 
                 // source is in smb
-                bufferedInputStream = new BufferedInputStream(mSourceFile.getInputStream(), 8192);
+                bufferedInputStream = new BufferedInputStream(mSourceFile.getInputStream(), DEFAULT_BUFFER_SIZE);
             } else {
 
                 // source file is neither smb nor otg; getting a channel from direct file instead of stream
@@ -75,7 +78,7 @@ public class GenericCopyThread implements Runnable {
                 outChannel = ((FileOutputStream) contentResolver.openOutputStream(documentTargetFile.getUri())).getChannel();
             } else if (mTargetFile.isSmb()) {
 
-                bufferedOutputStream = new BufferedOutputStream(mTargetFile.getOutputStream(mContext), 8192);
+                bufferedOutputStream = new BufferedOutputStream(mTargetFile.getOutputStream(mContext), DEFAULT_BUFFER_SIZE);
             } else {
                 // copying normal file, target not in OTG
                 outChannel = new RandomAccessFile(new File(mTargetFile.getPath()), "rw").getChannel();
@@ -134,14 +137,12 @@ public class GenericCopyThread implements Runnable {
         MappedByteBuffer byteBuffer = outChannel.map(FileChannel.MapMode.READ_WRITE, 0,
                 mSourceFile.getSize());
         int count;
-        byte[] buffer = new byte[8192];
+        byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
         do {
             count = bufferedInputStream.read(buffer);
             if (count!=-1) {
-                for (int i=0; i<count; i++) {
-                    byteBuffer.put(buffer[i]);
-                }
 
+                byteBuffer.put(buffer, 0, count);
                 ServiceWatcherUtil.POSITION+=count;
             }
         } while (count!=-1);
@@ -157,19 +158,24 @@ public class GenericCopyThread implements Runnable {
             outByteBuffer.put(inByteBuffer.get());
             ServiceWatcherUtil.POSITION++;
         }
+        int count;
+        byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
+        while (inByteBuffer.hasRemaining()) {
+            ByteBuffer byteBuffer = inByteBuffer.get(buffer);
+            count = byteBuffer.capacity();
+            outByteBuffer.put(byteBuffer.array(), 0, count);
+        }
     }
 
     private void copyFile(BufferedInputStream bufferedInputStream, BufferedOutputStream bufferedOutputStream)
             throws IOException{
         int count;
-        byte[] buffer = new byte[8192];
+        byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
         do {
             count = bufferedInputStream.read(buffer);
             if (count!=-1) {
-                for (int i=0; i<count; i++) {
-                    bufferedOutputStream.write(buffer[i]);
-                }
 
+                bufferedOutputStream.write(buffer, 0 , count);
                 ServiceWatcherUtil.POSITION+=count;
             }
         } while (count!=-1);
@@ -179,7 +185,7 @@ public class GenericCopyThread implements Runnable {
     private void copyFile(FileChannel inChannel, BufferedOutputStream bufferedOutputStream)
             throws IOException {
         MappedByteBuffer inBuffer = inChannel.map(FileChannel.MapMode.READ_ONLY, 0, mSourceFile.getSize());
-        byte[] buffer = new byte[8192];
+        byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
         int length, oldPosition, newPosition;
         do {
 
@@ -188,9 +194,8 @@ public class GenericCopyThread implements Runnable {
             newPosition = inBuffer.position();
             length = newPosition-oldPosition;
             if (length!=0) {
-                for (int i=0; i<length; i++) {
-                    bufferedOutputStream.write(buffer[i]);
-                }
+
+                bufferedOutputStream.write(buffer, 0, length);
                 ServiceWatcherUtil.POSITION+=length;
             }
         } while (length==0);
diff --git a/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java b/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java
index c9c9a7036..ba0a3477b 100644
--- a/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java
+++ b/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java
@@ -485,8 +485,8 @@ public class MainActivityHelper {
             mainActivity.operation = DataUtils.EXTRACT;
         } else if (mode == 1) {
             Intent intent = new Intent(mainActivity, ExtractService.class);
-            intent.putExtra("zip", file.getPath());
-            mainActivity.startService(intent);
+            intent.putExtra(ExtractService.KEY_PATH_ZIP, file.getPath());
+            ServiceWatcherUtil.runService(mainActivity, intent);
         } else Toast.makeText(mainActivity, R.string.not_allowed, Toast.LENGTH_SHORT).show();
     }
 
diff --git a/src/main/java/com/amaze/filemanager/utils/ServiceWatcherUtil.java b/src/main/java/com/amaze/filemanager/utils/ServiceWatcherUtil.java
index 130c47ea9..2cb1e23a9 100644
--- a/src/main/java/com/amaze/filemanager/utils/ServiceWatcherUtil.java
+++ b/src/main/java/com/amaze/filemanager/utils/ServiceWatcherUtil.java
@@ -32,6 +32,8 @@ public class ServiceWatcherUtil {
     // position of byte in total byte size to be copied
     public static long POSITION = 0L;
 
+    public static final int ID_NOTIFICATION_WAIT =  9248;
+
     /**
      *
      * @param progressHandler to publish progress after certain delay
@@ -91,6 +93,18 @@ public class ServiceWatcherUtil {
         if (handlerThread==null || !handlerThread.isAlive()) {
             // we're not bound, no need to proceed further and waste up resources
             // start the service directly
+
+            /**
+             * We can actually end up racing at this point with the {@link HandlerThread} started
+             * in {@link #init(Context)}. If older service has returned, we already have the runnable
+             * waiting to execute in #init, and user is in app, and starts another service, and
+             * as this block executes the {@link android.app.Service#onStartCommand(Intent, int, int)}
+             * we end up with a context switch to 'service_startup_watcher' in #init, it also starts
+             * a new service (as {@link #progressHandler} is not alive yet).
+             * Though chances are very slim, but even if this condition occurs, only the progress will
+             * be flawed, but the actual operation will go fine, due to android's native serial service
+             * execution. #nough' said!
+             */
             context.startService(intent);
             return;
         }
@@ -121,7 +135,7 @@ public class ServiceWatcherUtil {
         mBuilder.setAutoCancel(false);
         mBuilder.setSmallIcon(R.drawable.ic_all_inclusive_white_36dp);
         mBuilder.setProgress(0, 0, true);
-        notificationManager.notify(9248, mBuilder.build());
+        notificationManager.notify(ID_NOTIFICATION_WAIT, mBuilder.build());
 
         Runnable runnable = new Runnable() {
             @Override
@@ -135,7 +149,7 @@ public class ServiceWatcherUtil {
 
                     if (pendingIntents.size()==0) {
                         // we've done all the work, free up resources (if not already killed by system)
-                        notificationManager.cancel(9248);
+                        notificationManager.cancel(ID_NOTIFICATION_WAIT);
                         handler.removeCallbacks(this);
                         waitingThread.quit();
                         return;
diff --git a/src/play/java/com/amaze/filemanager/activities/MainActivity.java b/src/play/java/com/amaze/filemanager/activities/MainActivity.java
index c24a05a2f..bb13fa528 100644
--- a/src/play/java/com/amaze/filemanager/activities/MainActivity.java
+++ b/src/play/java/com/amaze/filemanager/activities/MainActivity.java
@@ -192,6 +192,9 @@ public class MainActivity extends BaseActivity implements
     int hidemode;
     public int operation = -1;
     public ArrayList<BaseFile> oparrayList;
+
+    // oppathe - the path at which certain operation needs to be performed
+    // oppathe1 - the new path which user wants to create/modify
     public String oppathe, oppathe1;
     MaterialDialog materialDialog;
     String newPath = null;
@@ -238,6 +241,7 @@ public class MainActivity extends BaseActivity implements
 
     private static final int REQUEST_CODE_SAF = 223;
     public static final String KEY_PREF_OTG = "uri_usb_otg";
+    public static final String KEY_INTENT_PROCESS_VIEWER = "openprocesses";
 
     // the current visible tab, either 0 or 1
     public static int currentTab;
@@ -308,7 +312,7 @@ public class MainActivity extends BaseActivity implements
             }
         };
         path = getIntent().getStringExtra("path");
-        openprocesses = getIntent().getBooleanExtra("openprocesses", false);
+        openprocesses = getIntent().getBooleanExtra(KEY_INTENT_PROCESS_VIEWER, false);
         try {
             intent = getIntent();
             if (intent.getStringArrayListExtra("failedOps") != null) {
@@ -2486,7 +2490,7 @@ public class MainActivity extends BaseActivity implements
             if (failedOps != null) {
                 mainActivityHelper.showFailedOperationDialog(failedOps, i.getBooleanExtra("move", false), this);
             }
-        } else if ((openprocesses = i.getBooleanExtra("openprocesses", false))) {
+        } else if ((openprocesses = i.getBooleanExtra(KEY_INTENT_PROCESS_VIEWER, false))) {
 
             android.support.v4.app.FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
             transaction.replace(R.id.content_frame, new ProcessViewer());
