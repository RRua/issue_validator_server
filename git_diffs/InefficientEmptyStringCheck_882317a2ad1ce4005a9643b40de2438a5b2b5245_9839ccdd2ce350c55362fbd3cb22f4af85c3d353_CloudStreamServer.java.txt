diff --git a/app/src/androidTest/java/com/amaze/filemanager/asynchronous/services/ftp/FtpServiceEspressoTest.kt b/app/src/androidTest/java/com/amaze/filemanager/asynchronous/services/ftp/FtpServiceEspressoTest.kt
index 662014daf..02cdb4d94 100644
--- a/app/src/androidTest/java/com/amaze/filemanager/asynchronous/services/ftp/FtpServiceEspressoTest.kt
+++ b/app/src/androidTest/java/com/amaze/filemanager/asynchronous/services/ftp/FtpServiceEspressoTest.kt
@@ -55,11 +55,11 @@ import java.net.SocketException
 import java.security.SecureRandom
 import java.util.concurrent.TimeUnit
 
+// Require UIAutomator if need to run test on Android 11
+// in order to obtain MANAGE_EXTERNAL_STORAGE permission
 @RunWith(AndroidJUnit4::class)
 @Suppress("StringLiteralDuplication")
 @androidx.test.filters.Suppress
-// Require UIAutomator if need to run test on Android 11
-// in order to obtain MANAGE_EXTERNAL_STORAGE permission
 class FtpServiceEspressoTest {
 
     @get:Rule
diff --git a/app/src/androidTest/java/com/amaze/filemanager/asynchronous/services/ftp/FtpServiceStaticMethodsTest.kt b/app/src/androidTest/java/com/amaze/filemanager/asynchronous/services/ftp/FtpServiceStaticMethodsTest.kt
index 717be406b..830e55fe9 100644
--- a/app/src/androidTest/java/com/amaze/filemanager/asynchronous/services/ftp/FtpServiceStaticMethodsTest.kt
+++ b/app/src/androidTest/java/com/amaze/filemanager/asynchronous/services/ftp/FtpServiceStaticMethodsTest.kt
@@ -53,8 +53,9 @@ class FtpServiceStaticMethodsTest {
          */
         if (SDK_INT >= N_MR1) {
             ApplicationProvider.getApplicationContext<Context>().run {
-                if (!FtpService.isConnectedToLocalNetwork(this))
+                if (!FtpService.isConnectedToLocalNetwork(this)) {
                     fail("Please connect your device to network to run this test!")
+                }
 
                 FtpService.getLocalInetAddress(this).also {
                     assertNotNull(it)
diff --git a/app/src/androidTest/java/com/amaze/filemanager/database/UtilsHandlerTest.java b/app/src/androidTest/java/com/amaze/filemanager/database/UtilsHandlerTest.java
index 8fdb6aa03..231b7920d 100644
--- a/app/src/androidTest/java/com/amaze/filemanager/database/UtilsHandlerTest.java
+++ b/app/src/androidTest/java/com/amaze/filemanager/database/UtilsHandlerTest.java
@@ -23,6 +23,18 @@ package com.amaze.filemanager.database;
 import static org.awaitility.Awaitility.await;
 import static org.junit.Assert.assertEquals;
 
+import java.io.File;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import com.amaze.filemanager.database.models.OperationData;
+import com.amaze.filemanager.filesystem.ssh.SshClientUtils;
+
 import android.content.Context;
 import android.os.Environment;
 
@@ -31,18 +43,6 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import androidx.test.filters.Suppress;
 import androidx.test.platform.app.InstrumentationRegistry;
 
-import com.amaze.filemanager.database.models.OperationData;
-import com.amaze.filemanager.filesystem.ssh.SshClientUtils;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import java.io.File;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-
 @RunWith(AndroidJUnit4.class)
 public class UtilsHandlerTest {
 
@@ -129,16 +129,14 @@ public class UtilsHandlerTest {
             null,
             null));
 
-    await()
-        .atMost(10, TimeUnit.SECONDS)
-        .until(() -> utilsHandler.getSftpList().size() > 0);
+    await().atMost(10, TimeUnit.SECONDS).until(() -> utilsHandler.getSftpList().size() > 0);
 
     List<String[]> result = utilsHandler.getSftpList();
     assertEquals(1, result.size());
     assertEquals("Test", result.get(0)[0]);
     assertEquals(encryptedPath, result.get(0)[1]);
     assertEquals(
-            "00:11:22:33:44:55:66:77:88:99:aa:bb:cc:dd:ee:ff",
-            utilsHandler.getSshHostKey(encryptedPath));
+        "00:11:22:33:44:55:66:77:88:99:aa:bb:cc:dd:ee:ff",
+        utilsHandler.getSshHostKey(encryptedPath));
   }
 }
diff --git a/app/src/androidTest/java/com/amaze/filemanager/filesystem/HybridFileParcelableTest.java b/app/src/androidTest/java/com/amaze/filemanager/filesystem/HybridFileParcelableTest.java
index 0dee255b4..4317c3a4c 100644
--- a/app/src/androidTest/java/com/amaze/filemanager/filesystem/HybridFileParcelableTest.java
+++ b/app/src/androidTest/java/com/amaze/filemanager/filesystem/HybridFileParcelableTest.java
@@ -25,7 +25,7 @@ import static org.junit.Assert.assertEquals;
 import org.junit.Before;
 import org.junit.Test;
 
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 
 import android.os.Parcel;
 
diff --git a/app/src/androidTest/java/com/amaze/filemanager/test/StoragePermissionHelper.kt b/app/src/androidTest/java/com/amaze/filemanager/test/StoragePermissionHelper.kt
index f95a4ddb6..b491fc0fd 100644
--- a/app/src/androidTest/java/com/amaze/filemanager/test/StoragePermissionHelper.kt
+++ b/app/src/androidTest/java/com/amaze/filemanager/test/StoragePermissionHelper.kt
@@ -1,3 +1,23 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.test
 
 // import android.content.Intent
diff --git a/app/src/androidTest/java/com/amaze/filemanager/utils/CryptUtilEspressoTest.kt b/app/src/androidTest/java/com/amaze/filemanager/utils/CryptUtilEspressoTest.kt
index f25bf3347..ef67fbb2d 100644
--- a/app/src/androidTest/java/com/amaze/filemanager/utils/CryptUtilEspressoTest.kt
+++ b/app/src/androidTest/java/com/amaze/filemanager/utils/CryptUtilEspressoTest.kt
@@ -1,3 +1,23 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.utils
 
 import android.os.Build.VERSION.SDK_INT
@@ -50,7 +70,10 @@ class CryptUtilEspressoTest {
             false,
             null
         )
-        val targetFile = File(Environment.getExternalStorageDirectory(), "test.bin${CryptUtil.CRYPT_EXTENSION}")
+        val targetFile = File(
+            Environment.getExternalStorageDirectory(),
+            "test.bin${CryptUtil.CRYPT_EXTENSION}"
+        )
         assertTrue(targetFile.exists())
         if (SDK_INT < JELLY_BEAN_MR2) {
             // Quirks for SDK < 18. File is not encrypted at all.
@@ -98,9 +121,15 @@ class CryptUtilEspressoTest {
             true,
             "12345678"
         )
-        val targetFile = File(Environment.getExternalStorageDirectory(), "test.bin${CryptUtil.AESCRYPT_EXTENSION}")
+        val targetFile = File(
+            Environment.getExternalStorageDirectory(),
+            "test.bin${CryptUtil.AESCRYPT_EXTENSION}"
+        )
         assertTrue(targetFile.exists())
-        assertTrue("Source size = ${source.size} target file size = ${targetFile.length()}", targetFile.length() > source.size)
+        assertTrue(
+            "Source size = ${source.size} target file size = ${targetFile.length()}",
+            targetFile.length() > source.size
+        )
         sourceFile.delete()
         CryptUtil(
             AppConfig.getInstance(),
diff --git a/app/src/androidTest/java/com/amaze/filemanager/utils/security/SecretKeygenEspressoTest.kt b/app/src/androidTest/java/com/amaze/filemanager/utils/security/SecretKeygenEspressoTest.kt
index ada619d90..773113c16 100644
--- a/app/src/androidTest/java/com/amaze/filemanager/utils/security/SecretKeygenEspressoTest.kt
+++ b/app/src/androidTest/java/com/amaze/filemanager/utils/security/SecretKeygenEspressoTest.kt
@@ -1,3 +1,23 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.utils.security
 
 import android.os.Build.VERSION.SDK_INT
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/AppsRecyclerAdapter.kt b/app/src/main/java/com/amaze/filemanager/adapters/AppsRecyclerAdapter.kt
index ed22fa534..7f4022e69 100644
--- a/app/src/main/java/com/amaze/filemanager/adapters/AppsRecyclerAdapter.kt
+++ b/app/src/main/java/com/amaze/filemanager/adapters/AppsRecyclerAdapter.kt
@@ -51,7 +51,7 @@ import com.amaze.filemanager.adapters.holders.SpecialViewHolder
 import com.amaze.filemanager.asynchronous.asynctasks.DeleteTask
 import com.amaze.filemanager.asynchronous.management.ServiceWatcherUtil
 import com.amaze.filemanager.asynchronous.services.CopyService
-import com.amaze.filemanager.file_operations.filesystem.OpenMode
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode
 import com.amaze.filemanager.filesystem.HybridFileParcelable
 import com.amaze.filemanager.filesystem.RootHelper
 import com.amaze.filemanager.filesystem.files.FileUtils
@@ -61,7 +61,7 @@ import com.amaze.filemanager.ui.activities.superclasses.ThemedActivity
 import com.amaze.filemanager.ui.dialogs.OpenFileDialogFragment.Companion.buildIntent
 import com.amaze.filemanager.ui.dialogs.OpenFileDialogFragment.Companion.setLastOpenedApp
 import com.amaze.filemanager.ui.fragments.AdjustListViewForTv
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants
 import com.amaze.filemanager.ui.startActivityCatchingSecurityException
 import com.amaze.filemanager.ui.theme.AppTheme
 import com.amaze.filemanager.utils.AnimUtils.marqueeAfterDelay
@@ -128,12 +128,14 @@ class AppsRecyclerAdapter(
             TYPE_HEADER_SYSTEM, TYPE_HEADER_THIRD_PARTY -> {
                 view = mInflater.inflate(R.layout.list_header, parent, false)
                 return SpecialViewHolder(
-                    fragment.requireContext(), view,
+                    fragment.requireContext(),
+                    view,
                     (fragment.requireActivity() as MainActivity).utilsProvider,
-                    if (viewType == TYPE_HEADER_SYSTEM)
+                    if (viewType == TYPE_HEADER_SYSTEM) {
                         SpecialViewHolder.HEADER_SYSTEM_APP
-                    else
+                    } else {
                         SpecialViewHolder.HEADER_USER_APP
+                    }
                 )
             }
             EMPTY_LAST_ITEM -> {
@@ -186,8 +188,11 @@ class AppsRecyclerAdapter(
                     (fragment.requireActivity() as MainActivity)
                         .getBoolean(PreferencesConstants.PREFERENCE_ENABLE_MARQUEE_FILENAME)
                 if (enableMarqueeFilename) {
-                    holder.txtTitle.ellipsize = if (enableMarqueeFilename)
-                        TextUtils.TruncateAt.MARQUEE else TextUtils.TruncateAt.MIDDLE
+                    holder.txtTitle.ellipsize = if (enableMarqueeFilename) {
+                        TextUtils.TruncateAt.MARQUEE
+                    } else {
+                        TextUtils.TruncateAt.MIDDLE
+                    }
                     marqueeAfterDelay(2000, holder.txtTitle)
                 }
 
@@ -239,12 +244,15 @@ class AppsRecyclerAdapter(
                 val openFileParcelable = rowItem.openFileParcelable
                 openFileParcelable?.let {
                     safeLet(
-                        openFileParcelable.uri, openFileParcelable.mimeType,
+                        openFileParcelable.uri,
+                        openFileParcelable.mimeType,
                         openFileParcelable.useNewStack
                     ) {
-                        uri, mimeType, useNewStack ->
+                            uri, mimeType, useNewStack ->
                         val intent = buildIntent(
-                            uri, mimeType, useNewStack,
+                            uri,
+                            mimeType,
+                            useNewStack,
                             openFileParcelable.className,
                             openFileParcelable.packageName
                         )
@@ -263,7 +271,8 @@ class AppsRecyclerAdapter(
                     fragment.startActivity(i1)
                 } else {
                     Toast.makeText(
-                        fragment.context, fragment.getString(R.string.not_allowed),
+                        fragment.context,
+                        fragment.getString(R.string.not_allowed),
                         Toast.LENGTH_LONG
                     )
                         .show()
@@ -284,7 +293,8 @@ class AppsRecyclerAdapter(
                 context = ContextThemeWrapper(context, R.style.overflow_black)
             }
             val popupMenu = PopupMenu(
-                context, view
+                context,
+                view
             )
             popupMenu.setOnMenuItemClickListener { item: MenuItem ->
                 val themedActivity: MainActivity = fragment.requireActivity() as MainActivity
@@ -441,9 +451,9 @@ class AppsRecyclerAdapter(
         val fileBaseName = appDataParcelable.label + "_$subString"
         mainApkFile.name = "$fileBaseName.apk"
         filesToCopyList.add(mainApkFile)
-        val splitPathList = appDataParcelable.splitPathList;
+        val splitPathList = appDataParcelable.splitPathList
         if (splitPathList != null) {
-            for (splitApkPath : String in splitPathList) {
+            for (splitApkPath: String in splitPathList) {
                 val splitApkFile = File(splitApkPath)
                 val splitParcelableFile = RootHelper.generateBaseFile(splitApkFile, true)
                 var name = splitApkFile.name.lowercase()
@@ -452,7 +462,7 @@ class AppsRecyclerAdapter(
                 }
                 val dotIdx = name.lastIndexOf('.')
                 name = name.substring(dotIdx + 1)
-                name = "${fileBaseName}_${name}.apk";
+                name = "${fileBaseName}_$name.apk"
                 splitParcelableFile.name = name
                 filesToCopyList.add(splitParcelableFile)
             }
@@ -462,11 +472,11 @@ class AppsRecyclerAdapter(
         intent.putExtra(CopyService.TAG_COPY_OPEN_MODE, 0)
 
         Toast.makeText(
-                fragment.context,
-                fragment.getString(R.string.copyingapks, filesToCopyList.size, dst.path),
-                Toast.LENGTH_LONG
+            fragment.context,
+            fragment.getString(R.string.copyingapks, filesToCopyList.size, dst.path),
+            Toast.LENGTH_LONG
         )
-                .show()
+            .show()
 
         ServiceWatcherUtil.runService(fragment.context, intent)
     }
@@ -518,7 +528,7 @@ class AppsRecyclerAdapter(
         TYPE_ITEM,
         TYPE_HEADER_SYSTEM,
         TYPE_HEADER_THIRD_PARTY,
-        EMPTY_LAST_ITEM,
+        EMPTY_LAST_ITEM
     )
     annotation class ListItemType
 
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/CompressedExplorerAdapter.java b/app/src/main/java/com/amaze/filemanager/adapters/CompressedExplorerAdapter.java
index c790fbab6..3917d23fb 100644
--- a/app/src/main/java/com/amaze/filemanager/adapters/CompressedExplorerAdapter.java
+++ b/app/src/main/java/com/amaze/filemanager/adapters/CompressedExplorerAdapter.java
@@ -27,13 +27,13 @@ import com.amaze.filemanager.GlideApp;
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.adapters.data.CompressedObjectParcelable;
 import com.amaze.filemanager.adapters.holders.CompressedItemViewHolder;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.compressed.CompressedHelper;
 import com.amaze.filemanager.filesystem.compressed.showcontents.Decompressor;
 import com.amaze.filemanager.ui.colors.ColorUtils;
 import com.amaze.filemanager.ui.fragments.CompressedExplorerFragment;
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants;
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants;
 import com.amaze.filemanager.ui.provider.UtilitiesProvider;
 import com.amaze.filemanager.ui.theme.AppTheme;
 import com.amaze.filemanager.ui.views.CircleGradientDrawable;
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/HiddenAdapter.kt b/app/src/main/java/com/amaze/filemanager/adapters/HiddenAdapter.kt
index ffc42d10c..a22c5788a 100644
--- a/app/src/main/java/com/amaze/filemanager/adapters/HiddenAdapter.kt
+++ b/app/src/main/java/com/amaze/filemanager/adapters/HiddenAdapter.kt
@@ -17,28 +17,27 @@
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
+
 package com.amaze.filemanager.adapters
 
 import android.app.Activity
 import android.content.Context
 import android.content.SharedPreferences
-import android.util.Log
 import android.view.LayoutInflater
 import android.view.View
 import android.view.ViewGroup
-import com.amaze.filemanager.ui.fragments.MainFragment
-import com.amaze.filemanager.filesystem.HybridFile
-import com.afollestad.materialdialogs.MaterialDialog
 import androidx.recyclerview.widget.RecyclerView
+import com.afollestad.materialdialogs.MaterialDialog
 import com.amaze.filemanager.R
 import com.amaze.filemanager.adapters.holders.HiddenViewHolder
-import com.amaze.filemanager.filesystem.HybridFileParcelable
 import com.amaze.filemanager.asynchronous.asynctasks.DeleteTask
-import com.amaze.filemanager.utils.DataUtils
-import com.amaze.filemanager.ui.activities.MainActivity
-import com.amaze.filemanager.adapters.HiddenAdapter
-import com.amaze.filemanager.file_operations.filesystem.OpenMode
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode
+import com.amaze.filemanager.filesystem.HybridFile
+import com.amaze.filemanager.filesystem.HybridFileParcelable
 import com.amaze.filemanager.filesystem.files.FileUtils
+import com.amaze.filemanager.ui.activities.MainActivity
+import com.amaze.filemanager.ui.fragments.MainFragment
+import com.amaze.filemanager.utils.DataUtils
 import java.io.File
 import java.util.ArrayList
 import kotlin.concurrent.thread
@@ -49,12 +48,13 @@ import kotlin.concurrent.thread
  * @see com.amaze.filemanager.adapters.holders.HiddenViewHolder
  */
 class HiddenAdapter(
-        private val context: Context,
-        private val mainFragment: MainFragment,
-        private val sharedPrefs: SharedPreferences,
-        hiddenFiles: List<HybridFile>,
-        var materialDialog: MaterialDialog?,
-        private val hide: Boolean) : RecyclerView.Adapter<HiddenViewHolder>() {
+    private val context: Context,
+    private val mainFragment: MainFragment,
+    private val sharedPrefs: SharedPreferences,
+    hiddenFiles: List<HybridFile>,
+    var materialDialog: MaterialDialog?,
+    private val hide: Boolean
+) : RecyclerView.Adapter<HiddenViewHolder>() {
 
     companion object {
         private const val TAG = "HiddenAdapter"
@@ -81,7 +81,8 @@ class HiddenAdapter(
             // .nomedia
             if (!file.isSmb && file.isDirectory(context)) {
                 val nomediaFile = HybridFileParcelable(
-                        hiddenFiles[position].path + "/" + FileUtils.NOMEDIA_FILE)
+                    hiddenFiles[position].path + "/" + FileUtils.NOMEDIA_FILE
+                )
                 nomediaFile.mode = OpenMode.FILE
                 val filesToDelete = ArrayList<HybridFileParcelable>()
                 filesToDelete.add(nomediaFile)
@@ -99,13 +100,20 @@ class HiddenAdapter(
             thread {
                 val fragmentActivity = mainFragment.requireActivity()
                 if (file.isDirectory(context)) {
-                    fragmentActivity.runOnUiThread { mainFragment.loadlist(file.path, false, OpenMode.UNKNOWN) }
+                    fragmentActivity.runOnUiThread {
+                        mainFragment.loadlist(
+                            file.path,
+                            false,
+                            OpenMode.UNKNOWN
+                        )
+                    }
                 } else if (!file.isSmb) {
                     fragmentActivity.runOnUiThread {
                         FileUtils.openFile(
-                                File(file.path),
-                                (fragmentActivity as MainActivity),
-                                sharedPrefs)
+                            File(file.path),
+                            (fragmentActivity as MainActivity),
+                            sharedPrefs
+                        )
                     }
                 }
             }
@@ -117,4 +125,4 @@ class HiddenAdapter(
     }
 
     override fun getItemCount(): Int = hiddenFiles.size
-}
\ No newline at end of file
+}
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/RecyclerAdapter.java b/app/src/main/java/com/amaze/filemanager/adapters/RecyclerAdapter.java
index 7f5b29d7f..dec452ca0 100644
--- a/app/src/main/java/com/amaze/filemanager/adapters/RecyclerAdapter.java
+++ b/app/src/main/java/com/amaze/filemanager/adapters/RecyclerAdapter.java
@@ -21,14 +21,14 @@
 package com.amaze.filemanager.adapters;
 
 import static com.amaze.filemanager.filesystem.compressed.CompressedHelper.*;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_COLORIZE_ICONS;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_SHOW_FILE_SIZE;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_SHOW_GOBACK_BUTTON;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_SHOW_HEADERS;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_SHOW_LAST_MODIFIED;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_SHOW_PERMISSIONS;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_SHOW_THUMB;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_USE_CIRCULAR_IMAGES;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_COLORIZE_ICONS;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SHOW_FILE_SIZE;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SHOW_GOBACK_BUTTON;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SHOW_HEADERS;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SHOW_LAST_MODIFIED;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SHOW_PERMISSIONS;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SHOW_THUMB;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_USE_CIRCULAR_IMAGES;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -49,7 +49,7 @@ import com.amaze.filemanager.ui.activities.superclasses.PreferenceActivity;
 import com.amaze.filemanager.ui.colors.ColorUtils;
 import com.amaze.filemanager.ui.drag.RecyclerAdapterDragListener;
 import com.amaze.filemanager.ui.fragments.MainFragment;
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants;
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants;
 import com.amaze.filemanager.ui.icons.Icons;
 import com.amaze.filemanager.ui.icons.MimeTypes;
 import com.amaze.filemanager.ui.provider.UtilitiesProvider;
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/data/AppDataParcelable.kt b/app/src/main/java/com/amaze/filemanager/adapters/data/AppDataParcelable.kt
index 05222947e..7f90bc8cb 100644
--- a/app/src/main/java/com/amaze/filemanager/adapters/data/AppDataParcelable.kt
+++ b/app/src/main/java/com/amaze/filemanager/adapters/data/AppDataParcelable.kt
@@ -26,14 +26,14 @@ import kotlinx.parcelize.Parcelize
 @Parcelize
 @Suppress("LongParameterList")
 class AppDataParcelable(
-        var label: String,
-        var path: String,
-        var splitPathList: List<String>?,
-        var packageName: String,
-        var data: String,
-        var fileSize: String,
-        var size: Long,
-        var lastModification: Long,
-        var isSystemApp: Boolean,
-        var openFileParcelable: OpenFileParcelable?
+    var label: String,
+    var path: String,
+    var splitPathList: List<String>?,
+    var packageName: String,
+    var data: String,
+    var fileSize: String,
+    var size: Long,
+    var lastModification: Long,
+    var isSystemApp: Boolean,
+    var openFileParcelable: OpenFileParcelable?
 ) : Parcelable
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/data/AppDataSorter.kt b/app/src/main/java/com/amaze/filemanager/adapters/data/AppDataSorter.kt
index e7a8918ad..42e26b32a 100644
--- a/app/src/main/java/com/amaze/filemanager/adapters/data/AppDataSorter.kt
+++ b/app/src/main/java/com/amaze/filemanager/adapters/data/AppDataSorter.kt
@@ -33,7 +33,7 @@ class AppDataSorter(var sort: Int, isAscending: Boolean) :
      */
     override fun compare(file1: AppDataParcelable?, file2: AppDataParcelable?): Int {
         safeLet(file1, file2) {
-            f1, f2 ->
+                f1, f2 ->
             if (f1.isSystemApp != f2.isSystemApp) {
                 return if (f1.isSystemApp) -1 else 1
             }
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/data/CompressedObjectParcelable.java b/app/src/main/java/com/amaze/filemanager/adapters/data/CompressedObjectParcelable.java
index f286228a1..f37b761bd 100644
--- a/app/src/main/java/com/amaze/filemanager/adapters/data/CompressedObjectParcelable.java
+++ b/app/src/main/java/com/amaze/filemanager/adapters/data/CompressedObjectParcelable.java
@@ -27,7 +27,9 @@ import com.amaze.filemanager.ui.icons.Icons;
 import android.os.Parcel;
 import android.os.Parcelable;
 
-/** @author Emmanuel Messulam <emmanuelbendavid@gmail.com> on 20/11/2017, at 15:26. */
+/**
+ * @author Emmanuel Messulam <emmanuelbendavid@gmail.com> on 20/11/2017, at 15:26.
+ */
 public class CompressedObjectParcelable implements Parcelable {
   public static final int TYPE_GOBACK = -1, TYPE_NORMAL = 0;
 
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/data/LayoutElementParcelable.java b/app/src/main/java/com/amaze/filemanager/adapters/data/LayoutElementParcelable.java
index c5c60ce34..0ecfde8b4 100644
--- a/app/src/main/java/com/amaze/filemanager/adapters/data/LayoutElementParcelable.java
+++ b/app/src/main/java/com/amaze/filemanager/adapters/data/LayoutElementParcelable.java
@@ -23,7 +23,7 @@ package com.amaze.filemanager.adapters.data;
 import java.io.File;
 import java.util.Calendar;
 
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.ui.icons.Icons;
 import com.amaze.filemanager.utils.Utils;
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/glide/AppsAdapterPreloadModel.java b/app/src/main/java/com/amaze/filemanager/adapters/glide/AppsAdapterPreloadModel.java
index 83cd6b664..2ce69b150 100644
--- a/app/src/main/java/com/amaze/filemanager/adapters/glide/AppsAdapterPreloadModel.java
+++ b/app/src/main/java/com/amaze/filemanager/adapters/glide/AppsAdapterPreloadModel.java
@@ -41,7 +41,9 @@ import androidx.annotation.Nullable;
 import androidx.core.content.ContextCompat;
 import androidx.fragment.app.Fragment;
 
-/** @author Emmanuel Messulam <emmanuelbendavid@gmail.com> on 10/12/2017, at 15:38. */
+/**
+ * @author Emmanuel Messulam <emmanuelbendavid@gmail.com> on 10/12/2017, at 15:38.
+ */
 public class AppsAdapterPreloadModel implements ListPreloader.PreloadModelProvider<String> {
 
   private Context mContext;
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/glide/RecyclerPreloadModelProvider.java b/app/src/main/java/com/amaze/filemanager/adapters/glide/RecyclerPreloadModelProvider.java
index 089d5eb06..706c65e88 100644
--- a/app/src/main/java/com/amaze/filemanager/adapters/glide/RecyclerPreloadModelProvider.java
+++ b/app/src/main/java/com/amaze/filemanager/adapters/glide/RecyclerPreloadModelProvider.java
@@ -36,7 +36,9 @@ import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.fragment.app.Fragment;
 
-/** @author Emmanuel Messulam <emmanuelbendavid@gmail.com> on 6/12/2017, at 15:15. */
+/**
+ * @author Emmanuel Messulam <emmanuelbendavid@gmail.com> on 6/12/2017, at 15:15.
+ */
 public class RecyclerPreloadModelProvider
     implements ListPreloader.PreloadModelProvider<IconDataParcelable> {
 
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/glide/apkimage/ApkImageDataFetcher.java b/app/src/main/java/com/amaze/filemanager/adapters/glide/apkimage/ApkImageDataFetcher.java
index 5e8cfdb86..4a46251b9 100644
--- a/app/src/main/java/com/amaze/filemanager/adapters/glide/apkimage/ApkImageDataFetcher.java
+++ b/app/src/main/java/com/amaze/filemanager/adapters/glide/apkimage/ApkImageDataFetcher.java
@@ -32,7 +32,9 @@ import android.graphics.drawable.Drawable;
 import androidx.annotation.NonNull;
 import androidx.core.content.ContextCompat;
 
-/** @author Emmanuel Messulam <emmanuelbendavid@gmail.com> on 10/12/2017, at 16:12. */
+/**
+ * @author Emmanuel Messulam <emmanuelbendavid@gmail.com> on 10/12/2017, at 16:12.
+ */
 public class ApkImageDataFetcher implements DataFetcher<Drawable> {
 
   private Context context;
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/glide/apkimage/ApkImageModelLoader.java b/app/src/main/java/com/amaze/filemanager/adapters/glide/apkimage/ApkImageModelLoader.java
index 535e865f0..18b66616e 100644
--- a/app/src/main/java/com/amaze/filemanager/adapters/glide/apkimage/ApkImageModelLoader.java
+++ b/app/src/main/java/com/amaze/filemanager/adapters/glide/apkimage/ApkImageModelLoader.java
@@ -29,7 +29,9 @@ import android.graphics.drawable.Drawable;
 
 import androidx.annotation.Nullable;
 
-/** @author Emmanuel Messulam <emmanuelbendavid@gmail.com> on 10/12/2017, at 16:06. */
+/**
+ * @author Emmanuel Messulam <emmanuelbendavid@gmail.com> on 10/12/2017, at 16:06.
+ */
 public class ApkImageModelLoader implements ModelLoader<String, Drawable> {
 
   private Context context;
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/glide/apkimage/ApkImageModelLoaderFactory.java b/app/src/main/java/com/amaze/filemanager/adapters/glide/apkimage/ApkImageModelLoaderFactory.java
index ce7d3fea1..5efc078ec 100644
--- a/app/src/main/java/com/amaze/filemanager/adapters/glide/apkimage/ApkImageModelLoaderFactory.java
+++ b/app/src/main/java/com/amaze/filemanager/adapters/glide/apkimage/ApkImageModelLoaderFactory.java
@@ -27,7 +27,9 @@ import com.bumptech.glide.load.model.MultiModelLoaderFactory;
 import android.content.Context;
 import android.graphics.drawable.Drawable;
 
-/** @author Emmanuel Messulam <emmanuelbendavid@gmail.com> on 10/12/2017, at 16:21. */
+/**
+ * @author Emmanuel Messulam <emmanuelbendavid@gmail.com> on 10/12/2017, at 16:21.
+ */
 public class ApkImageModelLoaderFactory implements ModelLoaderFactory<String, Drawable> {
 
   private Context context;
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/holders/SpecialViewHolder.kt b/app/src/main/java/com/amaze/filemanager/adapters/holders/SpecialViewHolder.kt
index 2a15b3411..ec4a3e128 100644
--- a/app/src/main/java/com/amaze/filemanager/adapters/holders/SpecialViewHolder.kt
+++ b/app/src/main/java/com/amaze/filemanager/adapters/holders/SpecialViewHolder.kt
@@ -36,7 +36,7 @@ class SpecialViewHolder(
     c: Context,
     view: View,
     utilsProvider: UtilitiesProvider,
-    val type: Int,
+    val type: Int
 ) : RecyclerView.ViewHolder(view) {
     // each data item is just a string in this case
     private val txtTitle: TextView = view.findViewById(R.id.text)
diff --git a/app/src/main/java/com/amaze/filemanager/application/GlideApplication.java b/app/src/main/java/com/amaze/filemanager/application/GlideApplication.java
index c0a333abd..32d5f2b4d 100644
--- a/app/src/main/java/com/amaze/filemanager/application/GlideApplication.java
+++ b/app/src/main/java/com/amaze/filemanager/application/GlideApplication.java
@@ -25,7 +25,9 @@ import com.bumptech.glide.MemoryCategory;
 
 import androidx.multidex.MultiDexApplication;
 
-/** @author Emmanuel on 22/11/2017, at 17:18. */
+/**
+ * @author Emmanuel on 22/11/2017, at 17:18.
+ */
 public class GlideApplication extends MultiDexApplication {
   @Override
   public void onCreate() {
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/CloudLoaderAsyncTask.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/CloudLoaderAsyncTask.java
index 7ca9671a5..15541f907 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/CloudLoaderAsyncTask.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/CloudLoaderAsyncTask.java
@@ -26,8 +26,8 @@ import com.amaze.filemanager.R;
 import com.amaze.filemanager.application.AppConfig;
 import com.amaze.filemanager.database.CloudHandler;
 import com.amaze.filemanager.database.models.explorer.CloudEntry;
-import com.amaze.filemanager.file_operations.exceptions.CloudPluginException;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.exceptions.CloudPluginException;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.ui.activities.MainActivity;
 import com.amaze.filemanager.utils.DataUtils;
 import com.cloudrail.si.CloudRail;
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/CountItemsOrAndSizeTask.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/CountItemsOrAndSizeTask.java
index 21b8f2e4c..2319ef3c3 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/CountItemsOrAndSizeTask.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/CountItemsOrAndSizeTask.java
@@ -33,7 +33,9 @@ import android.widget.TextView;
 
 import androidx.core.util.Pair;
 
-/** @author Emmanuel on 12/5/2017, at 19:40. */
+/**
+ * @author Emmanuel on 12/5/2017, at 19:40.
+ */
 public class CountItemsOrAndSizeTask extends AsyncTask<Void, Pair<Integer, Long>, String> {
 
   private Context context;
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/DeleteTask.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/DeleteTask.java
index 9eb5b99e5..65a2e9f0a 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/DeleteTask.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/DeleteTask.java
@@ -28,8 +28,8 @@ import java.util.ArrayList;
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.application.AppConfig;
 import com.amaze.filemanager.database.CryptHandler;
-import com.amaze.filemanager.file_operations.exceptions.ShellNotRunningException;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.exceptions.ShellNotRunningException;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.SafRootHolder;
@@ -38,7 +38,7 @@ import com.amaze.filemanager.filesystem.files.CryptUtil;
 import com.amaze.filemanager.filesystem.files.FileUtils;
 import com.amaze.filemanager.ui.activities.MainActivity;
 import com.amaze.filemanager.ui.fragments.CompressedExplorerFragment;
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants;
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants;
 import com.amaze.filemanager.ui.notifications.NotificationConstants;
 import com.amaze.filemanager.utils.DataUtils;
 import com.amaze.filemanager.utils.OTGUtil;
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/LoadFilesListTask.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/LoadFilesListTask.java
index d71083698..d6ca79fc1 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/LoadFilesListTask.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/LoadFilesListTask.java
@@ -36,8 +36,8 @@ import com.amaze.filemanager.adapters.data.LayoutElementParcelable;
 import com.amaze.filemanager.application.AppConfig;
 import com.amaze.filemanager.database.SortHandler;
 import com.amaze.filemanager.database.UtilsHandler;
-import com.amaze.filemanager.file_operations.exceptions.CloudPluginException;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.exceptions.CloudPluginException;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.RootHelper;
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/compress/RarHelperCallable.kt b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/compress/RarHelperCallable.kt
index bf074b82b..ea34c9378 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/compress/RarHelperCallable.kt
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/compress/RarHelperCallable.kt
@@ -50,7 +50,8 @@ class RarHelperCallable(
         try {
             val rarFile = Archive(File(fileLocation))
             val relativeDirDiffSeparator = relativeDirectory.replace(
-                CompressedHelper.SEPARATOR, "\\"
+                CompressedHelper.SEPARATOR,
+                "\\"
             )
             for (rarArchive in rarFile.fileHeaders) {
                 val name = rarArchive.fileName
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/compress/SevenZipHelperCallable.kt b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/compress/SevenZipHelperCallable.kt
index 87be97adf..4b5fc19f4 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/compress/SevenZipHelperCallable.kt
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/compress/SevenZipHelperCallable.kt
@@ -22,7 +22,7 @@ package com.amaze.filemanager.asynchronous.asynctasks.compress
 
 import android.util.Log
 import com.amaze.filemanager.adapters.data.CompressedObjectParcelable
-import com.amaze.filemanager.file_operations.filesystem.compressed.ArchivePasswordCache
+import com.amaze.filemanager.fileoperations.filesystem.compressed.ArchivePasswordCache
 import com.amaze.filemanager.filesystem.compressed.CompressedHelper
 import com.amaze.filemanager.filesystem.compressed.sevenz.SevenZFile
 import org.apache.commons.compress.PasswordRequiredException
@@ -68,7 +68,10 @@ class SevenZipHelperCallable(
                             try {
                                 entry.lastModifiedDate.time
                             } catch (e: UnsupportedOperationException) {
-                                Log.w(javaClass.simpleName, "Unable to get modified date for 7zip file")
+                                Log.w(
+                                    javaClass.simpleName,
+                                    "Unable to get modified date for 7zip file"
+                                )
                                 0L
                             },
                             entry.size,
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/compress/UnknownCompressedFileHelperCallable.kt b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/compress/UnknownCompressedFileHelperCallable.kt
index 6d3b0789e..e5c90b458 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/compress/UnknownCompressedFileHelperCallable.kt
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/compress/UnknownCompressedFileHelperCallable.kt
@@ -21,8 +21,6 @@
 package com.amaze.filemanager.asynchronous.asynctasks.compress
 
 import com.amaze.filemanager.adapters.data.CompressedObjectParcelable
-import com.amaze.filemanager.asynchronous.asynctasks.AsyncTaskResult
-import com.amaze.filemanager.utils.OnAsyncTaskFinished
 import java.util.ArrayList
 
 /**
@@ -56,7 +54,7 @@ class UnknownCompressedFileHelperCallable(
     private val filePath: String,
     goBack: Boolean
 ) :
-        CompressedHelperCallable(goBack) {
+    CompressedHelperCallable(goBack) {
 
     override fun addElements(elements: ArrayList<CompressedObjectParcelable>) {
         val entryName = filePath.substringAfterLast('/').substringBeforeLast('.')
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/movecopy/MoveFiles.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/movecopy/MoveFiles.java
index d4b6b6c9f..471f4bbaa 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/movecopy/MoveFiles.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/movecopy/MoveFiles.java
@@ -25,8 +25,8 @@ import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.concurrent.Callable;
 
-import com.amaze.filemanager.file_operations.exceptions.ShellNotRunningException;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.exceptions.ShellNotRunningException;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.Operations;
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/movecopy/MoveFilesTask.kt b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/movecopy/MoveFilesTask.kt
index 33e195b87..94aa33f0d 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/movecopy/MoveFilesTask.kt
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/movecopy/MoveFilesTask.kt
@@ -31,7 +31,7 @@ import com.amaze.filemanager.asynchronous.management.ServiceWatcherUtil
 import com.amaze.filemanager.asynchronous.services.CopyService
 import com.amaze.filemanager.database.CryptHandler
 import com.amaze.filemanager.database.models.explorer.EncryptedEntry
-import com.amaze.filemanager.file_operations.filesystem.OpenMode
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode
 import com.amaze.filemanager.filesystem.HybridFile
 import com.amaze.filemanager.filesystem.HybridFileParcelable
 import com.amaze.filemanager.filesystem.files.CryptUtil
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/movecopy/PrepareCopyTask.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/movecopy/PrepareCopyTask.java
index a740edf1d..4bd15f349 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/movecopy/PrepareCopyTask.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/movecopy/PrepareCopyTask.java
@@ -20,9 +20,9 @@
 
 package com.amaze.filemanager.asynchronous.asynctasks.movecopy;
 
-import static com.amaze.filemanager.file_operations.filesystem.FolderStateKt.CAN_CREATE_FILES;
-import static com.amaze.filemanager.file_operations.filesystem.OperationTypeKt.COPY;
-import static com.amaze.filemanager.file_operations.filesystem.OperationTypeKt.MOVE;
+import static com.amaze.filemanager.fileoperations.filesystem.FolderStateKt.CAN_CREATE_FILES;
+import static com.amaze.filemanager.fileoperations.filesystem.OperationTypeKt.COPY;
+import static com.amaze.filemanager.fileoperations.filesystem.OperationTypeKt.MOVE;
 
 import java.io.File;
 import java.lang.ref.WeakReference;
@@ -38,8 +38,8 @@ import com.amaze.filemanager.asynchronous.asynctasks.TaskKt;
 import com.amaze.filemanager.asynchronous.management.ServiceWatcherUtil;
 import com.amaze.filemanager.asynchronous.services.CopyService;
 import com.amaze.filemanager.databinding.CopyDialogBinding;
-import com.amaze.filemanager.file_operations.filesystem.FolderState;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.FolderState;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.files.FileUtils;
@@ -406,7 +406,9 @@ public class PrepareCopyTask extends AsyncTask<Void, String, PrepareCopyTask.Cop
       return this;
     }
 
-    /** @return true if there are no more nodes */
+    /**
+     * @return true if there are no more nodes
+     */
     CopyNode goToNextNode() {
       if (queue.isEmpty()) return null;
       else {
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/searchfilesystem/SearchAsyncTask.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/searchfilesystem/SearchAsyncTask.java
index 3207e3b27..0f219026c 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/searchfilesystem/SearchAsyncTask.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/searchfilesystem/SearchAsyncTask.java
@@ -20,12 +20,12 @@
 
 package com.amaze.filemanager.asynchronous.asynctasks.searchfilesystem;
 
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_SHOW_HIDDENFILES;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SHOW_HIDDENFILES;
 
 import java.util.regex.Pattern;
 
 import com.amaze.filemanager.asynchronous.asynctasks.StatefulAsyncTask;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.ui.fragments.SearchWorkerFragment;
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/PemToKeyPairTask.kt b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/PemToKeyPairTask.kt
index 0d5b3b52b..d8a3c4fb5 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/PemToKeyPairTask.kt
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/PemToKeyPairTask.kt
@@ -157,7 +157,8 @@ class PemToKeyPairTask(
         ) { text: String ->
             if (text.isEmpty()) {
                 ReturnState(
-                    ReturnState.STATE_ERROR, R.string.field_empty
+                    ReturnState.STATE_ERROR,
+                    R.string.field_empty
                 )
             }
             ReturnState()
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/texteditor/read/ReadTextFileCallable.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/texteditor/read/ReadTextFileCallable.java
index 28c48e031..9090324aa 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/texteditor/read/ReadTextFileCallable.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/texteditor/read/ReadTextFileCallable.java
@@ -20,20 +20,6 @@
 
 package com.amaze.filemanager.asynchronous.asynctasks.texteditor.read;
 
-import android.content.ContentResolver;
-
-import androidx.annotation.WorkerThread;
-import androidx.documentfile.provider.DocumentFile;
-
-import com.amaze.filemanager.application.AppConfig;
-import com.amaze.filemanager.file_operations.exceptions.ShellNotRunningException;
-import com.amaze.filemanager.file_operations.exceptions.StreamNotFoundException;
-import com.amaze.filemanager.filesystem.EditableFileAbstraction;
-import com.amaze.filemanager.filesystem.HybridFileParcelable;
-import com.amaze.filemanager.filesystem.files.FileUtils;
-import com.amaze.filemanager.filesystem.root.CopyFilesCommand;
-import com.amaze.filemanager.ui.activities.texteditor.ReturnedValueOnReadFile;
-
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
@@ -43,6 +29,20 @@ import java.io.InputStreamReader;
 import java.util.Objects;
 import java.util.concurrent.Callable;
 
+import com.amaze.filemanager.application.AppConfig;
+import com.amaze.filemanager.fileoperations.exceptions.ShellNotRunningException;
+import com.amaze.filemanager.fileoperations.exceptions.StreamNotFoundException;
+import com.amaze.filemanager.filesystem.EditableFileAbstraction;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
+import com.amaze.filemanager.filesystem.files.FileUtils;
+import com.amaze.filemanager.filesystem.root.CopyFilesCommand;
+import com.amaze.filemanager.ui.activities.texteditor.ReturnedValueOnReadFile;
+
+import android.content.ContentResolver;
+
+import androidx.annotation.WorkerThread;
+import androidx.documentfile.provider.DocumentFile;
+
 public class ReadTextFileCallable implements Callable<ReturnedValueOnReadFile> {
 
   public static final int MAX_FILE_SIZE_CHARS = 50 * 1024;
@@ -131,7 +131,7 @@ public class ReadTextFileCallable implements Callable<ReturnedValueOnReadFile> {
       // try loading stream associated using root
       cachedFile = new File(externalCacheDir, file.getName());
       // Scrap previously cached file if exist
-      if(cachedFile.exists()) {
+      if (cachedFile.exists()) {
         cachedFile.delete();
       }
       cachedFile.createNewFile();
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/texteditor/read/ReadTextFileTask.kt b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/texteditor/read/ReadTextFileTask.kt
index 3dfb1f3db..40141e458 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/texteditor/read/ReadTextFileTask.kt
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/texteditor/read/ReadTextFileTask.kt
@@ -28,7 +28,7 @@ import androidx.annotation.MainThread
 import androidx.annotation.StringRes
 import com.amaze.filemanager.R
 import com.amaze.filemanager.asynchronous.asynctasks.Task
-import com.amaze.filemanager.file_operations.exceptions.StreamNotFoundException
+import com.amaze.filemanager.fileoperations.exceptions.StreamNotFoundException
 import com.amaze.filemanager.filesystem.EditableFileAbstraction
 import com.amaze.filemanager.ui.activities.texteditor.ReturnedValueOnReadFile
 import com.amaze.filemanager.ui.activities.texteditor.TextEditorActivity
@@ -66,6 +66,7 @@ class ReadTextFileTask(
     override fun onError(error: Throwable) {
         Log.e(TAG, "Error on text read", error)
         val applicationContext = appContextWR.get() ?: return
+
         @StringRes val errorMessage: Int = when (error) {
             is StreamNotFoundException -> {
                 R.string.error_file_not_found
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/texteditor/write/WriteTextFileCallable.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/texteditor/write/WriteTextFileCallable.java
index f35ad024c..e4be05299 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/texteditor/write/WriteTextFileCallable.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/texteditor/write/WriteTextFileCallable.java
@@ -29,8 +29,8 @@ import java.util.Objects;
 import java.util.concurrent.Callable;
 
 import com.amaze.filemanager.application.AppConfig;
-import com.amaze.filemanager.file_operations.exceptions.ShellNotRunningException;
-import com.amaze.filemanager.file_operations.exceptions.StreamNotFoundException;
+import com.amaze.filemanager.fileoperations.exceptions.ShellNotRunningException;
+import com.amaze.filemanager.fileoperations.exceptions.StreamNotFoundException;
 import com.amaze.filemanager.filesystem.EditableFileAbstraction;
 import com.amaze.filemanager.filesystem.FileUtil;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
@@ -84,13 +84,13 @@ public class WriteTextFileCallable implements Callable<Unit> {
           DocumentFile documentFile =
               DocumentFile.fromSingleUri(AppConfig.getInstance(), fileAbstraction.uri);
           if (documentFile != null && documentFile.exists() && documentFile.canWrite()) {
-            outputStream = contentResolver.openOutputStream(fileAbstraction.uri);
+            outputStream = contentResolver.openOutputStream(fileAbstraction.uri, "wt");
           } else {
             destFile = FileUtils.fromContentUri(fileAbstraction.uri);
             outputStream = openFile(destFile, context.get());
           }
         } else {
-          outputStream = contentResolver.openOutputStream(fileAbstraction.uri);
+          outputStream = contentResolver.openOutputStream(fileAbstraction.uri, "wt");
         }
         break;
       case FILE:
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/texteditor/write/WriteTextFileTask.kt b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/texteditor/write/WriteTextFileTask.kt
index 5c3a00b10..660e597b6 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/texteditor/write/WriteTextFileTask.kt
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/texteditor/write/WriteTextFileTask.kt
@@ -28,8 +28,8 @@ import androidx.annotation.MainThread
 import androidx.annotation.StringRes
 import com.amaze.filemanager.R
 import com.amaze.filemanager.asynchronous.asynctasks.Task
-import com.amaze.filemanager.file_operations.exceptions.ShellNotRunningException
-import com.amaze.filemanager.file_operations.exceptions.StreamNotFoundException
+import com.amaze.filemanager.fileoperations.exceptions.ShellNotRunningException
+import com.amaze.filemanager.fileoperations.exceptions.StreamNotFoundException
 import com.amaze.filemanager.ui.activities.texteditor.TextEditorActivity
 import com.amaze.filemanager.ui.activities.texteditor.TextEditorActivityViewModel
 import java.io.IOException
@@ -66,6 +66,7 @@ class WriteTextFileTask(
     override fun onError(error: Throwable) {
         Log.e(TAG, "Error on text write", error)
         val applicationContext = appContextWR.get() ?: return
+
         @StringRes val errorMessage: Int = when (error) {
             is StreamNotFoundException -> {
                 R.string.error_file_not_found
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/handlers/FileHandler.kt b/app/src/main/java/com/amaze/filemanager/asynchronous/handlers/FileHandler.kt
index a8f85ae0c..60d59296d 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/handlers/FileHandler.kt
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/handlers/FileHandler.kt
@@ -66,7 +66,8 @@ class FileHandler(
                     return
                 }
                 val fileCreated = HybridFile(
-                    mainFragmentViewModel.openMode, "${main.currentPath}/$path"
+                    mainFragmentViewModel.openMode,
+                    "${main.currentPath}/$path"
                 )
                 val newElement = fileCreated.generateLayoutElement(main.requireContext(), useThumbs)
                 main.elementsList?.add(newElement)
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/management/ServiceWatcherUtil.java b/app/src/main/java/com/amaze/filemanager/asynchronous/management/ServiceWatcherUtil.java
index 1b024225e..43b264d42 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/management/ServiceWatcherUtil.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/management/ServiceWatcherUtil.java
@@ -35,7 +35,7 @@ import java.util.concurrent.*;
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.asynchronous.AbstractRepeatingRunnable;
 import com.amaze.filemanager.asynchronous.services.AbstractProgressiveService;
-import com.amaze.filemanager.file_operations.utils.UpdatePosition;
+import com.amaze.filemanager.fileoperations.utils.UpdatePosition;
 import com.amaze.filemanager.ui.notifications.NotificationConstants;
 import com.amaze.filemanager.utils.ProgressHandler;
 
@@ -72,7 +72,9 @@ public class ServiceWatcherUtil {
 
   private static int haltCounter = -1;
 
-  /** @param progressHandler to publish progress after certain delay */
+  /**
+   * @param progressHandler to publish progress after certain delay
+   */
   public ServiceWatcherUtil(ProgressHandler progressHandler) {
     this.progressHandler = progressHandler;
     position = 0L;
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/services/AbstractProgressiveService.java b/app/src/main/java/com/amaze/filemanager/asynchronous/services/AbstractProgressiveService.java
index 3a5ac4f6c..9e9ea1606 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/services/AbstractProgressiveService.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/services/AbstractProgressiveService.java
@@ -46,7 +46,9 @@ import androidx.annotation.CallSuper;
 import androidx.annotation.StringRes;
 import androidx.core.app.NotificationCompat;
 
-/** @author Emmanuel Messulam <emmanuelbendavid@gmail.com> on 28/11/2017, at 19:32. */
+/**
+ * @author Emmanuel Messulam <emmanuelbendavid@gmail.com> on 28/11/2017, at 19:32.
+ */
 public abstract class AbstractProgressiveService extends Service
     implements ServiceWatcherUtil.ServiceStatusCallbacks {
 
@@ -83,7 +85,9 @@ public abstract class AbstractProgressiveService extends Service
 
   public abstract void setProgressListener(ProgressListener progressListener);
 
-  /** @return list of data packages, to initiate chart in process viewer fragment */
+  /**
+   * @return list of data packages, to initiate chart in process viewer fragment
+   */
   protected abstract ArrayList<DatapointParcelable> getDataPackages();
 
   protected abstract ProgressHandler getProgressHandler();
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/services/CopyService.java b/app/src/main/java/com/amaze/filemanager/asynchronous/services/CopyService.java
index 472d8d92f..cb81d946f 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/services/CopyService.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/services/CopyService.java
@@ -29,8 +29,8 @@ import com.amaze.filemanager.asynchronous.asynctasks.DeleteTask;
 import com.amaze.filemanager.asynchronous.management.ServiceWatcherUtil;
 import com.amaze.filemanager.database.CryptHandler;
 import com.amaze.filemanager.database.models.explorer.EncryptedEntry;
-import com.amaze.filemanager.file_operations.exceptions.ShellNotRunningException;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.exceptions.ShellNotRunningException;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.FileProperties;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/services/DecryptService.java b/app/src/main/java/com/amaze/filemanager/asynchronous/services/DecryptService.java
index 9027b6e60..b51f7c9de 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/services/DecryptService.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/services/DecryptService.java
@@ -22,28 +22,15 @@ package com.amaze.filemanager.asynchronous.services;
 
 import static com.amaze.filemanager.asynchronous.services.EncryptService.TAG_PASSWORD;
 
-import android.app.NotificationManager;
-import android.app.PendingIntent;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.SharedPreferences;
-import android.os.IBinder;
-import android.util.Log;
-import android.widget.RemoteViews;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.StringRes;
-import androidx.core.app.NotificationCompat;
-import androidx.preference.PreferenceManager;
+import java.util.ArrayList;
+import java.util.concurrent.Callable;
 
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.application.AppConfig;
 import com.amaze.filemanager.asynchronous.asynctasks.Task;
 import com.amaze.filemanager.asynchronous.asynctasks.TaskKt;
 import com.amaze.filemanager.asynchronous.management.ServiceWatcherUtil;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.FileProperties;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
@@ -56,10 +43,25 @@ import com.amaze.filemanager.utils.DatapointParcelable;
 import com.amaze.filemanager.utils.ObtainableServiceBinder;
 import com.amaze.filemanager.utils.ProgressHandler;
 
-import java.util.ArrayList;
-import java.util.concurrent.Callable;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.SharedPreferences;
+import android.os.IBinder;
+import android.util.Log;
+import android.widget.RemoteViews;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.StringRes;
+import androidx.core.app.NotificationCompat;
+import androidx.preference.PreferenceManager;
 
-/** @author Emmanuel Messulam <emmanuelbendavid@gmail.com> on 28/11/2017, at 20:59. */
+/**
+ * @author Emmanuel Messulam <emmanuelbendavid@gmail.com> on 28/11/2017, at 20:59.
+ */
 public class DecryptService extends AbstractProgressiveService {
 
   public static final String TAG_SOURCE = "crypt_source"; // source file to encrypt or decrypt
@@ -102,7 +104,8 @@ public class DecryptService extends AbstractProgressiveService {
     decryptPath = intent.getStringExtra(TAG_DECRYPT_PATH);
 
     SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context);
-    int accentColor = ((AppConfig) getApplication())
+    int accentColor =
+        ((AppConfig) getApplication())
             .getUtilsProvider()
             .getColorPreference()
             .getCurrentUserColorPreferences(this, sharedPreferences)
@@ -234,9 +237,9 @@ public class DecryptService extends AbstractProgressiveService {
     public Callable<Long> getTask() {
       return () -> {
         String baseFileFolder =
-                baseFile.isDirectory()
-                        ? baseFile.getPath()
-                        : baseFile.getPath().substring(0, baseFile.getPath().lastIndexOf('/'));
+            baseFile.isDirectory()
+                ? baseFile.getPath()
+                : baseFile.getPath().substring(0, baseFile.getPath().lastIndexOf('/'));
 
         if (baseFile.isDirectory()) totalSize = baseFile.folderSize(context);
         else totalSize = baseFile.length(context);
@@ -247,10 +250,10 @@ public class DecryptService extends AbstractProgressiveService {
         serviceWatcherUtil = new ServiceWatcherUtil(progressHandler);
 
         addFirstDatapoint(
-                baseFile.getName(context),
-                1,
-                totalSize,
-                false); // we're using encrypt as move flag false
+            baseFile.getName(context),
+            1,
+            totalSize,
+            false); // we're using encrypt as move flag false
 
         if (FileProperties.checkFolder(baseFileFolder, context) == 1) {
           serviceWatcherUtil.watch(DecryptService.this);
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/services/EncryptService.java b/app/src/main/java/com/amaze/filemanager/asynchronous/services/EncryptService.java
index 588a817be..901123940 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/services/EncryptService.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/services/EncryptService.java
@@ -20,28 +20,15 @@
 
 package com.amaze.filemanager.asynchronous.services;
 
-import android.app.NotificationManager;
-import android.app.PendingIntent;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.SharedPreferences;
-import android.os.IBinder;
-import android.widget.RemoteViews;
-
-import androidx.annotation.DrawableRes;
-import androidx.annotation.NonNull;
-import androidx.annotation.StringRes;
-import androidx.core.app.NotificationCompat;
-import androidx.preference.PreferenceManager;
+import java.util.ArrayList;
+import java.util.concurrent.Callable;
 
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.application.AppConfig;
 import com.amaze.filemanager.asynchronous.asynctasks.Task;
 import com.amaze.filemanager.asynchronous.asynctasks.TaskKt;
 import com.amaze.filemanager.asynchronous.management.ServiceWatcherUtil;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.FileProperties;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
@@ -52,8 +39,21 @@ import com.amaze.filemanager.utils.DatapointParcelable;
 import com.amaze.filemanager.utils.ObtainableServiceBinder;
 import com.amaze.filemanager.utils.ProgressHandler;
 
-import java.util.ArrayList;
-import java.util.concurrent.Callable;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.SharedPreferences;
+import android.os.IBinder;
+import android.widget.RemoteViews;
+
+import androidx.annotation.DrawableRes;
+import androidx.annotation.NonNull;
+import androidx.annotation.StringRes;
+import androidx.core.app.NotificationCompat;
+import androidx.preference.PreferenceManager;
 
 /** Created by vishal on 8/4/17 edited by Emmanuel Messulam <emmanuelbendavid@gmail.com> */
 public class EncryptService extends AbstractProgressiveService {
@@ -102,7 +102,7 @@ public class EncryptService extends AbstractProgressiveService {
     baseFile = intent.getParcelableExtra(TAG_SOURCE);
     targetFilename = intent.getStringExtra(TAG_ENCRYPT_TARGET);
     useAesCrypt = intent.getBooleanExtra(TAG_AESCRYPT, false);
-    if(useAesCrypt) {
+    if (useAesCrypt) {
       password = intent.getStringExtra(TAG_PASSWORD);
     }
     sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context);
@@ -131,9 +131,7 @@ public class EncryptService extends AbstractProgressiveService {
         PendingIntent.getBroadcast(context, 1234, stopIntent, PendingIntent.FLAG_UPDATE_CURRENT);
     NotificationCompat.Action action =
         new NotificationCompat.Action(
-            getSmallIcon(),
-            getString(R.string.stop_ftp),
-            stopPendingIntent);
+            getSmallIcon(), getString(R.string.stop_ftp), stopPendingIntent);
 
     notificationBuilder =
         new NotificationCompat.Builder(this, NotificationConstants.CHANNEL_NORMAL_ID);
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/services/ExtractService.java b/app/src/main/java/com/amaze/filemanager/asynchronous/services/ExtractService.java
index 8fbc58dac..1b13f1a73 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/services/ExtractService.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/services/ExtractService.java
@@ -20,6 +20,28 @@
 
 package com.amaze.filemanager.asynchronous.services;
 
+import java.io.File;
+import java.io.IOException;
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+
+import org.apache.commons.compress.PasswordRequiredException;
+import org.tukaani.xz.CorruptedInputException;
+
+import com.amaze.filemanager.R;
+import com.amaze.filemanager.application.AppConfig;
+import com.amaze.filemanager.asynchronous.management.ServiceWatcherUtil;
+import com.amaze.filemanager.fileoperations.filesystem.compressed.ArchivePasswordCache;
+import com.amaze.filemanager.filesystem.compressed.CompressedHelper;
+import com.amaze.filemanager.filesystem.compressed.extractcontents.Extractor;
+import com.amaze.filemanager.ui.activities.MainActivity;
+import com.amaze.filemanager.ui.dialogs.GeneralDialogCreation;
+import com.amaze.filemanager.ui.notifications.NotificationConstants;
+import com.amaze.filemanager.utils.DatapointParcelable;
+import com.amaze.filemanager.utils.ObtainableServiceBinder;
+import com.amaze.filemanager.utils.ProgressHandler;
+import com.github.junrar.exception.UnsupportedRarV5Exception;
+
 import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.content.BroadcastReceiver;
@@ -39,28 +61,6 @@ import androidx.annotation.StringRes;
 import androidx.core.app.NotificationCompat;
 import androidx.preference.PreferenceManager;
 
-import com.amaze.filemanager.R;
-import com.amaze.filemanager.application.AppConfig;
-import com.amaze.filemanager.asynchronous.management.ServiceWatcherUtil;
-import com.amaze.filemanager.file_operations.filesystem.compressed.ArchivePasswordCache;
-import com.amaze.filemanager.filesystem.compressed.CompressedHelper;
-import com.amaze.filemanager.filesystem.compressed.extractcontents.Extractor;
-import com.amaze.filemanager.ui.activities.MainActivity;
-import com.amaze.filemanager.ui.dialogs.GeneralDialogCreation;
-import com.amaze.filemanager.ui.notifications.NotificationConstants;
-import com.amaze.filemanager.utils.DatapointParcelable;
-import com.amaze.filemanager.utils.ObtainableServiceBinder;
-import com.amaze.filemanager.utils.ProgressHandler;
-import com.github.junrar.exception.UnsupportedRarV5Exception;
-
-import org.apache.commons.compress.PasswordRequiredException;
-import org.tukaani.xz.CorruptedInputException;
-
-import java.io.File;
-import java.io.IOException;
-import java.lang.ref.WeakReference;
-import java.util.ArrayList;
-
 public class ExtractService extends AbstractProgressiveService {
 
   Context context;
@@ -311,8 +311,9 @@ public class ExtractService extends AbstractProgressiveService {
                 },
                 ServiceWatcherUtil.UPDATE_POSITION);
 
-        if(extractor == null) {
-          Toast.makeText(context, R.string.error_cant_decompress_that_file, Toast.LENGTH_LONG).show();
+        if (extractor == null) {
+          Toast.makeText(context, R.string.error_cant_decompress_that_file, Toast.LENGTH_LONG)
+              .show();
           return false;
         }
 
@@ -333,7 +334,10 @@ public class ExtractService extends AbstractProgressiveService {
           Log.e(TAG, "Archive " + compressedPath + " is a corrupted archive.", e);
           AppConfig.toast(
               extractService,
-              e.getCause() != null && TextUtils.isEmpty(e.getCause().getMessage()) ? getString(R.string.error_bad_archive_without_info, compressedPath) : getString(R.string.error_bad_archive_with_info, compressedPath, e.getMessage()));
+              e.getCause() != null && TextUtils.isEmpty(e.getCause().getMessage())
+                  ? getString(R.string.error_bad_archive_without_info, compressedPath)
+                  : getString(
+                      R.string.error_bad_archive_with_info, compressedPath, e.getMessage()));
           return true;
         } catch (CorruptedInputException e) {
           Log.d(TAG, "Corrupted LZMA input", e);
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/services/ZipService.kt b/app/src/main/java/com/amaze/filemanager/asynchronous/services/ZipService.kt
index e447e12ef..00a5b638e 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/services/ZipService.kt
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/services/ZipService.kt
@@ -103,10 +103,15 @@ class ZipService : AbstractProgressiveService() {
 
         val stopIntent = Intent(KEY_COMPRESS_BROADCAST_CANCEL)
         val stopPendingIntent = PendingIntent.getBroadcast(
-            applicationContext, 1234, stopIntent, PendingIntent.FLAG_UPDATE_CURRENT
+            applicationContext,
+            1234,
+            stopIntent,
+            PendingIntent.FLAG_UPDATE_CURRENT
         )
         val action = NotificationCompat.Action(
-            R.drawable.ic_zip_box_grey, getString(R.string.stop_ftp), stopPendingIntent
+            R.drawable.ic_zip_box_grey,
+            getString(R.string.stop_ftp),
+            stopPendingIntent
         )
         mBuilder = NotificationCompat.Builder(this, NotificationConstants.CHANNEL_NORMAL_ID)
             .setSmallIcon(R.drawable.ic_zip_box_grey)
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/services/ftp/FtpService.kt b/app/src/main/java/com/amaze/filemanager/asynchronous/services/ftp/FtpService.kt
index 139a97a61..30886ae8e 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/services/ftp/FtpService.kt
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/services/ftp/FtpService.kt
@@ -46,7 +46,7 @@ import com.amaze.filemanager.R
 import com.amaze.filemanager.application.AppConfig
 import com.amaze.filemanager.filesystem.ftpserver.AndroidFileSystemFactory
 import com.amaze.filemanager.filesystem.ftpserver.RootFileSystemFactory
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_ROOTMODE
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_ROOTMODE
 import com.amaze.filemanager.ui.notifications.FtpNotification
 import com.amaze.filemanager.ui.notifications.NotificationConstants
 import com.amaze.filemanager.utils.ObtainableServiceBinder
@@ -145,7 +145,8 @@ class FtpService : Service(), Runnable {
                 username = usernamePreference
                 runCatching {
                     password = PasswordUtil.decryptPassword(
-                        applicationContext, preferences.getString(KEY_PREFERENCE_PASSWORD, "")!!
+                        applicationContext,
+                        preferences.getString(KEY_PREFERENCE_PASSWORD, "")!!
                     )
                     isPasswordProtected = true
                 }.onFailure {
@@ -210,10 +211,11 @@ class FtpService : Service(), Runnable {
                     start()
                     EventBus.getDefault()
                         .post(
-                            if (isStartedByTile)
+                            if (isStartedByTile) {
                                 FtpReceiverActions.STARTED_FROM_TILE
-                            else
+                            } else {
                                 FtpReceiverActions.STARTED
+                            }
                         )
                 }
             }.onFailure {
@@ -248,7 +250,10 @@ class FtpService : Service(), Runnable {
             PendingIntent.FLAG_ONE_SHOT
         }
         val restartServicePI = PendingIntent.getService(
-            applicationContext, 1, restartService, flag
+            applicationContext,
+            1,
+            restartService,
+            flag
         )
         val alarmService = applicationContext.getSystemService(ALARM_SERVICE) as AlarmManager
         alarmService[AlarmManager.ELAPSED_REALTIME, SystemClock.elapsedRealtime() + 2000] =
@@ -311,6 +316,7 @@ class FtpService : Service(), Runnable {
                 }
             }.toTypedArray()
         }
+
         /**
          * Return a list of available ciphers for ftpserver.
          *
diff --git a/app/src/main/java/com/amaze/filemanager/crashreport/AcraReportSender.kt b/app/src/main/java/com/amaze/filemanager/crashreport/AcraReportSender.kt
index 82992b8f9..e528aa763 100644
--- a/app/src/main/java/com/amaze/filemanager/crashreport/AcraReportSender.kt
+++ b/app/src/main/java/com/amaze/filemanager/crashreport/AcraReportSender.kt
@@ -29,10 +29,12 @@ class AcraReportSender : ReportSender {
 
     override fun send(context: Context, errorContent: CrashReportData) {
         ErrorActivity.reportError(
-            context, errorContent,
+            context,
+            errorContent,
             ErrorActivity.ErrorInfo.make(
                 ErrorActivity.ERROR_UI_ERROR,
-                "Application crash", R.string.app_ui_crash
+                "Application crash",
+                R.string.app_ui_crash
             )
         )
     }
diff --git a/app/src/main/java/com/amaze/filemanager/crashreport/ErrorActivity.java b/app/src/main/java/com/amaze/filemanager/crashreport/ErrorActivity.java
index 2ba525da8..1720e48c3 100644
--- a/app/src/main/java/com/amaze/filemanager/crashreport/ErrorActivity.java
+++ b/app/src/main/java/com/amaze/filemanager/crashreport/ErrorActivity.java
@@ -20,6 +20,29 @@
 
 package com.amaze.filemanager.crashreport;
 
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.text.SimpleDateFormat;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.TimeZone;
+import java.util.Vector;
+
+import org.acra.ReportField;
+import org.acra.data.CrashReportData;
+import org.json.JSONObject;
+
+import com.amaze.filemanager.BuildConfig;
+import com.amaze.filemanager.R;
+import com.amaze.filemanager.filesystem.files.FileUtils;
+import com.amaze.filemanager.ui.activities.MainActivity;
+import com.amaze.filemanager.ui.activities.superclasses.ThemedActivity;
+import com.amaze.filemanager.utils.Utils;
+import com.google.android.material.snackbar.Snackbar;
+
 import android.content.Context;
 import android.content.Intent;
 import android.graphics.Color;
@@ -43,29 +66,6 @@ import androidx.appcompat.app.ActionBar;
 import androidx.appcompat.widget.Toolbar;
 import androidx.core.app.NavUtils;
 
-import com.amaze.filemanager.BuildConfig;
-import com.amaze.filemanager.R;
-import com.amaze.filemanager.filesystem.files.FileUtils;
-import com.amaze.filemanager.ui.activities.MainActivity;
-import com.amaze.filemanager.ui.activities.superclasses.ThemedActivity;
-import com.amaze.filemanager.utils.Utils;
-import com.google.android.material.snackbar.Snackbar;
-
-import org.acra.ReportField;
-import org.acra.data.CrashReportData;
-import org.json.JSONObject;
-
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.text.SimpleDateFormat;
-import java.util.Arrays;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.TimeZone;
-import java.util.Vector;
-
 /*
  * Created by Christian Schabesberger on 24.10.15.
  *
@@ -150,7 +150,7 @@ public class ErrorActivity extends ThemedActivity {
     // Add this to try figure out what happened when stacktrace is sent to acra.
     // Hope this will be useful for build failures...
     if (BuildConfig.DEBUG) {
-      for(String line: el) {
+      for (String line : el) {
         System.out.println(line);
       }
     }
diff --git a/app/src/main/java/com/amaze/filemanager/database/CloudHandler.java b/app/src/main/java/com/amaze/filemanager/database/CloudHandler.java
index 9a50f3613..9e7f7f455 100644
--- a/app/src/main/java/com/amaze/filemanager/database/CloudHandler.java
+++ b/app/src/main/java/com/amaze/filemanager/database/CloudHandler.java
@@ -23,8 +23,8 @@ package com.amaze.filemanager.database;
 import java.util.List;
 
 import com.amaze.filemanager.database.models.explorer.CloudEntry;
-import com.amaze.filemanager.file_operations.exceptions.CloudPluginException;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.exceptions.CloudPluginException;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.ui.fragments.CloudSheetFragment;
 
 import android.content.Context;
diff --git a/app/src/main/java/com/amaze/filemanager/database/ExplorerDatabase.java b/app/src/main/java/com/amaze/filemanager/database/ExplorerDatabase.java
index ce14d3110..7fc67d016 100644
--- a/app/src/main/java/com/amaze/filemanager/database/ExplorerDatabase.java
+++ b/app/src/main/java/com/amaze/filemanager/database/ExplorerDatabase.java
@@ -22,6 +22,15 @@ package com.amaze.filemanager.database;
 
 import static com.amaze.filemanager.database.ExplorerDatabase.DATABASE_VERSION;
 
+import com.amaze.filemanager.database.daos.CloudEntryDao;
+import com.amaze.filemanager.database.daos.EncryptedEntryDao;
+import com.amaze.filemanager.database.daos.SortDao;
+import com.amaze.filemanager.database.daos.TabDao;
+import com.amaze.filemanager.database.models.explorer.CloudEntry;
+import com.amaze.filemanager.database.models.explorer.EncryptedEntry;
+import com.amaze.filemanager.database.models.explorer.Sort;
+import com.amaze.filemanager.database.models.explorer.Tab;
+
 import android.content.Context;
 
 import androidx.annotation.NonNull;
@@ -33,15 +42,6 @@ import androidx.room.RoomDatabase;
 import androidx.room.migration.Migration;
 import androidx.sqlite.db.SupportSQLiteDatabase;
 
-import com.amaze.filemanager.database.daos.CloudEntryDao;
-import com.amaze.filemanager.database.daos.EncryptedEntryDao;
-import com.amaze.filemanager.database.daos.SortDao;
-import com.amaze.filemanager.database.daos.TabDao;
-import com.amaze.filemanager.database.models.explorer.CloudEntry;
-import com.amaze.filemanager.database.models.explorer.EncryptedEntry;
-import com.amaze.filemanager.database.models.explorer.Sort;
-import com.amaze.filemanager.database.models.explorer.Tab;
-
 /**
  * Repository for {@link Tab}, {@link Sort}, {@link EncryptedEntry}, {@link CloudEntry} in
  * explorer.db in Amaze.
@@ -281,10 +281,12 @@ public abstract class ExplorerDatabase extends RoomDatabase {
   protected abstract CloudEntryDao cloudEntryDao();
 
   public static synchronized ExplorerDatabase initialize(@NonNull Context context) {
-    Builder<ExplorerDatabase> builder = (overrideDatabaseBuilder == null) ?
-            Room.databaseBuilder(context, ExplorerDatabase.class, DATABASE_NAME) :
-            overrideDatabaseBuilder.apply(context);
-    return builder.addMigrations(MIGRATION_1_2)
+    Builder<ExplorerDatabase> builder =
+        (overrideDatabaseBuilder == null)
+            ? Room.databaseBuilder(context, ExplorerDatabase.class, DATABASE_NAME)
+            : overrideDatabaseBuilder.apply(context);
+    return builder
+        .addMigrations(MIGRATION_1_2)
         .addMigrations(MIGRATION_2_3)
         .addMigrations(MIGRATION_3_4)
         .addMigrations(MIGRATION_4_5)
diff --git a/app/src/main/java/com/amaze/filemanager/database/SortHandler.java b/app/src/main/java/com/amaze/filemanager/database/SortHandler.java
index 76ab9170d..1f85ffad8 100644
--- a/app/src/main/java/com/amaze/filemanager/database/SortHandler.java
+++ b/app/src/main/java/com/amaze/filemanager/database/SortHandler.java
@@ -20,7 +20,7 @@
 
 package com.amaze.filemanager.database;
 
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_SORTBY_ONLY_THIS;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SORTBY_ONLY_THIS;
 
 import java.util.HashSet;
 import java.util.Set;
diff --git a/app/src/main/java/com/amaze/filemanager/database/UtilitiesDatabase.java b/app/src/main/java/com/amaze/filemanager/database/UtilitiesDatabase.java
index 1b423d134..adcb4bd15 100644
--- a/app/src/main/java/com/amaze/filemanager/database/UtilitiesDatabase.java
+++ b/app/src/main/java/com/amaze/filemanager/database/UtilitiesDatabase.java
@@ -22,17 +22,6 @@ package com.amaze.filemanager.database;
 
 import static com.amaze.filemanager.database.UtilitiesDatabase.DATABASE_VERSION;
 
-import android.content.Context;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.VisibleForTesting;
-import androidx.arch.core.util.Function;
-import androidx.room.Database;
-import androidx.room.Room;
-import androidx.room.RoomDatabase;
-import androidx.room.migration.Migration;
-import androidx.sqlite.db.SupportSQLiteDatabase;
-
 import com.amaze.filemanager.database.daos.BookmarkEntryDao;
 import com.amaze.filemanager.database.daos.GridEntryDao;
 import com.amaze.filemanager.database.daos.HiddenEntryDao;
@@ -48,6 +37,17 @@ import com.amaze.filemanager.database.models.utilities.List;
 import com.amaze.filemanager.database.models.utilities.SftpEntry;
 import com.amaze.filemanager.database.models.utilities.SmbEntry;
 
+import android.content.Context;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.VisibleForTesting;
+import androidx.arch.core.util.Function;
+import androidx.room.Database;
+import androidx.room.Room;
+import androidx.room.RoomDatabase;
+import androidx.room.migration.Migration;
+import androidx.sqlite.db.SupportSQLiteDatabase;
+
 /**
  * Repository for {@link Bookmark}, {@link Grid}, {@link Hidden}, {@link History}, {@link List},
  * {@link SmbEntry}, {@link SftpEntry} objects in utilities.db in Amaze.
@@ -387,11 +387,13 @@ public abstract class UtilitiesDatabase extends RoomDatabase {
   protected abstract SftpEntryDao sftpEntryDao();
 
   public static UtilitiesDatabase initialize(@NonNull Context context) {
-    Builder<UtilitiesDatabase> builder = (overrideDatabaseBuilder == null) ?
-      Room.databaseBuilder(context, UtilitiesDatabase.class, DATABASE_NAME) :
-        overrideDatabaseBuilder.apply(context);
+    Builder<UtilitiesDatabase> builder =
+        (overrideDatabaseBuilder == null)
+            ? Room.databaseBuilder(context, UtilitiesDatabase.class, DATABASE_NAME)
+            : overrideDatabaseBuilder.apply(context);
 
-    return builder.allowMainThreadQueries()
+    return builder
+        .allowMainThreadQueries()
         .addMigrations(MIGRATION_1_2, MIGRATION_2_3, MIGRATION_3_4, MIGRATION_4_5)
         .build();
   }
diff --git a/app/src/main/java/com/amaze/filemanager/database/UtilsHandler.kt b/app/src/main/java/com/amaze/filemanager/database/UtilsHandler.kt
index ebaeda3d6..9f2487a3e 100644
--- a/app/src/main/java/com/amaze/filemanager/database/UtilsHandler.kt
+++ b/app/src/main/java/com/amaze/filemanager/database/UtilsHandler.kt
@@ -17,6 +17,7 @@
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
+
 package com.amaze.filemanager.database
 
 import android.content.Context
@@ -81,7 +82,9 @@ class UtilsHandler(
             Operation.LIST ->
                 utilitiesDatabase
                     .listEntryDao()
-                    .insert(com.amaze.filemanager.database.models.utilities.List(operationData.path))
+                    .insert(
+                        com.amaze.filemanager.database.models.utilities.List(operationData.path)
+                    )
                     .subscribeOn(Schedulers.io())
                     .subscribe()
             Operation.GRID ->
@@ -442,7 +445,7 @@ class UtilsHandler(
                 .findByNameAndPath(oldName, oldPath)
                 .subscribeOn(Schedulers.io())
                 .blockingGet()
-        } .onFailure {
+        }.onFailure {
             // catch error to handle Single#onError for blockingGet
             Log.e(TAG, it.message!!)
             return
diff --git a/app/src/main/java/com/amaze/filemanager/database/daos/SftpEntryDao.java b/app/src/main/java/com/amaze/filemanager/database/daos/SftpEntryDao.java
index 93a20c210..363fbd340 100644
--- a/app/src/main/java/com/amaze/filemanager/database/daos/SftpEntryDao.java
+++ b/app/src/main/java/com/amaze/filemanager/database/daos/SftpEntryDao.java
@@ -27,16 +27,16 @@ import static com.amaze.filemanager.database.UtilitiesDatabase.COLUMN_PRIVATE_KE
 import static com.amaze.filemanager.database.UtilitiesDatabase.COLUMN_PRIVATE_KEY_NAME;
 import static com.amaze.filemanager.database.UtilitiesDatabase.TABLE_SFTP;
 
+import java.util.List;
+
+import com.amaze.filemanager.database.models.utilities.SftpEntry;
+
 import androidx.room.Dao;
 import androidx.room.Insert;
 import androidx.room.OnConflictStrategy;
 import androidx.room.Query;
 import androidx.room.Update;
 
-import com.amaze.filemanager.database.models.utilities.SftpEntry;
-
-import java.util.List;
-
 import io.reactivex.Completable;
 import io.reactivex.Single;
 
diff --git a/app/src/main/java/com/amaze/filemanager/database/daos/SmbEntryDao.java b/app/src/main/java/com/amaze/filemanager/database/daos/SmbEntryDao.java
index 46da49414..adfd23dc5 100644
--- a/app/src/main/java/com/amaze/filemanager/database/daos/SmbEntryDao.java
+++ b/app/src/main/java/com/amaze/filemanager/database/daos/SmbEntryDao.java
@@ -24,16 +24,16 @@ import static com.amaze.filemanager.database.UtilitiesDatabase.COLUMN_NAME;
 import static com.amaze.filemanager.database.UtilitiesDatabase.COLUMN_PATH;
 import static com.amaze.filemanager.database.UtilitiesDatabase.TABLE_SMB;
 
+import java.util.List;
+
+import com.amaze.filemanager.database.models.utilities.SmbEntry;
+
 import androidx.room.Dao;
 import androidx.room.Insert;
 import androidx.room.OnConflictStrategy;
 import androidx.room.Query;
 import androidx.room.Update;
 
-import com.amaze.filemanager.database.models.utilities.SmbEntry;
-
-import java.util.List;
-
 import io.reactivex.Completable;
 import io.reactivex.Single;
 
diff --git a/app/src/main/java/com/amaze/filemanager/database/models/OperationData.java b/app/src/main/java/com/amaze/filemanager/database/models/OperationData.java
index 913791575..2cc3bc179 100644
--- a/app/src/main/java/com/amaze/filemanager/database/models/OperationData.java
+++ b/app/src/main/java/com/amaze/filemanager/database/models/OperationData.java
@@ -28,14 +28,14 @@ import static com.amaze.filemanager.database.UtilsHandler.Operation.LIST;
 import static com.amaze.filemanager.database.UtilsHandler.Operation.SFTP;
 import static com.amaze.filemanager.database.UtilsHandler.Operation.SMB;
 
+import com.amaze.filemanager.database.UtilsHandler;
+import com.amaze.filemanager.database.UtilsHandler.Operation;
+
 import android.text.TextUtils;
 
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 
-import com.amaze.filemanager.database.UtilsHandler;
-import com.amaze.filemanager.database.UtilsHandler.Operation;
-
 public class OperationData {
   public final Operation type;
   public final String path;
@@ -82,12 +82,12 @@ public class OperationData {
    * UtilsHandler#removeFromDatabase(OperationData)}
    */
   public OperationData(
-          @NonNull Operation type,
-          @NonNull String path,
-          @NonNull String name,
-          @Nullable String hostKey,
-          @Nullable String sshKeyName,
-          @Nullable String sshKey) {
+      @NonNull Operation type,
+      @NonNull String path,
+      @NonNull String name,
+      @Nullable String hostKey,
+      @Nullable String sshKeyName,
+      @Nullable String sshKey) {
     if (type != SFTP) throw new IllegalArgumentException("Wrong constructor for object type");
 
     this.type = type;
diff --git a/app/src/main/java/com/amaze/filemanager/database/models/explorer/CloudEntry.java b/app/src/main/java/com/amaze/filemanager/database/models/explorer/CloudEntry.java
index e67d02980..ec22c71ed 100644
--- a/app/src/main/java/com/amaze/filemanager/database/models/explorer/CloudEntry.java
+++ b/app/src/main/java/com/amaze/filemanager/database/models/explorer/CloudEntry.java
@@ -24,7 +24,7 @@ import com.amaze.filemanager.database.ExplorerDatabase;
 import com.amaze.filemanager.database.models.StringWrapper;
 import com.amaze.filemanager.database.typeconverters.EncryptedStringTypeConverter;
 import com.amaze.filemanager.database.typeconverters.OpenModeTypeConverter;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 
 import androidx.room.ColumnInfo;
 import androidx.room.Entity;
diff --git a/app/src/main/java/com/amaze/filemanager/database/models/utilities/OperationData.java b/app/src/main/java/com/amaze/filemanager/database/models/utilities/OperationData.java
index ed4411822..98eb2ab8a 100644
--- a/app/src/main/java/com/amaze/filemanager/database/models/utilities/OperationData.java
+++ b/app/src/main/java/com/amaze/filemanager/database/models/utilities/OperationData.java
@@ -20,13 +20,13 @@
 
 package com.amaze.filemanager.database.models.utilities;
 
+import com.amaze.filemanager.database.UtilitiesDatabase;
+
 import androidx.annotation.NonNull;
 import androidx.room.ColumnInfo;
 import androidx.room.Entity;
 import androidx.room.PrimaryKey;
 
-import com.amaze.filemanager.database.UtilitiesDatabase;
-
 /**
  * Base class {@link Entity} representation of tables in utilities.db.
  *
diff --git a/app/src/main/java/com/amaze/filemanager/database/models/utilities/OperationDataWithName.java b/app/src/main/java/com/amaze/filemanager/database/models/utilities/OperationDataWithName.java
index ddbfbabea..18314c524 100644
--- a/app/src/main/java/com/amaze/filemanager/database/models/utilities/OperationDataWithName.java
+++ b/app/src/main/java/com/amaze/filemanager/database/models/utilities/OperationDataWithName.java
@@ -20,12 +20,12 @@
 
 package com.amaze.filemanager.database.models.utilities;
 
+import com.amaze.filemanager.database.UtilitiesDatabase;
+
 import androidx.annotation.NonNull;
 import androidx.room.ColumnInfo;
 import androidx.room.Entity;
 
-import com.amaze.filemanager.database.UtilitiesDatabase;
-
 /**
  * Base class {@link Entity} representation of tables in utilities.db.
  *
diff --git a/app/src/main/java/com/amaze/filemanager/database/models/utilities/SftpEntry.java b/app/src/main/java/com/amaze/filemanager/database/models/utilities/SftpEntry.java
index b4667c950..e42401fed 100644
--- a/app/src/main/java/com/amaze/filemanager/database/models/utilities/SftpEntry.java
+++ b/app/src/main/java/com/amaze/filemanager/database/models/utilities/SftpEntry.java
@@ -20,13 +20,13 @@
 
 package com.amaze.filemanager.database.models.utilities;
 
+import com.amaze.filemanager.database.UtilitiesDatabase;
+
 import android.text.TextUtils;
 
 import androidx.room.ColumnInfo;
 import androidx.room.Entity;
 
-import com.amaze.filemanager.database.UtilitiesDatabase;
-
 /**
  * {@link Entity} representation of <code>sftp</code> table in utilities.db.
  *
@@ -71,15 +71,15 @@ public class SftpEntry extends OperationDataWithName {
     SftpEntry sftpEntry = (SftpEntry) o;
 
     if (!hostKey.equals(sftpEntry.hostKey)) return false;
-    return (sshKey != null && sshKey.equals(sftpEntry.sshKey)) ||
-            sshKey == null && sftpEntry.sshKey == null;
+    return (sshKey != null && sshKey.equals(sftpEntry.sshKey))
+        || sshKey == null && sftpEntry.sshKey == null;
   }
 
   @Override
   public int hashCode() {
     int result = super.hashCode();
     result = 31 * result + hostKey.hashCode();
-    if(sshKey != null) {
+    if (sshKey != null) {
       result = 31 * result + sshKey.hashCode();
     }
     return result;
diff --git a/app/src/main/java/com/amaze/filemanager/database/typeconverters/OpenModeTypeConverter.java b/app/src/main/java/com/amaze/filemanager/database/typeconverters/OpenModeTypeConverter.java
index dfc642f84..cf6e923b3 100644
--- a/app/src/main/java/com/amaze/filemanager/database/typeconverters/OpenModeTypeConverter.java
+++ b/app/src/main/java/com/amaze/filemanager/database/typeconverters/OpenModeTypeConverter.java
@@ -20,7 +20,7 @@
 
 package com.amaze.filemanager.database.typeconverters;
 
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 
 import androidx.room.TypeConverter;
 
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/DeleteOperation.kt b/app/src/main/java/com/amaze/filemanager/filesystem/DeleteOperation.kt
index f89a1e92b..0799307ae 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/DeleteOperation.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/DeleteOperation.kt
@@ -69,7 +69,8 @@ object DeleteOperation {
             // Delete the created entry, such that content provider will delete the file.
             resolver.delete(
                 MediaStore.Files.getContentUri("external"),
-                MediaStore.MediaColumns.DATA + "=?", arrayOf(file.absolutePath)
+                MediaStore.MediaColumns.DATA + "=?",
+                arrayOf(file.absolutePath)
             )
         }
         return !file.exists()
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/ExternalSdCardOperation.kt b/app/src/main/java/com/amaze/filemanager/filesystem/ExternalSdCardOperation.kt
index 3bf333741..a6abf42c8 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/ExternalSdCardOperation.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/ExternalSdCardOperation.kt
@@ -27,7 +27,7 @@ import android.os.Build
 import android.util.Log
 import androidx.documentfile.provider.DocumentFile
 import androidx.preference.PreferenceManager
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants
 import java.io.File
 import java.io.IOException
 import java.util.*
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/FileUtil.java b/app/src/main/java/com/amaze/filemanager/filesystem/FileUtil.java
index 329089b3a..4af555add 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/FileUtil.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/FileUtil.java
@@ -34,7 +34,7 @@ import com.amaze.filemanager.R;
 import com.amaze.filemanager.application.AppConfig;
 import com.amaze.filemanager.exceptions.NotAllowedException;
 import com.amaze.filemanager.exceptions.OperationWouldOverwriteException;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.cloud.CloudUtil;
 import com.amaze.filemanager.filesystem.files.GenericCopyUtil;
 import com.amaze.filemanager.ui.activities.MainActivity;
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/HybridFile.java b/app/src/main/java/com/amaze/filemanager/filesystem/HybridFile.java
index 77a06f07d..5597f42c6 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/HybridFile.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/HybridFile.java
@@ -38,10 +38,10 @@ import com.amaze.filemanager.R;
 import com.amaze.filemanager.adapters.data.LayoutElementParcelable;
 import com.amaze.filemanager.application.AppConfig;
 import com.amaze.filemanager.database.CloudHandler;
-import com.amaze.filemanager.file_operations.exceptions.CloudPluginException;
-import com.amaze.filemanager.file_operations.exceptions.ShellNotRunningException;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
-import com.amaze.filemanager.file_operations.filesystem.root.NativeOperations;
+import com.amaze.filemanager.fileoperations.exceptions.CloudPluginException;
+import com.amaze.filemanager.fileoperations.exceptions.ShellNotRunningException;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.root.NativeOperations;
 import com.amaze.filemanager.filesystem.cloud.CloudUtil;
 import com.amaze.filemanager.filesystem.files.FileUtils;
 import com.amaze.filemanager.filesystem.root.DeleteFileCommand;
@@ -51,7 +51,7 @@ import com.amaze.filemanager.filesystem.ssh.SshClientTemplate;
 import com.amaze.filemanager.filesystem.ssh.SshClientUtils;
 import com.amaze.filemanager.filesystem.ssh.SshConnectionPool;
 import com.amaze.filemanager.filesystem.ssh.Statvfs;
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants;
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants;
 import com.amaze.filemanager.utils.DataUtils;
 import com.amaze.filemanager.utils.OTGUtil;
 import com.amaze.filemanager.utils.OnFileFound;
@@ -561,10 +561,15 @@ public class HybridFile {
       case BOX:
       case GDRIVE:
       case ONEDRIVE:
-        isDirectory = Single.fromCallable(() -> dataUtils
-                .getAccount(mode)
-                .getMetadata(CloudUtil.stripPath(mode, path))
-                .getFolder()).subscribeOn(Schedulers.io()).blockingGet();
+        isDirectory =
+            Single.fromCallable(
+                    () ->
+                        dataUtils
+                            .getAccount(mode)
+                            .getMetadata(CloudUtil.stripPath(mode, path))
+                            .getFolder())
+                .subscribeOn(Schedulers.io())
+                .blockingGet();
         break;
       default:
         isDirectory = getFile().isDirectory();
@@ -573,7 +578,9 @@ public class HybridFile {
     return isDirectory;
   }
 
-  /** @deprecated use {@link #folderSize(Context)} */
+  /**
+   * @deprecated use {@link #folderSize(Context)}
+   */
   public long folderSize() {
     long size = 0L;
 
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/HybridFileParcelable.java b/app/src/main/java/com/amaze/filemanager/filesystem/HybridFileParcelable.java
index a4db3e823..21f7195e7 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/HybridFileParcelable.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/HybridFileParcelable.java
@@ -20,9 +20,9 @@
 
 package com.amaze.filemanager.filesystem;
 
-import static com.amaze.filemanager.file_operations.filesystem.OpenMode.DOCUMENT_FILE;
+import static com.amaze.filemanager.fileoperations.filesystem.OpenMode.DOCUMENT_FILE;
 
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.utils.Utils;
 
 import android.content.ContentResolver;
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/MakeDirectoryOperation.kt b/app/src/main/java/com/amaze/filemanager/filesystem/MakeDirectoryOperation.kt
index 95bc45c07..57d65d87f 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/MakeDirectoryOperation.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/MakeDirectoryOperation.kt
@@ -22,7 +22,7 @@ package com.amaze.filemanager.filesystem
 
 import android.content.Context
 import android.os.Build
-import com.amaze.filemanager.file_operations.filesystem.OpenMode
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode
 import com.amaze.filemanager.utils.OTGUtil
 import jcifs.smb.SmbException
 import java.io.File
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/MakeFileOperation.kt b/app/src/main/java/com/amaze/filemanager/filesystem/MakeFileOperation.kt
index ba370df2b..2149a37ca 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/MakeFileOperation.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/MakeFileOperation.kt
@@ -73,7 +73,8 @@ object MakeFileOperation {
             return try {
                 (
                     document?.createFile(
-                        MimeTypes.getMimeType(file.path, file.isDirectory), file.name
+                        MimeTypes.getMimeType(file.path, file.isDirectory),
+                        file.name
                     )
                         != null
                     )
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/Operations.java b/app/src/main/java/com/amaze/filemanager/filesystem/Operations.java
index 081eb14fd..dcb59af9c 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/Operations.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/Operations.java
@@ -33,8 +33,8 @@ import java.util.ArrayList;
 import java.util.concurrent.Executor;
 
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.file_operations.exceptions.ShellNotRunningException;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.exceptions.ShellNotRunningException;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.cloud.CloudUtil;
 import com.amaze.filemanager.filesystem.files.FileUtils;
 import com.amaze.filemanager.filesystem.root.MakeDirectoryCommand;
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/PasteHelper.java b/app/src/main/java/com/amaze/filemanager/filesystem/PasteHelper.java
index 510560210..6609be43c 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/PasteHelper.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/PasteHelper.java
@@ -22,14 +22,8 @@ package com.amaze.filemanager.filesystem;
 
 import static androidx.core.text.HtmlCompat.FROM_HTML_MODE_COMPACT;
 
-import android.os.AsyncTask;
-import android.os.Parcel;
-import android.os.Parcelable;
-import android.text.Spanned;
-import android.util.Log;
-
-import androidx.annotation.Nullable;
-import androidx.core.text.HtmlCompat;
+import java.util.ArrayList;
+import java.util.Arrays;
 
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.asynchronous.asynctasks.movecopy.PrepareCopyTask;
@@ -39,9 +33,14 @@ import com.amaze.filemanager.utils.Utils;
 import com.google.android.material.snackbar.BaseTransientBottomBar;
 import com.google.android.material.snackbar.Snackbar;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Objects;
+import android.os.AsyncTask;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.text.Spanned;
+import android.util.Log;
+
+import androidx.annotation.Nullable;
+import androidx.core.text.HtmlCompat;
 
 import io.reactivex.Single;
 import io.reactivex.SingleObserver;
@@ -160,8 +159,7 @@ public final class PasteHelper implements Parcelable {
                         R.string.paste,
                         () -> {
                           final MainFragment mainFragment = mainActivity.getCurrentMainFragment();
-                          if (mainFragment == null)
-                              return;
+                          if (mainFragment == null) return;
                           String path = mainFragment.getCurrentPath();
                           ArrayList<HybridFileParcelable> arrayList =
                               new ArrayList<>(Arrays.asList(paths));
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/RenameOperation.kt b/app/src/main/java/com/amaze/filemanager/filesystem/RenameOperation.kt
index 4500deae7..731ebb0cc 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/RenameOperation.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/RenameOperation.kt
@@ -23,7 +23,7 @@ package com.amaze.filemanager.filesystem
 import android.content.Context
 import android.os.Build
 import android.util.Log
-import com.amaze.filemanager.file_operations.exceptions.ShellNotRunningException
+import com.amaze.filemanager.fileoperations.exceptions.ShellNotRunningException
 import com.amaze.filemanager.filesystem.MakeDirectoryOperation.mkdir
 import com.amaze.filemanager.filesystem.root.RenameFileCommand.renameFile
 import java.io.*
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/RootHelper.java b/app/src/main/java/com/amaze/filemanager/filesystem/RootHelper.java
index a7318eca6..dd9c36f25 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/RootHelper.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/RootHelper.java
@@ -24,7 +24,7 @@ import java.io.File;
 import java.util.ArrayList;
 import java.util.List;
 
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.root.ListFilesCommand;
 
 import androidx.documentfile.provider.DocumentFile;
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/SafRootHolder.kt b/app/src/main/java/com/amaze/filemanager/filesystem/SafRootHolder.kt
index 9687c3b8c..4c3bafaa2 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/SafRootHolder.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/SafRootHolder.kt
@@ -25,8 +25,10 @@ import android.net.Uri
 object SafRootHolder {
     var uriRoot: Uri? = null
         @JvmStatic set
+
         @JvmStatic get
     var volumeLabel: String? = null
         @JvmStatic set
+
         @JvmStatic get
 }
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/cloud/CloudUtil.java b/app/src/main/java/com/amaze/filemanager/filesystem/cloud/CloudUtil.java
index 4aabb07f8..7f3c01793 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/cloud/CloudUtil.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/cloud/CloudUtil.java
@@ -31,9 +31,9 @@ import java.util.List;
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.adapters.data.IconDataParcelable;
 import com.amaze.filemanager.database.CloudHandler;
-import com.amaze.filemanager.file_operations.exceptions.CloudPluginException;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
-import com.amaze.filemanager.file_operations.filesystem.cloud.CloudStreamer;
+import com.amaze.filemanager.fileoperations.exceptions.CloudPluginException;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.cloud.CloudStreamer;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.ssh.SFtpClientTemplate;
@@ -72,7 +72,9 @@ public class CloudUtil {
 
   public static final String TAG = "Explorer";
 
-  /** @deprecated use getCloudFiles() */
+  /**
+   * @deprecated use getCloudFiles()
+   */
   public static ArrayList<HybridFileParcelable> listFiles(
       String path, CloudStorage cloudStorage, OpenMode openMode) throws CloudPluginException {
     final ArrayList<HybridFileParcelable> baseFiles = new ArrayList<>();
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/CompressedHelper.java b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/CompressedHelper.java
index 29202b50a..26372716f 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/CompressedHelper.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/CompressedHelper.java
@@ -23,7 +23,7 @@ package com.amaze.filemanager.filesystem.compressed;
 import java.io.File;
 
 import com.amaze.filemanager.BuildConfig;
-import com.amaze.filemanager.file_operations.utils.UpdatePosition;
+import com.amaze.filemanager.fileoperations.utils.UpdatePosition;
 import com.amaze.filemanager.filesystem.compressed.extractcontents.Extractor;
 import com.amaze.filemanager.filesystem.compressed.extractcontents.helpers.Bzip2Extractor;
 import com.amaze.filemanager.filesystem.compressed.extractcontents.helpers.GzipExtractor;
@@ -123,7 +123,7 @@ public abstract class CompressedHelper {
     } else if (isBzip2(type)) {
       extractor = new Bzip2Extractor(context, file.getPath(), outputPath, listener, updatePosition);
     } else {
-      if(BuildConfig.DEBUG) {
+      if (BuildConfig.DEBUG) {
         throw new IllegalArgumentException("The compressed file has no way of opening it: " + file);
       }
       Log.e(TAG, "The compressed file has no way of opening it: " + file);
@@ -161,7 +161,7 @@ public abstract class CompressedHelper {
       // without the compression extension
       decompressor = new UnknownCompressedFileDecompressor(context);
     } else {
-      if(BuildConfig.DEBUG) {
+      if (BuildConfig.DEBUG) {
         throw new IllegalArgumentException("The compressed file has no way of opening it: " + file);
       }
 
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/Extractor.java b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/Extractor.java
index 7101c6e49..4b9b8506b 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/Extractor.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/Extractor.java
@@ -23,18 +23,18 @@ package com.amaze.filemanager.filesystem.compressed.extractcontents;
 import static com.amaze.filemanager.filesystem.compressed.CompressedHelper.SEPARATOR;
 import static com.amaze.filemanager.filesystem.compressed.CompressedHelper.SEPARATOR_CHAR;
 
-import android.content.Context;
-
-import androidx.annotation.NonNull;
-
-import com.amaze.filemanager.file_operations.utils.UpdatePosition;
-
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 
+import com.amaze.filemanager.fileoperations.utils.UpdatePosition;
+
+import android.content.Context;
+
+import androidx.annotation.NonNull;
+
 public abstract class Extractor {
 
   protected Context context;
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/AbstractCommonsArchiveExtractor.kt b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/AbstractCommonsArchiveExtractor.kt
index 9ea611d22..d2e0ee964 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/AbstractCommonsArchiveExtractor.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/AbstractCommonsArchiveExtractor.kt
@@ -23,7 +23,7 @@ package com.amaze.filemanager.filesystem.compressed.extractcontents.helpers
 import android.content.Context
 import com.amaze.filemanager.R
 import com.amaze.filemanager.application.AppConfig
-import com.amaze.filemanager.file_operations.utils.UpdatePosition
+import com.amaze.filemanager.fileoperations.utils.UpdatePosition
 import com.amaze.filemanager.filesystem.FileUtil
 import com.amaze.filemanager.filesystem.MakeDirectoryOperation
 import com.amaze.filemanager.filesystem.compressed.extractcontents.Extractor
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/AbstractCommonsCompressedFileExtractor.kt b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/AbstractCommonsCompressedFileExtractor.kt
index c7c2cdf64..52d9a78ba 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/AbstractCommonsCompressedFileExtractor.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/AbstractCommonsCompressedFileExtractor.kt
@@ -23,7 +23,7 @@ package com.amaze.filemanager.filesystem.compressed.extractcontents.helpers
 import android.content.Context
 import com.amaze.filemanager.R
 import com.amaze.filemanager.application.AppConfig
-import com.amaze.filemanager.file_operations.utils.UpdatePosition
+import com.amaze.filemanager.fileoperations.utils.UpdatePosition
 import com.amaze.filemanager.filesystem.FileUtil
 import com.amaze.filemanager.filesystem.MakeDirectoryOperation
 import com.amaze.filemanager.filesystem.compressed.extractcontents.Extractor
@@ -61,27 +61,33 @@ abstract class AbstractCommonsCompressedFileExtractor(
     override fun extractWithFilter(filter: Filter) {
         val entryName = filePath.substringAfterLast('/').substringBeforeLast('.')
         runCatching {
-            compressorInputStreamConstructor.newInstance(FileInputStream(filePath)).use { inputStream ->
-                val outputFile = File(outputPath, entryName)
-                if (false == outputFile.parentFile?.exists()) {
-                    MakeDirectoryOperation.mkdir(outputFile.parentFile, context)
-                }
-                FileUtil.getOutputStream(outputFile, context)?.let { fileOutputStream ->
-                    BufferedOutputStream(fileOutputStream).use {
-                        var len: Int
-                        val buf = ByteArray(GenericCopyUtil.DEFAULT_BUFFER_SIZE)
-                        while (inputStream.read(buf).also { len = it } != -1) {
-                            it.write(buf, 0, len)
-                            updatePosition.updatePosition(len.toLong())
-                        }
-                        listener.onFinish()
+            compressorInputStreamConstructor
+                .newInstance(FileInputStream(filePath))
+                .use { inputStream ->
+                    val outputFile = File(outputPath, entryName)
+                    if (false == outputFile.parentFile?.exists()) {
+                        MakeDirectoryOperation.mkdir(outputFile.parentFile, context)
                     }
-                    outputFile.setLastModified(File(filePath).lastModified())
-                } ?: AppConfig.toast(
-                    context,
-                    context.getString(R.string.error_archive_cannot_extract, entryName, outputPath)
-                )
-            }
+                    FileUtil.getOutputStream(outputFile, context)?.let { fileOutputStream ->
+                        BufferedOutputStream(fileOutputStream).use {
+                            var len: Int
+                            val buf = ByteArray(GenericCopyUtil.DEFAULT_BUFFER_SIZE)
+                            while (inputStream.read(buf).also { len = it } != -1) {
+                                it.write(buf, 0, len)
+                                updatePosition.updatePosition(len.toLong())
+                            }
+                            listener.onFinish()
+                        }
+                        outputFile.setLastModified(File(filePath).lastModified())
+                    } ?: AppConfig.toast(
+                        context,
+                        context.getString(
+                            R.string.error_archive_cannot_extract,
+                            entryName,
+                            outputPath
+                        )
+                    )
+                }
         }.onFailure {
             throw BadArchiveNotice(it)
         }
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/AbstractCompressedTarArchiveExtractor.kt b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/AbstractCompressedTarArchiveExtractor.kt
index 11aa7b629..160869b24 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/AbstractCompressedTarArchiveExtractor.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/AbstractCompressedTarArchiveExtractor.kt
@@ -21,7 +21,7 @@
 package com.amaze.filemanager.filesystem.compressed.extractcontents.helpers
 
 import android.content.Context
-import com.amaze.filemanager.file_operations.utils.UpdatePosition
+import com.amaze.filemanager.fileoperations.utils.UpdatePosition
 import org.apache.commons.compress.archivers.tar.TarArchiveInputStream
 import org.apache.commons.compress.compressors.CompressorInputStream
 import java.io.InputStream
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/Bzip2Extractor.kt b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/Bzip2Extractor.kt
index d7276cf61..f0c8148b2 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/Bzip2Extractor.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/Bzip2Extractor.kt
@@ -21,7 +21,7 @@
 package com.amaze.filemanager.filesystem.compressed.extractcontents.helpers
 
 import android.content.Context
-import com.amaze.filemanager.file_operations.utils.UpdatePosition
+import com.amaze.filemanager.fileoperations.utils.UpdatePosition
 import org.apache.commons.compress.compressors.CompressorInputStream
 import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream
 
@@ -33,7 +33,10 @@ class Bzip2Extractor(
     updatePosition: UpdatePosition
 ) : AbstractCommonsCompressedFileExtractor(
     context,
-    filePath, outputPath, listener, updatePosition
+    filePath,
+    outputPath,
+    listener,
+    updatePosition
 ) {
     override fun getCompressorInputStreamClass(): Class<out CompressorInputStream> {
         return BZip2CompressorInputStream::class.java
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/GzipExtractor.kt b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/GzipExtractor.kt
index 785446ca0..663fff431 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/GzipExtractor.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/GzipExtractor.kt
@@ -21,7 +21,7 @@
 package com.amaze.filemanager.filesystem.compressed.extractcontents.helpers
 
 import android.content.Context
-import com.amaze.filemanager.file_operations.utils.UpdatePosition
+import com.amaze.filemanager.fileoperations.utils.UpdatePosition
 import org.apache.commons.compress.compressors.CompressorInputStream
 import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream
 
@@ -33,7 +33,10 @@ class GzipExtractor(
     updatePosition: UpdatePosition
 ) : AbstractCommonsCompressedFileExtractor(
     context,
-    filePath, outputPath, listener, updatePosition
+    filePath,
+    outputPath,
+    listener,
+    updatePosition
 ) {
     override fun getCompressorInputStreamClass(): Class<out CompressorInputStream> {
         return GzipCompressorInputStream::class.java
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/LzmaExtractor.kt b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/LzmaExtractor.kt
index 6bb173fde..79c6f08b0 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/LzmaExtractor.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/LzmaExtractor.kt
@@ -21,7 +21,7 @@
 package com.amaze.filemanager.filesystem.compressed.extractcontents.helpers
 
 import android.content.Context
-import com.amaze.filemanager.file_operations.utils.UpdatePosition
+import com.amaze.filemanager.fileoperations.utils.UpdatePosition
 import org.apache.commons.compress.compressors.CompressorInputStream
 import org.apache.commons.compress.compressors.lzma.LZMACompressorInputStream
 
@@ -33,7 +33,10 @@ class LzmaExtractor(
     updatePosition: UpdatePosition
 ) : AbstractCommonsCompressedFileExtractor(
     context,
-    filePath, outputPath, listener, updatePosition
+    filePath,
+    outputPath,
+    listener,
+    updatePosition
 ) {
     override fun getCompressorInputStreamClass(): Class<out CompressorInputStream> {
         return LZMACompressorInputStream::class.java
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/RarExtractor.kt b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/RarExtractor.kt
index 15410119a..806500eb9 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/RarExtractor.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/RarExtractor.kt
@@ -22,8 +22,8 @@ package com.amaze.filemanager.filesystem.compressed.extractcontents.helpers
 
 import android.content.Context
 import com.amaze.filemanager.asynchronous.management.ServiceWatcherUtil
-import com.amaze.filemanager.file_operations.filesystem.compressed.ArchivePasswordCache
-import com.amaze.filemanager.file_operations.utils.UpdatePosition
+import com.amaze.filemanager.fileoperations.filesystem.compressed.ArchivePasswordCache
+import com.amaze.filemanager.fileoperations.utils.UpdatePosition
 import com.amaze.filemanager.filesystem.FileUtil
 import com.amaze.filemanager.filesystem.MakeDirectoryOperation
 import com.amaze.filemanager.filesystem.compressed.CompressedHelper
@@ -158,7 +158,8 @@ class RarExtractor(
         */
         val inputStream = BufferedInputStream(rarFile.getInputStream(entry))
         val outputStream = CheckedOutputStream(
-            BufferedOutputStream(FileUtil.getOutputStream(outputFile, context)), CRC32()
+            BufferedOutputStream(FileUtil.getOutputStream(outputFile, context)),
+            CRC32()
         )
         try {
             var len: Int
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/SevenZipExtractor.kt b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/SevenZipExtractor.kt
index 8295212ac..c2fb0a081 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/SevenZipExtractor.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/SevenZipExtractor.kt
@@ -24,8 +24,8 @@ import android.content.Context
 import android.util.Log
 import com.amaze.filemanager.R
 import com.amaze.filemanager.application.AppConfig
-import com.amaze.filemanager.file_operations.filesystem.compressed.ArchivePasswordCache
-import com.amaze.filemanager.file_operations.utils.UpdatePosition
+import com.amaze.filemanager.fileoperations.filesystem.compressed.ArchivePasswordCache
+import com.amaze.filemanager.fileoperations.utils.UpdatePosition
 import com.amaze.filemanager.filesystem.FileUtil
 import com.amaze.filemanager.filesystem.MakeDirectoryOperation
 import com.amaze.filemanager.filesystem.compressed.extractcontents.Extractor
@@ -53,7 +53,10 @@ class SevenZipExtractor(
         var totalBytes: Long = 0
         val sevenzFile = runCatching {
             if (ArchivePasswordCache.getInstance().containsKey(filePath)) {
-                SevenZFile(File(filePath), ArchivePasswordCache.getInstance()[filePath]!!.toCharArray())
+                SevenZFile(
+                    File(filePath),
+                    ArchivePasswordCache.getInstance()[filePath]!!.toCharArray()
+                )
             } else {
                 SevenZFile(File(filePath))
             }
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/TarBzip2Extractor.kt b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/TarBzip2Extractor.kt
index 4bcf89828..47b148e21 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/TarBzip2Extractor.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/TarBzip2Extractor.kt
@@ -21,7 +21,7 @@
 package com.amaze.filemanager.filesystem.compressed.extractcontents.helpers
 
 import android.content.Context
-import com.amaze.filemanager.file_operations.utils.UpdatePosition
+import com.amaze.filemanager.fileoperations.utils.UpdatePosition
 import org.apache.commons.compress.compressors.CompressorInputStream
 import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream
 
@@ -32,7 +32,11 @@ class TarBzip2Extractor(
     listener: OnUpdate,
     updatePosition: UpdatePosition
 ) : AbstractCompressedTarArchiveExtractor(
-    context, filePath, outputPath, listener, updatePosition
+    context,
+    filePath,
+    outputPath,
+    listener,
+    updatePosition
 ) {
 
     override fun getCompressorInputStreamClass(): Class<out CompressorInputStream> =
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/TarExtractor.kt b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/TarExtractor.kt
index 96d681229..282c6d627 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/TarExtractor.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/TarExtractor.kt
@@ -21,7 +21,7 @@
 package com.amaze.filemanager.filesystem.compressed.extractcontents.helpers
 
 import android.content.Context
-import com.amaze.filemanager.file_operations.utils.UpdatePosition
+import com.amaze.filemanager.fileoperations.utils.UpdatePosition
 import org.apache.commons.compress.archivers.tar.TarArchiveInputStream
 import java.io.InputStream
 
@@ -32,7 +32,11 @@ class TarExtractor(
     listener: OnUpdate,
     updatePosition: UpdatePosition
 ) : AbstractCommonsArchiveExtractor(
-    context, filePath, outputPath, listener, updatePosition
+    context,
+    filePath,
+    outputPath,
+    listener,
+    updatePosition
 ) {
 
     override fun createFrom(inputStream: InputStream): TarArchiveInputStream =
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/TarGzExtractor.kt b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/TarGzExtractor.kt
index 93e75c233..b907f8e5d 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/TarGzExtractor.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/TarGzExtractor.kt
@@ -21,7 +21,7 @@
 package com.amaze.filemanager.filesystem.compressed.extractcontents.helpers
 
 import android.content.Context
-import com.amaze.filemanager.file_operations.utils.UpdatePosition
+import com.amaze.filemanager.fileoperations.utils.UpdatePosition
 import org.apache.commons.compress.compressors.CompressorInputStream
 import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream
 
@@ -32,7 +32,11 @@ class TarGzExtractor(
     listener: OnUpdate,
     updatePosition: UpdatePosition
 ) : AbstractCompressedTarArchiveExtractor(
-    context, filePath, outputPath, listener, updatePosition
+    context,
+    filePath,
+    outputPath,
+    listener,
+    updatePosition
 ) {
 
     override fun getCompressorInputStreamClass(): Class<out CompressorInputStream> =
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/TarLzmaExtractor.kt b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/TarLzmaExtractor.kt
index 8ad3b0581..636a309c2 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/TarLzmaExtractor.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/TarLzmaExtractor.kt
@@ -21,7 +21,7 @@
 package com.amaze.filemanager.filesystem.compressed.extractcontents.helpers
 
 import android.content.Context
-import com.amaze.filemanager.file_operations.utils.UpdatePosition
+import com.amaze.filemanager.fileoperations.utils.UpdatePosition
 import org.apache.commons.compress.compressors.CompressorInputStream
 import org.apache.commons.compress.compressors.lzma.LZMACompressorInputStream
 
@@ -32,7 +32,11 @@ class TarLzmaExtractor(
     listener: OnUpdate,
     updatePosition: UpdatePosition
 ) : AbstractCompressedTarArchiveExtractor(
-    context, filePath, outputPath, listener, updatePosition
+    context,
+    filePath,
+    outputPath,
+    listener,
+    updatePosition
 ) {
 
     override fun getCompressorInputStreamClass(): Class<out CompressorInputStream> =
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/TarXzExtractor.kt b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/TarXzExtractor.kt
index d11e0dad2..a0c75212c 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/TarXzExtractor.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/TarXzExtractor.kt
@@ -21,7 +21,7 @@
 package com.amaze.filemanager.filesystem.compressed.extractcontents.helpers
 
 import android.content.Context
-import com.amaze.filemanager.file_operations.utils.UpdatePosition
+import com.amaze.filemanager.fileoperations.utils.UpdatePosition
 import org.apache.commons.compress.compressors.CompressorInputStream
 import org.apache.commons.compress.compressors.xz.XZCompressorInputStream
 
@@ -32,7 +32,11 @@ class TarXzExtractor(
     listener: OnUpdate,
     updatePosition: UpdatePosition
 ) : AbstractCompressedTarArchiveExtractor(
-    context, filePath, outputPath, listener, updatePosition
+    context,
+    filePath,
+    outputPath,
+    listener,
+    updatePosition
 ) {
 
     override fun getCompressorInputStreamClass(): Class<out CompressorInputStream> =
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/XzExtractor.kt b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/XzExtractor.kt
index 5696a9329..62a8a82f7 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/XzExtractor.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/XzExtractor.kt
@@ -21,7 +21,7 @@
 package com.amaze.filemanager.filesystem.compressed.extractcontents.helpers
 
 import android.content.Context
-import com.amaze.filemanager.file_operations.utils.UpdatePosition
+import com.amaze.filemanager.fileoperations.utils.UpdatePosition
 import org.apache.commons.compress.compressors.CompressorInputStream
 import org.apache.commons.compress.compressors.xz.XZCompressorInputStream
 
@@ -33,7 +33,10 @@ class XzExtractor(
     updatePosition: UpdatePosition
 ) : AbstractCommonsCompressedFileExtractor(
     context,
-    filePath, outputPath, listener, updatePosition
+    filePath,
+    outputPath,
+    listener,
+    updatePosition
 ) {
     override fun getCompressorInputStreamClass(): Class<out CompressorInputStream> {
         return XZCompressorInputStream::class.java
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/ZipExtractor.kt b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/ZipExtractor.kt
index bfeede6a7..124bf6e9c 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/ZipExtractor.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/ZipExtractor.kt
@@ -23,8 +23,8 @@ package com.amaze.filemanager.filesystem.compressed.extractcontents.helpers
 import android.content.Context
 import com.amaze.filemanager.R
 import com.amaze.filemanager.application.AppConfig
-import com.amaze.filemanager.file_operations.filesystem.compressed.ArchivePasswordCache
-import com.amaze.filemanager.file_operations.utils.UpdatePosition
+import com.amaze.filemanager.fileoperations.filesystem.compressed.ArchivePasswordCache
+import com.amaze.filemanager.fileoperations.utils.UpdatePosition
 import com.amaze.filemanager.filesystem.FileUtil
 import com.amaze.filemanager.filesystem.MakeDirectoryOperation
 import com.amaze.filemanager.filesystem.compressed.CompressedHelper
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/showcontents/helpers/RarDecompressor.kt b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/showcontents/helpers/RarDecompressor.kt
index 1d520f2da..7c0e5abc1 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/showcontents/helpers/RarDecompressor.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/showcontents/helpers/RarDecompressor.kt
@@ -31,7 +31,7 @@ class RarDecompressor(context: Context) : Decompressor(context) {
         path: String,
         addGoBackItem: Boolean
     ) =
-    RarHelperCallable(filePath, path, addGoBackItem)
+        RarHelperCallable(filePath, path, addGoBackItem)
 
     override fun realRelativeDirectory(dir: String): String {
         var dir = dir
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/showcontents/helpers/SevenZipDecompressor.kt b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/showcontents/helpers/SevenZipDecompressor.kt
index b6309eae5..0da0d7dd1 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/showcontents/helpers/SevenZipDecompressor.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/showcontents/helpers/SevenZipDecompressor.kt
@@ -29,5 +29,5 @@ class SevenZipDecompressor(context: Context) : Decompressor(context) {
         path: String,
         addGoBackItem: Boolean
     ) =
-    SevenZipHelperCallable(filePath, path, addGoBackItem)
+        SevenZipHelperCallable(filePath, path, addGoBackItem)
 }
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/showcontents/helpers/UnknownCompressedFileDecompressor.kt b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/showcontents/helpers/UnknownCompressedFileDecompressor.kt
index 4088b5bc9..9f7120335 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/showcontents/helpers/UnknownCompressedFileDecompressor.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/showcontents/helpers/UnknownCompressedFileDecompressor.kt
@@ -21,12 +21,8 @@
 package com.amaze.filemanager.filesystem.compressed.showcontents.helpers
 
 import android.content.Context
-import com.amaze.filemanager.adapters.data.CompressedObjectParcelable
-import com.amaze.filemanager.asynchronous.asynctasks.AsyncTaskResult
 import com.amaze.filemanager.asynchronous.asynctasks.compress.UnknownCompressedFileHelperCallable
 import com.amaze.filemanager.filesystem.compressed.showcontents.Decompressor
-import com.amaze.filemanager.utils.OnAsyncTaskFinished
-import java.util.ArrayList
 
 /**
  * Used by files compressed with gzip, bz2, lzma and xz.
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/files/CryptUtil.java b/app/src/main/java/com/amaze/filemanager/filesystem/files/CryptUtil.java
index 0f7e7dc9a..0bc0c55ae 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/files/CryptUtil.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/files/CryptUtil.java
@@ -24,37 +24,37 @@ import static android.os.Build.VERSION.SDK_INT;
 import static android.os.Build.VERSION_CODES.JELLY_BEAN_MR2;
 import static android.os.Build.VERSION_CODES.KITKAT;
 
-import android.content.Context;
-import android.util.Log;
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.IOException;
+import java.security.GeneralSecurityException;
+import java.security.Key;
+import java.security.spec.AlgorithmParameterSpec;
+import java.util.ArrayList;
 
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
+import javax.crypto.Cipher;
+import javax.crypto.CipherOutputStream;
+import javax.crypto.spec.GCMParameterSpec;
+import javax.crypto.spec.IvParameterSpec;
 
 import com.amaze.filemanager.BuildConfig;
 import com.amaze.filemanager.TagsHelper;
 import com.amaze.filemanager.application.AppConfig;
 import com.amaze.filemanager.asynchronous.management.ServiceWatcherUtil;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.MakeDirectoryOperation;
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants;
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants;
 import com.amaze.filemanager.utils.AESCrypt;
 import com.amaze.filemanager.utils.ProgressHandler;
 import com.amaze.filemanager.utils.security.SecretKeygen;
 
-import java.io.BufferedInputStream;
-import java.io.BufferedOutputStream;
-import java.io.IOException;
-import java.security.GeneralSecurityException;
-import java.security.Key;
-import java.security.spec.AlgorithmParameterSpec;
-import java.util.ArrayList;
+import android.content.Context;
+import android.util.Log;
 
-import javax.crypto.Cipher;
-import javax.crypto.CipherOutputStream;
-import javax.crypto.spec.GCMParameterSpec;
-import javax.crypto.spec.IvParameterSpec;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 
 import kotlin.io.ByteStreamsKt;
 import kotlin.io.ConstantsKt;
@@ -200,12 +200,7 @@ public class CryptUtil {
           sourceFile.isRoot(),
           file -> {
             try {
-              decrypt(
-                context,
-                file,
-                hFile,
-                useAescrypt,
-                password);
+              decrypt(context, file, hFile, useAescrypt, password);
             } catch (IOException | GeneralSecurityException e) {
               throw new IllegalStateException(e); // throw unchecked exception, no throws needed
             }
@@ -291,8 +286,8 @@ public class CryptUtil {
           });
     } else {
 
-      if (sourceFile.getName(context).endsWith(CRYPT_EXTENSION) ||
-        sourceFile.getName(context).endsWith(AESCRYPT_EXTENSION)) {
+      if (sourceFile.getName(context).endsWith(CRYPT_EXTENSION)
+          || sourceFile.getName(context).endsWith(AESCRYPT_EXTENSION)) {
         failedOps.add(sourceFile);
         return;
       }
@@ -333,14 +328,16 @@ public class CryptUtil {
    *
    * @param inputStream stream associated with the file to be encrypted
    * @param outputStream stream associated with new output encrypted file
-   * @param operationMode either <code>Cipher.ENCRYPT_MODE</code> or <code>Cipher.DECRYPT_MODE</code>
+   * @param operationMode either <code>Cipher.ENCRYPT_MODE</code> or <code>Cipher.DECRYPT_MODE
+   *     </code>
    */
-  private void doEncrypt(BufferedInputStream inputStream, BufferedOutputStream outputStream, int operationMode)
+  private void doEncrypt(
+      BufferedInputStream inputStream, BufferedOutputStream outputStream, int operationMode)
       throws GeneralSecurityException, IOException {
 
     Cipher cipher = Cipher.getInstance(ALGO_AES);
     AlgorithmParameterSpec parameterSpec;
-    if(SDK_INT >= KITKAT) {
+    if (SDK_INT >= KITKAT) {
       parameterSpec = new GCMParameterSpec(GCM_TAG_LENGTH, IV.getBytes());
     } else {
       parameterSpec = new IvParameterSpec(IV.getBytes());
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/files/EncryptDecryptUtils.java b/app/src/main/java/com/amaze/filemanager/filesystem/files/EncryptDecryptUtils.java
index f1eb67f93..46a61f182 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/files/EncryptDecryptUtils.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/files/EncryptDecryptUtils.java
@@ -23,15 +23,8 @@ package com.amaze.filemanager.filesystem.files;
 import static com.amaze.filemanager.asynchronous.services.EncryptService.TAG_AESCRYPT;
 import static com.amaze.filemanager.filesystem.files.CryptUtil.AESCRYPT_EXTENSION;
 
-import android.content.Context;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.os.Build;
-import android.widget.EditText;
-import android.widget.Toast;
-
-import androidx.annotation.NonNull;
-import androidx.preference.PreferenceManager;
+import java.io.IOException;
+import java.security.GeneralSecurityException;
 
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.asynchronous.management.ServiceWatcherUtil;
@@ -39,18 +32,25 @@ import com.amaze.filemanager.asynchronous.services.DecryptService;
 import com.amaze.filemanager.asynchronous.services.EncryptService;
 import com.amaze.filemanager.database.CryptHandler;
 import com.amaze.filemanager.database.models.explorer.EncryptedEntry;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.ui.activities.MainActivity;
 import com.amaze.filemanager.ui.dialogs.DecryptFingerprintDialog;
 import com.amaze.filemanager.ui.dialogs.GeneralDialogCreation;
 import com.amaze.filemanager.ui.fragments.MainFragment;
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants;
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants;
 import com.amaze.filemanager.ui.provider.UtilitiesProvider;
 import com.amaze.filemanager.utils.PasswordUtil;
 
-import java.io.IOException;
-import java.security.GeneralSecurityException;
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.os.Build;
+import android.widget.EditText;
+import android.widget.Toast;
+
+import androidx.annotation.NonNull;
+import androidx.preference.PreferenceManager;
 
 /**
  * Provides useful interfaces and methods for encryption/decryption
@@ -103,17 +103,18 @@ public class EncryptDecryptUtils {
 
     if (sourceFile.getPath().endsWith(AESCRYPT_EXTENSION)) {
       GeneralDialogCreation.showPasswordDialog(
-              c,
-              mainActivity,
-              utilsProvider.getAppTheme(),
-              R.string.crypt_decrypt,
-              R.string.authenticate_password,
-              (dialog, which) -> {
-                EditText editText = dialog.getView().findViewById(R.id.singleedittext_input);
-                decryptIntent.putExtra(EncryptService.TAG_PASSWORD, editText.getText().toString());
-                ServiceWatcherUtil.runService(main.getContext(), decryptIntent);
-                dialog.dismiss();
-              }, null);
+          c,
+          mainActivity,
+          utilsProvider.getAppTheme(),
+          R.string.crypt_decrypt,
+          R.string.authenticate_password,
+          (dialog, which) -> {
+            EditText editText = dialog.getView().findViewById(R.id.singleedittext_input);
+            decryptIntent.putExtra(EncryptService.TAG_PASSWORD, editText.getText().toString());
+            ServiceWatcherUtil.runService(main.getContext(), decryptIntent);
+            dialog.dismiss();
+          },
+          null);
     } else {
       EncryptedEntry encryptedEntry;
 
@@ -127,26 +128,26 @@ public class EncryptDecryptUtils {
                 main.getContext(),
                 main.getActivity().getString(R.string.crypt_decryption_fail),
                 Toast.LENGTH_LONG)
-                .show();
+            .show();
         return;
       }
 
       DecryptButtonCallbackInterface decryptButtonCallbackInterface =
-              new DecryptButtonCallbackInterface() {
-                @Override
-                public void confirm(Intent intent) {
-                  ServiceWatcherUtil.runService(main.getContext(), intent);
-                }
+          new DecryptButtonCallbackInterface() {
+            @Override
+            public void confirm(Intent intent) {
+              ServiceWatcherUtil.runService(main.getContext(), intent);
+            }
 
-                @Override
-                public void failed() {
-                  Toast.makeText(
-                          main.getContext(),
-                          main.getActivity().getString(R.string.crypt_decryption_fail_password),
-                          Toast.LENGTH_LONG)
-                          .show();
-                }
-              };
+            @Override
+            public void failed() {
+              Toast.makeText(
+                      main.getContext(),
+                      main.getActivity().getString(R.string.crypt_decryption_fail_password),
+                      Toast.LENGTH_LONG)
+                  .show();
+            }
+          };
 
       if (encryptedEntry == null && !sourceFile.getPath().endsWith(AESCRYPT_EXTENSION)) {
         // couldn't find the matching path in database, we lost the password
@@ -155,7 +156,7 @@ public class EncryptDecryptUtils {
                 main.getContext(),
                 main.getActivity().getString(R.string.crypt_decryption_fail),
                 Toast.LENGTH_LONG)
-                .show();
+            .show();
         return;
       }
 
@@ -164,11 +165,11 @@ public class EncryptDecryptUtils {
           try {
             if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
               DecryptFingerprintDialog.show(
-                c,
-                mainActivity,
-                decryptIntent,
-                utilsProvider.getAppTheme(),
-                decryptButtonCallbackInterface);
+                  c,
+                  mainActivity,
+                  decryptIntent,
+                  utilsProvider.getAppTheme(),
+                  decryptButtonCallbackInterface);
             } else throw new IllegalStateException("API < M!");
           } catch (GeneralSecurityException | IOException | IllegalStateException e) {
             e.printStackTrace();
@@ -176,39 +177,39 @@ public class EncryptDecryptUtils {
                     main.getContext(),
                     main.getString(R.string.crypt_decryption_fail),
                     Toast.LENGTH_LONG)
-                    .show();
+                .show();
           }
           break;
         case PreferencesConstants.ENCRYPT_PASSWORD_MASTER:
           try {
             GeneralDialogCreation.showDecryptDialog(
+                c,
+                mainActivity,
+                decryptIntent,
+                utilsProvider.getAppTheme(),
+                PasswordUtil.INSTANCE.decryptPassword(
                     c,
-                    mainActivity,
-                    decryptIntent,
-                    utilsProvider.getAppTheme(),
-                    PasswordUtil.INSTANCE.decryptPassword(
-                            c,
-                            preferences1.getString(
-                                    PreferencesConstants.PREFERENCE_CRYPT_MASTER_PASSWORD,
-                                    PreferencesConstants.PREFERENCE_CRYPT_MASTER_PASSWORD_DEFAULT)),
-                    decryptButtonCallbackInterface);
+                    preferences1.getString(
+                        PreferencesConstants.PREFERENCE_CRYPT_MASTER_PASSWORD,
+                        PreferencesConstants.PREFERENCE_CRYPT_MASTER_PASSWORD_DEFAULT)),
+                decryptButtonCallbackInterface);
           } catch (GeneralSecurityException | IOException e) {
             e.printStackTrace();
             Toast.makeText(
                     main.getContext(),
                     main.getString(R.string.crypt_decryption_fail),
                     Toast.LENGTH_LONG)
-                    .show();
+                .show();
           }
           break;
         default:
           GeneralDialogCreation.showDecryptDialog(
-                  c,
-                  mainActivity,
-                  decryptIntent,
-                  utilsProvider.getAppTheme(),
-                  encryptedEntry.getPassword().value,
-                  decryptButtonCallbackInterface);
+              c,
+              mainActivity,
+              decryptIntent,
+              utilsProvider.getAppTheme(),
+              encryptedEntry.getPassword().value,
+              decryptButtonCallbackInterface);
           break;
       }
     }
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/files/FileUtils.java b/app/src/main/java/com/amaze/filemanager/filesystem/files/FileUtils.java
index a41ab695e..1a3bf4876 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/files/FileUtils.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/files/FileUtils.java
@@ -22,35 +22,20 @@ package com.amaze.filemanager.filesystem.files;
 
 import static com.amaze.filemanager.filesystem.EditableFileAbstraction.Scheme.CONTENT;
 
-import android.Manifest;
-import android.animation.Animator;
-import android.animation.AnimatorListenerAdapter;
-import android.app.Activity;
-import android.content.ActivityNotFoundException;
-import android.content.Context;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.content.pm.PackageManager;
-import android.content.pm.ResolveInfo;
-import android.media.MediaScannerConnection;
-import android.net.Uri;
-import android.os.AsyncTask;
-import android.os.Build;
-import android.util.Log;
-import android.view.View;
-import android.widget.Toast;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.core.content.FileProvider;
-import androidx.core.util.Pair;
-import androidx.documentfile.provider.DocumentFile;
+import java.io.File;
+import java.text.ParsePosition;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Date;
+import java.util.LinkedList;
+import java.util.concurrent.atomic.AtomicLong;
 
 import com.afollestad.materialdialogs.MaterialDialog;
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.adapters.data.LayoutElementParcelable;
 import com.amaze.filemanager.application.AppConfig;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.ExternalSdCardOperation;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
@@ -65,7 +50,7 @@ import com.amaze.filemanager.ui.activities.superclasses.PreferenceActivity;
 import com.amaze.filemanager.ui.dialogs.GeneralDialogCreation;
 import com.amaze.filemanager.ui.dialogs.OpenFileDialogFragment;
 import com.amaze.filemanager.ui.dialogs.share.ShareTask;
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants;
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants;
 import com.amaze.filemanager.ui.icons.MimeTypes;
 import com.amaze.filemanager.ui.theme.AppTheme;
 import com.amaze.filemanager.utils.DataUtils;
@@ -76,21 +61,35 @@ import com.cloudrail.si.types.CloudMetaData;
 import com.googlecode.concurrenttrees.radix.ConcurrentRadixTree;
 import com.googlecode.concurrenttrees.radix.node.concrete.voidvalue.VoidValue;
 
-import net.schmizz.sshj.sftp.RemoteResourceInfo;
-import net.schmizz.sshj.sftp.SFTPClient;
-import net.schmizz.sshj.sftp.SFTPException;
+import android.Manifest;
+import android.animation.Animator;
+import android.animation.AnimatorListenerAdapter;
+import android.app.Activity;
+import android.content.ActivityNotFoundException;
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.media.MediaScannerConnection;
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.os.Build;
+import android.util.Log;
+import android.view.View;
+import android.widget.Toast;
 
-import java.io.File;
-import java.text.ParsePosition;
-import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Date;
-import java.util.LinkedList;
-import java.util.concurrent.atomic.AtomicLong;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.core.content.FileProvider;
+import androidx.core.util.Pair;
+import androidx.documentfile.provider.DocumentFile;
 
 import jcifs.smb.SmbFile;
 import kotlin.collections.ArraysKt;
+import net.schmizz.sshj.sftp.RemoteResourceInfo;
+import net.schmizz.sshj.sftp.SFTPClient;
+import net.schmizz.sshj.sftp.SFTPException;
 
 /** Functions that deal with files */
 public class FileUtils {
@@ -345,7 +344,8 @@ public class FileUtils {
     }.execute(path);
   }
 
-  public static void shareCloudFiles(ArrayList<LayoutElementParcelable> files, final OpenMode openMode, final Context context) {
+  public static void shareCloudFiles(
+      ArrayList<LayoutElementParcelable> files, final OpenMode openMode, final Context context) {
     String[] paths = new String[files.size()];
     for (int i = 0; i < files.size(); i++) {
       paths[i] = files.get(i).desc;
@@ -1005,9 +1005,7 @@ public class FileUtils {
     return true;
   }
 
-  /**
-   * Determines the specified path is beyond storage level, i.e should require root access.
-   */
+  /** Determines the specified path is beyond storage level, i.e should require root access. */
   @SuppressWarnings("PMD.DoNotHardCodeSDCard")
   public static boolean isRunningAboveStorage(@NonNull String path) {
     return !path.startsWith("/storage") && !path.startsWith("/sdcard");
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/files/GenericCopyUtil.java b/app/src/main/java/com/amaze/filemanager/filesystem/files/GenericCopyUtil.java
index a2e53f494..baf306b89 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/files/GenericCopyUtil.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/files/GenericCopyUtil.java
@@ -36,9 +36,9 @@ import java.nio.channels.ReadableByteChannel;
 import java.nio.channels.WritableByteChannel;
 import java.util.Objects;
 
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
-import com.amaze.filemanager.file_operations.utils.OnLowMemory;
-import com.amaze.filemanager.file_operations.utils.UpdatePosition;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.utils.OnLowMemory;
+import com.amaze.filemanager.fileoperations.utils.UpdatePosition;
 import com.amaze.filemanager.filesystem.ExternalSdCardOperation;
 import com.amaze.filemanager.filesystem.FileProperties;
 import com.amaze.filemanager.filesystem.HybridFile;
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/ftpserver/AndroidFtpFileSystemView.kt b/app/src/main/java/com/amaze/filemanager/filesystem/ftpserver/AndroidFtpFileSystemView.kt
index 39d0354dd..b602ebc06 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/ftpserver/AndroidFtpFileSystemView.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/ftpserver/AndroidFtpFileSystemView.kt
@@ -44,8 +44,10 @@ class AndroidFtpFileSystemView(private var context: Context, root: String) : Fil
 
     override fun getWorkingDirectory(): FtpFile {
         return AndroidFtpFile(
-            context, rootDocumentFile,
-            resolveDocumentFileFromRoot(currentPath!!), currentPath!!
+            context,
+            rootDocumentFile,
+            resolveDocumentFileFromRoot(currentPath!!),
+            currentPath!!
         )
     }
 
@@ -57,9 +59,9 @@ class AndroidFtpFileSystemView(private var context: Context, root: String) : Fil
                 true
             }
             dir.startsWith("..") -> {
-                if (currentPath.isNullOrEmpty() || currentPath == "/")
+                if (currentPath.isNullOrEmpty() || currentPath == "/") {
                     false
-                else {
+                } else {
                     currentPath = normalizePath("$currentPath/$dir")
                     resolveDocumentFileFromRoot(currentPath) != null
                 }
@@ -87,7 +89,8 @@ class AndroidFtpFileSystemView(private var context: Context, root: String) : Fil
             AndroidFtpFile(
                 context,
                 resolveDocumentFileFromRoot(getParentFrom(normalizedPath))!!, // rootDocumentFile,
-                resolveDocumentFileFromRoot(normalizedPath), normalizedPath
+                resolveDocumentFileFromRoot(normalizedPath),
+                normalizedPath
             )
         }
     }
@@ -133,17 +136,18 @@ class AndroidFtpFileSystemView(private var context: Context, root: String) : Fil
     }
 
     private fun resolveDocumentFileFromRoot(path: String?): DocumentFile? {
-        return if (path.isNullOrBlank() or ("/" == path) or ("./" == path))
+        return if (path.isNullOrBlank() or ("/" == path) or ("./" == path)) {
             rootDocumentFile
-        else {
+        } else {
             val pathElements = path!!.split('/')
             if (pathElements.isEmpty()) {
                 rootDocumentFile
             } else {
                 var retval: DocumentFile? = rootDocumentFile
                 pathElements.forEach { pathElement ->
-                    if (pathElement.isNotBlank())
+                    if (pathElement.isNotBlank()) {
                         retval = retval?.findFile(pathElement)
+                    }
                 }
                 retval
             }
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/ftpserver/RootFileSystemFactory.kt b/app/src/main/java/com/amaze/filemanager/filesystem/ftpserver/RootFileSystemFactory.kt
index 04a72cf73..980ac2b55 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/ftpserver/RootFileSystemFactory.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/ftpserver/RootFileSystemFactory.kt
@@ -1,3 +1,23 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.filesystem.ftpserver
 
 import org.apache.ftpserver.ftplet.FileSystemFactory
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/ftpserver/RootFileSystemView.kt b/app/src/main/java/com/amaze/filemanager/filesystem/ftpserver/RootFileSystemView.kt
index 2e5d15987..83f6589d4 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/ftpserver/RootFileSystemView.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/ftpserver/RootFileSystemView.kt
@@ -1,3 +1,23 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.filesystem.ftpserver
 
 import android.util.Log
@@ -52,7 +72,6 @@ class RootFileSystemView(
     }
 
     override fun changeWorkingDirectory(dirArg: String): Boolean {
-
         var dir = dirArg
 
         // not a directory - return false
@@ -105,7 +124,6 @@ class RootFileSystemView(
         currDir: String,
         fileName: String
     ): String {
-
         // normalize root dir
         var normalizedRootDir: String = normalizeSeparateChar(rootDir)
         normalizedRootDir = appendSlash(normalizedRootDir)
@@ -231,14 +249,17 @@ class RootFileSystemView(
          * Create SuFile.
          */
         fun create(pathname: String): SuFile = SuFile(pathname)
+
         /**
          * Create SuFile.
          */
         fun create(parent: String, child: String): SuFile = SuFile(parent, child)
+
         /**
          * Create SuFile.
          */
         fun create(parent: File, child: String): SuFile = SuFile(parent, child)
+
         /**
          * Create SuFile.
          */
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/ftpserver/RootFtpFile.kt b/app/src/main/java/com/amaze/filemanager/filesystem/ftpserver/RootFtpFile.kt
index de0d960bc..7a1b4994f 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/ftpserver/RootFtpFile.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/ftpserver/RootFtpFile.kt
@@ -1,3 +1,23 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.filesystem.ftpserver
 
 import com.topjohnwu.superuser.io.SuFile
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/root/ChangeFilePermissionsCommand.kt b/app/src/main/java/com/amaze/filemanager/filesystem/root/ChangeFilePermissionsCommand.kt
index a00092d53..490827774 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/root/ChangeFilePermissionsCommand.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/root/ChangeFilePermissionsCommand.kt
@@ -20,7 +20,7 @@
 
 package com.amaze.filemanager.filesystem.root
 
-import com.amaze.filemanager.file_operations.exceptions.ShellNotRunningException
+import com.amaze.filemanager.fileoperations.exceptions.ShellNotRunningException
 import com.amaze.filemanager.filesystem.RootHelper
 import com.amaze.filemanager.filesystem.root.base.IRootCommand
 import com.topjohnwu.superuser.Shell
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/root/ConcatenateFileCommand.kt b/app/src/main/java/com/amaze/filemanager/filesystem/root/ConcatenateFileCommand.kt
index 3be6493b4..9578ce446 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/root/ConcatenateFileCommand.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/root/ConcatenateFileCommand.kt
@@ -20,7 +20,7 @@
 
 package com.amaze.filemanager.filesystem.root
 
-import com.amaze.filemanager.file_operations.exceptions.ShellNotRunningException
+import com.amaze.filemanager.fileoperations.exceptions.ShellNotRunningException
 import com.amaze.filemanager.filesystem.RootHelper
 import com.amaze.filemanager.filesystem.root.base.IRootCommand
 
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/root/CopyFilesCommand.kt b/app/src/main/java/com/amaze/filemanager/filesystem/root/CopyFilesCommand.kt
index 03cc8831d..a8598038f 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/root/CopyFilesCommand.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/root/CopyFilesCommand.kt
@@ -20,7 +20,7 @@
 
 package com.amaze.filemanager.filesystem.root
 
-import com.amaze.filemanager.file_operations.exceptions.ShellNotRunningException
+import com.amaze.filemanager.fileoperations.exceptions.ShellNotRunningException
 import com.amaze.filemanager.filesystem.RootHelper
 import com.amaze.filemanager.filesystem.root.MountPathCommand.mountPath
 import com.amaze.filemanager.filesystem.root.base.IRootCommand
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/root/DeleteFileCommand.kt b/app/src/main/java/com/amaze/filemanager/filesystem/root/DeleteFileCommand.kt
index 482bfd7e7..72385c02b 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/root/DeleteFileCommand.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/root/DeleteFileCommand.kt
@@ -20,7 +20,7 @@
 
 package com.amaze.filemanager.filesystem.root
 
-import com.amaze.filemanager.file_operations.exceptions.ShellNotRunningException
+import com.amaze.filemanager.fileoperations.exceptions.ShellNotRunningException
 import com.amaze.filemanager.filesystem.RootHelper
 import com.amaze.filemanager.filesystem.root.base.IRootCommand
 
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/root/FindFileCommand.kt b/app/src/main/java/com/amaze/filemanager/filesystem/root/FindFileCommand.kt
index 71e39e99d..a9baef6a6 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/root/FindFileCommand.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/root/FindFileCommand.kt
@@ -20,7 +20,7 @@
 
 package com.amaze.filemanager.filesystem.root
 
-import com.amaze.filemanager.file_operations.exceptions.ShellNotRunningException
+import com.amaze.filemanager.fileoperations.exceptions.ShellNotRunningException
 import com.amaze.filemanager.filesystem.RootHelper
 import com.amaze.filemanager.filesystem.root.base.IRootCommand
 
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/root/ListFilesCommand.kt b/app/src/main/java/com/amaze/filemanager/filesystem/root/ListFilesCommand.kt
index 6c2f3ab7c..882729da4 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/root/ListFilesCommand.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/root/ListFilesCommand.kt
@@ -25,14 +25,14 @@ import androidx.preference.PreferenceManager
 import com.amaze.filemanager.R
 import com.amaze.filemanager.application.AppConfig
 import com.amaze.filemanager.exceptions.ShellCommandInvalidException
-import com.amaze.filemanager.file_operations.exceptions.ShellNotRunningException
-import com.amaze.filemanager.file_operations.filesystem.OpenMode
-import com.amaze.filemanager.file_operations.filesystem.root.NativeOperations
+import com.amaze.filemanager.fileoperations.exceptions.ShellNotRunningException
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode
+import com.amaze.filemanager.fileoperations.filesystem.root.NativeOperations
 import com.amaze.filemanager.filesystem.HybridFileParcelable
 import com.amaze.filemanager.filesystem.RootHelper
 import com.amaze.filemanager.filesystem.files.FileUtils
 import com.amaze.filemanager.filesystem.root.base.IRootCommand
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants
 import java.io.File
 
 object ListFilesCommand : IRootCommand() {
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/root/MakeDirectoryCommand.kt b/app/src/main/java/com/amaze/filemanager/filesystem/root/MakeDirectoryCommand.kt
index d0092d906..d159b0ebe 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/root/MakeDirectoryCommand.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/root/MakeDirectoryCommand.kt
@@ -20,7 +20,7 @@
 
 package com.amaze.filemanager.filesystem.root
 
-import com.amaze.filemanager.file_operations.exceptions.ShellNotRunningException
+import com.amaze.filemanager.fileoperations.exceptions.ShellNotRunningException
 import com.amaze.filemanager.filesystem.RootHelper
 import com.amaze.filemanager.filesystem.root.base.IRootCommand
 
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/root/MakeFileCommand.kt b/app/src/main/java/com/amaze/filemanager/filesystem/root/MakeFileCommand.kt
index 9b1fc855d..2a80ce33c 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/root/MakeFileCommand.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/root/MakeFileCommand.kt
@@ -20,7 +20,7 @@
 
 package com.amaze.filemanager.filesystem.root
 
-import com.amaze.filemanager.file_operations.exceptions.ShellNotRunningException
+import com.amaze.filemanager.fileoperations.exceptions.ShellNotRunningException
 import com.amaze.filemanager.filesystem.RootHelper
 import com.amaze.filemanager.filesystem.root.base.IRootCommand
 
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/root/MountPathCommand.kt b/app/src/main/java/com/amaze/filemanager/filesystem/root/MountPathCommand.kt
index 8afdd8472..6f7b44f60 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/root/MountPathCommand.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/root/MountPathCommand.kt
@@ -21,7 +21,7 @@
 package com.amaze.filemanager.filesystem.root
 
 import android.os.Build
-import com.amaze.filemanager.file_operations.exceptions.ShellNotRunningException
+import com.amaze.filemanager.fileoperations.exceptions.ShellNotRunningException
 import com.amaze.filemanager.filesystem.root.base.IRootCommand
 
 object MountPathCommand : IRootCommand() {
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/root/MoveFileCommand.kt b/app/src/main/java/com/amaze/filemanager/filesystem/root/MoveFileCommand.kt
index 333d16e5a..5942486ef 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/root/MoveFileCommand.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/root/MoveFileCommand.kt
@@ -20,7 +20,7 @@
 
 package com.amaze.filemanager.filesystem.root
 
-import com.amaze.filemanager.file_operations.exceptions.ShellNotRunningException
+import com.amaze.filemanager.fileoperations.exceptions.ShellNotRunningException
 import com.amaze.filemanager.filesystem.RootHelper
 import com.amaze.filemanager.filesystem.root.base.IRootCommand
 
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/root/RenameFileCommand.kt b/app/src/main/java/com/amaze/filemanager/filesystem/root/RenameFileCommand.kt
index f516c6fac..acd770c50 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/root/RenameFileCommand.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/root/RenameFileCommand.kt
@@ -21,7 +21,7 @@
 package com.amaze.filemanager.filesystem.root
 
 import com.amaze.filemanager.exceptions.ShellCommandInvalidException
-import com.amaze.filemanager.file_operations.exceptions.ShellNotRunningException
+import com.amaze.filemanager.fileoperations.exceptions.ShellNotRunningException
 import com.amaze.filemanager.filesystem.RootHelper
 import com.amaze.filemanager.filesystem.root.base.IRootCommand
 
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/root/base/IRootCommand.kt b/app/src/main/java/com/amaze/filemanager/filesystem/root/base/IRootCommand.kt
index 110520062..ef14cd94d 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/root/base/IRootCommand.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/root/base/IRootCommand.kt
@@ -21,7 +21,7 @@
 package com.amaze.filemanager.filesystem.root.base
 
 import com.amaze.filemanager.exceptions.ShellCommandInvalidException
-import com.amaze.filemanager.file_operations.exceptions.ShellNotRunningException
+import com.amaze.filemanager.fileoperations.exceptions.ShellNotRunningException
 import com.amaze.filemanager.ui.activities.MainActivity
 import com.topjohnwu.superuser.Shell
 
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/ssh/CustomSshJConfig.kt b/app/src/main/java/com/amaze/filemanager/filesystem/ssh/CustomSshJConfig.kt
index 74f80c1a9..87e384993 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/ssh/CustomSshJConfig.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/ssh/CustomSshJConfig.kt
@@ -38,11 +38,11 @@ import java.security.Security
 class CustomSshJConfig : DefaultConfig() {
 
     companion object {
-        @JvmStatic
         /**
          * This is where we different from the original AndroidConfig. Found it only work if we remove
          * BouncyCastle bundled with Android before registering our BouncyCastle provider
          */
+        @JvmStatic
         fun init() {
             Security.removeProvider("BC")
             Security.insertProviderAt(BouncyCastleProvider(), 0)
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SFtpClientTemplate.kt b/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SFtpClientTemplate.kt
index 17546023c..365f00ef3 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SFtpClientTemplate.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SFtpClientTemplate.kt
@@ -27,7 +27,7 @@ import java.io.IOException
  * Template class for executing actions with [SFTPClient] while leave the complexities of
  * handling connection and session setup/teardown to [SshClientUtils].
  */
-abstract class SFtpClientTemplate <T>
+abstract class SFtpClientTemplate<T>
 /**
  * If closeClientOnFinish is set to true, calling code needs to handle closing of [ ] session.
  *
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshClientSessionTemplate.kt b/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshClientSessionTemplate.kt
index a6fc7121e..87f78b070 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshClientSessionTemplate.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshClientSessionTemplate.kt
@@ -23,7 +23,7 @@ package com.amaze.filemanager.filesystem.ssh
 import net.schmizz.sshj.connection.channel.direct.Session
 import java.io.IOException
 
-abstract class SshClientSessionTemplate <T>
+abstract class SshClientSessionTemplate<T>
 /**
  * Constructor.
  *
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshClientTemplate.kt b/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshClientTemplate.kt
index e5bffee2e..96077f2af 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshClientTemplate.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshClientTemplate.kt
@@ -28,7 +28,7 @@ import java.io.IOException
  * Template class for executing actions with [SSHClient] while leave the complexities of
  * handling connection setup/teardown to [SshClientUtils].
  */
-abstract class SshClientTemplate <T>
+abstract class SshClientTemplate<T>
 /**
  * Constructor, with closeClientOnFinish set to true (that the connection must close after `
  * execute`.
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshClientUtils.java b/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshClientUtils.java
index e6098e9a3..1951c746e 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshClientUtils.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshClientUtils.java
@@ -20,8 +20,8 @@
 
 package com.amaze.filemanager.filesystem.ssh;
 
-import static com.amaze.filemanager.file_operations.filesystem.FolderStateKt.DOESNT_EXIST;
-import static com.amaze.filemanager.file_operations.filesystem.FolderStateKt.WRITABLE_ON_REMOTE;
+import static com.amaze.filemanager.fileoperations.filesystem.FolderStateKt.DOESNT_EXIST;
+import static com.amaze.filemanager.fileoperations.filesystem.FolderStateKt.WRITABLE_ON_REMOTE;
 import static com.amaze.filemanager.filesystem.ssh.SshConnectionPool.SSH_URI_PREFIX;
 
 import java.io.File;
@@ -32,8 +32,8 @@ import java.util.List;
 
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.application.AppConfig;
-import com.amaze.filemanager.file_operations.filesystem.FolderState;
-import com.amaze.filemanager.file_operations.filesystem.cloud.CloudStreamer;
+import com.amaze.filemanager.fileoperations.filesystem.FolderState;
+import com.amaze.filemanager.fileoperations.filesystem.cloud.CloudStreamer;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.ui.activities.MainActivity;
 import com.amaze.filemanager.ui.icons.MimeTypes;
diff --git a/app/src/main/java/com/amaze/filemanager/ui/Extensions.kt b/app/src/main/java/com/amaze/filemanager/ui/Extensions.kt
index 416a0165e..194fe3264 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/Extensions.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/Extensions.kt
@@ -62,13 +62,17 @@ fun Context.startActivityCatchingSecurityException(intent: Intent) {
 fun Context.updateAUAlias(shouldEnable: Boolean) {
     val component = ComponentName(this, "com.amaze.filemanager.amazeutilsalias")
     if (!shouldEnable) {
-        packageManager.setComponentEnabledSetting(component,
+        packageManager.setComponentEnabledSetting(
+            component,
             PackageManager.COMPONENT_ENABLED_STATE_DISABLED,
-            PackageManager.DONT_KILL_APP)
+            PackageManager.DONT_KILL_APP
+        )
     } else {
-        packageManager.setComponentEnabledSetting(component,
+        packageManager.setComponentEnabledSetting(
+            component,
             PackageManager.COMPONENT_ENABLED_STATE_ENABLED,
-            PackageManager.DONT_KILL_APP)
+            PackageManager.DONT_KILL_APP
+        )
     }
 }
 
diff --git a/app/src/main/java/com/amaze/filemanager/ui/ItemPopupMenu.java b/app/src/main/java/com/amaze/filemanager/ui/ItemPopupMenu.java
index 2423527ea..c3798955f 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/ItemPopupMenu.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/ItemPopupMenu.java
@@ -20,24 +20,15 @@
 
 package com.amaze.filemanager.ui;
 
-import android.content.Context;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.net.Uri;
-import android.view.MenuItem;
-import android.view.View;
-import android.widget.PopupMenu;
-import android.widget.Toast;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.documentfile.provider.DocumentFile;
-import androidx.preference.PreferenceManager;
+import java.io.File;
+import java.io.IOException;
+import java.security.GeneralSecurityException;
+import java.util.ArrayList;
 
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.adapters.data.LayoutElementParcelable;
 import com.amaze.filemanager.asynchronous.services.EncryptService;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.PasteHelper;
 import com.amaze.filemanager.filesystem.files.EncryptDecryptUtils;
@@ -47,14 +38,23 @@ import com.amaze.filemanager.ui.dialogs.EncryptAuthenticateDialog;
 import com.amaze.filemanager.ui.dialogs.EncryptWithPresetPasswordSaveAsDialog;
 import com.amaze.filemanager.ui.dialogs.GeneralDialogCreation;
 import com.amaze.filemanager.ui.fragments.MainFragment;
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants;
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants;
 import com.amaze.filemanager.ui.provider.UtilitiesProvider;
 import com.amaze.filemanager.utils.DataUtils;
 
-import java.io.File;
-import java.io.IOException;
-import java.security.GeneralSecurityException;
-import java.util.ArrayList;
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.net.Uri;
+import android.view.MenuItem;
+import android.view.View;
+import android.widget.PopupMenu;
+import android.widget.Toast;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.documentfile.provider.DocumentFile;
+import androidx.preference.PreferenceManager;
 
 /**
  * This class contains the functionality of the PopupMenu for each file in the MainFragment
@@ -181,46 +181,46 @@ public class ItemPopupMenu extends PopupMenu implements PopupMenu.OnMenuItemClic
         encryptIntent.putExtra(EncryptService.TAG_SOURCE, rowItem.generateBaseFile());
 
         final EncryptDecryptUtils.EncryptButtonCallbackInterface
-          encryptButtonCallbackInterfaceAuthenticate =
-            new EncryptDecryptUtils.EncryptButtonCallbackInterface() {
-              @Override
-              public void onButtonPressed(Intent intent, String password)
-                  throws GeneralSecurityException, IOException {
-                EncryptDecryptUtils.startEncryption(
-                    context, rowItem.generateBaseFile().getPath(), password, intent);
-              }
-            };
+            encryptButtonCallbackInterfaceAuthenticate =
+                new EncryptDecryptUtils.EncryptButtonCallbackInterface() {
+                  @Override
+                  public void onButtonPressed(Intent intent, String password)
+                      throws GeneralSecurityException, IOException {
+                    EncryptDecryptUtils.startEncryption(
+                        context, rowItem.generateBaseFile().getPath(), password, intent);
+                  }
+                };
 
         final SharedPreferences preferences =
-          PreferenceManager.getDefaultSharedPreferences(context);
+            PreferenceManager.getDefaultSharedPreferences(context);
 
-        if (!preferences.getString(
-              PreferencesConstants.PREFERENCE_CRYPT_MASTER_PASSWORD,
-              PreferencesConstants.PREFERENCE_CRYPT_MASTER_PASSWORD_DEFAULT)
-          .equals("")) {
+        if (!preferences
+            .getString(
+                PreferencesConstants.PREFERENCE_CRYPT_MASTER_PASSWORD,
+                PreferencesConstants.PREFERENCE_CRYPT_MASTER_PASSWORD_DEFAULT)
+            .equals("")) {
           EncryptWithPresetPasswordSaveAsDialog.show(
-                  context,
-                  encryptIntent,
-                  mainActivity,
-                  PreferencesConstants.ENCRYPT_PASSWORD_MASTER,
-                  encryptButtonCallbackInterfaceAuthenticate);
+              context,
+              encryptIntent,
+              mainActivity,
+              PreferencesConstants.ENCRYPT_PASSWORD_MASTER,
+              encryptButtonCallbackInterfaceAuthenticate);
         } else if (preferences.getBoolean(
-              PreferencesConstants.PREFERENCE_CRYPT_FINGERPRINT,
-              PreferencesConstants.PREFERENCE_CRYPT_FINGERPRINT_DEFAULT)) {
+            PreferencesConstants.PREFERENCE_CRYPT_FINGERPRINT,
+            PreferencesConstants.PREFERENCE_CRYPT_FINGERPRINT_DEFAULT)) {
           EncryptWithPresetPasswordSaveAsDialog.show(
-                  context,
-                  encryptIntent,
-                  mainActivity,
-                  PreferencesConstants.ENCRYPT_PASSWORD_FINGERPRINT,
-                  encryptButtonCallbackInterfaceAuthenticate);
+              context,
+              encryptIntent,
+              mainActivity,
+              PreferencesConstants.ENCRYPT_PASSWORD_FINGERPRINT,
+              encryptButtonCallbackInterfaceAuthenticate);
         } else {
           EncryptAuthenticateDialog.show(
-                  context,
-                  encryptIntent,
-                  mainActivity,
-                  utilitiesProvider.getAppTheme(),
-                  encryptButtonCallbackInterfaceAuthenticate
-          );
+              context,
+              encryptIntent,
+              mainActivity,
+              utilitiesProvider.getAppTheme(),
+              encryptButtonCallbackInterfaceAuthenticate);
         }
         return true;
       case R.id.decrypt:
diff --git a/app/src/main/java/com/amaze/filemanager/ui/activities/AboutActivity.java b/app/src/main/java/com/amaze/filemanager/ui/activities/AboutActivity.java
index 707985ab8..e6a2f6b9a 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/activities/AboutActivity.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/activities/AboutActivity.java
@@ -20,7 +20,7 @@
 
 package com.amaze.filemanager.ui.activities;
 
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_COLORED_NAVIGATION;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_COLORED_NAVIGATION;
 import static com.amaze.filemanager.utils.Utils.openURL;
 
 import com.amaze.filemanager.LogHelper;
diff --git a/app/src/main/java/com/amaze/filemanager/ui/activities/DatabaseViewerActivity.java b/app/src/main/java/com/amaze/filemanager/ui/activities/DatabaseViewerActivity.java
index 9d50c2911..5762c392d 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/activities/DatabaseViewerActivity.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/activities/DatabaseViewerActivity.java
@@ -20,13 +20,13 @@
 
 package com.amaze.filemanager.ui.activities;
 
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_TEXTEDITOR_NEWSTACK;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_TEXTEDITOR_NEWSTACK;
 
 import java.io.File;
 import java.util.ArrayList;
 
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.file_operations.exceptions.ShellNotRunningException;
+import com.amaze.filemanager.fileoperations.exceptions.ShellNotRunningException;
 import com.amaze.filemanager.filesystem.root.CopyFilesCommand;
 import com.amaze.filemanager.ui.activities.superclasses.ThemedActivity;
 import com.amaze.filemanager.ui.fragments.DbViewerFragment;
@@ -70,10 +70,10 @@ public class DatabaseViewerActivity extends ThemedActivity {
 
     path = getIntent().getStringExtra("path");
 
-    if(path == null) {
-        Toast.makeText(this, R.string.operation_not_supported, Toast.LENGTH_SHORT).show();
-        finish();
-        return;
+    if (path == null) {
+      Toast.makeText(this, R.string.operation_not_supported, Toast.LENGTH_SHORT).show();
+      finish();
+      return;
     }
 
     pathFile = new File(path);
diff --git a/app/src/main/java/com/amaze/filemanager/ui/activities/MainActivity.java b/app/src/main/java/com/amaze/filemanager/ui/activities/MainActivity.java
index 0f3b686cf..1612e6568 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/activities/MainActivity.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/activities/MainActivity.java
@@ -27,17 +27,17 @@ import static android.os.Build.VERSION_CODES.KITKAT_WATCH;
 import static android.os.Build.VERSION_CODES.LOLLIPOP;
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.N;
-import static com.amaze.filemanager.file_operations.filesystem.FolderStateKt.WRITABLE_OR_ON_SDCARD;
-import static com.amaze.filemanager.file_operations.filesystem.OperationTypeKt.COMPRESS;
-import static com.amaze.filemanager.file_operations.filesystem.OperationTypeKt.COPY;
-import static com.amaze.filemanager.file_operations.filesystem.OperationTypeKt.DELETE;
-import static com.amaze.filemanager.file_operations.filesystem.OperationTypeKt.EXTRACT;
-import static com.amaze.filemanager.file_operations.filesystem.OperationTypeKt.MOVE;
-import static com.amaze.filemanager.file_operations.filesystem.OperationTypeKt.NEW_FILE;
-import static com.amaze.filemanager.file_operations.filesystem.OperationTypeKt.NEW_FOLDER;
-import static com.amaze.filemanager.file_operations.filesystem.OperationTypeKt.RENAME;
-import static com.amaze.filemanager.file_operations.filesystem.OperationTypeKt.SAVE_FILE;
-import static com.amaze.filemanager.file_operations.filesystem.OperationTypeKt.UNDEFINED;
+import static com.amaze.filemanager.fileoperations.filesystem.FolderStateKt.WRITABLE_OR_ON_SDCARD;
+import static com.amaze.filemanager.fileoperations.filesystem.OperationTypeKt.COMPRESS;
+import static com.amaze.filemanager.fileoperations.filesystem.OperationTypeKt.COPY;
+import static com.amaze.filemanager.fileoperations.filesystem.OperationTypeKt.DELETE;
+import static com.amaze.filemanager.fileoperations.filesystem.OperationTypeKt.EXTRACT;
+import static com.amaze.filemanager.fileoperations.filesystem.OperationTypeKt.MOVE;
+import static com.amaze.filemanager.fileoperations.filesystem.OperationTypeKt.NEW_FILE;
+import static com.amaze.filemanager.fileoperations.filesystem.OperationTypeKt.NEW_FOLDER;
+import static com.amaze.filemanager.fileoperations.filesystem.OperationTypeKt.RENAME;
+import static com.amaze.filemanager.fileoperations.filesystem.OperationTypeKt.SAVE_FILE;
+import static com.amaze.filemanager.fileoperations.filesystem.OperationTypeKt.UNDEFINED;
 import static com.amaze.filemanager.ui.dialogs.SftpConnectDialog.ARG_ADDRESS;
 import static com.amaze.filemanager.ui.dialogs.SftpConnectDialog.ARG_DEFAULT_PATH;
 import static com.amaze.filemanager.ui.dialogs.SftpConnectDialog.ARG_EDIT;
@@ -48,57 +48,18 @@ import static com.amaze.filemanager.ui.dialogs.SftpConnectDialog.ARG_PASSWORD;
 import static com.amaze.filemanager.ui.dialogs.SftpConnectDialog.ARG_PORT;
 import static com.amaze.filemanager.ui.dialogs.SftpConnectDialog.ARG_USERNAME;
 import static com.amaze.filemanager.ui.fragments.FtpServerFragment.REQUEST_CODE_SAF_FTP;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_BOOKMARKS_ADDED;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_COLORED_NAVIGATION;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_NEED_TO_SET_HOME;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_VIEW;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_BOOKMARKS_ADDED;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_COLORED_NAVIGATION;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_NEED_TO_SET_HOME;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_VIEW;
 
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.content.BroadcastReceiver;
-import android.content.ContentResolver;
-import android.content.ContentUris;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.res.Configuration;
-import android.database.Cursor;
-import android.graphics.Color;
-import android.graphics.drawable.ColorDrawable;
-import android.hardware.usb.UsbManager;
-import android.media.RingtoneManager;
-import android.net.Uri;
-import android.os.AsyncTask;
-import android.os.Build;
-import android.os.Bundle;
-import android.os.Environment;
-import android.os.Handler;
-import android.os.storage.StorageManager;
-import android.os.storage.StorageVolume;
-import android.service.quicksettings.TileService;
-import android.text.TextUtils;
-import android.util.Log;
-import android.view.KeyEvent;
-import android.view.Menu;
-import android.view.MenuInflater;
-import android.view.MenuItem;
-import android.view.View;
-import android.view.animation.DecelerateInterpolator;
-import android.widget.Toast;
-
-import androidx.annotation.DrawableRes;
-import androidx.annotation.IdRes;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.annotation.RequiresApi;
-import androidx.annotation.StringRes;
-import androidx.arch.core.util.Function;
-import androidx.coordinatorlayout.widget.CoordinatorLayout;
-import androidx.fragment.app.Fragment;
-import androidx.fragment.app.FragmentTransaction;
-import androidx.loader.app.LoaderManager;
-import androidx.loader.content.CursorLoader;
-import androidx.loader.content.Loader;
+import java.io.File;
+import java.io.IOException;
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.regex.Pattern;
 
 import com.afollestad.materialdialogs.DialogAction;
 import com.afollestad.materialdialogs.MaterialDialog;
@@ -122,11 +83,11 @@ import com.amaze.filemanager.database.TabHandler;
 import com.amaze.filemanager.database.UtilsHandler;
 import com.amaze.filemanager.database.models.OperationData;
 import com.amaze.filemanager.database.models.explorer.CloudEntry;
-import com.amaze.filemanager.file_operations.exceptions.CloudPluginException;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
-import com.amaze.filemanager.file_operations.filesystem.StorageNaming;
-import com.amaze.filemanager.file_operations.filesystem.usb.SingletonUsbOtg;
-import com.amaze.filemanager.file_operations.filesystem.usb.UsbOtgRepresentation;
+import com.amaze.filemanager.fileoperations.exceptions.CloudPluginException;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.StorageNaming;
+import com.amaze.filemanager.fileoperations.filesystem.usb.SingletonUsbOtg;
+import com.amaze.filemanager.fileoperations.filesystem.usb.UsbOtgRepresentation;
 import com.amaze.filemanager.filesystem.ExternalSdCardOperation;
 import com.amaze.filemanager.filesystem.FileUtil;
 import com.amaze.filemanager.filesystem.HybridFile;
@@ -157,7 +118,7 @@ import com.amaze.filemanager.ui.fragments.MainFragment;
 import com.amaze.filemanager.ui.fragments.ProcessViewerFragment;
 import com.amaze.filemanager.ui.fragments.SearchWorkerFragment;
 import com.amaze.filemanager.ui.fragments.TabFragment;
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants;
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants;
 import com.amaze.filemanager.ui.strings.StorageNamingHelper;
 import com.amaze.filemanager.ui.theme.AppTheme;
 import com.amaze.filemanager.ui.views.CustomZoomFocusChange;
@@ -184,13 +145,52 @@ import com.leinardi.android.speeddial.SpeedDialView;
 import com.readystatesoftware.systembartint.SystemBarTintManager;
 import com.topjohnwu.superuser.Shell;
 
-import java.io.File;
-import java.io.IOException;
-import java.lang.ref.WeakReference;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.regex.Pattern;
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.content.BroadcastReceiver;
+import android.content.ContentResolver;
+import android.content.ContentUris;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.res.Configuration;
+import android.database.Cursor;
+import android.graphics.Color;
+import android.graphics.drawable.ColorDrawable;
+import android.hardware.usb.UsbManager;
+import android.media.RingtoneManager;
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.Environment;
+import android.os.Handler;
+import android.os.storage.StorageManager;
+import android.os.storage.StorageVolume;
+import android.service.quicksettings.TileService;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.KeyEvent;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+import android.view.View;
+import android.view.animation.DecelerateInterpolator;
+import android.widget.Toast;
+
+import androidx.annotation.DrawableRes;
+import androidx.annotation.IdRes;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RequiresApi;
+import androidx.annotation.StringRes;
+import androidx.arch.core.util.Function;
+import androidx.coordinatorlayout.widget.CoordinatorLayout;
+import androidx.fragment.app.Fragment;
+import androidx.fragment.app.FragmentTransaction;
+import androidx.loader.app.LoaderManager;
+import androidx.loader.content.CursorLoader;
+import androidx.loader.content.Loader;
 
 import io.reactivex.Completable;
 import io.reactivex.CompletableObserver;
@@ -389,9 +389,10 @@ public class MainActivity extends PermissionsActivity
               servers.addAll(utilsHandler.getSftpList());
               dataUtils.setServers(servers);
 
-              ExtensionsKt.updateAUAlias(this,
-                      !PackageUtils.Companion.appInstalledOrNot(AboutActivity.PACKAGE_AMAZE_UTILS,
-                              mainActivity.getPackageManager()));
+              ExtensionsKt.updateAUAlias(
+                  this,
+                  !PackageUtils.Companion.appInstalledOrNot(
+                      AboutActivity.PACKAGE_AMAZE_UTILS, mainActivity.getPackageManager()));
             })
         .subscribeOn(Schedulers.io())
         .observeOn(AndroidSchedulers.mainThread())
@@ -564,13 +565,14 @@ public class MainActivity extends PermissionsActivity
           // no data field, open home for the tab in later processing
           path = null;
         }
-      } else if(FileUtils.isCompressedFile(Utils.sanitizeInput(uri.toString()))) {
+      } else if (FileUtils.isCompressedFile(Utils.sanitizeInput(uri.toString()))) {
         // we don't have folder resource mime type set, supposed to be zip/rar
         isCompressedOpen = true;
         pathInCompressedArchive = Utils.sanitizeInput(uri.toString());
         openCompressed(pathInCompressedArchive);
       } else {
-        Toast.makeText(this, getString(R.string.error_cannot_find_way_open), Toast.LENGTH_LONG).show();
+        Toast.makeText(this, getString(R.string.error_cannot_find_way_open), Toast.LENGTH_LONG)
+            .show();
       }
 
     } else if (actionIntent.equals(Intent.ACTION_SEND)) {
@@ -672,9 +674,7 @@ public class MainActivity extends PermissionsActivity
     floatingActionButton.removeActionItemById(R.id.menu_new_cloud);
   }
 
-  /**
-   * Initializes an interactive shell, which will stay throughout the app lifecycle.
-   */
+  /** Initializes an interactive shell, which will stay throughout the app lifecycle. */
   private void initializeInteractiveShell() {
     if (isRootExplorer()) {
       // Enable mount-master flag when invoking su command, to force su run in the global mount
@@ -684,7 +684,9 @@ public class MainActivity extends PermissionsActivity
     }
   }
 
-  /** @return paths to all available volumes in the system (include emulated) */
+  /**
+   * @return paths to all available volumes in the system (include emulated)
+   */
   public synchronized ArrayList<StorageDirectoryParcelable> getStorageDirectories() {
     ArrayList<StorageDirectoryParcelable> volumes;
     if (SDK_INT >= N) {
@@ -1696,13 +1698,16 @@ public class MainActivity extends PermissionsActivity
       } else {
         if (getAppTheme().equals(AppTheme.LIGHT)) {
           mainActivity
-                  .getWindow().setNavigationBarColor(Utils.getColor(this, android.R.color.white));
+              .getWindow()
+              .setNavigationBarColor(Utils.getColor(this, android.R.color.white));
         } else if (getAppTheme().equals(AppTheme.BLACK)) {
           mainActivity
-                  .getWindow().setNavigationBarColor(Utils.getColor(this, android.R.color.black));
+              .getWindow()
+              .setNavigationBarColor(Utils.getColor(this, android.R.color.black));
         } else {
           mainActivity
-                  .getWindow().setNavigationBarColor(Utils.getColor(this, R.color.holo_dark_background));
+              .getWindow()
+              .setNavigationBarColor(Utils.getColor(this, R.color.holo_dark_background));
         }
       }
     } else if (SDK_INT == KITKAT_WATCH || SDK_INT == KITKAT) {
@@ -2328,15 +2333,33 @@ public class MainActivity extends PermissionsActivity
         if (folder.exists() && folder.isDirectory()) {
           if (FileUtils.isRunningAboveStorage(folder.getAbsolutePath())) {
             if (!isRootExplorer()) {
-              AlertDialog.show(this, R.string.ftp_server_root_unavailable, R.string.error, android.R.string.ok, null, false);
+              AlertDialog.show(
+                  this,
+                  R.string.ftp_server_root_unavailable,
+                  R.string.error,
+                  android.R.string.ok,
+                  null,
+                  false);
             } else {
-              MaterialDialog confirmDialog = GeneralDialogCreation.showBasicDialog(this, R.string.ftp_server_root_filesystem_warning,R.string.warning,  android.R.string.ok, android.R.string.cancel);
-              confirmDialog.getActionButton(DialogAction.POSITIVE).setOnClickListener(v -> {
-                ftpServerFragment.changeFTPServerPath(folder.getPath());
-                Toast.makeText(this, R.string.ftp_path_change_success, Toast.LENGTH_SHORT).show();
-                confirmDialog.dismiss();
-              });
-              confirmDialog.getActionButton(DialogAction.NEGATIVE).setOnClickListener(v -> confirmDialog.dismiss());
+              MaterialDialog confirmDialog =
+                  GeneralDialogCreation.showBasicDialog(
+                      this,
+                      R.string.ftp_server_root_filesystem_warning,
+                      R.string.warning,
+                      android.R.string.ok,
+                      android.R.string.cancel);
+              confirmDialog
+                  .getActionButton(DialogAction.POSITIVE)
+                  .setOnClickListener(
+                      v -> {
+                        ftpServerFragment.changeFTPServerPath(folder.getPath());
+                        Toast.makeText(this, R.string.ftp_path_change_success, Toast.LENGTH_SHORT)
+                            .show();
+                        confirmDialog.dismiss();
+                      });
+              confirmDialog
+                  .getActionButton(DialogAction.NEGATIVE)
+                  .setOnClickListener(v -> confirmDialog.dismiss());
               confirmDialog.show();
             }
           } else {
@@ -2347,8 +2370,8 @@ public class MainActivity extends PermissionsActivity
           // try to get parent
           String pathParentFilePath = folder.getParent();
           if (pathParentFilePath == null) {
-              dialog.dismiss();
-              return;
+            dialog.dismiss();
+            return;
           }
           File pathParentFile = new File(pathParentFilePath);
           if (pathParentFile.exists() && pathParentFile.isDirectory()) {
diff --git a/app/src/main/java/com/amaze/filemanager/ui/activities/PreferencesActivity.kt b/app/src/main/java/com/amaze/filemanager/ui/activities/PreferencesActivity.kt
index e4081ba09..f54dc9848 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/activities/PreferencesActivity.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/activities/PreferencesActivity.kt
@@ -36,9 +36,9 @@ import com.afollestad.materialdialogs.folderselector.FolderChooserDialog
 import com.amaze.filemanager.R
 import com.amaze.filemanager.ui.activities.superclasses.ThemedActivity
 import com.amaze.filemanager.ui.colors.ColorPreferenceHelper
-import com.amaze.filemanager.ui.fragments.preference_fragments.BasePrefsFragment
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants
-import com.amaze.filemanager.ui.fragments.preference_fragments.PrefsFragment
+import com.amaze.filemanager.ui.fragments.preferencefragments.BasePrefsFragment
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants
+import com.amaze.filemanager.ui.fragments.preferencefragments.PrefsFragment
 import com.amaze.filemanager.ui.theme.AppTheme
 import com.amaze.filemanager.utils.PreferenceUtils
 import com.amaze.filemanager.utils.Utils
@@ -146,16 +146,16 @@ class PreferencesActivity : ThemedActivity(), FolderChooserDialog.FolderCallback
             val tabStatusColor = PreferenceUtils.getStatusColor(primaryColor)
             window.statusBarColor = tabStatusColor
             when {
-                colouredNavigation         -> {
+                colouredNavigation -> {
                     window.navigationBarColor = tabStatusColor
                 }
                 appTheme == AppTheme.BLACK -> {
                     window.navigationBarColor = Color.BLACK
                 }
-                appTheme == AppTheme.DARK  -> {
+                appTheme == AppTheme.DARK -> {
                     window.navigationBarColor = Utils.getColor(this, R.color.holo_dark_background)
                 }
-                appTheme == AppTheme.LIGHT  -> {
+                appTheme == AppTheme.LIGHT -> {
                     window.navigationBarColor = Color.WHITE
                 }
             }
diff --git a/app/src/main/java/com/amaze/filemanager/ui/activities/UtilitiesAliasActivity.kt b/app/src/main/java/com/amaze/filemanager/ui/activities/UtilitiesAliasActivity.kt
index 5e7746c34..6416150fc 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/activities/UtilitiesAliasActivity.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/activities/UtilitiesAliasActivity.kt
@@ -1,3 +1,23 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.ui.activities
 
 import android.content.ActivityNotFoundException
@@ -11,7 +31,7 @@ import com.amaze.filemanager.ui.updateAUAlias
 import com.amaze.filemanager.utils.PackageUtils
 import com.amaze.filemanager.utils.Utils
 
-class UtilitiesAliasActivity: AppCompatActivity() {
+class UtilitiesAliasActivity : AppCompatActivity() {
 
     private val _binding by lazy(LazyThreadSafetyMode.NONE) {
         UtilitiesAliasLayoutBinding.inflate(layoutInflater)
@@ -31,7 +51,7 @@ class UtilitiesAliasActivity: AppCompatActivity() {
         }
         val isAUInstalled = PackageUtils.appInstalledOrNot(
             AboutActivity.PACKAGE_AMAZE_UTILS,
-           packageManager
+            packageManager
         )
         if (isAUInstalled) {
             AppConfig.toast(this, R.string.amaze_utils_installed_alias)
@@ -49,4 +69,4 @@ class UtilitiesAliasActivity: AppCompatActivity() {
             }
         }
     }
-}
\ No newline at end of file
+}
diff --git a/app/src/main/java/com/amaze/filemanager/ui/activities/superclasses/PreferenceActivity.java b/app/src/main/java/com/amaze/filemanager/ui/activities/superclasses/PreferenceActivity.java
index 6739f4011..7b1d6d5ff 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/activities/superclasses/PreferenceActivity.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/activities/superclasses/PreferenceActivity.java
@@ -20,29 +20,29 @@
 
 package com.amaze.filemanager.ui.activities.superclasses;
 
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_BOOKMARKS_ADDED;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_CHANGEPATHS;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_COLORED_NAVIGATION;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_COLORIZE_ICONS;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_ENABLE_MARQUEE_FILENAME;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_NEED_TO_SET_HOME;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_ROOTMODE;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_ROOT_LEGACY_LISTING;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_SHOW_DIVIDERS;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_SHOW_FILE_SIZE;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_SHOW_GOBACK_BUTTON;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_SHOW_HEADERS;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_SHOW_HIDDENFILES;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_SHOW_LAST_MODIFIED;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_SHOW_PERMISSIONS;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_SHOW_SIDEBAR_FOLDERS;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_SHOW_SIDEBAR_QUICKACCESSES;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_SHOW_THUMB;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_TEXTEDITOR_NEWSTACK;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_USE_CIRCULAR_IMAGES;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_VIEW;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_BOOKMARKS_ADDED;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_CHANGEPATHS;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_COLORED_NAVIGATION;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_COLORIZE_ICONS;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_ENABLE_MARQUEE_FILENAME;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_NEED_TO_SET_HOME;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_ROOTMODE;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_ROOT_LEGACY_LISTING;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SHOW_DIVIDERS;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SHOW_FILE_SIZE;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SHOW_GOBACK_BUTTON;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SHOW_HEADERS;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SHOW_HIDDENFILES;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SHOW_LAST_MODIFIED;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SHOW_PERMISSIONS;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SHOW_SIDEBAR_FOLDERS;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SHOW_SIDEBAR_QUICKACCESSES;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SHOW_THUMB;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_TEXTEDITOR_NEWSTACK;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_USE_CIRCULAR_IMAGES;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_VIEW;
 
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants;
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants;
 import com.amaze.filemanager.utils.PreferenceUtils;
 
 import android.content.SharedPreferences;
@@ -51,7 +51,9 @@ import android.os.Bundle;
 import androidx.annotation.NonNull;
 import androidx.preference.PreferenceManager;
 
-/** @author Emmanuel on 24/8/2017, at 23:13. */
+/**
+ * @author Emmanuel on 24/8/2017, at 23:13.
+ */
 public class PreferenceActivity extends BasicActivity {
 
   private SharedPreferences sharedPrefs;
diff --git a/app/src/main/java/com/amaze/filemanager/ui/activities/superclasses/ThemedActivity.java b/app/src/main/java/com/amaze/filemanager/ui/activities/superclasses/ThemedActivity.java
index 49bad9b06..e35172af3 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/activities/superclasses/ThemedActivity.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/activities/superclasses/ThemedActivity.java
@@ -21,13 +21,13 @@
 package com.amaze.filemanager.ui.activities.superclasses;
 
 import static android.os.Build.VERSION.SDK_INT;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_COLORED_NAVIGATION;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_COLORED_NAVIGATION;
 
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.ui.colors.ColorPreferenceHelper;
 import com.amaze.filemanager.ui.colors.UserColorPreferences;
 import com.amaze.filemanager.ui.dialogs.ColorPickerDialog;
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants;
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants;
 import com.amaze.filemanager.ui.theme.AppTheme;
 import com.amaze.filemanager.utils.PreferenceUtils;
 import com.amaze.filemanager.utils.Utils;
diff --git a/app/src/main/java/com/amaze/filemanager/ui/activities/texteditor/TextEditorActivity.java b/app/src/main/java/com/amaze/filemanager/ui/activities/texteditor/TextEditorActivity.java
index 12dee85cf..51f86a430 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/activities/texteditor/TextEditorActivity.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/activities/texteditor/TextEditorActivity.java
@@ -22,7 +22,7 @@ package com.amaze.filemanager.ui.activities.texteditor;
 
 import static com.amaze.filemanager.filesystem.EditableFileAbstraction.Scheme.CONTENT;
 import static com.amaze.filemanager.filesystem.EditableFileAbstraction.Scheme.FILE;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_TEXTEDITOR_NEWSTACK;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_TEXTEDITOR_NEWSTACK;
 
 import java.io.File;
 import java.lang.ref.WeakReference;
@@ -37,7 +37,7 @@ import com.amaze.filemanager.asynchronous.asynctasks.SearchTextTask;
 import com.amaze.filemanager.asynchronous.asynctasks.TaskKt;
 import com.amaze.filemanager.asynchronous.asynctasks.texteditor.read.ReadTextFileTask;
 import com.amaze.filemanager.asynchronous.asynctasks.texteditor.write.WriteTextFileTask;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.EditableFileAbstraction;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.files.FileUtils;
diff --git a/app/src/main/java/com/amaze/filemanager/ui/colors/ColorPreferenceHelper.java b/app/src/main/java/com/amaze/filemanager/ui/colors/ColorPreferenceHelper.java
index 3999dab31..b3d5c1aa1 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/colors/ColorPreferenceHelper.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/colors/ColorPreferenceHelper.java
@@ -25,7 +25,7 @@ import java.util.List;
 import java.util.Random;
 
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants;
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants;
 import com.amaze.filemanager.utils.Utils;
 
 import android.content.Context;
diff --git a/app/src/main/java/com/amaze/filemanager/ui/colors/ColorUtils.java b/app/src/main/java/com/amaze/filemanager/ui/colors/ColorUtils.java
index 2583c2d41..872e4aaa7 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/colors/ColorUtils.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/colors/ColorUtils.java
@@ -29,7 +29,9 @@ import android.graphics.drawable.GradientDrawable;
 
 import androidx.annotation.ColorInt;
 
-/** @author Emmanuel on 24/5/2017, at 18:56. */
+/**
+ * @author Emmanuel on 24/5/2017, at 18:56.
+ */
 public class ColorUtils {
 
   public static void colorizeIcons(
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/AlertDialog.kt b/app/src/main/java/com/amaze/filemanager/ui/dialogs/AlertDialog.kt
index 53f218ece..86bae17c2 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/dialogs/AlertDialog.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/AlertDialog.kt
@@ -1,3 +1,23 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.ui.dialogs
 
 import androidx.annotation.Nullable
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/ColorPickerDialog.java b/app/src/main/java/com/amaze/filemanager/ui/dialogs/ColorPickerDialog.java
index 73357a479..18aa5742b 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/dialogs/ColorPickerDialog.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/ColorPickerDialog.java
@@ -24,7 +24,7 @@ import com.afollestad.materialdialogs.Theme;
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.application.AppConfig;
 import com.amaze.filemanager.ui.colors.UserColorPreferences;
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants;
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants;
 import com.amaze.filemanager.ui.theme.AppTheme;
 import com.amaze.filemanager.ui.views.CircularColorsView;
 import com.amaze.filemanager.utils.Utils;
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/DecryptFingerprintDialog.kt b/app/src/main/java/com/amaze/filemanager/ui/dialogs/DecryptFingerprintDialog.kt
index 0ff868ec3..149a24a31 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/dialogs/DecryptFingerprintDialog.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/DecryptFingerprintDialog.kt
@@ -1,3 +1,23 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.ui.dialogs
 
 import android.content.Context
@@ -54,4 +74,4 @@ object DecryptFingerprintDialog {
         val `object` = FingerprintManager.CryptoObject(CryptUtil.initCipher())
         handler.authenticate(manager, `object`)
     }
-}
\ No newline at end of file
+}
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/DragAndDropDialog.kt b/app/src/main/java/com/amaze/filemanager/ui/dialogs/DragAndDropDialog.kt
index e51502beb..8231235cc 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/dialogs/DragAndDropDialog.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/DragAndDropDialog.kt
@@ -35,7 +35,7 @@ import com.amaze.filemanager.R
 import com.amaze.filemanager.asynchronous.asynctasks.movecopy.PrepareCopyTask
 import com.amaze.filemanager.filesystem.HybridFileParcelable
 import com.amaze.filemanager.ui.activities.MainActivity
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants
 import com.amaze.filemanager.utils.safeLet
 
 class DragAndDropDialog : DialogFragment() {
@@ -68,7 +68,8 @@ class DragAndDropDialog : DialogFragment() {
                     .getString(PreferencesConstants.PREFERENCE_DRAG_AND_DROP_REMEMBERED, "")
                 if (dragAndDropCopy != "") {
                     startCopyOrMoveTask(
-                        pasteLocation, files,
+                        pasteLocation,
+                        files,
                         PreferencesConstants.PREFERENCE_DRAG_REMEMBER_MOVE
                             .equals(dragAndDropCopy, ignoreCase = true),
                         activity
@@ -132,9 +133,10 @@ class DragAndDropDialog : DialogFragment() {
             context,
             mainActivity?.appTheme?.getMaterialDialogTheme(mainActivity?.applicationContext),
             mainActivity?.accent,
-            pasteLocation, operationFiles
+            pasteLocation,
+            operationFiles
         ) {
-            context, dialogTheme, accent, pasteLocation, operationFiles ->
+                context, dialogTheme, accent, pasteLocation, operationFiles ->
             val dialog: MaterialDialog = MaterialDialog.Builder(context)
                 .title(getString(R.string.choose_operation))
                 .customView(R.layout.dialog_drag_drop, true)
@@ -173,11 +175,15 @@ class DragAndDropDialog : DialogFragment() {
                 if (dialogTheme == Theme.LIGHT) {
                     moveButton.setCompoundDrawablesWithIntrinsicBounds(
                         R.drawable.ic_baseline_content_cut_24,
-                        0, 0, 0
+                        0,
+                        0,
+                        0
                     )
                     copyButton.setCompoundDrawablesWithIntrinsicBounds(
                         R.drawable.ic_baseline_content_copy_24,
-                        0, 0, 0
+                        0,
+                        0,
+                        0
                     )
                 }
             }
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/EncryptAuthenticateDialog.kt b/app/src/main/java/com/amaze/filemanager/ui/dialogs/EncryptAuthenticateDialog.kt
index 24ffd8ab9..d025b12b0 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/dialogs/EncryptAuthenticateDialog.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/EncryptAuthenticateDialog.kt
@@ -1,3 +1,23 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.ui.dialogs
 
 import android.annotation.SuppressLint
@@ -30,7 +50,7 @@ import com.amaze.filemanager.filesystem.files.CryptUtil.AESCRYPT_EXTENSION
 import com.amaze.filemanager.filesystem.files.CryptUtil.CRYPT_EXTENSION
 import com.amaze.filemanager.filesystem.files.EncryptDecryptUtils.EncryptButtonCallbackInterface
 import com.amaze.filemanager.ui.activities.MainActivity
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_CRYPT_WARNING_REMEMBER
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_CRYPT_WARNING_REMEMBER
 import com.amaze.filemanager.ui.openKeyboard
 import com.amaze.filemanager.ui.theme.AppTheme
 import com.amaze.filemanager.ui.views.WarnableTextInputLayout
@@ -66,12 +86,14 @@ object EncryptAuthenticateDialog {
                 DialogEncryptAuthenticateBinding.inflate(LayoutInflater.from(c))
             val rootView: View = vb.root
             val passwordEditText: TextInputEditText = vb.editTextDialogEncryptPassword
-            val passwordConfirmEditText: TextInputEditText = vb.editTextDialogEncryptPasswordConfirm
+            val passwordConfirmEditText: TextInputEditText = vb
+                .editTextDialogEncryptPasswordConfirm
             val encryptSaveAsEditText: TextInputEditText = vb.editTextEncryptSaveAs
             val useAzeEncrypt: AppCompatCheckBox = vb.checkboxUseAze
             val usageTextInfo: AppCompatTextView = vb.textViewCryptInfo.apply {
                 text = HtmlCompat.fromHtml(
-                    main.getString(R.string.encrypt_option_use_aescrypt_desc), FROM_HTML_MODE_COMPACT
+                    main.getString(R.string.encrypt_option_use_aescrypt_desc),
+                    FROM_HTML_MODE_COMPACT
                 )
             }
             useAzeEncrypt.setOnCheckedChangeListener(
@@ -85,7 +107,8 @@ object EncryptAuthenticateDialog {
                 )
             )
             val textInputLayoutPassword: WarnableTextInputLayout = vb.tilEncryptPassword
-            val textInputLayoutPasswordConfirm: WarnableTextInputLayout = vb.tilEncryptPasswordConfirm
+            val textInputLayoutPasswordConfirm: WarnableTextInputLayout = vb
+                .tilEncryptPasswordConfirm
             val textInputLayoutEncryptSaveAs: WarnableTextInputLayout = vb.tilEncryptSaveAs
             encryptSaveAsEditText.setText(this.getName(c) + AESCRYPT_EXTENSION)
             textInputLayoutEncryptSaveAs.hint =
@@ -109,7 +132,8 @@ object EncryptAuthenticateDialog {
                         .putExtra(TAG_PASSWORD, passwordEditText.text.toString())
                     runCatching {
                         encryptButtonCallbackInterface.onButtonPressed(
-                            intent, passwordEditText.text.toString()
+                            intent,
+                            passwordEditText.text.toString()
                         )
                     }.onFailure {
                         Log.e(EncryptService.TAG, "Failed to encrypt", it)
@@ -197,7 +221,11 @@ object EncryptAuthenticateDialog {
         encryptSaveAsEditText: TextInputEditText,
         usageTextInfo: AppCompatTextView
     ) = { _: CompoundButton?, isChecked: Boolean ->
-        if (isChecked && !preferences.getBoolean(PREFERENCE_CRYPT_WARNING_REMEMBER, false)) {
+        if (isChecked && !preferences.getBoolean(
+                PREFERENCE_CRYPT_WARNING_REMEMBER,
+                false
+            )
+        ) {
             EncryptWarningDialog.show(main, main.appTheme)
         }
         encryptSaveAsEditText.setText(
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/EncryptWarningDialog.kt b/app/src/main/java/com/amaze/filemanager/ui/dialogs/EncryptWarningDialog.kt
index c9232eac3..ec2d9b5b7 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/dialogs/EncryptWarningDialog.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/EncryptWarningDialog.kt
@@ -1,10 +1,30 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.ui.dialogs
 
 import androidx.preference.PreferenceManager
 import com.afollestad.materialdialogs.MaterialDialog
 import com.amaze.filemanager.R
 import com.amaze.filemanager.ui.activities.MainActivity
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants
 import com.amaze.filemanager.ui.theme.AppTheme
 
 /**
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/EncryptWithPresetPasswordSaveAsDialog.kt b/app/src/main/java/com/amaze/filemanager/ui/dialogs/EncryptWithPresetPasswordSaveAsDialog.kt
index 0a5e65362..b1cc92d9a 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/dialogs/EncryptWithPresetPasswordSaveAsDialog.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/EncryptWithPresetPasswordSaveAsDialog.kt
@@ -1,3 +1,23 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.ui.dialogs
 
 import android.annotation.SuppressLint
@@ -21,8 +41,8 @@ import com.amaze.filemanager.filesystem.files.EncryptDecryptUtils.EncryptButtonC
 import com.amaze.filemanager.ui.activities.MainActivity
 import com.amaze.filemanager.ui.dialogs.EncryptAuthenticateDialog.createFilenameValidator
 import com.amaze.filemanager.ui.dialogs.EncryptAuthenticateDialog.createUseAzeEncryptCheckboxOnCheckedChangeListener
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.ENCRYPT_PASSWORD_FINGERPRINT
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.ENCRYPT_PASSWORD_MASTER
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.ENCRYPT_PASSWORD_FINGERPRINT
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.ENCRYPT_PASSWORD_MASTER
 import com.amaze.filemanager.ui.views.WarnableTextInputValidator
 
 /**
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/GeneralDialogCreation.java b/app/src/main/java/com/amaze/filemanager/ui/dialogs/GeneralDialogCreation.java
index 9a1a0ed79..2d094e1a4 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/dialogs/GeneralDialogCreation.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/GeneralDialogCreation.java
@@ -21,35 +21,19 @@
 package com.amaze.filemanager.ui.dialogs;
 
 import static android.os.Build.VERSION.SDK_INT;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_SORTBY_ONLY_THIS;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SORTBY_ONLY_THIS;
 
-import android.content.Context;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.graphics.Color;
-import android.graphics.Typeface;
-import android.net.Uri;
-import android.os.AsyncTask;
-import android.os.Build;
-import android.text.InputType;
-import android.text.SpannableString;
-import android.text.TextUtils;
-import android.text.format.Formatter;
-import android.util.Log;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.widget.CheckBox;
-import android.widget.EditText;
-import android.widget.LinearLayout;
-import android.widget.TextView;
-import android.widget.Toast;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.annotation.StringRes;
-import androidx.appcompat.widget.AppCompatButton;
-import androidx.core.text.TextUtilsCompat;
-import androidx.core.view.ViewCompat;
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Locale;
+import java.util.Objects;
+import java.util.Set;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
 
 import com.afollestad.materialdialogs.DialogAction;
 import com.afollestad.materialdialogs.MaterialDialog;
@@ -64,8 +48,8 @@ import com.amaze.filemanager.asynchronous.asynctasks.hashcalculator.CalculateHas
 import com.amaze.filemanager.database.SortHandler;
 import com.amaze.filemanager.database.models.explorer.Sort;
 import com.amaze.filemanager.databinding.DialogSigninWithGoogleBinding;
-import com.amaze.filemanager.file_operations.exceptions.ShellNotRunningException;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.exceptions.ShellNotRunningException;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.FileProperties;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
@@ -91,17 +75,33 @@ import com.github.mikephil.charting.data.PieEntry;
 import com.github.mikephil.charting.formatter.IValueFormatter;
 import com.github.mikephil.charting.utils.ViewPortHandler;
 
-import java.io.File;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Locale;
-import java.util.Objects;
-import java.util.Set;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.graphics.Color;
+import android.graphics.Typeface;
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.os.Build;
+import android.text.InputType;
+import android.text.SpannableString;
+import android.text.TextUtils;
+import android.text.format.Formatter;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.widget.CheckBox;
+import android.widget.EditText;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.StringRes;
+import androidx.appcompat.widget.AppCompatButton;
+import androidx.core.text.TextUtilsCompat;
+import androidx.core.view.ViewCompat;
 
 /**
  * Here are a lot of function that create material dialogs
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/HiddenFilesDialog.kt b/app/src/main/java/com/amaze/filemanager/ui/dialogs/HiddenFilesDialog.kt
index 3712488b6..53c3fd8ba 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/dialogs/HiddenFilesDialog.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/HiddenFilesDialog.kt
@@ -1,10 +1,30 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.ui.dialogs
 
 import android.graphics.Color
 import com.afollestad.materialdialogs.MaterialDialog
 import com.amaze.filemanager.R
 import com.amaze.filemanager.adapters.HiddenAdapter
-import com.amaze.filemanager.file_operations.filesystem.OpenMode
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode
 import com.amaze.filemanager.filesystem.files.FileUtils
 import com.amaze.filemanager.ui.activities.MainActivity
 import com.amaze.filemanager.ui.fragments.MainFragment
@@ -20,12 +40,13 @@ object HiddenFilesDialog {
         val appTheme = mainActivity.appTheme
 
         val adapter = HiddenAdapter(
-                mainActivity,
-                mainFragment,
-                sharedPrefs,
-                FileUtils.toHybridFileConcurrentRadixTree(DataUtils.getInstance().hiddenFiles),
-                null,
-                false)
+            mainActivity,
+            mainFragment,
+            sharedPrefs,
+            FileUtils.toHybridFileConcurrentRadixTree(DataUtils.getInstance().hiddenFiles),
+            null,
+            false
+        )
 
         val materialDialog = MaterialDialog.Builder(mainActivity).also { builder ->
             builder.positiveText(R.string.close)
@@ -43,4 +64,4 @@ object HiddenFilesDialog {
         }
         materialDialog.show()
     }
-}
\ No newline at end of file
+}
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/HistoryDialog.kt b/app/src/main/java/com/amaze/filemanager/ui/dialogs/HistoryDialog.kt
index e96b7b3cc..8ea33ff1a 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/dialogs/HistoryDialog.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/HistoryDialog.kt
@@ -1,6 +1,25 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.ui.dialogs
 
-import android.content.SharedPreferences
 import com.afollestad.materialdialogs.DialogAction
 import com.afollestad.materialdialogs.MaterialDialog
 import com.amaze.filemanager.R
@@ -8,7 +27,6 @@ import com.amaze.filemanager.adapters.HiddenAdapter
 import com.amaze.filemanager.filesystem.files.FileUtils
 import com.amaze.filemanager.ui.activities.MainActivity
 import com.amaze.filemanager.ui.fragments.MainFragment
-import com.amaze.filemanager.ui.theme.AppTheme
 import com.amaze.filemanager.utils.DataUtils
 
 object HistoryDialog {
@@ -21,12 +39,13 @@ object HistoryDialog {
         val appTheme = mainActivity.appTheme
 
         val adapter = HiddenAdapter(
-                mainActivity,
-                mainFragment,
-                sharedPrefs,
-                FileUtils.toHybridFileArrayList(DataUtils.getInstance().history),
-                null,
-                true)
+            mainActivity,
+            mainFragment,
+            sharedPrefs,
+            FileUtils.toHybridFileArrayList(DataUtils.getInstance().history),
+            null,
+            true
+        )
 
         val materialDialog = MaterialDialog.Builder(mainActivity).also { builder ->
             builder.positiveText(R.string.cancel)
@@ -43,5 +62,4 @@ object HistoryDialog {
         adapter.materialDialog = materialDialog
         materialDialog.show()
     }
-
-}
\ No newline at end of file
+}
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/OpenFileDialogFragment.kt b/app/src/main/java/com/amaze/filemanager/ui/dialogs/OpenFileDialogFragment.kt
index 969aeefd3..e04f658b4 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/dialogs/OpenFileDialogFragment.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/OpenFileDialogFragment.kt
@@ -94,17 +94,22 @@ class OpenFileDialogFragment : BaseBottomSheetFragment(), AdjustListViewForTv<Ap
             if (mimeType == MimeTypes.ALL_MIME_TYPES ||
                 forceChooser ||
                 !getPreferenceAndStartActivity(
-                        uri, mimeType, useNewStack, activity
+                        uri,
+                        mimeType,
+                        useNewStack,
+                        activity
                     )
             ) {
                 if (forceChooser) {
                     clearMimeTypePreference(
-                        MimeTypes.getMimeType(uri.toString(), false), activity.prefs
+                        MimeTypes.getMimeType(uri.toString(), false),
+                        activity.prefs
                     )
                 }
                 val openFileDialogFragment = newInstance(uri, mimeType, useNewStack)
                 openFileDialogFragment.show(
-                    activity.supportFragmentManager, javaClass.simpleName
+                    activity.supportFragmentManager,
+                    javaClass.simpleName
                 )
             }
         }
@@ -191,7 +196,8 @@ class OpenFileDialogFragment : BaseBottomSheetFragment(), AdjustListViewForTv<Ap
                     result = true
                 } catch (e: ActivityNotFoundException) {
                     activity.prefs.edit().putString(
-                        mimeType.plus(KEY_PREFERENCES_DEFAULT), null
+                        mimeType.plus(KEY_PREFERENCES_DEFAULT),
+                        null
                     ).apply()
                 }
             }
@@ -290,25 +296,35 @@ class OpenFileDialogFragment : BaseBottomSheetFragment(), AdjustListViewForTv<Ap
         val modelProvider = AppsAdapterPreloadModel(this, true)
         val sizeProvider = ViewPreloadSizeProvider<String>()
         var preloader = RecyclerViewPreloader(
-            GlideApp.with(this), modelProvider, sizeProvider, GlideConstants.MAX_PRELOAD_FILES
+            GlideApp.with(this),
+            modelProvider,
+            sizeProvider,
+            GlideConstants.MAX_PRELOAD_FILES
         )
         sharedPreferences = PreferenceManager.getDefaultSharedPreferences(requireContext())
 
         val intent = buildIntent(
-            uri!!, mimeType!!, useNewStack!!, null, null
+            uri!!,
+            mimeType!!,
+            useNewStack!!,
+            null,
+            null
         )
         val appDataParcelableList = initAppDataParcelableList(intent)
         val lastClassAndPackageRaw = sharedPreferences
             .getString(mimeType.plus(KEY_PREFERENCES_LAST), null)
         val lastClassAndPackage = lastClassAndPackageRaw?.split(" ")
         val lastAppData: AppDataParcelable = initLastAppData(
-            lastClassAndPackage, appDataParcelableList
+            lastClassAndPackage,
+            appDataParcelableList
         ) ?: return
 
         adapter = AppsRecyclerAdapter(
             this,
             modelProvider,
-            true, this, appDataParcelableList
+            true,
+            this,
+            appDataParcelableList
         )
         loadViews(lastAppData)
 
@@ -362,7 +378,11 @@ class OpenFileDialogFragment : BaseBottomSheetFragment(), AdjustListViewForTv<Ap
         val appDataParcelableList: MutableList<AppDataParcelable> = ArrayList()
         packageManager.queryIntentActivities(intent, PackageManager.MATCH_ALL).forEach {
             val openFileParcelable = OpenFileParcelable(
-                uri, mimeType, useNewStack, it.activityInfo.name, it.activityInfo.packageName
+                uri,
+                mimeType,
+                useNewStack,
+                it.activityInfo.name,
+                it.activityInfo.packageName
             )
             val label = it.loadLabel(packageManager).toString()
             val appDataParcelable =
@@ -394,7 +414,6 @@ class OpenFileDialogFragment : BaseBottomSheetFragment(), AdjustListViewForTv<Ap
         }
 
         if (appDataParcelableList.size == 1) {
-
             requireContext().startActivityCatchingSecurityException(
                 buildIntent(
                     appDataParcelableList[0].openFileParcelable?.uri!!,
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/SftpConnectDialog.kt b/app/src/main/java/com/amaze/filemanager/ui/dialogs/SftpConnectDialog.kt
index f55d18b19..964f0d1dd 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/dialogs/SftpConnectDialog.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/SftpConnectDialog.kt
@@ -48,7 +48,7 @@ import com.amaze.filemanager.asynchronous.asynctasks.ssh.PemToKeyPairTask
 import com.amaze.filemanager.database.UtilsHandler
 import com.amaze.filemanager.database.models.OperationData
 import com.amaze.filemanager.databinding.SftpDialogBinding
-import com.amaze.filemanager.file_operations.filesystem.OpenMode
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode
 import com.amaze.filemanager.filesystem.ssh.SshClientUtils
 import com.amaze.filemanager.filesystem.ssh.SshConnectionPool
 import com.amaze.filemanager.ui.activities.MainActivity
@@ -93,6 +93,7 @@ class SftpConnectDialog : DialogFragment() {
     private var oldPath: String? = null
 
     private var _binding: SftpDialogBinding? = null
+
     // This property is only valid between onCreateView and
     // onDestroyView.
     private val binding get() = _binding!!
@@ -329,7 +330,7 @@ class SftpConnectDialog : DialogFragment() {
                         )
                     ).setCancelable(true)
                     .setPositiveButton(R.string.yes) {
-                        dialog1: DialogInterface, _: Int ->
+                            dialog1: DialogInterface, _: Int ->
                         // This closes the host fingerprint verification dialog
                         dialog1.dismiss()
                         if (authenticateAndSaveSetup(
@@ -343,7 +344,7 @@ class SftpConnectDialog : DialogFragment() {
                             dismiss()
                         }
                     }.setNegativeButton(R.string.no) {
-                        dialog1: DialogInterface, _: Int ->
+                            dialog1: DialogInterface, _: Int ->
                         dialog1.dismiss()
                     }.show()
             }
@@ -357,7 +358,7 @@ class SftpConnectDialog : DialogFragment() {
     ) {
         connectionSettings.run {
             GetSshHostFingerprintTask(hostname, port) {
-                taskResult: AsyncTaskResult<PublicKey> ->
+                    taskResult: AsyncTaskResult<PublicKey> ->
                 taskResult.result?.let { hostKey ->
                     val hostKeyFingerprint = SecurityUtils.getFingerprint(hostKey)
                     if (hostKeyFingerprint == sshHostKey) {
@@ -381,7 +382,7 @@ class SftpConnectDialog : DialogFragment() {
                                     edit
                                 )
                             }.setNegativeButton(R.string.cancel_recommended) {
-                                dialog1: DialogInterface, _: Int ->
+                                    dialog1: DialogInterface, _: Int ->
                                 dialog1.dismiss()
                             }.show()
                     }
@@ -399,7 +400,7 @@ class SftpConnectDialog : DialogFragment() {
                 selectedPem = this
                 runCatching {
                     requireContext().contentResolver.openInputStream(this)?.let {
-                        selectedKeyContent ->
+                            selectedKeyContent ->
                         PemToKeyPairTask(selectedKeyContent) { result: KeyPair? ->
                             selectedParsedKeyPair = result
                             selectedParsedKeyPairName = this
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/SmbConnectDialog.java b/app/src/main/java/com/amaze/filemanager/ui/dialogs/SmbConnectDialog.java
index ef192520e..67d23da06 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/dialogs/SmbConnectDialog.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/SmbConnectDialog.java
@@ -48,15 +48,11 @@ import android.app.Dialog;
 import android.app.DialogFragment;
 import android.content.Context;
 import android.content.SharedPreferences;
-import android.content.res.ColorStateList;
-import android.graphics.Color;
 import android.net.UrlQuerySanitizer;
-import android.os.Build;
 import android.os.Bundle;
 import android.text.Editable;
 import android.text.TextUtils;
 import android.view.View;
-import android.widget.EditText;
 import android.widget.TextView;
 import android.widget.Toast;
 
@@ -384,5 +380,4 @@ public class SmbConnectDialog extends DialogFragment {
     }
     return null;
   }
-
 }
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/share/ShareTask.java b/app/src/main/java/com/amaze/filemanager/ui/dialogs/share/ShareTask.java
index fd0cb2125..193097aed 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/dialogs/share/ShareTask.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/share/ShareTask.java
@@ -86,7 +86,8 @@ public class ShareTask extends AsyncTask<String, String, Void> {
           targetShareIntents.add(intent);
         }
       }
-      if (!bluetooth_present && PackageUtils.Companion.appInstalledOrNot("com.android.bluetooth", packageManager)) {
+      if (!bluetooth_present
+          && PackageUtils.Companion.appInstalledOrNot("com.android.bluetooth", packageManager)) {
         Intent intent = new Intent();
         intent.setComponent(
             new ComponentName(
diff --git a/app/src/main/java/com/amaze/filemanager/ui/drag/RecyclerAdapterDragListener.kt b/app/src/main/java/com/amaze/filemanager/ui/drag/RecyclerAdapterDragListener.kt
index 4cd8d27fb..87efcd277 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/drag/RecyclerAdapterDragListener.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/drag/RecyclerAdapterDragListener.kt
@@ -31,7 +31,7 @@ import com.amaze.filemanager.filesystem.HybridFile
 import com.amaze.filemanager.filesystem.HybridFileParcelable
 import com.amaze.filemanager.ui.dialogs.DragAndDropDialog
 import com.amaze.filemanager.ui.fragments.MainFragment
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants
 import com.amaze.filemanager.utils.DataUtils
 import com.amaze.filemanager.utils.safeLet
 import kotlin.collections.ArrayList
@@ -66,7 +66,7 @@ class RecyclerAdapterDragListener(
             }
             DragEvent.ACTION_DRAG_ENTERED -> {
                 safeLet(holder, adapter.itemsDigested) {
-                    holder, itemsDigested ->
+                        holder, itemsDigested ->
                     if (itemsDigested.size != 0 &&
                         holder.adapterPosition < itemsDigested.size
                     ) {
@@ -99,7 +99,7 @@ class RecyclerAdapterDragListener(
             }
             DragEvent.ACTION_DRAG_EXITED -> {
                 safeLet(holder, adapter.itemsDigested) {
-                    holder, itemsDigested ->
+                        holder, itemsDigested ->
                     if (itemsDigested.size != 0 &&
                         holder.adapterPosition < itemsDigested.size
                     ) {
@@ -154,7 +154,7 @@ class RecyclerAdapterDragListener(
                             mainFragment.currentPath
                         } else {
                             adapter.itemsDigested?.let {
-                                itemsDigested ->
+                                    itemsDigested ->
                                 if (itemsDigested[holder.adapterPosition].specialType
                                     == RecyclerAdapter.TYPE_BACK
                                 ) {
@@ -232,7 +232,8 @@ class RecyclerAdapterDragListener(
                     )
                     DragAndDropDialog.showDialogOrPerformOperation(
                         pasteLocation!!,
-                        arrayList, mainFragment.requireMainActivity()
+                        arrayList,
+                        mainFragment.requireMainActivity()
                     )
                     adapter.toggleChecked(false)
                     holder?.rl?.run {
diff --git a/app/src/main/java/com/amaze/filemanager/ui/fragments/AppsListFragment.java b/app/src/main/java/com/amaze/filemanager/ui/fragments/AppsListFragment.java
index 90e6428d4..0ccfd4d0c 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/fragments/AppsListFragment.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/fragments/AppsListFragment.java
@@ -20,8 +20,8 @@
 
 package com.amaze.filemanager.ui.fragments;
 
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_APPLIST_ISASCENDING;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_APPLIST_SORTBY;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_APPLIST_ISASCENDING;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_APPLIST_SORTBY;
 
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
diff --git a/app/src/main/java/com/amaze/filemanager/ui/fragments/CloudSheetFragment.java b/app/src/main/java/com/amaze/filemanager/ui/fragments/CloudSheetFragment.java
index da6f82594..626eb534b 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/fragments/CloudSheetFragment.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/fragments/CloudSheetFragment.java
@@ -23,7 +23,7 @@ package com.amaze.filemanager.ui.fragments;
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.database.CloudContract;
 import com.amaze.filemanager.databinding.FragmentSheetCloudBinding;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.ui.activities.MainActivity;
 import com.amaze.filemanager.ui.dialogs.GeneralDialogCreation;
 import com.amaze.filemanager.ui.dialogs.SftpConnectDialog;
diff --git a/app/src/main/java/com/amaze/filemanager/ui/fragments/CompressedExplorerFragment.kt b/app/src/main/java/com/amaze/filemanager/ui/fragments/CompressedExplorerFragment.kt
index 77500c773..19714dd9e 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/fragments/CompressedExplorerFragment.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/fragments/CompressedExplorerFragment.kt
@@ -57,8 +57,8 @@ import com.amaze.filemanager.asynchronous.asynctasks.DeleteTask
 import com.amaze.filemanager.asynchronous.services.ExtractService
 import com.amaze.filemanager.databinding.ActionmodeBinding
 import com.amaze.filemanager.databinding.MainFragBinding
-import com.amaze.filemanager.file_operations.filesystem.OpenMode
-import com.amaze.filemanager.file_operations.filesystem.compressed.ArchivePasswordCache
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode
+import com.amaze.filemanager.fileoperations.filesystem.compressed.ArchivePasswordCache
 import com.amaze.filemanager.filesystem.HybridFileParcelable
 import com.amaze.filemanager.filesystem.compressed.CompressedHelper
 import com.amaze.filemanager.filesystem.compressed.showcontents.Decompressor
@@ -67,7 +67,7 @@ import com.amaze.filemanager.ui.activities.MainActivity
 import com.amaze.filemanager.ui.colors.ColorPreferenceHelper
 import com.amaze.filemanager.ui.dialogs.GeneralDialogCreation
 import com.amaze.filemanager.ui.fragments.data.CompressedExplorerFragmentViewModel
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants
 import com.amaze.filemanager.ui.theme.AppTheme
 import com.amaze.filemanager.ui.views.DividerItemDecoration
 import com.amaze.filemanager.ui.views.FastScroller
@@ -91,12 +91,14 @@ class CompressedExplorerFragment : Fragment(), BottomBarButtonPath {
     lateinit var compressedFile: File
 
     private val viewModel: CompressedExplorerFragmentViewModel by viewModels()
+
     /**
      * files to be deleted from cache with a Map maintaining key - the root of directory created (for
      * deletion purposes after we exit out of here and value - the path of file to open
      */
     @JvmField
     var files: ArrayList<HybridFileParcelable>? = null
+
     @JvmField
     var selection = false
 
@@ -111,17 +113,22 @@ class CompressedExplorerFragment : Fragment(), BottomBarButtonPath {
     @ColorInt
     var iconskin = 0
     var compressedExplorerAdapter: CompressedExplorerAdapter? = null
+
     @JvmField
     var mActionMode: ActionMode? = null
+
     @JvmField
     var coloriseIcons = false
+
     @JvmField
     var showSize = false
+
     @JvmField
     var showLastModified = false
     var gobackitem = false
     var listView: RecyclerView? = null
     lateinit var swipeRefreshLayout: SwipeRefreshLayout
+
     /** flag states whether to open file after service extracts it */
     @JvmField
     var isOpen = false
@@ -214,7 +221,8 @@ class CompressedExplorerFragment : Fragment(), BottomBarButtonPath {
             else ->
                 listView?.setBackgroundColor(
                     Utils.getColor(
-                        context, android.R.color.background_light
+                        context,
+                        android.R.color.background_light
                     )
                 )
         }
@@ -240,9 +248,14 @@ class CompressedExplorerFragment : Fragment(), BottomBarButtonPath {
                     }
                 files?.add(HybridFileParcelable(path))
                 val decompressor = CompressedHelper.getCompressorInstance(requireContext(), this)
-                if(decompressor == null) {
-                    Toast.makeText(requireContext(), R.string.error_cant_decompress_that_file, Toast.LENGTH_LONG).show()
-                    parentFragmentManager.beginTransaction().remove(this@CompressedExplorerFragment).commit()
+                if (decompressor == null) {
+                    Toast.makeText(
+                        requireContext(),
+                        R.string.error_cant_decompress_that_file,
+                        Toast.LENGTH_LONG
+                    ).show()
+                    parentFragmentManager.beginTransaction()
+                        .remove(this@CompressedExplorerFragment).commit()
                     return
                 }
                 this@CompressedExplorerFragment.decompressor = decompressor
@@ -263,7 +276,9 @@ class CompressedExplorerFragment : Fragment(), BottomBarButtonPath {
                 .query(
                     pathUri,
                     arrayOf(MediaStore.MediaColumns.DISPLAY_NAME),
-                    null, null, null
+                    null,
+                    null,
+                    null
                 )?.run {
                     try {
                         if (moveToFirst()) {
@@ -273,7 +288,11 @@ class CompressedExplorerFragment : Fragment(), BottomBarButtonPath {
                             // At this point, we know nothing the file the URI represents, we are doing everything
                             // wild guess.
                             compressedFile =
-                                File.createTempFile("compressed", null, requireContext().cacheDir)
+                                File.createTempFile(
+                                    "compressed",
+                                    null,
+                                    requireContext().cacheDir
+                                )
                                     .also {
                                         fileName = it.name
                                     }
@@ -327,9 +346,14 @@ class CompressedExplorerFragment : Fragment(), BottomBarButtonPath {
             relativeDirectory = bundle.getString(KEY_PATH, "")
             compressedFile.let {
                 val decompressor = CompressedHelper.getCompressorInstance(requireContext(), it)
-                if(decompressor == null) {
-                    parentFragmentManager.beginTransaction().remove(this@CompressedExplorerFragment).commit()
-                    Toast.makeText(requireContext(), R.string.error_cant_decompress_that_file, Toast.LENGTH_LONG).show()
+                if (decompressor == null) {
+                    parentFragmentManager.beginTransaction()
+                        .remove(this@CompressedExplorerFragment).commit()
+                    Toast.makeText(
+                        requireContext(),
+                        R.string.error_cant_decompress_that_file,
+                        Toast.LENGTH_LONG
+                    ).show()
                     return
                 }
                 this@CompressedExplorerFragment.decompressor = decompressor
@@ -371,7 +395,8 @@ class CompressedExplorerFragment : Fragment(), BottomBarButtonPath {
             requireMainActivity().updateViews(
                 ColorDrawable(
                     Utils.getColor(
-                        context, R.color.holo_dark_action_mode
+                        context,
+                        R.color.holo_dark_action_mode
                     )
                 )
             )
@@ -459,7 +484,8 @@ class CompressedExplorerFragment : Fragment(), BottomBarButtonPath {
         override fun onDestroyActionMode(actionMode: ActionMode) {
             compressedExplorerAdapter?.toggleChecked(false)
             @ColorInt val primaryColor = ColorPreferenceHelper.getPrimary(
-                requireMainActivity().currentColorPreference, MainActivity.currentTab
+                requireMainActivity().currentColorPreference,
+                MainActivity.currentTab
             )
             selection = false
             requireMainActivity().updateViews(ColorDrawable(primaryColor))
@@ -519,7 +545,9 @@ class CompressedExplorerFragment : Fragment(), BottomBarButtonPath {
                     val cacheFile = File(cachedFiles[cachedFiles.size - 1].path)
                     if (cacheFile.exists()) {
                         FileUtils.openFile(
-                            cacheFile, requireMainActivity(), requireMainActivity().prefs
+                            cacheFile,
+                            requireMainActivity(),
+                            requireMainActivity().prefs
                         )
                     }
                     // reset the flag and cache file, as it's root is already in the list for deletion
@@ -579,10 +607,11 @@ class CompressedExplorerFragment : Fragment(), BottomBarButtonPath {
 
     private fun archiveCorruptOrUnsupportedToast(e: Throwable?) {
         @StringRes val msg: Int =
-            if (e?.cause?.javaClass is UnsupportedRarV5Exception)
+            if (e?.cause?.javaClass is UnsupportedRarV5Exception) {
                 R.string.error_unsupported_v5_rar
-            else
+            } else {
                 R.string.archive_unsupported_or_corrupt
+            }
         Toast.makeText(
             activity,
             requireContext().getString(msg, compressedFile.absolutePath),
@@ -648,7 +677,11 @@ class CompressedExplorerFragment : Fragment(), BottomBarButtonPath {
             // listView.removeItemDecoration(headersDecor);
             addheader = true
         } else {
-            dividerItemDecoration = DividerItemDecoration(activity, true, showDividers).also {
+            dividerItemDecoration = DividerItemDecoration(
+                activity,
+                true,
+                showDividers
+            ).also {
                 listView?.addItemDecoration(it)
             }
             // headersDecor = new StickyRecyclerHeadersDecoration(compressedExplorerAdapter);
diff --git a/app/src/main/java/com/amaze/filemanager/ui/fragments/FtpServerFragment.kt b/app/src/main/java/com/amaze/filemanager/ui/fragments/FtpServerFragment.kt
index 3c2db57b2..6dbdbe353 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/fragments/FtpServerFragment.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/fragments/FtpServerFragment.kt
@@ -119,14 +119,14 @@ class FtpServerFragment : Fragment(R.layout.fragment_ftp) {
     private val mainActivity: MainActivity get() = requireActivity() as MainActivity
 
     private val activityResultHandlerOnFtpServerPathUpdate = createOpenDocumentTreeIntentCallback {
-        directoryUri ->
+            directoryUri ->
         changeFTPServerPath(directoryUri.toString())
         updatePathText()
     }
 
     private val activityResultHandlerOnFtpServerPathGrantedSafAccess =
         createOpenDocumentTreeIntentCallback {
-            directoryUri ->
+                directoryUri ->
             changeFTPServerPath(directoryUri.toString())
             updatePathText()
             doStartServer()
@@ -204,7 +204,9 @@ class FtpServerFragment : Fragment(R.layout.fragment_ftp) {
                             } else {
                                 changeFTPServerPort(portNumber)
                                 Toast.makeText(
-                                    activity, R.string.ftp_port_change_success, Toast.LENGTH_SHORT
+                                    activity,
+                                    R.string.ftp_port_change_success,
+                                    Toast.LENGTH_SHORT
                                 )
                                     .show()
                             }
@@ -410,7 +412,8 @@ class FtpServerFragment : Fragment(R.layout.fragment_ftp) {
             if (it.resultCode == RESULT_OK && SDK_INT >= LOLLIPOP) {
                 val directoryUri = it.data?.data ?: return@registerForActivityResult
                 requireContext().contentResolver.takePersistableUriPermission(
-                    directoryUri, GRANT_URI_RW_PERMISSION
+                    directoryUri,
+                    GRANT_URI_RW_PERMISSION
                 )
                 callback.invoke(directoryUri)
             }
@@ -424,7 +427,9 @@ class FtpServerFragment : Fragment(R.layout.fragment_ftp) {
         if (shouldUseSafFileSystem()) {
             Uri.parse(directoryUri).run {
                 if (requireContext().checkUriPermission(
-                        this, Process.myPid(), Process.myUid(),
+                        this,
+                        Process.myPid(),
+                        Process.myUid(),
                         GRANT_URI_RW_PERMISSION
                     ) == PackageManager.PERMISSION_DENIED
                 ) {
@@ -730,7 +735,8 @@ class FtpServerFragment : Fragment(R.layout.fragment_ftp) {
     private val passwordFromPreferences: String?
         get() = runCatching {
             val encryptedPassword: String = mainActivity.prefs.getString(
-                FtpService.KEY_PREFERENCE_PASSWORD, ""
+                FtpService.KEY_PREFERENCE_PASSWORD,
+                ""
             )!!
             if (encryptedPassword == "") {
                 ""
diff --git a/app/src/main/java/com/amaze/filemanager/ui/fragments/MainFragment.java b/app/src/main/java/com/amaze/filemanager/ui/fragments/MainFragment.java
index 1473699b3..37342f1d4 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/fragments/MainFragment.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/fragments/MainFragment.java
@@ -25,15 +25,13 @@ import static android.os.Build.VERSION_CODES.JELLY_BEAN;
 import static android.os.Build.VERSION_CODES.JELLY_BEAN_MR2;
 import static android.os.Build.VERSION_CODES.Q;
 import static com.amaze.filemanager.filesystem.ssh.SshConnectionPool.SSH_URI_PREFIX;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_GRID_COLUMNS_DEFAULT;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_SHOW_DIVIDERS;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_SHOW_GOBACK_BUTTON;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_SHOW_HIDDENFILES;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_SHOW_THUMB;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SHOW_DIVIDERS;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SHOW_GOBACK_BUTTON;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SHOW_HIDDENFILES;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SHOW_THUMB;
 
 import java.io.File;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 
@@ -51,8 +49,8 @@ import com.amaze.filemanager.asynchronous.asynctasks.searchfilesystem.SortSearch
 import com.amaze.filemanager.asynchronous.handlers.FileHandler;
 import com.amaze.filemanager.database.SortHandler;
 import com.amaze.filemanager.database.models.explorer.Tab;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
-import com.amaze.filemanager.file_operations.filesystem.smbstreamer.Streamer;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.smbstreamer.Streamer;
 import com.amaze.filemanager.filesystem.CustomFileObserver;
 import com.amaze.filemanager.filesystem.FileProperties;
 import com.amaze.filemanager.filesystem.HybridFile;
@@ -773,7 +771,7 @@ public class MainFragment extends Fragment
           && (mainFragmentViewModel.getOpenMode() == OpenMode.FILE
               || mainFragmentViewModel.getOpenMode() == OpenMode.ROOT
               || (mainFragmentViewModel.getIsCloudOpenMode()
-                && !mainFragmentViewModel.getIsOnCloudRoot()))
+                  && !mainFragmentViewModel.getIsOnCloudRoot()))
           && !isOtg
           && (mainFragmentViewModel.getListElements().size() == 0
               || !mainFragmentViewModel
@@ -785,8 +783,7 @@ public class MainFragment extends Fragment
         mainFragmentViewModel.getListElements().add(0, getBackElement());
       }
 
-      if (mainFragmentViewModel.getListElements().size() == 0
-          && !results) {
+      if (mainFragmentViewModel.getListElements().size() == 0 && !results) {
         nofilesview.setVisibility(View.VISIBLE);
         listView.setVisibility(View.GONE);
         mSwipeRefreshLayout.setEnabled(false);
@@ -1639,7 +1636,7 @@ public class MainFragment extends Fragment
     if (mainFragmentViewModel.getColumns() == null) {
       int screenWidth = listView.getWidth();
       int dpToPx = Utils.dpToPx(requireContext(), 115);
-      if(dpToPx == 0) {
+      if (dpToPx == 0) {
         // HACK to fix a crash see #3249
         dpToPx = 1;
       }
diff --git a/app/src/main/java/com/amaze/filemanager/ui/fragments/ProcessViewerFragment.java b/app/src/main/java/com/amaze/filemanager/ui/fragments/ProcessViewerFragment.java
index aa147b2a7..fd0c30275 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/fragments/ProcessViewerFragment.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/fragments/ProcessViewerFragment.java
@@ -22,28 +22,7 @@ package com.amaze.filemanager.ui.fragments;
 
 import static androidx.core.text.HtmlCompat.FROM_HTML_MODE_COMPACT;
 
-import android.content.ComponentName;
-import android.content.Intent;
-import android.content.ServiceConnection;
-import android.graphics.Color;
-import android.graphics.Typeface;
-import android.graphics.drawable.ColorDrawable;
-import android.os.Bundle;
-import android.os.IBinder;
-import android.text.Spanned;
-import android.text.format.Formatter;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.ImageButton;
-import android.widget.ImageView;
-import android.widget.TextView;
-import android.widget.Toast;
-
-import androidx.annotation.Nullable;
-import androidx.cardview.widget.CardView;
-import androidx.core.text.HtmlCompat;
-import androidx.fragment.app.Fragment;
+import java.util.ArrayList;
 
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.asynchronous.services.AbstractProgressiveService;
@@ -66,7 +45,28 @@ import com.github.mikephil.charting.data.LineData;
 import com.github.mikephil.charting.data.LineDataSet;
 import com.github.mikephil.charting.interfaces.datasets.ILineDataSet;
 
-import java.util.ArrayList;
+import android.content.ComponentName;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.graphics.Color;
+import android.graphics.Typeface;
+import android.graphics.drawable.ColorDrawable;
+import android.os.Bundle;
+import android.os.IBinder;
+import android.text.Spanned;
+import android.text.format.Formatter;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageButton;
+import android.widget.ImageView;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import androidx.annotation.Nullable;
+import androidx.cardview.widget.CardView;
+import androidx.core.text.HtmlCompat;
+import androidx.fragment.app.Fragment;
 
 public class ProcessViewerFragment extends Fragment {
 
@@ -226,7 +226,8 @@ public class ProcessViewerFragment extends Fragment {
                   + getResources().getString(R.string.out_of)
                   + " <i>"
                   + Formatter.formatFileSize(getContext(), total)
-                  + "</i>", FROM_HTML_MODE_COMPACT);
+                  + "</i>",
+              FROM_HTML_MODE_COMPACT);
       mProgressBytesText.setText(bytesText);
 
       Spanned fileProcessedSpan =
@@ -240,7 +241,8 @@ public class ProcessViewerFragment extends Fragment {
                   + getResources().getString(R.string.of)
                   + " <i>"
                   + dataPackage.getAmountOfSourceFiles()
-                  + "</i>", FROM_HTML_MODE_COMPACT);
+                  + "</i>",
+              FROM_HTML_MODE_COMPACT);
       mProgressFileText.setText(fileProcessedSpan);
 
       Spanned speedSpan =
@@ -250,7 +252,8 @@ public class ProcessViewerFragment extends Fragment {
                   + accentColor
                   + "'><i>"
                   + Formatter.formatFileSize(getContext(), dataPackage.getSpeedRaw())
-                  + "/s</font></i>", FROM_HTML_MODE_COMPACT);
+                  + "/s</font></i>",
+              FROM_HTML_MODE_COMPACT);
       mProgressSpeedText.setText(speedSpan);
 
       Spanned timerSpan =
@@ -260,7 +263,8 @@ public class ProcessViewerFragment extends Fragment {
                   + accentColor
                   + "'><i>"
                   + Utils.formatTimer(++looseTimeInSeconds)
-                  + "</font></i>", FROM_HTML_MODE_COMPACT);
+                  + "</font></i>",
+              FROM_HTML_MODE_COMPACT);
 
       mProgressTimer.setText(timerSpan);
 
diff --git a/app/src/main/java/com/amaze/filemanager/ui/fragments/SearchWorkerFragment.java b/app/src/main/java/com/amaze/filemanager/ui/fragments/SearchWorkerFragment.java
index def309102..9d72f121d 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/fragments/SearchWorkerFragment.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/fragments/SearchWorkerFragment.java
@@ -21,7 +21,7 @@
 package com.amaze.filemanager.ui.fragments;
 
 import com.amaze.filemanager.asynchronous.asynctasks.searchfilesystem.SearchAsyncTask;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 
 import android.content.Context;
diff --git a/app/src/main/java/com/amaze/filemanager/ui/fragments/TabFragment.java b/app/src/main/java/com/amaze/filemanager/ui/fragments/TabFragment.java
index 9594f6d99..460d75782 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/fragments/TabFragment.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/fragments/TabFragment.java
@@ -20,8 +20,8 @@
 
 package com.amaze.filemanager.ui.fragments;
 
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_CURRENT_TAB;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_SAVED_PATHS;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_CURRENT_TAB;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SAVED_PATHS;
 import static com.amaze.filemanager.utils.PreferenceUtils.DEFAULT_CURRENT_TAB;
 import static com.amaze.filemanager.utils.PreferenceUtils.DEFAULT_SAVED_PATHS;
 
@@ -31,12 +31,12 @@ import java.util.List;
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.database.TabHandler;
 import com.amaze.filemanager.database.models.explorer.Tab;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.ui.ColorCircleDrawable;
 import com.amaze.filemanager.ui.activities.MainActivity;
 import com.amaze.filemanager.ui.colors.UserColorPreferences;
 import com.amaze.filemanager.ui.drag.TabFragmentSideDragListener;
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants;
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants;
 import com.amaze.filemanager.ui.views.DisablableViewPager;
 import com.amaze.filemanager.ui.views.Indicator;
 import com.amaze.filemanager.utils.DataUtils;
diff --git a/app/src/main/java/com/amaze/filemanager/ui/fragments/data/MainFragmentViewModel.kt b/app/src/main/java/com/amaze/filemanager/ui/fragments/data/MainFragmentViewModel.kt
index 51afe191e..bce9a4271 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/fragments/data/MainFragmentViewModel.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/fragments/data/MainFragmentViewModel.kt
@@ -29,11 +29,11 @@ import com.amaze.filemanager.adapters.RecyclerAdapter
 import com.amaze.filemanager.adapters.data.IconDataParcelable
 import com.amaze.filemanager.adapters.data.LayoutElementParcelable
 import com.amaze.filemanager.database.CloudHandler
-import com.amaze.filemanager.file_operations.filesystem.OpenMode
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode
 import com.amaze.filemanager.filesystem.HybridFileParcelable
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_GRID_COLUMNS
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_GRID_COLUMNS_DEFAULT
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_GRID_COLUMNS
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_GRID_COLUMNS_DEFAULT
 import com.amaze.filemanager.utils.DataUtils
 import kotlinx.coroutines.Dispatchers
 import kotlinx.coroutines.launch
@@ -147,7 +147,10 @@ class MainFragmentViewModel : ViewModel() {
      * Initialize column number from preference
      */
     fun initColumns(sharedPreferences: SharedPreferences) {
-        val columnPreference = sharedPreferences.getString(PREFERENCE_GRID_COLUMNS, PREFERENCE_GRID_COLUMNS_DEFAULT)
+        val columnPreference = sharedPreferences.getString(
+            PREFERENCE_GRID_COLUMNS,
+            PREFERENCE_GRID_COLUMNS_DEFAULT
+        )
         Objects.requireNonNull(columnPreference)
         columns = columnPreference?.toInt()
     }
diff --git a/app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/AppearancePrefsFragment.kt b/app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/AppearancePrefsFragment.kt
similarity index 78%
rename from app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/AppearancePrefsFragment.kt
rename to app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/AppearancePrefsFragment.kt
index f9332e773..a18b09389 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/AppearancePrefsFragment.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/AppearancePrefsFragment.kt
@@ -18,14 +18,14 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.ui.fragments.preference_fragments
+package com.amaze.filemanager.ui.fragments.preferencefragments
 
 import android.os.Bundle
 import androidx.preference.Preference
 import com.afollestad.materialdialogs.MaterialDialog
 import com.amaze.filemanager.R
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_GRID_COLUMNS
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_GRID_COLUMNS_DEFAULT
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_GRID_COLUMNS
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_GRID_COLUMNS_DEFAULT
 import com.amaze.filemanager.ui.theme.AppTheme
 import java.util.*
 
@@ -35,7 +35,14 @@ class AppearancePrefsFragment : BasePrefsFragment() {
     /**
      * The actual value saved for the preference, to see the localized strings see [R.array.columns]
      */
-    private val savedPreferenceValues = listOf(PREFERENCE_GRID_COLUMNS_DEFAULT, "2", "3", "4", "5", "6")
+    private val savedPreferenceValues = listOf(
+        PREFERENCE_GRID_COLUMNS_DEFAULT,
+        "2",
+        "3",
+        "4",
+        "5",
+        "6"
+    )
     private var currentTheme = 0
     private var gridColumnPref: Preference? = null
 
@@ -66,8 +73,8 @@ class AppearancePrefsFragment : BasePrefsFragment() {
             builder.theme(activity.utilsProvider.appTheme.getMaterialDialogTheme(activity))
             builder.title(R.string.gridcolumnno)
             val columnsPreference = activity
-                    .prefs
-                    .getString(PREFERENCE_GRID_COLUMNS, PREFERENCE_GRID_COLUMNS_DEFAULT)
+                .prefs
+                .getString(PREFERENCE_GRID_COLUMNS, PREFERENCE_GRID_COLUMNS_DEFAULT)
 
             Objects.requireNonNull(columnsPreference)
             val current = when (columnsPreference) {
@@ -80,18 +87,18 @@ class AppearancePrefsFragment : BasePrefsFragment() {
             }
 
             builder
-                    .items(R.array.columns)
-                    .itemsCallbackSingleChoice(current) { dialog, _, which, _ ->
-                        val editor = activity.prefs.edit()
-                        editor.putString(
-                                PREFERENCE_GRID_COLUMNS,
-                                savedPreferenceValues[which]
-                        )
-                        editor.apply()
-                        dialog.dismiss()
-                        updateGridColumnSummary()
-                        true
-                    }
+                .items(R.array.columns)
+                .itemsCallbackSingleChoice(current) { dialog, _, which, _ ->
+                    val editor = activity.prefs.edit()
+                    editor.putString(
+                        PREFERENCE_GRID_COLUMNS,
+                        savedPreferenceValues[which]
+                    )
+                    editor.apply()
+                    dialog.dismiss()
+                    updateGridColumnSummary()
+                    true
+                }
         }.build()
         dialog.show()
 
@@ -134,7 +141,10 @@ class AppearancePrefsFragment : BasePrefsFragment() {
     }
 
     private fun updateGridColumnSummary() {
-        val preferenceColumns = activity.prefs.getString(PREFERENCE_GRID_COLUMNS, PREFERENCE_GRID_COLUMNS_DEFAULT)
+        val preferenceColumns = activity.prefs.getString(
+            PREFERENCE_GRID_COLUMNS,
+            PREFERENCE_GRID_COLUMNS_DEFAULT
+        )
         gridColumnPref?.summary = preferenceColumns
     }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/BasePrefsFragment.kt b/app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/BasePrefsFragment.kt
similarity index 96%
rename from app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/BasePrefsFragment.kt
rename to app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/BasePrefsFragment.kt
index 6e91f1732..4d416055a 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/BasePrefsFragment.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/BasePrefsFragment.kt
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.ui.fragments.preference_fragments
+package com.amaze.filemanager.ui.fragments.preferencefragments
 
 import androidx.preference.PreferenceFragmentCompat
 import com.afollestad.materialdialogs.folderselector.FolderChooserDialog
diff --git a/app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/BehaviorPrefsFragment.kt b/app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/BehaviorPrefsFragment.kt
similarity index 97%
rename from app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/BehaviorPrefsFragment.kt
rename to app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/BehaviorPrefsFragment.kt
index 849b02d14..dcd9273c0 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/BehaviorPrefsFragment.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/BehaviorPrefsFragment.kt
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.ui.fragments.preference_fragments
+package com.amaze.filemanager.ui.fragments.preferencefragments
 
 import android.os.Bundle
 import android.os.Environment
diff --git a/app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/BookmarksPrefsFragment.kt b/app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/BookmarksPrefsFragment.kt
similarity index 98%
rename from app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/BookmarksPrefsFragment.kt
rename to app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/BookmarksPrefsFragment.kt
index 6d7b2bbbd..12fe469ed 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/BookmarksPrefsFragment.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/BookmarksPrefsFragment.kt
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.ui.fragments.preference_fragments
+package com.amaze.filemanager.ui.fragments.preferencefragments
 
 import android.os.Bundle
 import android.text.Editable
@@ -222,7 +222,8 @@ class BookmarksPrefsFragment : BasePrefsFragment() {
                     dialog.getActionButton(DialogAction.POSITIVE).isEnabled =
                         FileUtils.isPathAccessible(s.toString(), activity.prefs)
                 }
-            })
+            }
+        )
     }
 
     private fun disableButtonIfTitleEmpty(title: EditText, dialog: MaterialDialog) {
@@ -231,6 +232,7 @@ class BookmarksPrefsFragment : BasePrefsFragment() {
                 override fun afterTextChanged(s: Editable) {
                     dialog.getActionButton(DialogAction.POSITIVE).isEnabled = title.length() > 0
                 }
-            })
+            }
+        )
     }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/ColorPrefsFragment.kt b/app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/ColorPrefsFragment.kt
similarity index 99%
rename from app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/ColorPrefsFragment.kt
rename to app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/ColorPrefsFragment.kt
index 0d685ecb8..a16446718 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/ColorPrefsFragment.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/ColorPrefsFragment.kt
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.ui.fragments.preference_fragments
+package com.amaze.filemanager.ui.fragments.preferencefragments
 
 import android.os.Bundle
 import android.view.LayoutInflater
@@ -116,8 +116,11 @@ class ColorPrefsFragment : BasePrefsFragment() {
             currentColor
         ) { selectedColor: Int ->
             @ColorInt var primaryFirst = currentColorPreference.primaryFirstTab
+
             @ColorInt var primarySecond = currentColorPreference.primarySecondTab
+
             @ColorInt var accent = currentColorPreference.accent
+
             @ColorInt var iconSkin = currentColorPreference.iconSkin
             when (colorPrefKey) {
                 PreferencesConstants.PREFERENCE_SKIN -> primaryFirst = selectedColor
diff --git a/app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/PreferencesConstants.kt b/app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/PreferencesConstants.kt
similarity index 98%
rename from app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/PreferencesConstants.kt
rename to app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/PreferencesConstants.kt
index e76a74af1..c89789ef3 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/PreferencesConstants.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/PreferencesConstants.kt
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.ui.fragments.preference_fragments
+package com.amaze.filemanager.ui.fragments.preferencefragments
 
 object PreferencesConstants {
     // appearance_prefs.xml
diff --git a/app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/PrefsFragment.kt b/app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/PrefsFragment.kt
similarity index 93%
rename from app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/PrefsFragment.kt
rename to app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/PrefsFragment.kt
index d382ac71c..e42a2f1ed 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/PrefsFragment.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/PrefsFragment.kt
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.ui.fragments.preference_fragments
+package com.amaze.filemanager.ui.fragments.preferencefragments
 
 import android.content.Intent
 import android.content.pm.PackageManager
@@ -70,13 +70,15 @@ class PrefsFragment : BasePrefsFragment() {
             val emailIntent = Utils.buildEmailIntent(null, Utils.EMAIL_SUPPORT)
 
             val activities = activity.packageManager.queryIntentActivities(
-                emailIntent, PackageManager.MATCH_DEFAULT_ONLY
+                emailIntent,
+                PackageManager.MATCH_DEFAULT_ONLY
             )
 
             if (activities.isNotEmpty()) {
                 startActivity(
                     Intent.createChooser(
-                        emailIntent, resources.getString(R.string.feedback)
+                        emailIntent,
+                        resources.getString(R.string.feedback)
                     )
                 )
             } else {
diff --git a/app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/QuickAccessesPrefsFragment.kt b/app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/QuickAccessesPrefsFragment.kt
similarity index 90%
rename from app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/QuickAccessesPrefsFragment.kt
rename to app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/QuickAccessesPrefsFragment.kt
index 4fa145b31..ebcee4e92 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/QuickAccessesPrefsFragment.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/QuickAccessesPrefsFragment.kt
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.ui.fragments.preference_fragments
+package com.amaze.filemanager.ui.fragments.preferencefragments
 
 import android.os.Bundle
 import androidx.preference.Preference
@@ -32,7 +32,13 @@ class QuickAccessesPrefsFragment : BasePrefsFragment() {
     companion object {
         const val KEY = "quick access array"
         val KEYS = arrayOf(
-            "fastaccess", "recent", "image", "video", "audio", "documents", "apks"
+            "fastaccess",
+            "recent",
+            "image",
+            "video",
+            "audio",
+            "documents",
+            "apks"
         )
         val DEFAULT = arrayOf(true, true, true, true, true, true, true)
 
diff --git a/app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/SecurityPrefsFragment.kt b/app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/SecurityPrefsFragment.kt
similarity index 96%
rename from app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/SecurityPrefsFragment.kt
rename to app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/SecurityPrefsFragment.kt
index 9e02c5f82..11d5e6819 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/SecurityPrefsFragment.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/SecurityPrefsFragment.kt
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.ui.fragments.preference_fragments
+package com.amaze.filemanager.ui.fragments.preferencefragments
 
 import android.Manifest
 import android.app.KeyguardManager
@@ -45,7 +45,8 @@ class SecurityPrefsFragment : BasePrefsFragment() {
     private var fingerprintManager: FingerprintManager? = null
     private val onClickFingerprint = Preference.OnPreferenceChangeListener { _, _ ->
         if (ActivityCompat.checkSelfPermission(
-                activity, Manifest.permission.USE_FINGERPRINT
+                activity,
+                Manifest.permission.USE_FINGERPRINT
             )
             != PackageManager.PERMISSION_GRANTED
         ) {
@@ -133,7 +134,8 @@ class SecurityPrefsFragment : BasePrefsFragment() {
                     editor.putString(
                         PreferencesConstants.PREFERENCE_CRYPT_MASTER_PASSWORD,
                         PasswordUtil.encryptPassword(
-                            activity, dialog.inputEditText!!.text.toString()
+                            activity,
+                            dialog.inputEditText!!.text.toString()
                         )
                     )
                     editor.apply()
@@ -181,7 +183,7 @@ class SecurityPrefsFragment : BasePrefsFragment() {
         if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR2 ||
             activity.prefs.getBoolean(
                     PreferencesConstants.PREFERENCE_CRYPT_FINGERPRINT,
-                    false,
+                    false
                 )
         ) {
             // encryption feature not available
@@ -189,7 +191,6 @@ class SecurityPrefsFragment : BasePrefsFragment() {
         }
 
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-
             // finger print sensor
             keyguardManager = activity.getSystemService(Context.KEYGUARD_SERVICE)
                 as KeyguardManager?
@@ -203,7 +204,6 @@ class SecurityPrefsFragment : BasePrefsFragment() {
 
             checkBoxFingerprint?.onPreferenceChangeListener = onClickFingerprint
         } else {
-
             // fingerprint manager class not defined in the framework
             checkBoxFingerprint?.isEnabled = false
         }
diff --git a/app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/UiPrefsFragment.kt b/app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/UiPrefsFragment.kt
similarity index 95%
rename from app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/UiPrefsFragment.kt
rename to app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/UiPrefsFragment.kt
index 26c9b518a..6e9f144bb 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/UiPrefsFragment.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/fragments/preferencefragments/UiPrefsFragment.kt
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.ui.fragments.preference_fragments
+package com.amaze.filemanager.ui.fragments.preferencefragments
 
 import android.os.Bundle
 import androidx.preference.Preference
@@ -63,10 +63,12 @@ class UiPrefsFragment : BasePrefsFragment() {
                 .itemsCallbackSingleChoice(currentDragPreference) { dialog, _, which, _ ->
                     val editor = activity.prefs.edit()
                     editor.putInt(
-                        PreferencesConstants.PREFERENCE_DRAG_AND_DROP_PREFERENCE, which
+                        PreferencesConstants.PREFERENCE_DRAG_AND_DROP_PREFERENCE,
+                        which
                     )
                     editor.putString(
-                        PreferencesConstants.PREFERENCE_DRAG_AND_DROP_REMEMBERED, null
+                        PreferencesConstants.PREFERENCE_DRAG_AND_DROP_REMEMBERED,
+                        null
                     )
                     editor.apply()
                     dialog.dismiss()
diff --git a/app/src/main/java/com/amaze/filemanager/ui/notifications/NotificationConstants.java b/app/src/main/java/com/amaze/filemanager/ui/notifications/NotificationConstants.java
index 6a1581871..6f9e15127 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/notifications/NotificationConstants.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/notifications/NotificationConstants.java
@@ -31,7 +31,9 @@ import android.os.Build;
 import androidx.annotation.RequiresApi;
 import androidx.core.app.NotificationCompat;
 
-/** @author Emmanuel Messulam <emmanuelbendavid@gmail.com> on 17/9/2017, at 13:34. */
+/**
+ * @author Emmanuel Messulam <emmanuelbendavid@gmail.com> on 17/9/2017, at 13:34.
+ */
 public class NotificationConstants {
 
   public static final int COPY_ID = 0;
diff --git a/app/src/main/java/com/amaze/filemanager/ui/selection/SelectionPopupMenu.kt b/app/src/main/java/com/amaze/filemanager/ui/selection/SelectionPopupMenu.kt
index 8fc44d600..04e6bbef0 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/selection/SelectionPopupMenu.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/selection/SelectionPopupMenu.kt
@@ -60,12 +60,14 @@ class SelectionPopupMenu(
                     )
                 }
                 val popupMenu = SelectionPopupMenu(
-                    recyclerAdapter, actionModeView,
-                    currentPath, currentContext
+                    recyclerAdapter,
+                    actionModeView,
+                    currentPath,
+                    currentContext
                 )
                 popupMenu.inflate(R.menu.selection_criteria)
                 recyclerAdapter.itemsDigested?.let {
-                    itemsDigested ->
+                        itemsDigested ->
                     if (itemsDigested.size > SIMILARITY_THRESHOLD) {
                         popupMenu.menu.findItem(R.id.select_similar).isVisible = false
                     }
diff --git a/app/src/main/java/com/amaze/filemanager/ui/strings/StorageNamingHelper.java b/app/src/main/java/com/amaze/filemanager/ui/strings/StorageNamingHelper.java
index f1627267c..358d92dcf 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/strings/StorageNamingHelper.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/strings/StorageNamingHelper.java
@@ -23,7 +23,7 @@ package com.amaze.filemanager.ui.strings;
 import java.io.File;
 
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.file_operations.filesystem.StorageNaming;
+import com.amaze.filemanager.fileoperations.filesystem.StorageNaming;
 
 import android.content.Context;
 
diff --git a/app/src/main/java/com/amaze/filemanager/ui/theme/AppThemeManager.java b/app/src/main/java/com/amaze/filemanager/ui/theme/AppThemeManager.java
index 7db0b7b03..0135d2f02 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/theme/AppThemeManager.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/theme/AppThemeManager.java
@@ -20,7 +20,7 @@
 
 package com.amaze.filemanager.ui.theme;
 
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants;
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants;
 
 import android.content.SharedPreferences;
 
@@ -38,7 +38,9 @@ public class AppThemeManager {
         AppTheme.getTheme(isNightMode, Integer.parseInt(themeId)).getSimpleTheme(isNightMode);
   }
 
-  /** @return The current Application theme */
+  /**
+   * @return The current Application theme
+   */
   public AppTheme getAppTheme() {
     return appTheme.getSimpleTheme(isNightMode);
   }
diff --git a/app/src/main/java/com/amaze/filemanager/ui/views/CircularColorsView.java b/app/src/main/java/com/amaze/filemanager/ui/views/CircularColorsView.java
index e968507bd..d946db5d3 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/views/CircularColorsView.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/views/CircularColorsView.java
@@ -30,7 +30,9 @@ import android.view.View;
 
 import androidx.annotation.Nullable;
 
-/** @author Emmanuel on 6/10/2017, at 15:41. */
+/**
+ * @author Emmanuel on 6/10/2017, at 15:41.
+ */
 public class CircularColorsView extends View {
 
   private static final float DISTANCE_PERCENTUAL = 0.08f;
diff --git a/app/src/main/java/com/amaze/filemanager/ui/views/ThemedImageButton.java b/app/src/main/java/com/amaze/filemanager/ui/views/ThemedImageButton.java
index c4ba96481..9f462a47a 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/views/ThemedImageButton.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/views/ThemedImageButton.java
@@ -24,7 +24,9 @@ import android.content.Context;
 import android.util.AttributeSet;
 import android.widget.ImageButton;
 
-/** @author Emmanuel on 8/5/2017, at 13:39. */
+/**
+ * @author Emmanuel on 8/5/2017, at 13:39.
+ */
 public class ThemedImageButton extends ThemedImageView {
 
   public ThemedImageButton(Context context) {
diff --git a/app/src/main/java/com/amaze/filemanager/ui/views/WarnableTextInputLayout.java b/app/src/main/java/com/amaze/filemanager/ui/views/WarnableTextInputLayout.java
index f767b0eba..8ce05ca58 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/views/WarnableTextInputLayout.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/views/WarnableTextInputLayout.java
@@ -29,7 +29,9 @@ import android.util.AttributeSet;
 import androidx.annotation.Nullable;
 import androidx.annotation.StringRes;
 
-/** @author Emmanuel Messulam <emmanuelbendavid@gmail.com> on 31/1/2018, at 14:50. */
+/**
+ * @author Emmanuel Messulam <emmanuelbendavid@gmail.com> on 31/1/2018, at 14:50.
+ */
 public class WarnableTextInputLayout extends TextInputLayout {
 
   private boolean isStyleWarning = false;
diff --git a/app/src/main/java/com/amaze/filemanager/ui/views/WarnableTextInputValidator.java b/app/src/main/java/com/amaze/filemanager/ui/views/WarnableTextInputValidator.java
index 71125c98a..4e946b2bf 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/views/WarnableTextInputValidator.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/views/WarnableTextInputValidator.java
@@ -84,7 +84,9 @@ public final class WarnableTextInputValidator extends SimpleTextWatcher
     doValidate(false);
   }
 
-  /** @return ReturnState.state */
+  /**
+   * @return ReturnState.state
+   */
   private int doValidate(boolean onlySetWarning) {
     ReturnState state = validator.isTextValid(editText.getText().toString());
     switch (state.state) {
diff --git a/app/src/main/java/com/amaze/filemanager/ui/views/appbar/AppBar.java b/app/src/main/java/com/amaze/filemanager/ui/views/appbar/AppBar.java
index b39588f2d..b090d0df6 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/views/appbar/AppBar.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/views/appbar/AppBar.java
@@ -24,7 +24,7 @@ import static android.os.Build.VERSION.SDK_INT;
 
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.ui.activities.MainActivity;
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants;
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants;
 import com.google.android.material.appbar.AppBarLayout;
 
 import android.content.SharedPreferences;
diff --git a/app/src/main/java/com/amaze/filemanager/ui/views/appbar/BottomBar.java b/app/src/main/java/com/amaze/filemanager/ui/views/appbar/BottomBar.java
index 73e22635e..b113ff9b8 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/views/appbar/BottomBar.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/views/appbar/BottomBar.java
@@ -20,13 +20,13 @@
 
 package com.amaze.filemanager.ui.views.appbar;
 
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_CHANGEPATHS;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_CHANGEPATHS;
 
 import java.util.ArrayList;
 import java.util.Objects;
 
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.files.FileUtils;
 import com.amaze.filemanager.ui.activities.MainActivity;
diff --git a/app/src/main/java/com/amaze/filemanager/ui/views/drawer/Drawer.java b/app/src/main/java/com/amaze/filemanager/ui/views/drawer/Drawer.java
index 67e5a60b2..8ffeb24ef 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/views/drawer/Drawer.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/views/drawer/Drawer.java
@@ -21,8 +21,8 @@
 package com.amaze.filemanager.ui.views.drawer;
 
 import static android.os.Build.VERSION.SDK_INT;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_SHOW_SIDEBAR_FOLDERS;
-import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_SHOW_SIDEBAR_QUICKACCESSES;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SHOW_SIDEBAR_FOLDERS;
+import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SHOW_SIDEBAR_QUICKACCESSES;
 
 import java.io.File;
 import java.util.ArrayList;
@@ -35,8 +35,8 @@ import com.amaze.filemanager.R;
 import com.amaze.filemanager.adapters.data.StorageDirectoryParcelable;
 import com.amaze.filemanager.application.AppConfig;
 import com.amaze.filemanager.database.CloudHandler;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
-import com.amaze.filemanager.file_operations.filesystem.usb.SingletonUsbOtg;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.usb.SingletonUsbOtg;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.RootHelper;
 import com.amaze.filemanager.filesystem.cloud.CloudUtil;
@@ -50,8 +50,8 @@ import com.amaze.filemanager.ui.fragments.AppsListFragment;
 import com.amaze.filemanager.ui.fragments.CloudSheetFragment;
 import com.amaze.filemanager.ui.fragments.FtpServerFragment;
 import com.amaze.filemanager.ui.fragments.MainFragment;
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants;
-import com.amaze.filemanager.ui.fragments.preference_fragments.QuickAccessesPrefsFragment;
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants;
+import com.amaze.filemanager.ui.fragments.preferencefragments.QuickAccessesPrefsFragment;
 import com.amaze.filemanager.ui.theme.AppTheme;
 import com.amaze.filemanager.utils.Billing;
 import com.amaze.filemanager.utils.BookSorter;
@@ -526,52 +526,52 @@ public class Drawer implements NavigationView.OnNavigationItemSelectedListener {
         null);
 
     addNewItem(
-            menu,
-            LASTGROUP,
-            order++,
-            R.string.wifip2p,
-            new MenuMetadata(
-                    () -> {
-                      boolean isAUInstalled = PackageUtils.Companion.appInstalledOrNot(AboutActivity.PACKAGE_AMAZE_UTILS,
-                              mainActivity.getPackageManager());
-                      if (isAUInstalled) {
-                        try {
-                          Utils.openURL("amaze://teamamaze.xyz/transfer", mainActivity);
-                        } catch (ActivityNotFoundException e) {
-                          mainActivity.startActivity(new Intent(mainActivity,
-                                  UtilitiesAliasActivity.class));
-                        }
-                      } else {
-                        mainActivity.startActivity(new Intent(mainActivity,
-                                UtilitiesAliasActivity.class));
-                      }
-                    }),
-            R.drawable.ic_round_connect_without_contact_24,
-            null);
+        menu,
+        LASTGROUP,
+        order++,
+        R.string.wifip2p,
+        new MenuMetadata(
+            () -> {
+              boolean isAUInstalled =
+                  PackageUtils.Companion.appInstalledOrNot(
+                      AboutActivity.PACKAGE_AMAZE_UTILS, mainActivity.getPackageManager());
+              if (isAUInstalled) {
+                try {
+                  Utils.openURL("amaze://teamamaze.xyz/transfer", mainActivity);
+                } catch (ActivityNotFoundException e) {
+                  mainActivity.startActivity(
+                      new Intent(mainActivity, UtilitiesAliasActivity.class));
+                }
+              } else {
+                mainActivity.startActivity(new Intent(mainActivity, UtilitiesAliasActivity.class));
+              }
+            }),
+        R.drawable.ic_round_connect_without_contact_24,
+        null);
 
     addNewItem(
-            menu,
-            LASTGROUP,
-            order++,
-            R.string.analyse_storage,
-            new MenuMetadata(
-                    () -> {
-                      boolean isAUInstalled = PackageUtils.Companion.appInstalledOrNot(AboutActivity.PACKAGE_AMAZE_UTILS,
-                              mainActivity.getPackageManager());
-                      if (isAUInstalled) {
-                        try {
-                          Utils.openURL("amaze://teamamaze.xyz/analyse", mainActivity);
-                        } catch (ActivityNotFoundException e) {
-                          mainActivity.startActivity(new Intent(mainActivity,
-                                  UtilitiesAliasActivity.class));
-                        }
-                      } else {
-                        mainActivity.startActivity(new Intent(mainActivity,
-                                UtilitiesAliasActivity.class));
-                      }
-                    }),
-            R.drawable.ic_round_analytics_24,
-            null);
+        menu,
+        LASTGROUP,
+        order++,
+        R.string.analyse_storage,
+        new MenuMetadata(
+            () -> {
+              boolean isAUInstalled =
+                  PackageUtils.Companion.appInstalledOrNot(
+                      AboutActivity.PACKAGE_AMAZE_UTILS, mainActivity.getPackageManager());
+              if (isAUInstalled) {
+                try {
+                  Utils.openURL("amaze://teamamaze.xyz/analyse", mainActivity);
+                } catch (ActivityNotFoundException e) {
+                  mainActivity.startActivity(
+                      new Intent(mainActivity, UtilitiesAliasActivity.class));
+                }
+              } else {
+                mainActivity.startActivity(new Intent(mainActivity, UtilitiesAliasActivity.class));
+              }
+            }),
+        R.drawable.ic_round_analytics_24,
+        null);
 
     addNewItem(
         menu,
diff --git a/app/src/main/java/com/amaze/filemanager/ui/views/preference/SelectedColorsPreference.kt b/app/src/main/java/com/amaze/filemanager/ui/views/preference/SelectedColorsPreference.kt
index de848c21c..ee652725c 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/views/preference/SelectedColorsPreference.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/views/preference/SelectedColorsPreference.kt
@@ -30,7 +30,7 @@ import androidx.preference.DialogPreference
 import androidx.preference.PreferenceViewHolder
 import com.amaze.filemanager.R
 import com.amaze.filemanager.ui.dialogs.ColorPickerDialog
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants
 import com.amaze.filemanager.ui.views.CircularColorsView
 
 /**
@@ -41,7 +41,10 @@ import com.amaze.filemanager.ui.views.CircularColorsView
 class SelectedColorsPreference(context: Context?, attrs: AttributeSet?) :
     DialogPreference(context, attrs) {
     private var colors = intArrayOf(
-        Color.TRANSPARENT, Color.TRANSPARENT, Color.TRANSPARENT, Color.TRANSPARENT
+        Color.TRANSPARENT,
+        Color.TRANSPARENT,
+        Color.TRANSPARENT,
+        Color.TRANSPARENT
     )
     private var backgroundColor = 0
     private var visibility = View.VISIBLE
diff --git a/app/src/main/java/com/amaze/filemanager/utils/AESCrypt.kt b/app/src/main/java/com/amaze/filemanager/utils/AESCrypt.kt
index 8d7d7e03f..429625642 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/AESCrypt.kt
+++ b/app/src/main/java/com/amaze/filemanager/utils/AESCrypt.kt
@@ -207,7 +207,12 @@ class AESCrypt(password: String) {
      */
     @Suppress("LongMethod", "ComplexMethod")
     @Throws(IOException::class, GeneralSecurityException::class)
-    fun encrypt(version: Int = AESCRYPT_SPEC_VERSION, `in`: InputStream, out: OutputStream, progressHandler: ProgressHandler) {
+    fun encrypt(
+        version: Int = AESCRYPT_SPEC_VERSION,
+        `in`: InputStream,
+        out: OutputStream,
+        progressHandler: ProgressHandler
+    ) {
         var text: ByteArray?
         ivSpec1 = IvParameterSpec(generateIv1())
         aesKey1 = SecretKeySpec(generateAESKey1(ivSpec1.iv, password), CRYPT_ALG)
@@ -333,7 +338,9 @@ class AESCrypt(password: String) {
         Log.v(TAG, "HMAC1: ${text.toHex()}")
         total = inSize - total // Payload size.
         if (total % BLOCK_SIZE != 0L) {
-            throw DecryptFailureException("Input file is corrupt. BLOCK_SIZE = $BLOCK_SIZE, total was $total")
+            throw DecryptFailureException(
+                "Input file is corrupt. BLOCK_SIZE = $BLOCK_SIZE, total was $total"
+            )
         }
         if (total == 0L) { // Hack: empty files won't enter block-processing for-loop below.
             `in`.read() // Skip last block size mod 16.
diff --git a/app/src/main/java/com/amaze/filemanager/utils/DataUtils.java b/app/src/main/java/com/amaze/filemanager/utils/DataUtils.java
index 42a0149b1..517aca48e 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/DataUtils.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/DataUtils.java
@@ -27,7 +27,7 @@ import java.util.List;
 
 import com.amaze.filemanager.adapters.data.LayoutElementParcelable;
 import com.amaze.filemanager.application.AppConfig;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.cloudrail.si.interfaces.CloudStorage;
 import com.cloudrail.si.services.Box;
 import com.cloudrail.si.services.Dropbox;
diff --git a/app/src/main/java/com/amaze/filemanager/utils/GenericExt.kt b/app/src/main/java/com/amaze/filemanager/utils/GenericExt.kt
index 1d235c3f1..bc0a88bb7 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/GenericExt.kt
+++ b/app/src/main/java/com/amaze/filemanager/utils/GenericExt.kt
@@ -34,7 +34,10 @@ inline fun <T1 : Any, T2 : Any, T3 : Any, T4 : Any, T5 : Any, R : Any> safeLet(
 ): R? {
     return if (p1 != null && p2 != null && p3 != null && p4 != null && p5 != null) block(
         p1,
-        p2, p3, p4, p5
+        p2,
+        p3,
+        p4,
+        p5
     ) else null
 }
 
@@ -50,7 +53,8 @@ inline fun <T1 : Any, T2 : Any, T3 : Any, R : Any> safeLet(
 ): R? {
     return if (p1 != null && p2 != null && p3 != null) block(
         p1,
-        p2, p3
+        p2,
+        p3
     ) else null
 }
 
@@ -76,6 +80,6 @@ inline fun <T1 : Any, T2 : Any, R : Any> safeLet(
  */
 fun ByteArray.toHex(separatorStr: String = ""): String =
     joinToString(separator = separatorStr) {
-        eachByte ->
+            eachByte ->
         "%02x".format(eachByte)
     }
diff --git a/app/src/main/java/com/amaze/filemanager/utils/GlideConstants.java b/app/src/main/java/com/amaze/filemanager/utils/GlideConstants.java
index aa3d8bc34..12db9e78e 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/GlideConstants.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/GlideConstants.java
@@ -20,7 +20,9 @@
 
 package com.amaze.filemanager.utils;
 
-/** @author Emmanuel Messulam <emmanuelbendavid@gmail.com> on 8/12/2017, at 16:33. */
+/**
+ * @author Emmanuel Messulam <emmanuelbendavid@gmail.com> on 8/12/2017, at 16:33.
+ */
 public class GlideConstants {
 
   public static final int MAX_PRELOAD_FILES = 50;
diff --git a/app/src/main/java/com/amaze/filemanager/utils/MainActivityActionMode.kt b/app/src/main/java/com/amaze/filemanager/utils/MainActivityActionMode.kt
index a58e378f1..dd7a50741 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/MainActivityActionMode.kt
+++ b/app/src/main/java/com/amaze/filemanager/utils/MainActivityActionMode.kt
@@ -34,7 +34,7 @@ import androidx.drawerlayout.widget.DrawerLayout
 import androidx.fragment.app.FragmentActivity
 import com.amaze.filemanager.R
 import com.amaze.filemanager.adapters.data.LayoutElementParcelable
-import com.amaze.filemanager.file_operations.filesystem.OpenMode
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode
 import com.amaze.filemanager.filesystem.HybridFileParcelable
 import com.amaze.filemanager.filesystem.PasteHelper
 import com.amaze.filemanager.filesystem.files.FileUtils
@@ -66,7 +66,7 @@ class MainActivityActionMode(private val mainActivityReference: WeakReference<Ma
         // Inflate a menu resource providing context menu items
         val inflater = mode.menuInflater
         mainActivityReference.get()?.let {
-            mainActivity ->
+                mainActivity ->
             actionModeView = mainActivity.layoutInflater.inflate(R.layout.actionmode, null)
             mode.customView = actionModeView
             mainActivity.setPagingEnabled(false)
@@ -109,7 +109,7 @@ class MainActivityActionMode(private val mainActivityReference: WeakReference<Ma
             mainActivityReference.get()?.currentMainFragment?.mainFragmentViewModel,
             mainActivityReference.get()?.currentMainFragment?.adapter
         ) {
-            mainActivity, mainFragmentViewModel, adapter ->
+                mainActivity, mainFragmentViewModel, adapter ->
             val checkedItems: ArrayList<LayoutElementParcelable> =
                 mainFragmentViewModel.getCheckedItems()
             actionModeView?.setOnClickListener {
@@ -130,7 +130,9 @@ class MainActivityActionMode(private val mainActivityReference: WeakReference<Ma
                         mainFragmentViewModel.fileCount
                     ) R.string.deselect_all else R.string.select_all
                 )
-            if (mainFragmentViewModel.openMode != OpenMode.FILE && !mainFragmentViewModel.getIsCloudOpenMode()) {
+            if (mainFragmentViewModel.openMode != OpenMode.FILE && !mainFragmentViewModel
+                .getIsCloudOpenMode()
+            ) {
                 hideOption(R.id.addshortcut, menu)
                 hideOption(R.id.compress, menu)
                 return true
@@ -170,7 +172,7 @@ class MainActivityActionMode(private val mainActivityReference: WeakReference<Ma
                         if (e.isDirectory) {
                             hideOption(R.id.share, menu)
                             hideOption(R.id.openmulti, menu)
-                            break;
+                            break
                         }
                     }
                     hideOption(R.id.openwith, menu)
@@ -205,7 +207,7 @@ class MainActivityActionMode(private val mainActivityReference: WeakReference<Ma
                         if (e.isDirectory) {
                             hideOption(R.id.share, menu)
                             hideOption(R.id.openmulti, menu)
-                            break;
+                            break
                         }
                     }
                     hideOption(R.id.openwith, menu)
@@ -229,7 +231,7 @@ class MainActivityActionMode(private val mainActivityReference: WeakReference<Ma
             mainActivityReference
                 .get()?.currentMainFragment?.mainFragmentViewModel?.getCheckedItems()
         ) {
-            mainActivity, checkedItems ->
+                mainActivity, checkedItems ->
             return when (item.itemId) {
                 R.id.openmulti -> {
                     val intent_result = Intent(Intent.ACTION_SEND_MULTIPLE)
@@ -283,7 +285,7 @@ class MainActivityActionMode(private val mainActivityReference: WeakReference<Ma
                     )
                         .show() else {
                         mainActivity.currentMainFragment?.mainFragmentViewModel?.also {
-                            mainFragmentViewModel ->
+                                mainFragmentViewModel ->
                             when (checkedItems[0].mode) {
                                 OpenMode.DROPBOX, OpenMode.BOX, OpenMode.GDRIVE,
                                 OpenMode.ONEDRIVE ->
@@ -292,16 +294,16 @@ class MainActivityActionMode(private val mainActivityReference: WeakReference<Ma
                                         checkedItems[0].mode,
                                         mainActivity
                                     )
-                                 else -> {
+                                else -> {
                                     val arrayList = ArrayList<File>()
                                     for (e in checkedItems) {
                                         arrayList.add(File(e.desc))
                                     }
                                     FileUtils.shareFiles(
-                                            arrayList,
-                                            mainActivity,
-                                            mainActivity.utilsProvider.appTheme,
-                                            mainFragmentViewModel.accentColor
+                                        arrayList,
+                                        mainActivity,
+                                        mainActivity.utilsProvider.appTheme,
+                                        mainFragmentViewModel.accentColor
                                     )
                                 }
                             }
@@ -312,7 +314,8 @@ class MainActivityActionMode(private val mainActivityReference: WeakReference<Ma
                 R.id.openparent -> {
                     mainActivity.currentMainFragment?.loadlist(
                         File(checkedItems[0].desc).parent,
-                        false, OpenMode.FILE
+                        false,
+                        OpenMode.FILE
                     )
 
                     true
@@ -322,7 +325,7 @@ class MainActivityActionMode(private val mainActivityReference: WeakReference<Ma
                         mainActivity.currentMainFragment?.mainFragmentViewModel,
                         mainActivity.currentMainFragment?.adapter
                     ) {
-                        mainFragmentViewModel, adapter ->
+                            mainFragmentViewModel, adapter ->
                         if (adapter.areAllChecked(mainFragmentViewModel.currentPath)) {
                             adapter.toggleChecked(
                                 false,
@@ -388,7 +391,8 @@ class MainActivityActionMode(private val mainActivityReference: WeakReference<Ma
                         i4++
                     }
                     GeneralDialogCreation.showCompressDialog(
-                        mainActivity, copies1,
+                        mainActivity,
+                        copies1,
                         mainActivity.currentMainFragment?.mainFragmentViewModel?.currentPath
                     )
                     mode.finish()
@@ -396,13 +400,16 @@ class MainActivityActionMode(private val mainActivityReference: WeakReference<Ma
                 }
                 R.id.openwith -> {
                     FileUtils.openFile(
-                        File(checkedItems[0].desc), mainActivity, mainActivity.prefs
+                        File(checkedItems[0].desc),
+                        mainActivity,
+                        mainActivity.prefs
                     )
                     true
                 }
                 R.id.addshortcut -> {
                     Utils.addShortcut(
-                        mainActivity, mainActivity.componentName,
+                        mainActivity,
+                        mainActivity.componentName,
                         checkedItems[0]
                     )
                     mode.finish()
@@ -418,7 +425,7 @@ class MainActivityActionMode(private val mainActivityReference: WeakReference<Ma
     override fun onDestroyActionMode(mode: ActionMode) {
         actionMode = null
         mainActivityReference.get()?.let {
-            mainActivity ->
+                mainActivity ->
             mainActivity.listItemSelected = false
 
             // translates the drawer content up
@@ -430,16 +437,16 @@ class MainActivityActionMode(private val mainActivityReference: WeakReference<Ma
                 mainActivity.currentMainFragment?.mainFragmentViewModel,
                 mainActivity.currentMainFragment?.adapter
             ) {
-                mainFragmentViewModel, adapter ->
-                if (!mainFragmentViewModel.results)
+                    mainFragmentViewModel, adapter ->
+                if (!mainFragmentViewModel.results) {
                     adapter.toggleChecked(false, mainFragmentViewModel.currentPath)
-                else adapter.toggleChecked(false)
+                } else adapter.toggleChecked(false)
                 mainActivity
                     .updateViews(
                         ColorDrawable(
-                            if (MainActivity.currentTab == 1)
+                            if (MainActivity.currentTab == 1) {
                                 mainFragmentViewModel.primaryTwoColor
-                            else mainFragmentViewModel.primaryColor
+                            } else mainFragmentViewModel.primaryColor
                         )
                     )
             }
diff --git a/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java b/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java
index dca500ef5..ed45026c5 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java
@@ -20,15 +20,15 @@
 
 package com.amaze.filemanager.utils;
 
-import static com.amaze.filemanager.file_operations.filesystem.FolderStateKt.CAN_CREATE_FILES;
-import static com.amaze.filemanager.file_operations.filesystem.FolderStateKt.DOESNT_EXIST;
-import static com.amaze.filemanager.file_operations.filesystem.FolderStateKt.WRITABLE_OR_ON_SDCARD;
-import static com.amaze.filemanager.file_operations.filesystem.OperationTypeKt.COMPRESS;
-import static com.amaze.filemanager.file_operations.filesystem.OperationTypeKt.DELETE;
-import static com.amaze.filemanager.file_operations.filesystem.OperationTypeKt.EXTRACT;
-import static com.amaze.filemanager.file_operations.filesystem.OperationTypeKt.NEW_FILE;
-import static com.amaze.filemanager.file_operations.filesystem.OperationTypeKt.NEW_FOLDER;
-import static com.amaze.filemanager.file_operations.filesystem.OperationTypeKt.RENAME;
+import static com.amaze.filemanager.fileoperations.filesystem.FolderStateKt.CAN_CREATE_FILES;
+import static com.amaze.filemanager.fileoperations.filesystem.FolderStateKt.DOESNT_EXIST;
+import static com.amaze.filemanager.fileoperations.filesystem.FolderStateKt.WRITABLE_OR_ON_SDCARD;
+import static com.amaze.filemanager.fileoperations.filesystem.OperationTypeKt.COMPRESS;
+import static com.amaze.filemanager.fileoperations.filesystem.OperationTypeKt.DELETE;
+import static com.amaze.filemanager.fileoperations.filesystem.OperationTypeKt.EXTRACT;
+import static com.amaze.filemanager.fileoperations.filesystem.OperationTypeKt.NEW_FILE;
+import static com.amaze.filemanager.fileoperations.filesystem.OperationTypeKt.NEW_FOLDER;
+import static com.amaze.filemanager.fileoperations.filesystem.OperationTypeKt.RENAME;
 
 import java.io.File;
 import java.util.ArrayList;
@@ -42,8 +42,8 @@ import com.amaze.filemanager.asynchronous.services.ZipService;
 import com.amaze.filemanager.database.CloudHandler;
 import com.amaze.filemanager.database.CryptHandler;
 import com.amaze.filemanager.database.models.explorer.EncryptedEntry;
-import com.amaze.filemanager.file_operations.filesystem.FolderState;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.FolderState;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.ExternalSdCardOperation;
 import com.amaze.filemanager.filesystem.FileProperties;
 import com.amaze.filemanager.filesystem.HybridFile;
@@ -60,7 +60,7 @@ import com.amaze.filemanager.ui.dialogs.GeneralDialogCreation;
 import com.amaze.filemanager.ui.fragments.MainFragment;
 import com.amaze.filemanager.ui.fragments.SearchWorkerFragment;
 import com.amaze.filemanager.ui.fragments.TabFragment;
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants;
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants;
 import com.amaze.filemanager.ui.views.WarnableTextInputValidator;
 import com.leinardi.android.speeddial.SpeedDialView;
 
@@ -679,7 +679,7 @@ public class MainActivityHelper {
 
   public void extractFile(@NonNull File file) {
     final File parent = file.getParentFile();
-    if(parent == null) {
+    if (parent == null) {
       Toast.makeText(mainActivity, R.string.error, Toast.LENGTH_SHORT).show();
       Log.e(TAG, "File's parent is null " + file.getPath());
       return;
@@ -690,7 +690,8 @@ public class MainActivityHelper {
       case WRITABLE_OR_ON_SDCARD:
         Decompressor decompressor = CompressedHelper.getCompressorInstance(mainActivity, file);
         if (decompressor == null) {
-          Toast.makeText(mainActivity, R.string.error_cant_decompress_that_file, Toast.LENGTH_LONG).show();
+          Toast.makeText(mainActivity, R.string.error_cant_decompress_that_file, Toast.LENGTH_LONG)
+              .show();
           return;
         }
         decompressor.decompress(file.getPath());
diff --git a/app/src/main/java/com/amaze/filemanager/utils/OTGUtil.kt b/app/src/main/java/com/amaze/filemanager/utils/OTGUtil.kt
index 5cab338b6..6b2dcb758 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/OTGUtil.kt
+++ b/app/src/main/java/com/amaze/filemanager/utils/OTGUtil.kt
@@ -32,9 +32,9 @@ import android.util.Log
 import androidx.annotation.RequiresApi
 import androidx.documentfile.provider.DocumentFile
 import com.amaze.filemanager.exceptions.DocumentFileNotFoundException
-import com.amaze.filemanager.file_operations.filesystem.OpenMode
-import com.amaze.filemanager.file_operations.filesystem.usb.SingletonUsbOtg
-import com.amaze.filemanager.file_operations.filesystem.usb.UsbOtgRepresentation
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode
+import com.amaze.filemanager.fileoperations.filesystem.usb.SingletonUsbOtg
+import com.amaze.filemanager.fileoperations.filesystem.usb.UsbOtgRepresentation
 import com.amaze.filemanager.filesystem.HybridFileParcelable
 import com.amaze.filemanager.filesystem.RootHelper
 import kotlin.collections.ArrayList
@@ -66,7 +66,8 @@ object OTGUtil {
     fun getDocumentFilesList(path: String, context: Context): ArrayList<HybridFileParcelable> {
         val files = ArrayList<HybridFileParcelable>()
         getDocumentFiles(
-            path, context,
+            path,
+            context,
             object : OnFileFound {
                 override fun onFileFound(file: HybridFileParcelable) {
                     files.add(file)
diff --git a/app/src/main/java/com/amaze/filemanager/utils/ObtainableServiceBinder.java b/app/src/main/java/com/amaze/filemanager/utils/ObtainableServiceBinder.java
index a53907ba4..ae6b9b2a5 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/ObtainableServiceBinder.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/ObtainableServiceBinder.java
@@ -23,7 +23,9 @@ package com.amaze.filemanager.utils;
 import android.app.Service;
 import android.os.Binder;
 
-/** @author Emmanuel on 28/11/2017, at 19:04. */
+/**
+ * @author Emmanuel on 28/11/2017, at 19:04.
+ */
 public class ObtainableServiceBinder<T extends Service> extends Binder {
 
   private final T service;
diff --git a/app/src/main/java/com/amaze/filemanager/utils/PackageUtils.kt b/app/src/main/java/com/amaze/filemanager/utils/PackageUtils.kt
index c4cc96ab1..aae981e95 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/PackageUtils.kt
+++ b/app/src/main/java/com/amaze/filemanager/utils/PackageUtils.kt
@@ -1,3 +1,23 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.utils
 
 import android.content.pm.PackageManager
@@ -18,4 +38,4 @@ class PackageUtils {
             }
         }
     }
-}
\ No newline at end of file
+}
diff --git a/app/src/main/java/com/amaze/filemanager/utils/ProgressHandler.java b/app/src/main/java/com/amaze/filemanager/utils/ProgressHandler.java
index 80261f2a6..58267ba44 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/ProgressHandler.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/ProgressHandler.java
@@ -130,7 +130,9 @@ public class ProgressHandler {
    * for notification generation and process viewer fragment
    */
   public interface ProgressListener {
-    /** @param speed raw write speed in bytes */
+    /**
+     * @param speed raw write speed in bytes
+     */
     void onProgressed(long speed);
   }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/utils/SmbUtil.java b/app/src/main/java/com/amaze/filemanager/utils/SmbUtil.java
index b50d0e080..88e597e7f 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/SmbUtil.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/SmbUtil.java
@@ -20,8 +20,8 @@
 
 package com.amaze.filemanager.utils;
 
-import static com.amaze.filemanager.file_operations.filesystem.FolderStateKt.DOESNT_EXIST;
-import static com.amaze.filemanager.file_operations.filesystem.FolderStateKt.WRITABLE_ON_REMOTE;
+import static com.amaze.filemanager.fileoperations.filesystem.FolderStateKt.DOESNT_EXIST;
+import static com.amaze.filemanager.fileoperations.filesystem.FolderStateKt.WRITABLE_ON_REMOTE;
 
 import java.io.File;
 import java.io.IOException;
diff --git a/app/src/main/java/com/amaze/filemanager/utils/security/SecretKeygen.kt b/app/src/main/java/com/amaze/filemanager/utils/security/SecretKeygen.kt
index af1aa2a74..4189ff41f 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/security/SecretKeygen.kt
+++ b/app/src/main/java/com/amaze/filemanager/utils/security/SecretKeygen.kt
@@ -107,7 +107,8 @@ object SecretKeygen {
         val encodedString = preferences.getString(PREFERENCE_KEY, null)
         return if (encodedString != null) {
             SecretKeySpec(
-                decryptAESKey(Base64.decode(encodedString, Base64.DEFAULT)), "AES"
+                decryptAESKey(Base64.decode(encodedString, Base64.DEFAULT)),
+                "AES"
             )
         } else {
             generateRsaKeyPair(AppConfig.getInstance())
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/AbstractDeleteTaskTestBase.kt b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/AbstractDeleteTaskTestBase.kt
index 54132f5aa..32a755dff 100644
--- a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/AbstractDeleteTaskTestBase.kt
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/AbstractDeleteTaskTestBase.kt
@@ -102,7 +102,6 @@ abstract class AbstractDeleteTaskTestBase {
     }
 
     protected fun doTestDeleteFileAccessDenied(file: HybridFileParcelable) {
-
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) TestUtils.initializeInternalStorage()
 
         ActivityScenario.launch(MainActivity::class.java).also {
@@ -135,9 +134,10 @@ abstract class AbstractDeleteTaskTestBase {
                 }
             }
         }.moveToState(Lifecycle.State.DESTROYED).close().run {
-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N)
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                 shadowOf(ctx?.getSystemService(StorageManager::class.java))
                     .resetStorageVolumeList()
+            }
         }
     }
 }
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/MoveFilesTest.java b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/MoveFilesTest.java
index 5d1afc7f3..0e9a899d9 100644
--- a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/MoveFilesTest.java
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/MoveFilesTest.java
@@ -40,7 +40,7 @@ import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
 
 import com.amaze.filemanager.asynchronous.asynctasks.movecopy.MoveFiles;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.ssh.AbstractSftpServerTest;
 import com.amaze.filemanager.shadows.ShadowMultiDex;
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/SshDeleteTaskTest.kt b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/SshDeleteTaskTest.kt
index 0e3a482fa..4a95cf5b0 100644
--- a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/SshDeleteTaskTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/SshDeleteTaskTest.kt
@@ -72,7 +72,8 @@ class SshDeleteTaskTest : AbstractDeleteTaskTestBase() {
 
         return HybridFileParcelable(
             "ssh://user:password@127.0.0.1:22222",
-            false, ri
+            false,
+            ri
         )
     }
 }
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/AbstractCompressedHelperCallableArchiveTest.kt b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/AbstractCompressedHelperCallableArchiveTest.kt
index dff622940..13e595226 100644
--- a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/AbstractCompressedHelperCallableArchiveTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/AbstractCompressedHelperCallableArchiveTest.kt
@@ -29,7 +29,8 @@ import java.time.ZoneId
 import java.time.ZonedDateTime
 
 @Suppress("TooManyFunctions", "StringLiteralDuplication")
-abstract class AbstractCompressedHelperCallableArchiveTest : AbstractCompressedHelperCallableTest() {
+abstract class AbstractCompressedHelperCallableArchiveTest :
+    AbstractCompressedHelperCallableTest() {
 
     companion object {
         @JvmStatic
@@ -127,7 +128,13 @@ abstract class AbstractCompressedHelperCallableArchiveTest : AbstractCompressedH
     }
 
     protected fun createCallable(relativePath: String): CompressedHelperCallable =
-        doCreateCallable(File(Environment.getExternalStorageDirectory(), archiveFileName), relativePath)
+        doCreateCallable(
+            File(Environment.getExternalStorageDirectory(), archiveFileName),
+            relativePath
+        )
 
-    protected abstract fun doCreateCallable(archive: File, relativePath: String): CompressedHelperCallable
+    protected abstract fun doCreateCallable(
+        archive: File,
+        relativePath: String
+    ): CompressedHelperCallable
 }
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/CompressedHelperForBadArchiveTest.kt b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/CompressedHelperForBadArchiveTest.kt
index 2bbcf1d36..c213f7f31 100644
--- a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/CompressedHelperForBadArchiveTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/CompressedHelperForBadArchiveTest.kt
@@ -1,3 +1,23 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.asynchronous.asynctasks.compress
 
 import android.os.Build.VERSION_CODES.*
@@ -44,10 +64,14 @@ class CompressedHelperForBadArchiveTest {
         for (
             archiveType in supportedArchiveExtensions().subtract(excludedArchiveTypes)
         ) {
-            val badArchive = File(Environment.getExternalStorageDirectory(), "bad-archive.$archiveType")
+            val badArchive = File(
+                Environment.getExternalStorageDirectory(),
+                "bad-archive.$archiveType"
+            )
             ByteArrayInputStream(data).copyTo(FileOutputStream(badArchive))
             val task = CompressedHelper.getCompressorInstance(
-                    ApplicationProvider.getApplicationContext(), badArchive
+                ApplicationProvider.getApplicationContext(),
+                badArchive
             )
             Assert.assertNotNull(task)
             task!!
@@ -57,8 +81,8 @@ class CompressedHelperForBadArchiveTest {
             } catch (exception: ArchiveException) {
                 Assert.assertNotNull(exception)
                 Assert.assertTrue(
-                        "Thrown from ${task.javaClass}: ${exception.javaClass} was thrown",
-                        ArchiveException::class.java.isAssignableFrom(exception.javaClass)
+                    "Thrown from ${task.javaClass}: ${exception.javaClass} was thrown",
+                    ArchiveException::class.java.isAssignableFrom(exception.javaClass)
                 )
             }
         }
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/EncryptedRarHelperCallableTest.kt b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/EncryptedRarHelperCallableTest.kt
index 3169897c6..26c57dd70 100644
--- a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/EncryptedRarHelperCallableTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/EncryptedRarHelperCallableTest.kt
@@ -28,7 +28,7 @@ class EncryptedRarHelperCallableTest : AbstractCompressedHelperCallableArchiveTe
         get() = "test-archive-encrypted.rar"
 
     override fun doCreateCallable(archive: File, relativePath: String): CompressedHelperCallable =
-            RarHelperCallable(
+        RarHelperCallable(
             archive.absolutePath,
             relativePath,
             false
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/EncryptedSevenZipHelperCallableTest.kt b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/EncryptedSevenZipHelperCallableTest.kt
index d476ccfc6..2e9c64deb 100644
--- a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/EncryptedSevenZipHelperCallableTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/EncryptedSevenZipHelperCallableTest.kt
@@ -28,7 +28,7 @@ class EncryptedSevenZipHelperCallableTest : AbstractCompressedHelperCallableArch
         get() = "test-archive-encrypted.7z"
 
     override fun doCreateCallable(archive: File, relativePath: String): CompressedHelperCallable =
-            SevenZipHelperCallable(
+        SevenZipHelperCallable(
             archive.absolutePath,
             relativePath,
             false
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/EncryptedZipHelperCallableTest.kt b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/EncryptedZipHelperCallableTest.kt
index fd91ec0b6..89f234109 100644
--- a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/EncryptedZipHelperCallableTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/EncryptedZipHelperCallableTest.kt
@@ -29,7 +29,7 @@ class EncryptedZipHelperCallableTest : AbstractCompressedHelperCallableArchiveTe
         get() = "test-archive-encrypted.zip"
 
     override fun doCreateCallable(archive: File, relativePath: String): CompressedHelperCallable =
-            ZipHelperCallable(
+        ZipHelperCallable(
             ApplicationProvider.getApplicationContext(),
             archive.absolutePath,
             relativePath,
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/ListEncryptedSevenZipHelperCallableTest.kt b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/ListEncryptedSevenZipHelperCallableTest.kt
index fa290cb2b..ee9ca6d61 100644
--- a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/ListEncryptedSevenZipHelperCallableTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/ListEncryptedSevenZipHelperCallableTest.kt
@@ -20,7 +20,7 @@
 
 package com.amaze.filemanager.asynchronous.asynctasks.compress
 
-import com.amaze.filemanager.file_operations.filesystem.compressed.ArchivePasswordCache
+import com.amaze.filemanager.fileoperations.filesystem.compressed.ArchivePasswordCache
 import java.io.File
 
 class ListEncryptedSevenZipHelperCallableTest : AbstractCompressedHelperCallableArchiveTest() {
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/RarHelperCallableTest.kt b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/RarHelperCallableTest.kt
index fbfbf8d22..deb2a9f2d 100644
--- a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/RarHelperCallableTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/RarHelperCallableTest.kt
@@ -80,9 +80,9 @@ class RarHelperCallableTest : AbstractCompressedHelperCallableArchiveTest() {
     }
 
     override fun doCreateCallable(archive: File, relativePath: String): CompressedHelperCallable =
-            RarHelperCallable(
-        archive.absolutePath,
-        relativePath,
-        false
-    )
+        RarHelperCallable(
+            archive.absolutePath,
+            relativePath,
+            false
+        )
 }
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/TarBzip2HelperCallableTest.kt b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/TarBzip2HelperCallableTest.kt
index f4b4d6c08..ab7ff22ca 100644
--- a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/TarBzip2HelperCallableTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/TarBzip2HelperCallableTest.kt
@@ -28,7 +28,7 @@ class TarBzip2HelperCallableTest : AbstractCompressedHelperCallableArchiveTest()
         get() = "test-archive.tar.bz2"
 
     override fun doCreateCallable(archive: File, relativePath: String): CompressedHelperCallable =
-            TarBzip2HelperCallable(
+        TarBzip2HelperCallable(
             ApplicationProvider.getApplicationContext(),
             archive.absolutePath,
             relativePath,
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/TarGzHelperCallableTest.kt b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/TarGzHelperCallableTest.kt
index 2fb20b075..f267b9faf 100644
--- a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/TarGzHelperCallableTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/TarGzHelperCallableTest.kt
@@ -29,7 +29,7 @@ class TarGzHelperCallableTest : AbstractCompressedHelperCallableArchiveTest() {
         get() = "test-archive.tar.gz"
 
     override fun doCreateCallable(archive: File, relativePath: String): CompressedHelperCallable =
-            TarGzHelperCallable(
+        TarGzHelperCallable(
             ApplicationProvider.getApplicationContext(),
             archive.absolutePath,
             relativePath,
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/TarHelperCallableTest.kt b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/TarHelperCallableTest.kt
index 0218910a9..a3d898515 100644
--- a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/TarHelperCallableTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/TarHelperCallableTest.kt
@@ -29,7 +29,7 @@ class TarHelperCallableTest : AbstractCompressedHelperCallableArchiveTest() {
         get() = "test-archive.tar"
 
     override fun doCreateCallable(archive: File, relativePath: String): CompressedHelperCallable =
-            TarHelperCallable(
+        TarHelperCallable(
             ApplicationProvider.getApplicationContext(),
             archive.absolutePath,
             relativePath,
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/TarLzmaHelperCallableTest.kt b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/TarLzmaHelperCallableTest.kt
index 7b8d27781..c04439363 100644
--- a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/TarLzmaHelperCallableTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/TarLzmaHelperCallableTest.kt
@@ -29,7 +29,7 @@ class TarLzmaHelperCallableTest : AbstractCompressedHelperCallableArchiveTest()
         get() = "test-archive.tar.lzma"
 
     override fun doCreateCallable(archive: File, relativePath: String): CompressedHelperCallable =
-            TarLzmaHelperCallable(
+        TarLzmaHelperCallable(
             ApplicationProvider.getApplicationContext(),
             archive.absolutePath,
             relativePath,
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/TarXzHelperCallableTest.kt b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/TarXzHelperCallableTest.kt
index 526880534..a8ff1f006 100644
--- a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/TarXzHelperCallableTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/TarXzHelperCallableTest.kt
@@ -29,7 +29,7 @@ class TarXzHelperCallableTest : AbstractCompressedHelperCallableArchiveTest() {
         get() = "test-archive.tar.xz"
 
     override fun doCreateCallable(archive: File, relativePath: String): CompressedHelperCallable =
-            TarXzHelperCallable(
+        TarXzHelperCallable(
             ApplicationProvider.getApplicationContext(),
             archive.absolutePath,
             relativePath,
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/TarXzHelperCallableTest2.kt b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/TarXzHelperCallableTest2.kt
index 9ca0fb3cd..0d83faf56 100644
--- a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/TarXzHelperCallableTest2.kt
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/TarXzHelperCallableTest2.kt
@@ -57,10 +57,10 @@ class TarXzHelperCallableTest2 : AbstractCompressedHelperCallableArchiveTest() {
     }
 
     override fun doCreateCallable(archive: File, relativePath: String): CompressedHelperCallable =
-            TarXzHelperCallable(
-        ApplicationProvider.getApplicationContext(),
-        archive.absolutePath,
-        relativePath,
-        false
-    )
+        TarXzHelperCallable(
+            ApplicationProvider.getApplicationContext(),
+            archive.absolutePath,
+            relativePath,
+            false
+        )
 }
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/ZipHelperCallableTest.kt b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/ZipHelperCallableTest.kt
index 98e303c1e..a4abb8ad1 100644
--- a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/ZipHelperCallableTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/compress/ZipHelperCallableTest.kt
@@ -40,16 +40,18 @@ class ZipHelperCallableTest : AbstractCompressedHelperCallableArchiveTest() {
     fun testVariableYAssignment() {
         var a = "aaz"
         var y = a.apply {
-            if (startsWith("/"))
+            if (startsWith("/")) {
                 substring(1, length)
+            }
         }
         assertEquals("aaz", y)
         a = "/abcdefg"
         y = a.let {
-            if (it.startsWith("/"))
+            if (it.startsWith("/")) {
                 it.substring(1, it.length)
-            else
+            } else {
                 it
+            }
         }
         assertEquals("abcdefg", y)
     }
@@ -68,7 +70,7 @@ class ZipHelperCallableTest : AbstractCompressedHelperCallableArchiveTest() {
     }
 
     override fun doCreateCallable(archive: File, relativePath: String): CompressedHelperCallable =
-            ZipHelperCallable(
+        ZipHelperCallable(
             ApplicationProvider.getApplicationContext(),
             archive.absolutePath,
             relativePath,
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/texteditor/read/ReadTextFileCallableTest.kt b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/texteditor/read/ReadTextFileCallableTest.kt
index 96ef7d47d..78b2790f7 100644
--- a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/texteditor/read/ReadTextFileCallableTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/texteditor/read/ReadTextFileCallableTest.kt
@@ -28,8 +28,8 @@ import android.os.Build.VERSION_CODES.P
 import androidx.test.core.app.ApplicationProvider
 import androidx.test.ext.junit.runners.AndroidJUnit4
 import com.amaze.filemanager.asynchronous.asynctasks.texteditor.read.ReadTextFileCallable.MAX_FILE_SIZE_CHARS
-import com.amaze.filemanager.file_operations.exceptions.ShellNotRunningException
-import com.amaze.filemanager.file_operations.exceptions.StreamNotFoundException
+import com.amaze.filemanager.fileoperations.exceptions.ShellNotRunningException
+import com.amaze.filemanager.fileoperations.exceptions.StreamNotFoundException
 import com.amaze.filemanager.filesystem.EditableFileAbstraction
 import com.amaze.filemanager.filesystem.RandomPathGenerator
 import com.amaze.filemanager.shadows.ShadowMultiDex
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/texteditor/write/WriteTextFileCallableTest.java b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/texteditor/write/WriteTextFileCallableTest.java
index 082a453ab..d9b2f1430 100644
--- a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/texteditor/write/WriteTextFileCallableTest.java
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/texteditor/write/WriteTextFileCallableTest.java
@@ -44,12 +44,14 @@ import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.shadow.api.Shadow;
 
-import com.amaze.filemanager.file_operations.exceptions.ShellNotRunningException;
-import com.amaze.filemanager.file_operations.exceptions.StreamNotFoundException;
+import com.amaze.filemanager.fileoperations.exceptions.ShellNotRunningException;
+import com.amaze.filemanager.fileoperations.exceptions.StreamNotFoundException;
 import com.amaze.filemanager.filesystem.EditableFileAbstraction;
 import com.amaze.filemanager.filesystem.FileUtil;
 import com.amaze.filemanager.filesystem.root.ConcatenateFileCommand;
+import com.amaze.filemanager.shadows.ShadowContentResolver;
 import com.amaze.filemanager.shadows.ShadowMultiDex;
 
 import android.content.ContentResolver;
@@ -62,7 +64,7 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 
 @RunWith(AndroidJUnit4.class)
 @Config(
-    shadows = {ShadowMultiDex.class},
+    shadows = {ShadowMultiDex.class, ShadowContentResolver.class},
     sdk = {JELLY_BEAN, KITKAT, P})
 public class WriteTextFileCallableTest {
 
@@ -75,7 +77,8 @@ public class WriteTextFileCallableTest {
     Context ctx = ApplicationProvider.getApplicationContext();
     ContentResolver cr = ctx.getContentResolver();
     ByteArrayOutputStream bout = new ByteArrayOutputStream();
-    shadowOf(cr).registerOutputStream(uri, bout);
+    ShadowContentResolver scr = Shadow.extract(cr);
+    scr.registerOutputStream(uri, bout);
 
     WriteTextFileCallable task =
         new WriteTextFileCallable(
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/services/DecryptServiceTest.kt b/app/src/test/java/com/amaze/filemanager/asynchronous/services/DecryptServiceTest.kt
index f298f9898..34260262b 100644
--- a/app/src/test/java/com/amaze/filemanager/asynchronous/services/DecryptServiceTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/services/DecryptServiceTest.kt
@@ -1,3 +1,23 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.asynchronous.services
 
 import android.app.NotificationManager
@@ -94,7 +114,10 @@ class DecryptServiceTest {
             false,
             null
         )
-        val targetFile = File(Environment.getExternalStorageDirectory(), "test.bin${CryptUtil.CRYPT_EXTENSION}")
+        val targetFile = File(
+            Environment.getExternalStorageDirectory(),
+            "test.bin${CryptUtil.CRYPT_EXTENSION}"
+        )
         assertTrue(targetFile.exists())
         sourceFile.delete()
 
@@ -112,8 +135,9 @@ class DecryptServiceTest {
         assertTrue(notificationManager.activeNotifications.isNotEmpty())
         notificationManager.activeNotifications.first().let {
             assertEquals(NotificationConstants.DECRYPT_ID, it.id)
-            if (SDK_INT >= O)
+            if (SDK_INT >= O) {
                 assertEquals(NotificationConstants.CHANNEL_NORMAL_ID, it.notification.channelId)
+            }
         }
         val verifyFile = File(Environment.getExternalStorageDirectory(), "test.bin")
         await().atMost(1000, TimeUnit.SECONDS).until {
@@ -129,7 +153,10 @@ class DecryptServiceTest {
     @Test
     fun testAescryptWorkflow() {
         if (SDK_INT >= M) {
-            val sourceFile = File(Environment.getExternalStorageDirectory(), "test.bin${CryptUtil.AESCRYPT_EXTENSION}")
+            val sourceFile = File(
+                Environment.getExternalStorageDirectory(),
+                "test.bin${CryptUtil.AESCRYPT_EXTENSION}"
+            )
             val targetFile = File(Environment.getExternalStorageDirectory(), "test.bin")
             AESCrypt("passW0rD").encrypt(
                 `in` = ByteArrayInputStream(source),
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/services/EncryptServiceTest.kt b/app/src/test/java/com/amaze/filemanager/asynchronous/services/EncryptServiceTest.kt
index 3839c7edb..99566ba15 100644
--- a/app/src/test/java/com/amaze/filemanager/asynchronous/services/EncryptServiceTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/services/EncryptServiceTest.kt
@@ -1,3 +1,23 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.asynchronous.services
 
 import android.app.NotificationManager
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/services/ExtractServiceTest.kt b/app/src/test/java/com/amaze/filemanager/asynchronous/services/ExtractServiceTest.kt
index db16c18aa..563f724e0 100644
--- a/app/src/test/java/com/amaze/filemanager/asynchronous/services/ExtractServiceTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/services/ExtractServiceTest.kt
@@ -29,7 +29,7 @@ import android.os.Environment
 import androidx.test.core.app.ApplicationProvider
 import androidx.test.ext.junit.runners.AndroidJUnit4
 import com.amaze.filemanager.R
-import com.amaze.filemanager.file_operations.filesystem.compressed.ArchivePasswordCache
+import com.amaze.filemanager.fileoperations.filesystem.compressed.ArchivePasswordCache
 import com.amaze.filemanager.shadows.ShadowMultiDex
 import com.amaze.filemanager.test.randomBytes
 import com.amaze.filemanager.test.supportedArchiveExtensions
@@ -408,7 +408,10 @@ class ExtractServiceTest {
 
     private fun doTestBadArchive(data: ByteArray) {
         for (archiveType in supportedArchiveExtensions()) {
-            val badArchive = File(Environment.getExternalStorageDirectory(), "bad-archive.$archiveType")
+            val badArchive = File(
+                Environment.getExternalStorageDirectory(),
+                "bad-archive.$archiveType"
+            )
             ByteArrayInputStream(data).copyTo(FileOutputStream(badArchive))
             performTest(badArchive)
             ShadowLooper.idleMainLooper()
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/services/FtpServiceSupportedCiphersTest.kt b/app/src/test/java/com/amaze/filemanager/asynchronous/services/FtpServiceSupportedCiphersTest.kt
index fca2fd8e0..8b6bbc41a 100644
--- a/app/src/test/java/com/amaze/filemanager/asynchronous/services/FtpServiceSupportedCiphersTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/services/FtpServiceSupportedCiphersTest.kt
@@ -1,3 +1,23 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.asynchronous.services
 
 import android.os.Build
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/services/ZipServiceTest.kt b/app/src/test/java/com/amaze/filemanager/asynchronous/services/ZipServiceTest.kt
index 8c565a094..73d5643a6 100644
--- a/app/src/test/java/com/amaze/filemanager/asynchronous/services/ZipServiceTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/services/ZipServiceTest.kt
@@ -127,7 +127,8 @@ class ZipServiceTest {
                         "${entry.fileName} timestamp not equal. " +
                             "${Date(this[idx].lastModified())} " +
                             "vs ${Date(entry.lastModifiedTimeEpoch)}",
-                        this[idx].lastModified(), entry.lastModifiedTimeEpoch
+                        this[idx].lastModified(),
+                        entry.lastModifiedTimeEpoch
                     )
                 }
             }
diff --git a/app/src/test/java/com/amaze/filemanager/database/ExplorerDatabaseMigrationTest.java b/app/src/test/java/com/amaze/filemanager/database/ExplorerDatabaseMigrationTest.java
index e9d1ff037..0e7ff7f20 100644
--- a/app/src/test/java/com/amaze/filemanager/database/ExplorerDatabaseMigrationTest.java
+++ b/app/src/test/java/com/amaze/filemanager/database/ExplorerDatabaseMigrationTest.java
@@ -44,7 +44,7 @@ import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
 
 import com.amaze.filemanager.database.models.explorer.CloudEntry;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.shadows.ShadowMultiDex;
 import com.amaze.filemanager.test.ShadowPasswordUtil;
 
diff --git a/app/src/test/java/com/amaze/filemanager/database/UtilsHandlerTest.kt b/app/src/test/java/com/amaze/filemanager/database/UtilsHandlerTest.kt
index 31bb21320..3e92419b9 100644
--- a/app/src/test/java/com/amaze/filemanager/database/UtilsHandlerTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/database/UtilsHandlerTest.kt
@@ -1,3 +1,23 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.database
 
 import android.os.Build.VERSION_CODES.JELLY_BEAN
@@ -172,7 +192,8 @@ class UtilsHandlerTest {
                 assertTrue(
                     verify.contains(
                         Pair<String, String>(
-                            d, File(Environment.getExternalStorageDirectory(), d).absolutePath
+                            d,
+                            File(Environment.getExternalStorageDirectory(), d).absolutePath
                         )
                     )
                 )
diff --git a/app/src/test/java/com/amaze/filemanager/database/models/utilities/GridTest.kt b/app/src/test/java/com/amaze/filemanager/database/models/utilities/GridTest.kt
index 974d9f788..46b8596ed 100644
--- a/app/src/test/java/com/amaze/filemanager/database/models/utilities/GridTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/database/models/utilities/GridTest.kt
@@ -1,3 +1,23 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.database.models.utilities
 
 import org.junit.Assert.assertEquals
diff --git a/app/src/test/java/com/amaze/filemanager/database/models/utilities/ListTest.kt b/app/src/test/java/com/amaze/filemanager/database/models/utilities/ListTest.kt
index 15eb267ad..3bd24e1b1 100644
--- a/app/src/test/java/com/amaze/filemanager/database/models/utilities/ListTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/database/models/utilities/ListTest.kt
@@ -1,3 +1,23 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.database.models.utilities
 
 import org.junit.Assert.assertEquals
diff --git a/app/src/test/java/com/amaze/filemanager/database/models/utilities/SftpEntryTest.kt b/app/src/test/java/com/amaze/filemanager/database/models/utilities/SftpEntryTest.kt
index 0b96f4198..bba5965b1 100644
--- a/app/src/test/java/com/amaze/filemanager/database/models/utilities/SftpEntryTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/database/models/utilities/SftpEntryTest.kt
@@ -1,3 +1,23 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.database.models.utilities
 
 import org.junit.Assert.assertEquals
diff --git a/app/src/test/java/com/amaze/filemanager/database/models/utilities/SmbEntryTest.kt b/app/src/test/java/com/amaze/filemanager/database/models/utilities/SmbEntryTest.kt
index 05ee57739..7c6a24415 100644
--- a/app/src/test/java/com/amaze/filemanager/database/models/utilities/SmbEntryTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/database/models/utilities/SmbEntryTest.kt
@@ -1,3 +1,23 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.database.models.utilities
 
 import org.junit.Assert.assertEquals
@@ -53,4 +73,4 @@ class SmbEntryTest {
         assertNotEquals(a, b)
         assertNotEquals(a.hashCode(), b.hashCode())
     }
-}
\ No newline at end of file
+}
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/AbstractOperationsTestBase.kt b/app/src/test/java/com/amaze/filemanager/filesystem/AbstractOperationsTestBase.kt
index 23239b9ac..a0d609300 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/AbstractOperationsTestBase.kt
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/AbstractOperationsTestBase.kt
@@ -31,7 +31,7 @@ import androidx.lifecycle.Lifecycle
 import androidx.test.core.app.ActivityScenario
 import androidx.test.core.app.ApplicationProvider
 import androidx.test.ext.junit.runners.AndroidJUnit4
-import com.amaze.filemanager.file_operations.filesystem.OpenMode
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode
 import com.amaze.filemanager.shadows.ShadowMultiDex
 import com.amaze.filemanager.shadows.ShadowSmbUtil
 import com.amaze.filemanager.test.ShadowPasswordUtil
@@ -133,9 +133,10 @@ abstract class AbstractOperationsTestBase {
                 }
             }
         }.moveToState(Lifecycle.State.DESTROYED).close().run {
-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N)
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                 Shadows.shadowOf(ctx?.getSystemService(StorageManager::class.java))
                     .resetStorageVolumeList()
+            }
         }
     }
 }
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/HybridFileTest.kt b/app/src/test/java/com/amaze/filemanager/filesystem/HybridFileTest.kt
index ab1a83d25..5e52d3391 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/HybridFileTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/HybridFileTest.kt
@@ -25,7 +25,7 @@ import android.os.Build.VERSION_CODES.KITKAT
 import android.os.Build.VERSION_CODES.P
 import androidx.test.core.app.ApplicationProvider
 import androidx.test.ext.junit.runners.AndroidJUnit4
-import com.amaze.filemanager.file_operations.filesystem.OpenMode
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode
 import com.amaze.filemanager.shadows.ShadowMultiDex
 import org.junit.Assert.assertEquals
 import org.junit.Test
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/OperationsTest.java b/app/src/test/java/com/amaze/filemanager/filesystem/OperationsTest.java
index 89ad3da40..41fcddddc 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/OperationsTest.java
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/OperationsTest.java
@@ -34,7 +34,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
 
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.shadows.ShadowMultiDex;
 
 import android.os.Environment;
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/RootHelperTest.java b/app/src/test/java/com/amaze/filemanager/filesystem/RootHelperTest.java
index d0bd24c80..f576ed94e 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/RootHelperTest.java
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/RootHelperTest.java
@@ -25,19 +25,6 @@ import static android.os.Build.VERSION_CODES.KITKAT;
 import static android.os.Build.VERSION_CODES.P;
 import static org.junit.Assert.fail;
 
-import android.os.Environment;
-
-import androidx.test.ext.junit.runners.AndroidJUnit4;
-
-import com.amaze.filemanager.filesystem.root.ListFilesCommand;
-import com.amaze.filemanager.shadows.ShadowMultiDex;
-
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.annotation.Config;
-
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
@@ -48,6 +35,19 @@ import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
 
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+import com.amaze.filemanager.filesystem.root.ListFilesCommand;
+import com.amaze.filemanager.shadows.ShadowMultiDex;
+
+import android.os.Environment;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+
 @RunWith(AndroidJUnit4.class)
 @Config(
     shadows = {ShadowMultiDex.class},
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/SmbOperationsTest.kt b/app/src/test/java/com/amaze/filemanager/filesystem/SmbOperationsTest.kt
index d00e7bb42..b13515bed 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/SmbOperationsTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/SmbOperationsTest.kt
@@ -20,7 +20,7 @@
 
 package com.amaze.filemanager.filesystem
 
-import com.amaze.filemanager.file_operations.filesystem.OpenMode
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode
 import com.amaze.filemanager.shadows.ShadowSmbUtil.Companion.PATH_CANNOT_RENAME_OLDFILE
 import org.junit.Test
 
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/SshOperationsTest.kt b/app/src/test/java/com/amaze/filemanager/filesystem/SshOperationsTest.kt
index c0315d261..2124892ec 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/SshOperationsTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/SshOperationsTest.kt
@@ -20,7 +20,7 @@
 
 package com.amaze.filemanager.filesystem
 
-import com.amaze.filemanager.file_operations.filesystem.OpenMode
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode
 import com.amaze.filemanager.filesystem.ssh.test.MockSshConnectionPools
 import org.junit.Test
 
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/cloud/CloudUtilTest.kt b/app/src/test/java/com/amaze/filemanager/filesystem/cloud/CloudUtilTest.kt
index f8ae6f094..1550a799c 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/cloud/CloudUtilTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/cloud/CloudUtilTest.kt
@@ -21,8 +21,8 @@
 package com.amaze.filemanager.filesystem.cloud
 
 import com.amaze.filemanager.database.CloudHandler
-import com.amaze.filemanager.file_operations.filesystem.OpenMode
-import com.amaze.filemanager.file_operations.filesystem.OpenMode.*
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode.*
 import com.amaze.filemanager.filesystem.RandomPathGenerator
 import org.junit.Assert
 import org.junit.Test
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/compressed/CompressedHelperTest.java b/app/src/test/java/com/amaze/filemanager/filesystem/compressed/CompressedHelperTest.java
index 4d378c83d..e0a8b5a22 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/compressed/CompressedHelperTest.java
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/compressed/CompressedHelperTest.java
@@ -35,7 +35,7 @@ import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
 
 import com.amaze.filemanager.asynchronous.management.ServiceWatcherUtil;
-import com.amaze.filemanager.file_operations.utils.UpdatePosition;
+import com.amaze.filemanager.fileoperations.utils.UpdatePosition;
 import com.amaze.filemanager.filesystem.compressed.extractcontents.Extractor;
 import com.amaze.filemanager.filesystem.compressed.extractcontents.helpers.RarExtractor;
 import com.amaze.filemanager.filesystem.compressed.extractcontents.helpers.SevenZipExtractor;
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/AbstractArchiveExtractorTest.kt b/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/AbstractArchiveExtractorTest.kt
index 4af7d0b3e..c43a88687 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/AbstractArchiveExtractorTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/AbstractArchiveExtractorTest.kt
@@ -24,7 +24,7 @@ import android.content.Context
 import android.os.Environment
 import androidx.test.core.app.ApplicationProvider
 import com.amaze.filemanager.asynchronous.management.ServiceWatcherUtil
-import com.amaze.filemanager.file_operations.utils.UpdatePosition
+import com.amaze.filemanager.fileoperations.utils.UpdatePosition
 import org.junit.Assert.assertEquals
 import org.junit.Assert.assertTrue
 import org.junit.Assert.fail
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/AbstractCompressedFileExtractorTest.kt b/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/AbstractCompressedFileExtractorTest.kt
index 008e52500..077c1050d 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/AbstractCompressedFileExtractorTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/AbstractCompressedFileExtractorTest.kt
@@ -24,7 +24,7 @@ import android.content.Context
 import android.os.Environment
 import androidx.test.core.app.ApplicationProvider
 import com.amaze.filemanager.asynchronous.management.ServiceWatcherUtil
-import com.amaze.filemanager.file_operations.utils.UpdatePosition
+import com.amaze.filemanager.fileoperations.utils.UpdatePosition
 import org.junit.Assert.assertEquals
 import org.junit.Assert.assertTrue
 import java.io.File
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/AbstractExtractorPasswordProtectedArchivesTest.kt b/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/AbstractExtractorPasswordProtectedArchivesTest.kt
index d812f1a95..a5d8a654c 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/AbstractExtractorPasswordProtectedArchivesTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/AbstractExtractorPasswordProtectedArchivesTest.kt
@@ -21,7 +21,7 @@
 package com.amaze.filemanager.filesystem.compressed.extractcontents
 
 import android.os.Environment
-import com.amaze.filemanager.file_operations.filesystem.compressed.ArchivePasswordCache
+import com.amaze.filemanager.fileoperations.filesystem.compressed.ArchivePasswordCache
 import org.junit.Assert
 import org.junit.Test
 import java.io.File
@@ -93,10 +93,12 @@ abstract class AbstractExtractorPasswordProtectedArchivesTest : AbstractArchiveE
 
     override val archiveFile: File
         get() = File(
-            Environment.getExternalStorageDirectory(), "test-archive-encrypted.$archiveType"
+            Environment.getExternalStorageDirectory(),
+            "test-archive-encrypted.$archiveType"
         )
 
     protected abstract fun expectedRootExceptionClass(): Array<Class<*>>
+
     @Throws(IOException::class)
     protected fun assertExceptionIsExpected(e: IOException) {
         for (c in expectedRootExceptionClass()) {
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/AbstractExtractorTest.kt b/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/AbstractExtractorTest.kt
index db53cb0c7..fd129da30 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/AbstractExtractorTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/AbstractExtractorTest.kt
@@ -28,8 +28,8 @@ import android.os.Environment
 import androidx.test.core.app.ApplicationProvider
 import androidx.test.ext.junit.runners.AndroidJUnit4
 import com.amaze.filemanager.asynchronous.management.ServiceWatcherUtil
-import com.amaze.filemanager.file_operations.filesystem.compressed.ArchivePasswordCache
-import com.amaze.filemanager.file_operations.utils.UpdatePosition
+import com.amaze.filemanager.fileoperations.filesystem.compressed.ArchivePasswordCache
+import com.amaze.filemanager.fileoperations.utils.UpdatePosition
 import com.amaze.filemanager.shadows.ShadowMultiDex
 import com.amaze.filemanager.test.randomBytes
 import org.junit.*
@@ -43,7 +43,6 @@ import java.nio.file.Files
 import java.nio.file.Path
 import java.nio.file.Paths
 import java.util.*
-import kotlin.random.Random
 
 @RunWith(AndroidJUnit4::class)
 @Config(shadows = [ShadowMultiDex::class], sdk = [JELLY_BEAN, KITKAT, P])
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/ListPasswordProtected7ZipTest.kt b/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/ListPasswordProtected7ZipTest.kt
index 47152786b..3b987f938 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/ListPasswordProtected7ZipTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/ListPasswordProtected7ZipTest.kt
@@ -26,6 +26,7 @@ import java.io.File
 class ListPasswordProtected7ZipTest : PasswordProtected7ZipTest() {
 
     override val archiveFile: File = File(
-        Environment.getExternalStorageDirectory(), "test-archive-encrypted-list.$archiveType"
+        Environment.getExternalStorageDirectory(),
+        "test-archive-encrypted-list.$archiveType"
     )
 }
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/ListPasswordProtectedRarTest.kt b/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/ListPasswordProtectedRarTest.kt
index 59f10b558..12d9ff3e0 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/ListPasswordProtectedRarTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/ListPasswordProtectedRarTest.kt
@@ -26,6 +26,7 @@ import java.io.File
 class ListPasswordProtectedRarTest : PasswordProtectedRarTest() {
 
     override val archiveFile: File = File(
-        Environment.getExternalStorageDirectory(), "test-archive-encrypted-list.$archiveType"
+        Environment.getExternalStorageDirectory(),
+        "test-archive-encrypted-list.$archiveType"
     )
 }
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/PasswordProtectedZipTest.kt b/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/PasswordProtectedZipTest.kt
index c2a072a10..29329d6e8 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/PasswordProtectedZipTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/PasswordProtectedZipTest.kt
@@ -27,7 +27,9 @@ class PasswordProtectedZipTest : AbstractExtractorPasswordProtectedArchivesTest(
 
     override fun extractorClass(): Class<out Extractor?> = ZipExtractor::class.java
 
-    override fun expectedRootExceptionClass(): Array<Class<*>> = arrayOf(PasswordRequiredException::class.java)
+    override fun expectedRootExceptionClass(): Array<Class<*>> = arrayOf(
+        PasswordRequiredException::class.java
+    )
 
     override val archiveType: String = "zip"
 }
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/SevenZipWithoutTimestampTest.kt b/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/SevenZipWithoutTimestampTest.kt
index e9f0921f5..1261fe45b 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/SevenZipWithoutTimestampTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/compressed/extractcontents/SevenZipWithoutTimestampTest.kt
@@ -30,7 +30,10 @@ import java.io.File
 class SevenZipWithoutTimestampTest : SevenZipExtractorTest() {
 
     override val archiveFile: File
-        get() = File(Environment.getExternalStorageDirectory(), "test-archive-no-timestamp.$archiveType")
+        get() = File(
+            Environment.getExternalStorageDirectory(),
+            "test-archive-no-timestamp.$archiveType"
+        )
 
     /**
      * As timestamp is only the time we extract the file, we just check it's created recently.
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/files/FileListSorterTest.java b/app/src/test/java/com/amaze/filemanager/filesystem/files/FileListSorterTest.java
index 17826d05a..79cc0edc1 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/files/FileListSorterTest.java
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/files/FileListSorterTest.java
@@ -33,7 +33,7 @@ import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
 
 import com.amaze.filemanager.adapters.data.LayoutElementParcelable;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.shadows.ShadowMultiDex;
 
 import androidx.test.core.app.ApplicationProvider;
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/files/FileUtilsTest.kt b/app/src/test/java/com/amaze/filemanager/filesystem/files/FileUtilsTest.kt
index c9da970e2..66061b264 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/files/FileUtilsTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/files/FileUtilsTest.kt
@@ -367,7 +367,6 @@ class FileUtilsTest {
      */
     @Test
     fun testParseStringForHybridFileParcelable() {
-
         val systemTz = TimeZone.getDefault()
         TimeZone.setDefault(TimeZone.getTimeZone("UTC"))
 
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/root/ListFilesCommandTest.kt b/app/src/test/java/com/amaze/filemanager/filesystem/root/ListFilesCommandTest.kt
index 7116f86ea..36ad4b111 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/root/ListFilesCommandTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/root/ListFilesCommandTest.kt
@@ -27,11 +27,11 @@ import android.os.Build.VERSION_CODES.P
 import androidx.preference.PreferenceManager
 import androidx.test.core.app.ApplicationProvider
 import androidx.test.ext.junit.runners.AndroidJUnit4
-import com.amaze.filemanager.file_operations.filesystem.OpenMode
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode
 import com.amaze.filemanager.filesystem.HybridFileParcelable
 import com.amaze.filemanager.shadows.ShadowMultiDex
 import com.amaze.filemanager.test.ShadowNativeOperations
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants
 import io.mockk.every
 import io.mockk.mockkObject
 import org.junit.Assert.assertEquals
@@ -44,17 +44,17 @@ import org.mockito.kotlin.argumentCaptor
 import org.robolectric.annotation.Config
 import java.io.InputStreamReader
 
-@RunWith(AndroidJUnit4::class)
-@Config(
-    shadows = [ShadowMultiDex::class, ShadowNativeOperations::class],
-    sdk = [JELLY_BEAN, KITKAT, P]
-)
 /**
  * Unit test for [ListFilesCommand].
  *
  * stat and ls outputs are captured from busybox or toybox, and used as fixed outputs from
  * mocked object to ensure command output.
  */
+@RunWith(AndroidJUnit4::class)
+@Config(
+    shadows = [ShadowMultiDex::class, ShadowNativeOperations::class],
+    sdk = [JELLY_BEAN, KITKAT, P]
+)
 class ListFilesCommandTest {
 
     private val sharedPreferences: SharedPreferences =
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/root/ListFilesCommandTest2.kt b/app/src/test/java/com/amaze/filemanager/filesystem/root/ListFilesCommandTest2.kt
index f9ef48d42..5755d9d01 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/root/ListFilesCommandTest2.kt
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/root/ListFilesCommandTest2.kt
@@ -28,12 +28,12 @@ import androidx.preference.PreferenceManager
 import androidx.test.core.app.ApplicationProvider
 import androidx.test.ext.junit.runners.AndroidJUnit4
 import com.amaze.filemanager.exceptions.ShellCommandInvalidException
-import com.amaze.filemanager.file_operations.filesystem.OpenMode
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode
 import com.amaze.filemanager.filesystem.HybridFileParcelable
 import com.amaze.filemanager.shadows.ShadowMultiDex
 import com.amaze.filemanager.test.ShadowNativeOperations
 import com.amaze.filemanager.test.TestUtils
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants
 import org.junit.After
 import org.junit.Assert.assertEquals
 import org.junit.Before
@@ -47,11 +47,6 @@ import org.mockito.kotlin.argumentCaptor
 import org.robolectric.annotation.Config
 import java.io.InputStreamReader
 
-@RunWith(AndroidJUnit4::class)
-@Config(
-    shadows = [ShadowMultiDex::class, ShadowNativeOperations::class],
-    sdk = [JELLY_BEAN, KITKAT, P]
-)
 /**
  * Unit test for [ListFilesCommand]. This is to test the case when stat command fails.
  *
@@ -60,6 +55,11 @@ import java.io.InputStreamReader
  *
  * FIXME: add toybox outputs, just to be sure?
  */
+@RunWith(AndroidJUnit4::class)
+@Config(
+    shadows = [ShadowMultiDex::class, ShadowNativeOperations::class],
+    sdk = [JELLY_BEAN, KITKAT, P]
+)
 class ListFilesCommandTest2 {
 
     val sharedPreferences: SharedPreferences =
@@ -85,7 +85,9 @@ class ListFilesCommandTest2 {
         ).thenCallRealMethod()
         `when`(
             mockCommand.executeRootCommand(
-                anyString(), anyBoolean(), anyBoolean()
+                anyString(),
+                anyBoolean(),
+                anyBoolean()
             )
         ).thenCallRealMethod()
         `when`(mockCommand.runShellCommandToList("ls -l \"/bin\"")).thenReturn(lsLines)
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/smb/SmbHybridFileTest.kt b/app/src/test/java/com/amaze/filemanager/filesystem/smb/SmbHybridFileTest.kt
index 16b24fd42..e21fbd353 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/smb/SmbHybridFileTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/smb/SmbHybridFileTest.kt
@@ -26,7 +26,7 @@ import android.os.Build.VERSION_CODES.KITKAT
 import android.os.Build.VERSION_CODES.P
 import androidx.test.core.app.ApplicationProvider
 import androidx.test.ext.junit.runners.AndroidJUnit4
-import com.amaze.filemanager.file_operations.filesystem.OpenMode
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode
 import com.amaze.filemanager.filesystem.HybridFile
 import com.amaze.filemanager.shadows.ShadowMultiDex
 import com.amaze.filemanager.shadows.ShadowSmbUtil
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/ssh/ListFilesOnSshdTest.java b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/ListFilesOnSshdTest.java
index 2179e8223..db4208ed5 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/ssh/ListFilesOnSshdTest.java
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/ListFilesOnSshdTest.java
@@ -36,7 +36,7 @@ import java.util.List;
 
 import org.junit.Test;
 
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.HybridFile;
 
 import android.os.Environment;
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshConnectionPoolTest.java b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshConnectionPoolTest.java
index af554c727..487b5173b 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshConnectionPoolTest.java
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshConnectionPoolTest.java
@@ -37,20 +37,10 @@ import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.test.ext.junit.runners.AndroidJUnit4;
-
-import com.amaze.filemanager.filesystem.ssh.test.TestUtils;
-import com.amaze.filemanager.shadows.ShadowMultiDex;
-import com.amaze.filemanager.test.ShadowPasswordUtil;
-import com.amaze.filemanager.utils.Utils;
-
-import net.schmizz.sshj.SSHClient;
-import net.schmizz.sshj.common.KeyType;
-import net.schmizz.sshj.common.SecurityUtils;
-import net.schmizz.sshj.userauth.UserAuthException;
-import net.schmizz.sshj.userauth.keyprovider.KeyProvider;
+import java.io.IOException;
+import java.security.KeyPair;
+import java.security.PrivateKey;
+import java.security.PublicKey;
 
 import org.junit.After;
 import org.junit.BeforeClass;
@@ -59,14 +49,23 @@ import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowSQLiteConnection;
 
-import java.io.IOException;
-import java.security.KeyPair;
-import java.security.PrivateKey;
-import java.security.PublicKey;
+import com.amaze.filemanager.filesystem.ssh.test.TestUtils;
+import com.amaze.filemanager.shadows.ShadowMultiDex;
+import com.amaze.filemanager.test.ShadowPasswordUtil;
+import com.amaze.filemanager.utils.Utils;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 
 import io.reactivex.android.plugins.RxAndroidPlugins;
 import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.schedulers.Schedulers;
+import net.schmizz.sshj.SSHClient;
+import net.schmizz.sshj.common.KeyType;
+import net.schmizz.sshj.common.SecurityUtils;
+import net.schmizz.sshj.userauth.UserAuthException;
+import net.schmizz.sshj.userauth.keyprovider.KeyProvider;
 
 @RunWith(AndroidJUnit4.class)
 @Config(
@@ -211,24 +210,24 @@ public class SshConnectionPoolTest {
     SSHClient mock = createSshServer("testuser", validPassword);
     saveSshConnectionSettings(hostKeyPair, "testuser", validPassword, null, "/home/testuser");
     assertNotNull(
-            SshConnectionPool.INSTANCE.getConnection(
-                    SshClientUtils.encryptSshPathAsNecessary(
-                            "ssh://testuser:testpassword@127.0.0.1:22222/home/testuser")));
+        SshConnectionPool.INSTANCE.getConnection(
+            SshClientUtils.encryptSshPathAsNecessary(
+                "ssh://testuser:testpassword@127.0.0.1:22222/home/testuser")));
     assertNotNull(
-            SshConnectionPool.INSTANCE.getConnection(
-                    SshClientUtils.encryptSshPathAsNecessary(
-                            "ssh://testuser:testpassword@127.0.0.1:22222")));
+        SshConnectionPool.INSTANCE.getConnection(
+            SshClientUtils.encryptSshPathAsNecessary(
+                "ssh://testuser:testpassword@127.0.0.1:22222")));
     assertNull(
-            SshConnectionPool.INSTANCE.getConnection(
-                    SshClientUtils.encryptSshPathAsNecessary(
-                            "ssh://invaliduser:invalidpassword@127.0.0.1:22222/home/testuser")));
+        SshConnectionPool.INSTANCE.getConnection(
+            SshClientUtils.encryptSshPathAsNecessary(
+                "ssh://invaliduser:invalidpassword@127.0.0.1:22222/home/testuser")));
     assertNull(
-            SshConnectionPool.INSTANCE.getConnection(
-                    SshClientUtils.encryptSshPathAsNecessary(
-                            "ssh://invaliduser:invalidpassword@127.0.0.1:22222")));
+        SshConnectionPool.INSTANCE.getConnection(
+            SshClientUtils.encryptSshPathAsNecessary(
+                "ssh://invaliduser:invalidpassword@127.0.0.1:22222")));
 
     verify(mock, atLeastOnce())
-            .addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
+        .addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
     verify(mock, atLeastOnce()).setConnectTimeout(SshConnectionPool.SSH_CONNECT_TIMEOUT);
     verify(mock, atLeastOnce()).connect("127.0.0.1", 22222);
     verify(mock).authPassword("testuser", "testpassword");
@@ -256,14 +255,18 @@ public class SshConnectionPoolTest {
   @Test
   public void testGetConnectionWithUrlAndKeyAuthHavingSubpath() throws IOException {
     SSHClient mock = createSshServer("testuser", null);
-    saveSshConnectionSettings(hostKeyPair, "testuser", null, userKeyPair.getPrivate(), "/home/testuser");
-    assertNotNull(SshConnectionPool.INSTANCE.getConnection("ssh://testuser@127.0.0.1:22222/home/testuser"));
+    saveSshConnectionSettings(
+        hostKeyPair, "testuser", null, userKeyPair.getPrivate(), "/home/testuser");
+    assertNotNull(
+        SshConnectionPool.INSTANCE.getConnection("ssh://testuser@127.0.0.1:22222/home/testuser"));
     assertNotNull(SshConnectionPool.INSTANCE.getConnection("ssh://testuser@127.0.0.1:22222"));
-    assertNull(SshConnectionPool.INSTANCE.getConnection("ssh://invaliduser@127.0.0.1:22222/home/testuser"));
+    assertNull(
+        SshConnectionPool.INSTANCE.getConnection(
+            "ssh://invaliduser@127.0.0.1:22222/home/testuser"));
     assertNull(SshConnectionPool.INSTANCE.getConnection("ssh://invaliduser@127.0.0.1:22222"));
 
     verify(mock, atLeastOnce())
-            .addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
+        .addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
     verify(mock, atLeastOnce()).setConnectTimeout(SshConnectionPool.SSH_CONNECT_TIMEOUT);
     verify(mock, atLeastOnce()).connect("127.0.0.1", 22222);
 
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshHybridFileTest.kt b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshHybridFileTest.kt
index 7573849c5..68bb7cf91 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshHybridFileTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshHybridFileTest.kt
@@ -26,7 +26,7 @@ import android.os.Build.VERSION_CODES.KITKAT
 import android.os.Build.VERSION_CODES.P
 import androidx.test.core.app.ApplicationProvider
 import androidx.test.ext.junit.runners.AndroidJUnit4
-import com.amaze.filemanager.file_operations.filesystem.OpenMode
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode
 import com.amaze.filemanager.filesystem.HybridFile
 import com.amaze.filemanager.filesystem.ssh.test.MockSshConnectionPools
 import com.amaze.filemanager.shadows.ShadowMultiDex
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/ssh/test/MockSshConnectionPools.kt b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/test/MockSshConnectionPools.kt
index b9e3e0492..82d0c07bc 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/ssh/test/MockSshConnectionPools.kt
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/test/MockSshConnectionPools.kt
@@ -47,7 +47,13 @@ object MockSshConnectionPools {
 
     // Yes, idiot hardcoded paths. Shall expand as more test cases arrive.
     private fun doPrepareSSHClientInternal(canDelete: Boolean) {
-        TestUtils.saveSshConnectionSettings(hostKeyPair, "user", "password", userKeyPair.private, null)
+        TestUtils.saveSshConnectionSettings(
+            hostKeyPair,
+            "user",
+            "password",
+            userKeyPair.private,
+            null
+        )
 
         val fileAttributes = mock(FileAttributes::class.java).apply {
             `when`(type).thenReturn(FileMode.Type.DIRECTORY)
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/usb/SingletonUsbOtgTest.java b/app/src/test/java/com/amaze/filemanager/filesystem/usb/SingletonUsbOtgTest.java
index ecafc7d05..9094fb302 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/usb/SingletonUsbOtgTest.java
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/usb/SingletonUsbOtgTest.java
@@ -32,7 +32,7 @@ import org.robolectric.Robolectric;
 import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 
-import com.amaze.filemanager.file_operations.filesystem.usb.SingletonUsbOtg;
+import com.amaze.filemanager.fileoperations.filesystem.usb.SingletonUsbOtg;
 import com.amaze.filemanager.shadows.ShadowMultiDex;
 import com.amaze.filemanager.ui.activities.MainActivity;
 
diff --git a/app/src/test/java/com/amaze/filemanager/shadows/ShadowContentResolver.kt b/app/src/test/java/com/amaze/filemanager/shadows/ShadowContentResolver.kt
new file mode 100644
index 000000000..867780287
--- /dev/null
+++ b/app/src/test/java/com/amaze/filemanager/shadows/ShadowContentResolver.kt
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.shadows
+
+import android.content.ContentResolver
+import android.net.Uri
+import org.robolectric.annotation.Implementation
+import org.robolectric.annotation.Implements
+import org.robolectric.shadows.ShadowContentResolver
+import java.io.OutputStream
+
+/**
+ * [ShadowContentResolver] implementation to include
+ * [ContentResolver.openOutputStream] with Uri and open mode arguments.
+ *
+ * @see ContentResolver.openOutputStream(uri, String)
+ */
+@Implements(ContentResolver::class)
+class ShadowContentResolver : ShadowContentResolver() {
+
+    /**
+     * Implements [ContentResolver.openOutputStream] with open mode parameter.
+     *
+     * Simply delegate to one without open mode.
+     */
+    @Implementation
+    fun openOutputStream(uri: Uri, mode: String): OutputStream? = super.openOutputStream(uri)
+}
diff --git a/app/src/test/java/com/amaze/filemanager/shadows/ShadowSmbUtil.kt b/app/src/test/java/com/amaze/filemanager/shadows/ShadowSmbUtil.kt
index 9893bd7aa..cdc2551c5 100644
--- a/app/src/test/java/com/amaze/filemanager/shadows/ShadowSmbUtil.kt
+++ b/app/src/test/java/com/amaze/filemanager/shadows/ShadowSmbUtil.kt
@@ -111,7 +111,8 @@ class ShadowSmbUtil {
         @JvmStatic @Implementation
         fun getSmbEncryptedPath(context: Context, path: String): String {
             return Shadow.directlyOn(
-                SmbUtil::class.java, "getSmbEncryptedPath",
+                SmbUtil::class.java,
+                "getSmbEncryptedPath",
                 ReflectionHelpers.ClassParameter(Context::class.java, context),
                 ReflectionHelpers.ClassParameter(String::class.java, path)
             )
@@ -123,7 +124,8 @@ class ShadowSmbUtil {
         @JvmStatic @Implementation
         fun getSmbDecryptedPath(context: Context, path: String): String {
             return Shadow.directlyOn(
-                SmbUtil::class.java, "getSmbDecryptedPath",
+                SmbUtil::class.java,
+                "getSmbDecryptedPath",
                 ReflectionHelpers.ClassParameter(Context::class.java, context),
                 ReflectionHelpers.ClassParameter(String::class.java, path)
             )
@@ -135,7 +137,8 @@ class ShadowSmbUtil {
         @JvmStatic @Implementation
         fun checkFolder(path: String): Int {
             return Shadow.directlyOn(
-                SmbUtil::class.java, "checkFolder",
+                SmbUtil::class.java,
+                "checkFolder",
                 ReflectionHelpers.ClassParameter(String::class.java, path)
             )
         }
@@ -147,7 +150,6 @@ class ShadowSmbUtil {
          */
         @JvmStatic @Implementation
         fun create(path: String): SmbFile {
-
             return when (path) {
                 PATH_CANNOT_DELETE_FILE -> mockDeleteAccessDenied!!
                 PATH_CANNOT_MOVE_FILE -> mockDeleteDifferentNetwork!!
diff --git a/app/src/test/java/com/amaze/filemanager/ssh/SshClientUtilTest.kt b/app/src/test/java/com/amaze/filemanager/ssh/SshClientUtilTest.kt
index d9018b936..bfd4aa83f 100644
--- a/app/src/test/java/com/amaze/filemanager/ssh/SshClientUtilTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/ssh/SshClientUtilTest.kt
@@ -46,7 +46,8 @@ class SshClientUtilTest {
             SshClientUtils.extractRemotePathFrom("ssh://user:password@127.0.0.1:22")
         )
         Assert.assertEquals(
-            "/", SshClientUtils.extractRemotePathFrom("ssh://root:a8/875dbc-==@127.0.0.1:9899")
+            "/",
+            SshClientUtils.extractRemotePathFrom("ssh://root:a8/875dbc-==@127.0.0.1:9899")
         )
         Assert.assertEquals(
             "/root/.config",
diff --git a/app/src/test/java/com/amaze/filemanager/test/ShadowNativeOperations.java b/app/src/test/java/com/amaze/filemanager/test/ShadowNativeOperations.java
index ebec6c41d..a849f10ee 100644
--- a/app/src/test/java/com/amaze/filemanager/test/ShadowNativeOperations.java
+++ b/app/src/test/java/com/amaze/filemanager/test/ShadowNativeOperations.java
@@ -23,7 +23,7 @@ package com.amaze.filemanager.test;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
-import com.amaze.filemanager.file_operations.filesystem.root.NativeOperations;
+import com.amaze.filemanager.fileoperations.filesystem.root.NativeOperations;
 
 import androidx.annotation.Nullable;
 
diff --git a/app/src/test/java/com/amaze/filemanager/test/TestUtils.kt b/app/src/test/java/com/amaze/filemanager/test/TestUtils.kt
index 029cb2be7..19ad9b841 100644
--- a/app/src/test/java/com/amaze/filemanager/test/TestUtils.kt
+++ b/app/src/test/java/com/amaze/filemanager/test/TestUtils.kt
@@ -131,7 +131,6 @@ object TestUtils {
      */
     @JvmStatic
     fun <T> replaceObjectInstance(clazz: Class<T>, newInstance: T?): T {
-
         if (!clazz.declaredFields.any {
             it.name == "INSTANCE" && it.type == clazz && Modifier.isStatic(it.modifiers)
         }
diff --git a/app/src/test/java/com/amaze/filemanager/ui/dialogs/AbstractEncryptDialogTests.kt b/app/src/test/java/com/amaze/filemanager/ui/dialogs/AbstractEncryptDialogTests.kt
index 032c93e90..99dd8f110 100644
--- a/app/src/test/java/com/amaze/filemanager/ui/dialogs/AbstractEncryptDialogTests.kt
+++ b/app/src/test/java/com/amaze/filemanager/ui/dialogs/AbstractEncryptDialogTests.kt
@@ -1,3 +1,23 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.ui.dialogs
 
 import android.os.Build.VERSION.SDK_INT
diff --git a/app/src/test/java/com/amaze/filemanager/ui/dialogs/DecryptFingerprintDialogTest.kt b/app/src/test/java/com/amaze/filemanager/ui/dialogs/DecryptFingerprintDialogTest.kt
index e869e893e..22309c511 100644
--- a/app/src/test/java/com/amaze/filemanager/ui/dialogs/DecryptFingerprintDialogTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/ui/dialogs/DecryptFingerprintDialogTest.kt
@@ -1,3 +1,23 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.ui.dialogs
 
 import android.Manifest.permission.USE_FINGERPRINT
@@ -12,7 +32,7 @@ import com.amaze.filemanager.application.AppConfig
 import com.amaze.filemanager.asynchronous.services.DecryptService.TAG_DECRYPT_PATH
 import com.amaze.filemanager.asynchronous.services.DecryptService.TAG_OPEN_MODE
 import com.amaze.filemanager.asynchronous.services.DecryptService.TAG_SOURCE
-import com.amaze.filemanager.file_operations.filesystem.OpenMode
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode
 import com.amaze.filemanager.filesystem.HybridFileParcelable
 import com.amaze.filemanager.filesystem.RandomPathGenerator
 import com.amaze.filemanager.filesystem.files.CryptUtil.CRYPT_EXTENSION
@@ -54,7 +74,8 @@ class DecryptFingerprintDialogTest : AbstractEncryptDialogTests() {
         file = File(
             Environment.getExternalStorageDirectory(),
             RandomPathGenerator.generateRandomPath(
-                randomizer, 16
+                randomizer,
+                16
             ) + CRYPT_EXTENSION
         )
         initMockSecretKeygen()
diff --git a/app/src/test/java/com/amaze/filemanager/ui/dialogs/EncryptAuthenticateDialogTest.kt b/app/src/test/java/com/amaze/filemanager/ui/dialogs/EncryptAuthenticateDialogTest.kt
index 2dc385df2..dfd3dea3a 100644
--- a/app/src/test/java/com/amaze/filemanager/ui/dialogs/EncryptAuthenticateDialogTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/ui/dialogs/EncryptAuthenticateDialogTest.kt
@@ -1,3 +1,23 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.ui.dialogs
 
 import android.content.Intent
@@ -16,7 +36,7 @@ import com.amaze.filemanager.asynchronous.services.EncryptService.TAG_AESCRYPT
 import com.amaze.filemanager.asynchronous.services.EncryptService.TAG_ENCRYPT_TARGET
 import com.amaze.filemanager.asynchronous.services.EncryptService.TAG_OPEN_MODE
 import com.amaze.filemanager.asynchronous.services.EncryptService.TAG_SOURCE
-import com.amaze.filemanager.file_operations.filesystem.OpenMode
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode
 import com.amaze.filemanager.filesystem.HybridFileParcelable
 import com.amaze.filemanager.filesystem.RandomPathGenerator
 import com.amaze.filemanager.filesystem.files.CryptUtil.AESCRYPT_EXTENSION
@@ -24,7 +44,7 @@ import com.amaze.filemanager.filesystem.files.CryptUtil.CRYPT_EXTENSION
 import com.amaze.filemanager.filesystem.files.EncryptDecryptUtils
 import com.amaze.filemanager.test.getString
 import com.amaze.filemanager.ui.activities.MainActivity
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants
 import com.amaze.filemanager.ui.views.WarnableTextInputLayout
 import com.google.android.material.textfield.TextInputEditText
 import org.junit.Assert.assertEquals
@@ -64,7 +84,8 @@ class EncryptAuthenticateDialogTest : AbstractEncryptDialogTests() {
         file = File(
             Environment.getExternalStorageDirectory(),
             RandomPathGenerator.generateRandomPath(
-                randomizer, 16
+                randomizer,
+                16
             )
         )
     }
diff --git a/app/src/test/java/com/amaze/filemanager/ui/dialogs/EncryptWarningDialogTest.kt b/app/src/test/java/com/amaze/filemanager/ui/dialogs/EncryptWarningDialogTest.kt
index 91439b864..81f18d13a 100644
--- a/app/src/test/java/com/amaze/filemanager/ui/dialogs/EncryptWarningDialogTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/ui/dialogs/EncryptWarningDialogTest.kt
@@ -1,3 +1,23 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.ui.dialogs
 
 import androidx.preference.PreferenceManager
@@ -6,7 +26,7 @@ import com.afollestad.materialdialogs.MaterialDialog
 import com.amaze.filemanager.R
 import com.amaze.filemanager.application.AppConfig
 import com.amaze.filemanager.test.getString
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants
 import org.junit.Assert.assertEquals
 import org.junit.Assert.assertFalse
 import org.junit.Assert.assertTrue
diff --git a/app/src/test/java/com/amaze/filemanager/ui/dialogs/EncryptWithPresetPasswordSaveAsDialogTest.kt b/app/src/test/java/com/amaze/filemanager/ui/dialogs/EncryptWithPresetPasswordSaveAsDialogTest.kt
index e2bae84c1..c0c5b02a5 100644
--- a/app/src/test/java/com/amaze/filemanager/ui/dialogs/EncryptWithPresetPasswordSaveAsDialogTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/ui/dialogs/EncryptWithPresetPasswordSaveAsDialogTest.kt
@@ -1,3 +1,23 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
 package com.amaze.filemanager.ui.dialogs
 
 import android.content.Intent
@@ -22,11 +42,11 @@ import com.amaze.filemanager.filesystem.files.CryptUtil.CRYPT_EXTENSION
 import com.amaze.filemanager.filesystem.files.EncryptDecryptUtils
 import com.amaze.filemanager.test.getString
 import com.amaze.filemanager.ui.activities.MainActivity
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.ENCRYPT_PASSWORD_FINGERPRINT
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.ENCRYPT_PASSWORD_MASTER
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_CRYPT_FINGERPRINT
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_CRYPT_FINGERPRINT_DEFAULT
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.ENCRYPT_PASSWORD_FINGERPRINT
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.ENCRYPT_PASSWORD_MASTER
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_CRYPT_FINGERPRINT
+import com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_CRYPT_FINGERPRINT_DEFAULT
 import com.amaze.filemanager.ui.views.WarnableTextInputLayout
 import com.google.android.material.textfield.TextInputEditText
 import org.junit.After
@@ -60,7 +80,8 @@ class EncryptWithPresetPasswordSaveAsDialogTest : AbstractEncryptDialogTests() {
         file = File(
             Environment.getExternalStorageDirectory(),
             RandomPathGenerator.generateRandomPath(
-                randomizer, 16
+                randomizer,
+                16
             )
         )
     }
@@ -318,7 +339,9 @@ class EncryptWithPresetPasswordSaveAsDialogTest : AbstractEncryptDialogTests() {
                             R.id.til_encrypt_save_as
                         )
                         checkboxUseAze = findViewById<AppCompatCheckBox>(R.id.checkbox_use_aze)
-                        textViewCryptInfo = findViewById<AppCompatTextView>(R.id.text_view_crypt_info)
+                        textViewCryptInfo = findViewById<AppCompatTextView>(
+                            R.id.text_view_crypt_info
+                        )
                         okButton = getActionButton(DialogAction.POSITIVE)
                         testContent.invoke(it, intent, activity)
                     }
diff --git a/app/src/test/java/com/amaze/filemanager/utils/AESCryptTest.kt b/app/src/test/java/com/amaze/filemanager/utils/AESCryptTest.kt
index b0e4d683c..662598e6e 100644
--- a/app/src/test/java/com/amaze/filemanager/utils/AESCryptTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/utils/AESCryptTest.kt
@@ -47,7 +47,8 @@ class AESCryptTest {
         val out = ByteArrayOutputStream()
         var crypter = AESCrypt("12345678")
         crypter.encrypt(
-            `in` = ByteArrayInputStream(contents), out = out,
+            `in` = ByteArrayInputStream(contents),
+            out = out,
             progressHandler = ProgressHandler()
         )
         out.close()
@@ -69,7 +70,8 @@ class AESCryptTest {
         val out = ByteArrayOutputStream()
         var crypter = AESCrypt("password")
         crypter.encrypt(
-            `in` = ByteArrayInputStream(contents), out = out,
+            `in` = ByteArrayInputStream(contents),
+            out = out,
             progressHandler = ProgressHandler()
         )
         out.close()
diff --git a/app/src/test/java/com/amaze/filemanager/utils/CryptUtilTest.kt b/app/src/test/java/com/amaze/filemanager/utils/CryptUtilTest.kt
index 612cb6a1d..e9c376a57 100644
--- a/app/src/test/java/com/amaze/filemanager/utils/CryptUtilTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/utils/CryptUtilTest.kt
@@ -84,7 +84,11 @@ class CryptUtilTest {
         performFolderTest(useAescrypt = false, targetExtension = "aze")
     }
 
-    private fun performTest(useAescrypt: Boolean, password: String? = null, targetExtension: String) {
+    private fun performTest(
+        useAescrypt: Boolean,
+        password: String? = null,
+        targetExtension: String
+    ) {
         val source = randomizer.nextBytes(117)
         val sourceFile = File(Environment.getExternalStorageDirectory(), "test.bin")
         ByteArrayInputStream(source).copyTo(FileOutputStream(sourceFile))
@@ -97,7 +101,10 @@ class CryptUtilTest {
             useAescrypt,
             password
         )
-        val targetFile = File(Environment.getExternalStorageDirectory(), "test.bin.$targetExtension")
+        val targetFile = File(
+            Environment.getExternalStorageDirectory(),
+            "test.bin.$targetExtension"
+        )
         assertTrue(targetFile.length() > source.size)
         sourceFile.delete()
         CryptUtil(
@@ -116,7 +123,11 @@ class CryptUtilTest {
         }
     }
 
-    private fun performFolderTest(useAescrypt: Boolean, password: String? = null, targetExtension: String) {
+    private fun performFolderTest(
+        useAescrypt: Boolean,
+        password: String? = null,
+        targetExtension: String
+    ) {
         val filesSize = randomizer.nextInt(10, 20)
         val sourceData = Array(filesSize) {
             randomizer.nextBytes(117)
@@ -138,7 +149,10 @@ class CryptUtilTest {
             useAescrypt,
             password
         )
-        val targetFolder = File(Environment.getExternalStorageDirectory(), "test.$targetExtension")
+        val targetFolder = File(
+            Environment.getExternalStorageDirectory(),
+            "test.$targetExtension"
+        )
         assertTrue(targetFolder.isDirectory)
         assertEquals(sourceData.size, targetFolder.listFiles()?.size)
         sourceFolder.deleteRecursively()
@@ -160,8 +174,15 @@ class CryptUtilTest {
             }
             this.listFiles()?.forEach { file: File? ->
                 file?.run {
-                    val index = file.name.substring("test".length, file.name.indexOf('.')).toInt()
-                    assertArrayEquals("Comparison broken at ${file.absolutePath}", sourceData[index], file.readBytes())
+                    val index = file.name.substring(
+                        "test".length,
+                        file.name.indexOf('.')
+                    ).toInt()
+                    assertArrayEquals(
+                        "Comparison broken at ${file.absolutePath}",
+                        sourceData[index],
+                        file.readBytes()
+                    )
                 } ?: fail("File not found")
             } ?: fail("No files found")
         }
diff --git a/app/src/test/java/com/amaze/filemanager/utils/OpenModeTest.java b/app/src/test/java/com/amaze/filemanager/utils/OpenModeTest.java
index 51e827605..fb273ed9a 100644
--- a/app/src/test/java/com/amaze/filemanager/utils/OpenModeTest.java
+++ b/app/src/test/java/com/amaze/filemanager/utils/OpenModeTest.java
@@ -20,25 +20,25 @@
 
 package com.amaze.filemanager.utils;
 
-import static com.amaze.filemanager.file_operations.filesystem.OpenMode.BOX;
-import static com.amaze.filemanager.file_operations.filesystem.OpenMode.CUSTOM;
-import static com.amaze.filemanager.file_operations.filesystem.OpenMode.DOCUMENT_FILE;
-import static com.amaze.filemanager.file_operations.filesystem.OpenMode.DROPBOX;
-import static com.amaze.filemanager.file_operations.filesystem.OpenMode.FILE;
-import static com.amaze.filemanager.file_operations.filesystem.OpenMode.GDRIVE;
-import static com.amaze.filemanager.file_operations.filesystem.OpenMode.ONEDRIVE;
-import static com.amaze.filemanager.file_operations.filesystem.OpenMode.OTG;
-import static com.amaze.filemanager.file_operations.filesystem.OpenMode.ROOT;
-import static com.amaze.filemanager.file_operations.filesystem.OpenMode.SFTP;
-import static com.amaze.filemanager.file_operations.filesystem.OpenMode.SMB;
-import static com.amaze.filemanager.file_operations.filesystem.OpenMode.UNKNOWN;
+import static com.amaze.filemanager.fileoperations.filesystem.OpenMode.BOX;
+import static com.amaze.filemanager.fileoperations.filesystem.OpenMode.CUSTOM;
+import static com.amaze.filemanager.fileoperations.filesystem.OpenMode.DOCUMENT_FILE;
+import static com.amaze.filemanager.fileoperations.filesystem.OpenMode.DROPBOX;
+import static com.amaze.filemanager.fileoperations.filesystem.OpenMode.FILE;
+import static com.amaze.filemanager.fileoperations.filesystem.OpenMode.GDRIVE;
+import static com.amaze.filemanager.fileoperations.filesystem.OpenMode.ONEDRIVE;
+import static com.amaze.filemanager.fileoperations.filesystem.OpenMode.OTG;
+import static com.amaze.filemanager.fileoperations.filesystem.OpenMode.ROOT;
+import static com.amaze.filemanager.fileoperations.filesystem.OpenMode.SFTP;
+import static com.amaze.filemanager.fileoperations.filesystem.OpenMode.SMB;
+import static com.amaze.filemanager.fileoperations.filesystem.OpenMode.UNKNOWN;
 import static java.lang.Integer.MAX_VALUE;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThrows;
 
 import org.junit.Test;
 
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 
 public class OpenModeTest {
 
diff --git a/app/src/test/java/com/amaze/filemanager/utils/SmbUtilTest.java b/app/src/test/java/com/amaze/filemanager/utils/SmbUtilTest.java
index 9a1cd2092..70d0d5836 100644
--- a/app/src/test/java/com/amaze/filemanager/utils/SmbUtilTest.java
+++ b/app/src/test/java/com/amaze/filemanager/utils/SmbUtilTest.java
@@ -23,8 +23,8 @@ package com.amaze.filemanager.utils;
 import static android.os.Build.VERSION_CODES.JELLY_BEAN;
 import static android.os.Build.VERSION_CODES.KITKAT;
 import static android.os.Build.VERSION_CODES.P;
-import static com.amaze.filemanager.file_operations.filesystem.FolderStateKt.DOESNT_EXIST;
-import static com.amaze.filemanager.file_operations.filesystem.FolderStateKt.WRITABLE_ON_REMOTE;
+import static com.amaze.filemanager.fileoperations.filesystem.FolderStateKt.DOESNT_EXIST;
+import static com.amaze.filemanager.fileoperations.filesystem.FolderStateKt.WRITABLE_ON_REMOTE;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertTrue;
diff --git a/app/src/test/java/com/amaze/filemanager/utils/UtilsTest.java b/app/src/test/java/com/amaze/filemanager/utils/UtilsTest.java
index 849384e6c..ed39e757a 100644
--- a/app/src/test/java/com/amaze/filemanager/utils/UtilsTest.java
+++ b/app/src/test/java/com/amaze/filemanager/utils/UtilsTest.java
@@ -46,7 +46,7 @@ import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowToast;
 
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 
 import android.net.Uri;
diff --git a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/AES256SHA256Decoder.java b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/AES256SHA256Decoder.java
index 249bd8c2d..4961b194d 100644
--- a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/AES256SHA256Decoder.java
+++ b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/AES256SHA256Decoder.java
@@ -1,20 +1,23 @@
 /*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * This file is part of Amaze File Manager.
  *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
  *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
+
 package com.amaze.filemanager.filesystem.compressed.sevenz;
 
 import java.io.IOException;
@@ -22,97 +25,108 @@ import java.io.InputStream;
 import java.security.GeneralSecurityException;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
+
 import javax.crypto.Cipher;
 import javax.crypto.CipherInputStream;
 import javax.crypto.SecretKey;
 import javax.crypto.spec.IvParameterSpec;
 import javax.crypto.spec.SecretKeySpec;
+
 import org.apache.commons.compress.PasswordRequiredException;
 
 class AES256SHA256Decoder extends CoderBase {
-    @Override
-    InputStream decode(final String archiveName, final InputStream in, final long uncompressedLength,
-            final Coder coder, final byte[] passwordBytes) throws IOException {
-        return new InputStream() {
-            private boolean isInitialized = false;
-            private CipherInputStream cipherInputStream = null;
-
-            private CipherInputStream init() throws IOException {
-                if (isInitialized) {
-                    return cipherInputStream;
-                }
-                final int byte0 = 0xff & coder.properties[0];
-                final int numCyclesPower = byte0 & 0x3f;
-                final int byte1 = 0xff & coder.properties[1];
-                final int ivSize = ((byte0 >> 6) & 1) + (byte1 & 0x0f);
-                final int saltSize = ((byte0 >> 7) & 1) + (byte1 >> 4);
-                if (2 + saltSize + ivSize > coder.properties.length) {
-                    throw new IOException("Salt size + IV size too long in " + archiveName);
-                }
-                final byte[] salt = new byte[saltSize];
-                System.arraycopy(coder.properties, 2, salt, 0, saltSize);
-                final byte[] iv = new byte[16];
-                System.arraycopy(coder.properties, 2 + saltSize, iv, 0, ivSize);
+  @Override
+  InputStream decode(
+      final String archiveName,
+      final InputStream in,
+      final long uncompressedLength,
+      final Coder coder,
+      final byte[] passwordBytes)
+      throws IOException {
+    return new InputStream() {
+      private boolean isInitialized = false;
+      private CipherInputStream cipherInputStream = null;
 
-                if (passwordBytes == null) {
-                    throw new PasswordRequiredException(archiveName);
-                }
-                final byte[] aesKeyBytes;
-                if (numCyclesPower == 0x3f) {
-                    aesKeyBytes = new byte[32];
-                    System.arraycopy(salt, 0, aesKeyBytes, 0, saltSize);
-                    System.arraycopy(passwordBytes, 0, aesKeyBytes, saltSize,
-                                     Math.min(passwordBytes.length, aesKeyBytes.length - saltSize));
-                } else {
-                    final MessageDigest digest;
-                    try {
-                        digest = MessageDigest.getInstance("SHA-256");
-                    } catch (final NoSuchAlgorithmException noSuchAlgorithmException) {
-                        throw new IOException("SHA-256 is unsupported by your Java implementation",
-                            noSuchAlgorithmException);
-                    }
-                    final byte[] extra = new byte[8];
-                    for (long j = 0; j < (1L << numCyclesPower); j++) {
-                        digest.update(salt);
-                        digest.update(passwordBytes);
-                        digest.update(extra);
-                        for (int k = 0; k < extra.length; k++) {
-                            ++extra[k];
-                            if (extra[k] != 0) {
-                                break;
-                            }
-                        }
-                    }
-                    aesKeyBytes = digest.digest();
-                }
+      private CipherInputStream init() throws IOException {
+        if (isInitialized) {
+          return cipherInputStream;
+        }
+        final int byte0 = 0xff & coder.properties[0];
+        final int numCyclesPower = byte0 & 0x3f;
+        final int byte1 = 0xff & coder.properties[1];
+        final int ivSize = ((byte0 >> 6) & 1) + (byte1 & 0x0f);
+        final int saltSize = ((byte0 >> 7) & 1) + (byte1 >> 4);
+        if (2 + saltSize + ivSize > coder.properties.length) {
+          throw new IOException("Salt size + IV size too long in " + archiveName);
+        }
+        final byte[] salt = new byte[saltSize];
+        System.arraycopy(coder.properties, 2, salt, 0, saltSize);
+        final byte[] iv = new byte[16];
+        System.arraycopy(coder.properties, 2 + saltSize, iv, 0, ivSize);
 
-                final SecretKey aesKey = new SecretKeySpec(aesKeyBytes, "AES");
-                try {
-                    final Cipher cipher = Cipher.getInstance("AES/CBC/NoPadding");
-                    cipher.init(Cipher.DECRYPT_MODE, aesKey, new IvParameterSpec(iv));
-                    cipherInputStream = new CipherInputStream(in, cipher);
-                    isInitialized = true;
-                    return cipherInputStream;
-                } catch (final GeneralSecurityException generalSecurityException) {
-                    throw new IOException("Decryption error " +
-                        "(do you have the JCE Unlimited Strength Jurisdiction Policy Files installed?)",
-                        generalSecurityException);
-                    }
+        if (passwordBytes == null) {
+          throw new PasswordRequiredException(archiveName);
+        }
+        final byte[] aesKeyBytes;
+        if (numCyclesPower == 0x3f) {
+          aesKeyBytes = new byte[32];
+          System.arraycopy(salt, 0, aesKeyBytes, 0, saltSize);
+          System.arraycopy(
+              passwordBytes,
+              0,
+              aesKeyBytes,
+              saltSize,
+              Math.min(passwordBytes.length, aesKeyBytes.length - saltSize));
+        } else {
+          final MessageDigest digest;
+          try {
+            digest = MessageDigest.getInstance("SHA-256");
+          } catch (final NoSuchAlgorithmException noSuchAlgorithmException) {
+            throw new IOException(
+                "SHA-256 is unsupported by your Java implementation", noSuchAlgorithmException);
+          }
+          final byte[] extra = new byte[8];
+          for (long j = 0; j < (1L << numCyclesPower); j++) {
+            digest.update(salt);
+            digest.update(passwordBytes);
+            digest.update(extra);
+            for (int k = 0; k < extra.length; k++) {
+              ++extra[k];
+              if (extra[k] != 0) {
+                break;
+              }
             }
+          }
+          aesKeyBytes = digest.digest();
+        }
 
-            @Override
-            public int read() throws IOException {
-                return init().read();
-            }
+        final SecretKey aesKey = new SecretKeySpec(aesKeyBytes, "AES");
+        try {
+          final Cipher cipher = Cipher.getInstance("AES/CBC/NoPadding");
+          cipher.init(Cipher.DECRYPT_MODE, aesKey, new IvParameterSpec(iv));
+          cipherInputStream = new CipherInputStream(in, cipher);
+          isInitialized = true;
+          return cipherInputStream;
+        } catch (final GeneralSecurityException generalSecurityException) {
+          throw new IOException(
+              "Decryption error "
+                  + "(do you have the JCE Unlimited Strength Jurisdiction Policy Files installed?)",
+              generalSecurityException);
+        }
+      }
 
-            @Override
-            public int read(final byte[] b, final int off, final int len) throws IOException {
-                return init().read(b, off, len);
-            }
+      @Override
+      public int read() throws IOException {
+        return init().read();
+      }
 
-            @Override
-            public void close() {
-            }
-        };
-    }
+      @Override
+      public int read(final byte[] b, final int off, final int len) throws IOException {
+        return init().read(b, off, len);
+      }
+
+      @Override
+      public void close() {}
+    };
+  }
 }
diff --git a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/Archive.java b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/Archive.java
index 8e41ae87e..b2544a53a 100644
--- a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/Archive.java
+++ b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/Archive.java
@@ -1,55 +1,66 @@
 /*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * This file is part of Amaze File Manager.
  *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
  *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
+
 package com.amaze.filemanager.filesystem.compressed.sevenz;
 
 import java.util.BitSet;
 
 class Archive {
-    /// Offset from beginning of file + SIGNATURE_HEADER_SIZE to packed streams.
-    long packPos;
-    /// Size of each packed stream.
-    long[] packSizes;
-    /// Whether each particular packed streams has a CRC.
-    BitSet packCrcsDefined;
-    /// CRCs for each packed stream, valid only if that packed stream has one.
-    long[] packCrcs;
-    /// Properties of solid compression blocks.
-    Folder[] folders;
-    /// Temporary properties for non-empty files (subsumed into the files array later).
-    SubStreamsInfo subStreamsInfo;
-    /// The files and directories in the archive.
-    SevenZArchiveEntry[] files;
-    /// Mapping between folders, files and streams.
-    StreamMap streamMap;
+  /// Offset from beginning of file + SIGNATURE_HEADER_SIZE to packed streams.
+  long packPos;
+  /// Size of each packed stream.
+  long[] packSizes;
+  /// Whether each particular packed streams has a CRC.
+  BitSet packCrcsDefined;
+  /// CRCs for each packed stream, valid only if that packed stream has one.
+  long[] packCrcs;
+  /// Properties of solid compression blocks.
+  Folder[] folders;
+  /// Temporary properties for non-empty files (subsumed into the files array later).
+  SubStreamsInfo subStreamsInfo;
+  /// The files and directories in the archive.
+  SevenZArchiveEntry[] files;
+  /// Mapping between folders, files and streams.
+  StreamMap streamMap;
 
-    @Override
-    public String toString() {
-        return "Archive with packed streams starting at offset " + packPos
-            + ", " + lengthOf(packSizes) + " pack sizes, " + lengthOf(packCrcs)
-            + " CRCs, " + lengthOf(folders) + " folders, " + lengthOf(files)
-            + " files and " + streamMap;
-    }
+  @Override
+  public String toString() {
+    return "Archive with packed streams starting at offset "
+        + packPos
+        + ", "
+        + lengthOf(packSizes)
+        + " pack sizes, "
+        + lengthOf(packCrcs)
+        + " CRCs, "
+        + lengthOf(folders)
+        + " folders, "
+        + lengthOf(files)
+        + " files and "
+        + streamMap;
+  }
 
-    private static String lengthOf(final long[] a) {
-        return a == null ? "(null)" : String.valueOf(a.length);
-    }
+  private static String lengthOf(final long[] a) {
+    return a == null ? "(null)" : String.valueOf(a.length);
+  }
 
-    private static String lengthOf(final Object[] a) {
-        return a == null ? "(null)" : String.valueOf(a.length);
-    }
+  private static String lengthOf(final Object[] a) {
+    return a == null ? "(null)" : String.valueOf(a.length);
+  }
 }
diff --git a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/BindPair.java b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/BindPair.java
index edc9ac032..b653b7764 100644
--- a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/BindPair.java
+++ b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/BindPair.java
@@ -1,28 +1,31 @@
 /*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * This file is part of Amaze File Manager.
  *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
  *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
+
 package com.amaze.filemanager.filesystem.compressed.sevenz;
 
 class BindPair {
-    long inIndex;
-    long outIndex;
+  long inIndex;
+  long outIndex;
 
-    @Override
-    public String toString() {
-        return "BindPair binding input " + inIndex + " to output " + outIndex;
-    }
+  @Override
+  public String toString() {
+    return "BindPair binding input " + inIndex + " to output " + outIndex;
+  }
 }
diff --git a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/BoundedFileChannelInputStream.java b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/BoundedFileChannelInputStream.java
index c8cb1ba4b..ee5c6fd86 100644
--- a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/BoundedFileChannelInputStream.java
+++ b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/BoundedFileChannelInputStream.java
@@ -1,93 +1,94 @@
 /*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * This file is part of Amaze File Manager.
  *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
  *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
+
 package com.amaze.filemanager.filesystem.compressed.sevenz;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
 import java.nio.channels.FileChannel;
-import java.nio.channels.SeekableByteChannel;
 
 class BoundedFileChannelInputStream extends InputStream {
-    private static final int MAX_BUF_LEN = 8192;
-    private final ByteBuffer buffer;
-    private final FileChannel channel;
-    private long bytesRemaining;
+  private static final int MAX_BUF_LEN = 8192;
+  private final ByteBuffer buffer;
+  private final FileChannel channel;
+  private long bytesRemaining;
 
-    public BoundedFileChannelInputStream(final FileChannel channel,
-                                         final long size) {
-        this.channel = channel;
-        this.bytesRemaining = size;
-        if (size < MAX_BUF_LEN && size > 0) {
-            buffer = ByteBuffer.allocate((int) size);
-        } else {
-            buffer = ByteBuffer.allocate(MAX_BUF_LEN);
-        }
+  public BoundedFileChannelInputStream(final FileChannel channel, final long size) {
+    this.channel = channel;
+    this.bytesRemaining = size;
+    if (size < MAX_BUF_LEN && size > 0) {
+      buffer = ByteBuffer.allocate((int) size);
+    } else {
+      buffer = ByteBuffer.allocate(MAX_BUF_LEN);
     }
+  }
 
-    @Override
-    public int read() throws IOException {
-        if (bytesRemaining > 0) {
-            --bytesRemaining;
-            int read = read(1);
-            if (read < 0) {
-                return read;
-            }
-            return buffer.get() & 0xff;
-        }
-        return -1;
+  @Override
+  public int read() throws IOException {
+    if (bytesRemaining > 0) {
+      --bytesRemaining;
+      int read = read(1);
+      if (read < 0) {
+        return read;
+      }
+      return buffer.get() & 0xff;
     }
+    return -1;
+  }
 
-    @Override
-    public int read(final byte[] b, final int off, final int len) throws IOException {
-        if (bytesRemaining == 0) {
-            return -1;
-        }
-        int bytesToRead = len;
-        if (bytesToRead > bytesRemaining) {
-            bytesToRead = (int) bytesRemaining;
-        }
-        int bytesRead;
-        ByteBuffer buf;
-        if (bytesToRead <= buffer.capacity()) {
-            buf = buffer;
-            bytesRead = read(bytesToRead);
-        } else {
-            buf = ByteBuffer.allocate(bytesToRead);
-            bytesRead = channel.read(buf);
-            buf.flip();
-        }
-        if (bytesRead >= 0) {
-            buf.get(b, off, bytesRead);
-            bytesRemaining -= bytesRead;
-        }
-        return bytesRead;
+  @Override
+  public int read(final byte[] b, final int off, final int len) throws IOException {
+    if (bytesRemaining == 0) {
+      return -1;
     }
-
-    private int read(int len) throws IOException {
-        buffer.rewind().limit(len);
-        int read = channel.read(buffer);
-        buffer.flip();
-        return read;
+    int bytesToRead = len;
+    if (bytesToRead > bytesRemaining) {
+      bytesToRead = (int) bytesRemaining;
     }
-
-    @Override
-    public void close() {
-        // the nested channel is controlled externally
+    int bytesRead;
+    ByteBuffer buf;
+    if (bytesToRead <= buffer.capacity()) {
+      buf = buffer;
+      bytesRead = read(bytesToRead);
+    } else {
+      buf = ByteBuffer.allocate(bytesToRead);
+      bytesRead = channel.read(buf);
+      buf.flip();
+    }
+    if (bytesRead >= 0) {
+      buf.get(b, off, bytesRead);
+      bytesRemaining -= bytesRead;
     }
+    return bytesRead;
+  }
+
+  private int read(int len) throws IOException {
+    buffer.rewind().limit(len);
+    int read = channel.read(buffer);
+    buffer.flip();
+    return read;
+  }
+
+  @Override
+  public void close() {
+    // the nested channel is controlled externally
+  }
 }
diff --git a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/Coder.java b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/Coder.java
index e723b79ca..b935c52fc 100644
--- a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/Coder.java
+++ b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/Coder.java
@@ -1,25 +1,28 @@
 /*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * This file is part of Amaze File Manager.
  *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
  *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
+
 package com.amaze.filemanager.filesystem.compressed.sevenz;
 
 class Coder {
-    byte[] decompressionMethodId;
-    long numInStreams;
-    long numOutStreams;
-    byte[] properties = null;
+  byte[] decompressionMethodId;
+  long numInStreams;
+  long numOutStreams;
+  byte[] properties = null;
 }
diff --git a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/CoderBase.java b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/CoderBase.java
index 623bc5947..3dde55a20 100644
--- a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/CoderBase.java
+++ b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/CoderBase.java
@@ -1,85 +1,91 @@
 /*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * This file is part of Amaze File Manager.
  *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
  *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
+
 package com.amaze.filemanager.filesystem.compressed.sevenz;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 
-/**
- * Base Codec class.
- */
+/** Base Codec class. */
 abstract class CoderBase {
-    private final Class<?>[] acceptableOptions;
-    private static final byte[] NONE = new byte[0];
+  private final Class<?>[] acceptableOptions;
+  private static final byte[] NONE = new byte[0];
 
-    /**
-     * @param acceptableOptions types that can be used as options for this codec.
-     */
-    protected CoderBase(final Class<?>... acceptableOptions) {
-        this.acceptableOptions = acceptableOptions;
-    }
+  /**
+   * @param acceptableOptions types that can be used as options for this codec.
+   */
+  protected CoderBase(final Class<?>... acceptableOptions) {
+    this.acceptableOptions = acceptableOptions;
+  }
 
-    /**
-     * @return whether this method can extract options from the given object.
-     */
-    boolean canAcceptOptions(final Object opts) {
-        for (final Class<?> c : acceptableOptions) {
-            if (c.isInstance(opts)) {
-                return true;
-            }
-        }
-        return false;
+  /**
+   * @return whether this method can extract options from the given object.
+   */
+  boolean canAcceptOptions(final Object opts) {
+    for (final Class<?> c : acceptableOptions) {
+      if (c.isInstance(opts)) {
+        return true;
+      }
     }
+    return false;
+  }
 
-    /**
-     * @return property-bytes to write in a Folder block
-     */
-    byte[] getOptionsAsProperties(final Object options) throws IOException {
-        return NONE;
-    }
+  /**
+   * @return property-bytes to write in a Folder block
+   */
+  byte[] getOptionsAsProperties(final Object options) throws IOException {
+    return NONE;
+  }
 
-    /**
-     * @return configuration options that have been used to create the given InputStream from the given Coder
-     */
-    Object getOptionsFromCoder(final Coder coder, final InputStream in) throws IOException {
-        return null;
-    }
+  /**
+   * @return configuration options that have been used to create the given InputStream from the
+   *     given Coder
+   */
+  Object getOptionsFromCoder(final Coder coder, final InputStream in) throws IOException {
+    return null;
+  }
 
-    /**
-     * @return a stream that reads from in using the configured coder and password.
-     */
-    abstract InputStream decode(final String archiveName,
-        final InputStream in, long uncomressedLength,
-        final Coder coder, byte[] password) throws IOException;
+  /**
+   * @return a stream that reads from in using the configured coder and password.
+   */
+  abstract InputStream decode(
+      final String archiveName,
+      final InputStream in,
+      long uncomressedLength,
+      final Coder coder,
+      byte[] password)
+      throws IOException;
 
-    /**
-     * @return a stream that writes to out using the given configuration.
-     */
-    OutputStream encode(final OutputStream out, final Object options) throws IOException {
-        throw new UnsupportedOperationException("method doesn't support writing");
-    }
+  /**
+   * @return a stream that writes to out using the given configuration.
+   */
+  OutputStream encode(final OutputStream out, final Object options) throws IOException {
+    throw new UnsupportedOperationException("method doesn't support writing");
+  }
 
-    /**
-     * If the option represents a number, return its integer
-     * value, otherwise return the given default value.
-     */
-    protected static int numberOptionOrDefault(final Object options, final int defaultValue) {
-        return options instanceof Number ? ((Number) options).intValue() : defaultValue;
-    }
+  /**
+   * If the option represents a number, return its integer value, otherwise return the given default
+   * value.
+   */
+  protected static int numberOptionOrDefault(final Object options, final int defaultValue) {
+    return options instanceof Number ? ((Number) options).intValue() : defaultValue;
+  }
 }
diff --git a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/Coders.java b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/Coders.java
index f63f7f553..31cd9eb4f 100644
--- a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/Coders.java
+++ b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/Coders.java
@@ -1,20 +1,23 @@
 /*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * This file is part of Amaze File Manager.
  *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
  *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
+
 package com.amaze.filemanager.filesystem.compressed.sevenz;
 
 import java.io.ByteArrayInputStream;
@@ -44,221 +47,260 @@ import org.tukaani.xz.SPARCOptions;
 import org.tukaani.xz.X86Options;
 
 class Coders {
-    private static final Map<SevenZMethod, CoderBase> CODER_MAP = new HashMap<SevenZMethod, CoderBase>() {
+  private static final Map<SevenZMethod, CoderBase> CODER_MAP =
+      new HashMap<SevenZMethod, CoderBase>() {
 
         private static final long serialVersionUID = 1664829131806520867L;
-    {
-            put(SevenZMethod.COPY, new CopyDecoder());
-            put(SevenZMethod.LZMA, new LZMADecoder());
-            put(SevenZMethod.LZMA2, new LZMA2Decoder());
-            put(SevenZMethod.DEFLATE, new DeflateDecoder());
-            put(SevenZMethod.DEFLATE64, new Deflate64Decoder());
-            put(SevenZMethod.BZIP2, new BZIP2Decoder());
-            put(SevenZMethod.AES256SHA256, new AES256SHA256Decoder());
-            put(SevenZMethod.BCJ_X86_FILTER, new BCJDecoder(new X86Options()));
-            put(SevenZMethod.BCJ_PPC_FILTER, new BCJDecoder(new PowerPCOptions()));
-            put(SevenZMethod.BCJ_IA64_FILTER, new BCJDecoder(new IA64Options()));
-            put(SevenZMethod.BCJ_ARM_FILTER, new BCJDecoder(new ARMOptions()));
-            put(SevenZMethod.BCJ_ARM_THUMB_FILTER, new BCJDecoder(new ARMThumbOptions()));
-            put(SevenZMethod.BCJ_SPARC_FILTER, new BCJDecoder(new SPARCOptions()));
-            put(SevenZMethod.DELTA_FILTER, new DeltaDecoder());
-        }};
-
-    static CoderBase findByMethod(final SevenZMethod method) {
-        return CODER_MAP.get(method);
-    }
 
-    static InputStream addDecoder(final String archiveName, final InputStream is, final long uncompressedLength,
-            final Coder coder, final byte[] password) throws IOException {
-        final CoderBase cb = findByMethod(SevenZMethod.byId(coder.decompressionMethodId));
-        if (cb == null) {
-            throw new IOException("Unsupported compression method " +
-                                  Arrays.toString(coder.decompressionMethodId)
-                                  + " used in " + archiveName);
+        {
+          put(SevenZMethod.COPY, new CopyDecoder());
+          put(SevenZMethod.LZMA, new LZMADecoder());
+          put(SevenZMethod.LZMA2, new LZMA2Decoder());
+          put(SevenZMethod.DEFLATE, new DeflateDecoder());
+          put(SevenZMethod.DEFLATE64, new Deflate64Decoder());
+          put(SevenZMethod.BZIP2, new BZIP2Decoder());
+          put(SevenZMethod.AES256SHA256, new AES256SHA256Decoder());
+          put(SevenZMethod.BCJ_X86_FILTER, new BCJDecoder(new X86Options()));
+          put(SevenZMethod.BCJ_PPC_FILTER, new BCJDecoder(new PowerPCOptions()));
+          put(SevenZMethod.BCJ_IA64_FILTER, new BCJDecoder(new IA64Options()));
+          put(SevenZMethod.BCJ_ARM_FILTER, new BCJDecoder(new ARMOptions()));
+          put(SevenZMethod.BCJ_ARM_THUMB_FILTER, new BCJDecoder(new ARMThumbOptions()));
+          put(SevenZMethod.BCJ_SPARC_FILTER, new BCJDecoder(new SPARCOptions()));
+          put(SevenZMethod.DELTA_FILTER, new DeltaDecoder());
         }
-        return cb.decode(archiveName, is, uncompressedLength, coder, password);
+      };
+
+  static CoderBase findByMethod(final SevenZMethod method) {
+    return CODER_MAP.get(method);
+  }
+
+  static InputStream addDecoder(
+      final String archiveName,
+      final InputStream is,
+      final long uncompressedLength,
+      final Coder coder,
+      final byte[] password)
+      throws IOException {
+    final CoderBase cb = findByMethod(SevenZMethod.byId(coder.decompressionMethodId));
+    if (cb == null) {
+      throw new IOException(
+          "Unsupported compression method "
+              + Arrays.toString(coder.decompressionMethodId)
+              + " used in "
+              + archiveName);
+    }
+    return cb.decode(archiveName, is, uncompressedLength, coder, password);
+  }
+
+  static OutputStream addEncoder(
+      final OutputStream out, final SevenZMethod method, final Object options) throws IOException {
+    final CoderBase cb = findByMethod(method);
+    if (cb == null) {
+      throw new IOException("Unsupported compression method " + method);
+    }
+    return cb.encode(out, options);
+  }
+
+  static class CopyDecoder extends CoderBase {
+    @Override
+    InputStream decode(
+        final String archiveName,
+        final InputStream in,
+        final long uncompressedLength,
+        final Coder coder,
+        final byte[] password)
+        throws IOException {
+      return in;
     }
 
-    static OutputStream addEncoder(final OutputStream out, final SevenZMethod method,
-                                   final Object options) throws IOException {
-        final CoderBase cb = findByMethod(method);
-        if (cb == null) {
-            throw new IOException("Unsupported compression method " + method);
-        }
-        return cb.encode(out, options);
+    @Override
+    OutputStream encode(final OutputStream out, final Object options) {
+      return out;
     }
+  }
 
-    static class CopyDecoder extends CoderBase {
-        @Override
-        InputStream decode(final String archiveName, final InputStream in, final long uncompressedLength,
-                final Coder coder, final byte[] password) throws IOException {
-            return in;
-        }
-        @Override
-        OutputStream encode(final OutputStream out, final Object options) {
-            return out;
-        }
+  static class BCJDecoder extends CoderBase {
+    private final FilterOptions opts;
+
+    BCJDecoder(final FilterOptions opts) {
+      this.opts = opts;
     }
 
-    static class BCJDecoder extends CoderBase {
-        private final FilterOptions opts;
-        BCJDecoder(final FilterOptions opts) {
-            this.opts = opts;
-        }
+    @Override
+    InputStream decode(
+        final String archiveName,
+        final InputStream in,
+        final long uncompressedLength,
+        final Coder coder,
+        final byte[] password)
+        throws IOException {
+      try {
+        return opts.getInputStream(in);
+      } catch (final AssertionError e) {
+        throw new IOException(
+            "BCJ filter used in "
+                + archiveName
+                + " needs XZ for Java > 1.4 - see "
+                + "https://commons.apache.org/proper/commons-compress/limitations.html#7Z",
+            e);
+      }
+    }
 
-        @Override
-        InputStream decode(final String archiveName, final InputStream in, final long uncompressedLength,
-                final Coder coder, final byte[] password) throws IOException {
-            try {
-                return opts.getInputStream(in);
-            } catch (final AssertionError e) {
-                throw new IOException("BCJ filter used in " + archiveName
-                                      + " needs XZ for Java > 1.4 - see "
-                                      + "https://commons.apache.org/proper/commons-compress/limitations.html#7Z",
-                                      e);
-            }
-        }
+    @SuppressWarnings("resource")
+    @Override
+    OutputStream encode(final OutputStream out, final Object options) {
+      return new FlushShieldFilterOutputStream(
+          opts.getOutputStream(new FinishableWrapperOutputStream(out)));
+    }
+  }
 
-        @SuppressWarnings("resource")
-        @Override
-        OutputStream encode(final OutputStream out, final Object options) {
-            return new FlushShieldFilterOutputStream(opts.getOutputStream(new FinishableWrapperOutputStream(out)));
-        }
+  static class DeflateDecoder extends CoderBase {
+    private static final byte[] ONE_ZERO_BYTE = new byte[1];
+
+    DeflateDecoder() {
+      super(Number.class);
     }
 
-    static class DeflateDecoder extends CoderBase {
-        private static final byte[] ONE_ZERO_BYTE = new byte[1];
-        DeflateDecoder() {
-            super(Number.class);
-        }
+    @SuppressWarnings("resource") // caller must close the InputStream
+    @Override
+    InputStream decode(
+        final String archiveName,
+        final InputStream in,
+        final long uncompressedLength,
+        final Coder coder,
+        final byte[] password)
+        throws IOException {
+      final Inflater inflater = new Inflater(true);
+      // Inflater with nowrap=true has this odd contract for a zero padding
+      // byte following the data stream; this used to be zlib's requirement
+      // and has been fixed a long time ago, but the contract persists so
+      // we comply.
+      // https://docs.oracle.com/javase/7/docs/api/java/util/zip/Inflater.html#Inflater(boolean)
+      final InflaterInputStream inflaterInputStream =
+          new InflaterInputStream(
+              new SequenceInputStream(in, new ByteArrayInputStream(ONE_ZERO_BYTE)), inflater);
+      return new DeflateDecoderInputStream(inflaterInputStream, inflater);
+    }
 
-        @SuppressWarnings("resource") // caller must close the InputStream
-        @Override
-        InputStream decode(final String archiveName, final InputStream in, final long uncompressedLength,
-                final Coder coder, final byte[] password)
-            throws IOException {
-            final Inflater inflater = new Inflater(true);
-            // Inflater with nowrap=true has this odd contract for a zero padding
-            // byte following the data stream; this used to be zlib's requirement
-            // and has been fixed a long time ago, but the contract persists so
-            // we comply.
-            // https://docs.oracle.com/javase/7/docs/api/java/util/zip/Inflater.html#Inflater(boolean)
-            final InflaterInputStream inflaterInputStream = new InflaterInputStream(new SequenceInputStream(in,
-                new ByteArrayInputStream(ONE_ZERO_BYTE)), inflater);
-            return new DeflateDecoderInputStream(inflaterInputStream, inflater);
-        }
-        @Override
-        OutputStream encode(final OutputStream out, final Object options) {
-            final int level = numberOptionOrDefault(options, 9);
-            final Deflater deflater = new Deflater(level, true);
-            final DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream(out, deflater);
-            return new DeflateDecoderOutputStream(deflaterOutputStream, deflater);
-        }
+    @Override
+    OutputStream encode(final OutputStream out, final Object options) {
+      final int level = numberOptionOrDefault(options, 9);
+      final Deflater deflater = new Deflater(level, true);
+      final DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream(out, deflater);
+      return new DeflateDecoderOutputStream(deflaterOutputStream, deflater);
+    }
 
-         static class DeflateDecoderInputStream extends InputStream {
-
-              InflaterInputStream inflaterInputStream;
-              Inflater inflater;
-
-            public DeflateDecoderInputStream(InflaterInputStream inflaterInputStream,
-                Inflater inflater) {
-                this.inflaterInputStream = inflaterInputStream;
-                this.inflater = inflater;
-            }
-
-            @Override
-            public int read() throws IOException {
-                return inflaterInputStream.read();
-            }
-
-            @Override
-            public int read(final byte[] b, final int off, final int len) throws IOException {
-                return inflaterInputStream.read(b, off, len);
-            }
-
-            @Override
-            public int read(final byte[] b) throws IOException {
-                return inflaterInputStream.read(b);
-            }
-
-            @Override
-            public void close() throws IOException {
-                try {
-                    inflaterInputStream.close();
-                } finally {
-                    inflater.end();
-                }
-            }
+    static class DeflateDecoderInputStream extends InputStream {
+
+      InflaterInputStream inflaterInputStream;
+      Inflater inflater;
+
+      public DeflateDecoderInputStream(InflaterInputStream inflaterInputStream, Inflater inflater) {
+        this.inflaterInputStream = inflaterInputStream;
+        this.inflater = inflater;
+      }
+
+      @Override
+      public int read() throws IOException {
+        return inflaterInputStream.read();
+      }
+
+      @Override
+      public int read(final byte[] b, final int off, final int len) throws IOException {
+        return inflaterInputStream.read(b, off, len);
+      }
+
+      @Override
+      public int read(final byte[] b) throws IOException {
+        return inflaterInputStream.read(b);
+      }
+
+      @Override
+      public void close() throws IOException {
+        try {
+          inflaterInputStream.close();
+        } finally {
+          inflater.end();
         }
+      }
+    }
 
-         static class DeflateDecoderOutputStream extends OutputStream {
-
-              DeflaterOutputStream deflaterOutputStream;
-              Deflater deflater;
-
-            public DeflateDecoderOutputStream(DeflaterOutputStream deflaterOutputStream,
-                Deflater deflater) {
-                this.deflaterOutputStream = deflaterOutputStream;
-                this.deflater = deflater;
-            }
-
-            @Override
-            public void write(final int b) throws IOException {
-                deflaterOutputStream.write(b);
-            }
-
-            @Override
-            public void write(final byte[] b) throws IOException {
-                deflaterOutputStream.write(b);
-            }
-
-            @Override
-            public void write(final byte[] b, final int off, final int len) throws IOException {
-                deflaterOutputStream.write(b, off, len);
-            }
-
-            @Override
-            public void close() throws IOException {
-                try {
-                    deflaterOutputStream.close();
-                } finally {
-                    deflater.end();
-                }
-            }
+    static class DeflateDecoderOutputStream extends OutputStream {
+
+      DeflaterOutputStream deflaterOutputStream;
+      Deflater deflater;
+
+      public DeflateDecoderOutputStream(
+          DeflaterOutputStream deflaterOutputStream, Deflater deflater) {
+        this.deflaterOutputStream = deflaterOutputStream;
+        this.deflater = deflater;
+      }
+
+      @Override
+      public void write(final int b) throws IOException {
+        deflaterOutputStream.write(b);
+      }
+
+      @Override
+      public void write(final byte[] b) throws IOException {
+        deflaterOutputStream.write(b);
+      }
+
+      @Override
+      public void write(final byte[] b, final int off, final int len) throws IOException {
+        deflaterOutputStream.write(b, off, len);
+      }
+
+      @Override
+      public void close() throws IOException {
+        try {
+          deflaterOutputStream.close();
+        } finally {
+          deflater.end();
         }
+      }
     }
+  }
 
-    static class Deflate64Decoder extends CoderBase {
-        Deflate64Decoder() {
-            super(Number.class);
-        }
+  static class Deflate64Decoder extends CoderBase {
+    Deflate64Decoder() {
+      super(Number.class);
+    }
 
-        @SuppressWarnings("resource") // caller must close the InputStream
-        @Override
-        InputStream decode(final String archiveName, final InputStream in, final long uncompressedLength,
-                final Coder coder, final byte[] password)
-            throws IOException {
-            return new Deflate64CompressorInputStream(in);
-        }
+    @SuppressWarnings("resource") // caller must close the InputStream
+    @Override
+    InputStream decode(
+        final String archiveName,
+        final InputStream in,
+        final long uncompressedLength,
+        final Coder coder,
+        final byte[] password)
+        throws IOException {
+      return new Deflate64CompressorInputStream(in);
     }
+  }
 
-    static class BZIP2Decoder extends CoderBase {
-        BZIP2Decoder() {
-            super(Number.class);
-        }
+  static class BZIP2Decoder extends CoderBase {
+    BZIP2Decoder() {
+      super(Number.class);
+    }
 
-        @Override
-        InputStream decode(final String archiveName, final InputStream in, final long uncompressedLength,
-                final Coder coder, final byte[] password)
-                throws IOException {
-            return new BZip2CompressorInputStream(in);
-        }
-        @Override
-        OutputStream encode(final OutputStream out, final Object options)
-                throws IOException {
-            final int blockSize = numberOptionOrDefault(options, BZip2CompressorOutputStream.MAX_BLOCKSIZE);
-            return new BZip2CompressorOutputStream(out, blockSize);
-        }
+    @Override
+    InputStream decode(
+        final String archiveName,
+        final InputStream in,
+        final long uncompressedLength,
+        final Coder coder,
+        final byte[] password)
+        throws IOException {
+      return new BZip2CompressorInputStream(in);
     }
 
+    @Override
+    OutputStream encode(final OutputStream out, final Object options) throws IOException {
+      final int blockSize =
+          numberOptionOrDefault(options, BZip2CompressorOutputStream.MAX_BLOCKSIZE);
+      return new BZip2CompressorOutputStream(out, blockSize);
+    }
+  }
 }
diff --git a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/DeltaDecoder.java b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/DeltaDecoder.java
index aeb12d1da..92bcefa34 100644
--- a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/DeltaDecoder.java
+++ b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/DeltaDecoder.java
@@ -1,67 +1,74 @@
 /*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * This file is part of Amaze File Manager.
  *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
  *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
+
 package com.amaze.filemanager.filesystem.compressed.sevenz;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+
 import org.tukaani.xz.DeltaOptions;
 import org.tukaani.xz.FinishableWrapperOutputStream;
 import org.tukaani.xz.UnsupportedOptionsException;
 
 class DeltaDecoder extends CoderBase {
-    DeltaDecoder() {
-        super(Number.class);
-    }
+  DeltaDecoder() {
+    super(Number.class);
+  }
 
-    @Override
-    InputStream decode(final String archiveName, final InputStream in, final long uncompressedLength,
-            final Coder coder, final byte[] password) throws IOException {
-        return new DeltaOptions(getOptionsFromCoder(coder)).getInputStream(in);
-    }
+  @Override
+  InputStream decode(
+      final String archiveName,
+      final InputStream in,
+      final long uncompressedLength,
+      final Coder coder,
+      final byte[] password)
+      throws IOException {
+    return new DeltaOptions(getOptionsFromCoder(coder)).getInputStream(in);
+  }
 
-    @SuppressWarnings("resource")
-    @Override
-    OutputStream encode(final OutputStream out, final Object options) throws IOException {
-        final int distance = numberOptionOrDefault(options, 1);
-        try {
-            return new DeltaOptions(distance).getOutputStream(new FinishableWrapperOutputStream(out));
-        } catch (final UnsupportedOptionsException ex) {
-            throw new IOException(ex.getMessage());
-        }
+  @SuppressWarnings("resource")
+  @Override
+  OutputStream encode(final OutputStream out, final Object options) throws IOException {
+    final int distance = numberOptionOrDefault(options, 1);
+    try {
+      return new DeltaOptions(distance).getOutputStream(new FinishableWrapperOutputStream(out));
+    } catch (final UnsupportedOptionsException ex) {
+      throw new IOException(ex.getMessage());
     }
+  }
 
-    @Override
-    byte[] getOptionsAsProperties(final Object options) {
-        return new byte[] {
-            (byte) (numberOptionOrDefault(options, 1) - 1)
-        };
-    }
+  @Override
+  byte[] getOptionsAsProperties(final Object options) {
+    return new byte[] {(byte) (numberOptionOrDefault(options, 1) - 1)};
+  }
 
-    @Override
-    Object getOptionsFromCoder(final Coder coder, final InputStream in) {
-        return getOptionsFromCoder(coder);
-    }
+  @Override
+  Object getOptionsFromCoder(final Coder coder, final InputStream in) {
+    return getOptionsFromCoder(coder);
+  }
 
-    private int getOptionsFromCoder(final Coder coder) {
-        if (coder.properties == null || coder.properties.length == 0) {
-            return 1;
-        }
-        return (0xff & coder.properties[0]) + 1;
+  private int getOptionsFromCoder(final Coder coder) {
+    if (coder.properties == null || coder.properties.length == 0) {
+      return 1;
     }
+    return (0xff & coder.properties[0]) + 1;
+  }
 }
diff --git a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/Folder.java b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/Folder.java
index ff733c78f..75eba8374 100644
--- a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/Folder.java
+++ b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/Folder.java
@@ -1,116 +1,127 @@
 /*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * This file is part of Amaze File Manager.
  *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
  *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
+
 package com.amaze.filemanager.filesystem.compressed.sevenz;
 
 import java.util.LinkedList;
 
-/**
- * The unit of solid compression.
- */
+/** The unit of solid compression. */
 class Folder {
-    /// List of coders used in this folder, eg. one for compression, one for encryption.
-    Coder[] coders;
-    /// Total number of input streams across all coders.
-    /// this field is currently unused but technically part of the 7z API
-    long totalInputStreams;
-    /// Total number of output streams across all coders.
-    long totalOutputStreams;
-    /// Mapping between input and output streams.
-    BindPair[] bindPairs;
-    /// Indeces of input streams, one per input stream not listed in bindPairs.
-    long[] packedStreams;
-    /// Unpack sizes, per each output stream.
-    long[] unpackSizes;
-    /// Whether the folder has a CRC.
-    boolean hasCrc;
-    /// The CRC, if present.
-    long crc;
-    /// The number of unpack substreams, product of the number of
-    /// output streams and the nuber of non-empty files in this
-    /// folder.
-    int numUnpackSubStreams;
+  /// List of coders used in this folder, eg. one for compression, one for encryption.
+  Coder[] coders;
+  /// Total number of input streams across all coders.
+  /// this field is currently unused but technically part of the 7z API
+  long totalInputStreams;
+  /// Total number of output streams across all coders.
+  long totalOutputStreams;
+  /// Mapping between input and output streams.
+  BindPair[] bindPairs;
+  /// Indeces of input streams, one per input stream not listed in bindPairs.
+  long[] packedStreams;
+  /// Unpack sizes, per each output stream.
+  long[] unpackSizes;
+  /// Whether the folder has a CRC.
+  boolean hasCrc;
+  /// The CRC, if present.
+  long crc;
+  /// The number of unpack substreams, product of the number of
+  /// output streams and the nuber of non-empty files in this
+  /// folder.
+  int numUnpackSubStreams;
 
-    /**
-     * Sorts Coders using bind pairs.
-     * <p>The first coder reads from the packed stream (we currently
-     * only support single input stream decoders), the second reads
-     * from the output of the first and so on.</p>
-     */
-    Iterable<Coder> getOrderedCoders() {
-        final LinkedList<Coder> l = new LinkedList<>();
-        int current = (int) packedStreams[0]; // more that 2^31 coders?
-        while (current != -1) {
-            l.addLast(coders[current]);
-            final int pair = findBindPairForOutStream(current);
-            current = pair != -1 ? (int) bindPairs[pair].inIndex : -1;
-        }
-        return l;
+  /**
+   * Sorts Coders using bind pairs.
+   *
+   * <p>The first coder reads from the packed stream (we currently only support single input stream
+   * decoders), the second reads from the output of the first and so on.
+   */
+  Iterable<Coder> getOrderedCoders() {
+    final LinkedList<Coder> l = new LinkedList<>();
+    int current = (int) packedStreams[0]; // more that 2^31 coders?
+    while (current != -1) {
+      l.addLast(coders[current]);
+      final int pair = findBindPairForOutStream(current);
+      current = pair != -1 ? (int) bindPairs[pair].inIndex : -1;
     }
+    return l;
+  }
 
-    int findBindPairForInStream(final int index) {
-        for (int i = 0; i < bindPairs.length; i++) {
-            if (bindPairs[i].inIndex == index) {
-                return i;
-            }
-        }
-        return -1;
+  int findBindPairForInStream(final int index) {
+    for (int i = 0; i < bindPairs.length; i++) {
+      if (bindPairs[i].inIndex == index) {
+        return i;
+      }
     }
+    return -1;
+  }
 
-    int findBindPairForOutStream(final int index) {
-        for (int i = 0; i < bindPairs.length; i++) {
-            if (bindPairs[i].outIndex == index) {
-                return i;
-            }
-        }
-        return -1;
+  int findBindPairForOutStream(final int index) {
+    for (int i = 0; i < bindPairs.length; i++) {
+      if (bindPairs[i].outIndex == index) {
+        return i;
+      }
     }
+    return -1;
+  }
 
-    long getUnpackSize() {
-        if (totalOutputStreams == 0) {
-            return 0;
-        }
-        for (int i = ((int)totalOutputStreams) - 1; i >= 0; i--) {
-            if (findBindPairForOutStream(i) < 0) {
-                return unpackSizes[i];
-            }
-        }
-        return 0;
+  long getUnpackSize() {
+    if (totalOutputStreams == 0) {
+      return 0;
+    }
+    for (int i = ((int) totalOutputStreams) - 1; i >= 0; i--) {
+      if (findBindPairForOutStream(i) < 0) {
+        return unpackSizes[i];
+      }
     }
+    return 0;
+  }
 
-    long getUnpackSizeForCoder(final Coder coder) {
-        if (coders != null) {
-            for (int i = 0; i < coders.length; i++) {
-                if (coders[i] == coder) {
-                    return unpackSizes[i];
-                }
-            }
+  long getUnpackSizeForCoder(final Coder coder) {
+    if (coders != null) {
+      for (int i = 0; i < coders.length; i++) {
+        if (coders[i] == coder) {
+          return unpackSizes[i];
         }
-        return 0;
+      }
     }
+    return 0;
+  }
 
-    @Override
-    public String toString() {
-        return "Folder with " + coders.length + " coders, " + totalInputStreams
-            + " input streams, " + totalOutputStreams + " output streams, "
-            + bindPairs.length + " bind pairs, " + packedStreams.length
-            + " packed streams, " + unpackSizes.length + " unpack sizes, "
-            + (hasCrc ? "with CRC " + crc : "without CRC")
-            + " and " + numUnpackSubStreams + " unpack streams";
-    }
+  @Override
+  public String toString() {
+    return "Folder with "
+        + coders.length
+        + " coders, "
+        + totalInputStreams
+        + " input streams, "
+        + totalOutputStreams
+        + " output streams, "
+        + bindPairs.length
+        + " bind pairs, "
+        + packedStreams.length
+        + " packed streams, "
+        + unpackSizes.length
+        + " unpack sizes, "
+        + (hasCrc ? "with CRC " + crc : "without CRC")
+        + " and "
+        + numUnpackSubStreams
+        + " unpack streams";
+  }
 }
-
diff --git a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/LZMA2Decoder.java b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/LZMA2Decoder.java
index b0042c58e..582b2b5d5 100644
--- a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/LZMA2Decoder.java
+++ b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/LZMA2Decoder.java
@@ -1,101 +1,106 @@
 /*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * This file is part of Amaze File Manager.
  *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
  *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
+
 package com.amaze.filemanager.filesystem.compressed.sevenz;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 
-import org.tukaani.xz.FinishableWrapperOutputStream;
 import org.tukaani.xz.FinishableOutputStream;
+import org.tukaani.xz.FinishableWrapperOutputStream;
 import org.tukaani.xz.LZMA2InputStream;
 import org.tukaani.xz.LZMA2Options;
 
 class LZMA2Decoder extends CoderBase {
-    LZMA2Decoder() {
-        super(LZMA2Options.class, Number.class);
-    }
+  LZMA2Decoder() {
+    super(LZMA2Options.class, Number.class);
+  }
 
-    @Override
-    InputStream decode(final String archiveName, final InputStream in, final long uncompressedLength,
-            final Coder coder, final byte[] password) throws IOException {
-        try {
-            final int dictionarySize = getDictionarySize(coder);
-            return new LZMA2InputStream(in, dictionarySize);
-        } catch (final IllegalArgumentException ex) {
-            throw new IOException(ex.getMessage());
-        }
+  @Override
+  InputStream decode(
+      final String archiveName,
+      final InputStream in,
+      final long uncompressedLength,
+      final Coder coder,
+      final byte[] password)
+      throws IOException {
+    try {
+      final int dictionarySize = getDictionarySize(coder);
+      return new LZMA2InputStream(in, dictionarySize);
+    } catch (final IllegalArgumentException ex) {
+      throw new IOException(ex.getMessage());
     }
+  }
 
-    @Override
-    OutputStream encode(final OutputStream out, final Object opts)
-        throws IOException {
-        final LZMA2Options options = getOptions(opts);
-        final FinishableOutputStream wrapped = new FinishableWrapperOutputStream(out);
-        return options.getOutputStream(wrapped);
-    }
+  @Override
+  OutputStream encode(final OutputStream out, final Object opts) throws IOException {
+    final LZMA2Options options = getOptions(opts);
+    final FinishableOutputStream wrapped = new FinishableWrapperOutputStream(out);
+    return options.getOutputStream(wrapped);
+  }
 
-    @Override
-    byte[] getOptionsAsProperties(final Object opts) {
-        final int dictSize = getDictSize(opts);
-        final int lead = Integer.numberOfLeadingZeros(dictSize);
-        final int secondBit = (dictSize >>> (30 - lead)) - 2;
-        return new byte[] {
-            (byte) ((19 - lead) * 2 + secondBit)
-        };
-    }
+  @Override
+  byte[] getOptionsAsProperties(final Object opts) {
+    final int dictSize = getDictSize(opts);
+    final int lead = Integer.numberOfLeadingZeros(dictSize);
+    final int secondBit = (dictSize >>> (30 - lead)) - 2;
+    return new byte[] {(byte) ((19 - lead) * 2 + secondBit)};
+  }
 
-    @Override
-    Object getOptionsFromCoder(final Coder coder, final InputStream in) {
-        return getDictionarySize(coder);
-    }
+  @Override
+  Object getOptionsFromCoder(final Coder coder, final InputStream in) {
+    return getDictionarySize(coder);
+  }
 
-    private int getDictSize(final Object opts) {
-        if (opts instanceof LZMA2Options) {
-            return ((LZMA2Options) opts).getDictSize();
-        }
-        return numberOptionOrDefault(opts);
+  private int getDictSize(final Object opts) {
+    if (opts instanceof LZMA2Options) {
+      return ((LZMA2Options) opts).getDictSize();
     }
+    return numberOptionOrDefault(opts);
+  }
 
-    private int getDictionarySize(final Coder coder) throws IllegalArgumentException {
-        final int dictionarySizeBits = 0xff & coder.properties[0];
-        if ((dictionarySizeBits & (~0x3f)) != 0) {
-            throw new IllegalArgumentException("Unsupported LZMA2 property bits");
-        }
-        if (dictionarySizeBits > 40) {
-            throw new IllegalArgumentException("Dictionary larger than 4GiB maximum size");
-        }
-        if (dictionarySizeBits == 40) {
-            return 0xFFFFffff;
-        }
-        return (2 | (dictionarySizeBits & 0x1)) << (dictionarySizeBits / 2 + 11);
+  private int getDictionarySize(final Coder coder) throws IllegalArgumentException {
+    final int dictionarySizeBits = 0xff & coder.properties[0];
+    if ((dictionarySizeBits & (~0x3f)) != 0) {
+      throw new IllegalArgumentException("Unsupported LZMA2 property bits");
     }
-
-    private LZMA2Options getOptions(final Object opts) throws IOException {
-        if (opts instanceof LZMA2Options) {
-            return (LZMA2Options) opts;
-        }
-        final LZMA2Options options = new LZMA2Options();
-        options.setDictSize(numberOptionOrDefault(opts));
-        return options;
+    if (dictionarySizeBits > 40) {
+      throw new IllegalArgumentException("Dictionary larger than 4GiB maximum size");
     }
+    if (dictionarySizeBits == 40) {
+      return 0xFFFFffff;
+    }
+    return (2 | (dictionarySizeBits & 0x1)) << (dictionarySizeBits / 2 + 11);
+  }
 
-    private int numberOptionOrDefault(final Object opts) {
-        return numberOptionOrDefault(opts, LZMA2Options.DICT_SIZE_DEFAULT);
+  private LZMA2Options getOptions(final Object opts) throws IOException {
+    if (opts instanceof LZMA2Options) {
+      return (LZMA2Options) opts;
     }
+    final LZMA2Options options = new LZMA2Options();
+    options.setDictSize(numberOptionOrDefault(opts));
+    return options;
+  }
+
+  private int numberOptionOrDefault(final Object opts) {
+    return numberOptionOrDefault(opts, LZMA2Options.DICT_SIZE_DEFAULT);
+  }
 }
diff --git a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/LZMADecoder.java b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/LZMADecoder.java
index df28bc9a6..3d14e20e9 100644
--- a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/LZMADecoder.java
+++ b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/LZMADecoder.java
@@ -1,20 +1,23 @@
 /*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * This file is part of Amaze File Manager.
  *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
  *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
+
 package com.amaze.filemanager.filesystem.compressed.sevenz;
 
 import java.io.IOException;
@@ -28,69 +31,73 @@ import org.tukaani.xz.LZMAInputStream;
 import org.tukaani.xz.LZMAOutputStream;
 
 class LZMADecoder extends CoderBase {
-    LZMADecoder() {
-        super(LZMA2Options.class, Number.class);
-    }
+  LZMADecoder() {
+    super(LZMA2Options.class, Number.class);
+  }
 
-    @Override
-    InputStream decode(final String archiveName, final InputStream in, final long uncompressedLength,
-            final Coder coder, final byte[] password) throws IOException {
-        final byte propsByte = coder.properties[0];
-        final int dictSize = getDictionarySize(coder);
-        if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {
-            throw new IOException("Dictionary larger than 4GiB maximum size used in " + archiveName);
-        }
-        return new LZMAInputStream(in, uncompressedLength, propsByte, dictSize);
+  @Override
+  InputStream decode(
+      final String archiveName,
+      final InputStream in,
+      final long uncompressedLength,
+      final Coder coder,
+      final byte[] password)
+      throws IOException {
+    final byte propsByte = coder.properties[0];
+    final int dictSize = getDictionarySize(coder);
+    if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {
+      throw new IOException("Dictionary larger than 4GiB maximum size used in " + archiveName);
     }
+    return new LZMAInputStream(in, uncompressedLength, propsByte, dictSize);
+  }
 
-    @SuppressWarnings("resource")
-    @Override
-    OutputStream encode(final OutputStream out, final Object opts)
-        throws IOException {
-        // NOOP as LZMAOutputStream throws an exception in flush
-        return new FlushShieldFilterOutputStream(new LZMAOutputStream(out, getOptions(opts), false));
-    }
+  @SuppressWarnings("resource")
+  @Override
+  OutputStream encode(final OutputStream out, final Object opts) throws IOException {
+    // NOOP as LZMAOutputStream throws an exception in flush
+    return new FlushShieldFilterOutputStream(new LZMAOutputStream(out, getOptions(opts), false));
+  }
 
-    @Override
-    byte[] getOptionsAsProperties(final Object opts) throws IOException {
-        final LZMA2Options options = getOptions(opts);
-        final byte props = (byte) ((options.getPb() * 5 + options.getLp()) * 9 + options.getLc());
-        int dictSize = options.getDictSize();
-        byte[] o = new byte[5];
-        o[0] = props;
-        ByteUtils.toLittleEndian(o, dictSize, 1, 4);
-        return o;
-    }
+  @Override
+  byte[] getOptionsAsProperties(final Object opts) throws IOException {
+    final LZMA2Options options = getOptions(opts);
+    final byte props = (byte) ((options.getPb() * 5 + options.getLp()) * 9 + options.getLc());
+    int dictSize = options.getDictSize();
+    byte[] o = new byte[5];
+    o[0] = props;
+    ByteUtils.toLittleEndian(o, dictSize, 1, 4);
+    return o;
+  }
 
-    @Override
-    Object getOptionsFromCoder(final Coder coder, final InputStream in) throws IOException {
-        final byte propsByte = coder.properties[0];
-        int props = propsByte & 0xFF;
-        int pb = props / (9 * 5);
-        props -= pb * 9 * 5;
-        int lp = props / 9;
-        int lc = props - lp * 9;
-        LZMA2Options opts = new LZMA2Options();
-        opts.setPb(pb);
-        opts.setLcLp(lc, lp);
-        opts.setDictSize(getDictionarySize(coder));
-        return opts;
-    }
+  @Override
+  Object getOptionsFromCoder(final Coder coder, final InputStream in) throws IOException {
+    final byte propsByte = coder.properties[0];
+    int props = propsByte & 0xFF;
+    int pb = props / (9 * 5);
+    props -= pb * 9 * 5;
+    int lp = props / 9;
+    int lc = props - lp * 9;
+    LZMA2Options opts = new LZMA2Options();
+    opts.setPb(pb);
+    opts.setLcLp(lc, lp);
+    opts.setDictSize(getDictionarySize(coder));
+    return opts;
+  }
 
-    private int getDictionarySize(final Coder coder) throws IllegalArgumentException {
-        return (int) ByteUtils.fromLittleEndian(coder.properties, 1, 4);
-    }
+  private int getDictionarySize(final Coder coder) throws IllegalArgumentException {
+    return (int) ByteUtils.fromLittleEndian(coder.properties, 1, 4);
+  }
 
-    private LZMA2Options getOptions(final Object opts) throws IOException {
-        if (opts instanceof LZMA2Options) {
-            return (LZMA2Options) opts;
-        }
-        final LZMA2Options options = new LZMA2Options();
-        options.setDictSize(numberOptionOrDefault(opts));
-        return options;
+  private LZMA2Options getOptions(final Object opts) throws IOException {
+    if (opts instanceof LZMA2Options) {
+      return (LZMA2Options) opts;
     }
+    final LZMA2Options options = new LZMA2Options();
+    options.setDictSize(numberOptionOrDefault(opts));
+    return options;
+  }
 
-    private int numberOptionOrDefault(final Object opts) {
-        return numberOptionOrDefault(opts, LZMA2Options.DICT_SIZE_DEFAULT);
-    }
+  private int numberOptionOrDefault(final Object opts) {
+    return numberOptionOrDefault(opts, LZMA2Options.DICT_SIZE_DEFAULT);
+  }
 }
diff --git a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/NID.java b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/NID.java
index 7cbf998c7..3a4f54e17 100644
--- a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/NID.java
+++ b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/NID.java
@@ -1,47 +1,50 @@
 /*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * This file is part of Amaze File Manager.
  *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
  *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
+
 package com.amaze.filemanager.filesystem.compressed.sevenz;
 
 final class NID {
-    public static final int kEnd = 0x00;
-    public static final int kHeader = 0x01;
-    public static final int kArchiveProperties = 0x02;
-    public static final int kAdditionalStreamsInfo = 0x03;
-    public static final int kMainStreamsInfo = 0x04;
-    public static final int kFilesInfo = 0x05;
-    public static final int kPackInfo = 0x06;
-    public static final int kUnpackInfo = 0x07;
-    public static final int kSubStreamsInfo = 0x08;
-    public static final int kSize = 0x09;
-    public static final int kCRC = 0x0A;
-    public static final int kFolder = 0x0B;
-    public static final int kCodersUnpackSize = 0x0C;
-    public static final int kNumUnpackStream = 0x0D;
-    public static final int kEmptyStream = 0x0E;
-    public static final int kEmptyFile = 0x0F;
-    public static final int kAnti = 0x10;
-    public static final int kName = 0x11;
-    public static final int kCTime = 0x12;
-    public static final int kATime = 0x13;
-    public static final int kMTime = 0x14;
-    public static final int kWinAttributes = 0x15;
-    public static final int kComment = 0x16;
-    public static final int kEncodedHeader = 0x17;
-    public static final int kStartPos = 0x18;
-    public static final int kDummy = 0x19;
+  public static final int kEnd = 0x00;
+  public static final int kHeader = 0x01;
+  public static final int kArchiveProperties = 0x02;
+  public static final int kAdditionalStreamsInfo = 0x03;
+  public static final int kMainStreamsInfo = 0x04;
+  public static final int kFilesInfo = 0x05;
+  public static final int kPackInfo = 0x06;
+  public static final int kUnpackInfo = 0x07;
+  public static final int kSubStreamsInfo = 0x08;
+  public static final int kSize = 0x09;
+  public static final int kCRC = 0x0A;
+  public static final int kFolder = 0x0B;
+  public static final int kCodersUnpackSize = 0x0C;
+  public static final int kNumUnpackStream = 0x0D;
+  public static final int kEmptyStream = 0x0E;
+  public static final int kEmptyFile = 0x0F;
+  public static final int kAnti = 0x10;
+  public static final int kName = 0x11;
+  public static final int kCTime = 0x12;
+  public static final int kATime = 0x13;
+  public static final int kMTime = 0x14;
+  public static final int kWinAttributes = 0x15;
+  public static final int kComment = 0x16;
+  public static final int kEncodedHeader = 0x17;
+  public static final int kStartPos = 0x18;
+  public static final int kDummy = 0x19;
 }
diff --git a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/SevenZArchiveEntry.java b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/SevenZArchiveEntry.java
index 2f7d448ee..d69ceaf5d 100644
--- a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/SevenZArchiveEntry.java
+++ b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/SevenZArchiveEntry.java
@@ -1,20 +1,23 @@
 /*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * This file is part of Amaze File Manager.
  *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
  *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
+
 package com.amaze.filemanager.filesystem.compressed.sevenz;
 
 import java.util.Calendar;
@@ -26,490 +29,506 @@ import java.util.TimeZone;
 import org.apache.commons.compress.archivers.ArchiveEntry;
 
 /**
- * An entry in a 7z archive.
+ * An entry in a 7z archive. @NotThreadSafe
  *
- * @NotThreadSafe
  * @since 1.6
  */
 public class SevenZArchiveEntry implements ArchiveEntry {
-    private String name;
-    private boolean hasStream;
-    private boolean isDirectory;
-    private boolean isAntiItem;
-    private boolean hasCreationDate;
-    private boolean hasLastModifiedDate;
-    private boolean hasAccessDate;
-    private long creationDate;
-    private long lastModifiedDate;
-    private long accessDate;
-    private boolean hasWindowsAttributes;
-    private int windowsAttributes;
-    private boolean hasCrc;
-    private long crc, compressedCrc;
-    private long size, compressedSize;
-    private Iterable<? extends SevenZMethodConfiguration> contentMethods;
-
-    public SevenZArchiveEntry() {
-    }
-
-    /**
-     * Get this entry's name.
-     *
-     * <p>This method returns the raw name as it is stored inside of the archive.</p>
-     *
-     * @return This entry's name.
-     */
-    @Override
-    public String getName() {
-        return name;
-    }
-
-    /**
-     * Set this entry's name.
-     *
-     * @param name This entry's new name.
-     */
-    public void setName(final String name) {
-        this.name = name;
-    }
-
-    /**
-     * Whether there is any content associated with this entry.
-     * @return whether there is any content associated with this entry.
-     */
-    public boolean hasStream() {
-        return hasStream;
-    }
-
-    /**
-     * Sets whether there is any content associated with this entry.
-     * @param hasStream whether there is any content associated with this entry.
-     */
-    public void setHasStream(final boolean hasStream) {
-        this.hasStream = hasStream;
-    }
-
-    /**
-     * Return whether or not this entry represents a directory.
-     *
-     * @return True if this entry is a directory.
-     */
-    @Override
-    public boolean isDirectory() {
-        return isDirectory;
-    }
-
-    /**
-     * Sets whether or not this entry represents a directory.
-     *
-     * @param isDirectory True if this entry is a directory.
-     */
-    public void setDirectory(final boolean isDirectory) {
-        this.isDirectory = isDirectory;
-    }
-
-    /**
-     * Indicates whether this is an "anti-item" used in differential backups,
-     * meaning it should delete the same file from a previous backup.
-     * @return true if it is an anti-item, false otherwise
-     */
-    public boolean isAntiItem() {
-        return isAntiItem;
-    }
-
-    /**
-     * Sets whether this is an "anti-item" used in differential backups,
-     * meaning it should delete the same file from a previous backup.
-     * @param isAntiItem true if it is an anti-item, false otherwise
-     */
-    public void setAntiItem(final boolean isAntiItem) {
-        this.isAntiItem = isAntiItem;
-    }
-
-    /**
-     * Returns whether this entry has got a creation date at all.
-     * @return whether the entry has got a creation date
-     */
-    public boolean getHasCreationDate() {
-        return hasCreationDate;
-    }
-
-    /**
-     * Sets whether this entry has got a creation date at all.
-     * @param hasCreationDate whether the entry has got a creation date
-     */
-    public void setHasCreationDate(final boolean hasCreationDate) {
-        this.hasCreationDate = hasCreationDate;
-    }
-
-    /**
-     * Gets the creation date.
-     * @throws UnsupportedOperationException if the entry hasn't got a
-     * creation date.
-     * @return the creation date
-     */
-    public Date getCreationDate() {
-        if (hasCreationDate) {
-            return ntfsTimeToJavaTime(creationDate);
-        }
-        throw new UnsupportedOperationException(
-                "The entry doesn't have this timestamp");
-    }
-
-    /**
-     * Sets the creation date using NTFS time (100 nanosecond units
-     * since 1 January 1601)
-     * @param ntfsCreationDate the creation date
-     */
-    public void setCreationDate(final long ntfsCreationDate) {
-        this.creationDate = ntfsCreationDate;
-    }
-
-    /**
-     * Sets the creation date,
-     * @param creationDate the creation date
-     */
-    public void setCreationDate(final Date creationDate) {
-        hasCreationDate = creationDate != null;
-        if (hasCreationDate) {
-            this.creationDate = javaTimeToNtfsTime(creationDate);
-        }
-    }
-
-    /**
-     * Returns whether this entry has got a last modified date at all.
-     * @return whether this entry has got a last modified date at all
-     */
-    public boolean getHasLastModifiedDate() {
-        return hasLastModifiedDate;
-    }
-
-    /**
-     * Sets whether this entry has got a last modified date at all.
-     * @param hasLastModifiedDate whether this entry has got a last
-     * modified date at all
-     */
-    public void setHasLastModifiedDate(final boolean hasLastModifiedDate) {
-        this.hasLastModifiedDate = hasLastModifiedDate;
-    }
-
-    /**
-     * Gets the last modified date.
-     * @throws UnsupportedOperationException if the entry hasn't got a
-     * last modified date.
-     * @return the last modified date
-     */
-    @Override
-    public Date getLastModifiedDate() {
-        if (hasLastModifiedDate) {
-            return ntfsTimeToJavaTime(lastModifiedDate);
-        }
-        throw new UnsupportedOperationException(
-                "The entry doesn't have this timestamp");
-    }
-
-    /**
-     * Sets the last modified date using NTFS time (100 nanosecond
-     * units since 1 January 1601)
-     * @param ntfsLastModifiedDate the last modified date
-     */
-    public void setLastModifiedDate(final long ntfsLastModifiedDate) {
-        this.lastModifiedDate = ntfsLastModifiedDate;
-    }
-
-    /**
-     * Sets the last modified date,
-     * @param lastModifiedDate the last modified date
-     */
-    public void setLastModifiedDate(final Date lastModifiedDate) {
-        hasLastModifiedDate = lastModifiedDate != null;
-        if (hasLastModifiedDate) {
-            this.lastModifiedDate = javaTimeToNtfsTime(lastModifiedDate);
-        }
-    }
-
-    /**
-     * Returns whether this entry has got an access date at all.
-     * @return whether this entry has got an access date at all.
-     */
-    public boolean getHasAccessDate() {
-        return hasAccessDate;
-    }
-
-    /**
-     * Sets whether this entry has got an access date at all.
-     * @param hasAcessDate whether this entry has got an access date at all.
-     */
-    public void setHasAccessDate(final boolean hasAcessDate) {
-        this.hasAccessDate = hasAcessDate;
-    }
-
-    /**
-     * Gets the access date.
-     * @throws UnsupportedOperationException if the entry hasn't got a
-     * access date.
-     * @return the access date
-     */
-    public Date getAccessDate() {
-        if (hasAccessDate) {
-            return ntfsTimeToJavaTime(accessDate);
-        }
-        throw new UnsupportedOperationException(
-                "The entry doesn't have this timestamp");
-    }
-
-    /**
-     * Sets the access date using NTFS time (100 nanosecond units
-     * since 1 January 1601)
-     * @param ntfsAccessDate the access date
-     */
-    public void setAccessDate(final long ntfsAccessDate) {
-        this.accessDate = ntfsAccessDate;
-    }
-
-    /**
-     * Sets the access date,
-     * @param accessDate the access date
-     */
-    public void setAccessDate(final Date accessDate) {
-        hasAccessDate = accessDate != null;
-        if (hasAccessDate) {
-            this.accessDate = javaTimeToNtfsTime(accessDate);
-        }
-    }
-
-    /**
-     * Returns whether this entry has windows attributes.
-     * @return whether this entry has windows attributes.
-     */
-    public boolean getHasWindowsAttributes() {
-        return hasWindowsAttributes;
-    }
-
-    /**
-     * Sets whether this entry has windows attributes.
-     * @param hasWindowsAttributes whether this entry has windows attributes.
-     */
-    public void setHasWindowsAttributes(final boolean hasWindowsAttributes) {
-        this.hasWindowsAttributes = hasWindowsAttributes;
-    }
-
-    /**
-     * Gets the windows attributes.
-     * @return the windows attributes
-     */
-    public int getWindowsAttributes() {
-        return windowsAttributes;
-    }
-
-    /**
-     * Sets the windows attributes.
-     * @param windowsAttributes the windows attributes
-     */
-    public void setWindowsAttributes(final int windowsAttributes) {
-        this.windowsAttributes = windowsAttributes;
-    }
-
-    /**
-     * Returns whether this entry has got a crc.
-     *
-     * <p>In general entries without streams don't have a CRC either.</p>
-     * @return whether this entry has got a crc.
-     */
-    public boolean getHasCrc() {
-        return hasCrc;
-    }
-
-    /**
-     * Sets whether this entry has got a crc.
-     * @param hasCrc whether this entry has got a crc.
-     */
-    public void setHasCrc(final boolean hasCrc) {
-        this.hasCrc = hasCrc;
-    }
-
-    /**
-     * Gets the CRC.
-     * @deprecated use getCrcValue instead.
-     * @return the CRC
-     */
-    @Deprecated
-    public int getCrc() {
-        return (int) crc;
-    }
-
-    /**
-     * Sets the CRC.
-     * @deprecated use setCrcValue instead.
-     * @param crc the CRC
-     */
-    @Deprecated
-    public void setCrc(final int crc) {
-        this.crc = crc;
-    }
-
-    /**
-     * Gets the CRC.
-     * @since Compress 1.7
-     * @return the CRC
-     */
-    public long getCrcValue() {
-        return crc;
-    }
-
-    /**
-     * Sets the CRC.
-     * @since Compress 1.7
-     * @param crc the CRC
-     */
-    public void setCrcValue(final long crc) {
-        this.crc = crc;
-    }
-
-    /**
-     * Gets the compressed CRC.
-     * @deprecated use getCompressedCrcValue instead.
-     * @return the compressed CRC
-     */
-    @Deprecated
-    int getCompressedCrc() {
-        return (int) compressedCrc;
-    }
-
-    /**
-     * Sets the compressed CRC.
-     * @deprecated use setCompressedCrcValue instead.
-     * @param crc the CRC
-     */
-    @Deprecated
-    void setCompressedCrc(final int crc) {
-        this.compressedCrc = crc;
-    }
-
-    /**
-     * Gets the compressed CRC.
-     * @since Compress 1.7
-     * @return the CRC
-     */
-    long getCompressedCrcValue() {
-        return compressedCrc;
-    }
-
-    /**
-     * Sets the compressed CRC.
-     * @since Compress 1.7
-     * @param crc the CRC
-     */
-    void setCompressedCrcValue(final long crc) {
-        this.compressedCrc = crc;
-    }
-
-    /**
-     * Get this entry's file size.
-     *
-     * @return This entry's file size.
-     */
-    @Override
-    public long getSize() {
-        return size;
-    }
-
-    /**
-     * Set this entry's file size.
-     *
-     * @param size This entry's new file size.
-     */
-    public void setSize(final long size) {
-        this.size = size;
-    }
-
-    /**
-     * Get this entry's compressed file size.
-     *
-     * @return This entry's compressed file size.
-     */
-    long getCompressedSize() {
-        return compressedSize;
-    }
-
-    /**
-     * Set this entry's compressed file size.
-     *
-     * @param size This entry's new compressed file size.
-     */
-    void setCompressedSize(final long size) {
-        this.compressedSize = size;
-    }
-
-    /**
-     * Sets the (compression) methods to use for entry's content - the
-     * default is LZMA2.
-     *
-     * <p>Currently only {@link SevenZMethod#COPY}, {@link
-     * SevenZMethod#LZMA2}, {@link SevenZMethod#BZIP2} and {@link
-     * SevenZMethod#DEFLATE} are supported when writing archives.</p>
-     *
-     * <p>The methods will be consulted in iteration order to create
-     * the final output.</p>
-     *
-     * @param methods the methods to use for the content
-     * @since 1.8
-     */
-    public void setContentMethods(final Iterable<? extends SevenZMethodConfiguration> methods) {
-        if (methods != null) {
-            final LinkedList<SevenZMethodConfiguration> l = new LinkedList<>();
-            for (final SevenZMethodConfiguration m : methods) {
-                l.addLast(m);
-            }
-            contentMethods = Collections.unmodifiableList(l);
-        } else {
-            contentMethods = null;
-        }
-    }
-
-    /**
-     * Gets the (compression) methods to use for entry's content - the
-     * default is LZMA2.
-     *
-     * <p>Currently only {@link SevenZMethod#COPY}, {@link
-     * SevenZMethod#LZMA2}, {@link SevenZMethod#BZIP2} and {@link
-     * SevenZMethod#DEFLATE} are supported when writing archives.</p>
-     *
-     * <p>The methods will be consulted in iteration order to create
-     * the final output.</p>
-     *
-     * @since 1.8
-     * @return the methods to use for the content
-     */
-    public Iterable<? extends SevenZMethodConfiguration> getContentMethods() {
-        return contentMethods;
-    }
-
-    /**
-     * Converts NTFS time (100 nanosecond units since 1 January 1601)
-     * to Java time.
-     * @param ntfsTime the NTFS time in 100 nanosecond units
-     * @return the Java time
-     */
-    public static Date ntfsTimeToJavaTime(final long ntfsTime) {
-        final Calendar ntfsEpoch = Calendar.getInstance();
-        ntfsEpoch.setTimeZone(TimeZone.getTimeZone("GMT+0"));
-        ntfsEpoch.set(1601, 0, 1, 0, 0, 0);
-        ntfsEpoch.set(Calendar.MILLISECOND, 0);
-        final long realTime = ntfsEpoch.getTimeInMillis() + (ntfsTime / (10*1000));
-        return new Date(realTime);
-    }
-
-    /**
-     * Converts Java time to NTFS time.
-     * @param date the Java time
-     * @return the NTFS time
-     */
-    public static long javaTimeToNtfsTime(final Date date) {
-        final Calendar ntfsEpoch = Calendar.getInstance();
-        ntfsEpoch.setTimeZone(TimeZone.getTimeZone("GMT+0"));
-        ntfsEpoch.set(1601, 0, 1, 0, 0, 0);
-        ntfsEpoch.set(Calendar.MILLISECOND, 0);
-        return ((date.getTime() - ntfsEpoch.getTimeInMillis())* 1000 * 10);
-    }
+  private String name;
+  private boolean hasStream;
+  private boolean isDirectory;
+  private boolean isAntiItem;
+  private boolean hasCreationDate;
+  private boolean hasLastModifiedDate;
+  private boolean hasAccessDate;
+  private long creationDate;
+  private long lastModifiedDate;
+  private long accessDate;
+  private boolean hasWindowsAttributes;
+  private int windowsAttributes;
+  private boolean hasCrc;
+  private long crc, compressedCrc;
+  private long size, compressedSize;
+  private Iterable<? extends SevenZMethodConfiguration> contentMethods;
+
+  public SevenZArchiveEntry() {}
+
+  /**
+   * Get this entry's name.
+   *
+   * <p>This method returns the raw name as it is stored inside of the archive.
+   *
+   * @return This entry's name.
+   */
+  @Override
+  public String getName() {
+    return name;
+  }
+
+  /**
+   * Set this entry's name.
+   *
+   * @param name This entry's new name.
+   */
+  public void setName(final String name) {
+    this.name = name;
+  }
+
+  /**
+   * Whether there is any content associated with this entry.
+   *
+   * @return whether there is any content associated with this entry.
+   */
+  public boolean hasStream() {
+    return hasStream;
+  }
+
+  /**
+   * Sets whether there is any content associated with this entry.
+   *
+   * @param hasStream whether there is any content associated with this entry.
+   */
+  public void setHasStream(final boolean hasStream) {
+    this.hasStream = hasStream;
+  }
+
+  /**
+   * Return whether or not this entry represents a directory.
+   *
+   * @return True if this entry is a directory.
+   */
+  @Override
+  public boolean isDirectory() {
+    return isDirectory;
+  }
+
+  /**
+   * Sets whether or not this entry represents a directory.
+   *
+   * @param isDirectory True if this entry is a directory.
+   */
+  public void setDirectory(final boolean isDirectory) {
+    this.isDirectory = isDirectory;
+  }
+
+  /**
+   * Indicates whether this is an "anti-item" used in differential backups, meaning it should delete
+   * the same file from a previous backup.
+   *
+   * @return true if it is an anti-item, false otherwise
+   */
+  public boolean isAntiItem() {
+    return isAntiItem;
+  }
+
+  /**
+   * Sets whether this is an "anti-item" used in differential backups, meaning it should delete the
+   * same file from a previous backup.
+   *
+   * @param isAntiItem true if it is an anti-item, false otherwise
+   */
+  public void setAntiItem(final boolean isAntiItem) {
+    this.isAntiItem = isAntiItem;
+  }
+
+  /**
+   * Returns whether this entry has got a creation date at all.
+   *
+   * @return whether the entry has got a creation date
+   */
+  public boolean getHasCreationDate() {
+    return hasCreationDate;
+  }
+
+  /**
+   * Sets whether this entry has got a creation date at all.
+   *
+   * @param hasCreationDate whether the entry has got a creation date
+   */
+  public void setHasCreationDate(final boolean hasCreationDate) {
+    this.hasCreationDate = hasCreationDate;
+  }
+
+  /**
+   * Gets the creation date.
+   *
+   * @throws UnsupportedOperationException if the entry hasn't got a creation date.
+   * @return the creation date
+   */
+  public Date getCreationDate() {
+    if (hasCreationDate) {
+      return ntfsTimeToJavaTime(creationDate);
+    }
+    throw new UnsupportedOperationException("The entry doesn't have this timestamp");
+  }
+
+  /**
+   * Sets the creation date using NTFS time (100 nanosecond units since 1 January 1601)
+   *
+   * @param ntfsCreationDate the creation date
+   */
+  public void setCreationDate(final long ntfsCreationDate) {
+    this.creationDate = ntfsCreationDate;
+  }
+
+  /**
+   * Sets the creation date,
+   *
+   * @param creationDate the creation date
+   */
+  public void setCreationDate(final Date creationDate) {
+    hasCreationDate = creationDate != null;
+    if (hasCreationDate) {
+      this.creationDate = javaTimeToNtfsTime(creationDate);
+    }
+  }
+
+  /**
+   * Returns whether this entry has got a last modified date at all.
+   *
+   * @return whether this entry has got a last modified date at all
+   */
+  public boolean getHasLastModifiedDate() {
+    return hasLastModifiedDate;
+  }
+
+  /**
+   * Sets whether this entry has got a last modified date at all.
+   *
+   * @param hasLastModifiedDate whether this entry has got a last modified date at all
+   */
+  public void setHasLastModifiedDate(final boolean hasLastModifiedDate) {
+    this.hasLastModifiedDate = hasLastModifiedDate;
+  }
+
+  /**
+   * Gets the last modified date.
+   *
+   * @throws UnsupportedOperationException if the entry hasn't got a last modified date.
+   * @return the last modified date
+   */
+  @Override
+  public Date getLastModifiedDate() {
+    if (hasLastModifiedDate) {
+      return ntfsTimeToJavaTime(lastModifiedDate);
+    }
+    throw new UnsupportedOperationException("The entry doesn't have this timestamp");
+  }
+
+  /**
+   * Sets the last modified date using NTFS time (100 nanosecond units since 1 January 1601)
+   *
+   * @param ntfsLastModifiedDate the last modified date
+   */
+  public void setLastModifiedDate(final long ntfsLastModifiedDate) {
+    this.lastModifiedDate = ntfsLastModifiedDate;
+  }
+
+  /**
+   * Sets the last modified date,
+   *
+   * @param lastModifiedDate the last modified date
+   */
+  public void setLastModifiedDate(final Date lastModifiedDate) {
+    hasLastModifiedDate = lastModifiedDate != null;
+    if (hasLastModifiedDate) {
+      this.lastModifiedDate = javaTimeToNtfsTime(lastModifiedDate);
+    }
+  }
+
+  /**
+   * Returns whether this entry has got an access date at all.
+   *
+   * @return whether this entry has got an access date at all.
+   */
+  public boolean getHasAccessDate() {
+    return hasAccessDate;
+  }
+
+  /**
+   * Sets whether this entry has got an access date at all.
+   *
+   * @param hasAcessDate whether this entry has got an access date at all.
+   */
+  public void setHasAccessDate(final boolean hasAcessDate) {
+    this.hasAccessDate = hasAcessDate;
+  }
+
+  /**
+   * Gets the access date.
+   *
+   * @throws UnsupportedOperationException if the entry hasn't got a access date.
+   * @return the access date
+   */
+  public Date getAccessDate() {
+    if (hasAccessDate) {
+      return ntfsTimeToJavaTime(accessDate);
+    }
+    throw new UnsupportedOperationException("The entry doesn't have this timestamp");
+  }
+
+  /**
+   * Sets the access date using NTFS time (100 nanosecond units since 1 January 1601)
+   *
+   * @param ntfsAccessDate the access date
+   */
+  public void setAccessDate(final long ntfsAccessDate) {
+    this.accessDate = ntfsAccessDate;
+  }
+
+  /**
+   * Sets the access date,
+   *
+   * @param accessDate the access date
+   */
+  public void setAccessDate(final Date accessDate) {
+    hasAccessDate = accessDate != null;
+    if (hasAccessDate) {
+      this.accessDate = javaTimeToNtfsTime(accessDate);
+    }
+  }
+
+  /**
+   * Returns whether this entry has windows attributes.
+   *
+   * @return whether this entry has windows attributes.
+   */
+  public boolean getHasWindowsAttributes() {
+    return hasWindowsAttributes;
+  }
+
+  /**
+   * Sets whether this entry has windows attributes.
+   *
+   * @param hasWindowsAttributes whether this entry has windows attributes.
+   */
+  public void setHasWindowsAttributes(final boolean hasWindowsAttributes) {
+    this.hasWindowsAttributes = hasWindowsAttributes;
+  }
+
+  /**
+   * Gets the windows attributes.
+   *
+   * @return the windows attributes
+   */
+  public int getWindowsAttributes() {
+    return windowsAttributes;
+  }
+
+  /**
+   * Sets the windows attributes.
+   *
+   * @param windowsAttributes the windows attributes
+   */
+  public void setWindowsAttributes(final int windowsAttributes) {
+    this.windowsAttributes = windowsAttributes;
+  }
+
+  /**
+   * Returns whether this entry has got a crc.
+   *
+   * <p>In general entries without streams don't have a CRC either.
+   *
+   * @return whether this entry has got a crc.
+   */
+  public boolean getHasCrc() {
+    return hasCrc;
+  }
+
+  /**
+   * Sets whether this entry has got a crc.
+   *
+   * @param hasCrc whether this entry has got a crc.
+   */
+  public void setHasCrc(final boolean hasCrc) {
+    this.hasCrc = hasCrc;
+  }
+
+  /**
+   * Gets the CRC.
+   *
+   * @deprecated use getCrcValue instead.
+   * @return the CRC
+   */
+  @Deprecated
+  public int getCrc() {
+    return (int) crc;
+  }
+
+  /**
+   * Sets the CRC.
+   *
+   * @deprecated use setCrcValue instead.
+   * @param crc the CRC
+   */
+  @Deprecated
+  public void setCrc(final int crc) {
+    this.crc = crc;
+  }
+
+  /**
+   * Gets the CRC.
+   *
+   * @since Compress 1.7
+   * @return the CRC
+   */
+  public long getCrcValue() {
+    return crc;
+  }
+
+  /**
+   * Sets the CRC.
+   *
+   * @since Compress 1.7
+   * @param crc the CRC
+   */
+  public void setCrcValue(final long crc) {
+    this.crc = crc;
+  }
+
+  /**
+   * Gets the compressed CRC.
+   *
+   * @deprecated use getCompressedCrcValue instead.
+   * @return the compressed CRC
+   */
+  @Deprecated
+  int getCompressedCrc() {
+    return (int) compressedCrc;
+  }
+
+  /**
+   * Sets the compressed CRC.
+   *
+   * @deprecated use setCompressedCrcValue instead.
+   * @param crc the CRC
+   */
+  @Deprecated
+  void setCompressedCrc(final int crc) {
+    this.compressedCrc = crc;
+  }
+
+  /**
+   * Gets the compressed CRC.
+   *
+   * @since Compress 1.7
+   * @return the CRC
+   */
+  long getCompressedCrcValue() {
+    return compressedCrc;
+  }
+
+  /**
+   * Sets the compressed CRC.
+   *
+   * @since Compress 1.7
+   * @param crc the CRC
+   */
+  void setCompressedCrcValue(final long crc) {
+    this.compressedCrc = crc;
+  }
+
+  /**
+   * Get this entry's file size.
+   *
+   * @return This entry's file size.
+   */
+  @Override
+  public long getSize() {
+    return size;
+  }
+
+  /**
+   * Set this entry's file size.
+   *
+   * @param size This entry's new file size.
+   */
+  public void setSize(final long size) {
+    this.size = size;
+  }
+
+  /**
+   * Get this entry's compressed file size.
+   *
+   * @return This entry's compressed file size.
+   */
+  long getCompressedSize() {
+    return compressedSize;
+  }
+
+  /**
+   * Set this entry's compressed file size.
+   *
+   * @param size This entry's new compressed file size.
+   */
+  void setCompressedSize(final long size) {
+    this.compressedSize = size;
+  }
+
+  /**
+   * Sets the (compression) methods to use for entry's content - the default is LZMA2.
+   *
+   * <p>Currently only {@link SevenZMethod#COPY}, {@link SevenZMethod#LZMA2}, {@link
+   * SevenZMethod#BZIP2} and {@link SevenZMethod#DEFLATE} are supported when writing archives.
+   *
+   * <p>The methods will be consulted in iteration order to create the final output.
+   *
+   * @param methods the methods to use for the content
+   * @since 1.8
+   */
+  public void setContentMethods(final Iterable<? extends SevenZMethodConfiguration> methods) {
+    if (methods != null) {
+      final LinkedList<SevenZMethodConfiguration> l = new LinkedList<>();
+      for (final SevenZMethodConfiguration m : methods) {
+        l.addLast(m);
+      }
+      contentMethods = Collections.unmodifiableList(l);
+    } else {
+      contentMethods = null;
+    }
+  }
+
+  /**
+   * Gets the (compression) methods to use for entry's content - the default is LZMA2.
+   *
+   * <p>Currently only {@link SevenZMethod#COPY}, {@link SevenZMethod#LZMA2}, {@link
+   * SevenZMethod#BZIP2} and {@link SevenZMethod#DEFLATE} are supported when writing archives.
+   *
+   * <p>The methods will be consulted in iteration order to create the final output.
+   *
+   * @since 1.8
+   * @return the methods to use for the content
+   */
+  public Iterable<? extends SevenZMethodConfiguration> getContentMethods() {
+    return contentMethods;
+  }
+
+  /**
+   * Converts NTFS time (100 nanosecond units since 1 January 1601) to Java time.
+   *
+   * @param ntfsTime the NTFS time in 100 nanosecond units
+   * @return the Java time
+   */
+  public static Date ntfsTimeToJavaTime(final long ntfsTime) {
+    final Calendar ntfsEpoch = Calendar.getInstance();
+    ntfsEpoch.setTimeZone(TimeZone.getTimeZone("GMT+0"));
+    ntfsEpoch.set(1601, 0, 1, 0, 0, 0);
+    ntfsEpoch.set(Calendar.MILLISECOND, 0);
+    final long realTime = ntfsEpoch.getTimeInMillis() + (ntfsTime / (10 * 1000));
+    return new Date(realTime);
+  }
+
+  /**
+   * Converts Java time to NTFS time.
+   *
+   * @param date the Java time
+   * @return the NTFS time
+   */
+  public static long javaTimeToNtfsTime(final Date date) {
+    final Calendar ntfsEpoch = Calendar.getInstance();
+    ntfsEpoch.setTimeZone(TimeZone.getTimeZone("GMT+0"));
+    ntfsEpoch.set(1601, 0, 1, 0, 0, 0);
+    ntfsEpoch.set(Calendar.MILLISECOND, 0);
+    return ((date.getTime() - ntfsEpoch.getTimeInMillis()) * 1000 * 10);
+  }
 }
diff --git a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/SevenZFile.java b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/SevenZFile.java
index c506d68e3..d0fd38e8c 100644
--- a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/SevenZFile.java
+++ b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/SevenZFile.java
@@ -1,27 +1,24 @@
 /*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * This file is part of Amaze File Manager.
  *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
  *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
-package com.amaze.filemanager.filesystem.compressed.sevenz;
 
-import org.apache.commons.compress.utils.BoundedInputStream;
-import org.apache.commons.compress.utils.CRC32VerifyingInputStream;
-import org.apache.commons.compress.utils.CharsetNames;
-import org.apache.commons.compress.utils.IOUtils;
-import org.apache.commons.compress.utils.InputStreamStatistics;
+package com.amaze.filemanager.filesystem.compressed.sevenz;
 
 import java.io.BufferedInputStream;
 import java.io.ByteArrayInputStream;
@@ -44,1163 +41,1180 @@ import java.util.BitSet;
 import java.util.LinkedList;
 import java.util.zip.CRC32;
 
+import org.apache.commons.compress.utils.BoundedInputStream;
+import org.apache.commons.compress.utils.CRC32VerifyingInputStream;
+import org.apache.commons.compress.utils.CharsetNames;
+import org.apache.commons.compress.utils.IOUtils;
+import org.apache.commons.compress.utils.InputStreamStatistics;
+
 /**
- * Reads a 7z file, using FileChannel under
- * the covers.
- * <p>
- * The 7z file format is a flexible container
- * that can contain many compression and
- * encryption types, but at the moment only
- * only Copy, LZMA, LZMA2, BZIP2, Deflate and AES-256 + SHA-256
- * are supported.
- * <p>
- * The format is very Windows/Intel specific,
- * so it uses little-endian byte order,
- * doesn't store user/group or permission bits,
- * and represents times using NTFS timestamps
- * (100 nanosecond units since 1 January 1601).
- * Hence the official tools recommend against
- * using it for backup purposes on *nix, and
- * recommend .tar.7z or .tar.lzma or .tar.xz
- * instead.
- * <p>
- * Both the header and file contents may be
- * compressed and/or encrypted. With both
- * encrypted, neither file names nor file
- * contents can be read, but the use of
- * encryption isn't plausibly deniable.
+ * Reads a 7z file, using FileChannel under the covers.
+ *
+ * <p>The 7z file format is a flexible container that can contain many compression and encryption
+ * types, but at the moment only only Copy, LZMA, LZMA2, BZIP2, Deflate and AES-256 + SHA-256 are
+ * supported.
+ *
+ * <p>The format is very Windows/Intel specific, so it uses little-endian byte order, doesn't store
+ * user/group or permission bits, and represents times using NTFS timestamps (100 nanosecond units
+ * since 1 January 1601). Hence the official tools recommend against using it for backup purposes on
+ * *nix, and recommend .tar.7z or .tar.lzma or .tar.xz instead.
+ *
+ * <p>Both the header and file contents may be compressed and/or encrypted. With both encrypted,
+ * neither file names nor file contents can be read, but the use of encryption isn't plausibly
+ * deniable. @NotThreadSafe
  *
- * @NotThreadSafe
  * @since 1.6
  */
 public class SevenZFile implements Closeable {
-    static final int SIGNATURE_HEADER_SIZE = 32;
-
-    private final String fileName;
-    private FileChannel channel;
-    private final Archive archive;
-    private int currentEntryIndex = -1;
-    private int currentFolderIndex = -1;
-    private InputStream currentFolderInputStream = null;
-    private byte[] password;
-
-    private long compressedBytesReadFromCurrentEntry;
-    private long uncompressedBytesReadFromCurrentEntry;
-
-    private final ArrayList<InputStream> deferredBlockStreams = new ArrayList<>();
-
-    // shared with SevenZOutputFile and tests, neither mutates it
-    static final byte[] sevenZSignature = { //NOSONAR
-        (byte)'7', (byte)'z', (byte)0xBC, (byte)0xAF, (byte)0x27, (byte)0x1C
-    };
-
-    /**
-     * Reads a file as 7z archive
-     *
-     * @param filename the file to read
-     * @param password optional password if the archive is encrypted
-     * @throws IOException if reading the archive fails
-     * @since 1.17
-     */
-    public SevenZFile(final File filename, final char[] password) throws IOException {
-        this(new FileInputStream(filename).getChannel(),
-             filename.getAbsolutePath(), utf16Decode(password), true);
-    }
-
-    /**
-     * Reads a file as 7z archive
-     *
-     * @param filename the file to read
-     * @param password optional password if the archive is encrypted -
-     * the byte array is supposed to be the UTF16-LE encoded
-     * representation of the password.
-     * @throws IOException if reading the archive fails
-     * @deprecated use the char[]-arg version for the password instead
-     */
-    public SevenZFile(final File filename, final byte[] password) throws IOException {
-        this(new FileInputStream(filename).getChannel(),
-             filename.getAbsolutePath(), password, true);
-    }
-
-    /**
-     * Reads a FileChannel as 7z archive
-     *
-     * <p>{@link
-     * org.apache.commons.compress.utils.SeekableInMemoryByteChannel}
-     * allows you to read from an in-memory archive.</p>
-     *
-     * @param channel the channel to read
-     * @throws IOException if reading the archive fails
-     * @since 1.13
-     */
-    public SevenZFile(final FileChannel channel) throws IOException {
-        this(channel, "unknown archive", (char[]) null);
-    }
-
-    /**
-     * Reads a FileChannel as 7z archive
-     *
-     * <p>{@link
-     * org.apache.commons.compress.utils.SeekableInMemoryByteChannel}
-     * allows you to read from an in-memory archive.</p>
-     *
-     * @param channel the channel to read
-     * @param password optional password if the archive is encrypted
-     * @throws IOException if reading the archive fails
-     * @since 1.17
-     */
-    public SevenZFile(final FileChannel channel,
-                      final char[] password) throws IOException {
-        this(channel, "unknown archive", utf16Decode(password));
-    }
-
-    /**
-     * Reads a FileChannel as 7z archive
-     *
-     * <p>{@link
-     * org.apache.commons.compress.utils.SeekableInMemoryByteChannel}
-     * allows you to read from an in-memory archive.</p>
-     *
-     * @param channel the channel to read
-     * @param filename name of the archive - only used for error reporting
-     * @param password optional password if the archive is encrypted
-     * @throws IOException if reading the archive fails
-     * @since 1.17
-     */
-    public SevenZFile(final FileChannel channel, String filename,
-                      final char[] password) throws IOException {
-        this(channel, filename, utf16Decode(password), false);
-    }
-
-    /**
-     * Reads a FileChannel as 7z archive
-     *
-     * <p>{@link
-     * org.apache.commons.compress.utils.SeekableInMemoryByteChannel}
-     * allows you to read from an in-memory archive.</p>
-     *
-     * @param channel the channel to read
-     * @param filename name of the archive - only used for error reporting
-     * @throws IOException if reading the archive fails
-     * @since 1.17
-     */
-    public SevenZFile(final FileChannel channel, String filename)
-        throws IOException {
-        this(channel, filename, null, false);
-    }
-
-    /**
-     * Reads a FileChannel as 7z archive
-     *
-     * <p>{@link
-     * org.apache.commons.compress.utils.SeekableInMemoryByteChannel}
-     * allows you to read from an in-memory archive.</p>
-     *
-     * @param channel the channel to read
-     * @param password optional password if the archive is encrypted -
-     * the byte array is supposed to be the UTF16-LE encoded
-     * representation of the password.
-     * @throws IOException if reading the archive fails
-     * @since 1.13
-     * @deprecated use the char[]-arg version for the password instead
-     */
-    public SevenZFile(final FileChannel channel,
-                      final byte[] password) throws IOException {
-        this(channel, "unknown archive", password);
-    }
-
-    /**
-     * Reads a FileChannel as 7z archive
-     *
-     * <p>{@link
-     * org.apache.commons.compress.utils.SeekableInMemoryByteChannel}
-     * allows you to read from an in-memory archive.</p>
-     *
-     * @param channel the channel to read
-     * @param filename name of the archive - only used for error reporting
-     * @param password optional password if the archive is encrypted -
-     * the byte array is supposed to be the UTF16-LE encoded
-     * representation of the password.
-     * @throws IOException if reading the archive fails
-     * @since 1.13
-     * @deprecated use the char[]-arg version for the password instead
-     */
-    public SevenZFile(final FileChannel channel, String filename,
-                      final byte[] password) throws IOException {
-        this(channel, filename, password, false);
-    }
-
-    private SevenZFile(final FileChannel channel, String filename,
-                       final byte[] password, boolean closeOnError) throws IOException {
-        boolean succeeded = false;
-        this.channel = channel;
-        this.fileName = filename;
-        try {
-            archive = readHeaders(password);
-            if (password != null) {
-                this.password = Arrays.copyOf(password, password.length);
-            } else {
-                this.password = null;
-            }
-            succeeded = true;
-        } finally {
-            if (!succeeded && closeOnError) {
-                this.channel.close();
-            }
-        }
+  static final int SIGNATURE_HEADER_SIZE = 32;
+
+  private final String fileName;
+  private FileChannel channel;
+  private final Archive archive;
+  private int currentEntryIndex = -1;
+  private int currentFolderIndex = -1;
+  private InputStream currentFolderInputStream = null;
+  private byte[] password;
+
+  private long compressedBytesReadFromCurrentEntry;
+  private long uncompressedBytesReadFromCurrentEntry;
+
+  private final ArrayList<InputStream> deferredBlockStreams = new ArrayList<>();
+
+  // shared with SevenZOutputFile and tests, neither mutates it
+  static final byte[] sevenZSignature = { // NOSONAR
+    (byte) '7', (byte) 'z', (byte) 0xBC, (byte) 0xAF, (byte) 0x27, (byte) 0x1C
+  };
+
+  /**
+   * Reads a file as 7z archive
+   *
+   * @param filename the file to read
+   * @param password optional password if the archive is encrypted
+   * @throws IOException if reading the archive fails
+   * @since 1.17
+   */
+  public SevenZFile(final File filename, final char[] password) throws IOException {
+    this(
+        new FileInputStream(filename).getChannel(),
+        filename.getAbsolutePath(),
+        utf16Decode(password),
+        true);
+  }
+
+  /**
+   * Reads a file as 7z archive
+   *
+   * @param filename the file to read
+   * @param password optional password if the archive is encrypted - the byte array is supposed to
+   *     be the UTF16-LE encoded representation of the password.
+   * @throws IOException if reading the archive fails
+   * @deprecated use the char[]-arg version for the password instead
+   */
+  public SevenZFile(final File filename, final byte[] password) throws IOException {
+    this(new FileInputStream(filename).getChannel(), filename.getAbsolutePath(), password, true);
+  }
+
+  /**
+   * Reads a FileChannel as 7z archive
+   *
+   * <p>{@link org.apache.commons.compress.utils.SeekableInMemoryByteChannel} allows you to read
+   * from an in-memory archive.
+   *
+   * @param channel the channel to read
+   * @throws IOException if reading the archive fails
+   * @since 1.13
+   */
+  public SevenZFile(final FileChannel channel) throws IOException {
+    this(channel, "unknown archive", (char[]) null);
+  }
+
+  /**
+   * Reads a FileChannel as 7z archive
+   *
+   * <p>{@link org.apache.commons.compress.utils.SeekableInMemoryByteChannel} allows you to read
+   * from an in-memory archive.
+   *
+   * @param channel the channel to read
+   * @param password optional password if the archive is encrypted
+   * @throws IOException if reading the archive fails
+   * @since 1.17
+   */
+  public SevenZFile(final FileChannel channel, final char[] password) throws IOException {
+    this(channel, "unknown archive", utf16Decode(password));
+  }
+
+  /**
+   * Reads a FileChannel as 7z archive
+   *
+   * <p>{@link org.apache.commons.compress.utils.SeekableInMemoryByteChannel} allows you to read
+   * from an in-memory archive.
+   *
+   * @param channel the channel to read
+   * @param filename name of the archive - only used for error reporting
+   * @param password optional password if the archive is encrypted
+   * @throws IOException if reading the archive fails
+   * @since 1.17
+   */
+  public SevenZFile(final FileChannel channel, String filename, final char[] password)
+      throws IOException {
+    this(channel, filename, utf16Decode(password), false);
+  }
+
+  /**
+   * Reads a FileChannel as 7z archive
+   *
+   * <p>{@link org.apache.commons.compress.utils.SeekableInMemoryByteChannel} allows you to read
+   * from an in-memory archive.
+   *
+   * @param channel the channel to read
+   * @param filename name of the archive - only used for error reporting
+   * @throws IOException if reading the archive fails
+   * @since 1.17
+   */
+  public SevenZFile(final FileChannel channel, String filename) throws IOException {
+    this(channel, filename, null, false);
+  }
+
+  /**
+   * Reads a FileChannel as 7z archive
+   *
+   * <p>{@link org.apache.commons.compress.utils.SeekableInMemoryByteChannel} allows you to read
+   * from an in-memory archive.
+   *
+   * @param channel the channel to read
+   * @param password optional password if the archive is encrypted - the byte array is supposed to
+   *     be the UTF16-LE encoded representation of the password.
+   * @throws IOException if reading the archive fails
+   * @since 1.13
+   * @deprecated use the char[]-arg version for the password instead
+   */
+  public SevenZFile(final FileChannel channel, final byte[] password) throws IOException {
+    this(channel, "unknown archive", password);
+  }
+
+  /**
+   * Reads a FileChannel as 7z archive
+   *
+   * <p>{@link org.apache.commons.compress.utils.SeekableInMemoryByteChannel} allows you to read
+   * from an in-memory archive.
+   *
+   * @param channel the channel to read
+   * @param filename name of the archive - only used for error reporting
+   * @param password optional password if the archive is encrypted - the byte array is supposed to
+   *     be the UTF16-LE encoded representation of the password.
+   * @throws IOException if reading the archive fails
+   * @since 1.13
+   * @deprecated use the char[]-arg version for the password instead
+   */
+  public SevenZFile(final FileChannel channel, String filename, final byte[] password)
+      throws IOException {
+    this(channel, filename, password, false);
+  }
+
+  private SevenZFile(
+      final FileChannel channel, String filename, final byte[] password, boolean closeOnError)
+      throws IOException {
+    boolean succeeded = false;
+    this.channel = channel;
+    this.fileName = filename;
+    try {
+      archive = readHeaders(password);
+      if (password != null) {
+        this.password = Arrays.copyOf(password, password.length);
+      } else {
+        this.password = null;
+      }
+      succeeded = true;
+    } finally {
+      if (!succeeded && closeOnError) {
+        this.channel.close();
+      }
     }
-
-    /**
-     * Reads a file as unencrypted 7z archive
-     *
-     * @param filename the file to read
-     * @throws IOException if reading the archive fails
-     */
-    public SevenZFile(final File filename) throws IOException {
-        this(filename, (char[]) null);
-    }
-
-    /**
-     * Closes the archive.
-     * @throws IOException if closing the file fails
-     */
-    @Override
-    public void close() throws IOException {
-        if (channel != null) {
-            try {
-                channel.close();
-            } finally {
-                channel = null;
-                if (password != null) {
-                    Arrays.fill(password, (byte) 0);
-                }
-                password = null;
-            }
-        }
+  }
+
+  /**
+   * Reads a file as unencrypted 7z archive
+   *
+   * @param filename the file to read
+   * @throws IOException if reading the archive fails
+   */
+  public SevenZFile(final File filename) throws IOException {
+    this(filename, (char[]) null);
+  }
+
+  /**
+   * Closes the archive.
+   *
+   * @throws IOException if closing the file fails
+   */
+  @Override
+  public void close() throws IOException {
+    if (channel != null) {
+      try {
+        channel.close();
+      } finally {
+        channel = null;
+        if (password != null) {
+          Arrays.fill(password, (byte) 0);
+        }
+        password = null;
+      }
     }
-
-    /**
-     * Returns the next Archive Entry in this archive.
-     *
-     * @return the next entry,
-     *         or {@code null} if there are no more entries
-     * @throws IOException if the next entry could not be read
-     */
-    public SevenZArchiveEntry getNextEntry() throws IOException {
-        if (currentEntryIndex >= archive.files.length - 1) {
-            return null;
-        }
-        ++currentEntryIndex;
-        final SevenZArchiveEntry entry = archive.files[currentEntryIndex];
-        buildDecodingStream();
-        uncompressedBytesReadFromCurrentEntry = compressedBytesReadFromCurrentEntry = 0;
-        return entry;
-    }
-
-    /**
-     * Returns meta-data of all archive entries.
-     *
-     * <p>This method only provides meta-data, the entries can not be
-     * used to read the contents, you still need to process all
-     * entries in order using {@link #getNextEntry} for that.</p>
-     *
-     * <p>The content methods are only available for entries that have
-     * already been reached via {@link #getNextEntry}.</p>
-     *
-     * @return meta-data of all archive entries.
-     * @since 1.11
-     */
-    public Iterable<SevenZArchiveEntry> getEntries() {
-        return Arrays.asList(archive.files);
-    }
-
-    private Archive readHeaders(final byte[] password) throws IOException {
-        ByteBuffer buf = ByteBuffer.allocate(12 /* signature + 2 bytes version + 4 bytes CRC */)
+  }
+
+  /**
+   * Returns the next Archive Entry in this archive.
+   *
+   * @return the next entry, or {@code null} if there are no more entries
+   * @throws IOException if the next entry could not be read
+   */
+  public SevenZArchiveEntry getNextEntry() throws IOException {
+    if (currentEntryIndex >= archive.files.length - 1) {
+      return null;
+    }
+    ++currentEntryIndex;
+    final SevenZArchiveEntry entry = archive.files[currentEntryIndex];
+    buildDecodingStream();
+    uncompressedBytesReadFromCurrentEntry = compressedBytesReadFromCurrentEntry = 0;
+    return entry;
+  }
+
+  /**
+   * Returns meta-data of all archive entries.
+   *
+   * <p>This method only provides meta-data, the entries can not be used to read the contents, you
+   * still need to process all entries in order using {@link #getNextEntry} for that.
+   *
+   * <p>The content methods are only available for entries that have already been reached via {@link
+   * #getNextEntry}.
+   *
+   * @return meta-data of all archive entries.
+   * @since 1.11
+   */
+  public Iterable<SevenZArchiveEntry> getEntries() {
+    return Arrays.asList(archive.files);
+  }
+
+  private Archive readHeaders(final byte[] password) throws IOException {
+    ByteBuffer buf =
+        ByteBuffer.allocate(12 /* signature + 2 bytes version + 4 bytes CRC */)
             .order(ByteOrder.LITTLE_ENDIAN);
-        readFully(buf);
-        final byte[] signature = new byte[6];
-        buf.get(signature);
-        if (!Arrays.equals(signature, sevenZSignature)) {
-            throw new IOException("Bad 7z signature");
-        }
-        // 7zFormat.txt has it wrong - it's first major then minor
-        final byte archiveVersionMajor = buf.get();
-        final byte archiveVersionMinor = buf.get();
-        if (archiveVersionMajor != 0) {
-            throw new IOException(String.format("Unsupported 7z version (%d,%d)",
-                    archiveVersionMajor, archiveVersionMinor));
-        }
-
-        final long startHeaderCrc = 0xffffFFFFL & buf.getInt();
-        final StartHeader startHeader = readStartHeader(startHeaderCrc);
+    readFully(buf);
+    final byte[] signature = new byte[6];
+    buf.get(signature);
+    if (!Arrays.equals(signature, sevenZSignature)) {
+      throw new IOException("Bad 7z signature");
+    }
+    // 7zFormat.txt has it wrong - it's first major then minor
+    final byte archiveVersionMajor = buf.get();
+    final byte archiveVersionMinor = buf.get();
+    if (archiveVersionMajor != 0) {
+      throw new IOException(
+          String.format(
+              "Unsupported 7z version (%d,%d)", archiveVersionMajor, archiveVersionMinor));
+    }
 
-        final int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;
-        if (nextHeaderSizeInt != startHeader.nextHeaderSize) {
-            throw new IOException("cannot handle nextHeaderSize " + startHeader.nextHeaderSize);
-        }
-        channel.position(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);
-        buf = ByteBuffer.allocate(nextHeaderSizeInt).order(ByteOrder.LITTLE_ENDIAN);
-        readFully(buf);
-        final CRC32 crc = new CRC32();
-        crc.update(buf.array());
-        if (startHeader.nextHeaderCrc != crc.getValue()) {
-            throw new IOException("NextHeader CRC mismatch");
-        }
+    final long startHeaderCrc = 0xffffFFFFL & buf.getInt();
+    final StartHeader startHeader = readStartHeader(startHeaderCrc);
 
-        Archive archive = new Archive();
-        int nid = getUnsignedByte(buf);
-        if (nid == NID.kEncodedHeader) {
-            buf = readEncodedHeader(buf, archive, password);
-            // Archive gets rebuilt with the new header
-            archive = new Archive();
-            nid = getUnsignedByte(buf);
-        }
-        if (nid == NID.kHeader) {
-            readHeader(buf, archive);
-        } else {
-            throw new IOException("Broken or unsupported archive: no Header");
-        }
-        return archive;
+    final int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;
+    if (nextHeaderSizeInt != startHeader.nextHeaderSize) {
+      throw new IOException("cannot handle nextHeaderSize " + startHeader.nextHeaderSize);
+    }
+    channel.position(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);
+    buf = ByteBuffer.allocate(nextHeaderSizeInt).order(ByteOrder.LITTLE_ENDIAN);
+    readFully(buf);
+    final CRC32 crc = new CRC32();
+    crc.update(buf.array());
+    if (startHeader.nextHeaderCrc != crc.getValue()) {
+      throw new IOException("NextHeader CRC mismatch");
     }
 
-    private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {
-        final StartHeader startHeader = new StartHeader();
-        // using Stream rather than ByteBuffer for the benefit of the
-        // built-in CRC check
-        DataInputStream dataInputStream = new DataInputStream(new CRC32VerifyingInputStream(
+    Archive archive = new Archive();
+    int nid = getUnsignedByte(buf);
+    if (nid == NID.kEncodedHeader) {
+      buf = readEncodedHeader(buf, archive, password);
+      // Archive gets rebuilt with the new header
+      archive = new Archive();
+      nid = getUnsignedByte(buf);
+    }
+    if (nid == NID.kHeader) {
+      readHeader(buf, archive);
+    } else {
+      throw new IOException("Broken or unsupported archive: no Header");
+    }
+    return archive;
+  }
+
+  private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {
+    final StartHeader startHeader = new StartHeader();
+    // using Stream rather than ByteBuffer for the benefit of the
+    // built-in CRC check
+    DataInputStream dataInputStream =
+        new DataInputStream(
+            new CRC32VerifyingInputStream(
                 new BoundedFileChannelInputStream(channel, 20), 20, startHeaderCrc));
-        startHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());
-        startHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());
-        startHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());
-        return startHeader;
+    startHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());
+    startHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());
+    startHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());
+    return startHeader;
+  }
+
+  private void readHeader(final ByteBuffer header, final Archive archive) throws IOException {
+    int nid = getUnsignedByte(header);
+
+    if (nid == NID.kArchiveProperties) {
+      readArchiveProperties(header);
+      nid = getUnsignedByte(header);
     }
 
-    private void readHeader(final ByteBuffer header, final Archive archive) throws IOException {
-        int nid = getUnsignedByte(header);
+    if (nid == NID.kAdditionalStreamsInfo) {
+      throw new IOException("Additional streams unsupported");
+      // nid = header.readUnsignedByte();
+    }
 
-        if (nid == NID.kArchiveProperties) {
-            readArchiveProperties(header);
-            nid = getUnsignedByte(header);
-        }
+    if (nid == NID.kMainStreamsInfo) {
+      readStreamsInfo(header, archive);
+      nid = getUnsignedByte(header);
+    }
 
-        if (nid == NID.kAdditionalStreamsInfo) {
-            throw new IOException("Additional streams unsupported");
-            //nid = header.readUnsignedByte();
-        }
+    if (nid == NID.kFilesInfo) {
+      readFilesInfo(header, archive);
+      nid = getUnsignedByte(header);
+    }
 
-        if (nid == NID.kMainStreamsInfo) {
-            readStreamsInfo(header, archive);
-            nid = getUnsignedByte(header);
-        }
+    if (nid != NID.kEnd) {
+      throw new IOException("Badly terminated header, found " + nid);
+    }
+  }
+
+  private void readArchiveProperties(final ByteBuffer input) throws IOException {
+    // FIXME: the reference implementation just throws them away?
+    int nid = getUnsignedByte(input);
+    while (nid != NID.kEnd) {
+      final long propertySize = readUint64(input);
+      final byte[] property = new byte[(int) propertySize];
+      input.get(property);
+      nid = getUnsignedByte(input);
+    }
+  }
+
+  private ByteBuffer readEncodedHeader(
+      final ByteBuffer header, final Archive archive, final byte[] password) throws IOException {
+    readStreamsInfo(header, archive);
+
+    // FIXME: merge with buildDecodingStream()/buildDecoderStack() at some stage?
+    final Folder folder = archive.folders[0];
+    final int firstPackStreamIndex = 0;
+    final long folderOffset = SIGNATURE_HEADER_SIZE + archive.packPos + 0;
+
+    channel.position(folderOffset);
+    InputStream inputStreamStack =
+        new BoundedFileChannelInputStream(channel, archive.packSizes[firstPackStreamIndex]);
+    for (final Coder coder : folder.getOrderedCoders()) {
+      if (coder.numInStreams != 1 || coder.numOutStreams != 1) {
+        throw new IOException("Multi input/output stream coders are not yet supported");
+      }
+      inputStreamStack =
+          Coders.addDecoder(
+              fileName,
+              inputStreamStack, // NOSONAR
+              folder.getUnpackSizeForCoder(coder),
+              coder,
+              password);
+    }
+    if (folder.hasCrc) {
+      inputStreamStack =
+          new CRC32VerifyingInputStream(inputStreamStack, folder.getUnpackSize(), folder.crc);
+    }
+    final byte[] nextHeader = new byte[(int) folder.getUnpackSize()];
+    DataInputStream nextHeaderInputStream = new DataInputStream(inputStreamStack);
+    nextHeaderInputStream.readFully(nextHeader);
+    return ByteBuffer.wrap(nextHeader).order(ByteOrder.LITTLE_ENDIAN);
+  }
+
+  private void readStreamsInfo(final ByteBuffer header, final Archive archive) throws IOException {
+    int nid = getUnsignedByte(header);
+
+    if (nid == NID.kPackInfo) {
+      readPackInfo(header, archive);
+      nid = getUnsignedByte(header);
+    }
 
-        if (nid == NID.kFilesInfo) {
-            readFilesInfo(header, archive);
-            nid = getUnsignedByte(header);
-        }
+    if (nid == NID.kUnpackInfo) {
+      readUnpackInfo(header, archive);
+      nid = getUnsignedByte(header);
+    } else {
+      // archive without unpack/coders info
+      archive.folders = new Folder[0];
+    }
 
-        if (nid != NID.kEnd) {
-            throw new IOException("Badly terminated header, found " + nid);
-        }
+    if (nid == NID.kSubStreamsInfo) {
+      readSubStreamsInfo(header, archive);
+      nid = getUnsignedByte(header);
     }
 
-    private void readArchiveProperties(final ByteBuffer input) throws IOException {
-        // FIXME: the reference implementation just throws them away?
-        int nid =  getUnsignedByte(input);
-        while (nid != NID.kEnd) {
-            final long propertySize = readUint64(input);
-            final byte[] property = new byte[(int)propertySize];
-            input.get(property);
-            nid = getUnsignedByte(input);
-        }
+    if (nid != NID.kEnd) {
+      throw new IOException("Badly terminated StreamsInfo");
+    }
+  }
+
+  private void readPackInfo(final ByteBuffer header, final Archive archive) throws IOException {
+    archive.packPos = readUint64(header);
+    final long numPackStreams = readUint64(header);
+    int nid = getUnsignedByte(header);
+    if (nid == NID.kSize) {
+      archive.packSizes = new long[(int) numPackStreams];
+      for (int i = 0; i < archive.packSizes.length; i++) {
+        archive.packSizes[i] = readUint64(header);
+      }
+      nid = getUnsignedByte(header);
     }
 
-    private ByteBuffer readEncodedHeader(final ByteBuffer header, final Archive archive,
-                                         final byte[] password) throws IOException {
-        readStreamsInfo(header, archive);
+    if (nid == NID.kCRC) {
+      archive.packCrcsDefined = readAllOrBits(header, (int) numPackStreams);
+      archive.packCrcs = new long[(int) numPackStreams];
+      for (int i = 0; i < (int) numPackStreams; i++) {
+        if (archive.packCrcsDefined.get(i)) {
+          archive.packCrcs[i] = 0xffffFFFFL & header.getInt();
+        }
+      }
 
-        // FIXME: merge with buildDecodingStream()/buildDecoderStack() at some stage?
-        final Folder folder = archive.folders[0];
-        final int firstPackStreamIndex = 0;
-        final long folderOffset = SIGNATURE_HEADER_SIZE + archive.packPos +
-                0;
+      nid = getUnsignedByte(header);
+    }
 
-        channel.position(folderOffset);
-        InputStream inputStreamStack = new BoundedFileChannelInputStream(channel,
-                archive.packSizes[firstPackStreamIndex]);
-        for (final Coder coder : folder.getOrderedCoders()) {
-            if (coder.numInStreams != 1 || coder.numOutStreams != 1) {
-                throw new IOException("Multi input/output stream coders are not yet supported");
-            }
-            inputStreamStack = Coders.addDecoder(fileName, inputStreamStack, //NOSONAR
-                    folder.getUnpackSizeForCoder(coder), coder, password);
-        }
-        if (folder.hasCrc) {
-            inputStreamStack = new CRC32VerifyingInputStream(inputStreamStack,
-                    folder.getUnpackSize(), folder.crc);
-        }
-        final byte[] nextHeader = new byte[(int)folder.getUnpackSize()];
-        DataInputStream nextHeaderInputStream = new DataInputStream(inputStreamStack);
-        nextHeaderInputStream.readFully(nextHeader);
-        return ByteBuffer.wrap(nextHeader).order(ByteOrder.LITTLE_ENDIAN);
+    if (nid != NID.kEnd) {
+      throw new IOException("Badly terminated PackInfo (" + nid + ")");
     }
+  }
 
-    private void readStreamsInfo(final ByteBuffer header, final Archive archive) throws IOException {
-        int nid = getUnsignedByte(header);
+  private void readUnpackInfo(final ByteBuffer header, final Archive archive) throws IOException {
+    int nid = getUnsignedByte(header);
+    if (nid != NID.kFolder) {
+      throw new IOException("Expected kFolder, got " + nid);
+    }
+    final long numFolders = readUint64(header);
+    final Folder[] folders = new Folder[(int) numFolders];
+    archive.folders = folders;
+    final int external = getUnsignedByte(header);
+    if (external != 0) {
+      throw new IOException("External unsupported");
+    }
+    for (int i = 0; i < (int) numFolders; i++) {
+      folders[i] = readFolder(header);
+    }
 
-        if (nid == NID.kPackInfo) {
-            readPackInfo(header, archive);
-            nid = getUnsignedByte(header);
-        }
+    nid = getUnsignedByte(header);
+    if (nid != NID.kCodersUnpackSize) {
+      throw new IOException("Expected kCodersUnpackSize, got " + nid);
+    }
+    for (final Folder folder : folders) {
+      folder.unpackSizes = new long[(int) folder.totalOutputStreams];
+      for (int i = 0; i < folder.totalOutputStreams; i++) {
+        folder.unpackSizes[i] = readUint64(header);
+      }
+    }
 
-        if (nid == NID.kUnpackInfo) {
-            readUnpackInfo(header, archive);
-            nid = getUnsignedByte(header);
+    nid = getUnsignedByte(header);
+    if (nid == NID.kCRC) {
+      final BitSet crcsDefined = readAllOrBits(header, (int) numFolders);
+      for (int i = 0; i < (int) numFolders; i++) {
+        if (crcsDefined.get(i)) {
+          folders[i].hasCrc = true;
+          folders[i].crc = 0xffffFFFFL & header.getInt();
         } else {
-            // archive without unpack/coders info
-            archive.folders = new Folder[0];
-        }
-
-        if (nid == NID.kSubStreamsInfo) {
-            readSubStreamsInfo(header, archive);
-            nid = getUnsignedByte(header);
+          folders[i].hasCrc = false;
         }
+      }
 
-        if (nid != NID.kEnd) {
-            throw new IOException("Badly terminated StreamsInfo");
-        }
+      nid = getUnsignedByte(header);
     }
 
-    private void readPackInfo(final ByteBuffer header, final Archive archive) throws IOException {
-        archive.packPos = readUint64(header);
-        final long numPackStreams = readUint64(header);
-        int nid = getUnsignedByte(header);
-        if (nid == NID.kSize) {
-            archive.packSizes = new long[(int)numPackStreams];
-            for (int i = 0; i < archive.packSizes.length; i++) {
-                archive.packSizes[i] = readUint64(header);
-            }
-            nid = getUnsignedByte(header);
-        }
-
-        if (nid == NID.kCRC) {
-            archive.packCrcsDefined = readAllOrBits(header, (int)numPackStreams);
-            archive.packCrcs = new long[(int)numPackStreams];
-            for (int i = 0; i < (int)numPackStreams; i++) {
-                if (archive.packCrcsDefined.get(i)) {
-                    archive.packCrcs[i] = 0xffffFFFFL & header.getInt();
-                }
-            }
+    if (nid != NID.kEnd) {
+      throw new IOException("Badly terminated UnpackInfo");
+    }
+  }
 
-            nid = getUnsignedByte(header);
-        }
+  private void readSubStreamsInfo(final ByteBuffer header, final Archive archive)
+      throws IOException {
+    for (final Folder folder : archive.folders) {
+      folder.numUnpackSubStreams = 1;
+    }
+    int totalUnpackStreams = archive.folders.length;
+
+    int nid = getUnsignedByte(header);
+    if (nid == NID.kNumUnpackStream) {
+      totalUnpackStreams = 0;
+      for (final Folder folder : archive.folders) {
+        final long numStreams = readUint64(header);
+        folder.numUnpackSubStreams = (int) numStreams;
+        totalUnpackStreams += numStreams;
+      }
+      nid = getUnsignedByte(header);
+    }
 
-        if (nid != NID.kEnd) {
-            throw new IOException("Badly terminated PackInfo (" + nid + ")");
-        }
+    final SubStreamsInfo subStreamsInfo = new SubStreamsInfo();
+    subStreamsInfo.unpackSizes = new long[totalUnpackStreams];
+    subStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);
+    subStreamsInfo.crcs = new long[totalUnpackStreams];
+
+    int nextUnpackStream = 0;
+    for (final Folder folder : archive.folders) {
+      if (folder.numUnpackSubStreams == 0) {
+        continue;
+      }
+      long sum = 0;
+      if (nid == NID.kSize) {
+        for (int i = 0; i < folder.numUnpackSubStreams - 1; i++) {
+          final long size = readUint64(header);
+          subStreamsInfo.unpackSizes[nextUnpackStream++] = size;
+          sum += size;
+        }
+      }
+      subStreamsInfo.unpackSizes[nextUnpackStream++] = folder.getUnpackSize() - sum;
+    }
+    if (nid == NID.kSize) {
+      nid = getUnsignedByte(header);
     }
 
-    private void readUnpackInfo(final ByteBuffer header, final Archive archive) throws IOException {
-        int nid = getUnsignedByte(header);
-        if (nid != NID.kFolder) {
-            throw new IOException("Expected kFolder, got " + nid);
-        }
-        final long numFolders = readUint64(header);
-        final Folder[] folders = new Folder[(int)numFolders];
-        archive.folders = folders;
-        final int external = getUnsignedByte(header);
-        if (external != 0) {
-            throw new IOException("External unsupported");
-        }
-        for (int i = 0; i < (int)numFolders; i++) {
-            folders[i] = readFolder(header);
-        }
+    int numDigests = 0;
+    for (final Folder folder : archive.folders) {
+      if (folder.numUnpackSubStreams != 1 || !folder.hasCrc) {
+        numDigests += folder.numUnpackSubStreams;
+      }
+    }
 
-        nid = getUnsignedByte(header);
-        if (nid != NID.kCodersUnpackSize) {
-            throw new IOException("Expected kCodersUnpackSize, got " + nid);
-        }
-        for (final Folder folder : folders) {
-            folder.unpackSizes = new long[(int)folder.totalOutputStreams];
-            for (int i = 0; i < folder.totalOutputStreams; i++) {
-                folder.unpackSizes[i] = readUint64(header);
-            }
+    if (nid == NID.kCRC) {
+      final BitSet hasMissingCrc = readAllOrBits(header, numDigests);
+      final long[] missingCrcs = new long[numDigests];
+      for (int i = 0; i < numDigests; i++) {
+        if (hasMissingCrc.get(i)) {
+          missingCrcs[i] = 0xffffFFFFL & header.getInt();
+        }
+      }
+      int nextCrc = 0;
+      int nextMissingCrc = 0;
+      for (final Folder folder : archive.folders) {
+        if (folder.numUnpackSubStreams == 1 && folder.hasCrc) {
+          subStreamsInfo.hasCrc.set(nextCrc, true);
+          subStreamsInfo.crcs[nextCrc] = folder.crc;
+          ++nextCrc;
+        } else {
+          for (int i = 0; i < folder.numUnpackSubStreams; i++) {
+            subStreamsInfo.hasCrc.set(nextCrc, hasMissingCrc.get(nextMissingCrc));
+            subStreamsInfo.crcs[nextCrc] = missingCrcs[nextMissingCrc];
+            ++nextCrc;
+            ++nextMissingCrc;
+          }
         }
+      }
 
-        nid = getUnsignedByte(header);
-        if (nid == NID.kCRC) {
-            final BitSet crcsDefined = readAllOrBits(header, (int)numFolders);
-            for (int i = 0; i < (int)numFolders; i++) {
-                if (crcsDefined.get(i)) {
-                    folders[i].hasCrc = true;
-                    folders[i].crc = 0xffffFFFFL & header.getInt();
-                } else {
-                    folders[i].hasCrc = false;
-                }
-            }
-
-            nid = getUnsignedByte(header);
-        }
+      nid = getUnsignedByte(header);
+    }
 
-        if (nid != NID.kEnd) {
-            throw new IOException("Badly terminated UnpackInfo");
-        }
+    if (nid != NID.kEnd) {
+      throw new IOException("Badly terminated SubStreamsInfo");
     }
 
-    private void readSubStreamsInfo(final ByteBuffer header, final Archive archive) throws IOException {
-        for (final Folder folder : archive.folders) {
-            folder.numUnpackSubStreams = 1;
-        }
-        int totalUnpackStreams = archive.folders.length;
-
-        int nid = getUnsignedByte(header);
-        if (nid == NID.kNumUnpackStream) {
-            totalUnpackStreams = 0;
-            for (final Folder folder : archive.folders) {
-                final long numStreams = readUint64(header);
-                folder.numUnpackSubStreams = (int)numStreams;
-                totalUnpackStreams += numStreams;
-            }
-            nid = getUnsignedByte(header);
-        }
+    archive.subStreamsInfo = subStreamsInfo;
+  }
+
+  private Folder readFolder(final ByteBuffer header) throws IOException {
+    final Folder folder = new Folder();
+
+    final long numCoders = readUint64(header);
+    final Coder[] coders = new Coder[(int) numCoders];
+    long totalInStreams = 0;
+    long totalOutStreams = 0;
+    for (int i = 0; i < coders.length; i++) {
+      coders[i] = new Coder();
+      final int bits = getUnsignedByte(header);
+      final int idSize = bits & 0xf;
+      final boolean isSimple = (bits & 0x10) == 0;
+      final boolean hasAttributes = (bits & 0x20) != 0;
+      final boolean moreAlternativeMethods = (bits & 0x80) != 0;
+
+      coders[i].decompressionMethodId = new byte[idSize];
+      header.get(coders[i].decompressionMethodId);
+      if (isSimple) {
+        coders[i].numInStreams = 1;
+        coders[i].numOutStreams = 1;
+      } else {
+        coders[i].numInStreams = readUint64(header);
+        coders[i].numOutStreams = readUint64(header);
+      }
+      totalInStreams += coders[i].numInStreams;
+      totalOutStreams += coders[i].numOutStreams;
+      if (hasAttributes) {
+        final long propertiesSize = readUint64(header);
+        coders[i].properties = new byte[(int) propertiesSize];
+        header.get(coders[i].properties);
+      }
+      // would need to keep looping as above:
+      while (moreAlternativeMethods) {
+        throw new IOException(
+            "Alternative methods are unsupported, please report. "
+                + "The reference implementation doesn't support them either.");
+      }
+    }
+    folder.coders = coders;
+    folder.totalInputStreams = totalInStreams;
+    folder.totalOutputStreams = totalOutStreams;
 
-        final SubStreamsInfo subStreamsInfo = new SubStreamsInfo();
-        subStreamsInfo.unpackSizes = new long[totalUnpackStreams];
-        subStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);
-        subStreamsInfo.crcs = new long[totalUnpackStreams];
+    if (totalOutStreams == 0) {
+      throw new IOException("Total output streams can't be 0");
+    }
+    final long numBindPairs = totalOutStreams - 1;
+    final BindPair[] bindPairs = new BindPair[(int) numBindPairs];
+    for (int i = 0; i < bindPairs.length; i++) {
+      bindPairs[i] = new BindPair();
+      bindPairs[i].inIndex = readUint64(header);
+      bindPairs[i].outIndex = readUint64(header);
+    }
+    folder.bindPairs = bindPairs;
 
-        int nextUnpackStream = 0;
-        for (final Folder folder : archive.folders) {
-            if (folder.numUnpackSubStreams == 0) {
-                continue;
+    if (totalInStreams < numBindPairs) {
+      throw new IOException("Total input streams can't be less than the number of bind pairs");
+    }
+    final long numPackedStreams = totalInStreams - numBindPairs;
+    final long packedStreams[] = new long[(int) numPackedStreams];
+    if (numPackedStreams == 1) {
+      int i;
+      for (i = 0; i < (int) totalInStreams; i++) {
+        if (folder.findBindPairForInStream(i) < 0) {
+          break;
+        }
+      }
+      if (i == (int) totalInStreams) {
+        throw new IOException("Couldn't find stream's bind pair index");
+      }
+      packedStreams[0] = i;
+    } else {
+      for (int i = 0; i < (int) numPackedStreams; i++) {
+        packedStreams[i] = readUint64(header);
+      }
+    }
+    folder.packedStreams = packedStreams;
+
+    return folder;
+  }
+
+  private BitSet readAllOrBits(final ByteBuffer header, final int size) throws IOException {
+    final int areAllDefined = getUnsignedByte(header);
+    final BitSet bits;
+    if (areAllDefined != 0) {
+      bits = new BitSet(size);
+      for (int i = 0; i < size; i++) {
+        bits.set(i, true);
+      }
+    } else {
+      bits = readBits(header, size);
+    }
+    return bits;
+  }
+
+  private BitSet readBits(final ByteBuffer header, final int size) throws IOException {
+    final BitSet bits = new BitSet(size);
+    int mask = 0;
+    int cache = 0;
+    for (int i = 0; i < size; i++) {
+      if (mask == 0) {
+        mask = 0x80;
+        cache = getUnsignedByte(header);
+      }
+      bits.set(i, (cache & mask) != 0);
+      mask >>>= 1;
+    }
+    return bits;
+  }
+
+  private void readFilesInfo(final ByteBuffer header, final Archive archive) throws IOException {
+    final long numFiles = readUint64(header);
+    final SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int) numFiles];
+    for (int i = 0; i < files.length; i++) {
+      files[i] = new SevenZArchiveEntry();
+    }
+    BitSet isEmptyStream = null;
+    BitSet isEmptyFile = null;
+    BitSet isAnti = null;
+    while (true) {
+      final int propertyType = getUnsignedByte(header);
+      if (propertyType == 0) {
+        break;
+      }
+      final long size = readUint64(header);
+      switch (propertyType) {
+        case NID.kEmptyStream:
+          {
+            isEmptyStream = readBits(header, files.length);
+            break;
+          }
+        case NID.kEmptyFile:
+          {
+            if (isEmptyStream == null) { // protect against NPE
+              throw new IOException(
+                  "Header format error: kEmptyStream must appear before kEmptyFile");
             }
-            long sum = 0;
-            if (nid == NID.kSize) {
-                for (int i = 0; i < folder.numUnpackSubStreams - 1; i++) {
-                    final long size = readUint64(header);
-                    subStreamsInfo.unpackSizes[nextUnpackStream++] = size;
-                    sum += size;
-                }
+            isEmptyFile = readBits(header, isEmptyStream.cardinality());
+            break;
+          }
+        case NID.kAnti:
+          {
+            if (isEmptyStream == null) { // protect against NPE
+              throw new IOException("Header format error: kEmptyStream must appear before kAnti");
             }
-            subStreamsInfo.unpackSizes[nextUnpackStream++] = folder.getUnpackSize() - sum;
-        }
-        if (nid == NID.kSize) {
-            nid = getUnsignedByte(header);
-        }
-
-        int numDigests = 0;
-        for (final Folder folder : archive.folders) {
-            if (folder.numUnpackSubStreams != 1 || !folder.hasCrc) {
-                numDigests += folder.numUnpackSubStreams;
+            isAnti = readBits(header, isEmptyStream.cardinality());
+            break;
+          }
+        case NID.kName:
+          {
+            final int external = getUnsignedByte(header);
+            if (external != 0) {
+              throw new IOException("Not implemented");
             }
-        }
-
-        if (nid == NID.kCRC) {
-            final BitSet hasMissingCrc = readAllOrBits(header, numDigests);
-            final long[] missingCrcs = new long[numDigests];
-            for (int i = 0; i < numDigests; i++) {
-                if (hasMissingCrc.get(i)) {
-                    missingCrcs[i] = 0xffffFFFFL & header.getInt();
-                }
+            if (((size - 1) & 1) != 0) {
+              throw new IOException("File names length invalid");
             }
-            int nextCrc = 0;
-            int nextMissingCrc = 0;
-            for (final Folder folder: archive.folders) {
-                if (folder.numUnpackSubStreams == 1 && folder.hasCrc) {
-                    subStreamsInfo.hasCrc.set(nextCrc, true);
-                    subStreamsInfo.crcs[nextCrc] = folder.crc;
-                    ++nextCrc;
-                } else {
-                    for (int i = 0; i < folder.numUnpackSubStreams; i++) {
-                        subStreamsInfo.hasCrc.set(nextCrc, hasMissingCrc.get(nextMissingCrc));
-                        subStreamsInfo.crcs[nextCrc] = missingCrcs[nextMissingCrc];
-                        ++nextCrc;
-                        ++nextMissingCrc;
-                    }
-                }
+            final byte[] names = new byte[(int) (size - 1)];
+            header.get(names);
+            int nextFile = 0;
+            int nextName = 0;
+            for (int i = 0; i < names.length; i += 2) {
+              if (names[i] == 0 && names[i + 1] == 0) {
+                files[nextFile++].setName(
+                    new String(names, nextName, i - nextName, CharsetNames.UTF_16LE));
+                nextName = i + 2;
+              }
             }
-
-            nid = getUnsignedByte(header);
-        }
-
-        if (nid != NID.kEnd) {
-            throw new IOException("Badly terminated SubStreamsInfo");
-        }
-
-        archive.subStreamsInfo = subStreamsInfo;
-    }
-
-    private Folder readFolder(final ByteBuffer header) throws IOException {
-        final Folder folder = new Folder();
-
-        final long numCoders = readUint64(header);
-        final Coder[] coders = new Coder[(int)numCoders];
-        long totalInStreams = 0;
-        long totalOutStreams = 0;
-        for (int i = 0; i < coders.length; i++) {
-            coders[i] = new Coder();
-            final int bits = getUnsignedByte(header);
-            final int idSize = bits & 0xf;
-            final boolean isSimple = (bits & 0x10) == 0;
-            final boolean hasAttributes = (bits & 0x20) != 0;
-            final boolean moreAlternativeMethods = (bits & 0x80) != 0;
-
-            coders[i].decompressionMethodId = new byte[idSize];
-            header.get(coders[i].decompressionMethodId);
-            if (isSimple) {
-                coders[i].numInStreams = 1;
-                coders[i].numOutStreams = 1;
-            } else {
-                coders[i].numInStreams = readUint64(header);
-                coders[i].numOutStreams = readUint64(header);
+            if (nextName != names.length || nextFile != files.length) {
+              throw new IOException("Error parsing file names");
             }
-            totalInStreams += coders[i].numInStreams;
-            totalOutStreams += coders[i].numOutStreams;
-            if (hasAttributes) {
-                final long propertiesSize = readUint64(header);
-                coders[i].properties = new byte[(int)propertiesSize];
-                header.get(coders[i].properties);
+            break;
+          }
+        case NID.kCTime:
+          {
+            final BitSet timesDefined = readAllOrBits(header, files.length);
+            final int external = getUnsignedByte(header);
+            if (external != 0) {
+              throw new IOException("Unimplemented");
             }
-            // would need to keep looping as above:
-            while (moreAlternativeMethods) {
-                throw new IOException("Alternative methods are unsupported, please report. " +
-                        "The reference implementation doesn't support them either.");
+            for (int i = 0; i < files.length; i++) {
+              files[i].setHasCreationDate(timesDefined.get(i));
+              if (files[i].getHasCreationDate()) {
+                files[i].setCreationDate(header.getLong());
+              }
             }
-        }
-        folder.coders = coders;
-        folder.totalInputStreams = totalInStreams;
-        folder.totalOutputStreams = totalOutStreams;
-
-        if (totalOutStreams == 0) {
-            throw new IOException("Total output streams can't be 0");
-        }
-        final long numBindPairs = totalOutStreams - 1;
-        final BindPair[] bindPairs = new BindPair[(int)numBindPairs];
-        for (int i = 0; i < bindPairs.length; i++) {
-            bindPairs[i] = new BindPair();
-            bindPairs[i].inIndex = readUint64(header);
-            bindPairs[i].outIndex = readUint64(header);
-        }
-        folder.bindPairs = bindPairs;
-
-        if (totalInStreams < numBindPairs) {
-            throw new IOException("Total input streams can't be less than the number of bind pairs");
-        }
-        final long numPackedStreams = totalInStreams - numBindPairs;
-        final long packedStreams[] = new long[(int)numPackedStreams];
-        if (numPackedStreams == 1) {
-            int i;
-            for (i = 0; i < (int)totalInStreams; i++) {
-                if (folder.findBindPairForInStream(i) < 0) {
-                    break;
-                }
+            break;
+          }
+        case NID.kATime:
+          {
+            final BitSet timesDefined = readAllOrBits(header, files.length);
+            final int external = getUnsignedByte(header);
+            if (external != 0) {
+              throw new IOException("Unimplemented");
             }
-            if (i == (int)totalInStreams) {
-                throw new IOException("Couldn't find stream's bind pair index");
+            for (int i = 0; i < files.length; i++) {
+              files[i].setHasAccessDate(timesDefined.get(i));
+              if (files[i].getHasAccessDate()) {
+                files[i].setAccessDate(header.getLong());
+              }
             }
-            packedStreams[0] = i;
-        } else {
-            for (int i = 0; i < (int)numPackedStreams; i++) {
-                packedStreams[i] = readUint64(header);
+            break;
+          }
+        case NID.kMTime:
+          {
+            final BitSet timesDefined = readAllOrBits(header, files.length);
+            final int external = getUnsignedByte(header);
+            if (external != 0) {
+              throw new IOException("Unimplemented");
             }
-        }
-        folder.packedStreams = packedStreams;
-
-        return folder;
-    }
-
-    private BitSet readAllOrBits(final ByteBuffer header, final int size) throws IOException {
-        final int areAllDefined = getUnsignedByte(header);
-        final BitSet bits;
-        if (areAllDefined != 0) {
-            bits = new BitSet(size);
-            for (int i = 0; i < size; i++) {
-                bits.set(i, true);
+            for (int i = 0; i < files.length; i++) {
+              files[i].setHasLastModifiedDate(timesDefined.get(i));
+              if (files[i].getHasLastModifiedDate()) {
+                files[i].setLastModifiedDate(header.getLong());
+              }
             }
-        } else {
-            bits = readBits(header, size);
-        }
-        return bits;
-    }
-
-    private BitSet readBits(final ByteBuffer header, final int size) throws IOException {
-        final BitSet bits = new BitSet(size);
-        int mask = 0;
-        int cache = 0;
-        for (int i = 0; i < size; i++) {
-            if (mask == 0) {
-                mask = 0x80;
-                cache = getUnsignedByte(header);
+            break;
+          }
+        case NID.kWinAttributes:
+          {
+            final BitSet attributesDefined = readAllOrBits(header, files.length);
+            final int external = getUnsignedByte(header);
+            if (external != 0) {
+              throw new IOException("Unimplemented");
             }
-            bits.set(i, (cache & mask) != 0);
-            mask >>>= 1;
-        }
-        return bits;
-    }
-
-    private void readFilesInfo(final ByteBuffer header, final Archive archive) throws IOException {
-        final long numFiles = readUint64(header);
-        final SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)numFiles];
-        for (int i = 0; i < files.length; i++) {
-            files[i] = new SevenZArchiveEntry();
-        }
-        BitSet isEmptyStream = null;
-        BitSet isEmptyFile = null;
-        BitSet isAnti = null;
-        while (true) {
-            final int propertyType = getUnsignedByte(header);
-            if (propertyType == 0) {
-                break;
+            for (int i = 0; i < files.length; i++) {
+              files[i].setHasWindowsAttributes(attributesDefined.get(i));
+              if (files[i].getHasWindowsAttributes()) {
+                files[i].setWindowsAttributes(header.getInt());
+              }
             }
-            final long size = readUint64(header);
-            switch (propertyType) {
-                case NID.kEmptyStream: {
-                    isEmptyStream = readBits(header, files.length);
-                    break;
-                }
-                case NID.kEmptyFile: {
-                    if (isEmptyStream == null) { // protect against NPE
-                        throw new IOException("Header format error: kEmptyStream must appear before kEmptyFile");
-                    }
-                    isEmptyFile = readBits(header, isEmptyStream.cardinality());
-                    break;
-                }
-                case NID.kAnti: {
-                    if (isEmptyStream == null) { // protect against NPE
-                        throw new IOException("Header format error: kEmptyStream must appear before kAnti");
-                    }
-                    isAnti = readBits(header, isEmptyStream.cardinality());
-                    break;
-                }
-                case NID.kName: {
-                    final int external = getUnsignedByte(header);
-                    if (external != 0) {
-                        throw new IOException("Not implemented");
-                    }
-                    if (((size - 1) & 1) != 0) {
-                        throw new IOException("File names length invalid");
-                    }
-                    final byte[] names = new byte[(int)(size - 1)];
-                    header.get(names);
-                    int nextFile = 0;
-                    int nextName = 0;
-                    for (int i = 0; i < names.length; i += 2) {
-                        if (names[i] == 0 && names[i+1] == 0) {
-                            files[nextFile++].setName(new String(names, nextName, i-nextName, CharsetNames.UTF_16LE));
-                            nextName = i + 2;
-                        }
-                    }
-                    if (nextName != names.length || nextFile != files.length) {
-                        throw new IOException("Error parsing file names");
-                    }
-                    break;
-                }
-                case NID.kCTime: {
-                    final BitSet timesDefined = readAllOrBits(header, files.length);
-                    final int external = getUnsignedByte(header);
-                    if (external != 0) {
-                        throw new IOException("Unimplemented");
-                    }
-                    for (int i = 0; i < files.length; i++) {
-                        files[i].setHasCreationDate(timesDefined.get(i));
-                        if (files[i].getHasCreationDate()) {
-                            files[i].setCreationDate(header.getLong());
-                        }
-                    }
-                    break;
-                }
-                case NID.kATime: {
-                    final BitSet timesDefined = readAllOrBits(header, files.length);
-                    final int external = getUnsignedByte(header);
-                    if (external != 0) {
-                        throw new IOException("Unimplemented");
-                    }
-                    for (int i = 0; i < files.length; i++) {
-                        files[i].setHasAccessDate(timesDefined.get(i));
-                        if (files[i].getHasAccessDate()) {
-                            files[i].setAccessDate(header.getLong());
-                        }
-                    }
-                    break;
-                }
-                case NID.kMTime: {
-                    final BitSet timesDefined = readAllOrBits(header, files.length);
-                    final int external = getUnsignedByte(header);
-                    if (external != 0) {
-                        throw new IOException("Unimplemented");
-                    }
-                    for (int i = 0; i < files.length; i++) {
-                        files[i].setHasLastModifiedDate(timesDefined.get(i));
-                        if (files[i].getHasLastModifiedDate()) {
-                            files[i].setLastModifiedDate(header.getLong());
-                        }
-                    }
-                    break;
-                }
-                case NID.kWinAttributes: {
-                    final BitSet attributesDefined = readAllOrBits(header, files.length);
-                    final int external = getUnsignedByte(header);
-                    if (external != 0) {
-                        throw new IOException("Unimplemented");
-                    }
-                    for (int i = 0; i < files.length; i++) {
-                        files[i].setHasWindowsAttributes(attributesDefined.get(i));
-                        if (files[i].getHasWindowsAttributes()) {
-                            files[i].setWindowsAttributes(header.getInt());
-                        }
-                    }
-                    break;
-                }
-                case NID.kStartPos: {
-                    throw new IOException("kStartPos is unsupported, please report");
-                }
-                case NID.kDummy: {
-                    // 7z 9.20 asserts the content is all zeros and ignores the property
-                    // Compress up to 1.8.1 would throw an exception, now we ignore it (see COMPRESS-287
-
-                    if (skipBytesFully(header, size) < size) {
-                        throw new IOException("Incomplete kDummy property");
-                    }
-                    break;
-                }
-
-                default: {
-                    // Compress up to 1.8.1 would throw an exception, now we ignore it (see COMPRESS-287
-                    if (skipBytesFully(header, size) < size) {
-                        throw new IOException("Incomplete property of type " + propertyType);
-                    }
-                    break;
-                }
+            break;
+          }
+        case NID.kStartPos:
+          {
+            throw new IOException("kStartPos is unsupported, please report");
+          }
+        case NID.kDummy:
+          {
+            // 7z 9.20 asserts the content is all zeros and ignores the property
+            // Compress up to 1.8.1 would throw an exception, now we ignore it (see COMPRESS-287
+
+            if (skipBytesFully(header, size) < size) {
+              throw new IOException("Incomplete kDummy property");
             }
-        }
-        int nonEmptyFileCounter = 0;
-        int emptyFileCounter = 0;
-        for (int i = 0; i < files.length; i++) {
-            files[i].setHasStream(isEmptyStream == null || !isEmptyStream.get(i));
-            if (files[i].hasStream()) {
-                files[i].setDirectory(false);
-                files[i].setAntiItem(false);
-                files[i].setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));
-                files[i].setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);
-                files[i].setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);
-                ++nonEmptyFileCounter;
-            } else {
-                files[i].setDirectory(isEmptyFile == null || !isEmptyFile.get(emptyFileCounter));
-                files[i].setAntiItem(isAnti != null && isAnti.get(emptyFileCounter));
-                files[i].setHasCrc(false);
-                files[i].setSize(0);
-                ++emptyFileCounter;
+            break;
+          }
+
+        default:
+          {
+            // Compress up to 1.8.1 would throw an exception, now we ignore it (see COMPRESS-287
+            if (skipBytesFully(header, size) < size) {
+              throw new IOException("Incomplete property of type " + propertyType);
             }
-        }
-        archive.files = files;
-        calculateStreamMap(archive);
+            break;
+          }
+      }
     }
-
-    private void calculateStreamMap(final Archive archive) throws IOException {
-        final StreamMap streamMap = new StreamMap();
-
-        int nextFolderPackStreamIndex = 0;
-        final int numFolders = archive.folders != null ? archive.folders.length : 0;
-        streamMap.folderFirstPackStreamIndex = new int[numFolders];
-        for (int i = 0; i < numFolders; i++) {
-            streamMap.folderFirstPackStreamIndex[i] = nextFolderPackStreamIndex;
-            nextFolderPackStreamIndex += archive.folders[i].packedStreams.length;
-        }
-
-        long nextPackStreamOffset = 0;
-        final int numPackSizes = archive.packSizes != null ? archive.packSizes.length : 0;
-        streamMap.packStreamOffsets = new long[numPackSizes];
-        for (int i = 0; i < numPackSizes; i++) {
-            streamMap.packStreamOffsets[i] = nextPackStreamOffset;
-            nextPackStreamOffset += archive.packSizes[i];
-        }
-
-        streamMap.folderFirstFileIndex = new int[numFolders];
-        streamMap.fileFolderIndex = new int[archive.files.length];
-        int nextFolderIndex = 0;
-        int nextFolderUnpackStreamIndex = 0;
-        for (int i = 0; i < archive.files.length; i++) {
-            if (!archive.files[i].hasStream() && nextFolderUnpackStreamIndex == 0) {
-                streamMap.fileFolderIndex[i] = -1;
-                continue;
-            }
-            if (nextFolderUnpackStreamIndex == 0) {
-                for (; nextFolderIndex < archive.folders.length; ++nextFolderIndex) {
-                    streamMap.folderFirstFileIndex[nextFolderIndex] = i;
-                    if (archive.folders[nextFolderIndex].numUnpackSubStreams > 0) {
-                        break;
-                    }
-                }
-                if (nextFolderIndex >= archive.folders.length) {
-                    throw new IOException("Too few folders in archive");
-                }
-            }
-            streamMap.fileFolderIndex[i] = nextFolderIndex;
-            if (!archive.files[i].hasStream()) {
-                continue;
-            }
-            ++nextFolderUnpackStreamIndex;
-            if (nextFolderUnpackStreamIndex >= archive.folders[nextFolderIndex].numUnpackSubStreams) {
-                ++nextFolderIndex;
-                nextFolderUnpackStreamIndex = 0;
-            }
-        }
-
-        archive.streamMap = streamMap;
+    int nonEmptyFileCounter = 0;
+    int emptyFileCounter = 0;
+    for (int i = 0; i < files.length; i++) {
+      files[i].setHasStream(isEmptyStream == null || !isEmptyStream.get(i));
+      if (files[i].hasStream()) {
+        files[i].setDirectory(false);
+        files[i].setAntiItem(false);
+        files[i].setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));
+        files[i].setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);
+        files[i].setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);
+        ++nonEmptyFileCounter;
+      } else {
+        files[i].setDirectory(isEmptyFile == null || !isEmptyFile.get(emptyFileCounter));
+        files[i].setAntiItem(isAnti != null && isAnti.get(emptyFileCounter));
+        files[i].setHasCrc(false);
+        files[i].setSize(0);
+        ++emptyFileCounter;
+      }
+    }
+    archive.files = files;
+    calculateStreamMap(archive);
+  }
+
+  private void calculateStreamMap(final Archive archive) throws IOException {
+    final StreamMap streamMap = new StreamMap();
+
+    int nextFolderPackStreamIndex = 0;
+    final int numFolders = archive.folders != null ? archive.folders.length : 0;
+    streamMap.folderFirstPackStreamIndex = new int[numFolders];
+    for (int i = 0; i < numFolders; i++) {
+      streamMap.folderFirstPackStreamIndex[i] = nextFolderPackStreamIndex;
+      nextFolderPackStreamIndex += archive.folders[i].packedStreams.length;
     }
 
-    private void buildDecodingStream() throws IOException {
-        final int folderIndex = archive.streamMap.fileFolderIndex[currentEntryIndex];
-        if (folderIndex < 0) {
-            deferredBlockStreams.clear();
-            // TODO: previously it'd return an empty stream?
-            // new BoundedInputStream(new ByteArrayInputStream(new byte[0]), 0);
-            return;
-        }
-        final SevenZArchiveEntry file = archive.files[currentEntryIndex];
-        if (currentFolderIndex == folderIndex) {
-            // (COMPRESS-320).
-            // The current entry is within the same (potentially opened) folder. The
-            // previous stream has to be fully decoded before we can start reading
-            // but don't do it eagerly -- if the user skips over the entire folder nothing
-            // is effectively decompressed.
-
-            file.setContentMethods(archive.files[currentEntryIndex - 1].getContentMethods());
-        } else {
-            // We're opening a new folder. Discard any queued streams/ folder stream.
-            currentFolderIndex = folderIndex;
-            deferredBlockStreams.clear();
-            if (currentFolderInputStream != null) {
-                currentFolderInputStream.close();
-                currentFolderInputStream = null;
-            }
+    long nextPackStreamOffset = 0;
+    final int numPackSizes = archive.packSizes != null ? archive.packSizes.length : 0;
+    streamMap.packStreamOffsets = new long[numPackSizes];
+    for (int i = 0; i < numPackSizes; i++) {
+      streamMap.packStreamOffsets[i] = nextPackStreamOffset;
+      nextPackStreamOffset += archive.packSizes[i];
+    }
 
-            final Folder folder = archive.folders[folderIndex];
-            final int firstPackStreamIndex = archive.streamMap.folderFirstPackStreamIndex[folderIndex];
-            final long folderOffset = SIGNATURE_HEADER_SIZE + archive.packPos +
-                    archive.streamMap.packStreamOffsets[firstPackStreamIndex];
-            currentFolderInputStream = buildDecoderStack(folder, folderOffset, firstPackStreamIndex, file);
-        }
+    streamMap.folderFirstFileIndex = new int[numFolders];
+    streamMap.fileFolderIndex = new int[archive.files.length];
+    int nextFolderIndex = 0;
+    int nextFolderUnpackStreamIndex = 0;
+    for (int i = 0; i < archive.files.length; i++) {
+      if (!archive.files[i].hasStream() && nextFolderUnpackStreamIndex == 0) {
+        streamMap.fileFolderIndex[i] = -1;
+        continue;
+      }
+      if (nextFolderUnpackStreamIndex == 0) {
+        for (; nextFolderIndex < archive.folders.length; ++nextFolderIndex) {
+          streamMap.folderFirstFileIndex[nextFolderIndex] = i;
+          if (archive.folders[nextFolderIndex].numUnpackSubStreams > 0) {
+            break;
+          }
+        }
+        if (nextFolderIndex >= archive.folders.length) {
+          throw new IOException("Too few folders in archive");
+        }
+      }
+      streamMap.fileFolderIndex[i] = nextFolderIndex;
+      if (!archive.files[i].hasStream()) {
+        continue;
+      }
+      ++nextFolderUnpackStreamIndex;
+      if (nextFolderUnpackStreamIndex >= archive.folders[nextFolderIndex].numUnpackSubStreams) {
+        ++nextFolderIndex;
+        nextFolderUnpackStreamIndex = 0;
+      }
+    }
 
-        InputStream fileStream = new BoundedInputStream(currentFolderInputStream, file.getSize());
-        if (file.getHasCrc()) {
-            fileStream = new CRC32VerifyingInputStream(fileStream, file.getSize(), file.getCrcValue());
-        }
+    archive.streamMap = streamMap;
+  }
 
-        deferredBlockStreams.add(fileStream);
-    }
-
-    private InputStream buildDecoderStack(final Folder folder, final long folderOffset,
-                final int firstPackStreamIndex, final SevenZArchiveEntry entry) throws IOException {
-        channel.position(folderOffset);
-        InputStream inputStreamStack = new FilterInputStream(new BufferedInputStream(
-              new BoundedFileChannelInputStream(channel,
-                  archive.packSizes[firstPackStreamIndex]))) {
-            @Override
-            public int read() throws IOException {
-                final int r = in.read();
-                if (r >= 0) {
-                    count(1);
-                }
-                return r;
-            }
-            @Override
-            public int read(final byte[] b) throws IOException {
-                return read(b, 0, b.length);
-            }
-            @Override
-            public int read(final byte[] b, final int off, final int len) throws IOException {
-                final int r = in.read(b, off, len);
-                if (r >= 0) {
-                    count(r);
-                }
-                return r;
-            }
-            private void count(int c) {
-                compressedBytesReadFromCurrentEntry += c;
-            }
-        };
-        final LinkedList<SevenZMethodConfiguration> methods = new LinkedList<>();
-        for (final Coder coder : folder.getOrderedCoders()) {
-            if (coder.numInStreams != 1 || coder.numOutStreams != 1) {
-                throw new IOException("Multi input/output stream coders are not yet supported");
-            }
-            final SevenZMethod method = SevenZMethod.byId(coder.decompressionMethodId);
-            inputStreamStack = Coders.addDecoder(fileName, inputStreamStack,
-                    folder.getUnpackSizeForCoder(coder), coder, password);
-            methods.addFirst(new SevenZMethodConfiguration(method,
-                     Coders.findByMethod(method).getOptionsFromCoder(coder, inputStreamStack)));
-        }
-        entry.setContentMethods(methods);
-        if (folder.hasCrc) {
-            return new CRC32VerifyingInputStream(inputStreamStack,
-                    folder.getUnpackSize(), folder.crc);
-        }
-        return inputStreamStack;
-    }
-
-    /**
-     * Reads a byte of data.
-     *
-     * @return the byte read, or -1 if end of input is reached
-     * @throws IOException
-     *             if an I/O error has occurred
-     */
-    public int read() throws IOException {
-        int b = getCurrentStream().read();
-        if (b >= 0) {
-            uncompressedBytesReadFromCurrentEntry++;
-        }
-        return b;
+  private void buildDecodingStream() throws IOException {
+    final int folderIndex = archive.streamMap.fileFolderIndex[currentEntryIndex];
+    if (folderIndex < 0) {
+      deferredBlockStreams.clear();
+      // TODO: previously it'd return an empty stream?
+      // new BoundedInputStream(new ByteArrayInputStream(new byte[0]), 0);
+      return;
+    }
+    final SevenZArchiveEntry file = archive.files[currentEntryIndex];
+    if (currentFolderIndex == folderIndex) {
+      // (COMPRESS-320).
+      // The current entry is within the same (potentially opened) folder. The
+      // previous stream has to be fully decoded before we can start reading
+      // but don't do it eagerly -- if the user skips over the entire folder nothing
+      // is effectively decompressed.
+
+      file.setContentMethods(archive.files[currentEntryIndex - 1].getContentMethods());
+    } else {
+      // We're opening a new folder. Discard any queued streams/ folder stream.
+      currentFolderIndex = folderIndex;
+      deferredBlockStreams.clear();
+      if (currentFolderInputStream != null) {
+        currentFolderInputStream.close();
+        currentFolderInputStream = null;
+      }
+
+      final Folder folder = archive.folders[folderIndex];
+      final int firstPackStreamIndex = archive.streamMap.folderFirstPackStreamIndex[folderIndex];
+      final long folderOffset =
+          SIGNATURE_HEADER_SIZE
+              + archive.packPos
+              + archive.streamMap.packStreamOffsets[firstPackStreamIndex];
+      currentFolderInputStream =
+          buildDecoderStack(folder, folderOffset, firstPackStreamIndex, file);
     }
 
-    private InputStream getCurrentStream() throws IOException {
-        if (archive.files[currentEntryIndex].getSize() == 0) {
-            return new ByteArrayInputStream(new byte[0]);
-        }
-        if (deferredBlockStreams.isEmpty()) {
-            throw new IllegalStateException("No current 7z entry (call getNextEntry() first).");
-        }
-
-        while (deferredBlockStreams.size() > 1) {
-            // In solid compression mode we need to decompress all leading folder'
-            // streams to get access to an entry. We defer this until really needed
-            // so that entire blocks can be skipped without wasting time for decompression.
-            final InputStream stream = deferredBlockStreams.remove(0);
-            IOUtils.skip(stream, Long.MAX_VALUE);
-            compressedBytesReadFromCurrentEntry = 0;
-        }
+    InputStream fileStream = new BoundedInputStream(currentFolderInputStream, file.getSize());
+    if (file.getHasCrc()) {
+      fileStream = new CRC32VerifyingInputStream(fileStream, file.getSize(), file.getCrcValue());
+    }
 
-        return deferredBlockStreams.get(0);
-    }
-
-    /**
-     * Reads data into an array of bytes.
-     *
-     * @param b the array to write data to
-     * @return the number of bytes read, or -1 if end of input is reached
-     * @throws IOException
-     *             if an I/O error has occurred
-     */
-    public int read(final byte[] b) throws IOException {
-        return read(b, 0, b.length);
-    }
-
-    /**
-     * Reads data into an array of bytes.
-     *
-     * @param b the array to write data to
-     * @param off offset into the buffer to start filling at
-     * @param len of bytes to read
-     * @return the number of bytes read, or -1 if end of input is reached
-     * @throws IOException
-     *             if an I/O error has occurred
-     */
-    public int read(final byte[] b, final int off, final int len) throws IOException {
-        int cnt = getCurrentStream().read(b, off, len);
-        if (cnt > 0) {
-            uncompressedBytesReadFromCurrentEntry += cnt;
-        }
-        return cnt;
-    }
-
-    /**
-     * Provides statistics for bytes read from the current entry.
-     *
-     * @return statistics for bytes read from the current entry
-     * @since 1.17
-     */
-    public InputStreamStatistics getStatisticsForCurrentEntry() {
-        return new InputStreamStatistics() {
-            @Override
-            public long getCompressedCount() {
-                return compressedBytesReadFromCurrentEntry;
+    deferredBlockStreams.add(fileStream);
+  }
+
+  private InputStream buildDecoderStack(
+      final Folder folder,
+      final long folderOffset,
+      final int firstPackStreamIndex,
+      final SevenZArchiveEntry entry)
+      throws IOException {
+    channel.position(folderOffset);
+    InputStream inputStreamStack =
+        new FilterInputStream(
+            new BufferedInputStream(
+                new BoundedFileChannelInputStream(
+                    channel, archive.packSizes[firstPackStreamIndex]))) {
+          @Override
+          public int read() throws IOException {
+            final int r = in.read();
+            if (r >= 0) {
+              count(1);
             }
-            @Override
-            public long getUncompressedCount() {
-                return uncompressedBytesReadFromCurrentEntry;
+            return r;
+          }
+
+          @Override
+          public int read(final byte[] b) throws IOException {
+            return read(b, 0, b.length);
+          }
+
+          @Override
+          public int read(final byte[] b, final int off, final int len) throws IOException {
+            final int r = in.read(b, off, len);
+            if (r >= 0) {
+              count(r);
             }
+            return r;
+          }
+
+          private void count(int c) {
+            compressedBytesReadFromCurrentEntry += c;
+          }
         };
+    final LinkedList<SevenZMethodConfiguration> methods = new LinkedList<>();
+    for (final Coder coder : folder.getOrderedCoders()) {
+      if (coder.numInStreams != 1 || coder.numOutStreams != 1) {
+        throw new IOException("Multi input/output stream coders are not yet supported");
+      }
+      final SevenZMethod method = SevenZMethod.byId(coder.decompressionMethodId);
+      inputStreamStack =
+          Coders.addDecoder(
+              fileName, inputStreamStack, folder.getUnpackSizeForCoder(coder), coder, password);
+      methods.addFirst(
+          new SevenZMethodConfiguration(
+              method, Coders.findByMethod(method).getOptionsFromCoder(coder, inputStreamStack)));
     }
-
-    private static long readUint64(final ByteBuffer in) throws IOException {
-        // long rather than int as it might get shifted beyond the range of an int
-        final long firstByte = getUnsignedByte(in);
-        int mask = 0x80;
-        long value = 0;
-        for (int i = 0; i < 8; i++) {
-            if ((firstByte & mask) == 0) {
-                return value | ((firstByte & (mask - 1)) << (8 * i));
-            }
-            final long nextByte = getUnsignedByte(in);
-            value |= nextByte << (8 * i);
-            mask >>>= 1;
-        }
-        return value;
-    }
-
-    private static int getUnsignedByte(ByteBuffer buf) {
-        return buf.get() & 0xff;
-    }
-
-    /**
-     * Checks if the signature matches what is expected for a 7z file.
-     *
-     * @param signature
-     *            the bytes to check
-     * @param length
-     *            the number of bytes to check
-     * @return true, if this is the signature of a 7z archive.
-     * @since 1.8
-     */
-    public static boolean matches(final byte[] signature, final int length) {
-        if (length < sevenZSignature.length) {
-            return false;
-        }
-
-        for (int i = 0; i < sevenZSignature.length; i++) {
-            if (signature[i] != sevenZSignature[i]) {
-                return false;
-            }
-        }
-        return true;
+    entry.setContentMethods(methods);
+    if (folder.hasCrc) {
+      return new CRC32VerifyingInputStream(inputStreamStack, folder.getUnpackSize(), folder.crc);
+    }
+    return inputStreamStack;
+  }
+
+  /**
+   * Reads a byte of data.
+   *
+   * @return the byte read, or -1 if end of input is reached
+   * @throws IOException if an I/O error has occurred
+   */
+  public int read() throws IOException {
+    int b = getCurrentStream().read();
+    if (b >= 0) {
+      uncompressedBytesReadFromCurrentEntry++;
     }
+    return b;
+  }
 
-    private static long skipBytesFully(final ByteBuffer input, long bytesToSkip) throws IOException {
-        if (bytesToSkip < 1) {
-            return 0;
-        }
-        int current = input.position();
-        int maxSkip = input.remaining();
-        if (maxSkip < bytesToSkip) {
-            bytesToSkip = maxSkip;
-        }
-        input.position(current + (int) bytesToSkip);
-        return bytesToSkip;
+  private InputStream getCurrentStream() throws IOException {
+    if (archive.files[currentEntryIndex].getSize() == 0) {
+      return new ByteArrayInputStream(new byte[0]);
+    }
+    if (deferredBlockStreams.isEmpty()) {
+      throw new IllegalStateException("No current 7z entry (call getNextEntry() first).");
     }
 
-    private void readFully(ByteBuffer buf) throws IOException {
-        buf.rewind();
-        IOUtils.readFully(channel, buf);
-        buf.flip();
+    while (deferredBlockStreams.size() > 1) {
+      // In solid compression mode we need to decompress all leading folder'
+      // streams to get access to an entry. We defer this until really needed
+      // so that entire blocks can be skipped without wasting time for decompression.
+      final InputStream stream = deferredBlockStreams.remove(0);
+      IOUtils.skip(stream, Long.MAX_VALUE);
+      compressedBytesReadFromCurrentEntry = 0;
     }
 
-    @Override
-    public String toString() {
-      return archive.toString();
+    return deferredBlockStreams.get(0);
+  }
+
+  /**
+   * Reads data into an array of bytes.
+   *
+   * @param b the array to write data to
+   * @return the number of bytes read, or -1 if end of input is reached
+   * @throws IOException if an I/O error has occurred
+   */
+  public int read(final byte[] b) throws IOException {
+    return read(b, 0, b.length);
+  }
+
+  /**
+   * Reads data into an array of bytes.
+   *
+   * @param b the array to write data to
+   * @param off offset into the buffer to start filling at
+   * @param len of bytes to read
+   * @return the number of bytes read, or -1 if end of input is reached
+   * @throws IOException if an I/O error has occurred
+   */
+  public int read(final byte[] b, final int off, final int len) throws IOException {
+    int cnt = getCurrentStream().read(b, off, len);
+    if (cnt > 0) {
+      uncompressedBytesReadFromCurrentEntry += cnt;
+    }
+    return cnt;
+  }
+
+  /**
+   * Provides statistics for bytes read from the current entry.
+   *
+   * @return statistics for bytes read from the current entry
+   * @since 1.17
+   */
+  public InputStreamStatistics getStatisticsForCurrentEntry() {
+    return new InputStreamStatistics() {
+      @Override
+      public long getCompressedCount() {
+        return compressedBytesReadFromCurrentEntry;
+      }
+
+      @Override
+      public long getUncompressedCount() {
+        return uncompressedBytesReadFromCurrentEntry;
+      }
+    };
+  }
+
+  private static long readUint64(final ByteBuffer in) throws IOException {
+    // long rather than int as it might get shifted beyond the range of an int
+    final long firstByte = getUnsignedByte(in);
+    int mask = 0x80;
+    long value = 0;
+    for (int i = 0; i < 8; i++) {
+      if ((firstByte & mask) == 0) {
+        return value | ((firstByte & (mask - 1)) << (8 * i));
+      }
+      final long nextByte = getUnsignedByte(in);
+      value |= nextByte << (8 * i);
+      mask >>>= 1;
+    }
+    return value;
+  }
+
+  private static int getUnsignedByte(ByteBuffer buf) {
+    return buf.get() & 0xff;
+  }
+
+  /**
+   * Checks if the signature matches what is expected for a 7z file.
+   *
+   * @param signature the bytes to check
+   * @param length the number of bytes to check
+   * @return true, if this is the signature of a 7z archive.
+   * @since 1.8
+   */
+  public static boolean matches(final byte[] signature, final int length) {
+    if (length < sevenZSignature.length) {
+      return false;
     }
 
-    private static final CharsetEncoder PASSWORD_ENCODER = Charset.forName("UTF-16LE").newEncoder();
+    for (int i = 0; i < sevenZSignature.length; i++) {
+      if (signature[i] != sevenZSignature[i]) {
+        return false;
+      }
+    }
+    return true;
+  }
 
-    private static byte[] utf16Decode(char[] chars) throws IOException {
-        if (chars == null) {
-            return null;
-        }
-        ByteBuffer encoded = PASSWORD_ENCODER.encode(CharBuffer.wrap(chars));
-        if (encoded.hasArray()) {
-            return encoded.array();
-        }
-        byte[] e = new byte[encoded.remaining()];
-        encoded.get(e);
-        return e;
+  private static long skipBytesFully(final ByteBuffer input, long bytesToSkip) throws IOException {
+    if (bytesToSkip < 1) {
+      return 0;
+    }
+    int current = input.position();
+    int maxSkip = input.remaining();
+    if (maxSkip < bytesToSkip) {
+      bytesToSkip = maxSkip;
+    }
+    input.position(current + (int) bytesToSkip);
+    return bytesToSkip;
+  }
+
+  private void readFully(ByteBuffer buf) throws IOException {
+    buf.rewind();
+    IOUtils.readFully(channel, buf);
+    buf.flip();
+  }
+
+  @Override
+  public String toString() {
+    return archive.toString();
+  }
+
+  private static final CharsetEncoder PASSWORD_ENCODER = Charset.forName("UTF-16LE").newEncoder();
+
+  private static byte[] utf16Decode(char[] chars) throws IOException {
+    if (chars == null) {
+      return null;
+    }
+    ByteBuffer encoded = PASSWORD_ENCODER.encode(CharBuffer.wrap(chars));
+    if (encoded.hasArray()) {
+      return encoded.array();
     }
+    byte[] e = new byte[encoded.remaining()];
+    encoded.get(e);
+    return e;
+  }
 }
diff --git a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/SevenZMethod.java b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/SevenZMethod.java
index 5b42c8733..4709caff5 100644
--- a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/SevenZMethod.java
+++ b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/SevenZMethod.java
@@ -1,20 +1,23 @@
 /*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * This file is part of Amaze File Manager.
  *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
  *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
+
 package com.amaze.filemanager.filesystem.compressed.sevenz;
 
 import java.util.Arrays;
@@ -22,92 +25,98 @@ import java.util.Arrays;
 /**
  * The (partially) supported compression/encryption methods used in 7z archives.
  *
- * <p>All methods with a _FILTER suffix are used as preprocessors with
- * the goal of creating a better compression ratio with the compressor
- * that comes next in the chain of methods.  7z will in general only
- * allow them to be used together with a "real" compression method but
- * Commons Compress doesn't enforce this.</p>
+ * <p>All methods with a _FILTER suffix are used as preprocessors with the goal of creating a better
+ * compression ratio with the compressor that comes next in the chain of methods. 7z will in general
+ * only allow them to be used together with a "real" compression method but Commons Compress doesn't
+ * enforce this.
  *
- * <p>The BCJ_ filters work on executable files for the given platform
- * and convert relative addresses to absolute addresses in CALL
- * instructions.  This means they are only useful when applied to
- * executables of the chosen platform.</p>
+ * <p>The BCJ_ filters work on executable files for the given platform and convert relative
+ * addresses to absolute addresses in CALL instructions. This means they are only useful when
+ * applied to executables of the chosen platform.
  */
 public enum SevenZMethod {
-    /** no compression at all */
-    COPY(new byte[] { (byte)0x00 }),
-    /** LZMA - only supported when reading */
-    LZMA(new byte[] { (byte)0x03, (byte)0x01, (byte)0x01 }),
-    /** LZMA2 */
-    LZMA2(new byte[] { (byte)0x21 }),
-    /** Deflate */
-    DEFLATE(new byte[] { (byte)0x04, (byte)0x01, (byte)0x08 }),
-    /**
-     * Deflate64
-     * @since 1.16
-     */
-    DEFLATE64(new byte[] { (byte)0x04, (byte)0x01, (byte)0x09 }),
-    /** BZIP2 */
-    BZIP2(new byte[] { (byte)0x04, (byte)0x02, (byte)0x02 }),
-    /**
-     * AES encryption with a key length of 256 bit using SHA256 for
-     * hashes - only supported when reading
-     */
-    AES256SHA256(new byte[] { (byte)0x06, (byte)0xf1, (byte)0x07, (byte)0x01 }),
-    /**
-     * BCJ x86 platform version 1.
-     * @since 1.8
-     */
-    BCJ_X86_FILTER(new byte[] { 0x03, 0x03, 0x01, 0x03 }),
-    /**
-     * BCJ PowerPC platform.
-     * @since 1.8
-     */
-    BCJ_PPC_FILTER(new byte[] { 0x03, 0x03, 0x02, 0x05 }),
-    /**
-     * BCJ I64 platform.
-     * @since 1.8
-     */
-    BCJ_IA64_FILTER(new byte[] { 0x03, 0x03, 0x04, 0x01 }),
-    /**
-     * BCJ ARM platform.
-     * @since 1.8
-     */
-    BCJ_ARM_FILTER(new byte[] { 0x03, 0x03, 0x05, 0x01 }),
-    /**
-     * BCJ ARM Thumb platform.
-     * @since 1.8
-     */
-    BCJ_ARM_THUMB_FILTER(new byte[] { 0x03, 0x03, 0x07, 0x01 }),
-    /**
-     * BCJ Sparc platform.
-     * @since 1.8
-     */
-    BCJ_SPARC_FILTER(new byte[] { 0x03, 0x03, 0x08, 0x05 }),
-    /**
-     * Delta filter.
-     * @since 1.8
-     */
-    DELTA_FILTER(new byte[] { 0x03 });
+  /** no compression at all */
+  COPY(new byte[] {(byte) 0x00}),
+  /** LZMA - only supported when reading */
+  LZMA(new byte[] {(byte) 0x03, (byte) 0x01, (byte) 0x01}),
+  /** LZMA2 */
+  LZMA2(new byte[] {(byte) 0x21}),
+  /** Deflate */
+  DEFLATE(new byte[] {(byte) 0x04, (byte) 0x01, (byte) 0x08}),
+  /**
+   * Deflate64
+   *
+   * @since 1.16
+   */
+  DEFLATE64(new byte[] {(byte) 0x04, (byte) 0x01, (byte) 0x09}),
+  /** BZIP2 */
+  BZIP2(new byte[] {(byte) 0x04, (byte) 0x02, (byte) 0x02}),
+  /**
+   * AES encryption with a key length of 256 bit using SHA256 for hashes - only supported when
+   * reading
+   */
+  AES256SHA256(new byte[] {(byte) 0x06, (byte) 0xf1, (byte) 0x07, (byte) 0x01}),
+  /**
+   * BCJ x86 platform version 1.
+   *
+   * @since 1.8
+   */
+  BCJ_X86_FILTER(new byte[] {0x03, 0x03, 0x01, 0x03}),
+  /**
+   * BCJ PowerPC platform.
+   *
+   * @since 1.8
+   */
+  BCJ_PPC_FILTER(new byte[] {0x03, 0x03, 0x02, 0x05}),
+  /**
+   * BCJ I64 platform.
+   *
+   * @since 1.8
+   */
+  BCJ_IA64_FILTER(new byte[] {0x03, 0x03, 0x04, 0x01}),
+  /**
+   * BCJ ARM platform.
+   *
+   * @since 1.8
+   */
+  BCJ_ARM_FILTER(new byte[] {0x03, 0x03, 0x05, 0x01}),
+  /**
+   * BCJ ARM Thumb platform.
+   *
+   * @since 1.8
+   */
+  BCJ_ARM_THUMB_FILTER(new byte[] {0x03, 0x03, 0x07, 0x01}),
+  /**
+   * BCJ Sparc platform.
+   *
+   * @since 1.8
+   */
+  BCJ_SPARC_FILTER(new byte[] {0x03, 0x03, 0x08, 0x05}),
+  /**
+   * Delta filter.
+   *
+   * @since 1.8
+   */
+  DELTA_FILTER(new byte[] {0x03});
 
-    private final byte[] id;
+  private final byte[] id;
 
-    SevenZMethod(final byte[] id) {
-        this.id = id;
-    }
+  SevenZMethod(final byte[] id) {
+    this.id = id;
+  }
 
-    byte[] getId() {
-        final byte[] copy = new byte[id.length];
-        System.arraycopy(id, 0, copy, 0, id.length);
-        return copy;
-    }
+  byte[] getId() {
+    final byte[] copy = new byte[id.length];
+    System.arraycopy(id, 0, copy, 0, id.length);
+    return copy;
+  }
 
-    static SevenZMethod byId(final byte[] id) {
-        for (final SevenZMethod m : SevenZMethod.class.getEnumConstants()) {
-            if (Arrays.equals(m.id, id)) {
-                return m;
-            }
-        }
-        return null;
+  static SevenZMethod byId(final byte[] id) {
+    for (final SevenZMethod m : SevenZMethod.class.getEnumConstants()) {
+      if (Arrays.equals(m.id, id)) {
+        return m;
+      }
     }
+    return null;
+  }
 }
diff --git a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/SevenZMethodConfiguration.java b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/SevenZMethodConfiguration.java
index 6b05f976c..1145ddc60 100644
--- a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/SevenZMethodConfiguration.java
+++ b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/SevenZMethodConfiguration.java
@@ -1,27 +1,30 @@
 /*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * This file is part of Amaze File Manager.
  *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
  *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
+
 package com.amaze.filemanager.filesystem.compressed.sevenz;
 
 /**
  * Combines a SevenZMethod with configuration options for the method.
  *
- * <p>The exact type and interpretation of options depends on the
- * method being configured.  Currently supported are:</p>
+ * <p>The exact type and interpretation of options depends on the method being configured. Currently
+ * supported are:
  *
  * <table summary="Options">
  * <tr><th>Method</th><th>Option Type</th><th>Description</th></tr>
@@ -33,49 +36,53 @@ package com.amaze.filemanager.filesystem.compressed.sevenz;
  * </table>
  *
  * @Immutable
+ *
  * @since 1.8
  */
 public class SevenZMethodConfiguration {
-    private final SevenZMethod method;
-    private final Object options;
+  private final SevenZMethod method;
+  private final Object options;
 
-    /**
-     * Doesn't configure any additional options.
-     * @param method the method to use
-     */
-    public SevenZMethodConfiguration(final SevenZMethod method) {
-        this(method, null);
-    }
+  /**
+   * Doesn't configure any additional options.
+   *
+   * @param method the method to use
+   */
+  public SevenZMethodConfiguration(final SevenZMethod method) {
+    this(method, null);
+  }
 
-    /**
-     * Specifies and method plus configuration options.
-     * @param method the method to use
-     * @param options the options to use
-     * @throws IllegalArgumentException if the method doesn't understand the options specified.
-     */
-    public SevenZMethodConfiguration(final SevenZMethod method, final Object options) {
-        this.method = method;
-        this.options = options;
-        if (options != null && !Coders.findByMethod(method).canAcceptOptions(options)) {
-            throw new IllegalArgumentException("The " + method + " method doesn't support options of type "
-                                               + options.getClass());
-        }
+  /**
+   * Specifies and method plus configuration options.
+   *
+   * @param method the method to use
+   * @param options the options to use
+   * @throws IllegalArgumentException if the method doesn't understand the options specified.
+   */
+  public SevenZMethodConfiguration(final SevenZMethod method, final Object options) {
+    this.method = method;
+    this.options = options;
+    if (options != null && !Coders.findByMethod(method).canAcceptOptions(options)) {
+      throw new IllegalArgumentException(
+          "The " + method + " method doesn't support options of type " + options.getClass());
     }
+  }
 
-    /**
-     * The specified method.
-     * @return the method
-     */
-    public SevenZMethod getMethod() {
-        return method;
-    }
-
-    /**
-     * The specified options.
-     * @return the options
-     */
-    public Object getOptions() {
-        return options;
-    }
+  /**
+   * The specified method.
+   *
+   * @return the method
+   */
+  public SevenZMethod getMethod() {
+    return method;
+  }
 
+  /**
+   * The specified options.
+   *
+   * @return the options
+   */
+  public Object getOptions() {
+    return options;
+  }
 }
diff --git a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/SevenZOutputFile.java b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/SevenZOutputFile.java
index 81b5576c6..685aa0bc7 100644
--- a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/SevenZOutputFile.java
+++ b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/SevenZOutputFile.java
@@ -1,23 +1,24 @@
 /*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * This file is part of Amaze File Manager.
  *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
  *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
-package com.amaze.filemanager.filesystem.compressed.sevenz;
 
-import android.annotation.TargetApi;
+package com.amaze.filemanager.filesystem.compressed.sevenz;
 
 import java.io.ByteArrayOutputStream;
 import java.io.Closeable;
@@ -29,17 +30,13 @@ import java.io.OutputStream;
 import java.io.RandomAccessFile;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
-import java.nio.channels.SeekableByteChannel;
-import java.nio.file.Files;
-import java.nio.file.StandardOpenOption;
 import java.util.ArrayList;
 import java.util.BitSet;
 import java.util.Collections;
 import java.util.Date;
-import java.util.EnumSet;
 import java.util.HashMap;
-import java.util.List;
 import java.util.LinkedList;
+import java.util.List;
 import java.util.Map;
 import java.util.zip.CRC32;
 
@@ -48,765 +45,769 @@ import org.apache.commons.compress.utils.CountingOutputStream;
 
 /**
  * Writes a 7z file.
+ *
  * @since 1.6
  */
 public class SevenZOutputFile implements Closeable {
-    private final RandomAccessFile channel;
-    private final List<SevenZArchiveEntry> files = new ArrayList<>();
-    private int numNonEmptyStreams = 0;
-    private final CRC32 crc32 = new CRC32();
-    private final CRC32 compressedCrc32 = new CRC32();
-    private long fileBytesWritten = 0;
-    private boolean finished = false;
-    private CountingOutputStream currentOutputStream;
-    private CountingOutputStream[] additionalCountingStreams;
-    private Iterable<? extends SevenZMethodConfiguration> contentMethods =
-            Collections.singletonList(new SevenZMethodConfiguration(SevenZMethod.LZMA2));
-    private final Map<SevenZArchiveEntry, long[]> additionalSizes = new HashMap<>();
-
-    /**
-     * Opens file to write a 7z archive to.
-     *
-     * @param filename the file to write to
-     * @throws IOException if opening the file fails
-     */
-    public SevenZOutputFile(final File filename) throws IOException {
-        this(new RandomAccessFile(filename, ""));
-    }
-
-    /**
-     * Prepares channel to write a 7z archive to.
-     *
-     * <p>{@link
-     * org.apache.commons.compress.utils.SeekableInMemoryByteChannel}
-     * allows you to write to an in-memory archive.</p>
-     *
-     * @param channel the channel to write to
-     * @throws IOException if the channel cannot be positioned properly
-     * @since 1.13
-     */
-    public SevenZOutputFile(final RandomAccessFile channel) throws IOException {
-        this.channel = channel;
-        channel.seek(SevenZFile.SIGNATURE_HEADER_SIZE);
-    }
-
-    /**
-     * Sets the default compression method to use for entry contents - the
-     * default is LZMA2.
-     *
-     * <p>Currently only {@link SevenZMethod#COPY}, {@link
-     * SevenZMethod#LZMA2}, {@link SevenZMethod#BZIP2} and {@link
-     * SevenZMethod#DEFLATE} are supported.</p>
-     *
-     * <p>This is a short form for passing a single-element iterable
-     * to {@link #setContentMethods}.</p>
-     * @param method the default compression method
-     */
-    public void setContentCompression(final SevenZMethod method) {
-        setContentMethods(Collections.singletonList(new SevenZMethodConfiguration(method)));
-    }
-
-    /**
-     * Sets the default (compression) methods to use for entry contents - the
-     * default is LZMA2.
-     *
-     * <p>Currently only {@link SevenZMethod#COPY}, {@link
-     * SevenZMethod#LZMA2}, {@link SevenZMethod#BZIP2} and {@link
-     * SevenZMethod#DEFLATE} are supported.</p>
-     *
-     * <p>The methods will be consulted in iteration order to create
-     * the final output.</p>
-     *
-     * @since 1.8
-     * @param methods the default (compression) methods
-     */
-    public void setContentMethods(final Iterable<? extends SevenZMethodConfiguration> methods) {
-        this.contentMethods = reverse(methods);
-    }
-
-    /**
-     * Closes the archive, calling {@link #finish} if necessary.
-     *
-     * @throws IOException on error
-     */
-    @Override
-    public void close() throws IOException {
-        try {
-            if (!finished) {
-                finish();
-            }
-        } finally {
-            channel.close();
-        }
-    }
-
-    /**
-     * Create an archive entry using the inputFile and entryName provided.
-     *
-     * @param inputFile file to create an entry from
-     * @param entryName the name to use
-     * @return the ArchiveEntry set up with details from the file
-     *
-     * @throws IOException on error
-     */
-    public SevenZArchiveEntry createArchiveEntry(final File inputFile,
-            final String entryName) throws IOException {
-        final SevenZArchiveEntry entry = new SevenZArchiveEntry();
-        entry.setDirectory(inputFile.isDirectory());
-        entry.setName(entryName);
-        entry.setLastModifiedDate(new Date(inputFile.lastModified()));
-        return entry;
-    }
-
-    /**
-     * Records an archive entry to add.
-     *
-     * The caller must then write the content to the archive and call
-     * {@link #closeArchiveEntry()} to complete the process.
-     *
-     * @param archiveEntry describes the entry
-     * @throws IOException on error
-     */
-    public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {
-        final SevenZArchiveEntry entry = (SevenZArchiveEntry) archiveEntry;
-        files.add(entry);
-    }
-
-    /**
-     * Closes the archive entry.
-     * @throws IOException on error
-     */
-    public void closeArchiveEntry() throws IOException {
-        if (currentOutputStream != null) {
-            currentOutputStream.flush();
-            currentOutputStream.close();
-        }
+  private final RandomAccessFile channel;
+  private final List<SevenZArchiveEntry> files = new ArrayList<>();
+  private int numNonEmptyStreams = 0;
+  private final CRC32 crc32 = new CRC32();
+  private final CRC32 compressedCrc32 = new CRC32();
+  private long fileBytesWritten = 0;
+  private boolean finished = false;
+  private CountingOutputStream currentOutputStream;
+  private CountingOutputStream[] additionalCountingStreams;
+  private Iterable<? extends SevenZMethodConfiguration> contentMethods =
+      Collections.singletonList(new SevenZMethodConfiguration(SevenZMethod.LZMA2));
+  private final Map<SevenZArchiveEntry, long[]> additionalSizes = new HashMap<>();
+
+  /**
+   * Opens file to write a 7z archive to.
+   *
+   * @param filename the file to write to
+   * @throws IOException if opening the file fails
+   */
+  public SevenZOutputFile(final File filename) throws IOException {
+    this(new RandomAccessFile(filename, ""));
+  }
+
+  /**
+   * Prepares channel to write a 7z archive to.
+   *
+   * <p>{@link org.apache.commons.compress.utils.SeekableInMemoryByteChannel} allows you to write to
+   * an in-memory archive.
+   *
+   * @param channel the channel to write to
+   * @throws IOException if the channel cannot be positioned properly
+   * @since 1.13
+   */
+  public SevenZOutputFile(final RandomAccessFile channel) throws IOException {
+    this.channel = channel;
+    channel.seek(SevenZFile.SIGNATURE_HEADER_SIZE);
+  }
+
+  /**
+   * Sets the default compression method to use for entry contents - the default is LZMA2.
+   *
+   * <p>Currently only {@link SevenZMethod#COPY}, {@link SevenZMethod#LZMA2}, {@link
+   * SevenZMethod#BZIP2} and {@link SevenZMethod#DEFLATE} are supported.
+   *
+   * <p>This is a short form for passing a single-element iterable to {@link #setContentMethods}.
+   *
+   * @param method the default compression method
+   */
+  public void setContentCompression(final SevenZMethod method) {
+    setContentMethods(Collections.singletonList(new SevenZMethodConfiguration(method)));
+  }
+
+  /**
+   * Sets the default (compression) methods to use for entry contents - the default is LZMA2.
+   *
+   * <p>Currently only {@link SevenZMethod#COPY}, {@link SevenZMethod#LZMA2}, {@link
+   * SevenZMethod#BZIP2} and {@link SevenZMethod#DEFLATE} are supported.
+   *
+   * <p>The methods will be consulted in iteration order to create the final output.
+   *
+   * @since 1.8
+   * @param methods the default (compression) methods
+   */
+  public void setContentMethods(final Iterable<? extends SevenZMethodConfiguration> methods) {
+    this.contentMethods = reverse(methods);
+  }
+
+  /**
+   * Closes the archive, calling {@link #finish} if necessary.
+   *
+   * @throws IOException on error
+   */
+  @Override
+  public void close() throws IOException {
+    try {
+      if (!finished) {
+        finish();
+      }
+    } finally {
+      channel.close();
+    }
+  }
+
+  /**
+   * Create an archive entry using the inputFile and entryName provided.
+   *
+   * @param inputFile file to create an entry from
+   * @param entryName the name to use
+   * @return the ArchiveEntry set up with details from the file
+   * @throws IOException on error
+   */
+  public SevenZArchiveEntry createArchiveEntry(final File inputFile, final String entryName)
+      throws IOException {
+    final SevenZArchiveEntry entry = new SevenZArchiveEntry();
+    entry.setDirectory(inputFile.isDirectory());
+    entry.setName(entryName);
+    entry.setLastModifiedDate(new Date(inputFile.lastModified()));
+    return entry;
+  }
+
+  /**
+   * Records an archive entry to add.
+   *
+   * <p>The caller must then write the content to the archive and call {@link #closeArchiveEntry()}
+   * to complete the process.
+   *
+   * @param archiveEntry describes the entry
+   * @throws IOException on error
+   */
+  public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {
+    final SevenZArchiveEntry entry = (SevenZArchiveEntry) archiveEntry;
+    files.add(entry);
+  }
+
+  /**
+   * Closes the archive entry.
+   *
+   * @throws IOException on error
+   */
+  public void closeArchiveEntry() throws IOException {
+    if (currentOutputStream != null) {
+      currentOutputStream.flush();
+      currentOutputStream.close();
+    }
+
+    final SevenZArchiveEntry entry = files.get(files.size() - 1);
+    if (fileBytesWritten > 0) { // this implies currentOutputStream != null
+      entry.setHasStream(true);
+      ++numNonEmptyStreams;
+      entry.setSize(currentOutputStream.getBytesWritten()); // NOSONAR
+      entry.setCompressedSize(fileBytesWritten);
+      entry.setCrcValue(crc32.getValue());
+      entry.setCompressedCrcValue(compressedCrc32.getValue());
+      entry.setHasCrc(true);
+      if (additionalCountingStreams != null) {
+        final long[] sizes = new long[additionalCountingStreams.length];
+        for (int i = 0; i < additionalCountingStreams.length; i++) {
+          sizes[i] = additionalCountingStreams[i].getBytesWritten();
+        }
+        additionalSizes.put(entry, sizes);
+      }
+    } else {
+      entry.setHasStream(false);
+      entry.setSize(0);
+      entry.setCompressedSize(0);
+      entry.setHasCrc(false);
+    }
+    currentOutputStream = null;
+    additionalCountingStreams = null;
+    crc32.reset();
+    compressedCrc32.reset();
+    fileBytesWritten = 0;
+  }
+
+  /**
+   * Writes a byte to the current archive entry.
+   *
+   * @param b The byte to be written.
+   * @throws IOException on error
+   */
+  public void write(final int b) throws IOException {
+    getCurrentOutputStream().write(b);
+  }
+
+  /**
+   * Writes a byte array to the current archive entry.
+   *
+   * @param b The byte array to be written.
+   * @throws IOException on error
+   */
+  public void write(final byte[] b) throws IOException {
+    write(b, 0, b.length);
+  }
+
+  /**
+   * Writes part of a byte array to the current archive entry.
+   *
+   * @param b The byte array to be written.
+   * @param off offset into the array to start writing from
+   * @param len number of bytes to write
+   * @throws IOException on error
+   */
+  public void write(final byte[] b, final int off, final int len) throws IOException {
+    if (len > 0) {
+      getCurrentOutputStream().write(b, off, len);
+    }
+  }
+
+  /**
+   * Finishes the addition of entries to this archive, without closing it.
+   *
+   * @throws IOException if archive is already closed.
+   */
+  public void finish() throws IOException {
+    if (finished) {
+      throw new IOException("This archive has already been finished");
+    }
+    finished = true;
+
+    final long headerPosition = channel.getFilePointer();
+
+    final ByteArrayOutputStream headerBaos = new ByteArrayOutputStream();
+    final DataOutputStream header = new DataOutputStream(headerBaos);
+
+    writeHeader(header);
+    header.flush();
+    final byte[] headerBytes = headerBaos.toByteArray();
+    channel.write(headerBytes);
+
+    final CRC32 crc32 = new CRC32();
+    crc32.update(headerBytes);
+
+    ByteBuffer bb =
+        ByteBuffer.allocate(
+                SevenZFile.sevenZSignature.length
+                    + 2 /* version */
+                    + 4 /* start header CRC */
+                    + 8 /* next header position */
+                    + 8 /* next header length */
+                    + 4 /* next header CRC */)
+            .order(ByteOrder.LITTLE_ENDIAN);
+    // signature header
+    channel.seek(0);
+    bb.put(SevenZFile.sevenZSignature);
+    // version
+    bb.put((byte) 0).put((byte) 2);
+
+    // placeholder for start header CRC
+    bb.putInt(0);
+
+    // start header
+    bb.putLong(headerPosition - SevenZFile.SIGNATURE_HEADER_SIZE)
+        .putLong(0xffffFFFFL & headerBytes.length)
+        .putInt((int) crc32.getValue());
+    crc32.reset();
+    crc32.update(bb.array(), SevenZFile.sevenZSignature.length + 6, 20);
+    bb.putInt(SevenZFile.sevenZSignature.length + 2, (int) crc32.getValue());
+    bb.flip();
+    channel.write(bb.array());
+  }
+
+  /*
+   * Creation of output stream is deferred until data is actually
+   * written as some codecs might write header information even for
+   * empty streams and directories otherwise.
+   */
+  private OutputStream getCurrentOutputStream() throws IOException {
+    if (currentOutputStream == null) {
+      currentOutputStream = setupFileOutputStream();
+    }
+    return currentOutputStream;
+  }
+
+  private CountingOutputStream setupFileOutputStream() throws IOException {
+    if (files.isEmpty()) {
+      throw new IllegalStateException("No current 7z entry");
+    }
+
+    OutputStream out = new OutputStreamWrapper();
+    final ArrayList<CountingOutputStream> moreStreams = new ArrayList<>();
+    boolean first = true;
+    for (final SevenZMethodConfiguration m : getContentMethods(files.get(files.size() - 1))) {
+      if (!first) {
+        final CountingOutputStream cos = new CountingOutputStream(out);
+        moreStreams.add(cos);
+        out = cos;
+      }
+      out = Coders.addEncoder(out, m.getMethod(), m.getOptions());
+      first = false;
+    }
+    if (!moreStreams.isEmpty()) {
+      additionalCountingStreams = moreStreams.toArray(new CountingOutputStream[moreStreams.size()]);
+    }
+    return new CountingOutputStream(out) {
+      @Override
+      public void write(final int b) throws IOException {
+        super.write(b);
+        crc32.update(b);
+      }
+
+      @Override
+      public void write(final byte[] b) throws IOException {
+        super.write(b);
+        crc32.update(b);
+      }
+
+      @Override
+      public void write(final byte[] b, final int off, final int len) throws IOException {
+        super.write(b, off, len);
+        crc32.update(b, off, len);
+      }
+    };
+  }
+
+  private Iterable<? extends SevenZMethodConfiguration> getContentMethods(
+      final SevenZArchiveEntry entry) {
+    final Iterable<? extends SevenZMethodConfiguration> ms = entry.getContentMethods();
+    return ms == null ? contentMethods : ms;
+  }
+
+  private void writeHeader(final DataOutput header) throws IOException {
+    header.write(NID.kHeader);
+
+    header.write(NID.kMainStreamsInfo);
+    writeStreamsInfo(header);
+    writeFilesInfo(header);
+    header.write(NID.kEnd);
+  }
+
+  private void writeStreamsInfo(final DataOutput header) throws IOException {
+    if (numNonEmptyStreams > 0) {
+      writePackInfo(header);
+      writeUnpackInfo(header);
+    }
+
+    writeSubStreamsInfo(header);
+
+    header.write(NID.kEnd);
+  }
+
+  private void writePackInfo(final DataOutput header) throws IOException {
+    header.write(NID.kPackInfo);
+
+    writeUint64(header, 0);
+    writeUint64(header, 0xffffFFFFL & numNonEmptyStreams);
+
+    header.write(NID.kSize);
+    for (final SevenZArchiveEntry entry : files) {
+      if (entry.hasStream()) {
+        writeUint64(header, entry.getCompressedSize());
+      }
+    }
+
+    header.write(NID.kCRC);
+    header.write(1); // "allAreDefined" == true
+    for (final SevenZArchiveEntry entry : files) {
+      if (entry.hasStream()) {
+        header.writeInt(Integer.reverseBytes((int) entry.getCompressedCrcValue()));
+      }
+    }
+
+    header.write(NID.kEnd);
+  }
+
+  private void writeUnpackInfo(final DataOutput header) throws IOException {
+    header.write(NID.kUnpackInfo);
+
+    header.write(NID.kFolder);
+    writeUint64(header, numNonEmptyStreams);
+    header.write(0);
+    for (final SevenZArchiveEntry entry : files) {
+      if (entry.hasStream()) {
+        writeFolder(header, entry);
+      }
+    }
+
+    header.write(NID.kCodersUnpackSize);
+    for (final SevenZArchiveEntry entry : files) {
+      if (entry.hasStream()) {
+        final long[] moreSizes = additionalSizes.get(entry);
+        if (moreSizes != null) {
+          for (final long s : moreSizes) {
+            writeUint64(header, s);
+          }
+        }
+        writeUint64(header, entry.getSize());
+      }
+    }
+
+    header.write(NID.kCRC);
+    header.write(1); // "allAreDefined" == true
+    for (final SevenZArchiveEntry entry : files) {
+      if (entry.hasStream()) {
+        header.writeInt(Integer.reverseBytes((int) entry.getCrcValue()));
+      }
+    }
+
+    header.write(NID.kEnd);
+  }
+
+  private void writeFolder(final DataOutput header, final SevenZArchiveEntry entry)
+      throws IOException {
+    final ByteArrayOutputStream bos = new ByteArrayOutputStream();
+    int numCoders = 0;
+    for (final SevenZMethodConfiguration m : getContentMethods(entry)) {
+      numCoders++;
+      writeSingleCodec(m, bos);
+    }
+
+    writeUint64(header, numCoders);
+    header.write(bos.toByteArray());
+    for (long i = 0; i < numCoders - 1; i++) {
+      writeUint64(header, i + 1);
+      writeUint64(header, i);
+    }
+  }
+
+  private void writeSingleCodec(final SevenZMethodConfiguration m, final OutputStream bos)
+      throws IOException {
+    final byte[] id = m.getMethod().getId();
+    final byte[] properties =
+        Coders.findByMethod(m.getMethod()).getOptionsAsProperties(m.getOptions());
+
+    int codecFlags = id.length;
+    if (properties.length > 0) {
+      codecFlags |= 0x20;
+    }
+    bos.write(codecFlags);
+    bos.write(id);
+
+    if (properties.length > 0) {
+      bos.write(properties.length);
+      bos.write(properties);
+    }
+  }
+
+  private void writeSubStreamsInfo(final DataOutput header) throws IOException {
+    header.write(NID.kSubStreamsInfo);
+    //
+    //        header.write(NID.kCRC);
+    //        header.write(1);
+    //        for (final SevenZArchiveEntry entry : files) {
+    //            if (entry.getHasCrc()) {
+    //                header.writeInt(Integer.reverseBytes(entry.getCrc()));
+    //            }
+    //        }
+    //
+    header.write(NID.kEnd);
+  }
+
+  private void writeFilesInfo(final DataOutput header) throws IOException {
+    header.write(NID.kFilesInfo);
+
+    writeUint64(header, files.size());
+
+    writeFileEmptyStreams(header);
+    writeFileEmptyFiles(header);
+    writeFileAntiItems(header);
+    writeFileNames(header);
+    writeFileCTimes(header);
+    writeFileATimes(header);
+    writeFileMTimes(header);
+    writeFileWindowsAttributes(header);
+    header.write(NID.kEnd);
+  }
+
+  private void writeFileEmptyStreams(final DataOutput header) throws IOException {
+    boolean hasEmptyStreams = false;
+    for (final SevenZArchiveEntry entry : files) {
+      if (!entry.hasStream()) {
+        hasEmptyStreams = true;
+        break;
+      }
+    }
+    if (hasEmptyStreams) {
+      header.write(NID.kEmptyStream);
+      final BitSet emptyStreams = new BitSet(files.size());
+      for (int i = 0; i < files.size(); i++) {
+        emptyStreams.set(i, !files.get(i).hasStream());
+      }
+      final ByteArrayOutputStream baos = new ByteArrayOutputStream();
+      final DataOutputStream out = new DataOutputStream(baos);
+      writeBits(out, emptyStreams, files.size());
+      out.flush();
+      final byte[] contents = baos.toByteArray();
+      writeUint64(header, contents.length);
+      header.write(contents);
+    }
+  }
+
+  private void writeFileEmptyFiles(final DataOutput header) throws IOException {
+    boolean hasEmptyFiles = false;
+    int emptyStreamCounter = 0;
+    final BitSet emptyFiles = new BitSet(0);
+    for (final SevenZArchiveEntry file1 : files) {
+      if (!file1.hasStream()) {
+        final boolean isDir = file1.isDirectory();
+        emptyFiles.set(emptyStreamCounter++, !isDir);
+        hasEmptyFiles |= !isDir;
+      }
+    }
+    if (hasEmptyFiles) {
+      header.write(NID.kEmptyFile);
+      final ByteArrayOutputStream baos = new ByteArrayOutputStream();
+      final DataOutputStream out = new DataOutputStream(baos);
+      writeBits(out, emptyFiles, emptyStreamCounter);
+      out.flush();
+      final byte[] contents = baos.toByteArray();
+      writeUint64(header, contents.length);
+      header.write(contents);
+    }
+  }
+
+  private void writeFileAntiItems(final DataOutput header) throws IOException {
+    boolean hasAntiItems = false;
+    final BitSet antiItems = new BitSet(0);
+    int antiItemCounter = 0;
+    for (final SevenZArchiveEntry file1 : files) {
+      if (!file1.hasStream()) {
+        final boolean isAnti = file1.isAntiItem();
+        antiItems.set(antiItemCounter++, isAnti);
+        hasAntiItems |= isAnti;
+      }
+    }
+    if (hasAntiItems) {
+      header.write(NID.kAnti);
+      final ByteArrayOutputStream baos = new ByteArrayOutputStream();
+      final DataOutputStream out = new DataOutputStream(baos);
+      writeBits(out, antiItems, antiItemCounter);
+      out.flush();
+      final byte[] contents = baos.toByteArray();
+      writeUint64(header, contents.length);
+      header.write(contents);
+    }
+  }
+
+  private void writeFileNames(final DataOutput header) throws IOException {
+    header.write(NID.kName);
+
+    final ByteArrayOutputStream baos = new ByteArrayOutputStream();
+    final DataOutputStream out = new DataOutputStream(baos);
+    out.write(0);
+    for (final SevenZArchiveEntry entry : files) {
+      out.write(entry.getName().getBytes("UTF-16LE"));
+      out.writeShort(0);
+    }
+    out.flush();
+    final byte[] contents = baos.toByteArray();
+    writeUint64(header, contents.length);
+    header.write(contents);
+  }
+
+  private void writeFileCTimes(final DataOutput header) throws IOException {
+    int numCreationDates = 0;
+    for (final SevenZArchiveEntry entry : files) {
+      if (entry.getHasCreationDate()) {
+        ++numCreationDates;
+      }
+    }
+    if (numCreationDates > 0) {
+      header.write(NID.kCTime);
+
+      final ByteArrayOutputStream baos = new ByteArrayOutputStream();
+      final DataOutputStream out = new DataOutputStream(baos);
+      if (numCreationDates != files.size()) {
+        out.write(0);
+        final BitSet cTimes = new BitSet(files.size());
+        for (int i = 0; i < files.size(); i++) {
+          cTimes.set(i, files.get(i).getHasCreationDate());
+        }
+        writeBits(out, cTimes, files.size());
+      } else {
+        out.write(1); // "allAreDefined" == true
+      }
+      out.write(0);
+      for (final SevenZArchiveEntry entry : files) {
+        if (entry.getHasCreationDate()) {
+          out.writeLong(
+              Long.reverseBytes(SevenZArchiveEntry.javaTimeToNtfsTime(entry.getCreationDate())));
+        }
+      }
+      out.flush();
+      final byte[] contents = baos.toByteArray();
+      writeUint64(header, contents.length);
+      header.write(contents);
+    }
+  }
+
+  private void writeFileATimes(final DataOutput header) throws IOException {
+    int numAccessDates = 0;
+    for (final SevenZArchiveEntry entry : files) {
+      if (entry.getHasAccessDate()) {
+        ++numAccessDates;
+      }
+    }
+    if (numAccessDates > 0) {
+      header.write(NID.kATime);
+
+      final ByteArrayOutputStream baos = new ByteArrayOutputStream();
+      final DataOutputStream out = new DataOutputStream(baos);
+      if (numAccessDates != files.size()) {
+        out.write(0);
+        final BitSet aTimes = new BitSet(files.size());
+        for (int i = 0; i < files.size(); i++) {
+          aTimes.set(i, files.get(i).getHasAccessDate());
+        }
+        writeBits(out, aTimes, files.size());
+      } else {
+        out.write(1); // "allAreDefined" == true
+      }
+      out.write(0);
+      for (final SevenZArchiveEntry entry : files) {
+        if (entry.getHasAccessDate()) {
+          out.writeLong(
+              Long.reverseBytes(SevenZArchiveEntry.javaTimeToNtfsTime(entry.getAccessDate())));
+        }
+      }
+      out.flush();
+      final byte[] contents = baos.toByteArray();
+      writeUint64(header, contents.length);
+      header.write(contents);
+    }
+  }
+
+  private void writeFileMTimes(final DataOutput header) throws IOException {
+    int numLastModifiedDates = 0;
+    for (final SevenZArchiveEntry entry : files) {
+      if (entry.getHasLastModifiedDate()) {
+        ++numLastModifiedDates;
+      }
+    }
+    if (numLastModifiedDates > 0) {
+      header.write(NID.kMTime);
+
+      final ByteArrayOutputStream baos = new ByteArrayOutputStream();
+      final DataOutputStream out = new DataOutputStream(baos);
+      if (numLastModifiedDates != files.size()) {
+        out.write(0);
+        final BitSet mTimes = new BitSet(files.size());
+        for (int i = 0; i < files.size(); i++) {
+          mTimes.set(i, files.get(i).getHasLastModifiedDate());
+        }
+        writeBits(out, mTimes, files.size());
+      } else {
+        out.write(1); // "allAreDefined" == true
+      }
+      out.write(0);
+      for (final SevenZArchiveEntry entry : files) {
+        if (entry.getHasLastModifiedDate()) {
+          out.writeLong(
+              Long.reverseBytes(
+                  SevenZArchiveEntry.javaTimeToNtfsTime(entry.getLastModifiedDate())));
+        }
+      }
+      out.flush();
+      final byte[] contents = baos.toByteArray();
+      writeUint64(header, contents.length);
+      header.write(contents);
+    }
+  }
+
+  private void writeFileWindowsAttributes(final DataOutput header) throws IOException {
+    int numWindowsAttributes = 0;
+    for (final SevenZArchiveEntry entry : files) {
+      if (entry.getHasWindowsAttributes()) {
+        ++numWindowsAttributes;
+      }
+    }
+    if (numWindowsAttributes > 0) {
+      header.write(NID.kWinAttributes);
+
+      final ByteArrayOutputStream baos = new ByteArrayOutputStream();
+      final DataOutputStream out = new DataOutputStream(baos);
+      if (numWindowsAttributes != files.size()) {
+        out.write(0);
+        final BitSet attributes = new BitSet(files.size());
+        for (int i = 0; i < files.size(); i++) {
+          attributes.set(i, files.get(i).getHasWindowsAttributes());
+        }
+        writeBits(out, attributes, files.size());
+      } else {
+        out.write(1); // "allAreDefined" == true
+      }
+      out.write(0);
+      for (final SevenZArchiveEntry entry : files) {
+        if (entry.getHasWindowsAttributes()) {
+          out.writeInt(Integer.reverseBytes(entry.getWindowsAttributes()));
+        }
+      }
+      out.flush();
+      final byte[] contents = baos.toByteArray();
+      writeUint64(header, contents.length);
+      header.write(contents);
+    }
+  }
+
+  private void writeUint64(final DataOutput header, long value) throws IOException {
+    int firstByte = 0;
+    int mask = 0x80;
+    int i;
+    for (i = 0; i < 8; i++) {
+      if (value < ((1L << (7 * (i + 1))))) {
+        firstByte |= (value >>> (8 * i));
+        break;
+      }
+      firstByte |= mask;
+      mask >>>= 1;
+    }
+    header.write(firstByte);
+    for (; i > 0; i--) {
+      header.write((int) (0xff & value));
+      value >>>= 8;
+    }
+  }
+
+  private void writeBits(final DataOutput header, final BitSet bits, final int length)
+      throws IOException {
+    int cache = 0;
+    int shift = 7;
+    for (int i = 0; i < length; i++) {
+      cache |= ((bits.get(i) ? 1 : 0) << shift);
+      if (--shift < 0) {
+        header.write(cache);
+        shift = 7;
+        cache = 0;
+      }
+    }
+    if (shift != 7) {
+      header.write(cache);
+    }
+  }
+
+  private static <T> Iterable<T> reverse(final Iterable<T> i) {
+    final LinkedList<T> l = new LinkedList<>();
+    for (final T t : i) {
+      l.addFirst(t);
+    }
+    return l;
+  }
+
+  private class OutputStreamWrapper extends OutputStream {
+    private static final int BUF_SIZE = 8192;
+    private final ByteBuffer buffer = ByteBuffer.allocate(BUF_SIZE);
 
-        final SevenZArchiveEntry entry = files.get(files.size() - 1);
-        if (fileBytesWritten > 0) { // this implies currentOutputStream != null
-            entry.setHasStream(true);
-            ++numNonEmptyStreams;
-            entry.setSize(currentOutputStream.getBytesWritten()); //NOSONAR
-            entry.setCompressedSize(fileBytesWritten);
-            entry.setCrcValue(crc32.getValue());
-            entry.setCompressedCrcValue(compressedCrc32.getValue());
-            entry.setHasCrc(true);
-            if (additionalCountingStreams != null) {
-                final long[] sizes = new long[additionalCountingStreams.length];
-                for (int i = 0; i < additionalCountingStreams.length; i++) {
-                    sizes[i] = additionalCountingStreams[i].getBytesWritten();
-                }
-                additionalSizes.put(entry, sizes);
-            }
-        } else {
-            entry.setHasStream(false);
-            entry.setSize(0);
-            entry.setCompressedSize(0);
-            entry.setHasCrc(false);
-        }
-        currentOutputStream = null;
-        additionalCountingStreams = null;
-        crc32.reset();
-        compressedCrc32.reset();
-        fileBytesWritten = 0;
-    }
-
-    /**
-     * Writes a byte to the current archive entry.
-     * @param b The byte to be written.
-     * @throws IOException on error
-     */
+    @Override
     public void write(final int b) throws IOException {
-        getCurrentOutputStream().write(b);
+      buffer.clear();
+      buffer.put((byte) b).flip();
+      channel.write(buffer.array());
+      compressedCrc32.update(b);
+      fileBytesWritten++;
     }
 
-    /**
-     * Writes a byte array to the current archive entry.
-     * @param b The byte array to be written.
-     * @throws IOException on error
-     */
+    @Override
     public void write(final byte[] b) throws IOException {
-        write(b, 0, b.length);
+      OutputStreamWrapper.this.write(b, 0, b.length);
     }
 
-    /**
-     * Writes part of a byte array to the current archive entry.
-     * @param b The byte array to be written.
-     * @param off offset into the array to start writing from
-     * @param len number of bytes to write
-     * @throws IOException on error
-     */
+    @Override
     public void write(final byte[] b, final int off, final int len) throws IOException {
-        if (len > 0) {
-            getCurrentOutputStream().write(b, off, len);
-        }
-    }
-
-    /**
-     * Finishes the addition of entries to this archive, without closing it.
-     *
-     * @throws IOException if archive is already closed.
-     */
-    public void finish() throws IOException {
-        if (finished) {
-            throw new IOException("This archive has already been finished");
-        }
-        finished = true;
-
-        final long headerPosition = channel.getFilePointer();
-
-        final ByteArrayOutputStream headerBaos = new ByteArrayOutputStream();
-        final DataOutputStream header = new DataOutputStream(headerBaos);
-
-        writeHeader(header);
-        header.flush();
-        final byte[] headerBytes = headerBaos.toByteArray();
-        channel.write(headerBytes);
-
-        final CRC32 crc32 = new CRC32();
-        crc32.update(headerBytes);
-
-        ByteBuffer bb = ByteBuffer.allocate(SevenZFile.sevenZSignature.length
-                                            + 2 /* version */
-                                            + 4 /* start header CRC */
-                                            + 8 /* next header position */
-                                            + 8 /* next header length */
-                                            + 4 /* next header CRC */)
-            .order(ByteOrder.LITTLE_ENDIAN);
-        // signature header
-        channel.seek(0);
-        bb.put(SevenZFile.sevenZSignature);
-        // version
-        bb.put((byte) 0).put((byte) 2);
-
-        // placeholder for start header CRC
-        bb.putInt(0);
-
-        // start header
-        bb.putLong(headerPosition - SevenZFile.SIGNATURE_HEADER_SIZE)
-            .putLong(0xffffFFFFL & headerBytes.length)
-            .putInt((int) crc32.getValue());
-        crc32.reset();
-        crc32.update(bb.array(), SevenZFile.sevenZSignature.length + 6, 20);
-        bb.putInt(SevenZFile.sevenZSignature.length + 2, (int) crc32.getValue());
-        bb.flip();
-        channel.write(bb.array());
-    }
-
-    /*
-     * Creation of output stream is deferred until data is actually
-     * written as some codecs might write header information even for
-     * empty streams and directories otherwise.
-     */
-    private OutputStream getCurrentOutputStream() throws IOException {
-        if (currentOutputStream == null) {
-            currentOutputStream = setupFileOutputStream();
-        }
-        return currentOutputStream;
-    }
-
-    private CountingOutputStream setupFileOutputStream() throws IOException {
-        if (files.isEmpty()) {
-            throw new IllegalStateException("No current 7z entry");
-        }
-
-        OutputStream out = new OutputStreamWrapper();
-        final ArrayList<CountingOutputStream> moreStreams = new ArrayList<>();
-        boolean first = true;
-        for (final SevenZMethodConfiguration m : getContentMethods(files.get(files.size() - 1))) {
-            if (!first) {
-                final CountingOutputStream cos = new CountingOutputStream(out);
-                moreStreams.add(cos);
-                out = cos;
-            }
-            out = Coders.addEncoder(out, m.getMethod(), m.getOptions());
-            first = false;
-        }
-        if (!moreStreams.isEmpty()) {
-            additionalCountingStreams = moreStreams.toArray(new CountingOutputStream[moreStreams.size()]);
-        }
-        return new CountingOutputStream(out) {
-            @Override
-            public void write(final int b) throws IOException {
-                super.write(b);
-                crc32.update(b);
-            }
-
-            @Override
-            public void write(final byte[] b) throws IOException {
-                super.write(b);
-                crc32.update(b);
-            }
-
-            @Override
-            public void write(final byte[] b, final int off, final int len)
-                throws IOException {
-                super.write(b, off, len);
-                crc32.update(b, off, len);
-            }
-        };
-    }
-
-    private Iterable<? extends SevenZMethodConfiguration> getContentMethods(final SevenZArchiveEntry entry) {
-        final Iterable<? extends SevenZMethodConfiguration> ms = entry.getContentMethods();
-        return ms == null ? contentMethods : ms;
-    }
-
-    private void writeHeader(final DataOutput header) throws IOException {
-        header.write(NID.kHeader);
-
-        header.write(NID.kMainStreamsInfo);
-        writeStreamsInfo(header);
-        writeFilesInfo(header);
-        header.write(NID.kEnd);
-    }
-
-    private void writeStreamsInfo(final DataOutput header) throws IOException {
-        if (numNonEmptyStreams > 0) {
-            writePackInfo(header);
-            writeUnpackInfo(header);
-        }
-
-        writeSubStreamsInfo(header);
-
-        header.write(NID.kEnd);
-    }
-
-    private void writePackInfo(final DataOutput header) throws IOException {
-        header.write(NID.kPackInfo);
-
-        writeUint64(header, 0);
-        writeUint64(header, 0xffffFFFFL & numNonEmptyStreams);
-
-        header.write(NID.kSize);
-        for (final SevenZArchiveEntry entry : files) {
-            if (entry.hasStream()) {
-                writeUint64(header, entry.getCompressedSize());
-            }
-        }
-
-        header.write(NID.kCRC);
-        header.write(1); // "allAreDefined" == true
-        for (final SevenZArchiveEntry entry : files) {
-            if (entry.hasStream()) {
-                header.writeInt(Integer.reverseBytes((int) entry.getCompressedCrcValue()));
-            }
-        }
-
-        header.write(NID.kEnd);
+      if (len > BUF_SIZE) {
+        channel.write(b, off, len);
+      } else {
+        buffer.clear();
+        buffer.put(b, off, len).flip();
+        channel.write(buffer.array());
+      }
+      compressedCrc32.update(b, off, len);
+      fileBytesWritten += len;
     }
 
-    private void writeUnpackInfo(final DataOutput header) throws IOException {
-        header.write(NID.kUnpackInfo);
-
-        header.write(NID.kFolder);
-        writeUint64(header, numNonEmptyStreams);
-        header.write(0);
-        for (final SevenZArchiveEntry entry : files) {
-            if (entry.hasStream()) {
-                writeFolder(header, entry);
-            }
-        }
-
-        header.write(NID.kCodersUnpackSize);
-        for (final SevenZArchiveEntry entry : files) {
-            if (entry.hasStream()) {
-                final long[] moreSizes = additionalSizes.get(entry);
-                if (moreSizes != null) {
-                    for (final long s : moreSizes) {
-                        writeUint64(header, s);
-                    }
-                }
-                writeUint64(header, entry.getSize());
-            }
-        }
-
-        header.write(NID.kCRC);
-        header.write(1); // "allAreDefined" == true
-        for (final SevenZArchiveEntry entry : files) {
-            if (entry.hasStream()) {
-                header.writeInt(Integer.reverseBytes((int) entry.getCrcValue()));
-            }
-        }
-
-        header.write(NID.kEnd);
-    }
-
-    private void writeFolder(final DataOutput header, final SevenZArchiveEntry entry) throws IOException {
-        final ByteArrayOutputStream bos = new ByteArrayOutputStream();
-        int numCoders = 0;
-        for (final SevenZMethodConfiguration m : getContentMethods(entry)) {
-            numCoders++;
-            writeSingleCodec(m, bos);
-        }
-
-        writeUint64(header, numCoders);
-        header.write(bos.toByteArray());
-        for (long i = 0; i < numCoders - 1; i++) {
-            writeUint64(header, i + 1);
-            writeUint64(header, i);
-        }
-    }
-
-    private void writeSingleCodec(final SevenZMethodConfiguration m, final OutputStream bos) throws IOException {
-        final byte[] id = m.getMethod().getId();
-        final byte[] properties = Coders.findByMethod(m.getMethod())
-            .getOptionsAsProperties(m.getOptions());
-
-        int codecFlags = id.length;
-        if (properties.length > 0) {
-            codecFlags |= 0x20;
-        }
-        bos.write(codecFlags);
-        bos.write(id);
-
-        if (properties.length > 0) {
-            bos.write(properties.length);
-            bos.write(properties);
-        }
-    }
-
-    private void writeSubStreamsInfo(final DataOutput header) throws IOException {
-        header.write(NID.kSubStreamsInfo);
-//
-//        header.write(NID.kCRC);
-//        header.write(1);
-//        for (final SevenZArchiveEntry entry : files) {
-//            if (entry.getHasCrc()) {
-//                header.writeInt(Integer.reverseBytes(entry.getCrc()));
-//            }
-//        }
-//
-        header.write(NID.kEnd);
-    }
-
-    private void writeFilesInfo(final DataOutput header) throws IOException {
-        header.write(NID.kFilesInfo);
-
-        writeUint64(header, files.size());
-
-        writeFileEmptyStreams(header);
-        writeFileEmptyFiles(header);
-        writeFileAntiItems(header);
-        writeFileNames(header);
-        writeFileCTimes(header);
-        writeFileATimes(header);
-        writeFileMTimes(header);
-        writeFileWindowsAttributes(header);
-        header.write(NID.kEnd);
-    }
-
-    private void writeFileEmptyStreams(final DataOutput header) throws IOException {
-        boolean hasEmptyStreams = false;
-        for (final SevenZArchiveEntry entry : files) {
-            if (!entry.hasStream()) {
-                hasEmptyStreams = true;
-                break;
-            }
-        }
-        if (hasEmptyStreams) {
-            header.write(NID.kEmptyStream);
-            final BitSet emptyStreams = new BitSet(files.size());
-            for (int i = 0; i < files.size(); i++) {
-                emptyStreams.set(i, !files.get(i).hasStream());
-            }
-            final ByteArrayOutputStream baos = new ByteArrayOutputStream();
-            final DataOutputStream out = new DataOutputStream(baos);
-            writeBits(out, emptyStreams, files.size());
-            out.flush();
-            final byte[] contents = baos.toByteArray();
-            writeUint64(header, contents.length);
-            header.write(contents);
-        }
-    }
-
-    private void writeFileEmptyFiles(final DataOutput header) throws IOException {
-        boolean hasEmptyFiles = false;
-        int emptyStreamCounter = 0;
-        final BitSet emptyFiles = new BitSet(0);
-        for (final SevenZArchiveEntry file1 : files) {
-            if (!file1.hasStream()) {
-                final boolean isDir = file1.isDirectory();
-                emptyFiles.set(emptyStreamCounter++, !isDir);
-                hasEmptyFiles |= !isDir;
-            }
-        }
-        if (hasEmptyFiles) {
-            header.write(NID.kEmptyFile);
-            final ByteArrayOutputStream baos = new ByteArrayOutputStream();
-            final DataOutputStream out = new DataOutputStream(baos);
-            writeBits(out, emptyFiles, emptyStreamCounter);
-            out.flush();
-            final byte[] contents = baos.toByteArray();
-            writeUint64(header, contents.length);
-            header.write(contents);
-        }
-    }
-
-    private void writeFileAntiItems(final DataOutput header) throws IOException {
-        boolean hasAntiItems = false;
-        final BitSet antiItems = new BitSet(0);
-        int antiItemCounter = 0;
-        for (final SevenZArchiveEntry file1 : files) {
-            if (!file1.hasStream()) {
-                final boolean isAnti = file1.isAntiItem();
-                antiItems.set(antiItemCounter++, isAnti);
-                hasAntiItems |= isAnti;
-            }
-        }
-        if (hasAntiItems) {
-            header.write(NID.kAnti);
-            final ByteArrayOutputStream baos = new ByteArrayOutputStream();
-            final DataOutputStream out = new DataOutputStream(baos);
-            writeBits(out, antiItems, antiItemCounter);
-            out.flush();
-            final byte[] contents = baos.toByteArray();
-            writeUint64(header, contents.length);
-            header.write(contents);
-        }
-    }
-
-    private void writeFileNames(final DataOutput header) throws IOException {
-        header.write(NID.kName);
-
-        final ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        final DataOutputStream out = new DataOutputStream(baos);
-        out.write(0);
-        for (final SevenZArchiveEntry entry : files) {
-            out.write(entry.getName().getBytes("UTF-16LE"));
-            out.writeShort(0);
-        }
-        out.flush();
-        final byte[] contents = baos.toByteArray();
-        writeUint64(header, contents.length);
-        header.write(contents);
-    }
-
-    private void writeFileCTimes(final DataOutput header) throws IOException {
-        int numCreationDates = 0;
-        for (final SevenZArchiveEntry entry : files) {
-            if (entry.getHasCreationDate()) {
-                ++numCreationDates;
-            }
-        }
-        if (numCreationDates > 0) {
-            header.write(NID.kCTime);
-
-            final ByteArrayOutputStream baos = new ByteArrayOutputStream();
-            final DataOutputStream out = new DataOutputStream(baos);
-            if (numCreationDates != files.size()) {
-                out.write(0);
-                final BitSet cTimes = new BitSet(files.size());
-                for (int i = 0; i < files.size(); i++) {
-                    cTimes.set(i, files.get(i).getHasCreationDate());
-                }
-                writeBits(out, cTimes, files.size());
-            } else {
-                out.write(1); // "allAreDefined" == true
-            }
-            out.write(0);
-            for (final SevenZArchiveEntry entry : files) {
-                if (entry.getHasCreationDate()) {
-                    out.writeLong(Long.reverseBytes(
-                            SevenZArchiveEntry.javaTimeToNtfsTime(entry.getCreationDate())));
-                }
-            }
-            out.flush();
-            final byte[] contents = baos.toByteArray();
-            writeUint64(header, contents.length);
-            header.write(contents);
-        }
-    }
-
-    private void writeFileATimes(final DataOutput header) throws IOException {
-        int numAccessDates = 0;
-        for (final SevenZArchiveEntry entry : files) {
-            if (entry.getHasAccessDate()) {
-                ++numAccessDates;
-            }
-        }
-        if (numAccessDates > 0) {
-            header.write(NID.kATime);
-
-            final ByteArrayOutputStream baos = new ByteArrayOutputStream();
-            final DataOutputStream out = new DataOutputStream(baos);
-            if (numAccessDates != files.size()) {
-                out.write(0);
-                final BitSet aTimes = new BitSet(files.size());
-                for (int i = 0; i < files.size(); i++) {
-                    aTimes.set(i, files.get(i).getHasAccessDate());
-                }
-                writeBits(out, aTimes, files.size());
-            } else {
-                out.write(1); // "allAreDefined" == true
-            }
-            out.write(0);
-            for (final SevenZArchiveEntry entry : files) {
-                if (entry.getHasAccessDate()) {
-                    out.writeLong(Long.reverseBytes(
-                            SevenZArchiveEntry.javaTimeToNtfsTime(entry.getAccessDate())));
-                }
-            }
-            out.flush();
-            final byte[] contents = baos.toByteArray();
-            writeUint64(header, contents.length);
-            header.write(contents);
-        }
-    }
-
-    private void writeFileMTimes(final DataOutput header) throws IOException {
-        int numLastModifiedDates = 0;
-        for (final SevenZArchiveEntry entry : files) {
-            if (entry.getHasLastModifiedDate()) {
-                ++numLastModifiedDates;
-            }
-        }
-        if (numLastModifiedDates > 0) {
-            header.write(NID.kMTime);
-
-            final ByteArrayOutputStream baos = new ByteArrayOutputStream();
-            final DataOutputStream out = new DataOutputStream(baos);
-            if (numLastModifiedDates != files.size()) {
-                out.write(0);
-                final BitSet mTimes = new BitSet(files.size());
-                for (int i = 0; i < files.size(); i++) {
-                    mTimes.set(i, files.get(i).getHasLastModifiedDate());
-                }
-                writeBits(out, mTimes, files.size());
-            } else {
-                out.write(1); // "allAreDefined" == true
-            }
-            out.write(0);
-            for (final SevenZArchiveEntry entry : files) {
-                if (entry.getHasLastModifiedDate()) {
-                    out.writeLong(Long.reverseBytes(
-                            SevenZArchiveEntry.javaTimeToNtfsTime(entry.getLastModifiedDate())));
-                }
-            }
-            out.flush();
-            final byte[] contents = baos.toByteArray();
-            writeUint64(header, contents.length);
-            header.write(contents);
-        }
-    }
-
-    private void writeFileWindowsAttributes(final DataOutput header) throws IOException {
-        int numWindowsAttributes = 0;
-        for (final SevenZArchiveEntry entry : files) {
-            if (entry.getHasWindowsAttributes()) {
-                ++numWindowsAttributes;
-            }
-        }
-        if (numWindowsAttributes > 0) {
-            header.write(NID.kWinAttributes);
-
-            final ByteArrayOutputStream baos = new ByteArrayOutputStream();
-            final DataOutputStream out = new DataOutputStream(baos);
-            if (numWindowsAttributes != files.size()) {
-                out.write(0);
-                final BitSet attributes = new BitSet(files.size());
-                for (int i = 0; i < files.size(); i++) {
-                    attributes.set(i, files.get(i).getHasWindowsAttributes());
-                }
-                writeBits(out, attributes, files.size());
-            } else {
-                out.write(1); // "allAreDefined" == true
-            }
-            out.write(0);
-            for (final SevenZArchiveEntry entry : files) {
-                if (entry.getHasWindowsAttributes()) {
-                    out.writeInt(Integer.reverseBytes(entry.getWindowsAttributes()));
-                }
-            }
-            out.flush();
-            final byte[] contents = baos.toByteArray();
-            writeUint64(header, contents.length);
-            header.write(contents);
-        }
-    }
-
-    private void writeUint64(final DataOutput header, long value) throws IOException {
-        int firstByte = 0;
-        int mask = 0x80;
-        int i;
-        for (i = 0; i < 8; i++) {
-            if (value < ((1L << ( 7  * (i + 1))))) {
-                firstByte |= (value >>> (8 * i));
-                break;
-            }
-            firstByte |= mask;
-            mask >>>= 1;
-        }
-        header.write(firstByte);
-        for (; i > 0; i--) {
-            header.write((int) (0xff & value));
-            value >>>= 8;
-        }
-    }
-
-    private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {
-        int cache = 0;
-        int shift = 7;
-        for (int i = 0; i < length; i++) {
-            cache |= ((bits.get(i) ? 1 : 0) << shift);
-            if (--shift < 0) {
-                header.write(cache);
-                shift = 7;
-                cache = 0;
-            }
-        }
-        if (shift != 7) {
-            header.write(cache);
-        }
+    @Override
+    public void flush() throws IOException {
+      // no reason to flush the channel
     }
 
-    private static <T> Iterable<T> reverse(final Iterable<T> i) {
-        final LinkedList<T> l = new LinkedList<>();
-        for (final T t : i) {
-            l.addFirst(t);
-        }
-        return l;
-    }
-
-    private class OutputStreamWrapper extends OutputStream {
-        private static final int BUF_SIZE = 8192;
-        private final ByteBuffer buffer = ByteBuffer.allocate(BUF_SIZE);
-        @Override
-        public void write(final int b) throws IOException {
-            buffer.clear();
-            buffer.put((byte) b).flip();
-            channel.write(buffer.array());
-            compressedCrc32.update(b);
-            fileBytesWritten++;
-        }
-
-        @Override
-        public void write(final byte[] b) throws IOException {
-            OutputStreamWrapper.this.write(b, 0, b.length);
-        }
-
-        @Override
-        public void write(final byte[] b, final int off, final int len)
-            throws IOException {
-            if (len > BUF_SIZE) {
-                channel.write(b, off, len);
-            } else {
-                buffer.clear();
-                buffer.put(b, off, len).flip();
-                channel.write(buffer.array());
-            }
-            compressedCrc32.update(b, off, len);
-            fileBytesWritten += len;
-        }
-
-        @Override
-        public void flush() throws IOException {
-            // no reason to flush the channel
-        }
-
-        @Override
-        public void close() throws IOException {
-            // the file will be closed by the containing class's close method
-        }
+    @Override
+    public void close() throws IOException {
+      // the file will be closed by the containing class's close method
     }
+  }
 }
diff --git a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/StartHeader.java b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/StartHeader.java
index 522ec3baa..06cedd679 100644
--- a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/StartHeader.java
+++ b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/StartHeader.java
@@ -1,24 +1,27 @@
 /*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * This file is part of Amaze File Manager.
  *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
  *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
+
 package com.amaze.filemanager.filesystem.compressed.sevenz;
 
 class StartHeader {
-    long nextHeaderOffset;
-    long nextHeaderSize;
-    long nextHeaderCrc;
+  long nextHeaderOffset;
+  long nextHeaderSize;
+  long nextHeaderCrc;
 }
diff --git a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/StreamMap.java b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/StreamMap.java
index 15e3888ab..1856f0c57 100644
--- a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/StreamMap.java
+++ b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/StreamMap.java
@@ -1,38 +1,49 @@
 /*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * This file is part of Amaze File Manager.
  *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
  *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
+
 package com.amaze.filemanager.filesystem.compressed.sevenz;
 
 /// Map between folders, files and streams.
 class StreamMap {
-    /// The first Archive.packStream index of each folder.
-    int[] folderFirstPackStreamIndex;
-    /// Offset to beginning of this pack stream's data, relative to the beginning of the first pack stream.
-    long[] packStreamOffsets;
-    /// Index of first file for each folder.
-    int[] folderFirstFileIndex;
-    /// Index of folder for each file.
-    int[] fileFolderIndex;
+  /// The first Archive.packStream index of each folder.
+  int[] folderFirstPackStreamIndex;
+  /// Offset to beginning of this pack stream's data, relative to the beginning of the first pack
+  // stream.
+  long[] packStreamOffsets;
+  /// Index of first file for each folder.
+  int[] folderFirstFileIndex;
+  /// Index of folder for each file.
+  int[] fileFolderIndex;
 
-    @Override
-    public String toString() {
-        return "StreamMap with indices of " + folderFirstPackStreamIndex.length
-            + " folders, offsets of " + packStreamOffsets.length + " packed streams,"
-            + " first files of " + folderFirstFileIndex.length + " folders and"
-            + " folder indices for " + fileFolderIndex.length + " files";
-    }
+  @Override
+  public String toString() {
+    return "StreamMap with indices of "
+        + folderFirstPackStreamIndex.length
+        + " folders, offsets of "
+        + packStreamOffsets.length
+        + " packed streams,"
+        + " first files of "
+        + folderFirstFileIndex.length
+        + " folders and"
+        + " folder indices for "
+        + fileFolderIndex.length
+        + " files";
+  }
 }
diff --git a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/SubStreamsInfo.java b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/SubStreamsInfo.java
index a72395936..7915cf380 100644
--- a/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/SubStreamsInfo.java
+++ b/commons_compress_7z/src/main/java/com/amaze/filemanager/filesystem/compressed/sevenz/SubStreamsInfo.java
@@ -1,30 +1,33 @@
 /*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * This file is part of Amaze File Manager.
  *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
  *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
+
 package com.amaze.filemanager.filesystem.compressed.sevenz;
 
 import java.util.BitSet;
 
 /// Properties for non-empty files.
 class SubStreamsInfo {
-    /// Unpacked size of each unpacked stream.
-    long[] unpackSizes;
-    /// Whether CRC is present for each unpacked stream.
-    BitSet hasCrc;
-    /// CRCs of unpacked streams, if present.
-    long[] crcs;
+  /// Unpacked size of each unpacked stream.
+  long[] unpackSizes;
+  /// Whether CRC is present for each unpacked stream.
+  BitSet hasCrc;
+  /// CRCs of unpacked streams, if present.
+  long[] crcs;
 }
diff --git a/file_operations/src/main/java/com/amaze/filemanager/file_operations/exceptions/CloudPluginException.java b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/exceptions/CloudPluginException.java
similarity index 94%
rename from file_operations/src/main/java/com/amaze/filemanager/file_operations/exceptions/CloudPluginException.java
rename to file_operations/src/main/java/com/amaze/filemanager/fileoperations/exceptions/CloudPluginException.java
index d48774c4f..a22f0aca8 100644
--- a/file_operations/src/main/java/com/amaze/filemanager/file_operations/exceptions/CloudPluginException.java
+++ b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/exceptions/CloudPluginException.java
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.file_operations.exceptions;
+package com.amaze.filemanager.fileoperations.exceptions;
 
 /** Created by vishal on 18/4/17. */
 public class CloudPluginException extends Exception {}
diff --git a/file_operations/src/main/java/com/amaze/filemanager/file_operations/exceptions/ShellNotRunningException.java b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/exceptions/ShellNotRunningException.java
similarity index 95%
rename from file_operations/src/main/java/com/amaze/filemanager/file_operations/exceptions/ShellNotRunningException.java
rename to file_operations/src/main/java/com/amaze/filemanager/fileoperations/exceptions/ShellNotRunningException.java
index 8b3435696..28b5503f0 100644
--- a/file_operations/src/main/java/com/amaze/filemanager/file_operations/exceptions/ShellNotRunningException.java
+++ b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/exceptions/ShellNotRunningException.java
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.file_operations.exceptions;
+package com.amaze.filemanager.fileoperations.exceptions;
 
 /** Created by vishal on 24/12/16. Exception thrown when root is */
 public class ShellNotRunningException extends Exception {
diff --git a/file_operations/src/main/java/com/amaze/filemanager/file_operations/exceptions/StreamNotFoundException.java b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/exceptions/StreamNotFoundException.java
similarity index 96%
rename from file_operations/src/main/java/com/amaze/filemanager/file_operations/exceptions/StreamNotFoundException.java
rename to file_operations/src/main/java/com/amaze/filemanager/fileoperations/exceptions/StreamNotFoundException.java
index d2b17f614..fa82938ad 100644
--- a/file_operations/src/main/java/com/amaze/filemanager/file_operations/exceptions/StreamNotFoundException.java
+++ b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/exceptions/StreamNotFoundException.java
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.file_operations.exceptions;
+package com.amaze.filemanager.fileoperations.exceptions;
 
 /**
  * Created by vishal on 21/1/17.
diff --git a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/FolderState.kt b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/FolderState.kt
similarity index 95%
rename from file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/FolderState.kt
rename to file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/FolderState.kt
index 77669b0b6..29709b648 100644
--- a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/FolderState.kt
+++ b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/FolderState.kt
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.file_operations.filesystem
+package com.amaze.filemanager.fileoperations.filesystem
 
 import androidx.annotation.IntDef
 
diff --git a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/OpenMode.java b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/OpenMode.java
similarity index 96%
rename from file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/OpenMode.java
rename to file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/OpenMode.java
index 30eafc22c..4a270fef4 100644
--- a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/OpenMode.java
+++ b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/OpenMode.java
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.file_operations.filesystem;
+package com.amaze.filemanager.fileoperations.filesystem;
 
 /**
  * Created by vishal on 10/11/16.
diff --git a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/OperationType.kt b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/OperationType.kt
similarity index 95%
rename from file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/OperationType.kt
rename to file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/OperationType.kt
index d6d9d92a6..b434d7326 100644
--- a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/OperationType.kt
+++ b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/OperationType.kt
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.file_operations.filesystem
+package com.amaze.filemanager.fileoperations.filesystem
 
 import androidx.annotation.IntDef
 
diff --git a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/StorageNaming.java b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/StorageNaming.java
similarity index 97%
rename from file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/StorageNaming.java
rename to file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/StorageNaming.java
index b7f3c3ada..9442017b0 100644
--- a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/StorageNaming.java
+++ b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/StorageNaming.java
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.file_operations.filesystem;
+package com.amaze.filemanager.fileoperations.filesystem;
 
 import java.io.File;
 
diff --git a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/cloud/CloudStreamServer.java b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/cloud/CloudStreamServer.java
similarity index 99%
rename from file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/cloud/CloudStreamServer.java
rename to file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/cloud/CloudStreamServer.java
index 72eb2c4bb..5dc6a5fa5 100644
--- a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/cloud/CloudStreamServer.java
+++ b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/cloud/CloudStreamServer.java
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.file_operations.filesystem.cloud;
+package com.amaze.filemanager.fileoperations.filesystem.cloud;
 
 import java.io.BufferedReader;
 import java.io.ByteArrayInputStream;
@@ -42,7 +42,7 @@ import java.util.StringTokenizer;
 import java.util.TimeZone;
 import java.util.Vector;
 
-import com.amaze.filemanager.file_operations.filesystem.smbstreamer.Streamer;
+import com.amaze.filemanager.fileoperations.filesystem.smbstreamer.Streamer;
 
 import android.net.Uri;
 import android.util.Log;
diff --git a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/cloud/CloudStreamSource.java b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/cloud/CloudStreamSource.java
similarity index 95%
rename from file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/cloud/CloudStreamSource.java
rename to file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/cloud/CloudStreamSource.java
index ab49e457b..9d04cd80e 100644
--- a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/cloud/CloudStreamSource.java
+++ b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/cloud/CloudStreamSource.java
@@ -18,12 +18,12 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.file_operations.filesystem.cloud;
+package com.amaze.filemanager.fileoperations.filesystem.cloud;
 
 import java.io.IOException;
 import java.io.InputStream;
 
-import com.amaze.filemanager.file_operations.filesystem.streams.RandomAccessStream;
+import com.amaze.filemanager.fileoperations.filesystem.streams.RandomAccessStream;
 
 public class CloudStreamSource extends RandomAccessStream {
   protected long fp;
diff --git a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/cloud/CloudStreamer.java b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/cloud/CloudStreamer.java
similarity index 98%
rename from file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/cloud/CloudStreamer.java
rename to file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/cloud/CloudStreamer.java
index b3f7da60e..3b840e7e2 100644
--- a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/cloud/CloudStreamer.java
+++ b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/cloud/CloudStreamer.java
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.file_operations.filesystem.cloud;
+package com.amaze.filemanager.fileoperations.filesystem.cloud;
 
 import java.io.File;
 import java.io.IOException;
diff --git a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/compressed/ArchivePasswordCache.java b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/compressed/ArchivePasswordCache.java
similarity index 98%
rename from file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/compressed/ArchivePasswordCache.java
rename to file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/compressed/ArchivePasswordCache.java
index 13c87f340..6ca7884d6 100644
--- a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/compressed/ArchivePasswordCache.java
+++ b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/compressed/ArchivePasswordCache.java
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.file_operations.filesystem.compressed;
+package com.amaze.filemanager.fileoperations.filesystem.compressed;
 
 import java.util.Collection;
 import java.util.HashMap;
diff --git a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/root/NativeOperations.kt b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/root/NativeOperations.kt
similarity index 94%
rename from file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/root/NativeOperations.kt
rename to file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/root/NativeOperations.kt
index 743f911ff..165352638 100644
--- a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/root/NativeOperations.kt
+++ b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/root/NativeOperations.kt
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.file_operations.filesystem.root
+package com.amaze.filemanager.fileoperations.filesystem.root
 
 object NativeOperations {
     init {
diff --git a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/smbstreamer/StreamServer.java b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/smbstreamer/StreamServer.java
similarity index 99%
rename from file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/smbstreamer/StreamServer.java
rename to file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/smbstreamer/StreamServer.java
index 27037155d..5bbd15149 100644
--- a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/smbstreamer/StreamServer.java
+++ b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/smbstreamer/StreamServer.java
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.file_operations.filesystem.smbstreamer;
+package com.amaze.filemanager.fileoperations.filesystem.smbstreamer;
 
 /** Created by Arpit on 06-07-2015. */
 import java.io.BufferedReader;
@@ -42,7 +42,7 @@ import java.util.StringTokenizer;
 import java.util.TimeZone;
 import java.util.Vector;
 
-import com.amaze.filemanager.file_operations.filesystem.cloud.CloudStreamer;
+import com.amaze.filemanager.fileoperations.filesystem.cloud.CloudStreamer;
 
 import android.net.Uri;
 import android.util.Log;
diff --git a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/smbstreamer/StreamSource.java b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/smbstreamer/StreamSource.java
similarity index 96%
rename from file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/smbstreamer/StreamSource.java
rename to file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/smbstreamer/StreamSource.java
index 37d9c6492..cadf18cb5 100644
--- a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/smbstreamer/StreamSource.java
+++ b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/smbstreamer/StreamSource.java
@@ -18,13 +18,13 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.file_operations.filesystem.smbstreamer;
+package com.amaze.filemanager.fileoperations.filesystem.smbstreamer;
 
 /** Created by Arpit on 06-07-2015. */
 import java.io.IOException;
 import java.io.InputStream;
 
-import com.amaze.filemanager.file_operations.filesystem.streams.RandomAccessStream;
+import com.amaze.filemanager.fileoperations.filesystem.streams.RandomAccessStream;
 
 import android.webkit.MimeTypeMap;
 
diff --git a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/smbstreamer/Streamer.java b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/smbstreamer/Streamer.java
similarity index 98%
rename from file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/smbstreamer/Streamer.java
rename to file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/smbstreamer/Streamer.java
index 3166ca393..7e10a46a8 100644
--- a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/smbstreamer/Streamer.java
+++ b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/smbstreamer/Streamer.java
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.file_operations.filesystem.smbstreamer;
+package com.amaze.filemanager.fileoperations.filesystem.smbstreamer;
 
 import java.io.File;
 import java.io.IOException;
diff --git a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/streams/RandomAccessStream.java b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/streams/RandomAccessStream.java
similarity index 96%
rename from file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/streams/RandomAccessStream.java
rename to file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/streams/RandomAccessStream.java
index f8977e41d..d69179364 100644
--- a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/streams/RandomAccessStream.java
+++ b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/streams/RandomAccessStream.java
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.file_operations.filesystem.streams;
+package com.amaze.filemanager.fileoperations.filesystem.streams;
 
 import java.io.IOException;
 import java.io.InputStream;
diff --git a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/usb/SingletonUsbOtg.java b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/usb/SingletonUsbOtg.java
similarity index 97%
rename from file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/usb/SingletonUsbOtg.java
rename to file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/usb/SingletonUsbOtg.java
index 3cfa39ef2..cb769a76b 100644
--- a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/usb/SingletonUsbOtg.java
+++ b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/usb/SingletonUsbOtg.java
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.file_operations.filesystem.usb;
+package com.amaze.filemanager.fileoperations.filesystem.usb;
 
 import android.net.Uri;
 
diff --git a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/usb/UsbOtgRepresentation.java b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/usb/UsbOtgRepresentation.java
similarity index 97%
rename from file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/usb/UsbOtgRepresentation.java
rename to file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/usb/UsbOtgRepresentation.java
index 08db7611c..4e1cd2001 100644
--- a/file_operations/src/main/java/com/amaze/filemanager/file_operations/filesystem/usb/UsbOtgRepresentation.java
+++ b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/usb/UsbOtgRepresentation.java
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.file_operations.filesystem.usb;
+package com.amaze.filemanager.fileoperations.filesystem.usb;
 
 import androidx.annotation.Nullable;
 
diff --git a/file_operations/src/main/java/com/amaze/filemanager/file_operations/utils/OnLowMemory.java b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/utils/OnLowMemory.java
similarity index 94%
rename from file_operations/src/main/java/com/amaze/filemanager/file_operations/utils/OnLowMemory.java
rename to file_operations/src/main/java/com/amaze/filemanager/fileoperations/utils/OnLowMemory.java
index d334c14cc..ae0876963 100644
--- a/file_operations/src/main/java/com/amaze/filemanager/file_operations/utils/OnLowMemory.java
+++ b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/utils/OnLowMemory.java
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.file_operations.utils;
+package com.amaze.filemanager.fileoperations.utils;
 
 public interface OnLowMemory {
   public void onLowMemory();
diff --git a/file_operations/src/main/java/com/amaze/filemanager/file_operations/utils/UpdatePosition.java b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/utils/UpdatePosition.java
similarity index 94%
rename from file_operations/src/main/java/com/amaze/filemanager/file_operations/utils/UpdatePosition.java
rename to file_operations/src/main/java/com/amaze/filemanager/fileoperations/utils/UpdatePosition.java
index dde29bfbe..5e23fb0cf 100644
--- a/file_operations/src/main/java/com/amaze/filemanager/file_operations/utils/UpdatePosition.java
+++ b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/utils/UpdatePosition.java
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.file_operations.utils;
+package com.amaze.filemanager.fileoperations.utils;
 
 public interface UpdatePosition {
   public void updatePosition(long toAdd);
diff --git a/file_operations/src/test/java/com/amaze/filemanager/file_operations/filesystem/cloud/CloudStreamSourceTest.java b/file_operations/src/test/java/com/amaze/filemanager/fileoperations/filesystem/cloud/CloudStreamSourceTest.java
similarity index 98%
rename from file_operations/src/test/java/com/amaze/filemanager/file_operations/filesystem/cloud/CloudStreamSourceTest.java
rename to file_operations/src/test/java/com/amaze/filemanager/fileoperations/filesystem/cloud/CloudStreamSourceTest.java
index e552faa82..d42ddfbf2 100644
--- a/file_operations/src/test/java/com/amaze/filemanager/file_operations/filesystem/cloud/CloudStreamSourceTest.java
+++ b/file_operations/src/test/java/com/amaze/filemanager/fileoperations/filesystem/cloud/CloudStreamSourceTest.java
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.file_operations.filesystem.cloud;
+package com.amaze.filemanager.fileoperations.filesystem.cloud;
 
 import static android.os.Build.VERSION_CODES.JELLY_BEAN;
 import static android.os.Build.VERSION_CODES.KITKAT;
@@ -41,7 +41,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
 
-import com.amaze.filemanager.file_operations.shadows.ShadowMultiDex;
+import com.amaze.filemanager.fileoperations.shadows.ShadowMultiDex;
 
 import android.os.Environment;
 
diff --git a/file_operations/src/test/java/com/amaze/filemanager/file_operations/filesystem/smbstreamer/StreamSourceTest.java b/file_operations/src/test/java/com/amaze/filemanager/fileoperations/filesystem/smbstreamer/StreamSourceTest.java
similarity index 97%
rename from file_operations/src/test/java/com/amaze/filemanager/file_operations/filesystem/smbstreamer/StreamSourceTest.java
rename to file_operations/src/test/java/com/amaze/filemanager/fileoperations/filesystem/smbstreamer/StreamSourceTest.java
index 0ec6d4027..e89e5d011 100644
--- a/file_operations/src/test/java/com/amaze/filemanager/file_operations/filesystem/smbstreamer/StreamSourceTest.java
+++ b/file_operations/src/test/java/com/amaze/filemanager/fileoperations/filesystem/smbstreamer/StreamSourceTest.java
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.file_operations.filesystem.smbstreamer;
+package com.amaze.filemanager.fileoperations.filesystem.smbstreamer;
 
 import static android.os.Build.VERSION_CODES.JELLY_BEAN;
 import static android.os.Build.VERSION_CODES.KITKAT;
@@ -39,8 +39,8 @@ import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 
-import com.amaze.filemanager.file_operations.shadows.ShadowMultiDex;
-import com.amaze.filemanager.file_operations.shadows.jcifs.smb.ShadowSmbFile;
+import com.amaze.filemanager.fileoperations.shadows.ShadowMultiDex;
+import com.amaze.filemanager.fileoperations.shadows.jcifs.smb.ShadowSmbFile;
 
 import android.os.Environment;
 
diff --git a/file_operations/src/test/java/com/amaze/filemanager/file_operations/shadows/ShadowMultiDex.java b/file_operations/src/test/java/com/amaze/filemanager/fileoperations/shadows/ShadowMultiDex.java
similarity index 95%
rename from file_operations/src/test/java/com/amaze/filemanager/file_operations/shadows/ShadowMultiDex.java
rename to file_operations/src/test/java/com/amaze/filemanager/fileoperations/shadows/ShadowMultiDex.java
index 71c10b9cd..3877a7018 100644
--- a/file_operations/src/test/java/com/amaze/filemanager/file_operations/shadows/ShadowMultiDex.java
+++ b/file_operations/src/test/java/com/amaze/filemanager/fileoperations/shadows/ShadowMultiDex.java
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.file_operations.shadows;
+package com.amaze.filemanager.fileoperations.shadows;
 
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
diff --git a/file_operations/src/test/java/com/amaze/filemanager/file_operations/shadows/jcifs/smb/ShadowSmbFile.java b/file_operations/src/test/java/com/amaze/filemanager/fileoperations/shadows/jcifs/smb/ShadowSmbFile.java
similarity index 96%
rename from file_operations/src/test/java/com/amaze/filemanager/file_operations/shadows/jcifs/smb/ShadowSmbFile.java
rename to file_operations/src/test/java/com/amaze/filemanager/fileoperations/shadows/jcifs/smb/ShadowSmbFile.java
index c16144b95..534fd4346 100644
--- a/file_operations/src/test/java/com/amaze/filemanager/file_operations/shadows/jcifs/smb/ShadowSmbFile.java
+++ b/file_operations/src/test/java/com/amaze/filemanager/fileoperations/shadows/jcifs/smb/ShadowSmbFile.java
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.file_operations.shadows.jcifs.smb;
+package com.amaze.filemanager.fileoperations.shadows.jcifs.smb;
 
 import java.io.File;
 import java.io.FileInputStream;
