diff --git a/src/com/android/alarmclock/AnalogAppWidgetProvider.java b/app/src/main/java/com/best/alarmclock/AnalogAppWidgetProvider.java
similarity index 100%
rename from src/com/android/alarmclock/AnalogAppWidgetProvider.java
rename to app/src/main/java/com/best/alarmclock/AnalogAppWidgetProvider.java
diff --git a/src/com/android/alarmclock/DigitalAppWidgetCityService.java b/app/src/main/java/com/best/alarmclock/DigitalAppWidgetCityService.java
similarity index 100%
rename from src/com/android/alarmclock/DigitalAppWidgetCityService.java
rename to app/src/main/java/com/best/alarmclock/DigitalAppWidgetCityService.java
diff --git a/src/com/android/alarmclock/DigitalAppWidgetCityViewsFactory.java b/app/src/main/java/com/best/alarmclock/DigitalAppWidgetCityViewsFactory.java
similarity index 99%
rename from src/com/android/alarmclock/DigitalAppWidgetCityViewsFactory.java
rename to app/src/main/java/com/best/alarmclock/DigitalAppWidgetCityViewsFactory.java
index 80e820c72..629c49b00 100644
--- a/src/com/android/alarmclock/DigitalAppWidgetCityViewsFactory.java
+++ b/app/src/main/java/com/best/alarmclock/DigitalAppWidgetCityViewsFactory.java
@@ -16,6 +16,10 @@
 
 package com.best.alarmclock;
 
+import static android.appwidget.AppWidgetManager.EXTRA_APPWIDGET_ID;
+import static android.appwidget.AppWidgetManager.INVALID_APPWIDGET_ID;
+import static java.util.Calendar.DAY_OF_WEEK;
+
 import android.content.Context;
 import android.content.Intent;
 import android.content.res.Resources;
@@ -38,10 +42,6 @@ import java.util.List;
 import java.util.Locale;
 import java.util.TimeZone;
 
-import static android.appwidget.AppWidgetManager.EXTRA_APPWIDGET_ID;
-import static android.appwidget.AppWidgetManager.INVALID_APPWIDGET_ID;
-import static java.util.Calendar.DAY_OF_WEEK;
-
 /**
  * This factory produces entries in the world cities list view displayed at the bottom of the
  * digital widget. Each row is comprised of two world cities located side-by-side.
@@ -84,7 +84,7 @@ public class DigitalAppWidgetCityViewsFactory implements RemoteViewsFactory {
     /**
      * <p>Synchronized to ensure single-threaded reading/writing of mCities, mHomeCity and
      * mShowHomeClock.</p>
-     *
+     * <p>
      * {@inheritDoc}
      */
     @Override
@@ -100,7 +100,7 @@ public class DigitalAppWidgetCityViewsFactory implements RemoteViewsFactory {
     /**
      * <p>Synchronized to ensure single-threaded reading/writing of mCities, mHomeCity and
      * mShowHomeClock.</p>
-     *
+     * <p>
      * {@inheritDoc}
      */
     @Override
@@ -161,7 +161,7 @@ public class DigitalAppWidgetCityViewsFactory implements RemoteViewsFactory {
     /**
      * <p>Synchronized to ensure single-threaded reading/writing of mCities, mHomeCity and
      * mShowHomeClock.</p>
-     *
+     * <p>
      * {@inheritDoc}
      */
     @Override
diff --git a/src/com/android/alarmclock/DigitalAppWidgetProvider.java b/app/src/main/java/com/best/alarmclock/DigitalAppWidgetProvider.java
similarity index 93%
rename from src/com/android/alarmclock/DigitalAppWidgetProvider.java
rename to app/src/main/java/com/best/alarmclock/DigitalAppWidgetProvider.java
index e083ac329..474b39fa6 100644
--- a/src/com/android/alarmclock/DigitalAppWidgetProvider.java
+++ b/app/src/main/java/com/best/alarmclock/DigitalAppWidgetProvider.java
@@ -16,6 +16,27 @@
 
 package com.best.alarmclock;
 
+import static android.app.AlarmManager.ACTION_NEXT_ALARM_CLOCK_CHANGED;
+import static android.app.PendingIntent.FLAG_NO_CREATE;
+import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
+import static android.appwidget.AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT;
+import static android.appwidget.AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH;
+import static android.appwidget.AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT;
+import static android.appwidget.AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH;
+import static android.content.Intent.ACTION_DATE_CHANGED;
+import static android.content.Intent.ACTION_LOCALE_CHANGED;
+import static android.content.Intent.ACTION_SCREEN_ON;
+import static android.content.Intent.ACTION_TIMEZONE_CHANGED;
+import static android.content.Intent.ACTION_TIME_CHANGED;
+import static android.util.TypedValue.COMPLEX_UNIT_PX;
+import static android.view.View.GONE;
+import static android.view.View.MeasureSpec.UNSPECIFIED;
+import static android.view.View.VISIBLE;
+import static com.best.deskclock.alarms.AlarmStateManager.ACTION_ALARM_CHANGED;
+import static com.best.deskclock.data.DataModel.ACTION_WORLD_CITIES_CHANGED;
+import static java.lang.Math.max;
+import static java.lang.Math.round;
+
 import android.annotation.SuppressLint;
 import android.app.AlarmManager;
 import android.app.PendingIntent;
@@ -28,7 +49,6 @@ import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.net.Uri;
 import android.os.Bundle;
-import androidx.annotation.NonNull;
 import android.text.TextUtils;
 import android.text.format.DateFormat;
 import android.util.ArraySet;
@@ -38,6 +58,8 @@ import android.widget.RemoteViews;
 import android.widget.TextClock;
 import android.widget.TextView;
 
+import androidx.annotation.NonNull;
+
 import com.best.deskclock.DeskClock;
 import com.best.deskclock.LogUtils;
 import com.best.deskclock.R;
@@ -51,45 +73,25 @@ import java.util.Calendar;
 import java.util.Date;
 import java.util.List;
 import java.util.Locale;
+import java.util.Objects;
 import java.util.Set;
 import java.util.TimeZone;
 
-import static android.app.AlarmManager.ACTION_NEXT_ALARM_CLOCK_CHANGED;
-import static android.app.PendingIntent.FLAG_NO_CREATE;
-import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
-import static android.appwidget.AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT;
-import static android.appwidget.AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH;
-import static android.appwidget.AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT;
-import static android.appwidget.AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH;
-import static android.content.Intent.ACTION_DATE_CHANGED;
-import static android.content.Intent.ACTION_LOCALE_CHANGED;
-import static android.content.Intent.ACTION_SCREEN_ON;
-import static android.content.Intent.ACTION_TIMEZONE_CHANGED;
-import static android.content.Intent.ACTION_TIME_CHANGED;
-import static android.util.TypedValue.COMPLEX_UNIT_PX;
-import static android.view.View.GONE;
-import static android.view.View.MeasureSpec.UNSPECIFIED;
-import static android.view.View.VISIBLE;
-import static com.best.deskclock.alarms.AlarmStateManager.ACTION_ALARM_CHANGED;
-import static com.best.deskclock.data.DataModel.ACTION_WORLD_CITIES_CHANGED;
-import static java.lang.Math.max;
-import static java.lang.Math.round;
-
 /**
  * <p>This provider produces a widget resembling one of the formats below.</p>
- *
+ * <p>
  * If an alarm is scheduled to ring in the future:
  * <pre>
  *         12:59 AM
  * WED, FEB 3 ‚è∞ THU 9:30 AM
  * </pre>
- *
+ * <p>
  * If no alarm is scheduled to ring in the future:
  * <pre>
  *         12:59 AM
  *        WED, FEB 3
  * </pre>
- *
+ * <p>
  * This widget is scaling the font sizes to fit within the widget bounds chosen by the user without
  * any clipping. To do so it measures layouts offscreen using a range of font sizes in order to
  * choose optimal values.
@@ -105,92 +107,17 @@ public class DigitalAppWidgetProvider extends AppWidgetProvider {
      */
     private static final String ACTION_ON_DAY_CHANGE = "com.best.deskclock.ON_DAY_CHANGE";
 
-    /** Intent used to deliver the {@link #ACTION_ON_DAY_CHANGE} callback. */
-    private static final Intent DAY_CHANGE_INTENT = new Intent(ACTION_ON_DAY_CHANGE);
-
-    @Override
-    public void onEnabled(Context context) {
-        super.onEnabled(context);
-
-        // Schedule the day-change callback if necessary.
-        updateDayChangeCallback(context);
-    }
-
-    @Override
-    public void onDisabled(Context context) {
-        super.onDisabled(context);
-
-        // Remove any scheduled day-change callback.
-        removeDayChangeCallback(context);
-    }
-
-    @Override
-    public void onReceive(@NonNull Context context, @NonNull Intent intent) {
-        LOGGER.i("onReceive: " + intent);
-        super.onReceive(context, intent);
-
-        final AppWidgetManager wm = AppWidgetManager.getInstance(context);
-        if (wm == null) {
-            return;
-        }
-
-        final ComponentName provider = new ComponentName(context, getClass());
-        final int[] widgetIds = wm.getAppWidgetIds(provider);
-
-        final String action = intent.getAction();
-        switch (action) {
-            case ACTION_NEXT_ALARM_CLOCK_CHANGED:
-            case ACTION_DATE_CHANGED:
-            case ACTION_LOCALE_CHANGED:
-            case ACTION_SCREEN_ON:
-            case ACTION_TIME_CHANGED:
-            case ACTION_TIMEZONE_CHANGED:
-            case ACTION_ALARM_CHANGED:
-            case ACTION_ON_DAY_CHANGE:
-            case ACTION_WORLD_CITIES_CHANGED:
-                for (int widgetId : widgetIds) {
-                    relayoutWidget(context, wm, widgetId, wm.getAppWidgetOptions(widgetId));
-                }
-        }
-
-        final DataModel dm = DataModel.getDataModel();
-        dm.updateWidgetCount(getClass(), widgetIds.length, R.string.category_digital_widget);
-
-        if (widgetIds.length > 0) {
-            updateDayChangeCallback(context);
-        }
-    }
-
-    /**
-     * Called when widgets must provide remote views.
-     */
-    @Override
-    public void onUpdate(Context context, AppWidgetManager wm, int[] widgetIds) {
-        super.onUpdate(context, wm, widgetIds);
-
-        for (int widgetId : widgetIds) {
-            relayoutWidget(context, wm, widgetId, wm.getAppWidgetOptions(widgetId));
-        }
-    }
-
     /**
-     * Called when the app widget changes sizes.
+     * Intent used to deliver the {@link #ACTION_ON_DAY_CHANGE} callback.
      */
-    @Override
-    public void onAppWidgetOptionsChanged(Context context, AppWidgetManager wm, int widgetId,
-            Bundle options) {
-        super.onAppWidgetOptionsChanged(context, wm, widgetId, options);
-
-        // scale the fonts of the clock to fit inside the new size
-        relayoutWidget(context, AppWidgetManager.getInstance(context), widgetId, options);
-    }
+    private static final Intent DAY_CHANGE_INTENT = new Intent(ACTION_ON_DAY_CHANGE);
 
     /**
      * Compute optimal font and icon sizes offscreen for both portrait and landscape orientations
      * using the last known widget size and apply them to the widget.
      */
     private static void relayoutWidget(Context context, AppWidgetManager wm, int widgetId,
-            Bundle options) {
+                                       Bundle options) {
         final RemoteViews portrait = relayoutWidget(context, wm, widgetId, options, true);
         final RemoteViews landscape = relayoutWidget(context, wm, widgetId, options, false);
         final RemoteViews widget = new RemoteViews(landscape, portrait);
@@ -202,7 +129,7 @@ public class DigitalAppWidgetProvider extends AppWidgetProvider {
      * Compute optimal font and icon sizes offscreen for the given orientation.
      */
     private static RemoteViews relayoutWidget(Context context, AppWidgetManager wm, int widgetId,
-            Bundle options, boolean portrait) {
+                                              Bundle options, boolean portrait) {
         // Create a remote view for the digital clock.
         final String packageName = context.getPackageName();
         final RemoteViews rv = new RemoteViews(packageName, R.layout.digital_widget);
@@ -223,7 +150,7 @@ public class DigitalAppWidgetProvider extends AppWidgetProvider {
         if (TextUtils.isEmpty(nextAlarmTime)) {
             rv.setViewVisibility(R.id.nextAlarm, GONE);
             rv.setViewVisibility(R.id.nextAlarmIcon, GONE);
-        } else  {
+        } else {
             rv.setTextViewText(R.id.nextAlarm, nextAlarmTime);
             rv.setViewVisibility(R.id.nextAlarm, VISIBLE);
             rv.setViewVisibility(R.id.nextAlarmIcon, VISIBLE);
@@ -291,22 +218,21 @@ public class DigitalAppWidgetProvider extends AppWidgetProvider {
     private static Sizes optimizeSizes(Context context, Sizes template, String nextAlarmTime) {
         // Inflate a test layout to compute sizes at different font sizes.
         final LayoutInflater inflater = LayoutInflater.from(context);
-        @SuppressLint("InflateParams")
-        final View sizer = inflater.inflate(R.layout.digital_widget_sizer, null /* root */);
+        @SuppressLint("InflateParams") final View sizer = inflater.inflate(R.layout.digital_widget_sizer, null /* root */);
 
         // Configure the date to display the current date string.
         final CharSequence dateFormat = getDateFormat(context);
-        final TextClock date = (TextClock) sizer.findViewById(R.id.date);
+        final TextClock date = sizer.findViewById(R.id.date);
         date.setFormat12Hour(dateFormat);
         date.setFormat24Hour(dateFormat);
 
         // Configure the next alarm views to display the next alarm time or be gone.
-        final TextView nextAlarmIcon = (TextView) sizer.findViewById(R.id.nextAlarmIcon);
-        final TextView nextAlarm = (TextView) sizer.findViewById(R.id.nextAlarm);
+        final TextView nextAlarmIcon = sizer.findViewById(R.id.nextAlarmIcon);
+        final TextView nextAlarm = sizer.findViewById(R.id.nextAlarm);
         if (TextUtils.isEmpty(nextAlarmTime)) {
             nextAlarm.setVisibility(GONE);
             nextAlarmIcon.setVisibility(GONE);
-        } else  {
+        } else {
             nextAlarm.setText(nextAlarmTime);
             nextAlarm.setVisibility(VISIBLE);
             nextAlarmIcon.setVisibility(VISIBLE);
@@ -343,49 +269,6 @@ public class DigitalAppWidgetProvider extends AppWidgetProvider {
         return low;
     }
 
-    /**
-     * Remove the existing day-change callback if it is not needed (no selected cities exist).
-     * Add the day-change callback if it is needed (selected cities exist).
-     */
-    private void updateDayChangeCallback(Context context) {
-        final DataModel dm = DataModel.getDataModel();
-        final List<City> selectedCities = dm.getSelectedCities();
-        final boolean showHomeClock = dm.getShowHomeClock();
-        if (selectedCities.isEmpty() && !showHomeClock) {
-            // Remove the existing day-change callback.
-            removeDayChangeCallback(context);
-            return;
-        }
-
-        // Look up the time at which the next day change occurs across all timezones.
-        final Set<TimeZone> zones = new ArraySet<>(selectedCities.size() + 2);
-        zones.add(TimeZone.getDefault());
-        if (showHomeClock) {
-            zones.add(dm.getHomeCity().getTimeZone());
-        }
-        for (City city : selectedCities) {
-            zones.add(city.getTimeZone());
-        }
-        final Date nextDay = Utils.getNextDay(new Date(), zones);
-
-        // Schedule the next day-change callback; at least one city is displayed.
-        final PendingIntent pi =
-                PendingIntent.getBroadcast(context, 0, DAY_CHANGE_INTENT, FLAG_UPDATE_CURRENT);
-        getAlarmManager(context).setExact(AlarmManager.RTC, nextDay.getTime(), pi);
-    }
-
-    /**
-     * Remove the existing day-change callback.
-     */
-    private void removeDayChangeCallback(Context context) {
-        final PendingIntent pi =
-                PendingIntent.getBroadcast(context, 0, DAY_CHANGE_INTENT, FLAG_NO_CREATE);
-        if (pi != null) {
-            getAlarmManager(context).cancel(pi);
-            pi.cancel();
-        }
-    }
-
     private static AlarmManager getAlarmManager(Context context) {
         return (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
     }
@@ -400,10 +283,10 @@ public class DigitalAppWidgetProvider extends AppWidgetProvider {
         final Sizes measuredSizes = template.newSize();
 
         // Configure the clock to display the widest time string.
-        final TextClock date = (TextClock) sizer.findViewById(R.id.date);
-        final TextClock clock = (TextClock) sizer.findViewById(R.id.clock);
-        final TextView nextAlarm = (TextView) sizer.findViewById(R.id.nextAlarm);
-        final TextView nextAlarmIcon = (TextView) sizer.findViewById(R.id.nextAlarmIcon);
+        final TextClock date = sizer.findViewById(R.id.date);
+        final TextClock clock = sizer.findViewById(R.id.clock);
+        final TextView nextAlarm = sizer.findViewById(R.id.nextAlarm);
+        final TextView nextAlarmIcon = sizer.findViewById(R.id.nextAlarmIcon);
 
         // Adjust the font sizes.
         measuredSizes.setClockFontSizePx(clockFontSize);
@@ -457,6 +340,126 @@ public class DigitalAppWidgetProvider extends AppWidgetProvider {
         return DateFormat.getBestDateTimePattern(locale, skeleton);
     }
 
+    @Override
+    public void onEnabled(Context context) {
+        super.onEnabled(context);
+
+        // Schedule the day-change callback if necessary.
+        updateDayChangeCallback(context);
+    }
+
+    @Override
+    public void onDisabled(Context context) {
+        super.onDisabled(context);
+
+        // Remove any scheduled day-change callback.
+        removeDayChangeCallback(context);
+    }
+
+    @Override
+    public void onReceive(@NonNull Context context, @NonNull Intent intent) {
+        LOGGER.i("onReceive: " + intent);
+        super.onReceive(context, intent);
+
+        final AppWidgetManager wm = AppWidgetManager.getInstance(context);
+        if (wm == null) {
+            return;
+        }
+
+        final ComponentName provider = new ComponentName(context, getClass());
+        final int[] widgetIds = wm.getAppWidgetIds(provider);
+
+        final String action = intent.getAction();
+        switch (action) {
+            case ACTION_NEXT_ALARM_CLOCK_CHANGED:
+            case ACTION_DATE_CHANGED:
+            case ACTION_LOCALE_CHANGED:
+            case ACTION_SCREEN_ON:
+            case ACTION_TIME_CHANGED:
+            case ACTION_TIMEZONE_CHANGED:
+            case ACTION_ALARM_CHANGED:
+            case ACTION_ON_DAY_CHANGE:
+            case ACTION_WORLD_CITIES_CHANGED:
+                for (int widgetId : widgetIds) {
+                    relayoutWidget(context, wm, widgetId, wm.getAppWidgetOptions(widgetId));
+                }
+        }
+
+        final DataModel dm = DataModel.getDataModel();
+        dm.updateWidgetCount(getClass(), widgetIds.length, R.string.category_digital_widget);
+
+        if (widgetIds.length > 0) {
+            updateDayChangeCallback(context);
+        }
+    }
+
+    /**
+     * Called when widgets must provide remote views.
+     */
+    @Override
+    public void onUpdate(Context context, AppWidgetManager wm, int[] widgetIds) {
+        super.onUpdate(context, wm, widgetIds);
+
+        for (int widgetId : widgetIds) {
+            relayoutWidget(context, wm, widgetId, wm.getAppWidgetOptions(widgetId));
+        }
+    }
+
+    /**
+     * Called when the app widget changes sizes.
+     */
+    @Override
+    public void onAppWidgetOptionsChanged(Context context, AppWidgetManager wm, int widgetId,
+                                          Bundle options) {
+        super.onAppWidgetOptionsChanged(context, wm, widgetId, options);
+
+        // scale the fonts of the clock to fit inside the new size
+        relayoutWidget(context, AppWidgetManager.getInstance(context), widgetId, options);
+    }
+
+    /**
+     * Remove the existing day-change callback if it is not needed (no selected cities exist).
+     * Add the day-change callback if it is needed (selected cities exist).
+     */
+    private void updateDayChangeCallback(Context context) {
+        final DataModel dm = DataModel.getDataModel();
+        final List<City> selectedCities = dm.getSelectedCities();
+        final boolean showHomeClock = dm.getShowHomeClock();
+        if (selectedCities.isEmpty() && !showHomeClock) {
+            // Remove the existing day-change callback.
+            removeDayChangeCallback(context);
+            return;
+        }
+
+        // Look up the time at which the next day change occurs across all timezones.
+        final Set<TimeZone> zones = new ArraySet<>(selectedCities.size() + 2);
+        zones.add(TimeZone.getDefault());
+        if (showHomeClock) {
+            zones.add(dm.getHomeCity().getTimeZone());
+        }
+        for (City city : selectedCities) {
+            zones.add(city.getTimeZone());
+        }
+        final Date nextDay = Utils.getNextDay(new Date(), zones);
+
+        // Schedule the next day-change callback; at least one city is displayed.
+        final PendingIntent pi =
+                PendingIntent.getBroadcast(context, 0, DAY_CHANGE_INTENT, FLAG_UPDATE_CURRENT);
+        getAlarmManager(context).setExact(AlarmManager.RTC, Objects.requireNonNull(nextDay).getTime(), pi);
+    }
+
+    /**
+     * Remove the existing day-change callback.
+     */
+    private void removeDayChangeCallback(Context context) {
+        final PendingIntent pi =
+                PendingIntent.getBroadcast(context, 0, DAY_CHANGE_INTENT, FLAG_NO_CREATE);
+        if (pi != null) {
+            getAlarmManager(context).cancel(pi);
+            pi.cancel();
+        }
+    }
+
     /**
      * This class stores the target size of the widget as well as the measured size using a given
      * clock font size. All other fonts and icons are scaled proportional to the clock font.
@@ -474,10 +477,14 @@ public class DigitalAppWidgetProvider extends AppWidgetProvider {
         private int mMeasuredTextClockWidthPx;
         private int mMeasuredTextClockHeightPx;
 
-        /** The size of the font to use on the date / next alarm time fields. */
+        /**
+         * The size of the font to use on the date / next alarm time fields.
+         */
         private int mFontSizePx;
 
-        /** The size of the font to use on the clock field. */
+        /**
+         * The size of the font to use on the clock field.
+         */
         private int mClockFontSizePx;
 
         private int mIconFontSizePx;
@@ -490,9 +497,22 @@ public class DigitalAppWidgetProvider extends AppWidgetProvider {
             mSmallestClockFontSizePx = 1;
         }
 
-        private int getLargestClockFontSizePx() { return mLargestClockFontSizePx; }
-        private int getSmallestClockFontSizePx() { return mSmallestClockFontSizePx; }
-        private int getClockFontSizePx() { return mClockFontSizePx; }
+        private static void append(StringBuilder builder, String format, Object... args) {
+            builder.append(String.format(Locale.ENGLISH, format, args));
+        }
+
+        private int getLargestClockFontSizePx() {
+            return mLargestClockFontSizePx;
+        }
+
+        private int getSmallestClockFontSizePx() {
+            return mSmallestClockFontSizePx;
+        }
+
+        private int getClockFontSizePx() {
+            return mClockFontSizePx;
+        }
+
         private void setClockFontSizePx(int clockFontSizePx) {
             mClockFontSizePx = clockFontSizePx;
             mFontSizePx = max(1, round(clockFontSizePx / 7.5f));
@@ -515,6 +535,7 @@ public class DigitalAppWidgetProvider extends AppWidgetProvider {
             return new Sizes(mTargetWidthPx, mTargetHeightPx, mLargestClockFontSizePx);
         }
 
+        @NonNull
         @Override
         public String toString() {
             final StringBuilder builder = new StringBuilder(1000);
@@ -535,9 +556,5 @@ public class DigitalAppWidgetProvider extends AppWidgetProvider {
             append(builder, "Clock font: %dpx\n", mClockFontSizePx);
             return builder.toString();
         }
-
-        private static void append(StringBuilder builder, String format, Object... args) {
-            builder.append(String.format(Locale.ENGLISH, format, args));
-        }
     }
 }
diff --git a/src/com/android/alarmclock/WidgetUtils.java b/app/src/main/java/com/best/alarmclock/WidgetUtils.java
similarity index 96%
rename from src/com/android/alarmclock/WidgetUtils.java
rename to app/src/main/java/com/best/alarmclock/WidgetUtils.java
index 8a17fdd7d..e2946e2bc 100644
--- a/src/com/android/alarmclock/WidgetUtils.java
+++ b/app/src/main/java/com/best/alarmclock/WidgetUtils.java
@@ -26,7 +26,8 @@ import com.best.deskclock.Utils;
 
 public final class WidgetUtils {
 
-    private WidgetUtils() {}
+    private WidgetUtils() {
+    }
 
     // Calculate the scale factor of the fonts in the widget
     public static float getScaleRatio(Context context, Bundle options, int id, int cityCount) {
@@ -51,14 +52,13 @@ public final class WidgetUtils {
             ratio *= .83f;
 
             if (cityCount > 0) {
-                return (ratio > 1f) ? 1f : ratio;
+                return Math.min(ratio, 1f);
             }
 
             ratio = Math.min(ratio, 1.6f);
             if (Utils.isPortrait(context)) {
                 ratio = Math.max(ratio, .71f);
-            }
-            else {
+            } else {
                 ratio = Math.max(ratio, .45f);
             }
             return ratio;
diff --git a/src/com/android/deskclock/AlarmAlertWakeLock.java b/app/src/main/java/com/best/deskclock/AlarmAlertWakeLock.java
similarity index 100%
rename from src/com/android/deskclock/AlarmAlertWakeLock.java
rename to app/src/main/java/com/best/deskclock/AlarmAlertWakeLock.java
diff --git a/src/com/android/deskclock/AlarmClockFragment.java b/app/src/main/java/com/best/deskclock/AlarmClockFragment.java
similarity index 93%
rename from src/com/android/deskclock/AlarmClockFragment.java
rename to app/src/main/java/com/best/deskclock/AlarmClockFragment.java
index 86ff2ee36..55f464f2e 100644
--- a/src/com/android/deskclock/AlarmClockFragment.java
+++ b/app/src/main/java/com/best/deskclock/AlarmClockFragment.java
@@ -16,6 +16,8 @@
 
 package com.best.deskclock;
 
+import static com.best.deskclock.uidata.UiDataModel.Tab.ALARMS;
+
 import android.app.LoaderManager;
 import android.content.Context;
 import android.content.Intent;
@@ -24,40 +26,38 @@ import android.database.Cursor;
 import android.graphics.drawable.Drawable;
 import android.os.Bundle;
 import android.os.SystemClock;
-import androidx.annotation.NonNull;
-import com.google.android.material.snackbar.Snackbar;
-import androidx.recyclerview.widget.LinearLayoutManager;
-import androidx.recyclerview.widget.RecyclerView;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
-import androidx.recyclerview.widget.ItemTouchHelper;
 import android.widget.Button;
 import android.widget.ImageView;
 import android.widget.TextView;
 
+import androidx.annotation.NonNull;
+import androidx.recyclerview.widget.ItemTouchHelper;
+import androidx.recyclerview.widget.LinearLayoutManager;
+import androidx.recyclerview.widget.RecyclerView;
 
 import com.best.deskclock.alarms.AlarmTimeClickHandler;
 import com.best.deskclock.alarms.AlarmUpdateHandler;
 import com.best.deskclock.alarms.ScrollHandler;
-import com.best.deskclock.alarms.dataadapter.AlarmItemViewHolder;
 import com.best.deskclock.alarms.TimePickerDialogFragment;
 import com.best.deskclock.alarms.dataadapter.AlarmItemHolder;
-import com.best.deskclock.events.Events;
+import com.best.deskclock.alarms.dataadapter.AlarmItemViewHolder;
 import com.best.deskclock.alarms.dataadapter.CollapsedAlarmViewHolder;
 import com.best.deskclock.alarms.dataadapter.ExpandedAlarmViewHolder;
+import com.best.deskclock.events.Events;
 import com.best.deskclock.provider.Alarm;
 import com.best.deskclock.provider.AlarmInstance;
 import com.best.deskclock.uidata.UiDataModel;
 import com.best.deskclock.widget.EmptyViewController;
 import com.best.deskclock.widget.toast.SnackbarManager;
 import com.best.deskclock.widget.toast.ToastManager;
-
+import com.google.android.material.snackbar.Snackbar;
 
 import java.util.ArrayList;
 import java.util.List;
-
-import static com.best.deskclock.uidata.UiDataModel.Tab.ALARMS;
+import java.util.Objects;
 
 /**
  * A fragment that displays a list of alarm time and allows interaction with them.
@@ -119,7 +119,7 @@ public final class AlarmClockFragment extends DeskClockFragment implements
         final View v = inflater.inflate(R.layout.alarm_clock, container, false);
         final Context context = getActivity();
 
-        mRecyclerView = (RecyclerView) v.findViewById(R.id.alarms_recycler_view);
+        mRecyclerView = v.findViewById(R.id.alarms_recycler_view);
         mLayoutManager = new LinearLayoutManager(context) {
             @Override
             protected int getExtraLayoutSpace(RecyclerView.State state) {
@@ -131,9 +131,9 @@ public final class AlarmClockFragment extends DeskClockFragment implements
             }
         };
         mRecyclerView.setLayoutManager(mLayoutManager);
-        mMainLayout = (ViewGroup) v.findViewById(R.id.main);
+        mMainLayout = v.findViewById(R.id.main);
         mAlarmUpdateHandler = new AlarmUpdateHandler(context, this, mMainLayout);
-        final TextView emptyView = (TextView) v.findViewById(R.id.alarms_empty_view);
+        final TextView emptyView = v.findViewById(R.id.alarms_empty_view);
         final Drawable noAlarms = Utils.getVectorDrawable(context, R.drawable.ic_noalarms);
         emptyView.setCompoundDrawablesWithIntrinsicBounds(null, noAlarms, null, null);
         mEmptyViewController = new EmptyViewController(mMainLayout, mRecyclerView, emptyView);
@@ -161,7 +161,7 @@ public final class AlarmClockFragment extends DeskClockFragment implements
                         final RecyclerView.ViewHolder viewHolder =
                                 mRecyclerView.findViewHolderForItemId(mExpandedAlarmId);
                         if (viewHolder != null) {
-                            smoothScrollTo(viewHolder.getAdapterPosition());
+                            smoothScrollTo(viewHolder.getBindingAdapterPosition());
                         }
                     }
                 } else if (mExpandedAlarmId == holder.itemId) {
@@ -183,15 +183,15 @@ public final class AlarmClockFragment extends DeskClockFragment implements
         itemAnimator.setChangeDuration(300L);
         itemAnimator.setMoveDuration(300L);
         mRecyclerView.setItemAnimator(itemAnimator);
-        
-             new ItemTouchHelper(new ItemTouchHelper.SimpleCallback(0, ItemTouchHelper.RIGHT) {
+
+        new ItemTouchHelper(new ItemTouchHelper.SimpleCallback(0, ItemTouchHelper.RIGHT) {
             @Override
-            public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) {
+            public boolean onMove(@NonNull RecyclerView recyclerView, @NonNull RecyclerView.ViewHolder viewHolder, @NonNull RecyclerView.ViewHolder target) {
                 return false;
             }
 
             @Override
-            public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) {
+            public void onSwiped(@NonNull RecyclerView.ViewHolder viewHolder, int direction) {
                 AlarmItemViewHolder alarmHolder = (AlarmItemViewHolder) viewHolder;
                 AlarmItemHolder itemHolder = alarmHolder.getItemHolder();
 
@@ -201,11 +201,11 @@ public final class AlarmClockFragment extends DeskClockFragment implements
                 mAlarmUpdateHandler.asyncDeleteAlarm(alarm);
             }
         }).attachToRecyclerView(mRecyclerView);
-            
-            return v;
+
+        return v;
     }
 
-                
+
     @Override
     public void onStart() {
         super.onStart();
@@ -324,15 +324,15 @@ public final class AlarmClockFragment extends DeskClockFragment implements
             return;
         }
 
-        if (mRecyclerView.getItemAnimator().isRunning()) {
+        if (Objects.requireNonNull(mRecyclerView.getItemAnimator()).isRunning()) {
             // RecyclerView is currently animating -> defer update.
             mRecyclerView.getItemAnimator().isRunning(
                     new RecyclerView.ItemAnimator.ItemAnimatorFinishedListener() {
-                @Override
-                public void onAnimationsFinished() {
-                    setAdapterItems(items, updateToken);
-                }
-            });
+                        @Override
+                        public void onAnimationsFinished() {
+                            setAdapterItems(items, updateToken);
+                        }
+                    });
         } else if (mRecyclerView.isComputingLayout()) {
             // RecyclerView is currently computing a layout -> defer update.
             mRecyclerView.post(new Runnable() {
@@ -427,12 +427,13 @@ public final class AlarmClockFragment extends DeskClockFragment implements
     }
 
 
-    private void startCreatingAlarm() {
+    public void startCreatingAlarm() {
         // Clear the currently selected alarm.
         mAlarmTimeClickHandler.setSelectedAlarm(null);
         TimePickerDialogFragment.show(this);
     }
 
+
     @Override
     public void onTimeSet(TimePickerDialogFragment fragment, int hourOfDay, int minute) {
         mAlarmTimeClickHandler.onTimeSet(hourOfDay, minute);
@@ -449,13 +450,13 @@ public final class AlarmClockFragment extends DeskClockFragment implements
     private final class ScrollPositionWatcher extends RecyclerView.OnScrollListener
             implements View.OnLayoutChangeListener {
         @Override
-        public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
+        public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) {
             setTabScrolledToTop(Utils.isScrolledToTop(mRecyclerView));
         }
 
         @Override
         public void onLayoutChange(View v, int left, int top, int right, int bottom,
-                int oldLeft, int oldTop, int oldRight, int oldBottom) {
+                                   int oldLeft, int oldTop, int oldRight, int oldBottom) {
             setTabScrolledToTop(Utils.isScrolledToTop(mRecyclerView));
         }
     }
diff --git a/src/com/android/deskclock/AlarmInitReceiver.java b/app/src/main/java/com/best/deskclock/AlarmInitReceiver.java
similarity index 99%
rename from src/com/android/deskclock/AlarmInitReceiver.java
rename to app/src/main/java/com/best/deskclock/AlarmInitReceiver.java
index af35bb7a1..19b8dcb23 100644
--- a/src/com/android/deskclock/AlarmInitReceiver.java
+++ b/app/src/main/java/com/best/deskclock/AlarmInitReceiver.java
@@ -23,11 +23,10 @@ import android.content.Context;
 import android.content.Intent;
 import android.os.PowerManager.WakeLock;
 
-import com.best.deskclock.alarms.AlarmStateManager;
 import com.best.deskclock.alarms.AlarmNotifications;
+import com.best.deskclock.alarms.AlarmStateManager;
 import com.best.deskclock.controller.Controller;
 import com.best.deskclock.data.DataModel;
-import com.best.deskclock.NotificationUtils;
 import com.best.deskclock.provider.AlarmInstance;
 
 import java.util.Calendar;
diff --git a/src/com/android/deskclock/AlarmRecyclerView.java b/app/src/main/java/com/best/deskclock/AlarmRecyclerView.java
similarity index 84%
rename from src/com/android/deskclock/AlarmRecyclerView.java
rename to app/src/main/java/com/best/deskclock/AlarmRecyclerView.java
index 95b1bf5c0..02d5545b2 100644
--- a/src/com/android/deskclock/AlarmRecyclerView.java
+++ b/app/src/main/java/com/best/deskclock/AlarmRecyclerView.java
@@ -17,14 +17,18 @@
 package com.best.deskclock;
 
 import android.content.Context;
-import androidx.annotation.Nullable;
-import androidx.recyclerview.widget.RecyclerView;
 import android.util.AttributeSet;
 import android.view.MotionEvent;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.recyclerview.widget.RecyclerView;
+
+import java.util.Objects;
+
 /**
- *  Thin wrapper around RecyclerView to prevent simultaneous layout passes, particularly during
- *  animations.
+ * Thin wrapper around RecyclerView to prevent simultaneous layout passes, particularly during
+ * animations.
  */
 public class AlarmRecyclerView extends RecyclerView {
 
@@ -42,9 +46,9 @@ public class AlarmRecyclerView extends RecyclerView {
         super(context, attrs, defStyle);
         addOnItemTouchListener(new RecyclerView.SimpleOnItemTouchListener() {
             @Override
-            public boolean onInterceptTouchEvent(RecyclerView rv, MotionEvent e) {
+            public boolean onInterceptTouchEvent(@NonNull RecyclerView rv, @NonNull MotionEvent e) {
                 // Disable scrolling/user action to prevent choppy animations.
-                return rv.getItemAnimator().isRunning();
+                return Objects.requireNonNull(rv.getItemAnimator()).isRunning();
             }
         });
     }
diff --git a/src/com/android/deskclock/AlarmSelectionActivity.java b/app/src/main/java/com/best/deskclock/AlarmSelectionActivity.java
similarity index 95%
rename from src/com/android/deskclock/AlarmSelectionActivity.java
rename to app/src/main/java/com/best/deskclock/AlarmSelectionActivity.java
index a04b9f3ff..b282f1626 100644
--- a/src/com/android/deskclock/AlarmSelectionActivity.java
+++ b/app/src/main/java/com/best/deskclock/AlarmSelectionActivity.java
@@ -35,15 +35,16 @@ import java.util.Locale;
 
 public class AlarmSelectionActivity extends ListActivity {
 
-    /** Used by default when an invalid action provided. */
-    private static final int ACTION_INVALID = -1;
-
-    /** Action used to signify alarm should be dismissed on selection. */
+    /**
+     * Action used to signify alarm should be dismissed on selection.
+     */
     public static final int ACTION_DISMISS = 0;
-
     public static final String EXTRA_ACTION = "com.best.deskclock.EXTRA_ACTION";
     public static final String EXTRA_ALARMS = "com.best.deskclock.EXTRA_ALARMS";
-
+    /**
+     * Used by default when an invalid action provided.
+     */
+    private static final int ACTION_INVALID = -1;
     private final List<AlarmSelection> mSelections = new ArrayList<>();
 
     private int mAction;
@@ -61,7 +62,7 @@ public class AlarmSelectionActivity extends ListActivity {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.selection_layout);
 
-        final Button cancelButton = (Button) findViewById(R.id.cancel_button);
+        final Button cancelButton = findViewById(R.id.cancel_button);
         cancelButton.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
diff --git a/src/com/android/deskclock/AlarmUtils.java b/app/src/main/java/com/best/deskclock/AlarmUtils.java
similarity index 98%
rename from src/com/android/deskclock/AlarmUtils.java
rename to app/src/main/java/com/best/deskclock/AlarmUtils.java
index a83380273..0ab79a291 100644
--- a/src/com/android/deskclock/AlarmUtils.java
+++ b/app/src/main/java/com/best/deskclock/AlarmUtils.java
@@ -17,16 +17,17 @@
 package com.best.deskclock;
 
 import android.content.Context;
-import androidx.annotation.VisibleForTesting;
-import com.google.android.material.snackbar.Snackbar;
 import android.text.format.DateFormat;
 import android.text.format.DateUtils;
 import android.view.View;
 import android.widget.Toast;
 
+import androidx.annotation.VisibleForTesting;
+
 import com.best.deskclock.provider.AlarmInstance;
 import com.best.deskclock.widget.toast.SnackbarManager;
 import com.best.deskclock.widget.toast.ToastManager;
+import com.google.android.material.snackbar.Snackbar;
 
 import java.util.Calendar;
 import java.util.Locale;
@@ -49,7 +50,7 @@ public class AlarmUtils {
     }
 
     public static String getAlarmText(Context context, AlarmInstance instance,
-            boolean includeLabel) {
+                                      boolean includeLabel) {
         String alarmTimeStr = getFormattedTime(context, instance.getAlarmTime());
         return (instance.mLabel.isEmpty() || !includeLabel)
                 ? alarmTimeStr
diff --git a/src/com/android/deskclock/AnalogClock.java b/app/src/main/java/com/best/deskclock/AnalogClock.java
similarity index 98%
rename from src/com/android/deskclock/AnalogClock.java
rename to app/src/main/java/com/best/deskclock/AnalogClock.java
index 17848211e..e2dc7d72c 100644
--- a/src/com/android/deskclock/AnalogClock.java
+++ b/app/src/main/java/com/best/deskclock/AnalogClock.java
@@ -16,29 +16,36 @@
 
 package com.best.deskclock;
 
+import static android.text.format.DateUtils.SECOND_IN_MILLIS;
+
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
-import androidx.appcompat.widget.AppCompatImageView;
-
 import android.graphics.Color;
 import android.text.format.DateFormat;
 import android.util.AttributeSet;
 import android.widget.FrameLayout;
 import android.widget.ImageView;
 
+import androidx.appcompat.widget.AppCompatImageView;
+
 import java.text.SimpleDateFormat;
 import java.util.Calendar;
 import java.util.TimeZone;
 
-import static android.text.format.DateUtils.SECOND_IN_MILLIS;
-
 /**
  * This widget display an analog clock with two hands for hours and minutes.
  */
 public class AnalogClock extends FrameLayout {
 
+    private final ImageView mHourHand;
+    private final ImageView mMinuteHand;
+    private final ImageView mSecondHand;
+    private final String mDescFormat;
+    private Calendar mTime;
+    private TimeZone mTimeZone;
+    private boolean mEnableSeconds = true;
     private final BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {
         @Override
         public void onReceive(Context context, Intent intent) {
@@ -49,7 +56,6 @@ public class AnalogClock extends FrameLayout {
             onTimeChanged();
         }
     };
-
     private final Runnable mClockTick = new Runnable() {
         @Override
         public void run() {
@@ -63,15 +69,6 @@ public class AnalogClock extends FrameLayout {
         }
     };
 
-    private final ImageView mHourHand;
-    private final ImageView mMinuteHand;
-    private final ImageView mSecondHand;
-
-    private Calendar mTime;
-    private String mDescFormat;
-    private TimeZone mTimeZone;
-    private boolean mEnableSeconds = true;
-
     public AnalogClock(Context context) {
         this(context, null /* attrs */);
     }
@@ -108,7 +105,7 @@ public class AnalogClock extends FrameLayout {
         mSecondHand.getDrawable().mutate();
         addView(mSecondHand);
 
-        if (context.getClass().getSimpleName().equalsIgnoreCase(ScreensaverActivity.class.getSimpleName())){
+        if (context.getClass().getSimpleName().equalsIgnoreCase(ScreensaverActivity.class.getSimpleName())) {
             dial.setColorFilter(Color.WHITE);
             mHourHand.setColorFilter(Color.WHITE);
             mMinuteHand.setColorFilter(Color.WHITE);
diff --git a/src/com/android/deskclock/AnimatorUtils.java b/app/src/main/java/com/best/deskclock/AnimatorUtils.java
similarity index 81%
rename from src/com/android/deskclock/AnimatorUtils.java
rename to app/src/main/java/com/best/deskclock/AnimatorUtils.java
index 4845b977a..1e7b17961 100644
--- a/src/com/android/deskclock/AnimatorUtils.java
+++ b/app/src/main/java/com/best/deskclock/AnimatorUtils.java
@@ -26,13 +26,14 @@ import android.graphics.Rect;
 import android.graphics.drawable.Animatable;
 import android.graphics.drawable.Drawable;
 import android.graphics.drawable.LayerDrawable;
-import androidx.core.graphics.drawable.DrawableCompat;
-import androidx.interpolator.view.animation.FastOutSlowInInterpolator;
 import android.util.Property;
 import android.view.View;
 import android.view.animation.Interpolator;
 import android.widget.ImageView;
 
+import androidx.core.graphics.drawable.DrawableCompat;
+import androidx.interpolator.view.animation.FastOutSlowInInterpolator;
+
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 
@@ -50,28 +51,111 @@ public class AnimatorUtils {
 
     public static final Property<View, Integer> BACKGROUND_ALPHA =
             new Property<View, Integer>(Integer.class, "background.alpha") {
-        @Override
-        public Integer get(View view) {
-            Drawable background = view.getBackground();
-            if (background instanceof LayerDrawable
-                    && ((LayerDrawable) background).getNumberOfLayers() > 0) {
-                background = ((LayerDrawable) background).getDrawable(0);
-            }
-            return background.getAlpha();
-        }
+                @Override
+                public Integer get(View view) {
+                    Drawable background = view.getBackground();
+                    if (background instanceof LayerDrawable
+                            && ((LayerDrawable) background).getNumberOfLayers() > 0) {
+                        background = ((LayerDrawable) background).getDrawable(0);
+                    }
+                    return background.getAlpha();
+                }
 
-        @Override
-        public void set(View view, Integer value) {
-            setBackgroundAlpha(view, value);
-        }
-    };
+                @Override
+                public void set(View view, Integer value) {
+                    setBackgroundAlpha(view, value);
+                }
+            };
+    public static final Property<ImageView, Integer> DRAWABLE_ALPHA =
+            new Property<ImageView, Integer>(Integer.class, "drawable.alpha") {
+                @Override
+                public Integer get(ImageView view) {
+                    return view.getDrawable().getAlpha();
+                }
+
+                @Override
+                public void set(ImageView view, Integer value) {
+                    view.getDrawable().setAlpha(value);
+                }
+            };
+    public static final Property<ImageView, Integer> DRAWABLE_TINT =
+            new Property<ImageView, Integer>(Integer.class, "drawable.tint") {
+                @Override
+                public Integer get(ImageView view) {
+                    return null;
+                }
+
+                @Override
+                public void set(ImageView view, Integer value) {
+                    // Ensure the drawable is wrapped using DrawableCompat.
+                    final Drawable drawable = view.getDrawable();
+                    final Drawable wrappedDrawable = DrawableCompat.wrap(drawable);
+                    if (wrappedDrawable != drawable) {
+                        view.setImageDrawable(wrappedDrawable);
+                    }
+                    // Set the new tint value via DrawableCompat.
+                    DrawableCompat.setTint(wrappedDrawable, value);
+                }
+            };
+    @SuppressWarnings("unchecked")
+    public static final TypeEvaluator<Integer> ARGB_EVALUATOR = new ArgbEvaluator();
+    public static final Property<View, Integer> VIEW_LEFT =
+            new Property<View, Integer>(Integer.class, "left") {
+                @Override
+                public Integer get(View view) {
+                    return view.getLeft();
+                }
+
+                @Override
+                public void set(View view, Integer left) {
+                    view.setLeft(left);
+                }
+            };
+    public static final Property<View, Integer> VIEW_TOP =
+            new Property<View, Integer>(Integer.class, "top") {
+                @Override
+                public Integer get(View view) {
+                    return view.getTop();
+                }
+
+                @Override
+                public void set(View view, Integer top) {
+                    view.setTop(top);
+                }
+            };
+    public static final Property<View, Integer> VIEW_BOTTOM =
+            new Property<View, Integer>(Integer.class, "bottom") {
+                @Override
+                public Integer get(View view) {
+                    return view.getBottom();
+                }
+
+                @Override
+                public void set(View view, Integer bottom) {
+                    view.setBottom(bottom);
+                }
+            };
+    public static final Property<View, Integer> VIEW_RIGHT =
+            new Property<View, Integer>(Integer.class, "right") {
+                @Override
+                public Integer get(View view) {
+                    return view.getRight();
+                }
+
+                @Override
+                public void set(View view, Integer right) {
+                    view.setRight(right);
+                }
+            };
+    private static Method sAnimateValue;
+    private static boolean sTryAnimateValue = true;
 
     /**
      * Sets the alpha of the top layer's drawable (of the background) only, if the background is a
      * layer drawable, to ensure that the other layers (i.e., the selectable item background, and
      * therefore the touch feedback RippleDrawable) are not affected.
      *
-     * @param view the affected view
+     * @param view  the affected view
      * @param value the alpha value (0-255)
      */
     public static void setBackgroundAlpha(View view, Integer value) {
@@ -83,45 +167,6 @@ public class AnimatorUtils {
         background.setAlpha(value);
     }
 
-    public static final Property<ImageView, Integer> DRAWABLE_ALPHA =
-            new Property<ImageView, Integer>(Integer.class, "drawable.alpha") {
-        @Override
-        public Integer get(ImageView view) {
-            return view.getDrawable().getAlpha();
-        }
-
-        @Override
-        public void set(ImageView view, Integer value) {
-            view.getDrawable().setAlpha(value);
-        }
-    };
-
-    public static final Property<ImageView, Integer> DRAWABLE_TINT =
-            new Property<ImageView, Integer>(Integer.class, "drawable.tint") {
-        @Override
-        public Integer get(ImageView view) {
-            return null;
-        }
-
-        @Override
-        public void set(ImageView view, Integer value) {
-            // Ensure the drawable is wrapped using DrawableCompat.
-            final Drawable drawable = view.getDrawable();
-            final Drawable wrappedDrawable = DrawableCompat.wrap(drawable);
-            if (wrappedDrawable != drawable) {
-                view.setImageDrawable(wrappedDrawable);
-            }
-            // Set the new tint value via DrawableCompat.
-            DrawableCompat.setTint(wrappedDrawable, value);
-        }
-    };
-
-    @SuppressWarnings("unchecked")
-    public static final TypeEvaluator<Integer> ARGB_EVALUATOR = new ArgbEvaluator();
-
-    private static Method sAnimateValue;
-    private static boolean sTryAnimateValue = true;
-
     public static void setAnimatedFraction(ValueAnimator animator, float fraction) {
         if (Utils.isLMR1OrLater()) {
             animator.setCurrentFraction(fraction);
@@ -178,66 +223,14 @@ public class AnimatorUtils {
         return ObjectAnimator.ofFloat(view, View.ALPHA, values);
     }
 
-    public static final Property<View, Integer> VIEW_LEFT =
-            new Property<View, Integer>(Integer.class, "left") {
-                @Override
-                public Integer get(View view) {
-                    return view.getLeft();
-                }
-
-                @Override
-                public void set(View view, Integer left) {
-                    view.setLeft(left);
-                }
-            };
-
-    public static final Property<View, Integer> VIEW_TOP =
-            new Property<View, Integer>(Integer.class, "top") {
-                @Override
-                public Integer get(View view) {
-                    return view.getTop();
-                }
-
-                @Override
-                public void set(View view, Integer top) {
-                    view.setTop(top);
-                }
-            };
-
-    public static final Property<View, Integer> VIEW_BOTTOM =
-            new Property<View, Integer>(Integer.class, "bottom") {
-                @Override
-                public Integer get(View view) {
-                    return view.getBottom();
-                }
-
-                @Override
-                public void set(View view, Integer bottom) {
-                    view.setBottom(bottom);
-                }
-            };
-
-    public static final Property<View, Integer> VIEW_RIGHT =
-            new Property<View, Integer>(Integer.class, "right") {
-                @Override
-                public Integer get(View view) {
-                    return view.getRight();
-                }
-
-                @Override
-                public void set(View view, Integer right) {
-                    view.setRight(right);
-                }
-            };
-
     /**
      * @param target the view to be morphed
-     * @param from the bounds of the {@code target} before animating
-     * @param to the bounds of the {@code target} after animating
+     * @param from   the bounds of the {@code target} before animating
+     * @param to     the bounds of the {@code target} after animating
      * @return an animator that morphs the {@code target} between the {@code from} bounds and the
-     *      {@code to} bounds. Note that it is the *content* bounds that matter here, so padding
-     *      insets contributed by the background are subtracted from the views when computing the
-     *      {@code target} bounds.
+     * {@code to} bounds. Note that it is the *content* bounds that matter here, so padding
+     * insets contributed by the background are subtracted from the views when computing the
+     * {@code target} bounds.
      */
     public static Animator getBoundsAnimator(View target, View from, View to) {
         // Fetch the content insets for the views. Content bounds are what matter, not total bounds.
@@ -268,7 +261,7 @@ public class AnimatorUtils {
      * Returns an animator that animates the bounds of a single view.
      */
     public static Animator getBoundsAnimator(View view, int fromLeft, int fromTop, int fromRight,
-            int fromBottom, int toLeft, int toTop, int toRight, int toBottom) {
+                                             int fromBottom, int toLeft, int toTop, int toRight, int toBottom) {
         view.setLeft(fromLeft);
         view.setTop(fromTop);
         view.setRight(fromRight);
diff --git a/src/com/android/deskclock/AsyncHandler.java b/app/src/main/java/com/best/deskclock/AsyncHandler.java
similarity index 97%
rename from src/com/android/deskclock/AsyncHandler.java
rename to app/src/main/java/com/best/deskclock/AsyncHandler.java
index 49187175e..75ee98981 100644
--- a/src/com/android/deskclock/AsyncHandler.java
+++ b/app/src/main/java/com/best/deskclock/AsyncHandler.java
@@ -32,9 +32,10 @@ public final class AsyncHandler {
         sHandler = new Handler(sHandlerThread.getLooper());
     }
 
+    private AsyncHandler() {
+    }
+
     public static void post(Runnable r) {
         sHandler.post(r);
     }
-
-    private AsyncHandler() {}
 }
diff --git a/src/com/android/deskclock/AsyncRingtonePlayer.java b/app/src/main/java/com/best/deskclock/AsyncRingtonePlayer.java
similarity index 92%
rename from src/com/android/deskclock/AsyncRingtonePlayer.java
rename to app/src/main/java/com/best/deskclock/AsyncRingtonePlayer.java
index 035d756d5..1f858c38c 100644
--- a/src/com/android/deskclock/AsyncRingtonePlayer.java
+++ b/app/src/main/java/com/best/deskclock/AsyncRingtonePlayer.java
@@ -1,5 +1,8 @@
 package com.best.deskclock;
 
+import static android.media.AudioManager.AUDIOFOCUS_GAIN_TRANSIENT;
+import static android.media.AudioManager.STREAM_ALARM;
+
 import android.annotation.SuppressLint;
 import android.content.Context;
 import android.media.AudioAttributes;
@@ -18,9 +21,6 @@ import android.telephony.TelephonyManager;
 import java.io.IOException;
 import java.lang.reflect.Method;
 
-import static android.media.AudioManager.AUDIOFOCUS_GAIN_TRANSIENT;
-import static android.media.AudioManager.STREAM_ALARM;
-
 /**
  * <p>This class controls playback of ringtones. Uses {@link Ringtone} or {@link MediaPlayer} in a
  * dedicated thread so that this class can be called from the main thread. Consequently, problems
@@ -60,33 +60,88 @@ public final class AsyncRingtonePlayer {
     private static final int EVENT_VOLUME = 3;
     private static final String RINGTONE_URI_KEY = "RINGTONE_URI_KEY";
     private static final String CRESCENDO_DURATION_KEY = "CRESCENDO_DURATION_KEY";
-
-    /** Handler running on the ringtone thread. */
+    /**
+     * The context.
+     */
+    private final Context mContext;
+    /**
+     * Handler running on the ringtone thread.
+     */
     private Handler mHandler;
-
-    /** {@link MediaPlayerPlaybackDelegate} on pre M; {@link RingtonePlaybackDelegate} on M+ */
+    /**
+     * {@link MediaPlayerPlaybackDelegate} on pre M; {@link RingtonePlaybackDelegate} on M+
+     */
     private PlaybackDelegate mPlaybackDelegate;
 
-    /** The context. */
-    private final Context mContext;
-
     public AsyncRingtonePlayer(Context context) {
         mContext = context;
     }
 
-    /** Plays the ringtone. */
+    /**
+     * @return <code>true</code> iff the device is currently in a telephone call
+     */
+    private static boolean isInTelephoneCall(Context context) {
+        final TelephonyManager tm = (TelephonyManager)
+                context.getSystemService(Context.TELEPHONY_SERVICE);
+        return tm.getCallState() != TelephonyManager.CALL_STATE_IDLE;
+    }
+
+    /**
+     * @return Uri of the ringtone to play when the user is in a telephone call
+     */
+    private static Uri getInCallRingtoneUri(Context context) {
+        return Utils.getResourceUri(context, R.raw.alarm_expire);
+    }
+
+    /**
+     * @return Uri of the ringtone to play when the chosen ringtone fails to play
+     */
+    private static Uri getFallbackRingtoneUri(Context context) {
+        return Utils.getResourceUri(context, R.raw.alarm_expire);
+    }
+
+    /**
+     * @param currentTime current time of the device
+     * @param stopTime    time at which the crescendo finishes
+     * @param duration    length of time over which the crescendo occurs
+     * @return the scalar volume value that produces a linear increase in volume (in decibels)
+     */
+    private static float computeVolume(long currentTime, long stopTime, long duration) {
+        // Compute the percentage of the crescendo that has completed.
+        final float elapsedCrescendoTime = stopTime - currentTime;
+        final float fractionComplete = 1 - (elapsedCrescendoTime / duration);
+
+        // Use the fraction to compute a target decibel between -40dB (near silent) and 0dB (max).
+        final float gain = (fractionComplete * 40) - 40;
+
+        // Convert the target gain (in decibels) into the corresponding volume scalar.
+        final float volume = (float) Math.pow(10f, gain / 20f);
+
+        LOGGER.v("Ringtone crescendo %,.2f%% complete (scalar: %f, volume: %f dB)",
+                fractionComplete * 100, volume, gain);
+
+        return volume;
+    }
+
+    /**
+     * Plays the ringtone.
+     */
     public void play(Uri ringtoneUri, long crescendoDuration) {
         LOGGER.d("Posting play.");
         postMessage(EVENT_PLAY, ringtoneUri, crescendoDuration, 0);
     }
 
-    /** Stops playing the ringtone. */
+    /**
+     * Stops playing the ringtone.
+     */
     public void stop() {
         LOGGER.d("Posting stop.");
         postMessage(EVENT_STOP, null, 0, 0);
     }
 
-    /** Schedules an adjustment of the playback volume 50ms in the future. */
+    /**
+     * Schedules an adjustment of the playback volume 50ms in the future.
+     */
     private void scheduleVolumeAdjustment() {
         LOGGER.v("Adjusting volume.");
 
@@ -100,13 +155,13 @@ public final class AsyncRingtonePlayer {
     /**
      * Posts a message to the ringtone-thread handler.
      *
-     * @param messageCode the message to post
-     * @param ringtoneUri the ringtone in question, if any
+     * @param messageCode       the message to post
+     * @param ringtoneUri       the ringtone in question, if any
      * @param crescendoDuration the length of time, in ms, over which to crescendo the ringtone
-     * @param delayMillis the amount of time to delay sending the message, if any
+     * @param delayMillis       the amount of time to delay sending the message, if any
      */
     private void postMessage(int messageCode, Uri ringtoneUri, long crescendoDuration,
-            long delayMillis) {
+                             long delayMillis) {
         synchronized (this) {
             if (mHandler == null) {
                 mHandler = getNewHandler();
@@ -157,29 +212,6 @@ public final class AsyncRingtonePlayer {
         };
     }
 
-    /**
-     * @return <code>true</code> iff the device is currently in a telephone call
-     */
-    private static boolean isInTelephoneCall(Context context) {
-        final TelephonyManager tm = (TelephonyManager)
-                context.getSystemService(Context.TELEPHONY_SERVICE);
-        return tm.getCallState() != TelephonyManager.CALL_STATE_IDLE;
-    }
-
-    /**
-     * @return Uri of the ringtone to play when the user is in a telephone call
-     */
-    private static Uri getInCallRingtoneUri(Context context) {
-        return Utils.getResourceUri(context, R.raw.alarm_expire);
-    }
-
-    /**
-     * @return Uri of the ringtone to play when the chosen ringtone fails to play
-     */
-    private static Uri getFallbackRingtoneUri(Context context) {
-        return Utils.getResourceUri(context, R.raw.alarm_expire);
-    }
-
     /**
      * Check if the executing thread is the one dedicated to controlling the ringtone playback.
      */
@@ -190,29 +222,6 @@ public final class AsyncRingtonePlayer {
         }
     }
 
-    /**
-     * @param currentTime current time of the device
-     * @param stopTime time at which the crescendo finishes
-     * @param duration length of time over which the crescendo occurs
-     * @return the scalar volume value that produces a linear increase in volume (in decibels)
-     */
-    private static float computeVolume(long currentTime, long stopTime, long duration) {
-        // Compute the percentage of the crescendo that has completed.
-        final float elapsedCrescendoTime = stopTime - currentTime;
-        final float fractionComplete = 1 - (elapsedCrescendoTime / duration);
-
-        // Use the fraction to compute a target decibel between -40dB (near silent) and 0dB (max).
-        final float gain = (fractionComplete * 40) - 40;
-
-        // Convert the target gain (in decibels) into the corresponding volume scalar.
-        final float volume = (float) Math.pow(10f, gain/20f);
-
-        LOGGER.v("Ringtone crescendo %,.2f%% complete (scalar: %f, volume: %f dB)",
-                fractionComplete * 100, volume, gain);
-
-        return volume;
-    }
-
     /**
      * @return the platform-specific playback delegate to use to play the ringtone
      */
@@ -260,16 +269,24 @@ public final class AsyncRingtonePlayer {
      */
     private class MediaPlayerPlaybackDelegate implements PlaybackDelegate {
 
-        /** The audio focus manager. Only used by the ringtone thread. */
+        /**
+         * The audio focus manager. Only used by the ringtone thread.
+         */
         private AudioManager mAudioManager;
 
-        /** Non-{@code null} while playing a ringtone; {@code null} otherwise. */
+        /**
+         * Non-{@code null} while playing a ringtone; {@code null} otherwise.
+         */
         private MediaPlayer mMediaPlayer;
 
-        /** The duration over which to increase the volume. */
+        /**
+         * The duration over which to increase the volume.
+         */
         private long mCrescendoDuration = 0;
 
-        /** The time at which the crescendo shall cease; 0 if no crescendo is present. */
+        /**
+         * The time at which the crescendo shall cease; 0 if no crescendo is present.
+         */
         private long mCrescendoStopTime = 0;
 
         /**
@@ -335,7 +352,7 @@ public final class AsyncRingtonePlayer {
          *
          * @param inTelephoneCall {@code true} if there is currently an active telephone call
          * @return {@code true} if a crescendo has started and future volume adjustments are
-         *      required to advance the crescendo effect
+         * required to advance the crescendo effect
          */
         private boolean startPlayback(boolean inTelephoneCall)
                 throws IOException {
@@ -437,22 +454,34 @@ public final class AsyncRingtonePlayer {
      */
     private class RingtonePlaybackDelegate implements PlaybackDelegate {
 
-        /** The audio focus manager. Only used by the ringtone thread. */
+        /**
+         * The audio focus manager. Only used by the ringtone thread.
+         */
         private AudioManager mAudioManager;
 
-        /** The current ringtone. Only used by the ringtone thread. */
+        /**
+         * The current ringtone. Only used by the ringtone thread.
+         */
         private Ringtone mRingtone;
 
-        /** The method to adjust playback volume; cannot be null. */
+        /**
+         * The method to adjust playback volume; cannot be null.
+         */
         private Method mSetVolumeMethod;
 
-        /** The method to adjust playback looping; cannot be null. */
+        /**
+         * The method to adjust playback looping; cannot be null.
+         */
         private Method mSetLoopingMethod;
 
-        /** The duration over which to increase the volume. */
+        /**
+         * The duration over which to increase the volume.
+         */
         private long mCrescendoDuration = 0;
 
-        /** The time at which the crescendo shall cease; 0 if no crescendo is present. */
+        /**
+         * The time at which the crescendo shall cease; 0 if no crescendo is present.
+         */
         private long mCrescendoStopTime = 0;
 
         private RingtonePlaybackDelegate() {
@@ -537,7 +566,7 @@ public final class AsyncRingtonePlayer {
          *
          * @param inTelephoneCall {@code true} if there is currently an active telephone call
          * @return {@code true} if a crescendo has started and future volume adjustments are
-         *      required to advance the crescendo effect
+         * required to advance the crescendo effect
          */
         private boolean startPlayback(boolean inTelephoneCall) {
             // Indicate the ringtone should be played via the alarm stream.
diff --git a/src/com/android/deskclock/BaseActivity.java b/app/src/main/java/com/best/deskclock/BaseActivity.java
similarity index 69%
rename from src/com/android/deskclock/BaseActivity.java
rename to app/src/main/java/com/best/deskclock/BaseActivity.java
index a7e4b3435..95a6efba3 100644
--- a/src/com/android/deskclock/BaseActivity.java
+++ b/app/src/main/java/com/best/deskclock/BaseActivity.java
@@ -22,39 +22,38 @@ import android.animation.ValueAnimator;
 import android.animation.ValueAnimator.AnimatorUpdateListener;
 import android.graphics.drawable.ColorDrawable;
 import android.os.Bundle;
+
 import androidx.annotation.ColorInt;
 import androidx.appcompat.app.AppCompatActivity;
-import android.view.View;
-
-import static com.best.deskclock.AnimatorUtils.ARGB_EVALUATOR;
 
 /**
  * Base activity class that changes the app window's color based on the current hour.
  */
 public abstract class BaseActivity extends AppCompatActivity {
 
-    /** Sets the app window color on each frame of the {@link #mAppColorAnimator}. */
+    /**
+     * Sets the app window color on each frame of the {@link #mAppColorAnimator}.
+     */
     private final AppColorAnimationListener mAppColorAnimationListener
             = new AppColorAnimationListener();
 
-    /** The current animator that is changing the app window color or {@code null}. */
+    /**
+     * The current animator that is changing the app window color or {@code null}.
+     */
     private ValueAnimator mAppColorAnimator;
 
-    /** Draws the app window's color. */
+    /**
+     * Draws the app window's color.
+     */
     private ColorDrawable mBackground;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
 
-        // Allow the content to layout behind the status and navigation bars.
-//        getWindow().getDecorView().setSystemUiVisibility(
-//                View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
-//                        | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
-//                        | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);
+        super.onCreate(savedInstanceState);
 
         final @ColorInt int color = ThemeUtils.resolveColor(this, android.R.attr.colorBackground);
-        adjustAppColor(color, false /* animate */);
+        adjustAppColor(color  /* animate */);
     }
 
     @Override
@@ -63,16 +62,15 @@ public abstract class BaseActivity extends AppCompatActivity {
 
         // Ensure the app window color is up-to-date.
         final @ColorInt int color = ThemeUtils.resolveColor(this, android.R.attr.colorBackground);
-        adjustAppColor(color, false /* animate */);
+        adjustAppColor(color  /* animate */);
     }
 
     /**
      * Adjusts the current app window color of this activity; animates the change if desired.
      *
-     * @param color   the ARGB value to set as the current app window color
-     * @param animate {@code true} if the change should be animated
+     * @param color the ARGB value to set as the current app window color
      */
-    protected void adjustAppColor(@ColorInt int color, boolean animate) {
+    protected void adjustAppColor(@ColorInt int color) {
         // Create and install the drawable that defines the window color.
         if (mBackground == null) {
             mBackground = new ColorDrawable(color);
@@ -86,15 +84,7 @@ public abstract class BaseActivity extends AppCompatActivity {
 
         final @ColorInt int currentColor = mBackground.getColor();
         if (currentColor != color) {
-            if (animate) {
-                mAppColorAnimator = ValueAnimator.ofObject(ARGB_EVALUATOR, currentColor, color)
-                        .setDuration(3000L);
-                mAppColorAnimator.addUpdateListener(mAppColorAnimationListener);
-                mAppColorAnimator.addListener(mAppColorAnimationListener);
-                mAppColorAnimator.start();
-            } else {
-                setAppColor(color);
-            }
+            setAppColor(color);
         }
     }
 
diff --git a/src/com/android/deskclock/CircleButtonsLayout.java b/app/src/main/java/com/best/deskclock/CircleButtonsLayout.java
similarity index 89%
rename from src/com/android/deskclock/CircleButtonsLayout.java
rename to app/src/main/java/com/best/deskclock/CircleButtonsLayout.java
index a8f80d2da..63894bd2d 100644
--- a/src/com/android/deskclock/CircleButtonsLayout.java
+++ b/app/src/main/java/com/best/deskclock/CircleButtonsLayout.java
@@ -9,14 +9,14 @@ import android.widget.FrameLayout;
 import android.widget.TextView;
 
 /**
- * This class adjusts the locations of children buttons and text of this view group by adjusting the
+ * This class adjusts the locations of child buttons and text of this view group by adjusting the
  * margins of each item. The left and right buttons are aligned with the bottom of the circle. The
  * stop button and label text are located within the circle with the stop button near the bottom and
  * the label text near the top. The maximum text size for the label text view is also calculated.
  */
 public class CircleButtonsLayout extends FrameLayout {
 
-    private float mDiamOffset;
+    private final float mDiamOffset;
     private View mCircleView;
     private Button mResetAddButton;
     private TextView mLabel;
@@ -31,9 +31,7 @@ public class CircleButtonsLayout extends FrameLayout {
 
         final Resources res = getContext().getResources();
         final float strokeSize = res.getDimension(R.dimen.circletimer_circle_size);
-        final float dotStrokeSize = res.getDimension(R.dimen.circletimer_dot_size);
-        final float markerStrokeSize = res.getDimension(R.dimen.circletimer_marker_size);
-        mDiamOffset = Utils.calculateRadiusOffset(strokeSize, dotStrokeSize, markerStrokeSize) * 2;
+        mDiamOffset = strokeSize * 2;
     }
 
     @Override
@@ -49,8 +47,8 @@ public class CircleButtonsLayout extends FrameLayout {
     protected void remeasureViews() {
         if (mLabel == null) {
             mCircleView = findViewById(R.id.timer_time);
-            mLabel = (TextView) findViewById(R.id.timer_label);
-            mResetAddButton = (Button) findViewById(R.id.reset_add);
+            mLabel = findViewById(R.id.timer_label);
+            mResetAddButton = findViewById(R.id.reset_add);
         }
 
         final int frameWidth = mCircleView.getMeasuredWidth();
@@ -69,9 +67,9 @@ public class CircleButtonsLayout extends FrameLayout {
 
         if (mLabel != null) {
             MarginLayoutParams labelParams = (MarginLayoutParams) mLabel.getLayoutParams();
-            labelParams.topMargin = circleDiam/6;
+            labelParams.topMargin = circleDiam / 6;
             if (minBound == frameWidth) {
-                labelParams.topMargin += (frameHeight-frameWidth)/2;
+                labelParams.topMargin += (frameHeight - frameWidth) / 2;
             }
             /* The following formula has been simplified based on the following:
              * Our goal is to calculate the maximum width for the label frame.
@@ -134,4 +132,4 @@ public class CircleButtonsLayout extends FrameLayout {
             mLabel.setMaxWidth((int) w);
         }
     }
-}
+}
\ No newline at end of file
diff --git a/src/com/android/deskclock/ClockFragment.java b/app/src/main/java/com/best/deskclock/ClockFragment.java
similarity index 94%
rename from src/com/android/deskclock/ClockFragment.java
rename to app/src/main/java/com/best/deskclock/ClockFragment.java
index 7ea61b6b6..77944ad32 100644
--- a/src/com/android/deskclock/ClockFragment.java
+++ b/app/src/main/java/com/best/deskclock/ClockFragment.java
@@ -16,6 +16,13 @@
 
 package com.best.deskclock;
 
+import static android.app.AlarmManager.ACTION_NEXT_ALARM_CLOCK_CHANGED;
+import static android.view.View.GONE;
+import static android.view.View.INVISIBLE;
+import static android.view.View.VISIBLE;
+import static com.best.deskclock.uidata.UiDataModel.Tab.CLOCKS;
+import static java.util.Calendar.DAY_OF_WEEK;
+
 import android.app.Activity;
 import android.app.AlarmManager;
 import android.content.BroadcastReceiver;
@@ -28,9 +35,6 @@ import android.net.Uri;
 import android.os.Bundle;
 import android.os.Handler;
 import android.provider.Settings;
-import androidx.annotation.NonNull;
-import androidx.recyclerview.widget.LinearLayoutManager;
-import androidx.recyclerview.widget.RecyclerView;
 import android.text.format.DateUtils;
 import android.view.GestureDetector;
 import android.view.LayoutInflater;
@@ -42,6 +46,10 @@ import android.widget.ImageView;
 import android.widget.TextClock;
 import android.widget.TextView;
 
+import androidx.annotation.NonNull;
+import androidx.recyclerview.widget.LinearLayoutManager;
+import androidx.recyclerview.widget.RecyclerView;
+
 import com.best.deskclock.data.City;
 import com.best.deskclock.data.CityListener;
 import com.best.deskclock.data.DataModel;
@@ -53,13 +61,6 @@ import java.util.Calendar;
 import java.util.List;
 import java.util.TimeZone;
 
-import static android.app.AlarmManager.ACTION_NEXT_ALARM_CLOCK_CHANGED;
-import static android.view.View.GONE;
-import static android.view.View.INVISIBLE;
-import static android.view.View.VISIBLE;
-import static com.best.deskclock.uidata.UiDataModel.Tab.CLOCKS;
-import static java.util.Calendar.DAY_OF_WEEK;
-
 /**
  * Fragment that shows the clock (analog or digital), the next alarm info and the world clock.
  */
@@ -109,7 +110,7 @@ public final class ClockFragment extends DeskClockFragment {
         mCityAdapter = new SelectedCitiesAdapter(getActivity(), mDateFormat,
                 mDateFormatForAccessibility);
 
-        mCityList = (RecyclerView) fragmentView.findViewById(R.id.cities);
+        mCityList = fragmentView.findViewById(R.id.cities);
         mCityList.setLayoutManager(new LinearLayoutManager(getActivity()));
         mCityList.setAdapter(mCityAdapter);
         mCityList.setItemAnimator(null);
@@ -126,8 +127,8 @@ public final class ClockFragment extends DeskClockFragment {
         // on as a header to the main listview.
         mClockFrame = fragmentView.findViewById(R.id.main_clock_left_pane);
         if (mClockFrame != null) {
-            mDigitalClock = (TextClock) mClockFrame.findViewById(R.id.digital_clock);
-            mAnalogClock = (AnalogClock) mClockFrame.findViewById(R.id.analog_clock);
+            mDigitalClock = mClockFrame.findViewById(R.id.digital_clock);
+            mAnalogClock = mClockFrame.findViewById(R.id.analog_clock);
             Utils.setClockIconTypeface(mClockFrame);
             Utils.updateDate(mDateFormat, mDateFormatForAccessibility, mClockFrame);
             Utils.setClockStyle(mDigitalClock, mAnalogClock);
@@ -171,7 +172,6 @@ public final class ClockFragment extends DeskClockFragment {
 
         // Alarm observer is null on L or later.
         if (mAlarmObserver != null) {
-            @SuppressWarnings("deprecation")
             final Uri uri = Settings.System.getUriFor(Settings.System.NEXT_ALARM_FORMATTED);
             activity.getContentResolver().registerContentObserver(uri, false, mAlarmObserver);
         }
@@ -227,107 +227,6 @@ public final class ClockFragment extends DeskClockFragment {
         }
     }
 
-    /**
-     * Long pressing over the main clock starts the screen saver.
-     */
-    private final class StartScreenSaverListener implements View.OnLongClickListener {
-
-        @Override
-        public boolean onLongClick(View view) {
-            startActivity(new Intent(getActivity(), ScreensaverActivity.class)
-                    .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
-                    .putExtra(Events.EXTRA_EVENT_LABEL, R.string.label_deskclock));
-            return true;
-        }
-    }
-
-    /**
-     * Long pressing over the city list starts the screen saver.
-     */
-    private final class CityListOnLongClickListener extends GestureDetector.SimpleOnGestureListener
-            implements View.OnTouchListener {
-
-        private final GestureDetector mGestureDetector;
-
-        private CityListOnLongClickListener(Context context) {
-            mGestureDetector = new GestureDetector(context, this);
-        }
-
-        @Override
-        public void onLongPress(MotionEvent e) {
-            final View view = getView();
-            if (view != null) {
-                view.performLongClick();
-            }
-        }
-
-        @Override
-        public boolean onDown(MotionEvent e) {
-            return true;
-        }
-
-        @Override
-        public boolean onTouch(View v, MotionEvent event) {
-            return mGestureDetector.onTouchEvent(event);
-        }
-    }
-
-    /**
-     * This runnable executes at every quarter-hour (e.g. 1:00, 1:15, 1:30, 1:45, etc...) and
-     * updates the dates displayed within the UI. Quarter-hour increments were chosen to accommodate
-     * the "weirdest" timezones (e.g. Nepal is UTC/GMT +05:45).
-     */
-    private final class QuarterHourRunnable implements Runnable {
-        @Override
-        public void run() {
-            mCityAdapter.notifyDataSetChanged();
-        }
-    }
-
-    /**
-     * Prior to L, a ContentObserver was used to monitor changes to the next scheduled alarm.
-     * In L and beyond this is accomplished via a system broadcast of
-     * {@link AlarmManager#ACTION_NEXT_ALARM_CLOCK_CHANGED}.
-     */
-    private final class AlarmObserverPreL extends ContentObserver {
-        private AlarmObserverPreL() {
-            super(new Handler());
-        }
-
-        @Override
-        public void onChange(boolean selfChange) {
-            refreshAlarm();
-        }
-    }
-
-    /**
-     * Update the display of the scheduled alarm as it changes.
-     */
-    private final class AlarmChangedBroadcastReceiver extends BroadcastReceiver {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            refreshAlarm();
-        }
-    }
-
-    /**
-     * Updates the vertical scroll state of this tab in the {@link UiDataModel} as the user scrolls
-     * the recyclerview or when the size/position of elements within the recyclerview changes.
-     */
-    private final class ScrollPositionWatcher extends RecyclerView.OnScrollListener
-            implements View.OnLayoutChangeListener {
-        @Override
-        public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
-            setTabScrolledToTop(Utils.isScrolledToTop(mCityList));
-        }
-
-        @Override
-        public void onLayoutChange(View v, int left, int top, int right, int bottom,
-                int oldLeft, int oldTop, int oldRight, int oldBottom) {
-            setTabScrolledToTop(Utils.isScrolledToTop(mCityList));
-        }
-    }
-
     /**
      * This adapter lists all of the selected world clocks. Optionally, it also includes a clock at
      * the top for the home timezone if "Automatic home clock" is turned on in settings and the
@@ -348,7 +247,7 @@ public final class ClockFragment extends DeskClockFragment {
         private final String mDateFormatForAccessibility;
 
         private SelectedCitiesAdapter(Context context, String dateFormat,
-                String dateFormatForAccessibility) {
+                                      String dateFormatForAccessibility) {
             mContext = context;
             mDateFormat = dateFormat;
             mDateFormatForAccessibility = dateFormatForAccessibility;
@@ -365,8 +264,9 @@ public final class ClockFragment extends DeskClockFragment {
             return WORLD_CLOCK;
         }
 
+        @NonNull
         @Override
-        public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+        public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
             final View view = mInflater.inflate(viewType, parent, false);
             switch (viewType) {
                 case WORLD_CLOCK:
@@ -379,7 +279,7 @@ public final class ClockFragment extends DeskClockFragment {
         }
 
         @Override
-        public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
+        public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int position) {
             final int viewType = getItemViewType(position);
             switch (viewType) {
                 case WORLD_CLOCK:
@@ -441,10 +341,10 @@ public final class ClockFragment extends DeskClockFragment {
             private CityViewHolder(View itemView) {
                 super(itemView);
 
-                mName = (TextView) itemView.findViewById(R.id.city_name);
-                mDigitalClock = (TextClock) itemView.findViewById(R.id.digital_clock);
-                mAnalogClock = (AnalogClock) itemView.findViewById(R.id.analog_clock);
-                mHoursAhead = (TextView) itemView.findViewById(R.id.hours_ahead);
+                mName = itemView.findViewById(R.id.city_name);
+                mDigitalClock = itemView.findViewById(R.id.digital_clock);
+                mAnalogClock = itemView.findViewById(R.id.analog_clock);
+                mHoursAhead = itemView.findViewById(R.id.hours_ahead);
             }
 
             private void bind(Context context, City city, int position, boolean isPortrait) {
@@ -528,13 +428,13 @@ public final class ClockFragment extends DeskClockFragment {
                 super(itemView);
 
                 mHairline = itemView.findViewById(R.id.hairline);
-                mDigitalClock = (TextClock) itemView.findViewById(R.id.digital_clock);
-                mAnalogClock = (AnalogClock) itemView.findViewById(R.id.analog_clock);
+                mDigitalClock = itemView.findViewById(R.id.digital_clock);
+                mAnalogClock = itemView.findViewById(R.id.analog_clock);
                 Utils.setClockIconTypeface(itemView);
             }
 
             private void bind(Context context, String dateFormat,
-                    String dateFormatForAccessibility, boolean showHairline) {
+                              String dateFormatForAccessibility, boolean showHairline) {
                 Utils.refreshAlarm(context, itemView);
 
                 Utils.updateDate(dateFormat, dateFormatForAccessibility, itemView);
@@ -545,4 +445,105 @@ public final class ClockFragment extends DeskClockFragment {
             }
         }
     }
+
+    /**
+     * Long pressing over the main clock starts the screen saver.
+     */
+    private final class StartScreenSaverListener implements View.OnLongClickListener {
+
+        @Override
+        public boolean onLongClick(View view) {
+            startActivity(new Intent(getActivity(), ScreensaverActivity.class)
+                    .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
+                    .putExtra(Events.EXTRA_EVENT_LABEL, R.string.label_deskclock));
+            return true;
+        }
+    }
+
+    /**
+     * Long pressing over the city list starts the screen saver.
+     */
+    private final class CityListOnLongClickListener extends GestureDetector.SimpleOnGestureListener
+            implements View.OnTouchListener {
+
+        private final GestureDetector mGestureDetector;
+
+        private CityListOnLongClickListener(Context context) {
+            mGestureDetector = new GestureDetector(context, this);
+        }
+
+        @Override
+        public void onLongPress(MotionEvent e) {
+            final View view = getView();
+            if (view != null) {
+                view.performLongClick();
+            }
+        }
+
+        @Override
+        public boolean onDown(MotionEvent e) {
+            return true;
+        }
+
+        @Override
+        public boolean onTouch(View v, MotionEvent event) {
+            return mGestureDetector.onTouchEvent(event);
+        }
+    }
+
+    /**
+     * This runnable executes at every quarter-hour (e.g. 1:00, 1:15, 1:30, 1:45, etc...) and
+     * updates the dates displayed within the UI. Quarter-hour increments were chosen to accommodate
+     * the "weirdest" timezones (e.g. Nepal is UTC/GMT +05:45).
+     */
+    private final class QuarterHourRunnable implements Runnable {
+        @Override
+        public void run() {
+            mCityAdapter.notifyDataSetChanged();
+        }
+    }
+
+    /**
+     * Prior to L, a ContentObserver was used to monitor changes to the next scheduled alarm.
+     * In L and beyond this is accomplished via a system broadcast of
+     * {@link AlarmManager#ACTION_NEXT_ALARM_CLOCK_CHANGED}.
+     */
+    private final class AlarmObserverPreL extends ContentObserver {
+        private AlarmObserverPreL() {
+            super(new Handler());
+        }
+
+        @Override
+        public void onChange(boolean selfChange) {
+            refreshAlarm();
+        }
+    }
+
+    /**
+     * Update the display of the scheduled alarm as it changes.
+     */
+    private final class AlarmChangedBroadcastReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            refreshAlarm();
+        }
+    }
+
+    /**
+     * Updates the vertical scroll state of this tab in the {@link UiDataModel} as the user scrolls
+     * the recyclerview or when the size/position of elements within the recyclerview changes.
+     */
+    private final class ScrollPositionWatcher extends RecyclerView.OnScrollListener
+            implements View.OnLayoutChangeListener {
+        @Override
+        public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) {
+            setTabScrolledToTop(Utils.isScrolledToTop(mCityList));
+        }
+
+        @Override
+        public void onLayoutChange(View v, int left, int top, int right, int bottom,
+                                   int oldLeft, int oldTop, int oldRight, int oldBottom) {
+            setTabScrolledToTop(Utils.isScrolledToTop(mCityList));
+        }
+    }
 }
diff --git a/src/com/android/deskclock/DeskClock.java b/app/src/main/java/com/best/deskclock/DeskClock.java
similarity index 82%
rename from src/com/android/deskclock/DeskClock.java
rename to app/src/main/java/com/best/deskclock/DeskClock.java
index 336e2c5e6..13e4f2d4a 100644
--- a/src/com/android/deskclock/DeskClock.java
+++ b/app/src/main/java/com/best/deskclock/DeskClock.java
@@ -17,20 +17,25 @@
 package com.best.deskclock;
 
 
+import static android.text.format.DateUtils.SECOND_IN_MILLIS;
+import static androidx.viewpager.widget.ViewPager.SCROLL_STATE_DRAGGING;
+import static androidx.viewpager.widget.ViewPager.SCROLL_STATE_IDLE;
+import static androidx.viewpager.widget.ViewPager.SCROLL_STATE_SETTLING;
+import static com.best.deskclock.AnimatorUtils.getScaleAnimator;
+
 import android.animation.Animator;
 import android.animation.AnimatorListenerAdapter;
 import android.animation.AnimatorSet;
 import android.animation.ValueAnimator;
+import android.annotation.SuppressLint;
 import android.app.Fragment;
 import android.content.Intent;
 import android.content.pm.PackageManager;
-import android.graphics.drawable.Drawable;
 import android.os.Bundle;
 import android.view.KeyEvent;
 import android.view.Menu;
 import android.view.MenuItem;
 import android.view.View;
-import android.view.View.OnClickListener;
 import android.widget.Button;
 import android.widget.ImageView;
 import android.widget.TextView;
@@ -48,97 +53,134 @@ import com.best.deskclock.actionbarmenu.OptionsMenuManager;
 import com.best.deskclock.actionbarmenu.SettingsMenuItemController;
 import com.best.deskclock.data.DataModel;
 import com.best.deskclock.data.DataModel.SilentSetting;
+import com.best.deskclock.data.DataModel.ThemeButtonBehavior;
 import com.best.deskclock.data.OnSilentSettingsListener;
 import com.best.deskclock.events.Events;
-import com.best.deskclock.LogUtils;
 import com.best.deskclock.provider.Alarm;
 import com.best.deskclock.uidata.TabListener;
 import com.best.deskclock.uidata.UiDataModel;
 import com.best.deskclock.widget.toast.SnackbarManager;
-
 import com.google.android.material.bottomnavigation.BottomNavigationView;
+import com.google.android.material.navigation.NavigationBarView;
 import com.google.android.material.snackbar.Snackbar;
 
-import static androidx.viewpager.widget.ViewPager.SCROLL_STATE_DRAGGING;
-import static androidx.viewpager.widget.ViewPager.SCROLL_STATE_IDLE;
-import static androidx.viewpager.widget.ViewPager.SCROLL_STATE_SETTLING;
-import static android.text.format.DateUtils.SECOND_IN_MILLIS;
-import static com.best.deskclock.AnimatorUtils.getScaleAnimator;
-
 /**
  * The main activity of the application which displays 4 different tabs contains alarms, world
  * clocks, timers and a stopwatch.
  */
 public class DeskClock extends BaseActivity
         implements FabContainer, LabelDialogFragment.AlarmLabelDialogHandler {
-
-    /** Models the interesting state of display the {@link #mFab} button may inhabit. */
-    private enum FabState { SHOWING, HIDE_ARMED, HIDING }
-
-    /** Coordinates handling of context menu items. */
+    private static final String PERMISSION_POWER_OFF_ALARM =
+            "org.codeaurora.permission.POWER_OFF_ALARM";
+    private static final int CODE_FOR_ALARM_PERMISSION = 1;
+    /**
+     * Coordinates handling of context menu items.
+     */
     private final OptionsMenuManager mOptionsMenuManager = new OptionsMenuManager();
-
-    /** Shrinks the {@link #mFab}, {@link #mLeftButton} and {@link #mRightButton} to nothing. */
+    /**
+     * Shrinks the {@link #mFab}, {@link #mLeftButton} and {@link #mRightButton} to nothing.
+     */
     private final AnimatorSet mHideAnimation = new AnimatorSet();
-
-    /** Grows the {@link #mFab}, {@link #mLeftButton} and {@link #mRightButton} to natural sizes. */
+    /**
+     * Grows the {@link #mFab}, {@link #mLeftButton} and {@link #mRightButton} to natural sizes.
+     */
     private final AnimatorSet mShowAnimation = new AnimatorSet();
-
-    /** Hides, updates, and shows only the {@link #mFab}; the buttons are untouched. */
+    /**
+     * Hides, updates, and shows only the {@link #mFab}; the buttons are untouched.
+     */
     private final AnimatorSet mUpdateFabOnlyAnimation = new AnimatorSet();
-
-    /** Hides, updates, and shows only the {@link #mLeftButton} and {@link #mRightButton}. */
+    /**
+     * Hides, updates, and shows only the {@link #mLeftButton} and {@link #mRightButton}.
+     */
     private final AnimatorSet mUpdateButtonsOnlyAnimation = new AnimatorSet();
-    
-    /** Automatically starts the {@link #mShowAnimation} after {@link #mHideAnimation} ends. */
+    /**
+     * Automatically starts the {@link #mShowAnimation} after {@link #mHideAnimation} ends.
+     */
     private final AnimatorListenerAdapter mAutoStartShowListener = new AutoStartShowListener();
-
-    /** Updates the user interface to reflect the selected tab from the backing model. */
+    /**
+     * Updates the user interface to reflect the selected tab from the backing model.
+     */
     private final TabListener mTabChangeWatcher = new TabChangeWatcher();
-
-    /** Shows/hides a snackbar explaining which setting is suppressing alarms from firing. */
+    /**
+     * Shows/hides a snackbar explaining which setting is suppressing alarms from firing.
+     */
     private final OnSilentSettingsListener mSilentSettingChangeWatcher =
             new SilentSettingChangeWatcher();
+    @SuppressLint("NonConstantResourceId")
+    private final NavigationBarView.OnItemSelectedListener mNavigationListener
+            = item -> {
+        UiDataModel.Tab tab = null;
+        switch (item.getItemId()) {
+            case R.id.page_alarm:
+                tab = UiDataModel.Tab.ALARMS;
+                break;
 
-    /** Displays a snackbar explaining why alarms may not fire or may fire silently. */
-    private Runnable mShowSilentSettingSnackbarRunnable;
+            case R.id.page_clock:
+                tab = UiDataModel.Tab.CLOCKS;
+                break;
 
-    /** The view to which snackbar items are anchored. */
-    private View mSnackbarAnchor;
+            case R.id.page_timer:
+                tab = UiDataModel.Tab.TIMERS;
+                break;
 
-    /** The current display state of the {@link #mFab}. */
-    private FabState mFabState = FabState.SHOWING;
+            case R.id.page_stopwatch:
+                tab = UiDataModel.Tab.STOPWATCH;
+                break;
+        }
 
-    /** The single floating-action button shared across all tabs in the user interface. */
-    private ImageView mFab;
+        if (tab != null) {
+            UiDataModel.getUiDataModel().setSelectedTab(tab);
+            return true;
+        }
 
-    /** The button left of the {@link #mFab} shared across all tabs in the user interface. */
+        return false;
+    };
+    private ThemeButtonBehavior mThemeBehavior;
+    /**
+     * Displays a snackbar explaining why alarms may not fire or may fire silently.
+     */
+    private Runnable mShowSilentSettingSnackbarRunnable;
+    /**
+     * The view to which snackbar items are anchored.
+     */
+    private View mSnackbarAnchor;
+    /**
+     * The current display state of the {@link #mFab}.
+     */
+    private FabState mFabState = FabState.SHOWING;
+    /**
+     * The single floating-action button shared across all tabs in the user interface.
+     */
+    private ImageView mFab;
+    /**
+     * The button left of the {@link #mFab} shared across all tabs in the user interface.
+     */
     private Button mLeftButton;
-
-    /** The button right of the {@link #mFab} shared across all tabs in the user interface. */
+    /**
+     * The button right of the {@link #mFab} shared across all tabs in the user interface.
+     */
     private Button mRightButton;
-
-    /** The ViewPager that pages through the fragments representing the content of the tabs. */
+    /**
+     * The ViewPager that pages through the fragments representing the content of the tabs.
+     */
     private ViewPager mFragmentTabPager;
-
-    /** Generates the fragments that are displayed by the {@link #mFragmentTabPager}. */
+    /**
+     * Generates the fragments that are displayed by the {@link #mFragmentTabPager}.
+     */
     private FragmentTabPagerAdapter mFragmentTabPagerAdapter;
-
-     /** The view that displays the current tab's title */
+    /**
+     * The view that displays the current tab's title
+     */
     private TextView mTitleView;
-
-    /** The bottom navigation bar */
+    /**
+     * The bottom navigation bar
+     */
     private BottomNavigationView mBottomNavigation;
-
-
-    /** {@code true} when a settings change necessitates recreating this activity. */
+    /**
+     * {@code true} when a settings change necessitates recreating this activity.
+     */
     private boolean mRecreateActivity;
 
-    private static final String PERMISSION_POWER_OFF_ALARM =
-            "org.codeaurora.permission.POWER_OFF_ALARM";
-
-    private static final int CODE_FOR_ALARM_PERMISSION = 1;
-    
     @Override
     public void onNewIntent(Intent newIntent) {
         super.onNewIntent(newIntent);
@@ -149,15 +191,25 @@ public class DeskClock extends BaseActivity
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
+
+        mThemeBehavior = DataModel.getDataModel().getThemeButtonBehavior();
+        if (mThemeBehavior == DataModel.ThemeButtonBehavior.DARK) {
+            getTheme().applyStyle(R.style.Theme_DeskClock_Dark, true);
+        }
+        if (mThemeBehavior == DataModel.ThemeButtonBehavior.LIGHT) {
+            getTheme().applyStyle(R.style.Theme_DeskClock_Light, true);
+        }
+
         super.onCreate(savedInstanceState);
 
+
         setContentView(R.layout.desk_clock);
         mSnackbarAnchor = findViewById(R.id.content);
 
         checkPermissions();
 
         // Configure the toolbar.
-        final Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
+        final Toolbar toolbar = findViewById(R.id.toolbar);
         setSupportActionBar(toolbar);
 
         final ActionBar actionBar = getSupportActionBar();
@@ -176,28 +228,13 @@ public class DeskClock extends BaseActivity
         onCreateOptionsMenu(toolbar.getMenu());
 
         // Configure the buttons shared by the tabs.
-        mFab = (ImageView) findViewById(R.id.fab);
-        mLeftButton = (Button) findViewById(R.id.left_button);
-        mRightButton = (Button) findViewById(R.id.right_button);
+        mFab = findViewById(R.id.fab);
+        mLeftButton = findViewById(R.id.left_button);
+        mRightButton = findViewById(R.id.right_button);
 
-        mFab.setOnClickListener(new OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                getSelectedDeskClockFragment().onFabClick(mFab);
-            }
-        });
-        mLeftButton.setOnClickListener(new OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                getSelectedDeskClockFragment().onLeftButtonClick(mLeftButton);
-            }
-        });
-        mRightButton.setOnClickListener(new OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                getSelectedDeskClockFragment().onRightButtonClick(mRightButton);
-            }
-        });
+        mFab.setOnClickListener(view -> getSelectedDeskClockFragment().onFabClick(mFab));
+        mLeftButton.setOnClickListener(view -> getSelectedDeskClockFragment().onLeftButtonClick(mLeftButton));
+        mRightButton.setOnClickListener(view -> getSelectedDeskClockFragment().onRightButtonClick(mRightButton));
 
         final long duration = UiDataModel.getUiDataModel().getShortAnimationDuration();
 
@@ -253,7 +290,7 @@ public class DeskClock extends BaseActivity
 
         // Customize the view pager.
         mFragmentTabPagerAdapter = new FragmentTabPagerAdapter(this);
-        mFragmentTabPager = (ViewPager) findViewById(R.id.desk_clock_pager);
+        mFragmentTabPager = findViewById(R.id.desk_clock_pager);
         // Keep all four tabs to minimize jank.
         mFragmentTabPager.setOffscreenPageLimit(3);
         // Set Accessibility Delegate to null so view pager doesn't intercept movements and
@@ -262,10 +299,10 @@ public class DeskClock extends BaseActivity
         // Mirror changes made to the selected page of the view pager into UiDataModel.
         mFragmentTabPager.addOnPageChangeListener(new PageChangeWatcher());
         mFragmentTabPager.setAdapter(mFragmentTabPagerAdapter);
-        
+
         // Mirror changes made to the selected tab into UiDataModel.
         mBottomNavigation = findViewById(R.id.bottom_view);
-        mBottomNavigation.setOnNavigationItemSelectedListener(mNavigationListener);
+        mBottomNavigation.setOnItemSelectedListener(mNavigationListener);
 
         // Honor changes to the selected tab from outside entities.
         UiDataModel.getUiDataModel().addTabListener(mTabChangeWatcher);
@@ -273,45 +310,12 @@ public class DeskClock extends BaseActivity
         mTitleView = findViewById(R.id.title_view);
     }
 
-    private BottomNavigationView.OnNavigationItemSelectedListener mNavigationListener
-            = new BottomNavigationView.OnNavigationItemSelectedListener() {
-
-        @Override
-        public boolean onNavigationItemSelected(@NonNull MenuItem item) {
-            UiDataModel.Tab tab = null;
-            switch (item.getItemId()) {
-                case R.id.page_alarm:
-                    tab = UiDataModel.Tab.ALARMS;
-                    break;
-
-                case R.id.page_clock:
-                    tab = UiDataModel.Tab.CLOCKS;
-                    break;
-
-                case R.id.page_timer:
-                    tab = UiDataModel.Tab.TIMERS;
-                    break;
-
-                case R.id.page_stopwatch:
-                    tab = UiDataModel.Tab.STOPWATCH;
-                    break;
-            }
-
-           if (tab != null) {
-                UiDataModel.getUiDataModel().setSelectedTab(tab);
-                return true;
-            }
-
-            return false;
-        }
-    };
-
     @Override
     protected void onStart() {
         DataModel.getDataModel().addSilentSettingsListener(mSilentSettingChangeWatcher);
         DataModel.getDataModel().setApplicationInForeground(true);
 
-      
+
         super.onStart();
     }
 
@@ -327,17 +331,12 @@ public class DeskClock extends BaseActivity
     protected void onPostResume() {
         super.onPostResume();
 
-       if (mRecreateActivity) {
+        if (mRecreateActivity) {
             mRecreateActivity = false;
 
             // A runnable must be posted here or the new DeskClock activity will be recreated in a
             // paused state, even though it is the foreground activity.
-            mFragmentTabPager.post(new Runnable() {
-                @Override
-                public void run() {
-                    recreate();
-                }
-            });
+            mFragmentTabPager.post(this::recreate);
         }
     }
 
@@ -392,7 +391,7 @@ public class DeskClock extends BaseActivity
      */
     @Override
     public boolean onKeyDown(int keyCode, KeyEvent event) {
-        return getSelectedDeskClockFragment().onKeyDown(keyCode,event)
+        return getSelectedDeskClockFragment().onKeyDown(keyCode, event)
                 || super.onKeyDown(keyCode, event);
     }
 
@@ -411,10 +410,8 @@ public class DeskClock extends BaseActivity
                 f.onMorphFab(mFab);
                 break;
         }
-        switch (updateType & FAB_REQUEST_FOCUS_MASK) {
-            case FAB_REQUEST_FOCUS:
-                mFab.requestFocus();
-                break;
+        if ((updateType & FAB_REQUEST_FOCUS_MASK) == FAB_REQUEST_FOCUS) {
+            mFab.requestFocus();
         }
         switch (updateType & BUTTONS_ANIMATION_MASK) {
             case BUTTONS_IMMEDIATE:
@@ -424,11 +421,9 @@ public class DeskClock extends BaseActivity
                 mUpdateButtonsOnlyAnimation.start();
                 break;
         }
-        switch (updateType & BUTTONS_DISABLE_MASK) {
-            case BUTTONS_DISABLE:
-                mLeftButton.setClickable(false);
-                mRightButton.setClickable(false);
-                break;
+        if ((updateType & BUTTONS_DISABLE_MASK) == BUTTONS_DISABLE) {
+            mLeftButton.setClickable(false);
+            mRightButton.setClickable(false);
         }
         switch (updateType & FAB_AND_BUTTONS_SHRINK_EXPAND_MASK) {
             case FAB_AND_BUTTONS_SHRINK:
@@ -443,6 +438,7 @@ public class DeskClock extends BaseActivity
     @Override
     protected void onActivityResult(int requestCode, int resultCode, Intent data) {
         // Recreate the activity if any settings have been changed
+        super.onActivityResult(requestCode, resultCode, data);
         if (requestCode == SettingsMenuItemController.REQUEST_CHANGE_SETTINGS
                 && resultCode == RESULT_OK) {
             mRecreateActivity = true;
@@ -458,8 +454,9 @@ public class DeskClock extends BaseActivity
 
     @Override
     public void onRequestPermissionsResult(int requestCode,
-                                           String permissions[], int[] grantResults) {
-        if (requestCode == CODE_FOR_ALARM_PERMISSION){
+                                           @NonNull String[] permissions, @NonNull int[] grantResults) {
+        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
+        if (requestCode == CODE_FOR_ALARM_PERMISSION) {
             LogUtils.i("Power off alarm permission is granted.");
         }
     }
@@ -468,12 +465,13 @@ public class DeskClock extends BaseActivity
      * Configure the {@link #mFragmentTabPager} and {@link #mBottomNavigation} to display
      * UiDataModel's selected tab.
      */
+    @SuppressLint("ResourceType")
     private void updateCurrentTab() {
         // Fetch the selected tab from the source of truth: UiDataModel.
         final UiDataModel.Tab selectedTab = UiDataModel.getUiDataModel().getSelectedTab();
         // Update the selected tab in the mBottomNavigation if it does not agree with UiDataModel.
         mBottomNavigation.setSelectedItemId(selectedTab.getPageResId());
-        
+
         // Update the selected fragment in the viewpager if it does not agree with UiDataModel.
         for (int i = 0; i < mFragmentTabPagerAdapter.getCount(); i++) {
             final DeskClockFragment fragment = mFragmentTabPagerAdapter.getDeskClockFragment(i);
@@ -482,8 +480,8 @@ public class DeskClock extends BaseActivity
                 break;
             }
         }
-        
-         mTitleView.setText(selectedTab.getLabelResId());
+
+        mTitleView.setText(selectedTab.getLabelResId());
     }
 
     /**
@@ -507,12 +505,19 @@ public class DeskClock extends BaseActivity
         return Snackbar.make(mSnackbarAnchor, messageId, 5000 /* duration */);
     }
 
+    /**
+     * Models the interesting state of display the {@link #mFab} button may inhabit.
+     */
+    private enum FabState {SHOWING, HIDE_ARMED, HIDING}
+
     /**
      * As the view pager changes the selected page, update the model to record the new selected tab.
      */
     private final class PageChangeWatcher implements OnPageChangeListener {
 
-        /** The last reported page scroll state; used to detect exotic state changes. */
+        /**
+         * The last reported page scroll state; used to detect exotic state changes.
+         */
         private int mPriorState = SCROLL_STATE_IDLE;
 
         public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
@@ -640,13 +645,14 @@ public class DeskClock extends BaseActivity
         }
     }
 
+
     /**
      * As the model reports changes to the selected tab, update the user interface.
      */
     private final class TabChangeWatcher implements TabListener {
         @Override
         public void selectedTabChanged(UiDataModel.Tab oldSelectedTab,
-                UiDataModel.Tab newSelectedTab) {
+                                       UiDataModel.Tab newSelectedTab) {
             // Update the view pager and tab layout to agree with the model.
             updateCurrentTab();
 
diff --git a/src/com/android/deskclock/DeskClockApplication.java b/app/src/main/java/com/best/deskclock/DeskClockApplication.java
similarity index 100%
rename from src/com/android/deskclock/DeskClockApplication.java
rename to app/src/main/java/com/best/deskclock/DeskClockApplication.java
index cba2d838d..79a510b9f 100644
--- a/src/com/android/deskclock/DeskClockApplication.java
+++ b/app/src/main/java/com/best/deskclock/DeskClockApplication.java
@@ -30,19 +30,6 @@ import com.best.deskclock.uidata.UiDataModel;
 
 public class DeskClockApplication extends Application {
 
-    @Override
-    public void onCreate() {
-        super.onCreate();
-
-        final Context applicationContext = getApplicationContext();
-        final SharedPreferences prefs = getDefaultSharedPreferences(applicationContext);
-
-        DataModel.getDataModel().init(applicationContext, prefs);
-        UiDataModel.getUiDataModel().init(applicationContext, prefs);
-        Controller.getController().setContext(applicationContext);
-        Controller.getController().addEventTracker(new LogEventTracker(applicationContext));
-    }
-
     /**
      * Returns the default {@link SharedPreferences} instance from the underlying storage context.
      */
@@ -62,4 +49,17 @@ public class DeskClockApplication extends Application {
         }
         return PreferenceManager.getDefaultSharedPreferences(storageContext);
     }
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+
+        final Context applicationContext = getApplicationContext();
+        final SharedPreferences prefs = getDefaultSharedPreferences(applicationContext);
+
+        DataModel.getDataModel().init(applicationContext, prefs);
+        UiDataModel.getUiDataModel().init(applicationContext, prefs);
+        Controller.getController().setContext(applicationContext);
+        Controller.getController().addEventTracker(new LogEventTracker(applicationContext));
+    }
 }
diff --git a/src/com/android/deskclock/DeskClockBackupAgent.java b/app/src/main/java/com/best/deskclock/DeskClockBackupAgent.java
similarity index 92%
rename from src/com/android/deskclock/DeskClockBackupAgent.java
rename to app/src/main/java/com/best/deskclock/DeskClockBackupAgent.java
index da21e8944..1fe62ba2f 100644
--- a/src/com/android/deskclock/DeskClockBackupAgent.java
+++ b/app/src/main/java/com/best/deskclock/DeskClockBackupAgent.java
@@ -26,6 +26,7 @@ import android.content.Context;
 import android.content.Intent;
 import android.os.ParcelFileDescriptor;
 import android.os.SystemClock;
+
 import androidx.annotation.NonNull;
 
 import com.best.deskclock.alarms.AlarmStateManager;
@@ -40,22 +41,65 @@ import java.util.List;
 
 public class DeskClockBackupAgent extends BackupAgent {
 
-    private static final LogUtils.Logger LOGGER = new LogUtils.Logger("DeskClockBackupAgent");
-
     public static final String ACTION_COMPLETE_RESTORE =
             "com.best.deskclock.action.COMPLETE_RESTORE";
+    private static final LogUtils.Logger LOGGER = new LogUtils.Logger("DeskClockBackupAgent");
+
+    /**
+     * @param context a context to access resources and services
+     * @return {@code true} if restore data was processed; {@code false} otherwise.
+     */
+    public static boolean processRestoredData(Context context) {
+        // If data was not recently restored, there is nothing to do.
+        if (!DataModel.getDataModel().isRestoreBackupFinished()) {
+            return false;
+        }
+
+        LOGGER.i("processRestoredData() started");
+
+        // Now that alarms have been restored, schedule new instances in AlarmManager.
+        final ContentResolver contentResolver = context.getContentResolver();
+        final List<Alarm> alarms = Alarm.getAlarms(contentResolver, null);
+
+        final Calendar now = Calendar.getInstance();
+        for (Alarm alarm : alarms) {
+            // Remove any instances that may currently exist for the alarm;
+            // these aren't relevant on the restore device and we'll recreate them below.
+            AlarmStateManager.deleteAllInstances(context, alarm.id);
+
+            if (alarm.enabled) {
+                // Create the next alarm instance to schedule.
+                AlarmInstance alarmInstance = alarm.createInstanceAfter(now);
+
+                // Add the next alarm instance to the database.
+                AlarmInstance.addInstance(contentResolver, alarmInstance);
+
+                // Schedule the next alarm instance in AlarmManager.
+                AlarmStateManager.registerInstance(context, alarmInstance, true);
+                LOGGER.i("DeskClockBackupAgent scheduled alarm instance: %s", alarmInstance);
+            }
+        }
+
+        // Remove the preference to avoid executing this logic multiple times.
+        DataModel.getDataModel().setRestoreBackupFinished(false);
+
+        LOGGER.i("processRestoredData() completed");
+        return true;
+    }
 
     @Override
     public void onBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
-            ParcelFileDescriptor newState) throws IOException { }
+                         ParcelFileDescriptor newState) throws IOException {
+    }
 
     @Override
     public void onRestore(BackupDataInput data, int appVersionCode,
-            ParcelFileDescriptor newState) throws IOException { }
+                          ParcelFileDescriptor newState) throws IOException {
+    }
 
     @Override
     public void onRestoreFile(@NonNull ParcelFileDescriptor data, long size, File destination,
-            int type, long mode, long mtime) throws IOException {
+                              int type, long mode, long mtime) throws IOException {
         // The preference file on the backup device may not be the same on the restore device.
         // Massage the file name here before writing it.
         if (destination.getName().endsWith("_preferences.xml")) {
@@ -79,10 +123,8 @@ public class DeskClockBackupAgent extends BackupAgent {
      */
     @Override
     public void onRestoreFinished() {
-        if (Utils.isNOrLater()) {
-            // TODO: migrate restored database and preferences over into
-            // the device-encrypted storage area
-        }
+        // TODO: migrate restored database and preferences over into
+        // the device-encrypted storage area
 
         // Indicate a data restore has been completed.
         DataModel.getDataModel().setRestoreBackupFinished(true);
@@ -101,46 +143,4 @@ public class DeskClockBackupAgent extends BackupAgent {
 
         LOGGER.i("Waiting for %s to complete the data restore", ACTION_COMPLETE_RESTORE);
     }
-
-    /**
-     * @param context a context to access resources and services
-     * @return {@code true} if restore data was processed; {@code false} otherwise.
-     */
-    public static boolean processRestoredData(Context context) {
-        // If data was not recently restored, there is nothing to do.
-        if (!DataModel.getDataModel().isRestoreBackupFinished()) {
-            return false;
-        }
-
-        LOGGER.i("processRestoredData() started");
-
-        // Now that alarms have been restored, schedule new instances in AlarmManager.
-        final ContentResolver contentResolver = context.getContentResolver();
-        final List<Alarm> alarms = Alarm.getAlarms(contentResolver, null);
-
-        final Calendar now = Calendar.getInstance();
-        for (Alarm alarm : alarms) {
-            // Remove any instances that may currently exist for the alarm;
-            // these aren't relevant on the restore device and we'll recreate them below.
-            AlarmStateManager.deleteAllInstances(context, alarm.id);
-
-            if (alarm.enabled) {
-                // Create the next alarm instance to schedule.
-                AlarmInstance alarmInstance = alarm.createInstanceAfter(now);
-
-                // Add the next alarm instance to the database.
-                alarmInstance = AlarmInstance.addInstance(contentResolver, alarmInstance);
-
-                // Schedule the next alarm instance in AlarmManager.
-                AlarmStateManager.registerInstance(context, alarmInstance, true);
-                LOGGER.i("DeskClockBackupAgent scheduled alarm instance: %s", alarmInstance);
-            }
-        }
-
-        // Remove the preference to avoid executing this logic multiple times.
-        DataModel.getDataModel().setRestoreBackupFinished(false);
-
-        LOGGER.i("processRestoredData() completed");
-        return true;
-    }
 }
diff --git a/src/com/android/deskclock/DeskClockFragment.java b/app/src/main/java/com/best/deskclock/DeskClockFragment.java
similarity index 95%
rename from src/com/android/deskclock/DeskClockFragment.java
rename to app/src/main/java/com/best/deskclock/DeskClockFragment.java
index 9724b7f73..8602ab5bd 100644
--- a/src/com/android/deskclock/DeskClockFragment.java
+++ b/app/src/main/java/com/best/deskclock/DeskClockFragment.java
@@ -17,22 +17,26 @@
 package com.best.deskclock;
 
 import android.app.Fragment;
-import androidx.annotation.ColorInt;
-import androidx.annotation.NonNull;
 import android.view.KeyEvent;
 import android.widget.Button;
 import android.widget.ImageView;
 
+import androidx.annotation.ColorInt;
+import androidx.annotation.NonNull;
 
 import com.best.deskclock.uidata.UiDataModel;
 import com.best.deskclock.uidata.UiDataModel.Tab;
 
 public abstract class DeskClockFragment extends Fragment implements FabContainer, FabController {
 
-    /** The tab associated with this fragment. */
+    /**
+     * The tab associated with this fragment.
+     */
     private final Tab mTab;
 
-    /** The container that houses the fab and its left and right buttons. */
+    /**
+     * The container that houses the fab and its left and right buttons.
+     */
     private FabContainer mFabContainer;
 
     public DeskClockFragment(Tab tab) {
diff --git a/src/com/android/deskclock/DropShadowController.java b/app/src/main/java/com/best/deskclock/DropShadowController.java
similarity index 84%
rename from src/com/android/deskclock/DropShadowController.java
rename to app/src/main/java/com/best/deskclock/DropShadowController.java
index 72ba4d4c4..f4cc87623 100644
--- a/src/com/android/deskclock/DropShadowController.java
+++ b/app/src/main/java/com/best/deskclock/DropShadowController.java
@@ -16,19 +16,21 @@
 
 package com.best.deskclock;
 
+import static com.best.deskclock.AnimatorUtils.getAlphaAnimator;
+
 import android.animation.ValueAnimator;
-import androidx.recyclerview.widget.RecyclerView;
 import android.view.View;
 import android.widget.AbsListView;
 import android.widget.ListView;
 
+import androidx.annotation.NonNull;
+import androidx.recyclerview.widget.RecyclerView;
+
 import com.best.deskclock.data.DataModel;
 import com.best.deskclock.uidata.TabScrollListener;
 import com.best.deskclock.uidata.UiDataModel;
 import com.best.deskclock.uidata.UiDataModel.Tab;
 
-import static com.best.deskclock.AnimatorUtils.getAlphaAnimator;
-
 /**
  * This controller encapsulates the logic that watches a model for changes to scroll state and
  * updates the display state of an associated drop shadow. The observable model may take many forms
@@ -39,16 +41,24 @@ import static com.best.deskclock.AnimatorUtils.getAlphaAnimator;
  */
 public final class DropShadowController {
 
-    /** Updates {@link #mDropShadowView} in response to changes in the backing scroll model. */
+    /**
+     * Updates {@link #mDropShadowView} in response to changes in the backing scroll model.
+     */
     private final ScrollChangeWatcher mScrollChangeWatcher = new ScrollChangeWatcher();
 
-    /** Fades the {@link @mDropShadowView} in/out as scroll state changes. */
+    /**
+     * Fades the {@link @mDropShadowView} in/out as scroll state changes.
+     */
     private final ValueAnimator mDropShadowAnimator;
 
-    /** The component that displays a drop shadow. */
+    /**
+     * The component that displays a drop shadow.
+     */
     private final View mDropShadowView;
 
-    /** Tab bar's hairline, which is hidden whenever the drop shadow is displayed. */
+    /**
+     * Tab bar's hairline, which is hidden whenever the drop shadow is displayed.
+     */
     private View mHairlineView;
 
     // Supported sources of scroll position include: ListView, RecyclerView and UiDataModel.
@@ -58,9 +68,9 @@ public final class DropShadowController {
 
     /**
      * @param dropShadowView to be hidden/shown as {@code uiDataModel} reports scrolling changes
-     * @param uiDataModel models the vertical scrolling state of the application's selected tab
-     * @param hairlineView at the bottom of the tab bar to be hidden or shown when the drop shadow
-     *                     is displayed or hidden, respectively.
+     * @param uiDataModel    models the vertical scrolling state of the application's selected tab
+     * @param hairlineView   at the bottom of the tab bar to be hidden or shown when the drop shadow
+     *                       is displayed or hidden, respectively.
      */
     public DropShadowController(View dropShadowView, UiDataModel uiDataModel, View hairlineView) {
         this(dropShadowView);
@@ -72,7 +82,7 @@ public final class DropShadowController {
 
     /**
      * @param dropShadowView to be hidden/shown as {@code listView} reports scrolling changes
-     * @param listView a scrollable view that dictates the visibility of {@code dropShadowView}
+     * @param listView       a scrollable view that dictates the visibility of {@code dropShadowView}
      */
     public DropShadowController(View dropShadowView, ListView listView) {
         this(dropShadowView);
@@ -83,7 +93,7 @@ public final class DropShadowController {
 
     /**
      * @param dropShadowView to be hidden/shown as {@code recyclerView} reports scrolling changes
-     * @param recyclerView a scrollable view that dictates the visibility of {@code dropShadowView}
+     * @param recyclerView   a scrollable view that dictates the visibility of {@code dropShadowView}
      */
     public DropShadowController(View dropShadowView, RecyclerView recyclerView) {
         this(dropShadowView);
@@ -114,7 +124,7 @@ public final class DropShadowController {
 
     /**
      * @param shouldShowDropShadow {@code true} indicates the drop shadow should be displayed;
-     *      {@code false} indicates the drop shadow should be hidden
+     *                             {@code false} indicates the drop shadow should be hidden
      */
     private void updateDropShadow(boolean shouldShowDropShadow) {
         if (!shouldShowDropShadow && mDropShadowView.getAlpha() != 0f) {
@@ -148,17 +158,18 @@ public final class DropShadowController {
 
         // RecyclerView scrolled.
         @Override
-        public void onScrolled(RecyclerView view, int dx, int dy) {
+        public void onScrolled(@NonNull RecyclerView view, int dx, int dy) {
             updateDropShadow(!Utils.isScrolledToTop(view));
         }
 
         // ListView scrolled.
         @Override
-        public void onScrollStateChanged(AbsListView view, int scrollState) {}
+        public void onScrollStateChanged(AbsListView view, int scrollState) {
+        }
 
         @Override
         public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount,
-                int totalItemCount) {
+                             int totalItemCount) {
             updateDropShadow(!Utils.isScrolledToTop(view));
         }
 
diff --git a/src/com/android/deskclock/FabContainer.java b/app/src/main/java/com/best/deskclock/FabContainer.java
similarity index 61%
rename from src/com/android/deskclock/FabContainer.java
rename to app/src/main/java/com/best/deskclock/FabContainer.java
index e8946fa36..0cd651db1 100644
--- a/src/com/android/deskclock/FabContainer.java
+++ b/app/src/main/java/com/best/deskclock/FabContainer.java
@@ -11,52 +11,73 @@ public interface FabContainer {
 
     /** Bit field for updates */
 
-    /** Bit 0-1 */
+    /**
+     * Bit 0-1
+     */
     int FAB_ANIMATION_MASK = 0b11;
-    /** Signals that the fab should be updated in place with no animation. */
+    /**
+     * Signals that the fab should be updated in place with no animation.
+     */
     int FAB_IMMEDIATE = 0b1;
-    /** Signals the fab should be "animated away", updated, and "animated back". */
+    /**
+     * Signals the fab should be "animated away", updated, and "animated back".
+     */
     int FAB_SHRINK_AND_EXPAND = 0b10;
-    /** Signals that the fab should morph into a new state in place. */
+    /**
+     * Signals that the fab should morph into a new state in place.
+     */
     int FAB_MORPH = 0b11;
 
-    /** Bit 2 */
+    /**
+     * Bit 2
+     */
     int FAB_REQUEST_FOCUS_MASK = 0b100;
-    /** Signals that the fab should request focus. */
+    /**
+     * Signals that the fab should request focus.
+     */
     int FAB_REQUEST_FOCUS = 0b100;
 
-    /** Bit 3-4 */
+    /**
+     * Bit 3-4
+     */
     int BUTTONS_ANIMATION_MASK = 0b11000;
-    /** Signals that the buttons should be updated in place with no animation. */
+    /**
+     * Signals that the buttons should be updated in place with no animation.
+     */
     int BUTTONS_IMMEDIATE = 0b1000;
-    /** Signals that the buttons should be "animated away", updated, and "animated back". */
+    /**
+     * Signals that the buttons should be "animated away", updated, and "animated back".
+     */
     int BUTTONS_SHRINK_AND_EXPAND = 0b10000;
 
-    /** Bit 5 */
+    /**
+     * Bit 5
+     */
     int BUTTONS_DISABLE_MASK = 0b100000;
-    /** Disable the buttons of the fab so they do not respond to clicks. */
+    /**
+     * Disable the buttons of the fab so they do not respond to clicks.
+     */
     int BUTTONS_DISABLE = 0b100000;
 
-    /** Bit 6-7 */
+    /**
+     * Bit 6-7
+     */
     int FAB_AND_BUTTONS_SHRINK_EXPAND_MASK = 0b11000000;
-    /** Signals the fab and buttons should be "animated away". */
+    /**
+     * Signals the fab and buttons should be "animated away".
+     */
     int FAB_AND_BUTTONS_SHRINK = 0b10000000;
-    /** Signals the fab and buttons should be "animated back". */
+    /**
+     * Signals the fab and buttons should be "animated back".
+     */
     int FAB_AND_BUTTONS_EXPAND = 0b01000000;
 
-    /** Convenience flags */
+    /**
+     * Convenience flags
+     */
     int FAB_AND_BUTTONS_IMMEDIATE = FAB_IMMEDIATE | BUTTONS_IMMEDIATE;
     int FAB_AND_BUTTONS_SHRINK_AND_EXPAND = FAB_SHRINK_AND_EXPAND | BUTTONS_SHRINK_AND_EXPAND;
 
-    @IntDef(
-            flag = true,
-            value = { FAB_IMMEDIATE, FAB_SHRINK_AND_EXPAND, FAB_MORPH, FAB_REQUEST_FOCUS,
-                    BUTTONS_IMMEDIATE, BUTTONS_SHRINK_AND_EXPAND, BUTTONS_DISABLE,
-                    FAB_AND_BUTTONS_IMMEDIATE, FAB_AND_BUTTONS_SHRINK_AND_EXPAND,
-                    FAB_AND_BUTTONS_SHRINK, FAB_AND_BUTTONS_EXPAND }
-    )
-    @interface UpdateFabFlag {}
-
     /**
      * Requests that this container update the fab and/or its buttons because their state has
      * changed. The update may be immediate or it may be animated depending on the choice of
@@ -65,4 +86,14 @@ public interface FabContainer {
      * @param updateTypes indicates the types of update to apply to the fab and its buttons
      */
     void updateFab(@UpdateFabFlag int updateTypes);
+
+    @IntDef(
+            flag = true,
+            value = {FAB_IMMEDIATE, FAB_SHRINK_AND_EXPAND, FAB_MORPH, FAB_REQUEST_FOCUS,
+                    BUTTONS_IMMEDIATE, BUTTONS_SHRINK_AND_EXPAND, BUTTONS_DISABLE,
+                    FAB_AND_BUTTONS_IMMEDIATE, FAB_AND_BUTTONS_SHRINK_AND_EXPAND,
+                    FAB_AND_BUTTONS_SHRINK, FAB_AND_BUTTONS_EXPAND}
+    )
+    @interface UpdateFabFlag {
+    }
 }
diff --git a/src/com/android/deskclock/FabController.java b/app/src/main/java/com/best/deskclock/FabController.java
similarity index 95%
rename from src/com/android/deskclock/FabController.java
rename to app/src/main/java/com/best/deskclock/FabController.java
index b03c8538e..f32afc4d6 100644
--- a/src/com/android/deskclock/FabController.java
+++ b/app/src/main/java/com/best/deskclock/FabController.java
@@ -1,10 +1,11 @@
 package com.best.deskclock;
 
-import androidx.annotation.NonNull;
 import android.view.View;
 import android.widget.Button;
 import android.widget.ImageView;
 
+import androidx.annotation.NonNull;
+
 /**
  * Implementers of this interface are able to {@link #onUpdateFab configure the fab} and associated
  * {@link #onUpdateFabButtons left/right buttons} including setting them {@link View#INVISIBLE} if
@@ -32,7 +33,7 @@ public interface FabController {
      * Configures the display of the buttons to the left and right of the fab to match the current
      * state of this controller.
      *
-     * @param left button to the left of the fab to configure based on current state
+     * @param left  button to the left of the fab to configure based on current state
      * @param right button to the right of the fab to configure based on current state
      */
     void onUpdateFabButtons(@NonNull Button left, @NonNull Button right);
diff --git a/src/com/android/deskclock/FetchMatchingAlarmsAction.java b/app/src/main/java/com/best/deskclock/FetchMatchingAlarmsAction.java
similarity index 98%
rename from src/com/android/deskclock/FetchMatchingAlarmsAction.java
rename to app/src/main/java/com/best/deskclock/FetchMatchingAlarmsAction.java
index 4ec2cbab4..5a2e722ce 100644
--- a/src/com/android/deskclock/FetchMatchingAlarmsAction.java
+++ b/app/src/main/java/com/best/deskclock/FetchMatchingAlarmsAction.java
@@ -20,7 +20,6 @@ import android.app.Activity;
 import android.content.ContentResolver;
 import android.content.Context;
 import android.content.Intent;
-import android.os.Looper;
 import android.provider.AlarmClock;
 
 import com.best.deskclock.alarms.AlarmStateManager;
@@ -163,7 +162,7 @@ class FetchMatchingAlarmsAction implements Runnable {
         // if we want to dismiss we should only add enabled alarms
         final String selection = String.format("%s=? AND %s=? AND %s=?",
                 Alarm.HOUR, Alarm.MINUTES, Alarm.ENABLED);
-        final String[] args = { String.valueOf(hour24), String.valueOf(minutes), "1" };
+        final String[] args = {String.valueOf(hour24), String.valueOf(minutes), "1"};
         return Alarm.getAlarms(cr, selection, args);
     }
 
diff --git a/src/com/android/deskclock/FormattedTextUtils.java b/app/src/main/java/com/best/deskclock/FormattedTextUtils.java
similarity index 100%
rename from src/com/android/deskclock/FormattedTextUtils.java
rename to app/src/main/java/com/best/deskclock/FormattedTextUtils.java
diff --git a/src/com/android/deskclock/FragmentTabPagerAdapter.java b/app/src/main/java/com/best/deskclock/FragmentTabPagerAdapter.java
similarity index 88%
rename from src/com/android/deskclock/FragmentTabPagerAdapter.java
rename to app/src/main/java/com/best/deskclock/FragmentTabPagerAdapter.java
index c6bc1a26c..3035354eb 100644
--- a/src/com/android/deskclock/FragmentTabPagerAdapter.java
+++ b/app/src/main/java/com/best/deskclock/FragmentTabPagerAdapter.java
@@ -19,12 +19,14 @@ package com.best.deskclock;
 import android.app.Fragment;
 import android.app.FragmentManager;
 import android.app.FragmentTransaction;
-import androidx.legacy.app.FragmentCompat;
-import androidx.viewpager.widget.PagerAdapter;
 import android.util.ArrayMap;
 import android.view.View;
 import android.view.ViewGroup;
 
+import androidx.annotation.NonNull;
+import androidx.legacy.app.FragmentCompat;
+import androidx.viewpager.widget.PagerAdapter;
+
 import com.best.deskclock.uidata.UiDataModel;
 
 import java.util.Map;
@@ -40,16 +42,24 @@ final class FragmentTabPagerAdapter extends PagerAdapter {
 
     private final DeskClock mDeskClock;
 
-    /** The manager into which fragments are added. */
+    /**
+     * The manager into which fragments are added.
+     */
     private final FragmentManager mFragmentManager;
 
-    /** A fragment cache that can be accessed before {@link #instantiateItem} is called. */
+    /**
+     * A fragment cache that can be accessed before {@link #instantiateItem} is called.
+     */
     private final Map<UiDataModel.Tab, DeskClockFragment> mFragmentCache;
 
-    /** The active fragment transaction if one exists. */
+    /**
+     * The active fragment transaction if one exists.
+     */
     private FragmentTransaction mCurrentTransaction;
 
-    /** The current fragment displayed to the user. */
+    /**
+     * The current fragment displayed to the user.
+     */
     private Fragment mCurrentPrimaryItem;
 
     FragmentTabPagerAdapter(DeskClock deskClock) {
@@ -102,8 +112,9 @@ final class FragmentTabPagerAdapter extends PagerAdapter {
         }
     }
 
+    @NonNull
     @Override
-    public Object instantiateItem(ViewGroup container, int position) {
+    public Object instantiateItem(@NonNull ViewGroup container, int position) {
         if (mCurrentTransaction == null) {
             mCurrentTransaction = mFragmentManager.beginTransaction();
         }
@@ -127,7 +138,7 @@ final class FragmentTabPagerAdapter extends PagerAdapter {
     }
 
     @Override
-    public void destroyItem(ViewGroup container, int position, Object object) {
+    public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) {
         if (mCurrentTransaction == null) {
             mCurrentTransaction = mFragmentManager.beginTransaction();
         }
@@ -137,7 +148,7 @@ final class FragmentTabPagerAdapter extends PagerAdapter {
     }
 
     @Override
-    public void setPrimaryItem(ViewGroup container, int position, Object object) {
+    public void setPrimaryItem(@NonNull ViewGroup container, int position, @NonNull Object object) {
         final Fragment fragment = (Fragment) object;
         if (fragment != mCurrentPrimaryItem) {
             if (mCurrentPrimaryItem != null) {
@@ -153,7 +164,7 @@ final class FragmentTabPagerAdapter extends PagerAdapter {
     }
 
     @Override
-    public void finishUpdate(ViewGroup container) {
+    public void finishUpdate(@NonNull ViewGroup container) {
         if (mCurrentTransaction != null) {
             mCurrentTransaction.commitAllowingStateLoss();
             mCurrentTransaction = null;
@@ -162,7 +173,7 @@ final class FragmentTabPagerAdapter extends PagerAdapter {
     }
 
     @Override
-    public boolean isViewFromObject(View view, Object object) {
+    public boolean isViewFromObject(@NonNull View view, @NonNull Object object) {
         return ((Fragment) object).getView() == view;
     }
 } 
diff --git a/src/com/android/deskclock/HandleApiCalls.java b/app/src/main/java/com/best/deskclock/HandleApiCalls.java
similarity index 97%
rename from src/com/android/deskclock/HandleApiCalls.java
rename to app/src/main/java/com/best/deskclock/HandleApiCalls.java
index 425dfcffa..2a3fc3cae 100644
--- a/src/com/android/deskclock/HandleApiCalls.java
+++ b/app/src/main/java/com/best/deskclock/HandleApiCalls.java
@@ -16,6 +16,15 @@
 
 package com.best.deskclock;
 
+import static android.text.format.DateUtils.SECOND_IN_MILLIS;
+import static com.best.deskclock.AlarmSelectionActivity.ACTION_DISMISS;
+import static com.best.deskclock.AlarmSelectionActivity.EXTRA_ACTION;
+import static com.best.deskclock.AlarmSelectionActivity.EXTRA_ALARMS;
+import static com.best.deskclock.provider.AlarmInstance.FIRED_STATE;
+import static com.best.deskclock.provider.AlarmInstance.SNOOZE_STATE;
+import static com.best.deskclock.uidata.UiDataModel.Tab.ALARMS;
+import static com.best.deskclock.uidata.UiDataModel.Tab.TIMERS;
+
 import android.app.Activity;
 import android.content.ContentResolver;
 import android.content.ContentUris;
@@ -47,15 +56,6 @@ import java.util.Date;
 import java.util.Iterator;
 import java.util.List;
 
-import static android.text.format.DateUtils.SECOND_IN_MILLIS;
-import static com.best.deskclock.AlarmSelectionActivity.ACTION_DISMISS;
-import static com.best.deskclock.AlarmSelectionActivity.EXTRA_ACTION;
-import static com.best.deskclock.AlarmSelectionActivity.EXTRA_ALARMS;
-import static com.best.deskclock.provider.AlarmInstance.FIRED_STATE;
-import static com.best.deskclock.provider.AlarmInstance.SNOOZE_STATE;
-import static com.best.deskclock.uidata.UiDataModel.Tab.ALARMS;
-import static com.best.deskclock.uidata.UiDataModel.Tab.TIMERS;
-
 /**
  * This activity is never visible. It processes all public intents defined by {@link AlarmClock}
  * that apply to alarms and timers. Its definition in AndroidManifest.xml requires callers to hold
@@ -67,62 +67,6 @@ public class HandleApiCalls extends Activity {
 
     private Context mAppContext;
 
-    @Override
-    protected void onCreate(Bundle icicle) {
-        super.onCreate(icicle);
-
-        mAppContext = getApplicationContext();
-
-        try {
-            final Intent intent = getIntent();
-            final String action = intent == null ? null : intent.getAction();
-            if (action == null) {
-                return;
-            }
-            LOGGER.i("onCreate: " + intent);
-
-            switch (action) {
-
-                case AlarmClock.ACTION_SET_ALARM:
-                    handleSetAlarm(intent);
-                    break;
-                case AlarmClock.ACTION_SHOW_ALARMS:
-                    handleShowAlarms();
-                    break;
-                case AlarmClock.ACTION_SET_TIMER:
-                    handleSetTimer(intent);
-                    break;
-                case AlarmClock.ACTION_SHOW_TIMERS:
-                    handleShowTimers(intent);
-                    break;
-                case AlarmClock.ACTION_DISMISS_ALARM:
-                    handleDismissAlarm(intent);
-                    break;
-                case AlarmClock.ACTION_SNOOZE_ALARM:
-                    handleSnoozeAlarm(intent);
-                    break;
-                case AlarmClock.ACTION_DISMISS_TIMER:
-                    handleDismissTimer(intent);
-                    break;
-            }
-        } catch (Exception e) {
-            LOGGER.wtf(e);
-        } finally {
-            finish();
-        }
-    }
-
-
-    private void handleDismissAlarm(Intent intent) {
-        // Change to the alarms tab.
-        UiDataModel.getUiDataModel().setSelectedTab(ALARMS);
-
-        // Open DeskClock which is now positioned on the alarms tab.
-        startActivity(new Intent(mAppContext, DeskClock.class));
-
-        new DismissAlarmAsync(mAppContext, intent, this).execute();
-    }
-
     public static void dismissAlarm(Alarm alarm, Activity activity) {
         final Context context = activity.getApplicationContext();
         final AlarmInstance instance = AlarmInstance.getNextUpcomingInstanceByAlarmId(
@@ -165,133 +109,128 @@ public class HandleApiCalls extends Activity {
         Events.sendAlarmEvent(R.string.action_dismiss, R.string.label_intent);
     }
 
-    private static class DismissAlarmAsync extends AsyncTask<Void, Void, Void> {
-
-        private final Context mContext;
-        private final Intent mIntent;
-        private final Activity mActivity;
+    static void snoozeAlarm(AlarmInstance alarmInstance, Context context, Activity activity) {
+        Utils.enforceNotMainLooper();
 
-        public DismissAlarmAsync(Context context, Intent intent, Activity activity) {
-            mContext = context;
-            mIntent = intent;
-            mActivity = activity;
-        }
+        final String time = DateFormat.getTimeFormat(context).format(
+                alarmInstance.getAlarmTime().getTime());
+        final String reason = context.getString(R.string.alarm_is_snoozed, time);
+        AlarmStateManager.setSnoozeState(context, alarmInstance, true);
 
-        @Override
-        protected Void doInBackground(Void... parameters) {
-            final ContentResolver cr = mContext.getContentResolver();
-            final List<Alarm> alarms = getEnabledAlarms(mContext);
-            if (alarms.isEmpty()) {
-                final String reason = mContext.getString(R.string.no_scheduled_alarms);
-                Controller.getController().notifyVoiceFailure(mActivity, reason);
-                LOGGER.i("No scheduled alarms");
-                return null;
-            }
+        Controller.getController().notifyVoiceSuccess(activity, reason);
+        LOGGER.i("Alarm snoozed: " + alarmInstance);
+        Events.sendAlarmEvent(R.string.action_snooze, R.string.label_intent);
+    }
 
-            // remove Alarms in MISSED, DISMISSED, and PREDISMISSED states
-            for (Iterator<Alarm> i = alarms.iterator(); i.hasNext();) {
-                final AlarmInstance instance = AlarmInstance.getNextUpcomingInstanceByAlarmId(
-                        cr, i.next().id);
-                if (instance == null || instance.mAlarmState > FIRED_STATE) {
-                    i.remove();
-                }
-            }
+    /**
+     * @param alarm  the alarm to be updated
+     * @param intent the intent containing new alarm field values to merge into the {@code alarm}
+     */
+    private static void updateAlarmFromIntent(Alarm alarm, Intent intent) {
+        alarm.enabled = true;
+        alarm.hour = intent.getIntExtra(AlarmClock.EXTRA_HOUR, alarm.hour);
+        alarm.minutes = intent.getIntExtra(AlarmClock.EXTRA_MINUTES, alarm.minutes);
+        alarm.vibrate = intent.getBooleanExtra(AlarmClock.EXTRA_VIBRATE, alarm.vibrate);
+        alarm.alert = getAlertFromIntent(intent, alarm.alert);
+        alarm.label = getLabelFromIntent(intent, alarm.label);
+        alarm.daysOfWeek = getDaysFromIntent(intent, alarm.daysOfWeek);
+    }
 
-            final String searchMode = mIntent.getStringExtra(AlarmClock.EXTRA_ALARM_SEARCH_MODE);
-            if (searchMode == null && alarms.size() > 1) {
-                // shows the UI where user picks which alarm they want to DISMISS
-                final Intent pickSelectionIntent = new Intent(mContext,
-                        AlarmSelectionActivity.class)
-                        .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
-                        .putExtra(EXTRA_ACTION, ACTION_DISMISS)
-                        .putExtra(EXTRA_ALARMS, alarms.toArray(new Parcelable[alarms.size()]));
-                mContext.startActivity(pickSelectionIntent);
-                final String voiceMessage = mContext.getString(R.string.pick_alarm_to_dismiss);
-                Controller.getController().notifyVoiceSuccess(mActivity, voiceMessage);
-                return null;
-            }
+    private static String getLabelFromIntent(Intent intent, String defaultLabel) {
+        final String message = intent.getExtras().getString(AlarmClock.EXTRA_MESSAGE, defaultLabel);
+        return message == null ? "" : message;
+    }
 
-            // fetch the alarms that are specified by the intent
-            final FetchMatchingAlarmsAction fmaa =
-                    new FetchMatchingAlarmsAction(mContext, alarms, mIntent, mActivity);
-            fmaa.run();
-            final List<Alarm> matchingAlarms = fmaa.getMatchingAlarms();
+    private static Weekdays getDaysFromIntent(Intent intent, Weekdays defaultWeekdays) {
+        if (!intent.hasExtra(AlarmClock.EXTRA_DAYS)) {
+            return defaultWeekdays;
+        }
 
-            // If there are multiple matching alarms and it wasn't expected
-            // disambiguate what the user meant
-            if (!AlarmClock.ALARM_SEARCH_MODE_ALL.equals(searchMode) && matchingAlarms.size() > 1) {
-              final Intent pickSelectionIntent = new Intent(mContext, AlarmSelectionActivity.class)
-                        .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
-                        .putExtra(EXTRA_ACTION, ACTION_DISMISS)
-                        .putExtra(EXTRA_ALARMS,
-                                matchingAlarms.toArray(new Parcelable[matchingAlarms.size()]));
-                mContext.startActivity(pickSelectionIntent);
-                final String voiceMessage = mContext.getString(R.string.pick_alarm_to_dismiss);
-                Controller.getController().notifyVoiceSuccess(mActivity, voiceMessage);
-                return null;
+        final List<Integer> days = intent.getIntegerArrayListExtra(AlarmClock.EXTRA_DAYS);
+        if (days != null) {
+            final int[] daysArray = new int[days.size()];
+            for (int i = 0; i < days.size(); i++) {
+                daysArray[i] = days.get(i);
             }
-
-            // Apply the action to the matching alarms
-            for (Alarm alarm : matchingAlarms) {
-                dismissAlarm(alarm, mActivity);
-                LOGGER.i("Alarm dismissed: " + alarm);
+            return Weekdays.fromCalendarDays(daysArray);
+        } else {
+            // API says to use an ArrayList<Integer> but we allow the user to use a int[] too.
+            final int[] daysArray = intent.getIntArrayExtra(AlarmClock.EXTRA_DAYS);
+            if (daysArray != null) {
+                return Weekdays.fromCalendarDays(daysArray);
             }
-            return null;
         }
+        return defaultWeekdays;
+    }
 
-        private static List<Alarm> getEnabledAlarms(Context context) {
-            final String selection = String.format("%s=?", Alarm.ENABLED);
-            final String[] args = { "1" };
-            return Alarm.getAlarms(context.getContentResolver(), selection, args);
+    private static Uri getAlertFromIntent(Intent intent, Uri defaultUri) {
+        final String alert = intent.getStringExtra(AlarmClock.EXTRA_RINGTONE);
+        if (alert == null) {
+            return defaultUri;
+        } else if (AlarmClock.VALUE_RINGTONE_SILENT.equals(alert) || alert.isEmpty()) {
+            return Alarm.NO_RINGTONE_URI;
         }
-    }
 
-    private void handleSnoozeAlarm(Intent intent) {
-        new SnoozeAlarmAsync(intent, this).execute();
+        return Uri.parse(alert);
     }
 
-    private static class SnoozeAlarmAsync extends AsyncTask<Void, Void, Void> {
-
-        private final Context mContext;
-        private final Intent mIntent;
-        private final Activity mActivity;
+    @Override
+    protected void onCreate(Bundle icicle) {
+        super.onCreate(icicle);
 
-        public SnoozeAlarmAsync(Intent intent, Activity activity) {
-            mContext = activity.getApplicationContext();
-            mIntent = intent;
-            mActivity = activity;
-        }
+        mAppContext = getApplicationContext();
 
-        @Override
-        protected Void doInBackground(Void... parameters) {
-            final ContentResolver cr = mContext.getContentResolver();
-            final List<AlarmInstance> alarmInstances = AlarmInstance.getInstancesByState(
-                    cr, FIRED_STATE);
-            if (alarmInstances.isEmpty()) {
-                final String reason = mContext.getString(R.string.no_firing_alarms);
-                Controller.getController().notifyVoiceFailure(mActivity, reason);
-                LOGGER.i("No firing alarms");
-                return null;
+        try {
+            final Intent intent = getIntent();
+            final String action = intent == null ? null : intent.getAction();
+            if (action == null) {
+                return;
             }
+            LOGGER.i("onCreate: " + intent);
 
-            for (AlarmInstance firingAlarmInstance : alarmInstances) {
-                snoozeAlarm(firingAlarmInstance, mContext, mActivity);
+            switch (action) {
+
+                case AlarmClock.ACTION_SET_ALARM:
+                    handleSetAlarm(intent);
+                    break;
+                case AlarmClock.ACTION_SHOW_ALARMS:
+                    handleShowAlarms();
+                    break;
+                case AlarmClock.ACTION_SET_TIMER:
+                    handleSetTimer(intent);
+                    break;
+                case AlarmClock.ACTION_SHOW_TIMERS:
+                    handleShowTimers(intent);
+                    break;
+                case AlarmClock.ACTION_DISMISS_ALARM:
+                    handleDismissAlarm(intent);
+                    break;
+                case AlarmClock.ACTION_SNOOZE_ALARM:
+                    handleSnoozeAlarm(intent);
+                    break;
+                case AlarmClock.ACTION_DISMISS_TIMER:
+                    handleDismissTimer(intent);
+                    break;
             }
-            return null;
+        } catch (Exception e) {
+            LOGGER.wtf(e);
+        } finally {
+            finish();
         }
     }
 
-    static void snoozeAlarm(AlarmInstance alarmInstance, Context context, Activity activity) {
-        Utils.enforceNotMainLooper();
+    private void handleDismissAlarm(Intent intent) {
+        // Change to the alarms tab.
+        UiDataModel.getUiDataModel().setSelectedTab(ALARMS);
 
-        final String time = DateFormat.getTimeFormat(context).format(
-                alarmInstance.getAlarmTime().getTime());
-        final String reason = context.getString(R.string.alarm_is_snoozed, time);
-        AlarmStateManager.setSnoozeState(context, alarmInstance, true);
+        // Open DeskClock which is now positioned on the alarms tab.
+        startActivity(new Intent(mAppContext, DeskClock.class));
 
-        Controller.getController().notifyVoiceSuccess(activity, reason);
-        LOGGER.i("Alarm snoozed: " + alarmInstance);
-        Events.sendAlarmEvent(R.string.action_snooze, R.string.label_intent);
+        new DismissAlarmAsync(mAppContext, intent, this).execute();
+    }
+
+    private void handleSnoozeAlarm(Intent intent) {
+        new SnoozeAlarmAsync(intent, this).execute();
     }
 
     /***
@@ -479,9 +418,15 @@ public class HandleApiCalls extends Activity {
         // Attempt to reuse an existing timer that is Reset with the same length and label.
         Timer timer = null;
         for (Timer t : DataModel.getDataModel().getTimers()) {
-            if (!t.isReset()) { continue; }
-            if (t.getLength() != lengthMillis) { continue; }
-            if (!TextUtils.equals(label, t.getLabel())) { continue; }
+            if (!t.isReset()) {
+                continue;
+            }
+            if (t.getLength() != lengthMillis) {
+                continue;
+            }
+            if (!TextUtils.equals(label, t.getLabel())) {
+                continue;
+            }
 
             timer = t;
             break;
@@ -510,7 +455,7 @@ public class HandleApiCalls extends Activity {
     }
 
     private void setupInstance(AlarmInstance instance, boolean skipUi) {
-        instance = AlarmInstance.addInstance(this.getContentResolver(), instance);
+        AlarmInstance.addInstance(this.getContentResolver(), instance);
         AlarmStateManager.registerInstance(this, instance, true);
         AlarmUtils.popAlarmSetToast(this, instance.getAlarmTime().getTimeInMillis());
         if (!skipUi) {
@@ -525,58 +470,6 @@ public class HandleApiCalls extends Activity {
         }
     }
 
-    /**
-     * @param alarm the alarm to be updated
-     * @param intent the intent containing new alarm field values to merge into the {@code alarm}
-     */
-    private static void updateAlarmFromIntent(Alarm alarm, Intent intent) {
-        alarm.enabled = true;
-        alarm.hour = intent.getIntExtra(AlarmClock.EXTRA_HOUR, alarm.hour);
-        alarm.minutes = intent.getIntExtra(AlarmClock.EXTRA_MINUTES, alarm.minutes);
-        alarm.vibrate = intent.getBooleanExtra(AlarmClock.EXTRA_VIBRATE, alarm.vibrate);
-        alarm.alert = getAlertFromIntent(intent, alarm.alert);
-        alarm.label = getLabelFromIntent(intent, alarm.label);
-        alarm.daysOfWeek = getDaysFromIntent(intent, alarm.daysOfWeek);
-    }
-
-    private static String getLabelFromIntent(Intent intent, String defaultLabel) {
-        final String message = intent.getExtras().getString(AlarmClock.EXTRA_MESSAGE, defaultLabel);
-        return message == null ? "" : message;
-    }
-
-    private static Weekdays getDaysFromIntent(Intent intent, Weekdays defaultWeekdays) {
-        if (!intent.hasExtra(AlarmClock.EXTRA_DAYS)) {
-            return defaultWeekdays;
-        }
-
-        final List<Integer> days = intent.getIntegerArrayListExtra(AlarmClock.EXTRA_DAYS);
-        if (days != null) {
-            final int[] daysArray = new int[days.size()];
-            for (int i = 0; i < days.size(); i++) {
-                daysArray[i] = days.get(i);
-            }
-            return Weekdays.fromCalendarDays(daysArray);
-        } else {
-            // API says to use an ArrayList<Integer> but we allow the user to use a int[] too.
-            final int[] daysArray = intent.getIntArrayExtra(AlarmClock.EXTRA_DAYS);
-            if (daysArray != null) {
-                return Weekdays.fromCalendarDays(daysArray);
-            }
-        }
-        return defaultWeekdays;
-    }
-
-    private static Uri getAlertFromIntent(Intent intent, Uri defaultUri) {
-        final String alert = intent.getStringExtra(AlarmClock.EXTRA_RINGTONE);
-        if (alert == null) {
-            return defaultUri;
-        } else if (AlarmClock.VALUE_RINGTONE_SILENT.equals(alert) || alert.isEmpty()) {
-            return Alarm.NO_RINGTONE_URI;
-        }
-
-        return Uri.parse(alert);
-    }
-
     /**
      * Assemble a database where clause to search for an alarm matching the given {@code hour} and
      * {@code minutes} as well as all of the optional information within the {@code intent}
@@ -589,11 +482,11 @@ public class HandleApiCalls extends Activity {
      *     <li>ringtone uri</li>
      * </ul>
      *
-     * @param intent contains details of the alarm to be located
-     * @param hour the hour of the day of the alarm
-     * @param minutes the minute of the hour of the alarm
+     * @param intent    contains details of the alarm to be located
+     * @param hour      the hour of the day of the alarm
+     * @param minutes   the minute of the hour of the alarm
      * @param selection an out parameter containing a SQL where clause
-     * @param args an out parameter containing the values to substitute into the {@code selection}
+     * @param args      an out parameter containing the values to substitute into the {@code selection}
      */
     private void setSelectionFromIntent(
             Intent intent,
@@ -630,4 +523,114 @@ public class HandleApiCalls extends Activity {
             args.add(ringtone.toString());
         }
     }
+
+    private static class DismissAlarmAsync extends AsyncTask<Void, Void, Void> {
+
+        private final Context mContext;
+        private final Intent mIntent;
+        private final Activity mActivity;
+
+        public DismissAlarmAsync(Context context, Intent intent, Activity activity) {
+            mContext = context;
+            mIntent = intent;
+            mActivity = activity;
+        }
+
+        private static List<Alarm> getEnabledAlarms(Context context) {
+            final String selection = String.format("%s=?", Alarm.ENABLED);
+            final String[] args = {"1"};
+            return Alarm.getAlarms(context.getContentResolver(), selection, args);
+        }
+
+        @Override
+        protected Void doInBackground(Void... parameters) {
+            final ContentResolver cr = mContext.getContentResolver();
+            final List<Alarm> alarms = getEnabledAlarms(mContext);
+            if (alarms.isEmpty()) {
+                final String reason = mContext.getString(R.string.no_scheduled_alarms);
+                Controller.getController().notifyVoiceFailure(mActivity, reason);
+                LOGGER.i("No scheduled alarms");
+                return null;
+            }
+
+            // remove Alarms in MISSED, DISMISSED, and PREDISMISSED states
+            for (Iterator<Alarm> i = alarms.iterator(); i.hasNext(); ) {
+                final AlarmInstance instance = AlarmInstance.getNextUpcomingInstanceByAlarmId(
+                        cr, i.next().id);
+                if (instance == null || instance.mAlarmState > FIRED_STATE) {
+                    i.remove();
+                }
+            }
+
+            final String searchMode = mIntent.getStringExtra(AlarmClock.EXTRA_ALARM_SEARCH_MODE);
+            if (searchMode == null && alarms.size() > 1) {
+                // shows the UI where user picks which alarm they want to DISMISS
+                final Intent pickSelectionIntent = new Intent(mContext,
+                        AlarmSelectionActivity.class)
+                        .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
+                        .putExtra(EXTRA_ACTION, ACTION_DISMISS)
+                        .putExtra(EXTRA_ALARMS, alarms.toArray(new Parcelable[alarms.size()]));
+                mContext.startActivity(pickSelectionIntent);
+                final String voiceMessage = mContext.getString(R.string.pick_alarm_to_dismiss);
+                Controller.getController().notifyVoiceSuccess(mActivity, voiceMessage);
+                return null;
+            }
+
+            // fetch the alarms that are specified by the intent
+            final FetchMatchingAlarmsAction fmaa =
+                    new FetchMatchingAlarmsAction(mContext, alarms, mIntent, mActivity);
+            fmaa.run();
+            final List<Alarm> matchingAlarms = fmaa.getMatchingAlarms();
+
+            // If there are multiple matching alarms and it wasn't expected
+            // disambiguate what the user meant
+            if (!AlarmClock.ALARM_SEARCH_MODE_ALL.equals(searchMode) && matchingAlarms.size() > 1) {
+                final Intent pickSelectionIntent = new Intent(mContext, AlarmSelectionActivity.class)
+                        .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
+                        .putExtra(EXTRA_ACTION, ACTION_DISMISS)
+                        .putExtra(EXTRA_ALARMS,
+                                matchingAlarms.toArray(new Parcelable[matchingAlarms.size()]));
+                mContext.startActivity(pickSelectionIntent);
+                final String voiceMessage = mContext.getString(R.string.pick_alarm_to_dismiss);
+                Controller.getController().notifyVoiceSuccess(mActivity, voiceMessage);
+                return null;
+            }
+
+            // Apply the action to the matching alarms
+            for (Alarm alarm : matchingAlarms) {
+                dismissAlarm(alarm, mActivity);
+                LOGGER.i("Alarm dismissed: " + alarm);
+            }
+            return null;
+        }
+    }
+
+    private static class SnoozeAlarmAsync extends AsyncTask<Void, Void, Void> {
+
+        private final Context mContext;
+        private final Activity mActivity;
+
+        public SnoozeAlarmAsync(Intent intent, Activity activity) {
+            mContext = activity.getApplicationContext();
+            mActivity = activity;
+        }
+
+        @Override
+        protected Void doInBackground(Void... parameters) {
+            final ContentResolver cr = mContext.getContentResolver();
+            final List<AlarmInstance> alarmInstances = AlarmInstance.getInstancesByState(
+                    cr, FIRED_STATE);
+            if (alarmInstances.isEmpty()) {
+                final String reason = mContext.getString(R.string.no_firing_alarms);
+                Controller.getController().notifyVoiceFailure(mActivity, reason);
+                LOGGER.i("No firing alarms");
+                return null;
+            }
+
+            for (AlarmInstance firingAlarmInstance : alarmInstances) {
+                snoozeAlarm(firingAlarmInstance, mContext, mActivity);
+            }
+            return null;
+        }
+    }
 }
diff --git a/src/com/android/deskclock/HandleShortcuts.java b/app/src/main/java/com/best/deskclock/HandleShortcuts.java
similarity index 100%
rename from src/com/android/deskclock/HandleShortcuts.java
rename to app/src/main/java/com/best/deskclock/HandleShortcuts.java
index fc0c1eefd..62c451b34 100644
--- a/src/com/android/deskclock/HandleShortcuts.java
+++ b/app/src/main/java/com/best/deskclock/HandleShortcuts.java
@@ -16,6 +16,8 @@
 
 package com.best.deskclock;
 
+import static com.best.deskclock.uidata.UiDataModel.Tab.STOPWATCH;
+
 import android.app.Activity;
 import android.content.Intent;
 import android.os.Bundle;
@@ -24,8 +26,6 @@ import com.best.deskclock.events.Events;
 import com.best.deskclock.stopwatch.StopwatchService;
 import com.best.deskclock.uidata.UiDataModel;
 
-import static com.best.deskclock.uidata.UiDataModel.Tab.STOPWATCH;
-
 public class HandleShortcuts extends Activity {
 
     private static final LogUtils.Logger LOGGER = new LogUtils.Logger("HandleShortcuts");
diff --git a/src/com/android/deskclock/ItemAdapter.java b/app/src/main/java/com/best/deskclock/ItemAdapter.java
similarity index 98%
rename from src/com/android/deskclock/ItemAdapter.java
rename to app/src/main/java/com/best/deskclock/ItemAdapter.java
index efb57a75a..358dfb5c9 100644
--- a/src/com/android/deskclock/ItemAdapter.java
+++ b/app/src/main/java/com/best/deskclock/ItemAdapter.java
@@ -16,18 +16,19 @@
 
 package com.best.deskclock;
 
+import static androidx.recyclerview.widget.RecyclerView.NO_ID;
+
 import android.os.Bundle;
-import androidx.annotation.NonNull;
-import androidx.recyclerview.widget.RecyclerView;
 import android.util.SparseArray;
 import android.view.View;
 import android.view.ViewGroup;
 
+import androidx.annotation.NonNull;
+import androidx.recyclerview.widget.RecyclerView;
+
 import java.util.ArrayList;
 import java.util.List;
 
-import static androidx.recyclerview.widget.RecyclerView.NO_ID;
-
 /**
  * Base adapter class for displaying a collection of items. Provides functionality for handling
  * changing items, persistent item state, item click events, and re-usable item views.
@@ -35,6 +36,36 @@ import static androidx.recyclerview.widget.RecyclerView.NO_ID;
 public class ItemAdapter<T extends ItemAdapter.ItemHolder>
         extends RecyclerView.Adapter<ItemAdapter.ItemViewHolder> {
 
+    /**
+     * Factories for creating new {@link ItemViewHolder} entities.
+     */
+    private final SparseArray<ItemViewHolder.Factory> mFactoriesByViewType = new SparseArray<>();
+    /**
+     * Listeners to invoke in {@link #mOnItemClickedListener}.
+     */
+    private final SparseArray<OnItemClickedListener> mListenersByViewType = new SparseArray<>();
+    /**
+     * Invokes the {@link OnItemClickedListener} in {@link #mListenersByViewType} corresponding
+     * to {@link ItemViewHolder#getItemViewType()}
+     */
+    private final OnItemClickedListener mOnItemClickedListener = new OnItemClickedListener() {
+        @Override
+        public void onItemClicked(ItemViewHolder<?> viewHolder, int id) {
+            final OnItemClickedListener listener =
+                    mListenersByViewType.get(viewHolder.getItemViewType());
+            if (listener != null) {
+                listener.onItemClicked(viewHolder, id);
+            }
+        }
+    };
+    /**
+     * Invoked when any item changes.
+     */
+    private OnItemChangedListener mOnItemChangedListener;
+    /**
+     * List of current item holders represented by this adapter.
+     */
+    private List<T> mItemHolders;
     /**
      * Finds the position of the changed item holder and invokes {@link #notifyItemChanged(int)} or
      * {@link #notifyItemChanged(int, Object)} if payloads are present (in order to do in-place
@@ -64,41 +95,6 @@ public class ItemAdapter<T extends ItemAdapter.ItemHolder>
         }
     };
 
-    /**
-     * Invokes the {@link OnItemClickedListener} in {@link #mListenersByViewType} corresponding
-     * to {@link ItemViewHolder#getItemViewType()}
-     */
-    private final OnItemClickedListener mOnItemClickedListener = new OnItemClickedListener() {
-        @Override
-        public void onItemClicked(ItemViewHolder<?> viewHolder, int id) {
-            final OnItemClickedListener listener =
-                    mListenersByViewType.get(viewHolder.getItemViewType());
-            if (listener != null) {
-                listener.onItemClicked(viewHolder, id);
-            }
-        }
-    };
-
-    /**
-     * Invoked when any item changes.
-     */
-    private OnItemChangedListener mOnItemChangedListener;
-
-    /**
-     * Factories for creating new {@link ItemViewHolder} entities.
-     */
-    private final SparseArray<ItemViewHolder.Factory> mFactoriesByViewType = new SparseArray<>();
-
-    /**
-     * Listeners to invoke in {@link #mOnItemClickedListener}.
-     */
-    private final SparseArray<OnItemClickedListener> mListenersByViewType = new SparseArray<>();
-
-    /**
-     * List of current item holders represented by this adapter.
-     */
-    private List<T> mItemHolders;
-
     /**
      * Convenience for calling {@link #setHasStableIds(boolean)} with {@code true}.
      *
@@ -120,7 +116,7 @@ public class ItemAdapter<T extends ItemAdapter.ItemHolder>
      * @return this object, allowing calls to methods in this class to be chained
      */
     public ItemAdapter withViewTypes(ItemViewHolder.Factory factory,
-            OnItemClickedListener listener, int... viewTypes) {
+                                     OnItemClickedListener listener, int... viewTypes) {
         for (int viewType : viewTypes) {
             mFactoriesByViewType.put(viewType, factory);
             mListenersByViewType.put(viewType, listener);
@@ -257,8 +253,9 @@ public class ItemAdapter<T extends ItemAdapter.ItemHolder>
         return mItemHolders.get(position).getItemViewType();
     }
 
+    @NonNull
     @Override
-    public ItemViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+    public ItemViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
         final ItemViewHolder.Factory factory = mFactoriesByViewType.get(viewType);
         if (factory != null) {
             return factory.createViewHolder(parent, viewType);
@@ -281,6 +278,40 @@ public class ItemAdapter<T extends ItemAdapter.ItemHolder>
         viewHolder.recycleItemView();
     }
 
+    /**
+     * Callback interface for when an item changes and should be re-bound.
+     */
+    public interface OnItemChangedListener {
+        /**
+         * Invoked by {@link ItemHolder#notifyItemChanged()}.
+         *
+         * @param itemHolder the item holder that has changed
+         */
+        void onItemChanged(ItemHolder<?> itemHolder);
+
+
+        /**
+         * Invoked by {@link ItemHolder#notifyItemChanged(Object payload)}.
+         *
+         * @param itemHolder the item holder that has changed
+         * @param payload    the payload object
+         */
+        void onItemChanged(ItemAdapter.ItemHolder<?> itemHolder, Object payload);
+    }
+
+    /**
+     * Callback interface for handling when an item is clicked.
+     */
+    public interface OnItemClickedListener {
+        /**
+         * Invoked by {@link ItemViewHolder#notifyItemClicked(int)}
+         *
+         * @param viewHolder the {@link ItemViewHolder} containing the view that was clicked
+         * @param id         the unique identifier for the click action that has occurred
+         */
+        void onItemClicked(ItemViewHolder<?> viewHolder, int id);
+    }
+
     /**
      * Base class for wrapping an item for compatibility with an {@link ItemHolder}.
      * <p/>
@@ -504,41 +535,7 @@ public class ItemAdapter<T extends ItemAdapter.ItemHolder>
              * @param viewType the unique id of the item view to create
              * @return a new initialized {@link ItemViewHolder}
              */
-            public ItemViewHolder<?> createViewHolder(ViewGroup parent, int viewType);
+            ItemViewHolder<?> createViewHolder(ViewGroup parent, int viewType);
         }
     }
-
-    /**
-     * Callback interface for when an item changes and should be re-bound.
-     */
-    public interface OnItemChangedListener {
-        /**
-         * Invoked by {@link ItemHolder#notifyItemChanged()}.
-         *
-         * @param itemHolder the item holder that has changed
-         */
-        void onItemChanged(ItemHolder<?> itemHolder);
-
-
-        /**
-         * Invoked by {@link ItemHolder#notifyItemChanged(Object payload)}.
-         *
-         * @param itemHolder the item holder that has changed
-         * @param payload the payload object
-         */
-        void onItemChanged(ItemAdapter.ItemHolder<?> itemHolder, Object payload);
-    }
-
-    /**
-     * Callback interface for handling when an item is clicked.
-     */
-    public interface OnItemClickedListener {
-        /**
-         * Invoked by {@link ItemViewHolder#notifyItemClicked(int)}
-         *
-         * @param viewHolder the {@link ItemViewHolder} containing the view that was clicked
-         * @param id         the unique identifier for the click action that has occurred
-         */
-        void onItemClicked(ItemViewHolder<?> viewHolder, int id);
-    }
 }
diff --git a/src/com/android/deskclock/ItemAnimator.java b/app/src/main/java/com/best/deskclock/ItemAnimator.java
similarity index 94%
rename from src/com/android/deskclock/ItemAnimator.java
rename to app/src/main/java/com/best/deskclock/ItemAnimator.java
index 279642340..45da4cd59 100644
--- a/src/com/android/deskclock/ItemAnimator.java
+++ b/app/src/main/java/com/best/deskclock/ItemAnimator.java
@@ -16,25 +16,26 @@
 
 package com.best.deskclock;
 
+import static android.view.View.TRANSLATION_X;
+import static android.view.View.TRANSLATION_Y;
+
 import android.animation.Animator;
 import android.animation.AnimatorListenerAdapter;
 import android.animation.AnimatorSet;
 import android.animation.ObjectAnimator;
 import android.animation.PropertyValuesHolder;
+import android.view.View;
+
 import androidx.annotation.NonNull;
 import androidx.collection.ArrayMap;
 import androidx.recyclerview.widget.RecyclerView.State;
 import androidx.recyclerview.widget.RecyclerView.ViewHolder;
 import androidx.recyclerview.widget.SimpleItemAnimator;
-import android.view.View;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 
-import static android.view.View.TRANSLATION_Y;
-import static android.view.View.TRANSLATION_X;
-
 public class ItemAnimator extends SimpleItemAnimator {
 
     private final List<Animator> mAddAnimatorsList = new ArrayList<>();
@@ -156,8 +157,8 @@ public class ItemAnimator extends SimpleItemAnimator {
 
     @Override
     public boolean animateChange(@NonNull final ViewHolder oldHolder,
-            @NonNull final ViewHolder newHolder, @NonNull ItemHolderInfo preInfo,
-            @NonNull ItemHolderInfo postInfo) {
+                                 @NonNull final ViewHolder newHolder, @NonNull ItemHolderInfo preInfo,
+                                 @NonNull ItemHolderInfo postInfo) {
         endAnimation(oldHolder);
         endAnimation(newHolder);
 
@@ -246,7 +247,7 @@ public class ItemAnimator extends SimpleItemAnimator {
 
     @Override
     public boolean animateChange(ViewHolder oldHolder,
-            ViewHolder newHolder, int fromLeft, int fromTop, int toLeft, int toTop) {
+                                 ViewHolder newHolder, int fromLeft, int fromTop, int toLeft, int toTop) {
         /* Unused */
         throw new IllegalStateException("This method should not be used");
     }
@@ -289,7 +290,7 @@ public class ItemAnimator extends SimpleItemAnimator {
     }
 
     @Override
-    public void endAnimation(ViewHolder holder) {
+    public void endAnimation(@NonNull ViewHolder holder) {
         final Animator animator = mAnimators.get(holder);
 
         mAnimators.remove(holder);
@@ -326,9 +327,10 @@ public class ItemAnimator extends SimpleItemAnimator {
     }
 
     @Override
-    public @NonNull ItemHolderInfo recordPreLayoutInformation(@NonNull State state,
-            @NonNull ViewHolder viewHolder, @AdapterChanges int changeFlags,
-            @NonNull List<Object> payloads) {
+    public @NonNull
+    ItemHolderInfo recordPreLayoutInformation(@NonNull State state,
+                                              @NonNull ViewHolder viewHolder, @AdapterChanges int changeFlags,
+                                              @NonNull List<Object> payloads) {
         final ItemHolderInfo itemHolderInfo = super.recordPreLayoutInformation(state, viewHolder,
                 changeFlags, payloads);
         if (itemHolderInfo instanceof PayloadItemHolderInfo) {
@@ -337,6 +339,7 @@ public class ItemAnimator extends SimpleItemAnimator {
         return itemHolderInfo;
     }
 
+    @NonNull
     @Override
     public ItemHolderInfo obtainHolderInfo() {
         return new PayloadItemHolderInfo();
@@ -344,28 +347,29 @@ public class ItemAnimator extends SimpleItemAnimator {
 
     @Override
     public boolean canReuseUpdatedViewHolder(@NonNull ViewHolder viewHolder,
-            @NonNull List<Object> payloads) {
+                                             @NonNull List<Object> payloads) {
         final boolean defaultReusePolicy = super.canReuseUpdatedViewHolder(viewHolder, payloads);
         // Whenever we have a payload, this is an in-place animation.
         return !payloads.isEmpty() || defaultReusePolicy;
     }
 
+    public interface OnAnimateChangeListener {
+        Animator onAnimateChange(ViewHolder oldHolder, ViewHolder newHolder, long duration);
+
+        Animator onAnimateChange(List<Object> payloads, int fromLeft, int fromTop, int fromRight,
+                                 int fromBottom, long duration);
+    }
+
     private static final class PayloadItemHolderInfo extends ItemHolderInfo {
         private final List<Object> mPayloads = new ArrayList<>();
 
-        void setPayloads(List<Object> payloads) {
-            mPayloads.clear();
-            mPayloads.addAll(payloads);
-        }
-
         List<Object> getPayloads() {
             return mPayloads;
         }
-    }
 
-    public interface OnAnimateChangeListener {
-        Animator onAnimateChange(ViewHolder oldHolder, ViewHolder newHolder, long duration);
-        Animator onAnimateChange(List<Object> payloads, int fromLeft, int fromTop, int fromRight,
-                int fromBottom, long duration);
+        void setPayloads(List<Object> payloads) {
+            mPayloads.clear();
+            mPayloads.addAll(payloads);
+        }
     }
 }
diff --git a/src/com/android/deskclock/LabelDialogFragment.java b/app/src/main/java/com/best/deskclock/LabelDialogFragment.java
similarity index 93%
rename from src/com/android/deskclock/LabelDialogFragment.java
rename to app/src/main/java/com/best/deskclock/LabelDialogFragment.java
index 35c398da4..1fdcd36af 100644
--- a/src/com/android/deskclock/LabelDialogFragment.java
+++ b/app/src/main/java/com/best/deskclock/LabelDialogFragment.java
@@ -16,6 +16,8 @@
 
 package com.best.deskclock;
 
+import static android.view.WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE;
+
 import android.app.Dialog;
 import android.app.DialogFragment;
 import android.app.Fragment;
@@ -24,11 +26,7 @@ import android.app.FragmentTransaction;
 import android.content.Context;
 import android.content.DialogInterface;
 import android.content.res.ColorStateList;
-import android.graphics.Color;
 import android.os.Bundle;
-import androidx.annotation.NonNull;
-import androidx.appcompat.app.AlertDialog;
-import androidx.appcompat.widget.AppCompatEditText;
 import android.text.Editable;
 import android.text.InputType;
 import android.text.TextUtils;
@@ -38,12 +36,15 @@ import android.view.Window;
 import android.view.inputmethod.EditorInfo;
 import android.widget.TextView;
 
+import androidx.annotation.NonNull;
+import androidx.appcompat.app.AlertDialog;
+import androidx.appcompat.widget.AppCompatEditText;
 
 import com.best.deskclock.data.DataModel;
 import com.best.deskclock.data.Timer;
 import com.best.deskclock.provider.Alarm;
 
-import static android.view.WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE;
+import java.util.Objects;
 
 /**
  * DialogFragment to edit label.
@@ -114,7 +115,7 @@ public class LabelDialogFragment extends DialogFragment {
         super.onSaveInstanceState(outState);
         // As long as the label box exists, save its state.
         if (mLabelBox != null) {
-            outState.putString(ARG_LABEL, mLabelBox.getText().toString());
+            outState.putString(ARG_LABEL, Objects.requireNonNull(mLabelBox.getText()).toString());
         }
     }
 
@@ -138,14 +139,14 @@ public class LabelDialogFragment extends DialogFragment {
         final Context context = dialog.getContext();
 
         final int colorControlActivated =
-                ThemeUtils.resolveColor(context, R.attr.colorControlActivated);
+                ThemeUtils.resolveColor(context, androidx.appcompat.R.attr.colorControlActivated);
         final int colorControlNormal =
-                ThemeUtils.resolveColor(context, R.attr.colorControlNormal);
+                ThemeUtils.resolveColor(context, androidx.appcompat.R.attr.colorControlNormal);
 
         mLabelBox = new AppCompatEditText(context);
         mLabelBox.setSupportBackgroundTintList(new ColorStateList(
-                new int[][] { { android.R.attr.state_activated }, {} },
-                new int[] { colorControlActivated, colorControlNormal }));
+                new int[][]{{android.R.attr.state_activated}, {}},
+                new int[]{colorControlActivated, colorControlNormal}));
         mLabelBox.setOnEditorActionListener(new ImeDoneListener());
         mLabelBox.addTextChangedListener(new TextChangeListener());
         mLabelBox.setSingleLine();
@@ -178,7 +179,7 @@ public class LabelDialogFragment extends DialogFragment {
      * Sets the new label into the timer or alarm.
      */
     private void setLabel() {
-        String label = mLabelBox.getText().toString();
+        String label = Objects.requireNonNull(mLabelBox.getText()).toString();
         if (label.trim().isEmpty()) {
             // Don't allow user to input label with only whitespace.
             label = "";
diff --git a/src/com/android/deskclock/LogUtils.java b/app/src/main/java/com/best/deskclock/LogUtils.java
similarity index 84%
rename from src/com/android/deskclock/LogUtils.java
rename to app/src/main/java/com/best/deskclock/LogUtils.java
index 85a15925a..680b500aa 100644
--- a/src/com/android/deskclock/LogUtils.java
+++ b/app/src/main/java/com/best/deskclock/LogUtils.java
@@ -73,12 +73,29 @@ public class LogUtils {
             this.logTag = logTag;
         }
 
-        public boolean isVerboseLoggable() { return DEBUG || Log.isLoggable(logTag, Log.VERBOSE); }
-        public boolean isDebugLoggable() { return DEBUG || Log.isLoggable(logTag, Log.DEBUG); }
-        public boolean isInfoLoggable() { return DEBUG || Log.isLoggable(logTag, Log.INFO); }
-        public boolean isWarnLoggable() { return DEBUG || Log.isLoggable(logTag, Log.WARN); }
-        public boolean isErrorLoggable() { return DEBUG || Log.isLoggable(logTag, Log.ERROR); }
-        public boolean isWtfLoggable() { return DEBUG || Log.isLoggable(logTag, Log.ASSERT); }
+        public boolean isVerboseLoggable() {
+            return DEBUG || Log.isLoggable(logTag, Log.VERBOSE);
+        }
+
+        public boolean isDebugLoggable() {
+            return DEBUG || Log.isLoggable(logTag, Log.DEBUG);
+        }
+
+        public boolean isInfoLoggable() {
+            return DEBUG || Log.isLoggable(logTag, Log.INFO);
+        }
+
+        public boolean isWarnLoggable() {
+            return DEBUG || Log.isLoggable(logTag, Log.WARN);
+        }
+
+        public boolean isErrorLoggable() {
+            return DEBUG || Log.isLoggable(logTag, Log.ERROR);
+        }
+
+        public boolean isWtfLoggable() {
+            return DEBUG || Log.isLoggable(logTag, Log.ASSERT);
+        }
 
         public void v(String message, Object... args) {
             if (isVerboseLoggable()) {
diff --git a/src/com/android/deskclock/MoveScreensaverRunnable.java b/app/src/main/java/com/best/deskclock/MoveScreensaverRunnable.java
similarity index 90%
rename from src/com/android/deskclock/MoveScreensaverRunnable.java
rename to app/src/main/java/com/best/deskclock/MoveScreensaverRunnable.java
index 40bf0727a..1010c66af 100644
--- a/src/com/android/deskclock/MoveScreensaverRunnable.java
+++ b/app/src/main/java/com/best/deskclock/MoveScreensaverRunnable.java
@@ -16,6 +16,9 @@
 
 package com.best.deskclock;
 
+import static com.best.deskclock.AnimatorUtils.getAlphaAnimator;
+import static com.best.deskclock.AnimatorUtils.getScaleAnimator;
+
 import android.animation.Animator;
 import android.animation.AnimatorListenerAdapter;
 import android.animation.AnimatorSet;
@@ -26,9 +29,6 @@ import android.view.animation.Interpolator;
 
 import com.best.deskclock.uidata.UiDataModel;
 
-import static com.best.deskclock.AnimatorUtils.getAlphaAnimator;
-import static com.best.deskclock.AnimatorUtils.getScaleAnimator;
-
 /**
  * This runnable chooses a random initial position for {@link #mSaverView} within
  * {@link #mContentView} if {@link #mSaverView} is transparent. It also schedules itself to run
@@ -37,33 +37,52 @@ import static com.best.deskclock.AnimatorUtils.getScaleAnimator;
  */
 public final class MoveScreensaverRunnable implements Runnable {
 
-    /** The duration over which the fade in/out animations occur. */
+    /**
+     * The duration over which the fade in/out animations occur.
+     */
     private static final long FADE_TIME = 3000L;
 
-    /** Accelerate the hide animation. */
+    /**
+     * Accelerate the hide animation.
+     */
     private final Interpolator mAcceleration = new AccelerateInterpolator();
 
-    /** Decelerate the show animation. */
+    /**
+     * Decelerate the show animation.
+     */
     private final Interpolator mDeceleration = new DecelerateInterpolator();
 
-    /** The container that houses {@link #mSaverView}. */
+    /**
+     * The container that houses {@link #mSaverView}.
+     */
     private final View mContentView;
 
-    /** The display within the {@link #mContentView} that is randomly positioned. */
+    /**
+     * The display within the {@link #mContentView} that is randomly positioned.
+     */
     private final View mSaverView;
 
-    /** Tracks the currently executing animation if any; used to gracefully stop the animation. */
+    /**
+     * Tracks the currently executing animation if any; used to gracefully stop the animation.
+     */
     private Animator mActiveAnimator;
 
     /**
      * @param contentView contains the {@code saverView}
-     * @param saverView a child view of {@code contentView} that periodically moves around
+     * @param saverView   a child view of {@code contentView} that periodically moves around
      */
     public MoveScreensaverRunnable(View contentView, View saverView) {
         mContentView = contentView;
         mSaverView = saverView;
     }
 
+    /**
+     * @return a random integer between 0 and the {@code maximum} exclusive.
+     */
+    private static float getRandomPoint(float maximum) {
+        return (int) (Math.random() * maximum);
+    }
+
     /**
      * Start or restart the random movement of the saver view within the content view.
      */
@@ -113,7 +132,6 @@ public final class MoveScreensaverRunnable implements Runnable {
             mActiveAnimator = getAlphaAnimator(mSaverView, 0f, 1f);
             mActiveAnimator.setDuration(FADE_TIME);
             mActiveAnimator.setInterpolator(mDeceleration);
-            mActiveAnimator.start();
         } else {
             // Select a new random position anywhere in mContentView that will fit mSaverView.
             final float newX = getRandomPoint(mContentView.getWidth() - mSaverView.getWidth());
@@ -144,14 +162,7 @@ public final class MoveScreensaverRunnable implements Runnable {
             final AnimatorSet all = new AnimatorSet();
             all.play(show).after(hide);
             mActiveAnimator = all;
-            mActiveAnimator.start();
         }
-    }
-
-    /**
-     * @return a random integer between 0 and the {@code maximum} exclusive.
-     */
-    private static float getRandomPoint(float maximum) {
-        return (int) (Math.random() * maximum);
+        mActiveAnimator.start();
     }
 }
diff --git a/src/com/android/deskclock/NotificationUtils.java b/app/src/main/java/com/best/deskclock/NotificationUtils.java
similarity index 94%
rename from src/com/android/deskclock/NotificationUtils.java
rename to app/src/main/java/com/best/deskclock/NotificationUtils.java
index f54c92159..c1b21bbd5 100644
--- a/src/com/android/deskclock/NotificationUtils.java
+++ b/app/src/main/java/com/best/deskclock/NotificationUtils.java
@@ -16,7 +16,6 @@
 
 package com.best.deskclock;
 
-import static androidx.core.app.NotificationManagerCompat.IMPORTANCE_DEFAULT;
 import static androidx.core.app.NotificationManagerCompat.IMPORTANCE_HIGH;
 import static androidx.core.app.NotificationManagerCompat.IMPORTANCE_LOW;
 
@@ -24,48 +23,41 @@ import android.app.NotificationChannel;
 import android.content.Context;
 import android.util.ArraySet;
 import android.util.Log;
-import androidx.core.app.NotificationManagerCompat;
 
-import com.best.deskclock.Utils;
+import androidx.core.app.NotificationManagerCompat;
 
 import java.util.HashMap;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Set;
 
 public class NotificationUtils {
 
-    private static final String TAG = NotificationUtils.class.getSimpleName();
-
     /**
      * Notification channel containing all missed alarm notifications.
      */
     public static final String ALARM_MISSED_NOTIFICATION_CHANNEL_ID = "alarmMissedNotification";
-
     /**
      * Notification channel containing all upcoming alarm notifications.
      */
     public static final String ALARM_UPCOMING_NOTIFICATION_CHANNEL_ID = "alarmUpcomingNotification";
-
     /**
      * Notification channel containing all snooze notifications.
      */
     public static final String ALARM_SNOOZE_NOTIFICATION_CHANNEL_ID = "alarmSnoozingNotification";
-
     /**
      * Notification channel containing all firing alarm and timer notifications.
      */
     public static final String FIRING_NOTIFICATION_CHANNEL_ID = "firingAlarmsAndTimersNotification";
-
     /**
      * Notification channel containing all TimerModel notifications.
      */
     public static final String TIMER_MODEL_NOTIFICATION_CHANNEL_ID = "timerNotification";
-
     /**
      * Notification channel containing all stopwatch notifications.
      */
     public static final String STOPWATCH_NOTIFICATION_CHANNEL_ID = "stopwatchNotification";
-
+    private static final String TAG = NotificationUtils.class.getSimpleName();
     /**
      * Values used to bitmask certain channel defaults
      */
@@ -73,7 +65,8 @@ public class NotificationUtils {
     private static final int ENABLE_LIGHTS = 0x02;
     private static final int ENABLE_VIBRATION = 0x04;
 
-    private static Map<String, int[]> CHANNEL_PROPS = new HashMap<String, int[]>();
+    private static final Map<String, int[]> CHANNEL_PROPS = new HashMap<String, int[]>();
+
     static {
         CHANNEL_PROPS.put(ALARM_MISSED_NOTIFICATION_CHANNEL_ID, new int[]{
                 R.string.alarm_missed_channel,
@@ -103,7 +96,7 @@ public class NotificationUtils {
     }
 
     public static void createChannel(Context context, String id) {
-        if (!Utils.isOOrLater()) {
+        if (Utils.isOOrLater()) {
             return;
         }
 
@@ -112,8 +105,8 @@ public class NotificationUtils {
             return;
         }
 
-        int[] properties = (int[]) CHANNEL_PROPS.get(id);
-        int nameId = properties[0];
+        int[] properties = CHANNEL_PROPS.get(id);
+        int nameId = Objects.requireNonNull(properties)[0];
         int importance = properties[1];
         NotificationChannel channel = new NotificationChannel(
                 id, context.getString(nameId), importance);
@@ -145,7 +138,7 @@ public class NotificationUtils {
     }
 
     public static void updateNotificationChannels(Context context) {
-        if (!Utils.isOOrLater()) {
+        if (Utils.isOOrLater()) {
             return;
         }
 
diff --git a/src/com/android/deskclock/Predicate.java b/app/src/main/java/com/best/deskclock/Predicate.java
similarity index 99%
rename from src/com/android/deskclock/Predicate.java
rename to app/src/main/java/com/best/deskclock/Predicate.java
index 35fc391af..eaab7fb72 100644
--- a/src/com/android/deskclock/Predicate.java
+++ b/app/src/main/java/com/best/deskclock/Predicate.java
@@ -28,8 +28,6 @@ package com.best.deskclock;
  */
 public interface Predicate<T> {
 
-    boolean apply(T t);
-
     /**
      * An implementation of the predicate interface that always returns true.
      */
@@ -39,7 +37,6 @@ public interface Predicate<T> {
             return true;
         }
     };
-
     /**
      * An implementation of the predicate interface that always returns false.
      */
@@ -49,4 +46,6 @@ public interface Predicate<T> {
             return false;
         }
     };
+
+    boolean apply(T t);
 }
diff --git a/src/com/android/deskclock/RingtonePreviewKlaxon.java b/app/src/main/java/com/best/deskclock/RingtonePreviewKlaxon.java
similarity index 100%
rename from src/com/android/deskclock/RingtonePreviewKlaxon.java
rename to app/src/main/java/com/best/deskclock/RingtonePreviewKlaxon.java
diff --git a/src/com/android/deskclock/Screensaver.java b/app/src/main/java/com/best/deskclock/Screensaver.java
similarity index 97%
rename from src/com/android/deskclock/Screensaver.java
rename to app/src/main/java/com/best/deskclock/Screensaver.java
index 64cbdfc6d..b97bd17fb 100644
--- a/src/com/android/deskclock/Screensaver.java
+++ b/app/src/main/java/com/best/deskclock/Screensaver.java
@@ -45,10 +45,6 @@ public final class Screensaver extends DreamService {
     private String mDateFormatForAccessibility;
 
     private View mContentView;
-    private View mMainClockView;
-    private TextClock mDigitalClock;
-    private AnalogClock mAnalogClock;
-
     /* Register ContentObserver to see alarm changes for pre-L */
     private final ContentObserver mSettingsContentObserver =
             Utils.isLOrLater() ? null : new ContentObserver(new Handler()) {
@@ -57,7 +53,6 @@ public final class Screensaver extends DreamService {
                     Utils.refreshAlarm(Screensaver.this, mContentView);
                 }
             };
-
     // Runs every midnight or when the time changes and refreshes the date.
     private final Runnable mMidnightUpdater = new Runnable() {
         @Override
@@ -65,7 +60,6 @@ public final class Screensaver extends DreamService {
             Utils.updateDate(mDateFormat, mDateFormatForAccessibility, mContentView);
         }
     };
-
     /**
      * Receiver to alarm clock changes.
      */
@@ -75,6 +69,9 @@ public final class Screensaver extends DreamService {
             Utils.refreshAlarm(Screensaver.this, mContentView);
         }
     };
+    private View mMainClockView;
+    private TextClock mDigitalClock;
+    private AnalogClock mAnalogClock;
 
     @Override
     public void onCreate() {
@@ -96,8 +93,8 @@ public final class Screensaver extends DreamService {
 
         mContentView = findViewById(R.id.saver_container);
         mMainClockView = mContentView.findViewById(R.id.main_clock);
-        mDigitalClock = (TextClock) mMainClockView.findViewById(R.id.digital_clock);
-        mAnalogClock = (AnalogClock) mMainClockView.findViewById(R.id.analog_clock);
+        mDigitalClock = mMainClockView.findViewById(R.id.digital_clock);
+        mAnalogClock = mMainClockView.findViewById(R.id.analog_clock);
 
         setClockStyle();
         Utils.setClockIconTypeface(mContentView);
@@ -123,7 +120,6 @@ public final class Screensaver extends DreamService {
         }
 
         if (mSettingsContentObserver != null) {
-            @SuppressWarnings("deprecation")
             final Uri uri = Settings.System.getUriFor(Settings.System.NEXT_ALARM_FORMATTED);
             getContentResolver().registerContentObserver(uri, false, mSettingsContentObserver);
         }
diff --git a/src/com/android/deskclock/ScreensaverActivity.java b/app/src/main/java/com/best/deskclock/ScreensaverActivity.java
similarity index 95%
rename from src/com/android/deskclock/ScreensaverActivity.java
rename to app/src/main/java/com/best/deskclock/ScreensaverActivity.java
index 7abc0a3b5..ecf4cfa68 100644
--- a/src/com/android/deskclock/ScreensaverActivity.java
+++ b/app/src/main/java/com/best/deskclock/ScreensaverActivity.java
@@ -16,6 +16,9 @@
 
 package com.best.deskclock;
 
+import static android.content.Intent.ACTION_BATTERY_CHANGED;
+import static android.os.BatteryManager.EXTRA_PLUGGED;
+
 import android.app.AlarmManager;
 import android.content.BroadcastReceiver;
 import android.content.Context;
@@ -35,21 +38,22 @@ import android.widget.TextClock;
 import com.best.deskclock.events.Events;
 import com.best.deskclock.uidata.UiDataModel;
 
-import static android.content.Intent.ACTION_BATTERY_CHANGED;
-import static android.os.BatteryManager.EXTRA_PLUGGED;
-
 public class ScreensaverActivity extends BaseActivity {
 
     private static final LogUtils.Logger LOGGER = new LogUtils.Logger("ScreensaverActivity");
 
-    /** These flags keep the screen on if the device is plugged in. */
+    /**
+     * These flags keep the screen on if the device is plugged in.
+     */
     private static final int WINDOW_FLAGS = WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD
             | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED
             | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON
             | WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;
 
     private final OnPreDrawListener mStartPositionUpdater = new StartPositionUpdater();
-
+    private String mDateFormat;
+    private String mDateFormatForAccessibility;
+    private View mContentView;
     private final BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {
         @Override
         public void onReceive(Context context, Intent intent) {
@@ -71,17 +75,15 @@ public class ScreensaverActivity extends BaseActivity {
             }
         }
     };
-
     /* Register ContentObserver to see alarm changes for pre-L */
     private final ContentObserver mSettingsContentObserver = Utils.isPreL()
-        ? new ContentObserver(new Handler()) {
-            @Override
-            public void onChange(boolean selfChange) {
-                Utils.refreshAlarm(ScreensaverActivity.this, mContentView);
-            }
+            ? new ContentObserver(new Handler()) {
+        @Override
+        public void onChange(boolean selfChange) {
+            Utils.refreshAlarm(ScreensaverActivity.this, mContentView);
         }
-        : null;
-
+    }
+            : null;
     // Runs every midnight or when the time changes and refreshes the date.
     private final Runnable mMidnightUpdater = new Runnable() {
         @Override
@@ -89,11 +91,6 @@ public class ScreensaverActivity extends BaseActivity {
             Utils.updateDate(mDateFormat, mDateFormatForAccessibility, mContentView);
         }
     };
-
-    private String mDateFormat;
-    private String mDateFormatForAccessibility;
-
-    private View mContentView;
     private View mMainClockView;
 
     private MoveScreensaverRunnable mPositionUpdater;
@@ -111,7 +108,7 @@ public class ScreensaverActivity extends BaseActivity {
 
         final View digitalClock = mMainClockView.findViewById(R.id.digital_clock);
         final AnalogClock analogClock =
-                (AnalogClock) mMainClockView.findViewById(R.id.analog_clock);
+                mMainClockView.findViewById(R.id.analog_clock);
 
         Utils.setClockIconTypeface(mMainClockView);
         Utils.setTimeFormat((TextClock) digitalClock, false);
@@ -149,7 +146,6 @@ public class ScreensaverActivity extends BaseActivity {
         registerReceiver(mIntentReceiver, filter);
 
         if (mSettingsContentObserver != null) {
-            @SuppressWarnings("deprecation")
             final Uri uri = Settings.System.getUriFor(Settings.System.NEXT_ALARM_FORMATTED);
             getContentResolver().registerContentObserver(uri, false, mSettingsContentObserver);
         }
diff --git a/src/com/android/deskclock/StopwatchTextController.java b/app/src/main/java/com/best/deskclock/StopwatchTextController.java
similarity index 100%
rename from src/com/android/deskclock/StopwatchTextController.java
rename to app/src/main/java/com/best/deskclock/StopwatchTextController.java
index 0fc8be659..8da1bb500 100644
--- a/src/com/android/deskclock/StopwatchTextController.java
+++ b/app/src/main/java/com/best/deskclock/StopwatchTextController.java
@@ -16,15 +16,15 @@
 
 package com.best.deskclock;
 
+import static android.text.format.DateUtils.HOUR_IN_MILLIS;
+import static android.text.format.DateUtils.MINUTE_IN_MILLIS;
+import static android.text.format.DateUtils.SECOND_IN_MILLIS;
+
 import android.content.Context;
 import android.widget.TextView;
 
 import com.best.deskclock.uidata.UiDataModel;
 
-import static android.text.format.DateUtils.HOUR_IN_MILLIS;
-import static android.text.format.DateUtils.MINUTE_IN_MILLIS;
-import static android.text.format.DateUtils.SECOND_IN_MILLIS;
-
 /**
  * A controller which will format a provided time in millis to display as a stopwatch.
  */
diff --git a/src/com/android/deskclock/ThemeUtils.java b/app/src/main/java/com/best/deskclock/ThemeUtils.java
similarity index 97%
rename from src/com/android/deskclock/ThemeUtils.java
rename to app/src/main/java/com/best/deskclock/ThemeUtils.java
index de97306e1..d6cb10024 100644
--- a/src/com/android/deskclock/ThemeUtils.java
+++ b/app/src/main/java/com/best/deskclock/ThemeUtils.java
@@ -21,12 +21,15 @@ import android.content.res.ColorStateList;
 import android.content.res.TypedArray;
 import android.graphics.Color;
 import android.graphics.drawable.Drawable;
+
 import androidx.annotation.AttrRes;
 import androidx.annotation.ColorInt;
 
 public final class ThemeUtils {
 
-    /** Temporary array used internally to resolve attributes. */
+    /**
+     * Temporary array used internally to resolve attributes.
+     */
     private static final int[] TEMP_ATTR = new int[1];
 
     private ThemeUtils() {
diff --git a/src/com/android/deskclock/TimerCircleFrameLayout.java b/app/src/main/java/com/best/deskclock/TimerCircleFrameLayout.java
similarity index 97%
rename from src/com/android/deskclock/TimerCircleFrameLayout.java
rename to app/src/main/java/com/best/deskclock/TimerCircleFrameLayout.java
index 38254d078..e0e94abfe 100644
--- a/src/com/android/deskclock/TimerCircleFrameLayout.java
+++ b/app/src/main/java/com/best/deskclock/TimerCircleFrameLayout.java
@@ -43,7 +43,7 @@ public class TimerCircleFrameLayout extends FrameLayout {
      * Note: this method assumes the parent container will specify {@link MeasureSpec#EXACTLY exact}
      * width and height values.
      *
-     * @param widthMeasureSpec horizontal space requirements as imposed by the parent
+     * @param widthMeasureSpec  horizontal space requirements as imposed by the parent
      * @param heightMeasureSpec vertical space requirements as imposed by the parent
      */
     @Override
diff --git a/src/com/android/deskclock/TimerTextController.java b/app/src/main/java/com/best/deskclock/TimerTextController.java
similarity index 100%
rename from src/com/android/deskclock/TimerTextController.java
rename to app/src/main/java/com/best/deskclock/TimerTextController.java
index 919a71003..de568514e 100644
--- a/src/com/android/deskclock/TimerTextController.java
+++ b/app/src/main/java/com/best/deskclock/TimerTextController.java
@@ -16,12 +16,12 @@
 
 package com.best.deskclock;
 
-import android.widget.TextView;
-
 import static android.text.format.DateUtils.HOUR_IN_MILLIS;
 import static android.text.format.DateUtils.MINUTE_IN_MILLIS;
 import static android.text.format.DateUtils.SECOND_IN_MILLIS;
 
+import android.widget.TextView;
+
 /**
  * A controller which will format a provided time in millis to display as a timer.
  */
diff --git a/src/com/android/deskclock/Utils.java b/app/src/main/java/com/best/deskclock/Utils.java
similarity index 94%
rename from src/com/android/deskclock/Utils.java
rename to app/src/main/java/com/best/deskclock/Utils.java
index 9410dfecb..f86201023 100644
--- a/src/com/android/deskclock/Utils.java
+++ b/app/src/main/java/com/best/deskclock/Utils.java
@@ -16,6 +16,13 @@
 
 package com.best.deskclock;
 
+import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
+import static android.appwidget.AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY;
+import static android.appwidget.AppWidgetProviderInfo.WIDGET_CATEGORY_KEYGUARD;
+import static android.content.res.Configuration.ORIENTATION_LANDSCAPE;
+import static android.content.res.Configuration.ORIENTATION_PORTRAIT;
+import static android.graphics.Bitmap.Config.ARGB_8888;
+
 import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.app.AlarmManager;
@@ -37,14 +44,6 @@ import android.os.Build;
 import android.os.Bundle;
 import android.os.Looper;
 import android.provider.Settings;
-import androidx.annotation.AnyRes;
-import androidx.annotation.DrawableRes;
-import androidx.annotation.StringRes;
-import androidx.vectordrawable.graphics.drawable.VectorDrawableCompat;
-import androidx.core.os.BuildCompat;
-import androidx.core.view.AccessibilityDelegateCompat;
-import androidx.core.view.accessibility.AccessibilityNodeInfoCompat;
-import androidx.core.view.accessibility.AccessibilityNodeInfoCompat.AccessibilityActionCompat;
 import android.text.Spannable;
 import android.text.SpannableString;
 import android.text.TextUtils;
@@ -58,6 +57,15 @@ import android.view.View;
 import android.widget.TextClock;
 import android.widget.TextView;
 
+import androidx.annotation.AnyRes;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.NonNull;
+import androidx.annotation.StringRes;
+import androidx.core.view.AccessibilityDelegateCompat;
+import androidx.core.view.accessibility.AccessibilityNodeInfoCompat;
+import androidx.core.view.accessibility.AccessibilityNodeInfoCompat.AccessibilityActionCompat;
+import androidx.vectordrawable.graphics.drawable.VectorDrawableCompat;
+
 import com.best.deskclock.data.DataModel;
 import com.best.deskclock.provider.AlarmInstance;
 import com.best.deskclock.uidata.UiDataModel;
@@ -70,13 +78,6 @@ import java.util.Date;
 import java.util.Locale;
 import java.util.TimeZone;
 
-import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
-import static android.appwidget.AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY;
-import static android.appwidget.AppWidgetProviderInfo.WIDGET_CATEGORY_KEYGUARD;
-import static android.content.res.Configuration.ORIENTATION_LANDSCAPE;
-import static android.content.res.Configuration.ORIENTATION_PORTRAIT;
-import static android.graphics.Bitmap.Config.ARGB_8888;
-
 public class Utils {
 
     /**
@@ -146,21 +147,21 @@ public class Utils {
      * @return {@code true} if the device is {@link Build.VERSION_CODES#N} or later
      */
     public static boolean isNOrLater() {
-        return BuildCompat.isAtLeastN();
+        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.N;
     }
 
     /**
      * @return {@code true} if the device is {@link Build.VERSION_CODES#N_MR1} or later
      */
     public static boolean isNMR1OrLater() {
-        return BuildCompat.isAtLeastNMR1();
+        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.N_MR1;
     }
 
     /**
      * @return {@code true} if the device is {@link Build.VERSION_CODES#O} or later
      */
     public static boolean isOOrLater() {
-        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.O;
+        return Build.VERSION.SDK_INT < Build.VERSION_CODES.O;
     }
 
     /**
@@ -294,8 +295,6 @@ public class Utils {
         return isPreL() ? getNextAlarmPreL(context) : getNextAlarmLOrLater(context);
     }
 
-    @SuppressWarnings("deprecation")
-    @TargetApi(Build.VERSION_CODES.KITKAT)
     private static String getNextAlarmPreL(Context context) {
         final ContentResolver cr = context.getContentResolver();
         return Settings.System.getString(cr, Settings.System.NEXT_ALARM_FORMATTED);
@@ -335,8 +334,8 @@ public class Utils {
      * Clock views can call this to refresh their alarm to the next upcoming value.
      */
     public static void refreshAlarm(Context context, View clock) {
-        final TextView nextAlarmIconView = (TextView) clock.findViewById(R.id.nextAlarmIcon);
-        final TextView nextAlarmView = (TextView) clock.findViewById(R.id.nextAlarm);
+        final TextView nextAlarmIconView = clock.findViewById(R.id.nextAlarmIcon);
+        final TextView nextAlarmView = clock.findViewById(R.id.nextAlarm);
         if (nextAlarmView == null) {
             return;
         }
@@ -356,7 +355,7 @@ public class Utils {
     }
 
     public static void setClockIconTypeface(View clock) {
-        final TextView nextAlarmIconView = (TextView) clock.findViewById(R.id.nextAlarmIcon);
+        final TextView nextAlarmIconView = clock.findViewById(R.id.nextAlarmIcon);
         nextAlarmIconView.setTypeface(UiDataModel.getUiDataModel().getAlarmIconTypeface());
     }
 
@@ -364,7 +363,7 @@ public class Utils {
      * Clock views can call this to refresh their date.
      **/
     public static void updateDate(String dateSkeleton, String descriptionSkeleton, View clock) {
-        final TextView dateDisplay = (TextView) clock.findViewById(R.id.date);
+        final TextView dateDisplay = clock.findViewById(R.id.date);
         if (dateDisplay == null) {
             return;
         }
@@ -551,15 +550,15 @@ public class Utils {
     }
 
     /**
-     * @param context to obtain strings.
-     * @param displayMinutes whether or not minutes should be included
-     * @param isAhead {@code true} if the time should be marked 'ahead', else 'behind'
-     * @param hoursDifferent the number of hours the time is ahead/behind
+     * @param context          to obtain strings.
+     * @param displayMinutes   whether or not minutes should be included
+     * @param isAhead          {@code true} if the time should be marked 'ahead', else 'behind'
+     * @param hoursDifferent   the number of hours the time is ahead/behind
      * @param minutesDifferent the number of minutes the time is ahead/behind
      * @return String describing the hours/minutes ahead or behind
      */
     public static String createHoursDifferentString(Context context, boolean displayMinutes,
-            boolean isAhead, int hoursDifferent, int minutesDifferent) {
+                                                    boolean isAhead, int hoursDifferent, int minutesDifferent) {
         String timeString;
         if (displayMinutes && hoursDifferent != 0) {
             // Both minutes and hours
@@ -590,7 +589,7 @@ public class Utils {
 
     /**
      * @param context The context from which to obtain strings
-     * @param hours Hours to display (if any)
+     * @param hours   Hours to display (if any)
      * @param minutes Minutes to display (if any)
      * @param seconds Seconds to display
      * @return Provided time formatted as a String
@@ -607,10 +606,14 @@ public class Utils {
 
     public static final class ClickAccessibilityDelegate extends AccessibilityDelegateCompat {
 
-        /** The label for talkback to apply to the view */
+        /**
+         * The label for talkback to apply to the view
+         */
         private final String mLabel;
 
-        /** Whether or not to always make the view visible to talkback */
+        /**
+         * Whether or not to always make the view visible to talkback
+         */
         private final boolean mIsAlwaysAccessibilityVisible;
 
         public ClickAccessibilityDelegate(String label) {
@@ -623,7 +626,7 @@ public class Utils {
         }
 
         @Override
-        public void onInitializeAccessibilityNodeInfo(View host, AccessibilityNodeInfoCompat info) {
+        public void onInitializeAccessibilityNodeInfo(@NonNull View host, @NonNull AccessibilityNodeInfoCompat info) {
             super.onInitializeAccessibilityNodeInfo(host, info);
             if (mIsAlwaysAccessibilityVisible) {
                 info.setVisibleToUser(true);
diff --git a/src/com/android/deskclock/VerticalViewPager.java b/app/src/main/java/com/best/deskclock/VerticalViewPager.java
similarity index 99%
rename from src/com/android/deskclock/VerticalViewPager.java
rename to app/src/main/java/com/best/deskclock/VerticalViewPager.java
index 8421d1514..b56a848fd 100644
--- a/src/com/android/deskclock/VerticalViewPager.java
+++ b/app/src/main/java/com/best/deskclock/VerticalViewPager.java
@@ -17,11 +17,12 @@
 package com.best.deskclock;
 
 import android.content.Context;
-import androidx.viewpager.widget.ViewPager;
 import android.util.AttributeSet;
 import android.view.MotionEvent;
 import android.view.View;
 
+import androidx.viewpager.widget.ViewPager;
+
 public class VerticalViewPager extends ViewPager {
 
     public VerticalViewPager(Context context) {
diff --git a/src/com/android/deskclock/actionbarmenu/MenuItemController.java b/app/src/main/java/com/best/deskclock/actionbarmenu/MenuItemController.java
similarity index 100%
rename from src/com/android/deskclock/actionbarmenu/MenuItemController.java
rename to app/src/main/java/com/best/deskclock/actionbarmenu/MenuItemController.java
diff --git a/src/com/android/deskclock/actionbarmenu/MenuItemControllerFactory.java b/app/src/main/java/com/best/deskclock/actionbarmenu/MenuItemControllerFactory.java
similarity index 99%
rename from src/com/android/deskclock/actionbarmenu/MenuItemControllerFactory.java
rename to app/src/main/java/com/best/deskclock/actionbarmenu/MenuItemControllerFactory.java
index ebcbfa797..9fd60db6a 100644
--- a/src/com/android/deskclock/actionbarmenu/MenuItemControllerFactory.java
+++ b/app/src/main/java/com/best/deskclock/actionbarmenu/MenuItemControllerFactory.java
@@ -27,17 +27,16 @@ import java.util.List;
 public final class MenuItemControllerFactory {
 
     private static final MenuItemControllerFactory INSTANCE = new MenuItemControllerFactory();
-
-    public static MenuItemControllerFactory getInstance() {
-        return INSTANCE;
-    }
-
     private final List<MenuItemProvider> mMenuItemProviders;
 
     private MenuItemControllerFactory() {
         mMenuItemProviders = new ArrayList<>();
     }
 
+    public static MenuItemControllerFactory getInstance() {
+        return INSTANCE;
+    }
+
     public MenuItemControllerFactory addMenuItemProvider(MenuItemProvider provider) {
         mMenuItemProviders.add(provider);
         return this;
diff --git a/src/com/android/deskclock/actionbarmenu/MenuItemProvider.java b/app/src/main/java/com/best/deskclock/actionbarmenu/MenuItemProvider.java
similarity index 100%
rename from src/com/android/deskclock/actionbarmenu/MenuItemProvider.java
rename to app/src/main/java/com/best/deskclock/actionbarmenu/MenuItemProvider.java
diff --git a/src/com/android/deskclock/actionbarmenu/NavUpMenuItemController.java b/app/src/main/java/com/best/deskclock/actionbarmenu/NavUpMenuItemController.java
similarity index 100%
rename from src/com/android/deskclock/actionbarmenu/NavUpMenuItemController.java
rename to app/src/main/java/com/best/deskclock/actionbarmenu/NavUpMenuItemController.java
diff --git a/src/com/android/deskclock/actionbarmenu/NightModeMenuItemController.java b/app/src/main/java/com/best/deskclock/actionbarmenu/NightModeMenuItemController.java
similarity index 100%
rename from src/com/android/deskclock/actionbarmenu/NightModeMenuItemController.java
rename to app/src/main/java/com/best/deskclock/actionbarmenu/NightModeMenuItemController.java
index 15b2557f5..90be36934 100644
--- a/src/com/android/deskclock/actionbarmenu/NightModeMenuItemController.java
+++ b/app/src/main/java/com/best/deskclock/actionbarmenu/NightModeMenuItemController.java
@@ -15,6 +15,8 @@
  */
 package com.best.deskclock.actionbarmenu;
 
+import static android.view.Menu.NONE;
+
 import android.content.Context;
 import android.content.Intent;
 import android.view.Menu;
@@ -24,8 +26,6 @@ import com.best.deskclock.R;
 import com.best.deskclock.ScreensaverActivity;
 import com.best.deskclock.events.Events;
 
-import static android.view.Menu.NONE;
-
 /**
  * {@link MenuItemController} for controlling night mode display.
  */
diff --git a/src/com/android/deskclock/actionbarmenu/OptionsMenuManager.java b/app/src/main/java/com/best/deskclock/actionbarmenu/OptionsMenuManager.java
similarity index 96%
rename from src/com/android/deskclock/actionbarmenu/OptionsMenuManager.java
rename to app/src/main/java/com/best/deskclock/actionbarmenu/OptionsMenuManager.java
index 114af366e..b8b336969 100644
--- a/src/com/android/deskclock/actionbarmenu/OptionsMenuManager.java
+++ b/app/src/main/java/com/best/deskclock/actionbarmenu/OptionsMenuManager.java
@@ -17,7 +17,6 @@
 package com.best.deskclock.actionbarmenu;
 
 import android.app.Activity;
-import android.os.Bundle;
 import android.view.Menu;
 import android.view.MenuItem;
 
@@ -36,7 +35,7 @@ public final class OptionsMenuManager {
     /**
      * Add one or more {@link MenuItemController} to the actionbar menu.
      * <p/>
-     * This should be called in {@link Activity#onCreate(Bundle)}.
+     * This should be called in {link Activity#onCreate(Bundle)}.
      */
     public OptionsMenuManager addMenuItemController(MenuItemController... controllers) {
         Collections.addAll(mControllers, controllers);
diff --git a/src/com/android/deskclock/actionbarmenu/SearchMenuItemController.java b/app/src/main/java/com/best/deskclock/actionbarmenu/SearchMenuItemController.java
similarity index 98%
rename from src/com/android/deskclock/actionbarmenu/SearchMenuItemController.java
rename to app/src/main/java/com/best/deskclock/actionbarmenu/SearchMenuItemController.java
index f9103db57..ea4fbfa06 100644
--- a/src/com/android/deskclock/actionbarmenu/SearchMenuItemController.java
+++ b/app/src/main/java/com/best/deskclock/actionbarmenu/SearchMenuItemController.java
@@ -16,20 +16,21 @@
 
 package com.best.deskclock.actionbarmenu;
 
+import static android.view.Menu.FIRST;
+import static android.view.Menu.NONE;
+
 import android.content.Context;
 import android.os.Bundle;
-import androidx.appcompat.widget.SearchView;
-import androidx.appcompat.widget.SearchView.OnQueryTextListener;
 import android.text.InputType;
 import android.view.Menu;
 import android.view.MenuItem;
 import android.view.View;
 import android.view.inputmethod.EditorInfo;
 
-import com.best.deskclock.R;
+import androidx.appcompat.widget.SearchView;
+import androidx.appcompat.widget.SearchView.OnQueryTextListener;
 
-import static android.view.Menu.FIRST;
-import static android.view.Menu.NONE;
+import com.best.deskclock.R;
 
 /**
  * {@link MenuItemController} for search menu.
@@ -49,7 +50,7 @@ public final class SearchMenuItemController implements MenuItemController {
     private boolean mSearchMode;
 
     public SearchMenuItemController(Context context, OnQueryTextListener queryListener,
-            Bundle savedState) {
+                                    Bundle savedState) {
         mContext = context;
         mSearchModeChangeListener = new SearchModeChangeListener();
         mQueryListener = queryListener;
diff --git a/src/com/android/deskclock/actionbarmenu/SettingsMenuItemController.java b/app/src/main/java/com/best/deskclock/actionbarmenu/SettingsMenuItemController.java
similarity index 100%
rename from src/com/android/deskclock/actionbarmenu/SettingsMenuItemController.java
rename to app/src/main/java/com/best/deskclock/actionbarmenu/SettingsMenuItemController.java
index 66325ccc9..0798c2530 100644
--- a/src/com/android/deskclock/actionbarmenu/SettingsMenuItemController.java
+++ b/app/src/main/java/com/best/deskclock/actionbarmenu/SettingsMenuItemController.java
@@ -16,6 +16,8 @@
 
 package com.best.deskclock.actionbarmenu;
 
+import static android.view.Menu.NONE;
+
 import android.app.Activity;
 import android.content.Intent;
 import android.view.Menu;
@@ -24,8 +26,6 @@ import android.view.MenuItem;
 import com.best.deskclock.R;
 import com.best.deskclock.settings.SettingsActivity;
 
-import static android.view.Menu.NONE;
-
 /**
  * {@link MenuItemController} for settings menu.
  */
diff --git a/src/com/android/deskclock/alarms/AlarmActivity.java b/app/src/main/java/com/best/deskclock/alarms/AlarmActivity.java
similarity index 91%
rename from src/com/android/deskclock/alarms/AlarmActivity.java
rename to app/src/main/java/com/best/deskclock/alarms/AlarmActivity.java
index 65860bf90..68c362cec 100644
--- a/src/com/android/deskclock/alarms/AlarmActivity.java
+++ b/app/src/main/java/com/best/deskclock/alarms/AlarmActivity.java
@@ -15,6 +15,8 @@
  */
 package com.best.deskclock.alarms;
 
+import static android.accessibilityservice.AccessibilityServiceInfo.FEEDBACK_GENERIC;
+
 import android.accessibilityservice.AccessibilityServiceInfo;
 import android.animation.Animator;
 import android.animation.AnimatorListenerAdapter;
@@ -37,9 +39,6 @@ import android.media.AudioManager;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.IBinder;
-import androidx.annotation.NonNull;
-import androidx.core.graphics.ColorUtils;
-import androidx.core.view.animation.PathInterpolatorCompat;
 import android.view.KeyEvent;
 import android.view.MotionEvent;
 import android.view.View;
@@ -50,6 +49,10 @@ import android.widget.ImageView;
 import android.widget.TextClock;
 import android.widget.TextView;
 
+import androidx.annotation.NonNull;
+import androidx.core.graphics.ColorUtils;
+import androidx.core.view.animation.PathInterpolatorCompat;
+
 import com.best.deskclock.AnimatorUtils;
 import com.best.deskclock.BaseActivity;
 import com.best.deskclock.LogUtils;
@@ -58,61 +61,28 @@ import com.best.deskclock.ThemeUtils;
 import com.best.deskclock.Utils;
 import com.best.deskclock.data.DataModel;
 import com.best.deskclock.data.DataModel.AlarmVolumeButtonBehavior;
+import com.best.deskclock.data.DataModel.ThemeButtonBehavior;
 import com.best.deskclock.events.Events;
 import com.best.deskclock.provider.AlarmInstance;
 import com.best.deskclock.widget.CircleView;
 
 import java.util.List;
 
-import static android.accessibilityservice.AccessibilityServiceInfo.FEEDBACK_GENERIC;
-
 public class AlarmActivity extends BaseActivity
         implements View.OnClickListener, View.OnTouchListener {
-
     private static final LogUtils.Logger LOGGER = new LogUtils.Logger("AlarmActivity");
-
     private static final TimeInterpolator PULSE_INTERPOLATOR =
             PathInterpolatorCompat.create(0.4f, 0.0f, 0.2f, 1.0f);
     private static final TimeInterpolator REVEAL_INTERPOLATOR =
             PathInterpolatorCompat.create(0.0f, 0.0f, 0.2f, 1.0f);
-
     private static final int PULSE_DURATION_MILLIS = 1000;
     private static final int ALARM_BOUNCE_DURATION_MILLIS = 500;
     private static final int ALERT_REVEAL_DURATION_MILLIS = 500;
     private static final int ALERT_FADE_DURATION_MILLIS = 500;
     private static final int ALERT_DISMISS_DELAY_MILLIS = 2000;
-
     private static final float BUTTON_SCALE_DEFAULT = 0.7f;
     private static final int BUTTON_DRAWABLE_ALPHA_DEFAULT = 165;
-
     private final Handler mHandler = new Handler();
-    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            final String action = intent.getAction();
-            LOGGER.v("Received broadcast: %s", action);
-
-            if (!mAlarmHandled) {
-                switch (action) {
-                    case AlarmService.ALARM_SNOOZE_ACTION:
-                        snooze();
-                        break;
-                    case AlarmService.ALARM_DISMISS_ACTION:
-                        dismiss();
-                        break;
-                    case AlarmService.ALARM_DONE_ACTION:
-                        finish();
-                        break;
-                    default:
-                        LOGGER.i("Unknown broadcast: %s", action);
-                        break;
-                }
-            } else {
-                LOGGER.v("Ignored broadcast: %s", action);
-            }
-        }
-    };
-
     private final ServiceConnection mConnection = new ServiceConnection() {
         @Override
         public void onServiceConnected(ComponentName name, IBinder service) {
@@ -124,37 +94,85 @@ public class AlarmActivity extends BaseActivity
             LOGGER.i("Disconnected from AlarmService");
         }
     };
-
+    private ThemeButtonBehavior mThemeBehavior;
     private AlarmInstance mAlarmInstance;
     private boolean mAlarmHandled;
     private AlarmVolumeButtonBehavior mVolumeBehavior;
     private AlarmVolumeButtonBehavior mPowerBehavior;
     private int mCurrentHourColor;
     private boolean mReceiverRegistered;
-    /** Whether the AlarmService is currently bound */
+    /**
+     * Whether the AlarmService is currently bound
+     */
     private boolean mServiceBound;
-
     private AccessibilityManager mAccessibilityManager;
-
     private ViewGroup mAlertView;
     private TextView mAlertTitleView;
     private TextView mAlertInfoView;
-
     private ViewGroup mContentView;
     private ImageView mAlarmButton;
     private ImageView mSnoozeButton;
     private ImageView mDismissButton;
     private TextView mHintView;
-
     private ValueAnimator mAlarmAnimator;
     private ValueAnimator mSnoozeAnimator;
     private ValueAnimator mDismissAnimator;
-    private ValueAnimator mPulseAnimator;
+    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            final String action = intent.getAction();
+            LOGGER.v("Received broadcast: %s", action);
 
+            if (!mAlarmHandled) {
+                switch (action) {
+                    case AlarmService.ALARM_SNOOZE_ACTION:
+                        snooze();
+                        break;
+                    case AlarmService.ALARM_DISMISS_ACTION:
+                        dismiss();
+                        break;
+                    case AlarmService.ALARM_DONE_ACTION:
+                        finish();
+                        break;
+                    default:
+                        LOGGER.i("Unknown broadcast: %s", action);
+                        break;
+                }
+            } else {
+                LOGGER.v("Ignored broadcast: %s", action);
+            }
+        }
+    };
+    private final BroadcastReceiver PowerBtnReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (intent != null && intent.getAction() != null) {
+                if (intent.getAction().equals(Intent.ACTION_SCREEN_OFF)
+                        || intent.getAction().equals(Intent.ACTION_SCREEN_ON)) {
+                    // Power keys dismiss the alarm.
+                    if (!mAlarmHandled) {
+                        if (mPowerBehavior == AlarmVolumeButtonBehavior.SNOOZE) {
+                            snooze();
+                        } else if (mPowerBehavior == AlarmVolumeButtonBehavior.DISMISS) {
+                            dismiss();
+                        }
+                    }
+                }
+            }
+        }
+    };
+    private ValueAnimator mPulseAnimator;
     private int mInitialPointerIndex = MotionEvent.INVALID_POINTER_ID;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
+        mThemeBehavior = DataModel.getDataModel().getThemeButtonBehavior();
+        if (mThemeBehavior == DataModel.ThemeButtonBehavior.DARK) {
+            getTheme().applyStyle(R.style.Theme_DeskClock_Wallpaper_Dark, true);
+        }
+        if (mThemeBehavior == DataModel.ThemeButtonBehavior.LIGHT) {
+            getTheme().applyStyle(R.style.Theme_DeskClock_Wallpaper_Light, true);
+        }
         super.onCreate(savedInstanceState);
         // Register Power button (screen off) intent receiver
 
@@ -181,8 +199,8 @@ public class AlarmActivity extends BaseActivity
 
         // Get the volume/camera button behavior setting
         mVolumeBehavior = DataModel.getDataModel().getAlarmVolumeButtonBehavior();
-        
-         // Get the power button behavior setting
+
+        // Get the power button behavior setting
         mPowerBehavior = DataModel.getDataModel().getAlarmPowerButtonBehavior();
 
         getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED
@@ -206,19 +224,21 @@ public class AlarmActivity extends BaseActivity
 
         setContentView(R.layout.alarm_activity);
 
-        mAlertView = (ViewGroup) findViewById(R.id.alert);
-        mAlertTitleView = (TextView) mAlertView.findViewById(R.id.alert_title);
-        mAlertInfoView = (TextView) mAlertView.findViewById(R.id.alert_info);
+        mAlertView = findViewById(R.id.alert);
+        mAlertTitleView = mAlertView.findViewById(R.id.alert_title);
+        mAlertInfoView = mAlertView.findViewById(R.id.alert_info);
 
-        mContentView = (ViewGroup) findViewById(R.id.content);
-        mAlarmButton = (ImageView) mContentView.findViewById(R.id.alarm);
-        mSnoozeButton = (ImageView) mContentView.findViewById(R.id.snooze);
-        mDismissButton = (ImageView) mContentView.findViewById(R.id.dismiss);
-        mHintView = (TextView) mContentView.findViewById(R.id.hint);
+        mContentView = findViewById(R.id.content);
+        mAlarmButton = mContentView.findViewById(R.id.alarm);
+        mSnoozeButton = mContentView.findViewById(R.id.snooze);
+        mDismissButton = mContentView.findViewById(R.id.dismiss);
+        mHintView = mContentView.findViewById(R.id.hint);
+        mDismissButton.setColorFilter(com.google.android.material.R.attr.colorOnBackground);
+        mSnoozeButton.setColorFilter(com.google.android.material.R.attr.colorOnBackground);
 
-        final TextView titleView = (TextView) mContentView.findViewById(R.id.title);
-        final TextClock digitalClock = (TextClock) mContentView.findViewById(R.id.digital_clock);
-        final CircleView pulseView = (CircleView) mContentView.findViewById(R.id.pulse);
+        final TextView titleView = mContentView.findViewById(R.id.title);
+        final TextClock digitalClock = mContentView.findViewById(R.id.digital_clock);
+        final CircleView pulseView = mContentView.findViewById(R.id.pulse);
 
         titleView.setText(mAlarmInstance.getLabelOrDefault(this));
         Utils.setTimeFormat(digitalClock, false);
@@ -231,8 +251,8 @@ public class AlarmActivity extends BaseActivity
         mDismissButton.setOnClickListener(this);
 
         mAlarmAnimator = AnimatorUtils.getScaleAnimator(mAlarmButton, 1.0f, 0.0f);
-        mSnoozeAnimator = getButtonAnimator(mSnoozeButton, Color.WHITE);
-        mDismissAnimator = getButtonAnimator(mDismissButton, mCurrentHourColor);
+        mSnoozeAnimator = getButtonAnimator(mSnoozeButton, com.google.android.material.R.attr.colorOnBackground);
+        mDismissAnimator = getButtonAnimator(mDismissButton, com.google.android.material.R.attr.colorOnBackground);
         mPulseAnimator = ObjectAnimator.ofPropertyValuesHolder(pulseView,
                 PropertyValuesHolder.ofFloat(CircleView.RADIUS, 0.0f, pulseView.getRadius()),
                 PropertyValuesHolder.ofObject(CircleView.FILL_COLOR, AnimatorUtils.ARGB_EVALUATOR,
@@ -291,28 +311,6 @@ public class AlarmActivity extends BaseActivity
         }
     }
 
-
- private final BroadcastReceiver PowerBtnReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            if (intent != null && intent.getAction() != null) {
-                if (intent.getAction().equals(Intent.ACTION_SCREEN_OFF)
-                        || intent.getAction().equals(Intent.ACTION_SCREEN_ON)) {
-                    // Power keys dismiss the alarm.
-                        if (!mAlarmHandled) {
-                            if (mPowerBehavior == AlarmVolumeButtonBehavior.SNOOZE) {
-                                snooze();
-                            }
-                            else if (mPowerBehavior == AlarmVolumeButtonBehavior.DISMISS){
-                                dismiss();
-                            }
-                        }
-                }
-        }
-        }
-    };
-
-
     @Override
     public boolean dispatchKeyEvent(@NonNull KeyEvent keyEvent) {
         // Do this in dispatch to intercept a few of the system keys.
@@ -518,7 +516,7 @@ public class AlarmActivity extends BaseActivity
         mAlarmHandled = true;
         LOGGER.v("Snoozed: %s", mAlarmInstance);
 
-        final int colorAccent = ThemeUtils.resolveColor(this, R.attr.colorPrimaryDark);
+        final int colorAccent = ThemeUtils.resolveColor(this, androidx.appcompat.R.attr.colorPrimaryDark);
         setAnimatedFractions(1.0f /* snoozeFraction */, 0.0f /* dismissFraction */);
 
         final int snoozeMinutes = DataModel.getDataModel().getSnoozeLength();
@@ -621,9 +619,9 @@ public class AlarmActivity extends BaseActivity
     }
 
     private Animator getAlertAnimator(final View source, final int titleResId,
-            final String infoText, final String accessibilityText, final int revealColor,
-            final int backgroundColor) {
-        final ViewGroup containerView = (ViewGroup) findViewById(android.R.id.content);
+                                      final String infoText, final String accessibilityText, final int revealColor,
+                                      final int backgroundColor) {
+        final ViewGroup containerView = findViewById(android.R.id.content);
 
         final Rect sourceBounds = new Rect(0, 0, source.getHeight(), source.getWidth());
         containerView.offsetDescendantRectToMyCoords(source, sourceBounds);
diff --git a/src/com/android/deskclock/alarms/AlarmKlaxon.java b/app/src/main/java/com/best/deskclock/alarms/AlarmKlaxon.java
similarity index 98%
rename from src/com/android/deskclock/alarms/AlarmKlaxon.java
rename to app/src/main/java/com/best/deskclock/alarms/AlarmKlaxon.java
index 08ff76f8b..706ea4d8d 100644
--- a/src/com/android/deskclock/alarms/AlarmKlaxon.java
+++ b/app/src/main/java/com/best/deskclock/alarms/AlarmKlaxon.java
@@ -38,7 +38,8 @@ final class AlarmKlaxon {
     private static boolean sStarted = false;
     private static AsyncRingtonePlayer sAsyncRingtonePlayer;
 
-    private AlarmKlaxon() {}
+    private AlarmKlaxon() {
+    }
 
     public static void stop(Context context) {
         if (sStarted) {
diff --git a/src/com/android/deskclock/alarms/AlarmNotifications.java b/app/src/main/java/com/best/deskclock/alarms/AlarmNotifications.java
similarity index 80%
rename from src/com/android/deskclock/alarms/AlarmNotifications.java
rename to app/src/main/java/com/best/deskclock/alarms/AlarmNotifications.java
index 9014e9e11..38353c4bf 100644
--- a/src/com/android/deskclock/alarms/AlarmNotifications.java
+++ b/app/src/main/java/com/best/deskclock/alarms/AlarmNotifications.java
@@ -22,7 +22,6 @@ import static com.best.deskclock.NotificationUtils.FIRING_NOTIFICATION_CHANNEL_I
 
 import android.annotation.TargetApi;
 import android.app.Notification;
-import android.app.NotificationChannel;
 import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.app.Service;
@@ -31,9 +30,9 @@ import android.content.Intent;
 import android.content.res.Resources;
 import android.os.Build;
 import android.service.notification.StatusBarNotification;
+
 import androidx.core.app.NotificationCompat;
 import androidx.core.app.NotificationManagerCompat;
-import androidx.core.content.ContextCompat;
 
 import com.best.deskclock.AlarmClockFragment;
 import com.best.deskclock.AlarmUtils;
@@ -61,54 +60,54 @@ public final class AlarmNotifications {
 
     /**
      * This value is coordinated with group ids from
-     * {@link com.best.deskclock.data.NotificationModel}
+     * {link com.best.deskclock.data.NotificationModel}
      */
     private static final String UPCOMING_GROUP_KEY = "1";
 
     /**
      * This value is coordinated with group ids from
-     * {@link com.best.deskclock.data.NotificationModel}
+     * {link com.best.deskclock.data.NotificationModel}
      */
     private static final String MISSED_GROUP_KEY = "4";
 
     /**
      * This value is coordinated with notification ids from
-     * {@link com.best.deskclock.data.NotificationModel}
+     * {link com.best.deskclock.data.NotificationModel}
      */
     private static final int ALARM_GROUP_NOTIFICATION_ID = Integer.MAX_VALUE - 4;
 
     /**
      * This value is coordinated with notification ids from
-     * {@link com.best.deskclock.data.NotificationModel}
+     * {link com.best.deskclock.data.NotificationModel}
      */
     private static final int ALARM_GROUP_MISSED_NOTIFICATION_ID = Integer.MAX_VALUE - 5;
 
     /**
      * This value is coordinated with notification ids from
-     * {@link com.best.deskclock.data.NotificationModel}
+     * {link com.best.deskclock.data.NotificationModel}
      */
     private static final int ALARM_FIRING_NOTIFICATION_ID = Integer.MAX_VALUE - 7;
 
     static synchronized void showUpcomingNotification(Context context,
-            AlarmInstance instance, boolean lowPriority) {
+                                                      AlarmInstance instance, boolean lowPriority) {
         LogUtils.v("Displaying upcoming alarm notification for alarm instance: " + instance.mId +
                 "low priority: " + lowPriority);
 
         NotificationCompat.Builder builder = new NotificationCompat.Builder(
-                 context, ALARM_UPCOMING_NOTIFICATION_CHANNEL_ID)
-                         .setShowWhen(false)
-                        .setContentTitle(context.getString(
-                                R.string.alarm_alert_predismiss_title))
-                        .setContentText(AlarmUtils.getAlarmText(
-                                context, instance, true /* includeLabel */))
-                        .setColor(ContextCompat.getColor(context, R.color.default_background))
-                        .setSmallIcon(R.drawable.stat_notify_alarm)
-                        .setAutoCancel(false)
-                        .setSortKey(createSortKey(instance))
-                        .setPriority(NotificationCompat.PRIORITY_LOW)
-                        .setCategory(NotificationCompat.CATEGORY_EVENT)
-                        .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
-                        .setLocalOnly(true);
+                context, ALARM_UPCOMING_NOTIFICATION_CHANNEL_ID)
+                .setShowWhen(false)
+                .setContentTitle(context.getString(
+                        R.string.alarm_alert_predismiss_title))
+                .setContentText(AlarmUtils.getAlarmText(
+                        context, instance, true /* includeLabel */))
+                .setColor(android.R.attr.colorAccent)
+                .setSmallIcon(R.drawable.stat_notify_alarm)
+                .setAutoCancel(false)
+                .setSortKey(createSortKey(instance))
+                .setPriority(NotificationCompat.PRIORITY_LOW)
+                .setCategory(NotificationCompat.CATEGORY_EVENT)
+                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
+                .setLocalOnly(true);
 
         if (Utils.isNOrLater()) {
             builder.setGroup(UPCOMING_GROUP_KEY);
@@ -157,15 +156,15 @@ public final class AlarmNotifications {
      * extra parameters are needed due to a race condition which exists in
      * {@link NotificationManager#getActiveNotifications()}.
      *
-     * @param context Context from which to grab the NotificationManager
-     * @param group The group key to query for notifications
+     * @param context                Context from which to grab the NotificationManager
+     * @param group                  The group key to query for notifications
      * @param canceledNotificationId The id of the just-canceled notification (-1 if none)
-     * @param postedNotification The notification that was just posted
+     * @param postedNotification     The notification that was just posted
      * @return The first active notification for the group
      */
     @TargetApi(Build.VERSION_CODES.N)
     private static Notification getFirstActiveNotification(Context context, String group,
-            int canceledNotificationId, Notification postedNotification) {
+                                                           int canceledNotificationId, Notification postedNotification) {
         final NotificationManager nm =
                 (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
         final StatusBarNotification[] notifications = nm.getActiveNotifications();
@@ -199,7 +198,7 @@ public final class AlarmNotifications {
     }
 
     private static void updateUpcomingAlarmGroupNotification(Context context,
-            int canceledNotificationId, Notification postedNotification) {
+                                                             int canceledNotificationId, Notification postedNotification) {
         if (!Utils.isNOrLater()) {
             return;
         }
@@ -217,10 +216,10 @@ public final class AlarmNotifications {
                 || !Objects.equals(summary.contentIntent, firstUpcoming.contentIntent)) {
             NotificationUtils.createChannel(context, ALARM_UPCOMING_NOTIFICATION_CHANNEL_ID);
             summary = new NotificationCompat.Builder(context,
-                        ALARM_UPCOMING_NOTIFICATION_CHANNEL_ID)
+                    ALARM_UPCOMING_NOTIFICATION_CHANNEL_ID)
                     .setShowWhen(false)
                     .setContentIntent(firstUpcoming.contentIntent)
-                    .setColor(ContextCompat.getColor(context, R.color.default_background))
+                    .setColor(android.R.attr.colorAccent)
                     .setSmallIcon(R.drawable.stat_notify_alarm)
                     .setGroup(UPCOMING_GROUP_KEY)
                     .setGroupSummary(true)
@@ -234,7 +233,7 @@ public final class AlarmNotifications {
     }
 
     private static void updateMissedAlarmGroupNotification(Context context,
-            int canceledNotificationId, Notification postedNotification) {
+                                                           int canceledNotificationId, Notification postedNotification) {
         if (!Utils.isNOrLater()) {
             return;
         }
@@ -254,7 +253,7 @@ public final class AlarmNotifications {
             summary = new NotificationCompat.Builder(context, ALARM_MISSED_NOTIFICATION_CHANNEL_ID)
                     .setShowWhen(false)
                     .setContentIntent(firstMissed.contentIntent)
-                    .setColor(ContextCompat.getColor(context, R.color.default_background))
+                    .setColor(android.R.attr.colorAccent)
                     .setSmallIcon(R.drawable.stat_notify_alarm)
                     .setGroup(MISSED_GROUP_KEY)
                     .setGroupSummary(true)
@@ -268,23 +267,23 @@ public final class AlarmNotifications {
     }
 
     static synchronized void showSnoozeNotification(Context context,
-            AlarmInstance instance) {
+                                                    AlarmInstance instance) {
         LogUtils.v("Displaying snoozed notification for alarm instance: " + instance.mId);
 
         NotificationCompat.Builder builder = new NotificationCompat.Builder(
                 context, ALARM_SNOOZE_NOTIFICATION_CHANNEL_ID)
-                        .setShowWhen(false)
-                        .setContentTitle(instance.getLabelOrDefault(context))
-                        .setContentText(context.getString(R.string.alarm_alert_snooze_until,
-                                AlarmUtils.getFormattedTime(context, instance.getAlarmTime())))
-                        .setColor(ContextCompat.getColor(context, R.color.default_background))
-                        .setSmallIcon(R.drawable.stat_notify_alarm)
-                        .setAutoCancel(false)
-                        .setSortKey(createSortKey(instance))
-                        .setPriority(NotificationCompat.PRIORITY_LOW)
-                        .setCategory(NotificationCompat.CATEGORY_EVENT)
-                        .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
-                        .setLocalOnly(true);
+                .setShowWhen(false)
+                .setContentTitle(instance.getLabelOrDefault(context))
+                .setContentText(context.getString(R.string.alarm_alert_snooze_until,
+                        AlarmUtils.getFormattedTime(context, instance.getAlarmTime())))
+                .setColor(android.R.attr.colorAccent)
+                .setSmallIcon(R.drawable.stat_notify_alarm)
+                .setAutoCancel(false)
+                .setSortKey(createSortKey(instance))
+                .setPriority(NotificationCompat.PRIORITY_LOW)
+                .setCategory(NotificationCompat.CATEGORY_EVENT)
+                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
+                .setLocalOnly(true);
 
         if (Utils.isNOrLater()) {
             builder.setGroup(UPCOMING_GROUP_KEY);
@@ -312,24 +311,24 @@ public final class AlarmNotifications {
     }
 
     static synchronized void showMissedNotification(Context context,
-            AlarmInstance instance) {
+                                                    AlarmInstance instance) {
         LogUtils.v("Displaying missed notification for alarm instance: " + instance.mId);
 
         String label = instance.mLabel;
         String alarmTime = AlarmUtils.getFormattedTime(context, instance.getAlarmTime());
         NotificationCompat.Builder builder = new NotificationCompat.Builder(
                 context, ALARM_MISSED_NOTIFICATION_CHANNEL_ID)
-                        .setShowWhen(false)
-                        .setContentTitle(context.getString(R.string.alarm_missed_title))
-                        .setContentText(instance.mLabel.isEmpty() ? alarmTime :
-                                context.getString(R.string.alarm_missed_text, alarmTime, label))
-                        .setColor(ContextCompat.getColor(context, R.color.default_background))
-                        .setSortKey(createSortKey(instance))
-                        .setSmallIcon(R.drawable.stat_notify_alarm)
-                        .setPriority(NotificationCompat.PRIORITY_HIGH)
-                        .setCategory(NotificationCompat.CATEGORY_EVENT)
-                        .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
-                        .setLocalOnly(true);
+                .setShowWhen(false)
+                .setContentTitle(context.getString(R.string.alarm_missed_title))
+                .setContentText(instance.mLabel.isEmpty() ? alarmTime :
+                        context.getString(R.string.alarm_missed_text, alarmTime, label))
+                .setColor(android.R.attr.colorAccent)
+                .setSortKey(createSortKey(instance))
+                .setSmallIcon(R.drawable.stat_notify_alarm)
+                .setPriority(NotificationCompat.PRIORITY_HIGH)
+                .setCategory(NotificationCompat.CATEGORY_EVENT)
+                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
+                .setLocalOnly(true);
 
         if (Utils.isNOrLater()) {
             builder.setGroup(MISSED_GROUP_KEY);
@@ -364,18 +363,18 @@ public final class AlarmNotifications {
         Resources resources = service.getResources();
         NotificationCompat.Builder notification = new NotificationCompat.Builder(
                 service, FIRING_NOTIFICATION_CHANNEL_ID)
-                        .setContentTitle(instance.getLabelOrDefault(service))
-                        .setContentText(AlarmUtils.getFormattedTime(
-                                service, instance.getAlarmTime()))
-                        .setColor(ContextCompat.getColor(service, R.color.default_background))
-                        .setSmallIcon(R.drawable.stat_notify_alarm)
-                        .setOngoing(true)
-                        .setAutoCancel(false)
-                        .setDefaults(NotificationCompat.DEFAULT_LIGHTS)
-                        .setWhen(0)
-                        .setCategory(NotificationCompat.CATEGORY_ALARM)
-                        .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
-                        .setLocalOnly(true);
+                .setContentTitle(instance.getLabelOrDefault(service))
+                .setContentText(AlarmUtils.getFormattedTime(
+                        service, instance.getAlarmTime()))
+                .setColor(android.R.attr.colorAccent)
+                .setSmallIcon(R.drawable.stat_notify_alarm)
+                .setOngoing(true)
+                .setAutoCancel(false)
+                .setDefaults(NotificationCompat.DEFAULT_LIGHTS)
+                .setWhen(0)
+                .setCategory(NotificationCompat.CATEGORY_ALARM)
+                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
+                .setLocalOnly(true);
 
         // Setup Snooze Action
         Intent snoozeIntent = AlarmStateManager.createStateChangeIntent(service,
@@ -410,7 +409,7 @@ public final class AlarmNotifications {
         fullScreenIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
                 Intent.FLAG_ACTIVITY_NO_USER_ACTION);
         notification.setFullScreenIntent(PendingIntent.getActivity(service,
-                ALARM_FIRING_NOTIFICATION_ID, fullScreenIntent, PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE),
+                        ALARM_FIRING_NOTIFICATION_ID, fullScreenIntent, PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE),
                 true);
         notification.setPriority(NotificationCompat.PRIORITY_HIGH);
 
diff --git a/src/com/android/deskclock/alarms/AlarmService.java b/app/src/main/java/com/best/deskclock/alarms/AlarmService.java
similarity index 80%
rename from src/com/android/deskclock/alarms/AlarmService.java
rename to app/src/main/java/com/best/deskclock/alarms/AlarmService.java
index 0f332998d..51a472baa 100644
--- a/src/com/android/deskclock/alarms/AlarmService.java
+++ b/app/src/main/java/com/best/deskclock/alarms/AlarmService.java
@@ -40,7 +40,7 @@ import com.best.deskclock.provider.AlarmInstance;
 /**
  * This service is in charge of starting/stopping the alarm. It will bring up and manage the
  * {@link AlarmActivity} as well as {@link AlarmKlaxon}.
- *
+ * <p>
  * Registers a broadcast receiver to listen for snooze/dismiss intents. The broadcast receiver
  * exits early if AlarmActivity is bound to prevent double-processing of the snooze/dismiss intents.
  */
@@ -58,13 +58,19 @@ public class AlarmService extends Service {
      */
     public static final String ALARM_DISMISS_ACTION = "com.best.deskclock.ALARM_DISMISS";
 
-    /** A public action sent by AlarmService when the alarm has started. */
+    /**
+     * A public action sent by AlarmService when the alarm has started.
+     */
     public static final String ALARM_ALERT_ACTION = "com.best.deskclock.ALARM_ALERT";
 
-    /** A public action sent by AlarmService when the alarm has stopped for any reason. */
+    /**
+     * A public action sent by AlarmService when the alarm has stopped for any reason.
+     */
     public static final String ALARM_DONE_ACTION = "com.best.deskclock.ALARM_DONE";
 
-    /** Private action used to stop an alarm with this service. */
+    /**
+     * Private action used to stop an alarm with this service.
+     */
     public static final String STOP_ALARM_ACTION = "STOP_ALARM";
 
     // constants for no action/snooze/dismiss
@@ -75,35 +81,168 @@ public class AlarmService extends Service {
     // default action for flip and shake
     private static final String DEFAULT_ACTION = Integer.toString(ALARM_NO_ACTION);
 
-    /** Binder given to AlarmActivity. */
+    /**
+     * Binder given to AlarmActivity.
+     */
     private final IBinder mBinder = new Binder();
-
-    /** Whether the service is currently bound to AlarmActivity */
+    /**
+     * Listener for changes in phone state.
+     */
+    private final PhoneStateChangeListener mPhoneStateListener = new PhoneStateChangeListener();
+    /**
+     * Whether the service is currently bound to AlarmActivity
+     */
     private boolean mIsBound = false;
+    /**
+     * Whether the receiver is currently registered
+     */
+    private boolean mIsRegistered = false;
+    private TelephonyManager mTelephonyManager;
+    private AlarmInstance mCurrentAlarm = null;
+    private final BroadcastReceiver mActionsReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            final String action = intent.getAction();
+            LogUtils.i("AlarmService received intent %s", action);
+            if (mCurrentAlarm == null || mCurrentAlarm.mAlarmState != AlarmInstance.FIRED_STATE) {
+                LogUtils.i("No valid firing alarm");
+                return;
+            }
 
-    /** Listener for changes in phone state. */
-    private final PhoneStateChangeListener mPhoneStateListener = new PhoneStateChangeListener();
+            if (mIsBound) {
+                LogUtils.i("AlarmActivity bound; AlarmService no-op");
+                return;
+            }
 
-    /** Whether the receiver is currently registered */
-    private boolean mIsRegistered = false;
+            switch (action) {
+                case ALARM_SNOOZE_ACTION:
+                    // Set the alarm state to snoozed.
+                    // If this broadcast receiver is handling the snooze intent then AlarmActivity
+                    // must not be showing, so always show snooze toast.
+                    AlarmStateManager.setSnoozeState(context, mCurrentAlarm, true /* showToast */);
+                    Events.sendAlarmEvent(R.string.action_snooze, R.string.label_intent);
+                    break;
+                case ALARM_DISMISS_ACTION:
+                    // Set the alarm state to dismissed.
+                    AlarmStateManager.deleteInstanceAndUpdateParent(context, mCurrentAlarm);
+                    Events.sendAlarmEvent(R.string.action_dismiss, R.string.label_intent);
+                    break;
+            }
+        }
+    };
+    private SensorManager mSensorManager;
+    private int mFlipAction;
+    private final ResettableSensorEventListener mFlipListener =
+            new ResettableSensorEventListener() {
+                // Accelerometers are not quite accurate.
+                private static final float GRAVITY_UPPER_THRESHOLD = 1.3f * SensorManager.STANDARD_GRAVITY;
+                private static final float GRAVITY_LOWER_THRESHOLD = 0.7f * SensorManager.STANDARD_GRAVITY;
+                private static final int SENSOR_SAMPLES = 3;
+                private final boolean[] mSamples = new boolean[SENSOR_SAMPLES];
+                private boolean mStopped;
+                private boolean mWasFaceUp;
+                private int mSampleIndex;
+
+                @Override
+                public void onAccuracyChanged(Sensor sensor, int acc) {
+                }
 
-    @Override
-    public IBinder onBind(Intent intent) {
-        mIsBound = true;
-        return mBinder;
-    }
+                @Override
+                public void reset() {
+                    mWasFaceUp = false;
+                    mStopped = false;
+                    for (int i = 0; i < SENSOR_SAMPLES; i++) {
+                        mSamples[i] = false;
+                    }
+                }
 
-    @Override
-    public boolean onUnbind(Intent intent) {
-        mIsBound = false;
-        return super.onUnbind(intent);
-    }
+                private boolean filterSamples() {
+                    boolean allPass = true;
+                    for (boolean sample : mSamples) {
+                        allPass = allPass && sample;
+                    }
+                    return allPass;
+                }
+
+                @Override
+                public void onSensorChanged(SensorEvent event) {
+                    // Add a sample overwriting the oldest one. Several samples
+                    // are used to avoid the erroneous values the sensor sometimes
+                    // returns.
+                    float z = event.values[2];
+
+                    if (mStopped) {
+                        return;
+                    }
+
+                    if (!mWasFaceUp) {
+                        // Check if its face up enough.
+                        mSamples[mSampleIndex] = (z > GRAVITY_LOWER_THRESHOLD) &&
+                                (z < GRAVITY_UPPER_THRESHOLD);
+
+                        // face up
+                        if (filterSamples()) {
+                            mWasFaceUp = true;
+                            for (int i = 0; i < SENSOR_SAMPLES; i++) {
+                                mSamples[i] = false;
+                            }
+                        }
+                    } else {
+                        // Check if its face down enough.
+                        mSamples[mSampleIndex] = (z < -GRAVITY_LOWER_THRESHOLD) &&
+                                (z > -GRAVITY_UPPER_THRESHOLD);
+
+                        // face down
+                        if (filterSamples()) {
+                            mStopped = true;
+                            handleAction(mFlipAction);
+                        }
+                    }
+
+                    mSampleIndex = ((mSampleIndex + 1) % SENSOR_SAMPLES);
+                }
+            };
+    private int mShakeAction;
+    private final SensorEventListener mShakeListener = new SensorEventListener() {
+        private static final float SENSITIVITY = 16;
+        private static final int BUFFER = 5;
+        private final float[] gravity = new float[3];
+        private float average = 0;
+        private int fill = 0;
+
+        @Override
+        public void onAccuracyChanged(Sensor sensor, int acc) {
+        }
+
+        public void onSensorChanged(SensorEvent event) {
+            final float alpha = 0.8F;
+
+            for (int i = 0; i < 3; i++) {
+                gravity[i] = alpha * gravity[i] + (1 - alpha) * event.values[i];
+            }
+
+            float x = event.values[0] - gravity[0];
+            float y = event.values[1] - gravity[1];
+            float z = event.values[2] - gravity[2];
+
+            if (fill <= BUFFER) {
+                average += Math.abs(x) + Math.abs(y) + Math.abs(z);
+                fill++;
+            } else {
+                if (average / BUFFER >= SENSITIVITY) {
+                    handleAction(mShakeAction);
+                }
+                average = 0;
+                fill = 0;
+            }
+        }
+    };
 
     /**
      * Utility method to help stop an alarm properly. Nothing will happen, if alarm is not firing
      * or using a different instance.
      *
-     * @param context application context
+     * @param context  application context
      * @param instance you are trying to stop
      */
     public static void stopAlarm(Context context, AlarmInstance instance) {
@@ -114,11 +253,17 @@ public class AlarmService extends Service {
         context.startService(intent);
     }
 
-    private TelephonyManager mTelephonyManager;
-    private AlarmInstance mCurrentAlarm = null;
-    private SensorManager mSensorManager;
-    private int mFlipAction;
-    private int mShakeAction;
+    @Override
+    public IBinder onBind(Intent intent) {
+        mIsBound = true;
+        return mBinder;
+    }
+
+    @Override
+    public boolean onUnbind(Intent intent) {
+        mIsBound = false;
+        return super.onUnbind(intent);
+    }
 
     private void startAlarm(AlarmInstance instance) {
         LogUtils.v("AlarmService.start with instance: " + instance.mId);
@@ -157,38 +302,6 @@ public class AlarmService extends Service {
         AlarmAlertWakeLock.releaseCpuLock();
     }
 
-    private final BroadcastReceiver mActionsReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            final String action = intent.getAction();
-            LogUtils.i("AlarmService received intent %s", action);
-            if (mCurrentAlarm == null || mCurrentAlarm.mAlarmState != AlarmInstance.FIRED_STATE) {
-                LogUtils.i("No valid firing alarm");
-                return;
-            }
-
-            if (mIsBound) {
-                LogUtils.i("AlarmActivity bound; AlarmService no-op");
-                return;
-            }
-
-            switch (action) {
-                case ALARM_SNOOZE_ACTION:
-                    // Set the alarm state to snoozed.
-                    // If this broadcast receiver is handling the snooze intent then AlarmActivity
-                    // must not be showing, so always show snooze toast.
-                    AlarmStateManager.setSnoozeState(context, mCurrentAlarm, true /* showToast */);
-                    Events.sendAlarmEvent(R.string.action_snooze, R.string.label_intent);
-                    break;
-                case ALARM_DISMISS_ACTION:
-                    // Set the alarm state to dismissed.
-                    AlarmStateManager.deleteInstanceAndUpdateParent(context, mCurrentAlarm);
-                    Events.sendAlarmEvent(R.string.action_dismiss, R.string.label_intent);
-                    break;
-            }
-        }
-    };
-
     @Override
     public void onCreate() {
         super.onCreate();
@@ -266,139 +379,6 @@ public class AlarmService extends Service {
         }
     }
 
-    private final class PhoneStateChangeListener extends PhoneStateListener {
-
-        private int mPhoneCallState;
-
-        PhoneStateChangeListener init() {
-            mPhoneCallState = -1;
-            return this;
-        }
-
-        @Override
-        public void onCallStateChanged(int state, String ignored) {
-            if (mPhoneCallState == -1) {
-                mPhoneCallState = state;
-            }
-
-            if (state != TelephonyManager.CALL_STATE_IDLE && state != mPhoneCallState) {
-                startService(AlarmStateManager.createStateChangeIntent(AlarmService.this,
-                        "AlarmService", mCurrentAlarm, AlarmInstance.MISSED_STATE));
-            }
-        }
-    }
-
-    private interface ResettableSensorEventListener extends SensorEventListener {
-        public void reset();
-    }
-
-    private final ResettableSensorEventListener mFlipListener =
-        new ResettableSensorEventListener() {
-        // Accelerometers are not quite accurate.
-        private static final float GRAVITY_UPPER_THRESHOLD = 1.3f * SensorManager.STANDARD_GRAVITY;
-        private static final float GRAVITY_LOWER_THRESHOLD = 0.7f * SensorManager.STANDARD_GRAVITY;
-        private static final int SENSOR_SAMPLES = 3;
-
-        private boolean mStopped;
-        private boolean mWasFaceUp;
-        private boolean[] mSamples = new boolean[SENSOR_SAMPLES];
-        private int mSampleIndex;
-
-        @Override
-        public void onAccuracyChanged(Sensor sensor, int acc) {
-        }
-
-        @Override
-        public void reset() {
-            mWasFaceUp = false;
-            mStopped = false;
-            for (int i = 0; i < SENSOR_SAMPLES; i++) {
-                mSamples[i] = false;
-            }
-        }
-
-        private boolean filterSamples() {
-            boolean allPass = true;
-            for (boolean sample : mSamples) {
-                allPass = allPass && sample;
-            }
-            return allPass;
-        }
-
-        @Override
-        public void onSensorChanged(SensorEvent event) {
-            // Add a sample overwriting the oldest one. Several samples
-            // are used to avoid the erroneous values the sensor sometimes
-            // returns.
-            float z = event.values[2];
-
-            if (mStopped) {
-                return;
-            }
-
-            if (!mWasFaceUp) {
-                // Check if its face up enough.
-                mSamples[mSampleIndex] = (z > GRAVITY_LOWER_THRESHOLD) &&
-                    (z < GRAVITY_UPPER_THRESHOLD);
-
-                // face up
-                if (filterSamples()) {
-                    mWasFaceUp = true;
-                    for (int i = 0; i < SENSOR_SAMPLES; i++) {
-                        mSamples[i] = false;
-                    }
-                }
-            } else {
-                // Check if its face down enough.
-                mSamples[mSampleIndex] = (z < -GRAVITY_LOWER_THRESHOLD) &&
-                    (z > -GRAVITY_UPPER_THRESHOLD);
-
-                // face down
-                if (filterSamples()) {
-                    mStopped = true;
-                    handleAction(mFlipAction);
-                }
-            }
-
-            mSampleIndex = ((mSampleIndex + 1) % SENSOR_SAMPLES);
-        }
-    };
-
-    private final SensorEventListener mShakeListener = new SensorEventListener() {
-        private static final float SENSITIVITY = 16;
-        private static final int BUFFER = 5;
-        private float[] gravity = new float[3];
-        private float average = 0;
-        private int fill = 0;
-
-        @Override
-        public void onAccuracyChanged(Sensor sensor, int acc) {
-        }
-
-        public void onSensorChanged(SensorEvent event) {
-            final float alpha = 0.8F;
-
-            for (int i = 0; i < 3; i++) {
-                gravity[i] = alpha * gravity[i] + (1 - alpha) * event.values[i];
-            }
-
-            float x = event.values[0] - gravity[0];
-            float y = event.values[1] - gravity[1];
-            float z = event.values[2] - gravity[2];
-
-            if (fill <= BUFFER) {
-                average += Math.abs(x) + Math.abs(y) + Math.abs(z);
-                fill++;
-            } else {
-                if (average / BUFFER >= SENSITIVITY) {
-                    handleAction(mShakeAction);
-                }
-                average = 0;
-                fill = 0;
-            }
-        }
-    };
-
     private void attachListeners() {
         if (mFlipAction != ALARM_NO_ACTION) {
             mFlipListener.reset();
@@ -444,4 +424,30 @@ public class AlarmService extends Service {
                 break;
         }
     }
+
+    private interface ResettableSensorEventListener extends SensorEventListener {
+        void reset();
+    }
+
+    private final class PhoneStateChangeListener extends PhoneStateListener {
+
+        private int mPhoneCallState;
+
+        PhoneStateChangeListener init() {
+            mPhoneCallState = -1;
+            return this;
+        }
+
+        @Override
+        public void onCallStateChanged(int state, String ignored) {
+            if (mPhoneCallState == -1) {
+                mPhoneCallState = state;
+            }
+
+            if (state != TelephonyManager.CALL_STATE_IDLE && state != mPhoneCallState) {
+                startService(AlarmStateManager.createStateChangeIntent(AlarmService.this,
+                        "AlarmService", mCurrentAlarm, AlarmInstance.MISSED_STATE));
+            }
+        }
+    }
 }
diff --git a/src/com/android/deskclock/alarms/AlarmStateManager.java b/app/src/main/java/com/best/deskclock/alarms/AlarmStateManager.java
similarity index 96%
rename from src/com/android/deskclock/alarms/AlarmStateManager.java
rename to app/src/main/java/com/best/deskclock/alarms/AlarmStateManager.java
index 3a701187b..97fecc686 100644
--- a/src/com/android/deskclock/alarms/AlarmStateManager.java
+++ b/app/src/main/java/com/best/deskclock/alarms/AlarmStateManager.java
@@ -15,6 +15,9 @@
  */
 package com.best.deskclock.alarms;
 
+import static android.content.Context.ALARM_SERVICE;
+import static android.provider.Settings.System.NEXT_ALARM_FORMATTED;
+
 import android.annotation.TargetApi;
 import android.app.AlarmManager;
 import android.app.AlarmManager.AlarmClockInfo;
@@ -28,10 +31,11 @@ import android.os.Build;
 import android.os.Handler;
 import android.os.PowerManager;
 import android.provider.Settings;
-import androidx.core.app.NotificationManagerCompat;
 import android.text.format.DateFormat;
 import android.widget.Toast;
 
+import androidx.core.app.NotificationManagerCompat;
+
 import com.best.deskclock.AlarmAlertWakeLock;
 import com.best.deskclock.AlarmClockFragment;
 import com.best.deskclock.AlarmUtils;
@@ -49,55 +53,53 @@ import java.util.Calendar;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
-
-import static android.content.Context.ALARM_SERVICE;
-import static android.provider.Settings.System.NEXT_ALARM_FORMATTED;
+import java.util.Objects;
 
 /**
  * This class handles all the state changes for alarm instances. You need to
  * register all alarm instances with the state manager if you want them to
  * be activated. If a major time change has occurred (ie. TIMEZONE_CHANGE, TIMESET_CHANGE),
  * then you must also re-register instances to fix their states.
- *
+ * <p>
  * Please see {@link #registerInstance) for special transitions when major time changes
  * occur.
- *
+ * <p>
  * Following states:
- *
+ * <p>
  * SILENT_STATE:
  * This state is used when the alarm is activated, but doesn't need to display anything. It
  * is in charge of changing the alarm instance state to a LOW_NOTIFICATION_STATE.
- *
+ * <p>
  * LOW_NOTIFICATION_STATE:
  * This state is used to notify the user that the alarm will go off
  * {@link AlarmInstance#LOW_NOTIFICATION_HOUR_OFFSET}. This
  * state handles the state changes to HIGH_NOTIFICATION_STATE, HIDE_NOTIFICATION_STATE and
  * DISMISS_STATE.
- *
+ * <p>
  * HIDE_NOTIFICATION_STATE:
  * This is a transient state of the LOW_NOTIFICATION_STATE, where the user wants to hide the
  * notification. This will sit and wait until the HIGH_PRIORITY_NOTIFICATION should go off.
- *
+ * <p>
  * HIGH_NOTIFICATION_STATE:
  * This state behaves like the LOW_NOTIFICATION_STATE, but doesn't allow the user to hide it.
  * This state is in charge of triggering a FIRED_STATE or DISMISS_STATE.
- *
+ * <p>
  * SNOOZED_STATE:
  * The SNOOZED_STATE behaves like a HIGH_NOTIFICATION_STATE, but with a different message. It
  * also increments the alarm time in the instance to reflect the new snooze time.
- *
+ * <p>
  * FIRED_STATE:
  * The FIRED_STATE is used when the alarm is firing. It will start the AlarmService, and wait
  * until the user interacts with the alarm via SNOOZED_STATE or DISMISS_STATE change. If the user
  * doesn't then it might be change to MISSED_STATE if auto-silenced was enabled.
- *
+ * <p>
  * MISSED_STATE:
  * The MISSED_STATE is used when the alarm already fired, but the user could not interact with
  * it. At this point the alarm instance is dead and we check the parent alarm to see if we need
  * to disable or schedule a new alarm_instance. There is also a notification shown to the user
  * that he/she missed the alarm and that stays for
  * {@link AlarmInstance#MISSED_TIME_TO_LIVE_HOUR_OFFSET} or until the user acknownledges it.
- *
+ * <p>
  * DISMISS_STATE:
  * This is really a transient state that will properly delete the alarm instance. Use this state,
  * whenever you want to get rid of the alarm instance. This state will also check the alarm
@@ -109,50 +111,36 @@ public final class AlarmStateManager extends BroadcastReceiver {
 
     // Intent action to show the alarm and dismiss the instance
     public static final String SHOW_AND_DISMISS_ALARM_ACTION = "show_and_dismiss_alarm";
-
-    // Intent action for an AlarmManager alarm serving only to set the next alarm indicators
-    private static final String INDICATOR_ACTION = "indicator";
-
     // System intent action to notify AppWidget that we changed the alarm text.
     public static final String ACTION_ALARM_CHANGED = "com.best.deskclock.ALARM_CHANGED";
-
     // Extra key to set the desired state change.
     public static final String ALARM_STATE_EXTRA = "intent.extra.alarm.state";
-
     // Extra key to indicate the state change was launched from a notification.
     public static final String FROM_NOTIFICATION_EXTRA = "intent.extra.from.notification";
-
-    // Extra key to set the global broadcast id.
-    private static final String ALARM_GLOBAL_ID_EXTRA = "intent.extra.alarm.global.id";
-
     // Intent category tags used to dismiss, snooze or delete an alarm
     public static final String ALARM_DISMISS_TAG = "DISMISS_TAG";
     public static final String ALARM_SNOOZE_TAG = "SNOOZE_TAG";
     public static final String ALARM_DELETE_TAG = "DELETE_TAG";
-
-    // Intent category tag used when schedule state change intents in alarm manager.
-    private static final String ALARM_MANAGER_TAG = "ALARM_MANAGER";
-
     // Buffer time in seconds to fire alarm instead of marking it missed.
     public static final int ALARM_FIRE_BUFFER = 15;
-
-    // A factory for the current time; can be mocked for testing purposes.
-    private static CurrentTimeFactory sCurrentTimeFactory;
-
-    // Schedules alarm state transitions; can be mocked for testing purposes.
-    private static StateChangeScheduler sStateChangeScheduler =
-            new AlarmManagerStateChangeScheduler();
-
+    // Intent action for an AlarmManager alarm serving only to set the next alarm indicators
+    private static final String INDICATOR_ACTION = "indicator";
+    // Extra key to set the global broadcast id.
+    private static final String ALARM_GLOBAL_ID_EXTRA = "intent.extra.alarm.global.id";
+    // Intent category tag used when schedule state change intents in alarm manager.
+    private static final String ALARM_MANAGER_TAG = "ALARM_MANAGER";
     private static final String ACTION_SET_POWEROFF_ALARM =
             "org.codeaurora.poweroffalarm.action.SET_ALARM";
-
     private static final String ACTION_CANCEL_POWEROFF_ALARM =
             "org.codeaurora.poweroffalarm.action.CANCEL_ALARM";
-
     private static final String POWER_OFF_ALARM_PACKAGE =
             "com.qualcomm.qti.poweroffalarm";
-
     private static final String TIME = "time";
+    // A factory for the current time; can be mocked for testing purposes.
+    private static CurrentTimeFactory sCurrentTimeFactory;
+    // Schedules alarm state transitions; can be mocked for testing purposes.
+    private static StateChangeScheduler sStateChangeScheduler =
+            new AlarmManagerStateChangeScheduler();
 
     private static Calendar getCurrentTime() {
         return sCurrentTimeFactory == null
@@ -212,8 +200,6 @@ public final class AlarmStateManager extends BroadcastReceiver {
     /**
      * Used in pre-L devices, where "next alarm" is stored in system settings.
      */
-    @SuppressWarnings("deprecation")
-    @TargetApi(Build.VERSION_CODES.KITKAT)
     private static void updateNextAlarmInSystemSettings(Context context, AlarmInstance nextAlarm) {
         // Format the next alarm time if an alarm is scheduled.
         String time = "";
@@ -225,13 +211,13 @@ public final class AlarmStateManager extends BroadcastReceiver {
             // Write directly to NEXT_ALARM_FORMATTED in all pre-L versions
             Settings.System.putString(context.getContentResolver(), NEXT_ALARM_FORMATTED, time);
 
-            LogUtils.i("Updated next alarm time to: \'" + time + '\'');
+            LogUtils.i("Updated next alarm time to: '" + time + '\'');
 
             // Send broadcast message so pre-L AppWidgets will recognize an update.
             context.sendBroadcast(new Intent(ACTION_ALARM_CHANGED));
         } catch (SecurityException se) {
             // The user has most likely revoked WRITE_SETTINGS.
-            LogUtils.e("Unable to update next alarm to: \'" + time + '\'', se);
+            LogUtils.e("Unable to update next alarm to: '" + time + '\'', se);
         }
     }
 
@@ -278,7 +264,7 @@ public final class AlarmStateManager extends BroadcastReceiver {
         ContentResolver cr = context.getContentResolver();
         Alarm alarm = Alarm.getAlarm(cr, instance.mAlarmId);
         if (alarm == null) {
-            LogUtils.e("Parent has been deleted with instance: " + instance.toString());
+            LogUtils.e("Parent has been deleted with instance: " + instance);
             return;
         }
 
@@ -318,7 +304,7 @@ public final class AlarmStateManager extends BroadcastReceiver {
      * @return intent that can be used to change an alarm instance state
      */
     public static Intent createStateChangeIntent(Context context, String tag,
-            AlarmInstance instance, Integer state) {
+                                                 AlarmInstance instance, Integer state) {
         // This intent is directed to AlarmService, though the actual handling of it occurs here
         // in AlarmStateManager. The reason is that evidence exists showing the jump between the
         // broadcast receiver (AlarmStateManager) and service (AlarmService) can be thwarted by the
@@ -344,7 +330,7 @@ public final class AlarmStateManager extends BroadcastReceiver {
      * @param newState to change to
      */
     private static void scheduleInstanceStateChange(Context ctx, Calendar time,
-            AlarmInstance instance, int newState) {
+                                                    AlarmInstance instance, int newState) {
         sStateChangeScheduler.scheduleInstanceStateChange(ctx, time, instance, newState);
     }
 
@@ -490,7 +476,7 @@ public final class AlarmStateManager extends BroadcastReceiver {
      * @param instance to set state to
      */
     public static void setSnoozeState(final Context context, AlarmInstance instance,
-            boolean showToast) {
+                                      boolean showToast) {
         // Stop alarm if this instance is firing it
         AlarmService.stopAlarm(context, instance);
 
@@ -518,7 +504,7 @@ public final class AlarmStateManager extends BroadcastReceiver {
                 @Override
                 public void run() {
                     String displayTime = String.format(context.getResources().getQuantityText
-                            (R.plurals.alarm_alert_snooze_set, snoozeMinutes).toString(),
+                                    (R.plurals.alarm_alert_snooze_set, snoozeMinutes).toString(),
                             snoozeMinutes);
                     Toast.makeText(context, displayTime, Toast.LENGTH_LONG).show();
                 }
@@ -649,7 +635,7 @@ public final class AlarmStateManager extends BroadcastReceiver {
      * This registers the AlarmInstance to the state manager. This will look at the instance
      * and choose the most appropriate state to put it in. This is primarily used by new
      * alarms, but it can also be called when the system time changes.
-     *
+     * <p>
      * Most state changes are handled by the states themselves, but during major time changes we
      * have to correct the alarm instance state. This means we have to handle special cases as
      * describe below:
@@ -662,7 +648,7 @@ public final class AlarmStateManager extends BroadcastReceiver {
      *     <li>If alarm was SNOOZED, then show the notification but don't update time</li>
      *     <li>If low priority notification was hidden, then make sure it stays hidden</li>
      * </ul>
-     *
+     * <p>
      * If none of these special case are found, then we just check the time and see what is the
      * proper state for the instance.
      *
@@ -670,7 +656,7 @@ public final class AlarmStateManager extends BroadcastReceiver {
      * @param instance to register
      */
     public static void registerInstance(Context context, AlarmInstance instance,
-            boolean updateNextAlarm) {
+                                        boolean updateNextAlarm) {
         LogUtils.i("Registering instance: " + instance.mId);
         final ContentResolver cr = context.getContentResolver();
         final Alarm alarm = Alarm.getAlarm(cr, instance.mAlarmId);
@@ -710,7 +696,7 @@ public final class AlarmStateManager extends BroadcastReceiver {
 
                 // Make sure we re-enable the parent alarm of the instance
                 // because it will get activated by by the below code
-                alarm.enabled = true;
+                Objects.requireNonNull(alarm).enabled = true;
                 Alarm.updateAlarm(cr, alarm);
             }
         } else if (instance.mAlarmState == AlarmInstance.PREDISMISSED_STATE) {
@@ -897,25 +883,6 @@ public final class AlarmStateManager extends BroadcastReceiver {
         }
     }
 
-    @Override
-    public void onReceive(final Context context, final Intent intent) {
-        if (INDICATOR_ACTION.equals(intent.getAction())) {
-            return;
-        }
-
-        final PendingResult result = goAsync();
-        final PowerManager.WakeLock wl = AlarmAlertWakeLock.createPartialWakeLock(context);
-        wl.acquire();
-        AsyncHandler.post(new Runnable() {
-            @Override
-            public void run() {
-                handleIntent(context, intent);
-                result.finish();
-                wl.release();
-            }
-        });
-    }
-
     public static void handleIntent(Context context, Intent intent) {
         final String action = intent.getAction();
         LogUtils.v("AlarmStateManager received intent " + intent);
@@ -990,6 +957,42 @@ public final class AlarmStateManager extends BroadcastReceiver {
         return new Intent(context, AlarmStateManager.class).setAction(INDICATOR_ACTION);
     }
 
+    private static void setPowerOffAlarm(Context context, AlarmInstance instance) {
+        LogUtils.i("Set next power off alarm : instance id " + instance.mId);
+        Intent intent = new Intent(ACTION_SET_POWEROFF_ALARM);
+        intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
+        intent.setPackage(POWER_OFF_ALARM_PACKAGE);
+        intent.putExtra(TIME, instance.getAlarmTime().getTimeInMillis());
+        context.sendBroadcast(intent);
+    }
+
+    private static void cancelPowerOffAlarm(Context context, AlarmInstance instance) {
+        Intent intent = new Intent(ACTION_CANCEL_POWEROFF_ALARM);
+        intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
+        intent.putExtra(TIME, instance.getAlarmTime().getTimeInMillis());
+        intent.setPackage(POWER_OFF_ALARM_PACKAGE);
+        context.sendBroadcast(intent);
+    }
+
+    @Override
+    public void onReceive(final Context context, final Intent intent) {
+        if (INDICATOR_ACTION.equals(intent.getAction())) {
+            return;
+        }
+
+        final PendingResult result = goAsync();
+        final PowerManager.WakeLock wl = AlarmAlertWakeLock.createPartialWakeLock(context);
+        wl.acquire();
+        AsyncHandler.post(new Runnable() {
+            @Override
+            public void run() {
+                handleIntent(context, intent);
+                result.finish();
+                wl.release();
+            }
+        });
+    }
+
     /**
      * Abstract away how the current time is computed. If no implementation of this interface is
      * given the default is to return {@link Calendar#getInstance()}. Otherwise, the factory
@@ -1006,35 +1009,18 @@ public final class AlarmStateManager extends BroadcastReceiver {
      */
     interface StateChangeScheduler {
         void scheduleInstanceStateChange(Context context, Calendar time,
-                AlarmInstance instance, int newState);
+                                         AlarmInstance instance, int newState);
 
         void cancelScheduledInstanceStateChange(Context context, AlarmInstance instance);
     }
 
-    private static void setPowerOffAlarm(Context context, AlarmInstance instance) {
-         LogUtils.i("Set next power off alarm : instance id "+ instance.mId);
-         Intent intent = new Intent(ACTION_SET_POWEROFF_ALARM);
-         intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
-         intent.setPackage(POWER_OFF_ALARM_PACKAGE);
-         intent.putExtra(TIME, instance.getAlarmTime().getTimeInMillis());
-         context.sendBroadcast(intent);
-    }
-
-    private static void cancelPowerOffAlarm(Context context, AlarmInstance instance) {
-         Intent intent = new Intent(ACTION_CANCEL_POWEROFF_ALARM);
-         intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
-         intent.putExtra(TIME, instance.getAlarmTime().getTimeInMillis());
-         intent.setPackage(POWER_OFF_ALARM_PACKAGE);
-         context.sendBroadcast(intent);
-    }
-
     /**
      * Schedules state change callbacks within the AlarmManager.
      */
     private static class AlarmManagerStateChangeScheduler implements StateChangeScheduler {
         @Override
         public void scheduleInstanceStateChange(Context context, Calendar time,
-                AlarmInstance instance, int newState) {
+                                                AlarmInstance instance, int newState) {
             final long timeInMillis = time.getTimeInMillis();
             LogUtils.i("Scheduling state change %d to instance %d at %s (%d)", newState,
                     instance.mId, AlarmUtils.getFormattedTime(context, time), timeInMillis);
diff --git a/src/com/android/deskclock/alarms/AlarmTimeClickHandler.java b/app/src/main/java/com/best/deskclock/alarms/AlarmTimeClickHandler.java
similarity index 98%
rename from src/com/android/deskclock/alarms/AlarmTimeClickHandler.java
rename to app/src/main/java/com/best/deskclock/alarms/AlarmTimeClickHandler.java
index 569263697..de64878cf 100644
--- a/src/com/android/deskclock/alarms/AlarmTimeClickHandler.java
+++ b/app/src/main/java/com/best/deskclock/alarms/AlarmTimeClickHandler.java
@@ -22,7 +22,6 @@ import android.content.Intent;
 import android.os.Bundle;
 import android.os.Vibrator;
 
-
 import com.best.deskclock.AlarmClockFragment;
 import com.best.deskclock.LabelDialogFragment;
 import com.best.deskclock.LogUtils;
@@ -45,19 +44,16 @@ public final class AlarmTimeClickHandler {
     private static final LogUtils.Logger LOGGER = new LogUtils.Logger("AlarmTimeClickHandler");
 
     private static final String KEY_PREVIOUS_DAY_MAP = "previousDayMap";
-
+    final Vibrator vibrator;
     private final Fragment mFragment;
     private final Context mContext;
     private final AlarmUpdateHandler mAlarmUpdateHandler;
     private final ScrollHandler mScrollHandler;
-
     private Alarm mSelectedAlarm;
     private Bundle mPreviousDaysOfWeekMap;
 
-    final Vibrator vibrator;
-
     public AlarmTimeClickHandler(Fragment fragment, Bundle savedState,
-            AlarmUpdateHandler alarmUpdateHandler, ScrollHandler smoothScrollController) {
+                                 AlarmUpdateHandler alarmUpdateHandler, ScrollHandler smoothScrollController) {
         mFragment = fragment;
         mContext = mFragment.getActivity().getApplicationContext();
         mAlarmUpdateHandler = alarmUpdateHandler;
diff --git a/src/com/android/deskclock/alarms/AlarmUpdateHandler.java b/app/src/main/java/com/best/deskclock/alarms/AlarmUpdateHandler.java
similarity index 97%
rename from src/com/android/deskclock/alarms/AlarmUpdateHandler.java
rename to app/src/main/java/com/best/deskclock/alarms/AlarmUpdateHandler.java
index adbfb37be..4474799d9 100644
--- a/src/com/android/deskclock/alarms/AlarmUpdateHandler.java
+++ b/app/src/main/java/com/best/deskclock/alarms/AlarmUpdateHandler.java
@@ -19,7 +19,6 @@ package com.best.deskclock.alarms;
 import android.content.ContentResolver;
 import android.content.Context;
 import android.os.AsyncTask;
-import com.google.android.material.snackbar.Snackbar;
 import android.text.format.DateFormat;
 import android.view.View;
 import android.view.ViewGroup;
@@ -30,6 +29,7 @@ import com.best.deskclock.events.Events;
 import com.best.deskclock.provider.Alarm;
 import com.best.deskclock.provider.AlarmInstance;
 import com.best.deskclock.widget.toast.SnackbarManager;
+import com.google.android.material.snackbar.Snackbar;
 
 import java.util.Calendar;
 import java.util.List;
@@ -47,7 +47,7 @@ public final class AlarmUpdateHandler {
     private Alarm mDeletedAlarm;
 
     public AlarmUpdateHandler(Context context, ScrollHandler scrollHandler,
-            ViewGroup snackbarAnchor) {
+                              ViewGroup snackbarAnchor) {
         mAppContext = context.getApplicationContext();
         mScrollHandler = scrollHandler;
         mSnackbarAnchor = snackbarAnchor;
@@ -100,7 +100,7 @@ public final class AlarmUpdateHandler {
      * @param minorUpdate if true, don't affect any currently snoozed instances.
      */
     public void asyncUpdateAlarm(final Alarm alarm, final boolean popToast,
-            final boolean minorUpdate) {
+                                 final boolean minorUpdate) {
         final AsyncTask<Void, Void, AlarmInstance> updateTask =
                 new AsyncTask<Void, Void, AlarmInstance>() {
                     @Override
@@ -200,7 +200,7 @@ public final class AlarmUpdateHandler {
     private void showUndoBar() {
         final Alarm deletedAlarm = mDeletedAlarm;
         final Snackbar snackbar = Snackbar.make(mSnackbarAnchor,
-                mAppContext.getString(R.string.alarm_deleted), Snackbar.LENGTH_LONG)
+                        mAppContext.getString(R.string.alarm_deleted), Snackbar.LENGTH_LONG)
                 .setAction(R.string.alarm_undo, new View.OnClickListener() {
                     @Override
                     public void onClick(View v) {
@@ -214,7 +214,7 @@ public final class AlarmUpdateHandler {
     private AlarmInstance setupAlarmInstance(Alarm alarm) {
         final ContentResolver cr = mAppContext.getContentResolver();
         AlarmInstance newInstance = alarm.createInstanceAfter(Calendar.getInstance());
-        newInstance = AlarmInstance.addInstance(cr, newInstance);
+        AlarmInstance.addInstance(cr, newInstance);
         // Register instance to state manager
         AlarmStateManager.registerInstance(mAppContext, newInstance, true);
         return newInstance;
diff --git a/src/com/android/deskclock/alarms/ScrollHandler.java b/app/src/main/java/com/best/deskclock/alarms/ScrollHandler.java
similarity index 100%
rename from src/com/android/deskclock/alarms/ScrollHandler.java
rename to app/src/main/java/com/best/deskclock/alarms/ScrollHandler.java
diff --git a/src/com/android/deskclock/alarms/TimePickerDialogFragment.java b/app/src/main/java/com/best/deskclock/alarms/TimePickerDialogFragment.java
similarity index 100%
rename from src/com/android/deskclock/alarms/TimePickerDialogFragment.java
rename to app/src/main/java/com/best/deskclock/alarms/TimePickerDialogFragment.java
index 6da6d974b..d28f0ac8b 100644
--- a/src/com/android/deskclock/alarms/TimePickerDialogFragment.java
+++ b/app/src/main/java/com/best/deskclock/alarms/TimePickerDialogFragment.java
@@ -24,10 +24,10 @@ import android.app.TimePickerDialog;
 import android.content.Context;
 import android.content.DialogInterface;
 import android.os.Bundle;
-import androidx.appcompat.app.AlertDialog;
 import android.text.format.DateFormat;
 import android.widget.TimePicker;
 
+import androidx.appcompat.app.AlertDialog;
 
 import com.best.deskclock.Utils;
 
@@ -46,45 +46,6 @@ public class TimePickerDialogFragment extends DialogFragment {
     private static final String ARG_HOUR = TAG + "_hour";
     private static final String ARG_MINUTE = TAG + "_minute";
 
-    @Override
-    @SuppressWarnings("deprecation")
-    public Dialog onCreateDialog(Bundle savedInstanceState) {
-        final OnTimeSetListener listener = ((OnTimeSetListener) getParentFragment());
-
-        final Calendar now = Calendar.getInstance();
-        final Bundle args = getArguments() == null ? Bundle.EMPTY : getArguments();
-        final int hour = args.getInt(ARG_HOUR, now.get(Calendar.HOUR_OF_DAY));
-        final int minute = args.getInt(ARG_MINUTE, now.get(Calendar.MINUTE));
-
-        if (Utils.isLOrLater()) {
-            final Context context = getActivity();
-            return new TimePickerDialog(context, new TimePickerDialog.OnTimeSetListener() {
-                @Override
-                public void onTimeSet(TimePicker view, int hourOfDay, int minute) {
-                    listener.onTimeSet(TimePickerDialogFragment.this, hourOfDay, minute);
-                }
-            }, hour, minute, DateFormat.is24HourFormat(context));
-        } else {
-            final AlertDialog.Builder builder = new AlertDialog.Builder(getContext());
-            final Context context = builder.getContext();
-
-            final TimePicker timePicker = new TimePicker(context);
-            timePicker.setCurrentHour(hour);
-            timePicker.setCurrentMinute(minute);
-            timePicker.setIs24HourView(DateFormat.is24HourFormat(context));
-
-            return builder.setView(timePicker)
-                    .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
-                        @Override
-                        public void onClick(DialogInterface dialog, int which) {
-                            listener.onTimeSet(TimePickerDialogFragment.this,
-                                    timePicker.getCurrentHour(), timePicker.getCurrentMinute());
-                        }
-                    }).setNegativeButton(android.R.string.cancel, null /* listener */)
-                    .create();
-        }
-    }
-
     public static void show(Fragment fragment) {
         show(fragment, -1 /* hour */, -1 /* minute */);
     }
@@ -125,6 +86,45 @@ public class TimePickerDialogFragment extends DialogFragment {
         }
     }
 
+    @Override
+    @SuppressWarnings("deprecation")
+    public Dialog onCreateDialog(Bundle savedInstanceState) {
+        final OnTimeSetListener listener = ((OnTimeSetListener) getParentFragment());
+
+        final Calendar now = Calendar.getInstance();
+        final Bundle args = getArguments() == null ? Bundle.EMPTY : getArguments();
+        final int hour = args.getInt(ARG_HOUR, now.get(Calendar.HOUR_OF_DAY));
+        final int minute = args.getInt(ARG_MINUTE, now.get(Calendar.MINUTE));
+
+        if (Utils.isLOrLater()) {
+            final Context context = getActivity();
+            return new TimePickerDialog(context, new TimePickerDialog.OnTimeSetListener() {
+                @Override
+                public void onTimeSet(TimePicker view, int hourOfDay, int minute) {
+                    listener.onTimeSet(TimePickerDialogFragment.this, hourOfDay, minute);
+                }
+            }, hour, minute, DateFormat.is24HourFormat(context));
+        } else {
+            final AlertDialog.Builder builder = new AlertDialog.Builder(getContext());
+            final Context context = builder.getContext();
+
+            final TimePicker timePicker = new TimePicker(context);
+            timePicker.setCurrentHour(hour);
+            timePicker.setCurrentMinute(minute);
+            timePicker.setIs24HourView(DateFormat.is24HourFormat(context));
+
+            return builder.setView(timePicker)
+                    .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialog, int which) {
+                            listener.onTimeSet(TimePickerDialogFragment.this,
+                                    timePicker.getCurrentHour(), timePicker.getCurrentMinute());
+                        }
+                    }).setNegativeButton(android.R.string.cancel, null /* listener */)
+                    .create();
+        }
+    }
+
     /**
      * The callback interface used to indicate the user is done filling in the time (e.g. they
      * clicked on the 'OK' button).
diff --git a/src/com/android/deskclock/alarms/dataadapter/AlarmItemHolder.java b/app/src/main/java/com/best/deskclock/alarms/dataadapter/AlarmItemHolder.java
similarity index 97%
rename from src/com/android/deskclock/alarms/dataadapter/AlarmItemHolder.java
rename to app/src/main/java/com/best/deskclock/alarms/dataadapter/AlarmItemHolder.java
index 45a1eb2bb..f583200bc 100644
--- a/src/com/android/deskclock/alarms/dataadapter/AlarmItemHolder.java
+++ b/app/src/main/java/com/best/deskclock/alarms/dataadapter/AlarmItemHolder.java
@@ -31,7 +31,7 @@ public class AlarmItemHolder extends ItemAdapter.ItemHolder<Alarm> {
     private boolean mExpanded;
 
     public AlarmItemHolder(Alarm alarm, AlarmInstance alarmInstance,
-            AlarmTimeClickHandler alarmTimeClickHandler) {
+                           AlarmTimeClickHandler alarmTimeClickHandler) {
         super(alarm, alarm.id);
         mAlarmInstance = alarmInstance;
         mAlarmTimeClickHandler = alarmTimeClickHandler;
diff --git a/src/com/android/deskclock/alarms/dataadapter/AlarmItemViewHolder.java b/app/src/main/java/com/best/deskclock/alarms/dataadapter/AlarmItemViewHolder.java
similarity index 91%
rename from src/com/android/deskclock/alarms/dataadapter/AlarmItemViewHolder.java
rename to app/src/main/java/com/best/deskclock/alarms/dataadapter/AlarmItemViewHolder.java
index 90360c502..e2a9c3647 100644
--- a/src/com/android/deskclock/alarms/dataadapter/AlarmItemViewHolder.java
+++ b/app/src/main/java/com/best/deskclock/alarms/dataadapter/AlarmItemViewHolder.java
@@ -57,11 +57,11 @@ public abstract class AlarmItemViewHolder extends ItemAdapter.ItemViewHolder<Ala
     public AlarmItemViewHolder(View itemView) {
         super(itemView);
 
-        clock = (TextTime) itemView.findViewById(R.id.digital_clock);
-        onOff = (CompoundButton) itemView.findViewById(R.id.onoff);
-        arrow = (ImageView) itemView.findViewById(R.id.arrow);
+        clock = itemView.findViewById(R.id.digital_clock);
+        onOff = itemView.findViewById(R.id.onoff);
+        arrow = itemView.findViewById(R.id.arrow);
         preemptiveDismissButton =
-                (TextView) itemView.findViewById(R.id.preemptive_dismiss_button);
+                itemView.findViewById(R.id.preemptive_dismiss_button);
         preemptiveDismissButton.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
@@ -101,13 +101,13 @@ public abstract class AlarmItemViewHolder extends ItemAdapter.ItemViewHolder<Ala
     }
 
     protected boolean bindPreemptiveDismissButton(Context context, Alarm alarm,
-            AlarmInstance alarmInstance) {
+                                                  AlarmInstance alarmInstance) {
         final boolean canBind = alarm.canPreemptivelyDismiss() && alarmInstance != null;
         if (canBind) {
             preemptiveDismissButton.setVisibility(View.VISIBLE);
             final String dismissText = alarm.instanceState == AlarmInstance.SNOOZE_STATE
                     ? context.getString(R.string.alarm_alert_snooze_until,
-                            AlarmUtils.getAlarmText(context, alarmInstance, false))
+                    AlarmUtils.getAlarmText(context, alarmInstance, false))
                     : context.getString(R.string.alarm_alert_dismiss_text);
             preemptiveDismissButton.setText(dismissText);
             preemptiveDismissButton.setClickable(true);
diff --git a/src/com/android/deskclock/alarms/dataadapter/CollapsedAlarmViewHolder.java b/app/src/main/java/com/best/deskclock/alarms/dataadapter/CollapsedAlarmViewHolder.java
similarity index 97%
rename from src/com/android/deskclock/alarms/dataadapter/CollapsedAlarmViewHolder.java
rename to app/src/main/java/com/best/deskclock/alarms/dataadapter/CollapsedAlarmViewHolder.java
index 086c1f189..0314bb2e3 100644
--- a/src/com/android/deskclock/alarms/dataadapter/CollapsedAlarmViewHolder.java
+++ b/app/src/main/java/com/best/deskclock/alarms/dataadapter/CollapsedAlarmViewHolder.java
@@ -22,12 +22,13 @@ import android.animation.AnimatorSet;
 import android.animation.ObjectAnimator;
 import android.content.Context;
 import android.graphics.Rect;
-import androidx.recyclerview.widget.RecyclerView.ViewHolder;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.TextView;
 
+import androidx.recyclerview.widget.RecyclerView.ViewHolder;
+
 import com.best.deskclock.AnimatorUtils;
 import com.best.deskclock.ItemAdapter;
 import com.best.deskclock.R;
@@ -46,9 +47,8 @@ import java.util.List;
 public final class CollapsedAlarmViewHolder extends AlarmItemViewHolder {
 
     public static final int VIEW_TYPE = R.layout.alarm_time_collapsed;
-
-    private final TextView alarmLabel;
     public final TextView daysOfWeek;
+    private final TextView alarmLabel;
     private final TextView upcomingInstanceLabel;
     private final View hairLine;
 
@@ -57,9 +57,9 @@ public final class CollapsedAlarmViewHolder extends AlarmItemViewHolder {
     private CollapsedAlarmViewHolder(View itemView) {
         super(itemView);
 
-        alarmLabel = (TextView) itemView.findViewById(R.id.label);
-        daysOfWeek = (TextView) itemView.findViewById(R.id.days_of_week);
-        upcomingInstanceLabel = (TextView) itemView.findViewById(R.id.upcoming_instance_label);
+        alarmLabel = itemView.findViewById(R.id.label);
+        daysOfWeek = itemView.findViewById(R.id.days_of_week);
+        upcomingInstanceLabel = itemView.findViewById(R.id.upcoming_instance_label);
         hairLine = itemView.findViewById(R.id.hairline);
 
         // Expand handler
@@ -155,14 +155,14 @@ public final class CollapsedAlarmViewHolder extends AlarmItemViewHolder {
 
     @Override
     public Animator onAnimateChange(List<Object> payloads, int fromLeft, int fromTop, int fromRight,
-            int fromBottom, long duration) {
+                                    int fromBottom, long duration) {
         /* There are no possible partial animations for collapsed view holders. */
         return null;
     }
 
     @Override
     public Animator onAnimateChange(final ViewHolder oldHolder, ViewHolder newHolder,
-            long duration) {
+                                    long duration) {
         if (!(oldHolder instanceof AlarmItemViewHolder)
                 || !(newHolder instanceof AlarmItemViewHolder)) {
             return null;
diff --git a/src/com/android/deskclock/alarms/dataadapter/ExpandedAlarmViewHolder.java b/app/src/main/java/com/best/deskclock/alarms/dataadapter/ExpandedAlarmViewHolder.java
similarity index 94%
rename from src/com/android/deskclock/alarms/dataadapter/ExpandedAlarmViewHolder.java
rename to app/src/main/java/com/best/deskclock/alarms/dataadapter/ExpandedAlarmViewHolder.java
index 7e5aefacc..aa3c634b4 100644
--- a/src/com/android/deskclock/alarms/dataadapter/ExpandedAlarmViewHolder.java
+++ b/app/src/main/java/com/best/deskclock/alarms/dataadapter/ExpandedAlarmViewHolder.java
@@ -16,19 +16,19 @@
 
 package com.best.deskclock.alarms.dataadapter;
 
+import static android.content.Context.VIBRATOR_SERVICE;
+import static android.view.View.TRANSLATION_Y;
+
 import android.animation.Animator;
 import android.animation.AnimatorListenerAdapter;
 import android.animation.AnimatorSet;
 import android.animation.ObjectAnimator;
 import android.animation.PropertyValuesHolder;
 import android.content.Context;
-import android.graphics.Color;
 import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
 import android.graphics.drawable.LayerDrawable;
 import android.os.Vibrator;
-import androidx.core.content.ContextCompat;
-import androidx.recyclerview.widget.RecyclerView.ViewHolder;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
@@ -37,6 +37,9 @@ import android.widget.CompoundButton;
 import android.widget.LinearLayout;
 import android.widget.TextView;
 
+import androidx.core.content.ContextCompat;
+import androidx.recyclerview.widget.RecyclerView.ViewHolder;
+
 import com.best.deskclock.AnimatorUtils;
 import com.best.deskclock.ItemAdapter;
 import com.best.deskclock.R;
@@ -51,9 +54,6 @@ import com.best.deskclock.uidata.UiDataModel;
 
 import java.util.List;
 
-import static android.content.Context.VIBRATOR_SERVICE;
-import static android.view.View.TRANSLATION_Y;
-
 /**
  * A ViewHolder containing views for an alarm item in expanded state.
  */
@@ -61,12 +61,12 @@ public final class ExpandedAlarmViewHolder extends AlarmItemViewHolder {
     public static final int VIEW_TYPE = R.layout.alarm_time_expanded;
 
     public final CheckBox repeat;
-    private final TextView editLabel;
     public final LinearLayout repeatDays;
-    private final CompoundButton[] dayButtons = new CompoundButton[7];
     public final CheckBox vibrate;
     public final TextView ringtone;
     public final TextView delete;
+    private final TextView editLabel;
+    private final CompoundButton[] dayButtons = new CompoundButton[7];
     private final View hairLine;
 
     private final boolean mHasVibrator;
@@ -76,18 +76,18 @@ public final class ExpandedAlarmViewHolder extends AlarmItemViewHolder {
 
         mHasVibrator = hasVibrator;
 
-        delete = (TextView) itemView.findViewById(R.id.delete);
-        repeat = (CheckBox) itemView.findViewById(R.id.repeat_onoff);
-        vibrate = (CheckBox) itemView.findViewById(R.id.vibrate_onoff);
-        ringtone = (TextView) itemView.findViewById(R.id.choose_ringtone);
-        editLabel = (TextView) itemView.findViewById(R.id.edit_label);
-        repeatDays = (LinearLayout) itemView.findViewById(R.id.repeat_days);
+        delete = itemView.findViewById(R.id.delete);
+        repeat = itemView.findViewById(R.id.repeat_onoff);
+        vibrate = itemView.findViewById(R.id.vibrate_onoff);
+        ringtone = itemView.findViewById(R.id.choose_ringtone);
+        editLabel = itemView.findViewById(R.id.edit_label);
+        repeatDays = itemView.findViewById(R.id.repeat_days);
         hairLine = itemView.findViewById(R.id.hairline);
 
         final Context context = itemView.getContext();
-        itemView.setBackground(new LayerDrawable(new Drawable[] {
+        itemView.setBackground(new LayerDrawable(new Drawable[]{
                 ContextCompat.getDrawable(context, R.drawable.alarm_background_expanded),
-                ThemeUtils.resolveDrawable(context, R.attr.selectableItemBackground)
+                ThemeUtils.resolveDrawable(context, androidx.appcompat.R.attr.selectableItemBackground)
         }));
 
         // Build button for each day.
@@ -97,7 +97,7 @@ public final class ExpandedAlarmViewHolder extends AlarmItemViewHolder {
             final View dayButtonFrame = inflater.inflate(R.layout.day_button, repeatDays,
                     false /* attachToRoot */);
             final CompoundButton dayButton =
-                    (CompoundButton) dayButtonFrame.findViewById(R.id.day_button_box);
+                    dayButtonFrame.findViewById(R.id.day_button_box);
             final int weekday = weekdays.get(i);
             dayButton.setText(UiDataModel.getUiDataModel().getShortWeekday(weekday));
             dayButton.setContentDescription(UiDataModel.getUiDataModel().getLongWeekday(weekday));
@@ -108,8 +108,6 @@ public final class ExpandedAlarmViewHolder extends AlarmItemViewHolder {
         // Cannot set in xml since we need compat functionality for API < 21
         final Drawable labelIcon = Utils.getVectorDrawable(context, R.drawable.ic_label);
         editLabel.setCompoundDrawablesRelativeWithIntrinsicBounds(labelIcon, null, null, null);
-        final Drawable deleteIcon = Utils.getVectorDrawable(context, R.drawable.ic_delete_small);
-        delete.setCompoundDrawablesRelativeWithIntrinsicBounds(deleteIcon, null, null, null);
 
         // Collapse handler
         itemView.setOnClickListener(new View.OnClickListener() {
@@ -222,10 +220,11 @@ public final class ExpandedAlarmViewHolder extends AlarmItemViewHolder {
             if (alarm.daysOfWeek.isBitOn(weekdays.get(i))) {
                 dayButton.setChecked(true);
                 dayButton.setTextColor(ThemeUtils.resolveColor(context,
-                        android.R.attr.colorBackground));
+                        android.R.attr.textColorPrimaryInverse));
             } else {
                 dayButton.setChecked(false);
-                dayButton.setTextColor(context.getResources().getColor(R.color.day_unchecked_color));
+                dayButton.setTextColor(ThemeUtils.resolveColor(context,
+                        android.R.attr.textColorPrimary));
             }
         }
         if (alarm.daysOfWeek.isRepeating()) {
@@ -259,7 +258,7 @@ public final class ExpandedAlarmViewHolder extends AlarmItemViewHolder {
 
     @Override
     public Animator onAnimateChange(List<Object> payloads, int fromLeft, int fromTop, int fromRight,
-            int fromBottom, long duration) {
+                                    int fromBottom, long duration) {
         if (payloads == null || payloads.isEmpty() || !payloads.contains(ANIMATE_REPEAT_DAYS)) {
             return null;
         }
@@ -272,8 +271,8 @@ public final class ExpandedAlarmViewHolder extends AlarmItemViewHolder {
 
         final AnimatorSet animatorSet = new AnimatorSet();
         animatorSet.playTogether(AnimatorUtils.getBoundsAnimator(itemView,
-                fromLeft, fromTop, fromRight, fromBottom,
-                itemView.getLeft(), itemView.getTop(), itemView.getRight(), itemView.getBottom()),
+                        fromLeft, fromTop, fromRight, fromBottom,
+                        itemView.getLeft(), itemView.getTop(), itemView.getRight(), itemView.getBottom()),
                 ObjectAnimator.ofFloat(repeatDays, View.ALPHA, isExpansion ? 1f : 0f),
                 ObjectAnimator.ofFloat(repeatDays, TRANSLATION_Y, isExpansion ? 0f : -height),
                 ObjectAnimator.ofFloat(ringtone, TRANSLATION_Y, 0f),
@@ -311,7 +310,7 @@ public final class ExpandedAlarmViewHolder extends AlarmItemViewHolder {
 
     @Override
     public Animator onAnimateChange(final ViewHolder oldHolder, ViewHolder newHolder,
-            long duration) {
+                                    long duration) {
         if (!(oldHolder instanceof AlarmItemViewHolder)
                 || !(newHolder instanceof AlarmItemViewHolder)) {
             return null;
diff --git a/src/com/android/deskclock/controller/Controller.java b/app/src/main/java/com/best/deskclock/controller/Controller.java
similarity index 89%
rename from src/com/android/deskclock/controller/Controller.java
rename to app/src/main/java/com/best/deskclock/controller/Controller.java
index cd46731d5..3e37019d4 100644
--- a/src/com/android/deskclock/controller/Controller.java
+++ b/app/src/main/java/com/best/deskclock/controller/Controller.java
@@ -16,15 +16,16 @@
 
 package com.best.deskclock.controller;
 
+import static com.best.deskclock.Utils.enforceMainLooper;
+
 import android.app.Activity;
 import android.content.Context;
+
 import androidx.annotation.StringRes;
 
 import com.best.deskclock.Utils;
 import com.best.deskclock.events.EventTracker;
 
-import static com.best.deskclock.Utils.enforceMainLooper;
-
 /**
  * Interactions with Android framework components responsible for part of the user experience are
  * handled via this singleton.
@@ -35,16 +36,23 @@ public final class Controller {
 
     private Context mContext;
 
-    /** The controller that dispatches app events to event trackers. */
+    /**
+     * The controller that dispatches app events to event trackers.
+     */
     private EventController mEventController;
 
-    /** The controller that interacts with voice interaction sessions on M+. */
+    /**
+     * The controller that interacts with voice interaction sessions on M+.
+     */
     private VoiceController mVoiceController;
 
-    /** The controller that creates and updates launcher shortcuts on N MR1+ */
+    /**
+     * The controller that creates and updates launcher shortcuts on N MR1+
+     */
     private ShortcutController mShortcutController;
 
-    private Controller() {}
+    private Controller() {
+    }
 
     public static Controller getController() {
         return sController;
@@ -86,8 +94,8 @@ public final class Controller {
      * events such as button presses or other user interactions with your application.
      *
      * @param category resource id of event category
-     * @param action resource id of event action
-     * @param label resource id of event label
+     * @param action   resource id of event action
+     * @param label    resource id of event label
      */
     public void sendEvent(@StringRes int category, @StringRes int action, @StringRes int label) {
         mEventController.sendEvent(category, action, label);
diff --git a/src/com/android/deskclock/controller/EventController.java b/app/src/main/java/com/best/deskclock/controller/EventController.java
similarity index 100%
rename from src/com/android/deskclock/controller/EventController.java
rename to app/src/main/java/com/best/deskclock/controller/EventController.java
diff --git a/src/com/android/deskclock/controller/ShortcutController.java b/app/src/main/java/com/best/deskclock/controller/ShortcutController.java
similarity index 99%
rename from src/com/android/deskclock/controller/ShortcutController.java
rename to app/src/main/java/com/best/deskclock/controller/ShortcutController.java
index a997a71d2..f04ea1a8b 100644
--- a/src/com/android/deskclock/controller/ShortcutController.java
+++ b/app/src/main/java/com/best/deskclock/controller/ShortcutController.java
@@ -26,6 +26,7 @@ import android.graphics.drawable.Icon;
 import android.os.Build;
 import android.os.UserManager;
 import android.provider.AlarmClock;
+
 import androidx.annotation.StringRes;
 
 import com.best.deskclock.DeskClock;
diff --git a/src/com/android/deskclock/controller/VoiceController.java b/app/src/main/java/com/best/deskclock/controller/VoiceController.java
similarity index 94%
rename from src/com/android/deskclock/controller/VoiceController.java
rename to app/src/main/java/com/best/deskclock/controller/VoiceController.java
index f77251756..e15a68270 100644
--- a/src/com/android/deskclock/controller/VoiceController.java
+++ b/app/src/main/java/com/best/deskclock/controller/VoiceController.java
@@ -33,7 +33,7 @@ class VoiceController {
      * command was processed successfully.
      *
      * @param activity an Activity that may be hosting a voice interaction session
-     * @param message to be spoken to the user to indicate success
+     * @param message  to be spoken to the user to indicate success
      */
     void notifyVoiceSuccess(Activity activity, String message) {
         if (!Utils.isMOrLater()) {
@@ -52,7 +52,7 @@ class VoiceController {
      * command failed and must be aborted.
      *
      * @param activity an Activity that may be hosting a voice interaction session
-     * @param message to be spoken to the user to indicate failure
+     * @param message  to be spoken to the user to indicate failure
      */
     void notifyVoiceFailure(Activity activity, String message) {
         if (!Utils.isMOrLater()) {
diff --git a/src/com/android/deskclock/data/AlarmModel.java b/app/src/main/java/com/best/deskclock/data/AlarmModel.java
similarity index 95%
rename from src/com/android/deskclock/data/AlarmModel.java
rename to app/src/main/java/com/best/deskclock/data/AlarmModel.java
index 5234b3944..75d1b0ae4 100644
--- a/src/com/android/deskclock/data/AlarmModel.java
+++ b/app/src/main/java/com/best/deskclock/data/AlarmModel.java
@@ -31,10 +31,14 @@ import com.best.deskclock.provider.Alarm;
  */
 final class AlarmModel {
 
-    /** The model from which settings are fetched. */
+    /**
+     * The model from which settings are fetched.
+     */
     private final SettingsModel mSettingsModel;
 
-    /** The uri of the default ringtone to play for new alarms; mirrors last selection. */
+    /**
+     * The uri of the default ringtone to play for new alarms; mirrors last selection.
+     */
     private Uri mDefaultAlarmRingtoneUri;
 
     AlarmModel(Context context, SettingsModel settingsModel) {
@@ -73,7 +77,7 @@ final class AlarmModel {
     AlarmVolumeButtonBehavior getAlarmPowerButtonBehavior() {
         return mSettingsModel.getAlarmPowerButtonBehavior();
     }
-    
+
     int getAlarmTimeout() {
         return mSettingsModel.getAlarmTimeout();
     }
diff --git a/src/com/android/deskclock/data/City.java b/app/src/main/java/com/best/deskclock/data/City.java
similarity index 86%
rename from src/com/android/deskclock/data/City.java
rename to app/src/main/java/com/best/deskclock/data/City.java
index a201f9039..eeb1664b8 100644
--- a/src/com/android/deskclock/data/City.java
+++ b/app/src/main/java/com/best/deskclock/data/City.java
@@ -16,6 +16,8 @@
 
 package com.best.deskclock.data;
 
+import androidx.annotation.NonNull;
+
 import java.text.Collator;
 import java.util.Comparator;
 import java.util.Locale;
@@ -27,25 +29,39 @@ import java.util.TimeZone;
  */
 public final class City {
 
-    /** A unique identifier for the city. */
+    /**
+     * A unique identifier for the city.
+     */
     private final String mId;
 
-    /** An optional numeric index used to order cities for display; -1 if no such index exists. */
+    /**
+     * An optional numeric index used to order cities for display; -1 if no such index exists.
+     */
     private final int mIndex;
 
-    /** An index string used to order cities for display. */
+    /**
+     * An index string used to order cities for display.
+     */
     private final String mIndexString;
 
-    /** The display name of the city. */
+    /**
+     * The display name of the city.
+     */
     private final String mName;
 
-    /** The phonetic name of the city used to order cities for display. */
+    /**
+     * The phonetic name of the city used to order cities for display.
+     */
     private final String mPhoneticName;
 
-    /** The TimeZone corresponding to the city. */
+    /**
+     * The TimeZone corresponding to the city.
+     */
     private final TimeZone mTimeZone;
 
-    /** A cached upper case form of the {@link #mName} used in case-insensitive name comparisons. */
+    /**
+     * A cached upper case form of the {@link #mName} used in case-insensitive name comparisons.
+     */
     private String mNameUpperCase;
 
     /**
@@ -63,12 +79,40 @@ public final class City {
         mTimeZone = tz;
     }
 
-    public String getId() { return mId; }
-    public int getIndex() { return mIndex; }
-    public String getName() { return mName; }
-    public TimeZone getTimeZone() { return mTimeZone; }
-    public String getIndexString() { return mIndexString; }
-    public String getPhoneticName() { return mPhoneticName; }
+    /**
+     * Strips out any characters considered optional for matching purposes. These include spaces,
+     * dashes, periods and apostrophes.
+     *
+     * @param token a city name or search term
+     * @return the given {@code token} without any characters considered optional when matching
+     */
+    public static String removeSpecialCharacters(String token) {
+        return token.replaceAll("[ -.']", "");
+    }
+
+    public String getId() {
+        return mId;
+    }
+
+    public int getIndex() {
+        return mIndex;
+    }
+
+    public String getName() {
+        return mName;
+    }
+
+    public TimeZone getTimeZone() {
+        return mTimeZone;
+    }
+
+    public String getIndexString() {
+        return mIndexString;
+    }
+
+    public String getPhoneticName() {
+        return mPhoneticName;
+    }
 
     /**
      * @return the city name converted to upper case
@@ -92,7 +136,7 @@ public final class City {
 
     /**
      * @param upperCaseQueryNoSpecialCharacters search term with all special characters removed
-     *      to match against the upper case city name
+     *                                          to match against the upper case city name
      * @return {@code true} iff the name of this city starts with the given query
      */
     public boolean matches(String upperCaseQueryNoSpecialCharacters) {
@@ -101,6 +145,7 @@ public final class City {
         return getNameUpperCaseNoSpecialCharacters().startsWith(upperCaseQueryNoSpecialCharacters);
     }
 
+    @NonNull
     @Override
     public String toString() {
         return String.format(Locale.US,
@@ -108,17 +153,6 @@ public final class City {
                 mId, mIndex, mIndexString, mName, mPhoneticName, mTimeZone.getID());
     }
 
-    /**
-     * Strips out any characters considered optional for matching purposes. These include spaces,
-     * dashes, periods and apostrophes.
-     *
-     * @param token a city name or search term
-     * @return the given {@code token} without any characters considered optional when matching
-     */
-    public static String removeSpecialCharacters(String token) {
-        return token.replaceAll("[ -.']", "");
-    }
-
     /**
      * Orders by:
      *
diff --git a/src/com/android/deskclock/data/CityDAO.java b/app/src/main/java/com/best/deskclock/data/CityDAO.java
similarity index 93%
rename from src/com/android/deskclock/data/CityDAO.java
rename to app/src/main/java/com/best/deskclock/data/CityDAO.java
index 05f084c33..348ac242f 100644
--- a/src/com/android/deskclock/data/CityDAO.java
+++ b/app/src/main/java/com/best/deskclock/data/CityDAO.java
@@ -20,10 +20,11 @@ import android.content.Context;
 import android.content.SharedPreferences;
 import android.content.res.Resources;
 import android.content.res.TypedArray;
-import androidx.annotation.VisibleForTesting;
 import android.text.TextUtils;
 import android.util.ArrayMap;
 
+import androidx.annotation.VisibleForTesting;
+
 import com.best.deskclock.R;
 
 import java.util.ArrayList;
@@ -42,16 +43,23 @@ import java.util.regex.Pattern;
  */
 final class CityDAO {
 
-    /** Regex to match numeric index values when parsing city names. */
+    /**
+     * Regex to match numeric index values when parsing city names.
+     */
     private static final Pattern NUMERIC_INDEX_REGEX = Pattern.compile("\\d+");
 
-    /** Key to a preference that stores the number of selected cities. */
+    /**
+     * Key to a preference that stores the number of selected cities.
+     */
     private static final String NUMBER_OF_CITIES = "number_of_cities";
 
-    /** Prefix for a key to a preference that stores the id of a selected city. */
+    /**
+     * Prefix for a key to a preference that stores the id of a selected city.
+     */
     private static final String CITY_ID = "city_id_";
 
-    private CityDAO() {}
+    private CityDAO() {
+    }
 
     /**
      * @param cityMap maps city ids to city instances
@@ -136,11 +144,11 @@ final class CityDAO {
     }
 
     /**
-     * @param id unique identifier for city
+     * @param id            unique identifier for city
      * @param formattedName "[index string]=[name]" or "[index string]=[name]:[phonetic name]",
      *                      If [index string] is empty, use the first character of name as index,
      *                      If phonetic name is empty, use the name itself as phonetic name.
-     * @param tzId the string id of the timezone a given city is located in
+     * @param tzId          the string id of the timezone a given city is located in
      */
     @VisibleForTesting
     static City createCity(String id, String formattedName, String tzId) {
diff --git a/src/com/android/deskclock/data/CityListener.java b/app/src/main/java/com/best/deskclock/data/CityListener.java
similarity index 100%
rename from src/com/android/deskclock/data/CityListener.java
rename to app/src/main/java/com/best/deskclock/data/CityListener.java
diff --git a/src/com/android/deskclock/data/CityModel.java b/app/src/main/java/com/best/deskclock/data/CityModel.java
similarity index 90%
rename from src/com/android/deskclock/data/CityModel.java
rename to app/src/main/java/com/best/deskclock/data/CityModel.java
index 61b5807cc..403218e7c 100644
--- a/src/com/android/deskclock/data/CityModel.java
+++ b/app/src/main/java/com/best/deskclock/data/CityModel.java
@@ -46,7 +46,9 @@ final class CityModel {
 
     private final SharedPreferences mPrefs;
 
-    /** The model from which settings are fetched. */
+    /**
+     * The model from which settings are fetched.
+     */
     private final SettingsModel mSettingsModel;
 
     /**
@@ -56,26 +58,40 @@ final class CityModel {
     @SuppressWarnings("FieldCanBeLocal")
     private final OnSharedPreferenceChangeListener mPreferenceListener = new PreferenceListener();
 
-    /** Clears data structures containing data that is locale-sensitive. */
+    /**
+     * Clears data structures containing data that is locale-sensitive.
+     */
     @SuppressWarnings("FieldCanBeLocal")
     private final BroadcastReceiver mLocaleChangedReceiver = new LocaleChangedReceiver();
 
-    /** List of listeners to invoke upon world city list change */
+    /**
+     * List of listeners to invoke upon world city list change
+     */
     private final List<CityListener> mCityListeners = new ArrayList<>();
 
-    /** Maps city ID to city instance. */
+    /**
+     * Maps city ID to city instance.
+     */
     private Map<String, City> mCityMap;
 
-    /** List of city instances in display order. */
+    /**
+     * List of city instances in display order.
+     */
     private List<City> mAllCities;
 
-    /** List of selected city instances in display order. */
+    /**
+     * List of selected city instances in display order.
+     */
     private List<City> mSelectedCities;
 
-    /** List of unselected city instances in display order. */
+    /**
+     * List of unselected city instances in display order.
+     */
     private List<City> mUnselectedCities;
 
-    /** A city instance representing the home timezone of the user. */
+    /**
+     * A city instance representing the home timezone of the user.
+     */
     private City mHomeCity;
 
     CityModel(Context context, SharedPreferences prefs, SettingsModel settingsModel) {
@@ -193,8 +209,10 @@ final class CityModel {
     Comparator<City> getCityIndexComparator() {
         final CitySort citySort = mSettingsModel.getCitySort();
         switch (citySort) {
-            case NAME: return new City.NameIndexComparator();
-            case UTC_OFFSET: return new City.UtcOffsetIndexComparator();
+            case NAME:
+                return new City.NameIndexComparator();
+            case UTC_OFFSET:
+                return new City.UtcOffsetIndexComparator();
         }
         throw new IllegalStateException("unexpected city sort: " + citySort);
     }
@@ -228,8 +246,10 @@ final class CityModel {
     private Comparator<City> getCitySortComparator() {
         final CitySort citySort = mSettingsModel.getCitySort();
         switch (citySort) {
-            case NAME: return new City.NameComparator();
-            case UTC_OFFSET: return new City.UtcOffsetComparator();
+            case NAME:
+                return new City.NameComparator();
+            case UTC_OFFSET:
+                return new City.UtcOffsetComparator();
         }
         throw new IllegalStateException("unexpected city sort: " + citySort);
     }
diff --git a/src/com/android/deskclock/data/CustomRingtone.java b/app/src/main/java/com/best/deskclock/data/CustomRingtone.java
similarity index 73%
rename from src/com/android/deskclock/data/CustomRingtone.java
rename to app/src/main/java/com/best/deskclock/data/CustomRingtone.java
index e69afbcce..5603d3969 100644
--- a/src/com/android/deskclock/data/CustomRingtone.java
+++ b/app/src/main/java/com/best/deskclock/data/CustomRingtone.java
@@ -17,6 +17,7 @@
 package com.best.deskclock.data;
 
 import android.net.Uri;
+
 import androidx.annotation.NonNull;
 
 /**
@@ -24,16 +25,24 @@ import androidx.annotation.NonNull;
  */
 public final class CustomRingtone implements Comparable<CustomRingtone> {
 
-    /** The unique identifier of the custom ringtone. */
+    /**
+     * The unique identifier of the custom ringtone.
+     */
     private final long mId;
 
-    /** The uri that allows playback of the ringtone. */
+    /**
+     * The uri that allows playback of the ringtone.
+     */
     private final Uri mUri;
 
-    /** The title describing the file at the given uri; typically the file name. */
+    /**
+     * The title describing the file at the given uri; typically the file name.
+     */
     private final String mTitle;
 
-    /** {@code true} iff the application has permission to read the content of {@code mUri uri}. */
+    /**
+     * {@code true} iff the application has permission to read the content of {@code mUri uri}.
+     */
     private final boolean mHasPermissions;
 
     CustomRingtone(long id, Uri uri, String title, boolean hasPermissions) {
@@ -43,10 +52,21 @@ public final class CustomRingtone implements Comparable<CustomRingtone> {
         mHasPermissions = hasPermissions;
     }
 
-    public long getId() { return mId; }
-    public Uri getUri() { return mUri; }
-    public String getTitle() { return mTitle; }
-    public boolean hasPermissions() { return mHasPermissions; }
+    public long getId() {
+        return mId;
+    }
+
+    public Uri getUri() {
+        return mUri;
+    }
+
+    public String getTitle() {
+        return mTitle;
+    }
+
+    public boolean hasPermissions() {
+        return mHasPermissions;
+    }
 
     CustomRingtone setHasPermissions(boolean hasPermissions) {
         if (mHasPermissions == hasPermissions) {
diff --git a/src/com/android/deskclock/data/CustomRingtoneDAO.java b/app/src/main/java/com/best/deskclock/data/CustomRingtoneDAO.java
similarity index 86%
rename from src/com/android/deskclock/data/CustomRingtoneDAO.java
rename to app/src/main/java/com/best/deskclock/data/CustomRingtoneDAO.java
index d21fe4bcc..219ecfbf9 100644
--- a/src/com/android/deskclock/data/CustomRingtoneDAO.java
+++ b/app/src/main/java/com/best/deskclock/data/CustomRingtoneDAO.java
@@ -31,22 +31,31 @@ import java.util.Set;
  */
 final class CustomRingtoneDAO {
 
-    /** Key to a preference that stores the set of all custom ringtone ids. */
+    /**
+     * Key to a preference that stores the set of all custom ringtone ids.
+     */
     private static final String RINGTONE_IDS = "ringtone_ids";
 
-    /** Key to a preference that stores the next unused ringtone id. */
+    /**
+     * Key to a preference that stores the next unused ringtone id.
+     */
     private static final String NEXT_RINGTONE_ID = "next_ringtone_id";
 
-    /** Prefix for a key to a preference that stores the URI associated with the ringtone id. */
+    /**
+     * Prefix for a key to a preference that stores the URI associated with the ringtone id.
+     */
     private static final String RINGTONE_URI = "ringtone_uri_";
 
-    /** Prefix for a key to a preference that stores the title associated with the ringtone id. */
+    /**
+     * Prefix for a key to a preference that stores the title associated with the ringtone id.
+     */
     private static final String RINGTONE_TITLE = "ringtone_title_";
 
-    private CustomRingtoneDAO() {}
+    private CustomRingtoneDAO() {
+    }
 
     /**
-     * @param uri points to an audio file located on the file system
+     * @param uri   points to an audio file located on the file system
      * @param title the title of the audio content at the given {@code uri}
      * @return the newly added custom ringtone
      */
@@ -88,7 +97,7 @@ final class CustomRingtoneDAO {
      * @return a list of all known custom ringtones
      */
     static List<CustomRingtone> getCustomRingtones(SharedPreferences prefs) {
-        final Set<String> ids = prefs.getStringSet(RINGTONE_IDS, Collections.<String>emptySet());
+        final Set<String> ids = prefs.getStringSet(RINGTONE_IDS, Collections.emptySet());
         final List<CustomRingtone> ringtones = new ArrayList<>(ids.size());
 
         for (String id : ids) {
@@ -102,6 +111,6 @@ final class CustomRingtoneDAO {
     }
 
     private static Set<String> getRingtoneIds(SharedPreferences prefs) {
-        return new HashSet<>(prefs.getStringSet(RINGTONE_IDS, Collections.<String>emptySet()));
+        return new HashSet<>(prefs.getStringSet(RINGTONE_IDS, Collections.emptySet()));
     }
 }
diff --git a/src/com/android/deskclock/data/DataModel.java b/app/src/main/java/com/best/deskclock/data/DataModel.java
similarity index 91%
rename from src/com/android/deskclock/data/DataModel.java
rename to app/src/main/java/com/best/deskclock/data/DataModel.java
index 1eb89cf22..8bdee5318 100644
--- a/src/com/android/deskclock/data/DataModel.java
+++ b/app/src/main/java/com/best/deskclock/data/DataModel.java
@@ -16,6 +16,15 @@
 
 package com.best.deskclock.data;
 
+import static android.content.Context.AUDIO_SERVICE;
+import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
+import static android.media.AudioManager.FLAG_SHOW_UI;
+import static android.media.AudioManager.STREAM_ALARM;
+import static android.provider.Settings.ACTION_APPLICATION_DETAILS_SETTINGS;
+import static android.provider.Settings.ACTION_SOUND_SETTINGS;
+import static com.best.deskclock.Utils.enforceMainLooper;
+import static com.best.deskclock.Utils.enforceNotMainLooper;
+
 import android.app.Service;
 import android.content.Context;
 import android.content.Intent;
@@ -24,9 +33,10 @@ import android.media.AudioManager;
 import android.net.Uri;
 import android.os.Handler;
 import android.os.Looper;
-import androidx.annotation.StringRes;
 import android.view.View;
 
+import androidx.annotation.StringRes;
+
 import com.best.deskclock.Predicate;
 import com.best.deskclock.R;
 import com.best.deskclock.Utils;
@@ -37,169 +47,69 @@ import java.util.Collection;
 import java.util.Comparator;
 import java.util.List;
 
-import static android.content.Context.AUDIO_SERVICE;
-import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
-import static android.media.AudioManager.FLAG_SHOW_UI;
-import static android.media.AudioManager.STREAM_ALARM;
-import static android.provider.Settings.ACTION_APPLICATION_DETAILS_SETTINGS;
-import static android.provider.Settings.ACTION_SOUND_SETTINGS;
-import static com.best.deskclock.Utils.enforceMainLooper;
-import static com.best.deskclock.Utils.enforceNotMainLooper;
-
 /**
  * All application-wide data is accessible through this singleton.
  */
 public final class DataModel {
 
-    /** Indicates the display style of clocks. */
-    public enum ClockStyle {ANALOG, DIGITAL}
-
-    /** Indicates the preferred sort order of cities. */
-    public enum CitySort {NAME, UTC_OFFSET}
-
-    /** Indicates the preferred behavior of hardware volume buttons when firing alarms. */
-    public enum AlarmVolumeButtonBehavior {NOTHING, SNOOZE, DISMISS}
-
-    /** Indicates the reason alarms may not fire or may fire silently. */
-    public enum SilentSetting {
-        @SuppressWarnings("unchecked")
-        DO_NOT_DISTURB(R.string.alarms_blocked_by_dnd, 0, Predicate.FALSE, null),
-        @SuppressWarnings("unchecked")
-        MUTED_VOLUME(R.string.alarm_volume_muted,
-                R.string.unmute_alarm_volume,
-                Predicate.TRUE,
-                new UnmuteAlarmVolumeListener()),
-        SILENT_RINGTONE(R.string.silent_default_alarm_ringtone,
-                R.string.change_setting_action,
-                new ChangeSoundActionPredicate(),
-                new ChangeSoundSettingsListener()),
-        @SuppressWarnings("unchecked")
-        BLOCKED_NOTIFICATIONS(R.string.app_notifications_blocked,
-                R.string.change_setting_action,
-                Predicate.TRUE,
-                new ChangeAppNotificationSettingsListener());
-
-        private final @StringRes int mLabelResId;
-        private final @StringRes int mActionResId;
-        private final Predicate<Context> mActionEnabled;
-        private final View.OnClickListener mActionListener;
-
-        SilentSetting(int labelResId, int actionResId, Predicate<Context> actionEnabled,
-                View.OnClickListener actionListener) {
-            mLabelResId = labelResId;
-            mActionResId = actionResId;
-            mActionEnabled = actionEnabled;
-            mActionListener = actionListener;
-        }
-
-        public @StringRes int getLabelResId() { return mLabelResId; }
-        public @StringRes int getActionResId() { return mActionResId; }
-        public View.OnClickListener getActionListener() { return mActionListener; }
-        public boolean isActionEnabled(Context context) {
-            return mLabelResId != 0 && mActionEnabled.apply(context);
-        }
-
-        private static class UnmuteAlarmVolumeListener implements View.OnClickListener {
-            @Override
-            public void onClick(View v) {
-                // Set the alarm volume to 11/16th of max and show the slider UI.
-                // 11/16th of max is the initial volume of the alarm stream on a fresh install.
-                final Context context = v.getContext();
-                final AudioManager am = (AudioManager) context.getSystemService(AUDIO_SERVICE);
-                final int index = Math.round(am.getStreamMaxVolume(STREAM_ALARM) * 11f / 16f);
-                am.setStreamVolume(STREAM_ALARM, index, FLAG_SHOW_UI);
-            }
-        }
-
-        private static class ChangeSoundSettingsListener implements View.OnClickListener {
-            @Override
-            public void onClick(View v) {
-                final Context context = v.getContext();
-                context.startActivity(new Intent(ACTION_SOUND_SETTINGS)
-                        .addFlags(FLAG_ACTIVITY_NEW_TASK));
-            }
-        }
-
-        private static class ChangeSoundActionPredicate implements Predicate<Context> {
-            @Override
-            public boolean apply(Context context) {
-                final Intent intent = new Intent(ACTION_SOUND_SETTINGS);
-                return intent.resolveActivity(context.getPackageManager()) != null;
-            }
-        }
-
-        private static class ChangeAppNotificationSettingsListener implements View.OnClickListener {
-            @Override
-            public void onClick(View v) {
-                final Context context = v.getContext();
-                if (Utils.isLOrLater()) {
-                    try {
-                        // Attempt to open the notification settings for this app.
-                        context.startActivity(
-                                new Intent("android.settings.APP_NOTIFICATION_SETTINGS")
-                                .putExtra("app_package", context.getPackageName())
-                                .putExtra("app_uid", context.getApplicationInfo().uid)
-                                .addFlags(FLAG_ACTIVITY_NEW_TASK));
-                        return;
-                    } catch (Exception ignored) {
-                        // best attempt only; recovery code below
-                    }
-                }
-
-                // Fall back to opening the app settings page.
-                context.startActivity(new Intent(ACTION_APPLICATION_DETAILS_SETTINGS)
-                        .setData(Uri.fromParts("package", context.getPackageName(), null))
-                        .addFlags(FLAG_ACTIVITY_NEW_TASK));
-            }
-        }
-    }
-
     public static final String ACTION_WORLD_CITIES_CHANGED =
             "com.best.deskclock.WORLD_CITIES_CHANGED";
-
-    /** The single instance of this data model that exists for the life of the application. */
+    /**
+     * The single instance of this data model that exists for the life of the application.
+     */
     private static final DataModel sDataModel = new DataModel();
-
     private Handler mHandler;
-
     private Context mContext;
-
-    /** The model from which settings are fetched. */
+    /**
+     * The model from which settings are fetched.
+     */
     private SettingsModel mSettingsModel;
-
-    /** The model from which city data are fetched. */
+    /**
+     * The model from which city data are fetched.
+     */
     private CityModel mCityModel;
-
-    /** The model from which timer data are fetched. */
+    /**
+     * The model from which timer data are fetched.
+     */
     private TimerModel mTimerModel;
-
-    /** The model from which alarm data are fetched. */
+    /**
+     * The model from which alarm data are fetched.
+     */
     private AlarmModel mAlarmModel;
 
-    /** The model from which widget data are fetched. */
+    private ThemeModel mThemeModel;
+    /**
+     * The model from which widget data are fetched.
+     */
     private WidgetModel mWidgetModel;
-
-    /** The model from which data about settings that silence alarms are fetched. */
+    /**
+     * The model from which data about settings that silence alarms are fetched.
+     */
     private SilentSettingsModel mSilentSettingsModel;
-
-    /** The model from which stopwatch data are fetched. */
+    /**
+     * The model from which stopwatch data are fetched.
+     */
     private StopwatchModel mStopwatchModel;
-
-    /** The model from which notification data are fetched. */
+    /**
+     * The model from which notification data are fetched.
+     */
     private NotificationModel mNotificationModel;
-
-    /** The model from which time data are fetched. */
+    /**
+     * The model from which time data are fetched.
+     */
     private TimeModel mTimeModel;
-
-    /** The model from which ringtone data are fetched. */
+    /**
+     * The model from which ringtone data are fetched.
+     */
     private RingtoneModel mRingtoneModel;
 
+    private DataModel() {
+    }
+
     public static DataModel getDataModel() {
         return sDataModel;
     }
 
-    private DataModel() {}
-
     /**
      * Initializes the data model with the context and shared preferences to be used.
      */
@@ -214,6 +124,7 @@ public final class DataModel {
             mSettingsModel = new SettingsModel(mContext, prefs, mTimeModel);
             mCityModel = new CityModel(mContext, prefs, mSettingsModel);
             mAlarmModel = new AlarmModel(mContext, mSettingsModel);
+            mThemeModel = new ThemeModel(mContext, mSettingsModel);
             mSilentSettingsModel = new SilentSettingsModel(mContext, mNotificationModel);
             mStopwatchModel = new StopwatchModel(mContext, prefs, mNotificationModel);
             mTimerModel = new TimerModel(mContext, prefs, mSettingsModel, mRingtoneModel,
@@ -280,9 +191,13 @@ public final class DataModel {
         return mHandler;
     }
 
-    //
-    // Application
-    //
+    /**
+     * @return {@code true} when the application is open in the foreground; {@code false} otherwise
+     */
+    public boolean isApplicationInForeground() {
+        enforceMainLooper();
+        return mNotificationModel.isApplicationInForeground();
+    }
 
     /**
      * @param inForeground {@code true} to indicate the application is open in the foreground
@@ -301,14 +216,6 @@ public final class DataModel {
         }
     }
 
-    /**
-     * @return {@code true} when the application is open in the foreground; {@code false} otherwise
-     */
-    public boolean isApplicationInForeground() {
-        enforceMainLooper();
-        return mNotificationModel.isApplicationInForeground();
-    }
-
     /**
      * Called when the notifications may be stale or absent from the notification manager and must
      * be rebuilt. e.g. after upgrading the application
@@ -320,10 +227,6 @@ public final class DataModel {
         mStopwatchModel.updateNotification();
     }
 
-    //
-    // Cities
-    //
-
     /**
      * @return a list of all cities in their display order
      */
@@ -332,6 +235,10 @@ public final class DataModel {
         return mCityModel.getAllCities();
     }
 
+    //
+    // Application
+    //
+
     /**
      * @return a city representing the user's home timezone
      */
@@ -356,6 +263,10 @@ public final class DataModel {
         return mCityModel.getSelectedCities();
     }
 
+    //
+    // Cities
+    //
+
     /**
      * @param cities the new collection of cities selected for display by the user
      */
@@ -404,10 +315,6 @@ public final class DataModel {
         mCityModel.removeCityListener(cityListener);
     }
 
-    //
-    // Timers
-    //
-
     /**
      * @param timerListener to be notified when timers are added, updated and removed
      */
@@ -440,6 +347,10 @@ public final class DataModel {
         return mTimerModel.getExpiredTimers();
     }
 
+    //
+    // Timers
+    //
+
     /**
      * @param timerId identifies the timer to return
      * @return the timer with the given {@code timerId}
@@ -451,7 +362,7 @@ public final class DataModel {
 
     /**
      * @return the timer that last expired and is still expired now; {@code null} if no timers are
-     *      expired
+     * expired
      */
     public Timer getMostRecentExpiredTimer() {
         enforceMainLooper();
@@ -459,8 +370,8 @@ public final class DataModel {
     }
 
     /**
-     * @param length the length of the timer in milliseconds
-     * @param label describes the purpose of the timer
+     * @param length         the length of the timer in milliseconds
+     * @param label          describes the purpose of the timer
      * @param deleteAfterUse {@code true} indicates the timer should be deleted when it is reset
      * @return the newly added timer
      */
@@ -486,7 +397,7 @@ public final class DataModel {
 
     /**
      * @param service used to start foreground notifications for expired timers
-     * @param timer the timer to be started
+     * @param timer   the timer to be started
      */
     public void startTimer(Service service, Timer timer) {
         enforceMainLooper();
@@ -511,7 +422,7 @@ public final class DataModel {
 
     /**
      * @param service used to start foreground notifications for expired timers
-     * @param timer the timer to be expired
+     * @param timer   the timer to be expired
      */
     public void expireTimer(Service service, Timer timer) {
         enforceMainLooper();
@@ -532,7 +443,7 @@ public final class DataModel {
      * removes the the timer. The timer is otherwise transitioned to the reset state and continues
      * to exist.
      *
-     * @param timer the timer to be reset
+     * @param timer        the timer to be reset
      * @param eventLabelId the label of the timer event to send; 0 if no event should be sent
      * @return the reset {@code timer} or {@code null} if the timer was deleted
      */
@@ -589,7 +500,7 @@ public final class DataModel {
     }
 
     /**
-     * @param timer the timer whose {@code length} to change
+     * @param timer  the timer whose {@code length} to change
      * @param length the new length of the timer in milliseconds
      */
     public void setTimerLength(Timer timer, long length) {
@@ -598,7 +509,7 @@ public final class DataModel {
     }
 
     /**
-     * @param timer the timer whose {@code remainingTime} to change
+     * @param timer         the timer whose {@code remainingTime} to change
      * @param remainingTime the new remaining time of the timer in milliseconds
      */
     public void setRemainingTime(Timer timer, long remainingTime) {
@@ -661,7 +572,7 @@ public final class DataModel {
 
     /**
      * @return the duration, in milliseconds, of the crescendo to apply to timer ringtone playback;
-     *      {@code 0} implies no crescendo should be applied
+     * {@code 0} implies no crescendo should be applied
      */
     public long getTimerCrescendoDuration() {
         enforceMainLooper();
@@ -684,10 +595,6 @@ public final class DataModel {
         mTimerModel.setTimerVibrate(enabled);
     }
 
-    //
-    // Alarms
-    //
-
     /**
      * @return the uri of the ringtone to which all new alarms default
      */
@@ -706,7 +613,7 @@ public final class DataModel {
 
     /**
      * @return the duration, in milliseconds, of the crescendo to apply to alarm ringtone playback;
-     *      {@code 0} implies no crescendo should be applied
+     * {@code 0} implies no crescendo should be applied
      */
     public long getAlarmCrescendoDuration() {
         enforceMainLooper();
@@ -721,14 +628,23 @@ public final class DataModel {
         return mAlarmModel.getAlarmVolumeButtonBehavior();
     }
 
-     /**
+    public ThemeButtonBehavior getThemeButtonBehavior() {
+        enforceMainLooper();
+        return mThemeModel.getThemeButtonBehavior();
+    }
+
+    //
+    // Alarms
+    //
+
+    /**
      * @return the behavior to execute when power buttons are pressed while firing an alarm
      */
     public AlarmVolumeButtonBehavior getAlarmPowerButtonBehavior() {
         enforceMainLooper();
         return mAlarmModel.getAlarmPowerButtonBehavior();
     }
-    
+
     /**
      * @return the number of minutes an alarm may ring before it has timed out and becomes missed
      */
@@ -751,10 +667,6 @@ public final class DataModel {
         return mAlarmModel.getShakeAction();
     }
 
-    //
-    // Stopwatch
-    //
-
     /**
      * @param stopwatchListener to be notified when stopwatch changes or laps are added
      */
@@ -787,6 +699,10 @@ public final class DataModel {
         return mStopwatchModel.setStopwatch(getStopwatch().start());
     }
 
+    //
+    // Stopwatch
+    //
+
     /**
      * @return the stopwatch after being paused
      */
@@ -844,11 +760,6 @@ public final class DataModel {
         return mStopwatchModel.getCurrentLapTime(time);
     }
 
-    //
-    // Time
-    // (Time settings/values are accessible from any Thread so no Thread-enforcement exists.)
-    //
-
     /**
      * @return the current time in milliseconds
      */
@@ -878,7 +789,8 @@ public final class DataModel {
     }
 
     //
-    // Ringtones
+    // Time
+    // (Time settings/values are accessible from any Thread so no Thread-enforcement exists.)
     //
 
     /**
@@ -909,7 +821,7 @@ public final class DataModel {
     }
 
     /**
-     * @param uri the uri of an audio file to use as a ringtone
+     * @param uri   the uri of an audio file to use as a ringtone
      * @param title the title of the audio content at the given {@code uri}
      * @return the ringtone instance created for the audio file
      */
@@ -918,6 +830,10 @@ public final class DataModel {
         return mRingtoneModel.addCustomRingtone(uri, title);
     }
 
+    //
+    // Ringtones
+    //
+
     /**
      * @param uri identifies the ringtone to remove
      */
@@ -934,13 +850,9 @@ public final class DataModel {
         return mRingtoneModel.getCustomRingtones();
     }
 
-    //
-    // Widgets
-    //
-
     /**
-     * @param widgetClass indicates the type of widget being counted
-     * @param count the number of widgets of the given type
+     * @param widgetClass     indicates the type of widget being counted
+     * @param count           the number of widgets of the given type
      * @param eventCategoryId identifies the category of event to send
      */
     public void updateWidgetCount(Class widgetClass, int count, @StringRes int eventCategoryId) {
@@ -948,10 +860,6 @@ public final class DataModel {
         mWidgetModel.updateWidgetCount(widgetClass, count, eventCategoryId);
     }
 
-    //
-    // Settings
-    //
-
     /**
      * @param silentSettingsListener to be notified when alarm-silencing settings change
      */
@@ -975,6 +883,10 @@ public final class DataModel {
         return mSettingsModel.getGlobalIntentId();
     }
 
+    //
+    // Widgets
+    //
+
     /**
      * Update the id used to discriminate relevant AlarmManager callbacks from defunct ones
      */
@@ -983,6 +895,10 @@ public final class DataModel {
         mSettingsModel.updateGlobalIntentId();
     }
 
+    //
+    // Settings
+    //
+
     /**
      * @return the style of clock to display in the clock application
      */
@@ -1025,7 +941,7 @@ public final class DataModel {
 
     /**
      * @return {@code true} if the users wants to automatically show a clock for their home timezone
-     *      when they have travelled outside of that timezone
+     * when they have travelled outside of that timezone
      */
     public boolean getShowHomeClock() {
         enforceMainLooper();
@@ -1034,7 +950,7 @@ public final class DataModel {
 
     /**
      * @return the display order of the weekdays, which can start with {@link Calendar#SATURDAY},
-     *      {@link Calendar#SUNDAY} or {@link Calendar#MONDAY}
+     * {@link Calendar#SUNDAY} or {@link Calendar#MONDAY}
      */
     public Weekdays.Order getWeekdayOrder() {
         enforceMainLooper();
@@ -1063,6 +979,129 @@ public final class DataModel {
         return mSettingsModel.getTimeZones();
     }
 
+    /**
+     * Indicates the display style of clocks.
+     */
+    public enum ClockStyle {ANALOG, DIGITAL}
+
+    /**
+     * Indicates the preferred sort order of cities.
+     */
+    public enum CitySort {NAME, UTC_OFFSET}
+
+    /**
+     * Indicates the preferred behavior of hardware volume buttons when firing alarms.
+     */
+    public enum AlarmVolumeButtonBehavior {NOTHING, SNOOZE, DISMISS}
+
+    public enum ThemeButtonBehavior {SYSTEM, DARK, LIGHT}
+
+    /**
+     * Indicates the reason alarms may not fire or may fire silently.
+     */
+    public enum SilentSetting {
+        DO_NOT_DISTURB(R.string.alarms_blocked_by_dnd, 0, Predicate.FALSE, null),
+        MUTED_VOLUME(R.string.alarm_volume_muted,
+                R.string.unmute_alarm_volume,
+                Predicate.TRUE,
+                new UnmuteAlarmVolumeListener()),
+        SILENT_RINGTONE(R.string.silent_default_alarm_ringtone,
+                R.string.change_setting_action,
+                new ChangeSoundActionPredicate(),
+                new ChangeSoundSettingsListener()),
+        BLOCKED_NOTIFICATIONS(R.string.app_notifications_blocked,
+                R.string.change_setting_action,
+                Predicate.TRUE,
+                new ChangeAppNotificationSettingsListener());
+
+        private final @StringRes
+        int mLabelResId;
+        private final @StringRes
+        int mActionResId;
+        private final Predicate<Context> mActionEnabled;
+        private final View.OnClickListener mActionListener;
+
+        SilentSetting(int labelResId, int actionResId, Predicate<Context> actionEnabled,
+                      View.OnClickListener actionListener) {
+            mLabelResId = labelResId;
+            mActionResId = actionResId;
+            mActionEnabled = actionEnabled;
+            mActionListener = actionListener;
+        }
+
+        public @StringRes
+        int getLabelResId() {
+            return mLabelResId;
+        }
+
+        public @StringRes
+        int getActionResId() {
+            return mActionResId;
+        }
+
+        public View.OnClickListener getActionListener() {
+            return mActionListener;
+        }
+
+        public boolean isActionEnabled(Context context) {
+            return mLabelResId != 0 && mActionEnabled.apply(context);
+        }
+
+        private static class UnmuteAlarmVolumeListener implements View.OnClickListener {
+            @Override
+            public void onClick(View v) {
+                // Set the alarm volume to 11/16th of max and show the slider UI.
+                // 11/16th of max is the initial volume of the alarm stream on a fresh install.
+                final Context context = v.getContext();
+                final AudioManager am = (AudioManager) context.getSystemService(AUDIO_SERVICE);
+                final int index = Math.round(am.getStreamMaxVolume(STREAM_ALARM) * 11f / 16f);
+                am.setStreamVolume(STREAM_ALARM, index, FLAG_SHOW_UI);
+            }
+        }
+
+        private static class ChangeSoundSettingsListener implements View.OnClickListener {
+            @Override
+            public void onClick(View v) {
+                final Context context = v.getContext();
+                context.startActivity(new Intent(ACTION_SOUND_SETTINGS)
+                        .addFlags(FLAG_ACTIVITY_NEW_TASK));
+            }
+        }
+
+        private static class ChangeSoundActionPredicate implements Predicate<Context> {
+            @Override
+            public boolean apply(Context context) {
+                final Intent intent = new Intent(ACTION_SOUND_SETTINGS);
+                return intent.resolveActivity(context.getPackageManager()) != null;
+            }
+        }
+
+        private static class ChangeAppNotificationSettingsListener implements View.OnClickListener {
+            @Override
+            public void onClick(View v) {
+                final Context context = v.getContext();
+                if (Utils.isLOrLater()) {
+                    try {
+                        // Attempt to open the notification settings for this app.
+                        context.startActivity(
+                                new Intent("android.settings.APP_NOTIFICATION_SETTINGS")
+                                        .putExtra("app_package", context.getPackageName())
+                                        .putExtra("app_uid", context.getApplicationInfo().uid)
+                                        .addFlags(FLAG_ACTIVITY_NEW_TASK));
+                        return;
+                    } catch (Exception ignored) {
+                        // best attempt only; recovery code below
+                    }
+                }
+
+                // Fall back to opening the app settings page.
+                context.startActivity(new Intent(ACTION_APPLICATION_DETAILS_SETTINGS)
+                        .setData(Uri.fromParts("package", context.getPackageName(), null))
+                        .addFlags(FLAG_ACTIVITY_NEW_TASK));
+            }
+        }
+    }
+
     /**
      * Used to execute a delegate runnable and track its completion.
      */
diff --git a/src/com/android/deskclock/data/Lap.java b/app/src/main/java/com/best/deskclock/data/Lap.java
similarity index 70%
rename from src/com/android/deskclock/data/Lap.java
rename to app/src/main/java/com/best/deskclock/data/Lap.java
index d9a9f019a..796de6376 100644
--- a/src/com/android/deskclock/data/Lap.java
+++ b/app/src/main/java/com/best/deskclock/data/Lap.java
@@ -21,13 +21,19 @@ package com.best.deskclock.data;
  */
 public final class Lap {
 
-    /** The 1-based position of the lap. */
+    /**
+     * The 1-based position of the lap.
+     */
     private final int mLapNumber;
 
-    /** Elapsed time in ms since the lap was last started. */
+    /**
+     * Elapsed time in ms since the lap was last started.
+     */
     private final long mLapTime;
 
-    /** Elapsed time in ms accumulated for all laps up to and including this one. */
+    /**
+     * Elapsed time in ms accumulated for all laps up to and including this one.
+     */
     private final long mAccumulatedTime;
 
     Lap(int lapNumber, long lapTime, long accumulatedTime) {
@@ -36,7 +42,15 @@ public final class Lap {
         mAccumulatedTime = accumulatedTime;
     }
 
-    public int getLapNumber() { return mLapNumber; }
-    public long getLapTime() { return mLapTime; }
-    public long getAccumulatedTime() { return mAccumulatedTime; }
+    public int getLapNumber() {
+        return mLapNumber;
+    }
+
+    public long getLapTime() {
+        return mLapTime;
+    }
+
+    public long getAccumulatedTime() {
+        return mAccumulatedTime;
+    }
 }
diff --git a/src/com/android/deskclock/data/NotificationModel.java b/app/src/main/java/com/best/deskclock/data/NotificationModel.java
similarity index 100%
rename from src/com/android/deskclock/data/NotificationModel.java
rename to app/src/main/java/com/best/deskclock/data/NotificationModel.java
index dff93516d..ba6d7387a 100644
--- a/src/com/android/deskclock/data/NotificationModel.java
+++ b/app/src/main/java/com/best/deskclock/data/NotificationModel.java
@@ -24,17 +24,17 @@ final class NotificationModel {
     private boolean mApplicationInForeground;
 
     /**
-     * @param inForeground {@code true} to indicate the application is open in the foreground
+     * @return {@code true} while the application is open in the foreground
      */
-    void setApplicationInForeground(boolean inForeground) {
-        mApplicationInForeground = inForeground;
+    boolean isApplicationInForeground() {
+        return mApplicationInForeground;
     }
 
     /**
-     * @return {@code true} while the application is open in the foreground
+     * @param inForeground {@code true} to indicate the application is open in the foreground
      */
-    boolean isApplicationInForeground() {
-        return mApplicationInForeground;
+    void setApplicationInForeground(boolean inForeground) {
+        mApplicationInForeground = inForeground;
     }
 
     //
diff --git a/src/com/android/deskclock/data/OnSilentSettingsListener.java b/app/src/main/java/com/best/deskclock/data/OnSilentSettingsListener.java
similarity index 100%
rename from src/com/android/deskclock/data/OnSilentSettingsListener.java
rename to app/src/main/java/com/best/deskclock/data/OnSilentSettingsListener.java
diff --git a/src/com/android/deskclock/data/RingtoneModel.java b/app/src/main/java/com/best/deskclock/data/RingtoneModel.java
similarity index 96%
rename from src/com/android/deskclock/data/RingtoneModel.java
rename to app/src/main/java/com/best/deskclock/data/RingtoneModel.java
index 7b9679817..6644f0d3e 100644
--- a/src/com/android/deskclock/data/RingtoneModel.java
+++ b/app/src/main/java/com/best/deskclock/data/RingtoneModel.java
@@ -16,6 +16,9 @@
 
 package com.best.deskclock.data;
 
+import static android.media.AudioManager.STREAM_ALARM;
+import static android.media.RingtoneManager.TITLE_COLUMN_INDEX;
+
 import android.annotation.SuppressLint;
 import android.content.BroadcastReceiver;
 import android.content.ContentResolver;
@@ -44,9 +47,6 @@ import java.util.ListIterator;
 import java.util.Map;
 import java.util.Set;
 
-import static android.media.AudioManager.STREAM_ALARM;
-import static android.media.RingtoneManager.TITLE_COLUMN_INDEX;
-
 /**
  * All ringtone data is accessed via this model.
  */
@@ -56,14 +56,20 @@ final class RingtoneModel {
 
     private final SharedPreferences mPrefs;
 
-    /** Maps ringtone uri to ringtone title; looking up a title from scratch is expensive. */
+    /**
+     * Maps ringtone uri to ringtone title; looking up a title from scratch is expensive.
+     */
     private final Map<Uri, String> mRingtoneTitles = new ArrayMap<>(16);
 
-    /** Clears data structures containing data that is locale-sensitive. */
+    /**
+     * Clears data structures containing data that is locale-sensitive.
+     */
     @SuppressWarnings("FieldCanBeLocal")
     private final BroadcastReceiver mLocaleChangedReceiver = new LocaleChangedReceiver();
 
-    /** A mutable copy of the custom ringtones. */
+    /**
+     * A mutable copy of the custom ringtones.
+     */
     private List<CustomRingtone> mCustomRingtones;
 
     RingtoneModel(Context context, SharedPreferences prefs) {
@@ -132,7 +138,7 @@ final class RingtoneModel {
             permissions.add(uriPermission.getUri());
         }
 
-        for (ListIterator<CustomRingtone> i = ringtones.listIterator(); i.hasNext();) {
+        for (ListIterator<CustomRingtone> i = ringtones.listIterator(); i.hasNext(); ) {
             final CustomRingtone ringtone = i.next();
             i.set(ringtone.setHasPermissions(permissions.contains(ringtone.getUri())));
         }
diff --git a/src/com/android/deskclock/data/SettingsDAO.java b/app/src/main/java/com/best/deskclock/data/SettingsDAO.java
similarity index 86%
rename from src/com/android/deskclock/data/SettingsDAO.java
rename to app/src/main/java/com/best/deskclock/data/SettingsDAO.java
index 961d2eec8..bbab019c4 100644
--- a/src/com/android/deskclock/data/SettingsDAO.java
+++ b/app/src/main/java/com/best/deskclock/data/SettingsDAO.java
@@ -16,18 +16,35 @@
 
 package com.best.deskclock.data;
 
+import static android.text.format.DateUtils.HOUR_IN_MILLIS;
+import static android.text.format.DateUtils.MINUTE_IN_MILLIS;
+import static com.best.deskclock.data.DataModel.AlarmVolumeButtonBehavior.DISMISS;
+import static com.best.deskclock.data.DataModel.AlarmVolumeButtonBehavior.NOTHING;
+import static com.best.deskclock.data.DataModel.AlarmVolumeButtonBehavior.SNOOZE;
+import static com.best.deskclock.data.DataModel.ThemeButtonBehavior.DARK;
+import static com.best.deskclock.data.DataModel.ThemeButtonBehavior.LIGHT;
+import static com.best.deskclock.data.DataModel.ThemeButtonBehavior.SYSTEM;
+import static com.best.deskclock.data.Weekdays.Order.MON_TO_SUN;
+import static com.best.deskclock.data.Weekdays.Order.SAT_TO_FRI;
+import static com.best.deskclock.data.Weekdays.Order.SUN_TO_SAT;
+import static java.util.Calendar.MONDAY;
+import static java.util.Calendar.SATURDAY;
+import static java.util.Calendar.SUNDAY;
+
 import android.content.Context;
 import android.content.SharedPreferences;
 import android.content.res.Resources;
 import android.net.Uri;
 import android.provider.Settings;
-import androidx.annotation.NonNull;
 import android.text.format.DateUtils;
 
+import androidx.annotation.NonNull;
+
 import com.best.deskclock.R;
 import com.best.deskclock.data.DataModel.AlarmVolumeButtonBehavior;
 import com.best.deskclock.data.DataModel.CitySort;
 import com.best.deskclock.data.DataModel.ClockStyle;
+import com.best.deskclock.data.DataModel.ThemeButtonBehavior;
 import com.best.deskclock.settings.ScreensaverSettingsActivity;
 import com.best.deskclock.settings.SettingsActivity;
 
@@ -36,36 +53,33 @@ import java.util.Calendar;
 import java.util.Locale;
 import java.util.TimeZone;
 
-import static android.text.format.DateUtils.HOUR_IN_MILLIS;
-import static android.text.format.DateUtils.MINUTE_IN_MILLIS;
-import static com.best.deskclock.data.DataModel.AlarmVolumeButtonBehavior.DISMISS;
-import static com.best.deskclock.data.DataModel.AlarmVolumeButtonBehavior.NOTHING;
-import static com.best.deskclock.data.DataModel.AlarmVolumeButtonBehavior.SNOOZE;
-import static com.best.deskclock.data.Weekdays.Order.MON_TO_SUN;
-import static com.best.deskclock.data.Weekdays.Order.SAT_TO_FRI;
-import static com.best.deskclock.data.Weekdays.Order.SUN_TO_SAT;
-import static java.util.Calendar.MONDAY;
-import static java.util.Calendar.SATURDAY;
-import static java.util.Calendar.SUNDAY;
-
 /**
  * This class encapsulates the storage of application preferences in {@link SharedPreferences}.
  */
 final class SettingsDAO {
 
-    /** Key to a preference that stores the preferred sort order of world cities. */
+    /**
+     * Key to a preference that stores the preferred sort order of world cities.
+     */
     private static final String KEY_SORT_PREFERENCE = "sort_preference";
 
-    /** Key to a preference that stores the default ringtone for new alarms. */
+    /**
+     * Key to a preference that stores the default ringtone for new alarms.
+     */
     private static final String KEY_DEFAULT_ALARM_RINGTONE_URI = "default_alarm_ringtone_uri";
 
-    /** Key to a preference that stores the global broadcast id. */
+    /**
+     * Key to a preference that stores the global broadcast id.
+     */
     private static final String KEY_ALARM_GLOBAL_ID = "intent.extra.alarm.global.id";
 
-    /** Key to a preference that indicates whether restore (of backup and restore) has completed. */
+    /**
+     * Key to a preference that indicates whether restore (of backup and restore) has completed.
+     */
     private static final String KEY_RESTORE_BACKUP_FINISHED = "restore_finished";
 
-    private SettingsDAO() {}
+    private SettingsDAO() {
+    }
 
     /**
      * @return the id used to discriminate relevant AlarmManager callbacks from defunct ones
@@ -102,7 +116,7 @@ final class SettingsDAO {
 
     /**
      * @return {@code true} if a clock for the user's home timezone should be automatically
-     *      displayed when it doesn't match the current timezone
+     * displayed when it doesn't match the current timezone
      */
     static boolean getAutoShowHomeClock(SharedPreferences prefs) {
         return prefs.getBoolean(SettingsActivity.KEY_AUTO_HOME_CLOCK, true);
@@ -142,7 +156,7 @@ final class SettingsDAO {
      * @return a value indicating whether analog or digital clocks are displayed in the app
      */
     static boolean getDisplayClockSeconds(SharedPreferences prefs) {
-       return prefs.getBoolean(SettingsActivity.KEY_CLOCK_DISPLAY_SECONDS, false);
+        return prefs.getBoolean(SettingsActivity.KEY_CLOCK_DISPLAY_SECONDS, false);
     }
 
     /**
@@ -180,7 +194,7 @@ final class SettingsDAO {
 
     /**
      * @return the uri of the selected ringtone or the {@code defaultUri} if no explicit selection
-     *      has yet been made
+     * has yet been made
      */
     static Uri getTimerRingtoneUri(SharedPreferences prefs, Uri defaultUri) {
         final String uriString = prefs.getString(SettingsActivity.KEY_TIMER_RINGTONE, null);
@@ -210,7 +224,7 @@ final class SettingsDAO {
 
     /**
      * @return the uri of the selected ringtone or the {@code defaultUri} if no explicit selection
-     *      has yet been made
+     * has yet been made
      */
     static Uri getDefaultAlarmRingtoneUri(SharedPreferences prefs) {
         final String uriString = prefs.getString(KEY_DEFAULT_ALARM_RINGTONE_URI, null);
@@ -226,7 +240,7 @@ final class SettingsDAO {
 
     /**
      * @return the duration, in milliseconds, of the crescendo to apply to alarm ringtone playback;
-     *      {@code 0} implies no crescendo should be applied
+     * {@code 0} implies no crescendo should be applied
      */
     static long getAlarmCrescendoDuration(SharedPreferences prefs) {
         final String crescendoSeconds = prefs.getString(SettingsActivity.KEY_ALARM_CRESCENDO, "0");
@@ -235,7 +249,7 @@ final class SettingsDAO {
 
     /**
      * @return the duration, in milliseconds, of the crescendo to apply to timer ringtone playback;
-     *      {@code 0} implies no crescendo should be applied
+     * {@code 0} implies no crescendo should be applied
      */
     static long getTimerCrescendoDuration(SharedPreferences prefs) {
         final String crescendoSeconds = prefs.getString(SettingsActivity.KEY_TIMER_CRESCENDO, "0");
@@ -244,16 +258,19 @@ final class SettingsDAO {
 
     /**
      * @return the display order of the weekdays, which can start with {@link Calendar#SATURDAY},
-     *      {@link Calendar#SUNDAY} or {@link Calendar#MONDAY}
+     * {@link Calendar#SUNDAY} or {@link Calendar#MONDAY}
      */
     static Weekdays.Order getWeekdayOrder(SharedPreferences prefs) {
         final String defaultValue = String.valueOf(Calendar.getInstance().getFirstDayOfWeek());
         final String value = prefs.getString(SettingsActivity.KEY_WEEK_START, defaultValue);
         final int firstCalendarDay = Integer.parseInt(value);
         switch (firstCalendarDay) {
-            case SATURDAY: return SAT_TO_FRI;
-            case SUNDAY: return SUN_TO_SAT;
-            case MONDAY: return MON_TO_SUN;
+            case SATURDAY:
+                return SAT_TO_FRI;
+            case SUNDAY:
+                return SUN_TO_SAT;
+            case MONDAY:
+                return MON_TO_SUN;
             default:
                 throw new IllegalArgumentException("Unknown weekday: " + firstCalendarDay);
         }
@@ -284,14 +301,32 @@ final class SettingsDAO {
         final String defaultValue = SettingsActivity.DEFAULT_VOLUME_BEHAVIOR;
         final String value = prefs.getString(SettingsActivity.KEY_VOLUME_BUTTONS, defaultValue);
         switch (value) {
-            case SettingsActivity.DEFAULT_VOLUME_BEHAVIOR: return NOTHING;
-            case SettingsActivity.VOLUME_BEHAVIOR_SNOOZE: return SNOOZE;
-            case SettingsActivity.VOLUME_BEHAVIOR_DISMISS: return DISMISS;
+            case SettingsActivity.DEFAULT_VOLUME_BEHAVIOR:
+                return NOTHING;
+            case SettingsActivity.VOLUME_BEHAVIOR_SNOOZE:
+                return SNOOZE;
+            case SettingsActivity.VOLUME_BEHAVIOR_DISMISS:
+                return DISMISS;
             default:
                 throw new IllegalArgumentException("Unknown volume button behavior: " + value);
         }
     }
 
+    static ThemeButtonBehavior getThemeButtonBehavior(SharedPreferences prefs) {
+        final String defaultValue = SettingsActivity.SYSTEM_THEME_BEHAVIOR;
+        final String value = prefs.getString(SettingsActivity.KEY_THEME, defaultValue);
+        switch (value) {
+            case SettingsActivity.SYSTEM_THEME_BEHAVIOR:
+                return SYSTEM;
+            case SettingsActivity.THEME_BEHAVIOR_DARK:
+                return DARK;
+            case SettingsActivity.THEME_BEHAVIOR_LIGHT:
+                return LIGHT;
+            default:
+                throw new IllegalArgumentException("Unknown theme button behavior: " + value);
+        }
+    }
+
     /**
      * @return the behavior to execute when power buttons are pressed while firing an alarm
      */
@@ -299,14 +334,17 @@ final class SettingsDAO {
         final String defaultValue = SettingsActivity.DEFAULT_POWER_BEHAVIOR;
         final String value = prefs.getString(SettingsActivity.KEY_POWER_BUTTONS, defaultValue);
         switch (value) {
-            case SettingsActivity.DEFAULT_POWER_BEHAVIOR: return NOTHING;
-            case SettingsActivity.POWER_BEHAVIOR_SNOOZE: return SNOOZE;
-            case SettingsActivity.POWER_BEHAVIOR_DISMISS: return DISMISS;
+            case SettingsActivity.DEFAULT_POWER_BEHAVIOR:
+                return NOTHING;
+            case SettingsActivity.POWER_BEHAVIOR_SNOOZE:
+                return SNOOZE;
+            case SettingsActivity.POWER_BEHAVIOR_DISMISS:
+                return DISMISS;
             default:
                 throw new IllegalArgumentException("Unknown power button behavior: " + value);
         }
     }
-    
+
     /**
      * @return the number of minutes an alarm may ring before it has timed out and becomes missed
      */
diff --git a/src/com/android/deskclock/data/SettingsModel.java b/app/src/main/java/com/best/deskclock/data/SettingsModel.java
similarity index 93%
rename from src/com/android/deskclock/data/SettingsModel.java
rename to app/src/main/java/com/best/deskclock/data/SettingsModel.java
index cc6444d47..d7563965e 100644
--- a/src/com/android/deskclock/data/SettingsModel.java
+++ b/app/src/main/java/com/best/deskclock/data/SettingsModel.java
@@ -25,6 +25,7 @@ import com.best.deskclock.Utils;
 import com.best.deskclock.data.DataModel.AlarmVolumeButtonBehavior;
 import com.best.deskclock.data.DataModel.CitySort;
 import com.best.deskclock.data.DataModel.ClockStyle;
+import com.best.deskclock.data.DataModel.ThemeButtonBehavior;
 
 import java.util.TimeZone;
 
@@ -37,10 +38,14 @@ final class SettingsModel {
 
     private final SharedPreferences mPrefs;
 
-    /** The model from which time data are fetched. */
+    /**
+     * The model from which time data are fetched.
+     */
     private final TimeModel mTimeModel;
 
-    /** The uri of the default ringtone to use for timers until the user explicitly chooses one. */
+    /**
+     * The uri of the default ringtone to use for timers until the user explicitly chooses one.
+     */
     private Uri mDefaultTimerRingtoneUri;
 
     SettingsModel(Context context, SharedPreferences prefs, TimeModel timeModel) {
@@ -113,22 +118,26 @@ final class SettingsModel {
         return mDefaultTimerRingtoneUri;
     }
 
-    void setTimerRingtoneUri(Uri uri) {
-        SettingsDAO.setTimerRingtoneUri(mPrefs, uri);
-    }
-
     Uri getTimerRingtoneUri() {
         return SettingsDAO.getTimerRingtoneUri(mPrefs, getDefaultTimerRingtoneUri());
     }
 
+    void setTimerRingtoneUri(Uri uri) {
+        SettingsDAO.setTimerRingtoneUri(mPrefs, uri);
+    }
+
     AlarmVolumeButtonBehavior getAlarmVolumeButtonBehavior() {
         return SettingsDAO.getAlarmVolumeButtonBehavior(mPrefs);
     }
 
+    ThemeButtonBehavior getThemeButtonBehavior() {
+        return SettingsDAO.getThemeButtonBehavior(mPrefs);
+    }
+
     AlarmVolumeButtonBehavior getAlarmPowerButtonBehavior() {
         return SettingsDAO.getAlarmPowerButtonBehavior(mPrefs);
     }
-    
+
     int getAlarmTimeout() {
         return SettingsDAO.getAlarmTimeout(mPrefs);
     }
diff --git a/src/com/android/deskclock/data/SilentSettingsModel.java b/app/src/main/java/com/best/deskclock/data/SilentSettingsModel.java
similarity index 93%
rename from src/com/android/deskclock/data/SilentSettingsModel.java
rename to app/src/main/java/com/best/deskclock/data/SilentSettingsModel.java
index 8d171aa4d..551d375f7 100644
--- a/src/com/android/deskclock/data/SilentSettingsModel.java
+++ b/app/src/main/java/com/best/deskclock/data/SilentSettingsModel.java
@@ -16,7 +16,15 @@
 
 package com.best.deskclock.data;
 
-import android.annotation.TargetApi;
+import static android.app.NotificationManager.ACTION_INTERRUPTION_FILTER_CHANGED;
+import static android.app.NotificationManager.INTERRUPTION_FILTER_NONE;
+import static android.content.Context.AUDIO_SERVICE;
+import static android.content.Context.NOTIFICATION_SERVICE;
+import static android.media.AudioManager.STREAM_ALARM;
+import static android.media.RingtoneManager.TYPE_ALARM;
+import static android.provider.Settings.System.CONTENT_URI;
+import static android.provider.Settings.System.DEFAULT_ALARM_ALERT_URI;
+
 import android.app.NotificationManager;
 import android.content.BroadcastReceiver;
 import android.content.ContentResolver;
@@ -28,8 +36,8 @@ import android.media.AudioManager;
 import android.media.RingtoneManager;
 import android.net.Uri;
 import android.os.AsyncTask;
-import android.os.Build;
 import android.os.Handler;
+
 import androidx.core.app.NotificationManagerCompat;
 
 import com.best.deskclock.Utils;
@@ -38,15 +46,6 @@ import com.best.deskclock.data.DataModel.SilentSetting;
 import java.util.ArrayList;
 import java.util.List;
 
-import static android.app.NotificationManager.ACTION_INTERRUPTION_FILTER_CHANGED;
-import static android.app.NotificationManager.INTERRUPTION_FILTER_NONE;
-import static android.content.Context.AUDIO_SERVICE;
-import static android.content.Context.NOTIFICATION_SERVICE;
-import static android.media.AudioManager.STREAM_ALARM;
-import static android.media.RingtoneManager.TYPE_ALARM;
-import static android.provider.Settings.System.CONTENT_URI;
-import static android.provider.Settings.System.DEFAULT_ALARM_ALERT_URI;
-
 /**
  * This model fetches and stores reasons that alarms may be suppressed or silenced by system
  * settings on the device. This information is displayed passively to notify the user of this
@@ -54,21 +53,31 @@ import static android.provider.Settings.System.DEFAULT_ALARM_ALERT_URI;
  */
 final class SilentSettingsModel {
 
-    /** The Uri to the settings entry that stores alarm stream volume. */
+    /**
+     * The Uri to the settings entry that stores alarm stream volume.
+     */
     private static final Uri VOLUME_URI = Uri.withAppendedPath(CONTENT_URI, "volume_alarm_speaker");
 
     private final Context mContext;
 
-    /** Used to query the alarm volume and display the system control to change the alarm volume. */
+    /**
+     * Used to query the alarm volume and display the system control to change the alarm volume.
+     */
     private final AudioManager mAudioManager;
 
-    /** Used to query the do-not-disturb setting value, also called "interruption filter". */
+    /**
+     * Used to query the do-not-disturb setting value, also called "interruption filter".
+     */
     private final NotificationManager mNotificationManager;
 
-    /** Used to determine if the application is in the foreground. */
+    /**
+     * Used to determine if the application is in the foreground.
+     */
     private final NotificationModel mNotificationModel;
 
-    /** List of listeners to invoke upon silence state change. */
+    /**
+     * List of listeners to invoke upon silence state change.
+     */
     private final List<OnSilentSettingsListener> mListeners = new ArrayList<>(1);
 
     /**
@@ -77,7 +86,9 @@ final class SilentSettingsModel {
      */
     private SilentSetting mSilentSetting;
 
-    /** The background task that checks the device system settings that influence alarm firing. */
+    /**
+     * The background task that checks the device system settings that influence alarm firing.
+     */
     private CheckSilenceSettingsTask mCheckSilenceSettingsTask;
 
     SilentSettingsModel(Context context, NotificationModel notificationModel) {
@@ -128,7 +139,7 @@ final class SilentSettingsModel {
 
     /**
      * @param silentSetting the latest notion of which setting is suppressing alarms; {@code null}
-     *      if no settings are suppressing alarms
+     *                      if no settings are suppressing alarms
      */
     private void setSilentState(SilentSetting silentSetting) {
         if (mSilentSetting != silentSetting) {
@@ -177,7 +188,6 @@ final class SilentSettingsModel {
             }
         }
 
-        @TargetApi(Build.VERSION_CODES.M)
         private boolean isDoNotDisturbBlockingAlarms() {
             if (!Utils.isMOrLater()) {
                 return false;
diff --git a/src/com/android/deskclock/data/Stopwatch.java b/app/src/main/java/com/best/deskclock/data/Stopwatch.java
similarity index 79%
rename from src/com/android/deskclock/data/Stopwatch.java
rename to app/src/main/java/com/best/deskclock/data/Stopwatch.java
index 19f135e6d..fd7327b18 100644
--- a/src/com/android/deskclock/data/Stopwatch.java
+++ b/app/src/main/java/com/best/deskclock/data/Stopwatch.java
@@ -27,23 +27,26 @@ import static com.best.deskclock.data.Stopwatch.State.RUNNING;
  */
 public final class Stopwatch {
 
-    public enum State { RESET, RUNNING, PAUSED }
-
     static final long UNUSED = Long.MIN_VALUE;
-
-    /** The single, immutable instance of a reset stopwatch. */
+    /**
+     * The single, immutable instance of a reset stopwatch.
+     */
     private static final Stopwatch RESET_STOPWATCH = new Stopwatch(RESET, UNUSED, UNUSED, 0);
-
-    /** Current state of this stopwatch. */
+    /**
+     * Current state of this stopwatch.
+     */
     private final State mState;
-
-    /** Elapsed time in ms the stopwatch was last started; {@link #UNUSED} if not running. */
+    /**
+     * Elapsed time in ms the stopwatch was last started; {@link #UNUSED} if not running.
+     */
     private final long mLastStartTime;
-
-    /** The time since epoch at which the stopwatch was last started. */
+    /**
+     * The time since epoch at which the stopwatch was last started.
+     */
     private final long mLastStartWallClockTime;
-
-    /** Elapsed time in ms this stopwatch has accumulated while running. */
+    /**
+     * Elapsed time in ms this stopwatch has accumulated while running.
+     */
     private final long mAccumulatedTime;
 
     Stopwatch(State state, long lastStartTime, long lastWallClockTime, long accumulatedTime) {
@@ -53,12 +56,29 @@ public final class Stopwatch {
         mAccumulatedTime = accumulatedTime;
     }
 
-    public State getState() { return mState; }
-    public long getLastStartTime() { return mLastStartTime; }
-    public long getLastWallClockTime() { return mLastStartWallClockTime; }
-    public boolean isReset() { return mState == RESET; }
-    public boolean isPaused() { return mState == PAUSED; }
-    public boolean isRunning() { return mState == RUNNING; }
+    public State getState() {
+        return mState;
+    }
+
+    public long getLastStartTime() {
+        return mLastStartTime;
+    }
+
+    public long getLastWallClockTime() {
+        return mLastStartWallClockTime;
+    }
+
+    public boolean isReset() {
+        return mState == RESET;
+    }
+
+    public boolean isPaused() {
+        return mState == PAUSED;
+    }
+
+    public boolean isRunning() {
+        return mState == RUNNING;
+    }
 
     /**
      * @return the total amount of time accumulated up to this moment
@@ -113,8 +133,8 @@ public final class Stopwatch {
 
     /**
      * @return this Stopwatch if it is not running or an updated version based on wallclock time.
-     *      The internals of the stopwatch are updated using the wallclock time which is durable
-     *      across reboots.
+     * The internals of the stopwatch are updated using the wallclock time which is durable
+     * across reboots.
      */
     Stopwatch updateAfterReboot() {
         if (mState != RUNNING) {
@@ -130,8 +150,8 @@ public final class Stopwatch {
 
     /**
      * @return this Stopwatch if it is not running or an updated version based on the realtime.
-     *      The internals of the stopwatch are updated using the realtime clock which is accurate
-     *      across wallclock time adjustments.
+     * The internals of the stopwatch are updated using the realtime clock which is accurate
+     * across wallclock time adjustments.
      */
     Stopwatch updateAfterTimeSet() {
         if (mState != RUNNING) {
@@ -148,4 +168,6 @@ public final class Stopwatch {
         }
         return new Stopwatch(mState, timeSinceBoot, wallClockTime, mAccumulatedTime + delta);
     }
+
+    public enum State {RESET, RUNNING, PAUSED}
 }
diff --git a/src/com/android/deskclock/data/StopwatchDAO.java b/app/src/main/java/com/best/deskclock/data/StopwatchDAO.java
similarity index 88%
rename from src/com/android/deskclock/data/StopwatchDAO.java
rename to app/src/main/java/com/best/deskclock/data/StopwatchDAO.java
index 61b7351d4..a55d43a88 100644
--- a/src/com/android/deskclock/data/StopwatchDAO.java
+++ b/app/src/main/java/com/best/deskclock/data/StopwatchDAO.java
@@ -16,6 +16,8 @@
 
 package com.best.deskclock.data;
 
+import static com.best.deskclock.data.Stopwatch.State.RESET;
+
 import android.content.SharedPreferences;
 
 import com.best.deskclock.data.Stopwatch.State;
@@ -24,33 +26,44 @@ import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
-import static com.best.deskclock.data.Stopwatch.State.RESET;
-
 /**
  * This class encapsulates the transfer of data between {@link Stopwatch} and {@link Lap} domain
  * objects and their permanent storage in {@link SharedPreferences}.
  */
 final class StopwatchDAO {
 
-    /** Key to a preference that stores the state of the stopwatch. */
+    /**
+     * Key to a preference that stores the state of the stopwatch.
+     */
     private static final String STATE = "sw_state";
 
-    /** Key to a preference that stores the last start time of the stopwatch. */
+    /**
+     * Key to a preference that stores the last start time of the stopwatch.
+     */
     private static final String LAST_START_TIME = "sw_start_time";
 
-    /** Key to a preference that stores the epoch time when the stopwatch last started. */
+    /**
+     * Key to a preference that stores the epoch time when the stopwatch last started.
+     */
     private static final String LAST_WALL_CLOCK_TIME = "sw_wall_clock_time";
 
-    /** Key to a preference that stores the accumulated elapsed time of the stopwatch. */
+    /**
+     * Key to a preference that stores the accumulated elapsed time of the stopwatch.
+     */
     private static final String ACCUMULATED_TIME = "sw_accum_time";
 
-    /** Prefix for a key to a preference that stores the number of recorded laps. */
+    /**
+     * Prefix for a key to a preference that stores the number of recorded laps.
+     */
     private static final String LAP_COUNT = "sw_lap_num";
 
-    /** Prefix for a key to a preference that stores accumulated time at the end of a lap. */
+    /**
+     * Prefix for a key to a preference that stores accumulated time at the end of a lap.
+     */
     private static final String LAP_ACCUMULATED_TIME = "sw_lap_time_";
 
-    private StopwatchDAO() {}
+    private StopwatchDAO() {
+    }
 
     /**
      * @return the stopwatch from permanent storage or a reset stopwatch if none exists
@@ -125,7 +138,7 @@ final class StopwatchDAO {
     }
 
     /**
-     * @param newLapCount the number of laps including the new lap
+     * @param newLapCount     the number of laps including the new lap
      * @param accumulatedTime the amount of time accumulate by the stopwatch at the end of the lap
      */
     static void addLap(SharedPreferences prefs, int newLapCount, long accumulatedTime) {
diff --git a/src/com/android/deskclock/data/StopwatchListener.java b/app/src/main/java/com/best/deskclock/data/StopwatchListener.java
similarity index 94%
rename from src/com/android/deskclock/data/StopwatchListener.java
rename to app/src/main/java/com/best/deskclock/data/StopwatchListener.java
index a79447edb..dae2c862e 100644
--- a/src/com/android/deskclock/data/StopwatchListener.java
+++ b/app/src/main/java/com/best/deskclock/data/StopwatchListener.java
@@ -23,7 +23,7 @@ public interface StopwatchListener {
 
     /**
      * @param before the stopwatch state before the update
-     * @param after the stopwatch state after the update
+     * @param after  the stopwatch state after the update
      */
     void stopwatchUpdated(Stopwatch before, Stopwatch after);
 
diff --git a/src/com/android/deskclock/data/StopwatchModel.java b/app/src/main/java/com/best/deskclock/data/StopwatchModel.java
similarity index 93%
rename from src/com/android/deskclock/data/StopwatchModel.java
rename to app/src/main/java/com/best/deskclock/data/StopwatchModel.java
index eb54d6614..4bd8d2820 100644
--- a/src/com/android/deskclock/data/StopwatchModel.java
+++ b/app/src/main/java/com/best/deskclock/data/StopwatchModel.java
@@ -17,17 +17,15 @@
 package com.best.deskclock.data;
 
 import android.app.Notification;
-import android.app.NotificationChannel;
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.SharedPreferences;
+
 import androidx.annotation.VisibleForTesting;
 import androidx.core.app.NotificationManagerCompat;
 
-import com.best.deskclock.R;
-
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -41,27 +39,41 @@ final class StopwatchModel {
 
     private final SharedPreferences mPrefs;
 
-    /** The model from which notification data are fetched. */
+    /**
+     * The model from which notification data are fetched.
+     */
     private final NotificationModel mNotificationModel;
 
-    /** Used to create and destroy system notifications related to the stopwatch. */
+    /**
+     * Used to create and destroy system notifications related to the stopwatch.
+     */
     private final NotificationManagerCompat mNotificationManager;
 
-    /** Update stopwatch notification when locale changes. */
+    /**
+     * Update stopwatch notification when locale changes.
+     */
     @SuppressWarnings("FieldCanBeLocal")
     private final BroadcastReceiver mLocaleChangedReceiver = new LocaleChangedReceiver();
 
-    /** The listeners to notify when the stopwatch or its laps change. */
+    /**
+     * The listeners to notify when the stopwatch or its laps change.
+     */
     private final List<StopwatchListener> mStopwatchListeners = new ArrayList<>();
 
-    /** Delegate that builds platform-specific stopwatch notifications. */
+    /**
+     * Delegate that builds platform-specific stopwatch notifications.
+     */
     private final StopwatchNotificationBuilder mNotificationBuilder =
             new StopwatchNotificationBuilder();
 
-    /** The current state of the stopwatch. */
+    /**
+     * The current state of the stopwatch.
+     */
     private Stopwatch mStopwatch;
 
-    /** A mutable copy of the recorded stopwatch laps. */
+    /**
+     * A mutable copy of the recorded stopwatch laps.
+     */
     private List<Lap> mLaps;
 
     StopwatchModel(Context context, SharedPreferences prefs, NotificationModel notificationModel) {
@@ -212,7 +224,7 @@ final class StopwatchModel {
      *
      * @param time a point in time expected, but not required, to be after the end of the prior lap
      * @return the elapsed time between the given {@code time} and the end of the prior lap;
-     *      negative elapsed times are normalized to {@code 0}
+     * negative elapsed times are normalized to {@code 0}
      */
     long getCurrentLapTime(long time) {
         final Lap previousLap = getLaps().get(0);
diff --git a/src/com/android/deskclock/data/StopwatchNotificationBuilder.java b/app/src/main/java/com/best/deskclock/data/StopwatchNotificationBuilder.java
similarity index 90%
rename from src/com/android/deskclock/data/StopwatchNotificationBuilder.java
rename to app/src/main/java/com/best/deskclock/data/StopwatchNotificationBuilder.java
index 4272e89eb..00a7837bb 100644
--- a/src/com/android/deskclock/data/StopwatchNotificationBuilder.java
+++ b/app/src/main/java/com/best/deskclock/data/StopwatchNotificationBuilder.java
@@ -16,23 +16,23 @@
 
 package com.best.deskclock.data;
 
+import static android.view.View.GONE;
+import static android.view.View.VISIBLE;
 import static com.best.deskclock.NotificationUtils.STOPWATCH_NOTIFICATION_CHANNEL_ID;
 
 import android.app.Notification;
-import android.app.NotificationChannel;
 import android.app.PendingIntent;
 import android.content.Context;
 import android.content.Intent;
 import android.content.res.Resources;
 import android.os.SystemClock;
+import android.widget.RemoteViews;
+
 import androidx.annotation.DrawableRes;
 import androidx.annotation.StringRes;
 import androidx.core.app.NotificationCompat;
 import androidx.core.app.NotificationCompat.Action;
 import androidx.core.app.NotificationCompat.Builder;
-import androidx.core.app.NotificationManagerCompat;
-import androidx.core.content.ContextCompat;
-import android.widget.RemoteViews;
 
 import com.best.deskclock.NotificationUtils;
 import com.best.deskclock.R;
@@ -43,9 +43,6 @@ import com.best.deskclock.stopwatch.StopwatchService;
 import java.util.ArrayList;
 import java.util.List;
 
-import static android.view.View.GONE;
-import static android.view.View.VISIBLE;
-
 /**
  * Builds notification to reflect the latest state of the stopwatch and recorded laps.
  */
@@ -134,15 +131,15 @@ class StopwatchNotificationBuilder {
 
         final Builder notification = new NotificationCompat.Builder(
                 context, STOPWATCH_NOTIFICATION_CHANNEL_ID)
-                        .setLocalOnly(true)
-                        .setOngoing(running)
-                        .setCustomContentView(content)
-                        .setContentIntent(pendingShowApp)
-                        .setAutoCancel(stopwatch.isPaused())
-                        .setPriority(Notification.PRIORITY_LOW)
-                        .setSmallIcon(R.drawable.stat_notify_stopwatch)
-                        .setStyle(new NotificationCompat.DecoratedCustomViewStyle())
-                        .setColor(ContextCompat.getColor(context, R.color.default_background));
+                .setLocalOnly(true)
+                .setOngoing(running)
+                .setCustomContentView(content)
+                .setContentIntent(pendingShowApp)
+                .setAutoCancel(stopwatch.isPaused())
+                .setPriority(Notification.PRIORITY_LOW)
+                .setSmallIcon(R.drawable.stat_notify_stopwatch)
+                .setStyle(new NotificationCompat.DecoratedCustomViewStyle())
+                .setColor(android.R.attr.colorAccent);
 
         if (Utils.isNOrLater()) {
             notification.setGroup(nm.getStopwatchNotificationGroupKey());
diff --git a/gen/com/android/deskclock/BuildConfig.java b/app/src/main/java/com/best/deskclock/data/ThemeModel.java
similarity index 54%
rename from gen/com/android/deskclock/BuildConfig.java
rename to app/src/main/java/com/best/deskclock/data/ThemeModel.java
index 68f01514f..4108982d1 100644
--- a/gen/com/android/deskclock/BuildConfig.java
+++ b/app/src/main/java/com/best/deskclock/data/ThemeModel.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 The Android Open Source Project
+ * Copyright (C) 2015 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,9 +14,21 @@
  * limitations under the License.
  */
 
-package com.best.deskclock;
+package com.best.deskclock.data;
 
-public final class BuildConfig {
-    public static final boolean DEBUG = false;
-    public static final String APPLICATION_ID = "com.best.deskclock";
+import android.content.Context;
+
+import com.best.deskclock.data.DataModel.ThemeButtonBehavior;
+
+final class ThemeModel {
+
+    private final SettingsModel mSettingsModel;
+
+    ThemeModel(Context mContext, SettingsModel settingsModel) {
+        mSettingsModel = settingsModel;
+    }
+
+    ThemeButtonBehavior getThemeButtonBehavior() {
+        return mSettingsModel.getThemeButtonBehavior();
+    }
 }
diff --git a/src/com/android/deskclock/data/TimeModel.java b/app/src/main/java/com/best/deskclock/data/TimeModel.java
similarity index 100%
rename from src/com/android/deskclock/data/TimeModel.java
rename to app/src/main/java/com/best/deskclock/data/TimeModel.java
diff --git a/src/com/android/deskclock/data/TimeZones.java b/app/src/main/java/com/best/deskclock/data/TimeZones.java
similarity index 100%
rename from src/com/android/deskclock/data/TimeZones.java
rename to app/src/main/java/com/best/deskclock/data/TimeZones.java
diff --git a/src/com/android/deskclock/data/Timer.java b/app/src/main/java/com/best/deskclock/data/Timer.java
similarity index 85%
rename from src/com/android/deskclock/data/Timer.java
rename to app/src/main/java/com/best/deskclock/data/Timer.java
index 2012369d0..eeed32cbf 100644
--- a/src/com/android/deskclock/data/Timer.java
+++ b/app/src/main/java/com/best/deskclock/data/Timer.java
@@ -16,12 +16,6 @@
 
 package com.best.deskclock.data;
 
-import android.text.TextUtils;
-
-import java.util.Arrays;
-import java.util.Comparator;
-import java.util.List;
-
 import static android.text.format.DateUtils.HOUR_IN_MILLIS;
 import static android.text.format.DateUtils.MINUTE_IN_MILLIS;
 import static android.text.format.DateUtils.SECOND_IN_MILLIS;
@@ -33,76 +27,105 @@ import static com.best.deskclock.data.Timer.State.PAUSED;
 import static com.best.deskclock.data.Timer.State.RESET;
 import static com.best.deskclock.data.Timer.State.RUNNING;
 
+import android.text.TextUtils;
+
+import java.util.Arrays;
+import java.util.Comparator;
+import java.util.List;
+
 /**
  * A read-only domain object representing a countdown timer.
  */
 public final class Timer {
 
-    public enum State {
-        RUNNING(1), PAUSED(2), EXPIRED(3), RESET(4), MISSED(5);
-
-        /** The value assigned to this State in prior releases. */
-        private final int mValue;
-
-        State(int value) {
-            mValue = value;
+    /**
+     * The minimum duration of a timer.
+     */
+    public static final long MIN_LENGTH = SECOND_IN_MILLIS;
+    /**
+     * The maximum duration of a new timer created via the user interface.
+     */
+    static final long MAX_LENGTH =
+            99 * HOUR_IN_MILLIS + 99 * MINUTE_IN_MILLIS + 99 * SECOND_IN_MILLIS;
+    static final long UNUSED = Long.MIN_VALUE;
+    /**
+     * Orders timers by their IDs. Oldest timers are at the bottom. Newest timers are at the top.
+     */
+    static final Comparator<Timer> ID_COMPARATOR = new Comparator<Timer>() {
+        @Override
+        public int compare(Timer timer1, Timer timer2) {
+            return Integer.compare(timer2.getId(), timer1.getId());
         }
+    };
+    /**
+     * Orders timers by their expected/actual expiration time. The general order is:
+     *
+     * <ol>
+     *     <li>{@link State#MISSED MISSED} timers; ties broken by {@link #getRemainingTime()}</li>
+     *     <li>{@link State#EXPIRED EXPIRED} timers; ties broken by {@link #getRemainingTime()}</li>
+     *     <li>{@link State#RUNNING RUNNING} timers; ties broken by {@link #getRemainingTime()}</li>
+     *     <li>{@link State#PAUSED PAUSED} timers; ties broken by {@link #getRemainingTime()}</li>
+     *     <li>{@link State#RESET RESET} timers; ties broken by {@link #getLength()}</li>
+     * </ol>
+     */
+    static final Comparator<Timer> EXPIRY_COMPARATOR = new Comparator<Timer>() {
 
-        /**
-         * @return the numeric value assigned to this state
-         */
-        public int getValue() {
-            return mValue;
-        }
+        private final List<State> stateExpiryOrder = Arrays.asList(MISSED, EXPIRED, RUNNING, PAUSED,
+                RESET);
 
-        /**
-         * @return the state corresponding to the given {@code value}
-         */
-        public static State fromValue(int value) {
-            for (State state : values()) {
-                if (state.getValue() == value) {
-                    return state;
+        @Override
+        public int compare(Timer timer1, Timer timer2) {
+            final int stateIndex1 = stateExpiryOrder.indexOf(timer1.getState());
+            final int stateIndex2 = stateExpiryOrder.indexOf(timer2.getState());
+
+            int order = Integer.compare(stateIndex1, stateIndex2);
+            if (order == 0) {
+                final State state = timer1.getState();
+                if (state == RESET) {
+                    order = Long.compare(timer1.getLength(), timer2.getLength());
+                } else {
+                    order = Long.compare(timer1.getRemainingTime(), timer2.getRemainingTime());
                 }
             }
 
-            return null;
+            return order;
         }
-    }
-
-    /** The minimum duration of a timer. */
-    public static final long MIN_LENGTH = SECOND_IN_MILLIS;
-
-    /** The maximum duration of a new timer created via the user interface. */
-    static final long MAX_LENGTH =
-            99 * HOUR_IN_MILLIS + 99 * MINUTE_IN_MILLIS + 99 * SECOND_IN_MILLIS;
-
-    static final long UNUSED = Long.MIN_VALUE;
-
-    /** A unique identifier for the timer. */
+    };
+    /**
+     * A unique identifier for the timer.
+     */
     private final int mId;
-
-    /** The current state of the timer. */
+    /**
+     * The current state of the timer.
+     */
     private final State mState;
-
-    /** The original length of the timer in milliseconds when it was created. */
+    /**
+     * The original length of the timer in milliseconds when it was created.
+     */
     private final long mLength;
-
-    /** The length of the timer in milliseconds including additional time added by the user. */
+    /**
+     * The length of the timer in milliseconds including additional time added by the user.
+     */
     private final long mTotalLength;
-
-    /** The time at which the timer was last started; {@link #UNUSED} when not running. */
+    /**
+     * The time at which the timer was last started; {@link #UNUSED} when not running.
+     */
     private final long mLastStartTime;
-
-    /** The time since epoch at which the timer was last started. */
+    /**
+     * The time since epoch at which the timer was last started.
+     */
     private final long mLastStartWallClockTime;
-
-    /** The time at which the timer is scheduled to expire; negative if it is already expired. */
+    /**
+     * The time at which the timer is scheduled to expire; negative if it is already expired.
+     */
     private final long mRemainingTime;
-
-    /** A message describing the meaning of the timer. */
+    /**
+     * A message describing the meaning of the timer.
+     */
     private final String mLabel;
-
-    /** A flag indicating the timer should be deleted when it is reset. */
+    /**
+     * A flag indicating the timer should be deleted when it is reset.
+     */
     private final boolean mDeleteAfterUse;
 
     Timer(int id, State state, long length, long totalLength, long lastStartTime,
@@ -118,17 +141,84 @@ public final class Timer {
         mDeleteAfterUse = deleteAfterUse;
     }
 
-    public int getId() { return mId; }
-    public State getState() { return mState; }
-    public String getLabel() { return mLabel; }
-    public long getLength() { return mLength; }
-    public long getTotalLength() { return mTotalLength; }
-    public boolean getDeleteAfterUse() { return mDeleteAfterUse; }
-    public boolean isReset() { return mState == RESET; }
-    public boolean isRunning() { return mState == RUNNING; }
-    public boolean isPaused() { return mState == PAUSED; }
-    public boolean isExpired() { return mState == EXPIRED; }
-    public boolean isMissed() { return mState == MISSED; }
+    public int getId() {
+        return mId;
+    }
+
+    public State getState() {
+        return mState;
+    }
+
+    public String getLabel() {
+        return mLabel;
+    }
+
+    /**
+     * @return a copy of this timer with the given {@code label}
+     */
+    Timer setLabel(String label) {
+        if (TextUtils.equals(mLabel, label)) {
+            return this;
+        }
+
+        return new Timer(mId, mState, mLength, mTotalLength, mLastStartTime,
+                mLastStartWallClockTime, mRemainingTime, label, mDeleteAfterUse);
+    }
+
+    public long getLength() {
+        return mLength;
+    }
+
+    /**
+     * @return a copy of this timer with the given {@code length} or this timer if the length could
+     * not be legally adjusted
+     */
+    Timer setLength(long length) {
+        if (mLength == length || length <= Timer.MIN_LENGTH) {
+            return this;
+        }
+
+        final long totalLength;
+        final long remainingTime;
+        if (mState == RESET) {
+            totalLength = length;
+            remainingTime = length;
+        } else {
+            totalLength = mTotalLength;
+            remainingTime = mRemainingTime;
+        }
+
+        return new Timer(mId, mState, length, totalLength, mLastStartTime,
+                mLastStartWallClockTime, remainingTime, mLabel, mDeleteAfterUse);
+    }
+
+    public long getTotalLength() {
+        return mTotalLength;
+    }
+
+    public boolean getDeleteAfterUse() {
+        return mDeleteAfterUse;
+    }
+
+    public boolean isReset() {
+        return mState == RESET;
+    }
+
+    public boolean isRunning() {
+        return mState == RUNNING;
+    }
+
+    public boolean isPaused() {
+        return mState == PAUSED;
+    }
+
+    public boolean isExpired() {
+        return mState == EXPIRED;
+    }
+
+    public boolean isMissed() {
+        return mState == MISSED;
+    }
 
     /**
      * @return the amount of remaining time when the timer was last started or paused.
@@ -139,7 +229,7 @@ public final class Timer {
 
     /**
      * @return the total amount of time remaining up to this moment; expired and missed timers will
-     *      return a negative amount
+     * return a negative amount
      */
     public long getRemainingTime() {
         if (mState == PAUSED || mState == RESET) {
@@ -153,6 +243,36 @@ public final class Timer {
         return mRemainingTime - Math.max(0, timeSinceStart);
     }
 
+    /**
+     * @return a copy of this timer with the given {@code remainingTime} or this timer if the
+     * remaining time could not be legally adjusted
+     */
+    Timer setRemainingTime(long remainingTime) {
+        // Do not change the remaining time of a reset timer.
+        if (mRemainingTime == remainingTime || mState == RESET) {
+            return this;
+        }
+
+        final long delta = remainingTime - mRemainingTime;
+        final long totalLength = mTotalLength + delta;
+
+        final long lastStartTime;
+        final long lastWallClockTime;
+        final State state;
+        if (remainingTime > 0 && (mState == EXPIRED || mState == MISSED)) {
+            state = RUNNING;
+            lastStartTime = now();
+            lastWallClockTime = wallClock();
+        } else {
+            state = mState;
+            lastStartTime = mLastStartTime;
+            lastWallClockTime = mLastStartWallClockTime;
+        }
+
+        return new Timer(mId, state, mLength, totalLength, lastStartTime,
+                lastWallClockTime, remainingTime, mLabel, mDeleteAfterUse);
+    }
+
     /**
      * @return the elapsed realtime at which this timer will or did expire
      */
@@ -176,16 +296,20 @@ public final class Timer {
     }
 
     /**
-     *
      * @return the total amount of time elapsed up to this moment; expired timers will report more
-     *      than the {@link #getTotalLength() total length}
+     * than the {@link #getTotalLength() total length}
      */
     public long getElapsedTime() {
         return getTotalLength() - getRemainingTime();
     }
 
-    long getLastStartTime() { return mLastStartTime; }
-    long getLastWallClockTime() { return mLastStartWallClockTime; }
+    long getLastStartTime() {
+        return mLastStartTime;
+    }
+
+    long getLastWallClockTime() {
+        return mLastStartWallClockTime;
+    }
 
     /**
      * @return a copy of this timer that is running, expired or missed
@@ -292,74 +416,9 @@ public final class Timer {
                 remainingTime, mLabel, mDeleteAfterUse);
     }
 
-    /**
-     * @return a copy of this timer with the given {@code label}
-     */
-    Timer setLabel(String label) {
-        if (TextUtils.equals(mLabel, label)) {
-            return this;
-        }
-
-        return new Timer(mId, mState, mLength, mTotalLength, mLastStartTime,
-                mLastStartWallClockTime, mRemainingTime, label, mDeleteAfterUse);
-    }
-
-    /**
-     * @return a copy of this timer with the given {@code length} or this timer if the length could
-     *      not be legally adjusted
-     */
-    Timer setLength(long length) {
-        if (mLength == length || length <= Timer.MIN_LENGTH) {
-            return this;
-        }
-
-        final long totalLength;
-        final long remainingTime;
-        if (mState == RESET) {
-            totalLength = length;
-            remainingTime = length;
-        } else {
-            totalLength = mTotalLength;
-            remainingTime = mRemainingTime;
-        }
-
-        return new Timer(mId, mState, length, totalLength, mLastStartTime,
-                mLastStartWallClockTime, remainingTime, mLabel, mDeleteAfterUse);
-    }
-
-    /**
-     * @return a copy of this timer with the given {@code remainingTime} or this timer if the
-     *      remaining time could not be legally adjusted
-     */
-    Timer setRemainingTime(long remainingTime) {
-        // Do not change the remaining time of a reset timer.
-        if (mRemainingTime == remainingTime || mState == RESET) {
-            return this;
-        }
-
-        final long delta = remainingTime - mRemainingTime;
-        final long totalLength = mTotalLength + delta;
-
-        final long lastStartTime;
-        final long lastWallClockTime;
-        final State state;
-        if (remainingTime > 0 && (mState == EXPIRED || mState == MISSED)) {
-            state = RUNNING;
-            lastStartTime = now();
-            lastWallClockTime = wallClock();
-        } else {
-            state = mState;
-            lastStartTime = mLastStartTime;
-            lastWallClockTime = mLastStartWallClockTime;
-        }
-
-        return new Timer(mId, state, mLength, totalLength, lastStartTime,
-                lastWallClockTime, remainingTime, mLabel, mDeleteAfterUse);
-    }
-
     /**
      * @return a copy of this timer with an additional minute added to the remaining time and total
-     *      length, or this Timer if the minute could not be added
+     * length, or this Timer if the minute could not be added
      */
     Timer addMinute() {
         // Expired and missed timers restart with 60 seconds of remaining time.
@@ -386,48 +445,36 @@ public final class Timer {
         return mId;
     }
 
-    /**
-     * Orders timers by their IDs. Oldest timers are at the bottom. Newest timers are at the top.
-     */
-    static Comparator<Timer> ID_COMPARATOR = new Comparator<Timer>() {
-        @Override
-        public int compare(Timer timer1, Timer timer2) {
-            return Integer.compare(timer2.getId(), timer1.getId());
-        }
-    };
-
-    /**
-     * Orders timers by their expected/actual expiration time. The general order is:
-     *
-     * <ol>
-     *     <li>{@link State#MISSED MISSED} timers; ties broken by {@link #getRemainingTime()}</li>
-     *     <li>{@link State#EXPIRED EXPIRED} timers; ties broken by {@link #getRemainingTime()}</li>
-     *     <li>{@link State#RUNNING RUNNING} timers; ties broken by {@link #getRemainingTime()}</li>
-     *     <li>{@link State#PAUSED PAUSED} timers; ties broken by {@link #getRemainingTime()}</li>
-     *     <li>{@link State#RESET RESET} timers; ties broken by {@link #getLength()}</li>
-     * </ol>
-     */
-    static Comparator<Timer> EXPIRY_COMPARATOR = new Comparator<Timer>() {
+    public enum State {
+        RUNNING(1), PAUSED(2), EXPIRED(3), RESET(4), MISSED(5);
 
-        private final List<State> stateExpiryOrder = Arrays.asList(MISSED, EXPIRED, RUNNING, PAUSED,
-                RESET);
+        /**
+         * The value assigned to this State in prior releases.
+         */
+        private final int mValue;
 
-        @Override
-        public int compare(Timer timer1, Timer timer2) {
-            final int stateIndex1 = stateExpiryOrder.indexOf(timer1.getState());
-            final int stateIndex2 = stateExpiryOrder.indexOf(timer2.getState());
+        State(int value) {
+            mValue = value;
+        }
 
-            int order = Integer.compare(stateIndex1, stateIndex2);
-            if (order == 0) {
-                final State state = timer1.getState();
-                if (state == RESET) {
-                    order = Long.compare(timer1.getLength(), timer2.getLength());
-                } else {
-                    order = Long.compare(timer1.getRemainingTime(), timer2.getRemainingTime());
+        /**
+         * @return the state corresponding to the given {@code value}
+         */
+        public static State fromValue(int value) {
+            for (State state : values()) {
+                if (state.getValue() == value) {
+                    return state;
                 }
             }
 
-            return order;
+            return null;
         }
-    };
+
+        /**
+         * @return the numeric value assigned to this state
+         */
+        public int getValue() {
+            return mValue;
+        }
+    }
 }
diff --git a/src/com/android/deskclock/data/TimerDAO.java b/app/src/main/java/com/best/deskclock/data/TimerDAO.java
similarity index 85%
rename from src/com/android/deskclock/data/TimerDAO.java
rename to app/src/main/java/com/best/deskclock/data/TimerDAO.java
index fbd26eec7..116676669 100644
--- a/src/com/android/deskclock/data/TimerDAO.java
+++ b/app/src/main/java/com/best/deskclock/data/TimerDAO.java
@@ -16,6 +16,8 @@
 
 package com.best.deskclock.data;
 
+import static com.best.deskclock.data.Timer.State.RESET;
+
 import android.content.SharedPreferences;
 
 import com.best.deskclock.data.Timer.State;
@@ -26,52 +28,71 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
-import static com.best.deskclock.data.Timer.State.RESET;
-
 /**
  * This class encapsulates the transfer of data between {@link Timer} domain objects and their
  * permanent storage in {@link SharedPreferences}.
  */
 final class TimerDAO {
 
-    /** Key to a preference that stores the set of timer ids. */
+    /**
+     * Key to a preference that stores the set of timer ids.
+     */
     private static final String TIMER_IDS = "timers_list";
 
-    /** Key to a preference that stores the id to assign to the next timer. */
+    /**
+     * Key to a preference that stores the id to assign to the next timer.
+     */
     private static final String NEXT_TIMER_ID = "next_timer_id";
 
-    /** Prefix for a key to a preference that stores the state of the timer. */
+    /**
+     * Prefix for a key to a preference that stores the state of the timer.
+     */
     private static final String STATE = "timer_state_";
 
-    /** Prefix for a key to a preference that stores the original timer length at creation. */
+    /**
+     * Prefix for a key to a preference that stores the original timer length at creation.
+     */
     private static final String LENGTH = "timer_setup_timet_";
 
-    /** Prefix for a key to a preference that stores the total timer length with additions. */
+    /**
+     * Prefix for a key to a preference that stores the total timer length with additions.
+     */
     private static final String TOTAL_LENGTH = "timer_original_timet_";
 
-    /** Prefix for a key to a preference that stores the last start time of the timer. */
+    /**
+     * Prefix for a key to a preference that stores the last start time of the timer.
+     */
     private static final String LAST_START_TIME = "timer_start_time_";
 
-    /** Prefix for a key to a preference that stores the epoch time when the timer last started. */
+    /**
+     * Prefix for a key to a preference that stores the epoch time when the timer last started.
+     */
     private static final String LAST_WALL_CLOCK_TIME = "timer_wall_clock_time_";
 
-    /** Prefix for a key to a preference that stores the remaining time before expiry. */
+    /**
+     * Prefix for a key to a preference that stores the remaining time before expiry.
+     */
     private static final String REMAINING_TIME = "timer_time_left_";
 
-    /** Prefix for a key to a preference that stores the label of the timer. */
+    /**
+     * Prefix for a key to a preference that stores the label of the timer.
+     */
     private static final String LABEL = "timer_label_";
 
-    /** Prefix for a key to a preference that signals the timer should be deleted on first reset. */
+    /**
+     * Prefix for a key to a preference that signals the timer should be deleted on first reset.
+     */
     private static final String DELETE_AFTER_USE = "delete_after_use_";
 
-    private TimerDAO() {}
+    private TimerDAO() {
+    }
 
     /**
      * @return the timers from permanent storage
      */
     static List<Timer> getTimers(SharedPreferences prefs) {
         // Read the set of timer ids.
-        final Set<String> timerIds = prefs.getStringSet(TIMER_IDS, Collections.<String>emptySet());
+        final Set<String> timerIds = prefs.getStringSet(TIMER_IDS, Collections.emptySet());
         final List<Timer> timers = new ArrayList<>(timerIds.size());
 
         // Build a timer using the data associated with each timer id.
@@ -184,6 +205,6 @@ final class TimerDAO {
     }
 
     private static Set<String> getTimerIds(SharedPreferences prefs) {
-        return prefs.getStringSet(TIMER_IDS, Collections.<String>emptySet());
+        return prefs.getStringSet(TIMER_IDS, Collections.emptySet());
     }
 }
diff --git a/src/com/android/deskclock/data/TimerListener.java b/app/src/main/java/com/best/deskclock/data/TimerListener.java
similarity index 95%
rename from src/com/android/deskclock/data/TimerListener.java
rename to app/src/main/java/com/best/deskclock/data/TimerListener.java
index 8a921bc5b..cac66b901 100644
--- a/src/com/android/deskclock/data/TimerListener.java
+++ b/app/src/main/java/com/best/deskclock/data/TimerListener.java
@@ -28,7 +28,7 @@ public interface TimerListener {
 
     /**
      * @param before the timer state before the update
-     * @param after the timer state after the update
+     * @param after  the timer state after the update
      */
     void timerUpdated(Timer before, Timer after);
 
diff --git a/src/com/android/deskclock/data/TimerModel.java b/app/src/main/java/com/best/deskclock/data/TimerModel.java
similarity index 94%
rename from src/com/android/deskclock/data/TimerModel.java
rename to app/src/main/java/com/best/deskclock/data/TimerModel.java
index bdbe85306..06790e130 100644
--- a/src/com/android/deskclock/data/TimerModel.java
+++ b/app/src/main/java/com/best/deskclock/data/TimerModel.java
@@ -16,10 +16,14 @@
 
 package com.best.deskclock.data;
 
+import static android.app.AlarmManager.ELAPSED_REALTIME_WAKEUP;
+import static android.text.format.DateUtils.MINUTE_IN_MILLIS;
+import static com.best.deskclock.data.Timer.State.EXPIRED;
+import static com.best.deskclock.data.Timer.State.RESET;
+
 import android.annotation.SuppressLint;
 import android.app.AlarmManager;
 import android.app.Notification;
-import android.app.NotificationChannel;
 import android.app.PendingIntent;
 import android.app.Service;
 import android.content.BroadcastReceiver;
@@ -29,9 +33,10 @@ import android.content.IntentFilter;
 import android.content.SharedPreferences;
 import android.content.SharedPreferences.OnSharedPreferenceChangeListener;
 import android.net.Uri;
+import android.util.ArraySet;
+
 import androidx.annotation.StringRes;
 import androidx.core.app.NotificationManagerCompat;
-import android.util.ArraySet;
 
 import com.best.deskclock.AlarmAlertWakeLock;
 import com.best.deskclock.LogUtils;
@@ -47,11 +52,6 @@ import java.util.Collections;
 import java.util.List;
 import java.util.Set;
 
-import static android.app.AlarmManager.ELAPSED_REALTIME_WAKEUP;
-import static android.text.format.DateUtils.MINUTE_IN_MILLIS;
-import static com.best.deskclock.data.Timer.State.EXPIRED;
-import static com.best.deskclock.data.Timer.State.RESET;
-
 /**
  * All {@link Timer} data is accessed via this model.
  */
@@ -67,22 +67,34 @@ final class TimerModel {
 
     private final SharedPreferences mPrefs;
 
-    /** The alarm manager system service that calls back when timers expire. */
+    /**
+     * The alarm manager system service that calls back when timers expire.
+     */
     private final AlarmManager mAlarmManager;
 
-    /** The model from which settings are fetched. */
+    /**
+     * The model from which settings are fetched.
+     */
     private final SettingsModel mSettingsModel;
 
-    /** The model from which notification data are fetched. */
+    /**
+     * The model from which notification data are fetched.
+     */
     private final NotificationModel mNotificationModel;
 
-    /** The model from which ringtone data are fetched. */
+    /**
+     * The model from which ringtone data are fetched.
+     */
     private final RingtoneModel mRingtoneModel;
 
-    /** Used to create and destroy system notifications related to timers. */
+    /**
+     * Used to create and destroy system notifications related to timers.
+     */
     private final NotificationManagerCompat mNotificationManager;
 
-    /** Update timer notification when locale changes. */
+    /**
+     * Update timer notification when locale changes.
+     */
     @SuppressWarnings("FieldCanBeLocal")
     private final BroadcastReceiver mLocaleChangedReceiver = new LocaleChangedReceiver();
 
@@ -93,10 +105,14 @@ final class TimerModel {
     @SuppressWarnings("FieldCanBeLocal")
     private final OnSharedPreferenceChangeListener mPreferenceListener = new PreferenceListener();
 
-    /** The listeners to notify when a timer is added, updated or removed. */
+    /**
+     * The listeners to notify when a timer is added, updated or removed.
+     */
     private final List<TimerListener> mTimerListeners = new ArrayList<>();
 
-    /** Delegate that builds platform-specific timer notifications. */
+    /**
+     * Delegate that builds platform-specific timer notifications.
+     */
     private final TimerNotificationBuilder mNotificationBuilder = new TimerNotificationBuilder();
 
     /**
@@ -107,19 +123,29 @@ final class TimerModel {
     @SuppressLint("NewApi")
     private final Set<Integer> mRingingIds = new ArraySet<>();
 
-    /** The uri of the ringtone to play for timers. */
+    /**
+     * The uri of the ringtone to play for timers.
+     */
     private Uri mTimerRingtoneUri;
 
-    /** The title of the ringtone to play for timers. */
+    /**
+     * The title of the ringtone to play for timers.
+     */
     private String mTimerRingtoneTitle;
 
-    /** A mutable copy of the timers. */
+    /**
+     * A mutable copy of the timers.
+     */
     private List<Timer> mTimers;
 
-    /** A mutable copy of the expired timers. */
+    /**
+     * A mutable copy of the expired timers.
+     */
     private List<Timer> mExpiredTimers;
 
-    /** A mutable copy of the missed timers. */
+    /**
+     * A mutable copy of the missed timers.
+     */
     private List<Timer> mMissedTimers;
 
     /**
@@ -130,7 +156,7 @@ final class TimerModel {
     private Service mService;
 
     TimerModel(Context context, SharedPreferences prefs, SettingsModel settingsModel,
-            RingtoneModel ringtoneModel, NotificationModel notificationModel) {
+               RingtoneModel ringtoneModel, NotificationModel notificationModel) {
         mContext = context;
         mPrefs = prefs;
         mSettingsModel = settingsModel;
@@ -148,6 +174,15 @@ final class TimerModel {
         mContext.registerReceiver(mLocaleChangedReceiver, localeBroadcastFilter);
     }
 
+    static void schedulePendingIntent(AlarmManager am, long triggerTime, PendingIntent pi) {
+        if (Utils.isMOrLater()) {
+            // Ensure the timer fires even if the device is dozing.
+            am.setExactAndAllowWhileIdle(ELAPSED_REALTIME_WAKEUP, triggerTime, pi);
+        } else {
+            am.setExact(ELAPSED_REALTIME_WAKEUP, triggerTime, pi);
+        }
+    }
+
     /**
      * @param timerListener to be notified when timers are added, updated and removed
      */
@@ -199,7 +234,7 @@ final class TimerModel {
 
     /**
      * @return the timer that last expired and is still expired now; {@code null} if no timers are
-     *      expired
+     * expired
      */
     Timer getMostRecentExpiredTimer() {
         final List<Timer> timers = getMutableExpiredTimers();
@@ -207,8 +242,8 @@ final class TimerModel {
     }
 
     /**
-     * @param length the length of the timer in milliseconds
-     * @param label describes the purpose of the timer
+     * @param length         the length of the timer in milliseconds
+     * @param label          describes the purpose of the timer
      * @param deleteAfterUse {@code true} indicates the timer should be deleted when it is reset
      * @return the newly added timer
      */
@@ -237,7 +272,7 @@ final class TimerModel {
 
     /**
      * @param service used to start foreground notifications related to expired timers
-     * @param timer the timer to be expired
+     * @param timer   the timer to be expired
      */
     void expireTimer(Service service, Timer timer) {
         if (mService == null) {
@@ -451,7 +486,7 @@ final class TimerModel {
 
     /**
      * @return the duration, in milliseconds, of the crescendo to apply to timer ringtone playback;
-     *      {@code 0} implies no crescendo should be applied
+     * {@code 0} implies no crescendo should be applied
      */
     long getTimerCrescendoDuration() {
         return mSettingsModel.getTimerCrescendoDuration();
@@ -603,19 +638,19 @@ final class TimerModel {
     /**
      * This method updates/removes timer data without updating notifications. This is useful in
      * bulk-update scenarios so the notifications are only rebuilt once.
-     *
+     * <p>
      * If the given {@code timer} is expired and marked for deletion after use then this method
      * removes the the timer. The timer is otherwise transitioned to the reset state and continues
      * to exist.
      *
-     * @param timer the timer to be reset
+     * @param timer        the timer to be reset
      * @param allowDelete  {@code true} if the timer is allowed to be deleted instead of reset
      *                     (e.g. one use timers)
      * @param eventLabelId the label of the timer event to send; 0 if no event should be sent
      * @return the reset {@code timer} or {@code null} if the timer was deleted
      */
     private Timer doResetOrDeleteTimer(Timer timer, boolean allowDelete,
-            @StringRes int eventLabelId) {
+                                       @StringRes int eventLabelId) {
         if (allowDelete
                 && (timer.isExpired() || timer.isMissed())
                 && timer.getDeleteAfterUse()) {
@@ -654,7 +689,6 @@ final class TimerModel {
         doUpdateTimer(updated);
     }
 
-
     /**
      * Updates the callback given to this application from the {@link AlarmManager} that signals the
      * expiration of the next timer. If no timers are currently set to expire (i.e. no running
@@ -696,7 +730,7 @@ final class TimerModel {
      * Starts and stops the ringer for timers if the change to the timer demands it.
      *
      * @param before the state of the timer before the change; {@code null} indicates added
-     * @param after the state of the timer after the change; {@code null} indicates delete
+     * @param after  the state of the timer after the change; {@code null} indicates delete
      */
     private void updateRinger(Timer before, Timer after) {
         // Retrieve the states before and after the change.
@@ -825,21 +859,10 @@ final class TimerModel {
     private final class PreferenceListener implements OnSharedPreferenceChangeListener {
         @Override
         public void onSharedPreferenceChanged(SharedPreferences prefs, String key) {
-            switch (key) {
-                case SettingsActivity.KEY_TIMER_RINGTONE:
-                    mTimerRingtoneUri = null;
-                    mTimerRingtoneTitle = null;
-                    break;
+            if (SettingsActivity.KEY_TIMER_RINGTONE.equals(key)) {
+                mTimerRingtoneUri = null;
+                mTimerRingtoneTitle = null;
             }
         }
     }
-
-    static void schedulePendingIntent(AlarmManager am, long triggerTime, PendingIntent pi) {
-        if (Utils.isMOrLater()) {
-            // Ensure the timer fires even if the device is dozing.
-            am.setExactAndAllowWhileIdle(ELAPSED_REALTIME_WAKEUP, triggerTime, pi);
-        } else {
-            am.setExact(ELAPSED_REALTIME_WAKEUP, triggerTime, pi);
-        }
-    }
 }
diff --git a/src/com/android/deskclock/data/TimerNotificationBuilder.java b/app/src/main/java/com/best/deskclock/data/TimerNotificationBuilder.java
similarity index 87%
rename from src/com/android/deskclock/data/TimerNotificationBuilder.java
rename to app/src/main/java/com/best/deskclock/data/TimerNotificationBuilder.java
index 5a112d69c..0ae95a3df 100644
--- a/src/com/android/deskclock/data/TimerNotificationBuilder.java
+++ b/app/src/main/java/com/best/deskclock/data/TimerNotificationBuilder.java
@@ -16,26 +16,28 @@
 
 package com.best.deskclock.data;
 
+import static android.text.format.DateUtils.MINUTE_IN_MILLIS;
+import static android.text.format.DateUtils.SECOND_IN_MILLIS;
+import static androidx.core.app.NotificationCompat.Action;
+import static androidx.core.app.NotificationCompat.Builder;
 import static com.best.deskclock.NotificationUtils.FIRING_NOTIFICATION_CHANNEL_ID;
 import static com.best.deskclock.NotificationUtils.TIMER_MODEL_NOTIFICATION_CHANNEL_ID;
 
 import android.annotation.TargetApi;
 import android.app.AlarmManager;
 import android.app.Notification;
-import android.app.NotificationChannel;
 import android.app.PendingIntent;
 import android.content.Context;
 import android.content.Intent;
 import android.content.res.Resources;
 import android.os.Build;
 import android.os.SystemClock;
-import androidx.annotation.DrawableRes;
-import androidx.core.app.NotificationCompat;
-import androidx.core.app.NotificationManagerCompat;
-import androidx.core.content.ContextCompat;
 import android.text.TextUtils;
 import android.widget.RemoteViews;
 
+import androidx.annotation.DrawableRes;
+import androidx.core.app.NotificationCompat;
+
 import com.best.deskclock.AlarmUtils;
 import com.best.deskclock.NotificationUtils;
 import com.best.deskclock.R;
@@ -47,11 +49,6 @@ import com.best.deskclock.timer.TimerService;
 import java.util.ArrayList;
 import java.util.List;
 
-import static androidx.core.app.NotificationCompat.Action;
-import static androidx.core.app.NotificationCompat.Builder;
-import static android.text.format.DateUtils.MINUTE_IN_MILLIS;
-import static android.text.format.DateUtils.SECOND_IN_MILLIS;
-
 /**
  * Builds notifications to reflect the latest state of the timers.
  */
@@ -60,6 +57,20 @@ class TimerNotificationBuilder {
     private static final int REQUEST_CODE_UPCOMING = 0;
     private static final int REQUEST_CODE_MISSING = 1;
 
+    /**
+     * @param timer the timer on which to base the chronometer display
+     * @return the time at which the chronometer will/did reach 0:00 in realtime
+     */
+    private static long getChronometerBase(Timer timer) {
+        // The in-app timer display rounds *up* to the next second for positive timer values. Mirror
+        // that behavior in the notification's Chronometer by padding in an extra second as needed.
+        final long remaining = timer.getRemainingTime();
+        final long adjustedRemaining = remaining < 0 ? remaining : remaining + SECOND_IN_MILLIS;
+
+        // Chronometer will/did reach 0:00 adjustedRemaining milliseconds from now.
+        return SystemClock.elapsedRealtime() + adjustedRemaining;
+    }
+
     public Notification build(Context context, NotificationModel nm, List<Timer> unexpired) {
         final Timer timer = unexpired.get(0);
         final int count = unexpired.size();
@@ -156,18 +167,18 @@ class TimerNotificationBuilder {
 
         final Builder notification = new NotificationCompat.Builder(
                 context, TIMER_MODEL_NOTIFICATION_CHANNEL_ID)
-                        .setOngoing(true)
-                        .setLocalOnly(true)
-                        .setShowWhen(false)
-                        .setAutoCancel(false)
-                        .setContentIntent(pendingShowApp)
-                        .setPriority(Notification.PRIORITY_LOW)
-                        .setCategory(NotificationCompat.CATEGORY_ALARM)
-                        .setSmallIcon(R.drawable.stat_notify_timer)
-                        .setSortKey(nm.getTimerNotificationSortKey())
-                        .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
-                        .setStyle(new NotificationCompat.DecoratedCustomViewStyle())
-                        .setColor(ContextCompat.getColor(context, R.color.default_background));
+                .setOngoing(true)
+                .setLocalOnly(true)
+                .setShowWhen(false)
+                .setAutoCancel(false)
+                .setContentIntent(pendingShowApp)
+                .setPriority(Notification.PRIORITY_LOW)
+                .setCategory(NotificationCompat.CATEGORY_ALARM)
+                .setSmallIcon(R.drawable.stat_notify_timer)
+                .setSortKey(nm.getTimerNotificationSortKey())
+                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
+                .setStyle(new NotificationCompat.DecoratedCustomViewStyle())
+                .setColor(android.R.attr.colorAccent);
 
         for (Action action : actions) {
             notification.addAction(action);
@@ -271,17 +282,17 @@ class TimerNotificationBuilder {
 
         final Builder notification = new NotificationCompat.Builder(
                 context, FIRING_NOTIFICATION_CHANNEL_ID)
-                        .setOngoing(true)
-                        .setLocalOnly(true)
-                        .setShowWhen(false)
-                        .setAutoCancel(false)
-                        .setContentIntent(contentIntent)
-                        .setPriority(Notification.PRIORITY_HIGH)
-                        .setDefaults(Notification.DEFAULT_LIGHTS)
-                        .setSmallIcon(R.drawable.stat_notify_timer)
-                        .setFullScreenIntent(pendingFullScreen, true)
-                        .setStyle(new NotificationCompat.DecoratedCustomViewStyle())
-                        .setColor(ContextCompat.getColor(context, R.color.default_background));
+                .setOngoing(true)
+                .setLocalOnly(true)
+                .setShowWhen(false)
+                .setAutoCancel(false)
+                .setContentIntent(contentIntent)
+                .setPriority(Notification.PRIORITY_HIGH)
+                .setDefaults(Notification.DEFAULT_LIGHTS)
+                .setSmallIcon(R.drawable.stat_notify_timer)
+                .setFullScreenIntent(pendingFullScreen, true)
+                .setStyle(new NotificationCompat.DecoratedCustomViewStyle())
+                .setColor(android.R.attr.colorAccent);
 
         for (Action action : actions) {
             notification.addAction(action);
@@ -302,7 +313,7 @@ class TimerNotificationBuilder {
     }
 
     Notification buildMissed(Context context, NotificationModel nm,
-            List<Timer> missedTimers) {
+                             List<Timer> missedTimers) {
         final Timer timer = missedTimers.get(0);
         final int count = missedTimers.size();
 
@@ -356,18 +367,18 @@ class TimerNotificationBuilder {
 
         final Builder notification = new NotificationCompat.Builder(
                 context, TIMER_MODEL_NOTIFICATION_CHANNEL_ID)
-                        .setLocalOnly(true)
-                        .setShowWhen(false)
-                        .setAutoCancel(false)
-                        .setContentIntent(pendingShowApp)
-                        .setPriority(Notification.PRIORITY_HIGH)
-                        .setCategory(NotificationCompat.CATEGORY_ALARM)
-                        .setSmallIcon(R.drawable.stat_notify_timer)
-                        .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
-                        .setSortKey(nm.getTimerNotificationMissedSortKey())
-                        .setStyle(new NotificationCompat.DecoratedCustomViewStyle())
-                        .addAction(action)
-                        .setColor(ContextCompat.getColor(context, R.color.default_background));
+                .setLocalOnly(true)
+                .setShowWhen(false)
+                .setAutoCancel(false)
+                .setContentIntent(pendingShowApp)
+                .setPriority(Notification.PRIORITY_HIGH)
+                .setCategory(NotificationCompat.CATEGORY_ALARM)
+                .setSmallIcon(R.drawable.stat_notify_timer)
+                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
+                .setSortKey(nm.getTimerNotificationMissedSortKey())
+                .setStyle(new NotificationCompat.DecoratedCustomViewStyle())
+                .addAction(action)
+                .setColor(android.R.attr.colorAccent);
 
         if (Utils.isNOrLater()) {
             notification.setCustomContentView(buildChronometer(pname, base, true, stateText))
@@ -382,23 +393,9 @@ class TimerNotificationBuilder {
         return notification.build();
     }
 
-    /**
-     * @param timer the timer on which to base the chronometer display
-     * @return the time at which the chronometer will/did reach 0:00 in realtime
-     */
-    private static long getChronometerBase(Timer timer) {
-        // The in-app timer display rounds *up* to the next second for positive timer values. Mirror
-        // that behavior in the notification's Chronometer by padding in an extra second as needed.
-        final long remaining = timer.getRemainingTime();
-        final long adjustedRemaining = remaining < 0 ? remaining : remaining + SECOND_IN_MILLIS;
-
-        // Chronometer will/did reach 0:00 adjustedRemaining milliseconds from now.
-        return SystemClock.elapsedRealtime() + adjustedRemaining;
-    }
-
     @TargetApi(Build.VERSION_CODES.N)
     private RemoteViews buildChronometer(String pname, long base, boolean running,
-            CharSequence stateText) {
+                                         CharSequence stateText) {
         final RemoteViews content = new RemoteViews(pname, R.layout.chronometer_notif_content);
         content.setChronometerCountDown(R.id.chronometer, true);
         content.setChronometer(R.id.chronometer, base, null, running);
diff --git a/src/com/android/deskclock/data/TimerStringFormatter.java b/app/src/main/java/com/best/deskclock/data/TimerStringFormatter.java
similarity index 94%
rename from src/com/android/deskclock/data/TimerStringFormatter.java
rename to app/src/main/java/com/best/deskclock/data/TimerStringFormatter.java
index c6e8335e3..777230f60 100644
--- a/src/com/android/deskclock/data/TimerStringFormatter.java
+++ b/app/src/main/java/com/best/deskclock/data/TimerStringFormatter.java
@@ -16,23 +16,26 @@
 
 package com.best.deskclock.data;
 
+import static android.text.format.DateUtils.HOUR_IN_MILLIS;
+import static android.text.format.DateUtils.MINUTE_IN_MILLIS;
+import static android.text.format.DateUtils.SECOND_IN_MILLIS;
+
+import android.annotation.SuppressLint;
 import android.content.Context;
+
 import androidx.annotation.StringRes;
 
 import com.best.deskclock.R;
 import com.best.deskclock.Utils;
 
-import static android.text.format.DateUtils.HOUR_IN_MILLIS;
-import static android.text.format.DateUtils.MINUTE_IN_MILLIS;
-import static android.text.format.DateUtils.SECOND_IN_MILLIS;
-
 public class TimerStringFormatter {
 
     /**
      * Format "7 hours 52 minutes 14 seconds remaining"
      */
+    @SuppressLint("StringFormatInvalid")
     public static String formatTimeRemaining(Context context, long remainingTime,
-            boolean shouldShowSeconds) {
+                                             boolean shouldShowSeconds) {
         int roundedHours = (int) (remainingTime / HOUR_IN_MILLIS);
         int roundedMinutes = (int) (remainingTime / MINUTE_IN_MILLIS % 60);
         int roundedSeconds = (int) (remainingTime / SECOND_IN_MILLIS % 60);
@@ -50,22 +53,19 @@ public class TimerStringFormatter {
                 if (roundedMinutes == 60) {
                     minutes = 0;
                     roundedHours += 1;
-                    hours = roundedHours;
                 } else {
                     minutes = roundedMinutes;
-                    hours = roundedHours;
                 }
             } else {
                 seconds = roundedSeconds;
                 minutes = roundedMinutes;
-                hours = roundedHours;
             }
         } else {
             // Already perfect precision, or we don't want to consider seconds at all.
             seconds = roundedSeconds;
             minutes = roundedMinutes;
-            hours = roundedHours;
         }
+        hours = roundedHours;
 
         final String minSeq = Utils.getNumberFormattedQuantityString(context, R.plurals.minutes,
                 minutes);
@@ -116,7 +116,7 @@ public class TimerStringFormatter {
     }
 
     public static String formatString(Context context, @StringRes int stringResId, long currentTime,
-            boolean shouldShowSeconds) {
+                                      boolean shouldShowSeconds) {
         return String.format(context.getString(stringResId),
                 formatTimeRemaining(context, currentTime, shouldShowSeconds));
     }
diff --git a/src/com/android/deskclock/data/Weekdays.java b/app/src/main/java/com/best/deskclock/data/Weekdays.java
similarity index 81%
rename from src/com/android/deskclock/data/Weekdays.java
rename to app/src/main/java/com/best/deskclock/data/Weekdays.java
index 9a896568b..46f4b6018 100644
--- a/src/com/android/deskclock/data/Weekdays.java
+++ b/app/src/main/java/com/best/deskclock/data/Weekdays.java
@@ -16,10 +16,21 @@
 
 package com.best.deskclock.data;
 
+import static java.util.Calendar.DAY_OF_WEEK;
+import static java.util.Calendar.FRIDAY;
+import static java.util.Calendar.MONDAY;
+import static java.util.Calendar.SATURDAY;
+import static java.util.Calendar.SUNDAY;
+import static java.util.Calendar.THURSDAY;
+import static java.util.Calendar.TUESDAY;
+import static java.util.Calendar.WEDNESDAY;
+
 import android.content.Context;
-import androidx.annotation.VisibleForTesting;
 import android.util.ArrayMap;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.VisibleForTesting;
+
 import com.best.deskclock.R;
 
 import java.text.DateFormatSymbols;
@@ -29,15 +40,6 @@ import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 
-import static java.util.Calendar.DAY_OF_WEEK;
-import static java.util.Calendar.FRIDAY;
-import static java.util.Calendar.MONDAY;
-import static java.util.Calendar.SATURDAY;
-import static java.util.Calendar.SUNDAY;
-import static java.util.Calendar.THURSDAY;
-import static java.util.Calendar.TUESDAY;
-import static java.util.Calendar.WEDNESDAY;
-
 /**
  * This class is responsible for encoding a weekly repeat cycle in a {@link #getBits bitset}. It
  * also converts between those bits and the {@link Calendar#DAY_OF_WEEK} values for easier mutation
@@ -46,49 +48,38 @@ import static java.util.Calendar.WEDNESDAY;
 public final class Weekdays {
 
     /**
-     * The preferred starting day of the week can differ by locale. This enumerated value is used to
-     * describe the preferred ordering.
+     * An instance with no weekdays in the weekly repeat cycle.
+     */
+    public static final Weekdays NONE = Weekdays.fromBits(0);
+    /**
+     * All valid bits set.
      */
-    public enum Order {
-        SAT_TO_FRI(SATURDAY, SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY),
-        SUN_TO_SAT(SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY),
-        MON_TO_SUN(MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY);
-
-        private final List<Integer> mCalendarDays;
-
-        Order(Integer... calendarDays) {
-            mCalendarDays = Arrays.asList(calendarDays);
-        }
-
-        public List<Integer> getCalendarDays() {
-            return mCalendarDays;
-        }
-    }
-
-    /** All valid bits set. */
     private static final int ALL_DAYS = 0x7F;
 
-    /** An instance with all weekdays in the weekly repeat cycle. */
+    /**
+     * An instance with all weekdays in the weekly repeat cycle.
+     */
     public static final Weekdays ALL = Weekdays.fromBits(ALL_DAYS);
-
-    /** An instance with no weekdays in the weekly repeat cycle. */
-    public static final Weekdays NONE = Weekdays.fromBits(0);
-
-    /** Maps calendar weekdays to the bit masks that represent them in this class. */
+    /**
+     * Maps calendar weekdays to the bit masks that represent them in this class.
+     */
     private static final Map<Integer, Integer> sCalendarDayToBit;
+
     static {
         final Map<Integer, Integer> map = new ArrayMap<>(7);
-        map.put(MONDAY,    0x01);
-        map.put(TUESDAY,   0x02);
+        map.put(MONDAY, 0x01);
+        map.put(TUESDAY, 0x02);
         map.put(WEDNESDAY, 0x04);
-        map.put(THURSDAY,  0x08);
-        map.put(FRIDAY,    0x10);
-        map.put(SATURDAY,  0x20);
-        map.put(SUNDAY,    0x40);
+        map.put(THURSDAY, 0x08);
+        map.put(FRIDAY, 0x10);
+        map.put(SATURDAY, 0x20);
+        map.put(SUNDAY, 0x40);
         sCalendarDayToBit = Collections.unmodifiableMap(map);
     }
 
-    /** An encoded form of a weekly repeat schedule. */
+    /**
+     * An encoded form of a weekly repeat schedule.
+     */
     private final int mBits;
 
     private Weekdays(int bits) {
@@ -130,16 +121,16 @@ public final class Weekdays {
 
     /**
      * @param calendarDay any of the following values
-     *                     <ul>
-     *                     <li>{@link Calendar#SUNDAY}</li>
-     *                     <li>{@link Calendar#MONDAY}</li>
-     *                     <li>{@link Calendar#TUESDAY}</li>
-     *                     <li>{@link Calendar#WEDNESDAY}</li>
-     *                     <li>{@link Calendar#THURSDAY}</li>
-     *                     <li>{@link Calendar#FRIDAY}</li>
-     *                     <li>{@link Calendar#SATURDAY}</li>
-     *                     </ul>
-     * @param on {@code true} if the {@code calendarDay} is on; {@code false} otherwise
+     *                    <ul>
+     *                    <li>{@link Calendar#SUNDAY}</li>
+     *                    <li>{@link Calendar#MONDAY}</li>
+     *                    <li>{@link Calendar#TUESDAY}</li>
+     *                    <li>{@link Calendar#WEDNESDAY}</li>
+     *                    <li>{@link Calendar#THURSDAY}</li>
+     *                    <li>{@link Calendar#FRIDAY}</li>
+     *                    <li>{@link Calendar#SATURDAY}</li>
+     *                    </ul>
+     * @param on          {@code true} if the {@code calendarDay} is on; {@code false} otherwise
      * @return a WeekDays instance with the {@code calendarDay} mutated
      */
     public Weekdays setBit(int calendarDay, boolean on) {
@@ -152,15 +143,15 @@ public final class Weekdays {
 
     /**
      * @param calendarDay any of the following values
-     *                     <ul>
-     *                     <li>{@link Calendar#SUNDAY}</li>
-     *                     <li>{@link Calendar#MONDAY}</li>
-     *                     <li>{@link Calendar#TUESDAY}</li>
-     *                     <li>{@link Calendar#WEDNESDAY}</li>
-     *                     <li>{@link Calendar#THURSDAY}</li>
-     *                     <li>{@link Calendar#FRIDAY}</li>
-     *                     <li>{@link Calendar#SATURDAY}</li>
-     *                     </ul>
+     *                    <ul>
+     *                    <li>{@link Calendar#SUNDAY}</li>
+     *                    <li>{@link Calendar#MONDAY}</li>
+     *                    <li>{@link Calendar#TUESDAY}</li>
+     *                    <li>{@link Calendar#WEDNESDAY}</li>
+     *                    <li>{@link Calendar#THURSDAY}</li>
+     *                    <li>{@link Calendar#FRIDAY}</li>
+     *                    <li>{@link Calendar#SATURDAY}</li>
+     *                    </ul>
      * @return {@code true} if the given {@code calendarDay}
      */
     public boolean isBitOn(int calendarDay) {
@@ -174,12 +165,16 @@ public final class Weekdays {
     /**
      * @return the weekly repeat schedule encoded as an integer
      */
-    public int getBits() { return mBits; }
+    public int getBits() {
+        return mBits;
+    }
 
     /**
      * @return {@code true} iff at least one weekday is enabled in the repeat schedule
      */
-    public boolean isRepeating() { return mBits != 0; }
+    public boolean isRepeating() {
+        return mBits != 0;
+    }
 
     /**
      * Note: only the day-of-week is read from the {@code time}. The time fields
@@ -187,7 +182,7 @@ public final class Weekdays {
      *
      * @param time a timestamp relative to which the answer is given
      * @return the number of days between the given {@code time} and the previous enabled weekday
-     *      which is always between 1 and 7 inclusive; {@code -1} if no weekdays are enabled
+     * which is always between 1 and 7 inclusive; {@code -1} if no weekdays are enabled
      */
     public int getDistanceToPreviousDay(Calendar time) {
         int calendarDay = time.get(DAY_OF_WEEK);
@@ -210,7 +205,7 @@ public final class Weekdays {
      *
      * @param time a timestamp relative to which the answer is given
      * @return the number of days between the given {@code time} and the next enabled weekday which
-     *      is always between 0 and 6 inclusive; {@code -1} if no weekdays are enabled
+     * is always between 0 and 6 inclusive; {@code -1} if no weekdays are enabled
      */
     public int getDistanceToNextDay(Calendar time) {
         int calendarDay = time.get(DAY_OF_WEEK);
@@ -242,6 +237,7 @@ public final class Weekdays {
         return mBits;
     }
 
+    @NonNull
     @Override
     public String toString() {
         final StringBuilder builder = new StringBuilder(19);
@@ -273,7 +269,7 @@ public final class Weekdays {
 
     /**
      * @param context for accessing resources
-     * @param order the order in which to present the weekdays
+     * @param order   the order in which to present the weekdays
      * @return the enabled weekdays in the given {@code order}
      */
     public String toString(Context context, Order order) {
@@ -282,9 +278,9 @@ public final class Weekdays {
 
     /**
      * @param context for accessing resources
-     * @param order the order in which to present the weekdays
+     * @param order   the order in which to present the weekdays
      * @return the enabled weekdays in the given {@code order} in a manner that
-     *      is most appropriate for talk-back
+     * is most appropriate for talk-back
      */
     public String toAccessibilityString(Context context, Order order) {
         return toString(context, order, true /* forceLongNames */);
@@ -302,8 +298,8 @@ public final class Weekdays {
     }
 
     /**
-     * @param context for accessing resources
-     * @param order the order in which to present the weekdays
+     * @param context        for accessing resources
+     * @param order          the order in which to present the weekdays
      * @param forceLongNames if {@code true} the un-abbreviated weekdays are used
      * @return the enabled weekdays in the given {@code order}
      */
@@ -333,4 +329,24 @@ public final class Weekdays {
         }
         return builder.toString();
     }
+
+    /**
+     * The preferred starting day of the week can differ by locale. This enumerated value is used to
+     * describe the preferred ordering.
+     */
+    public enum Order {
+        SAT_TO_FRI(SATURDAY, SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY),
+        SUN_TO_SAT(SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY),
+        MON_TO_SUN(MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY);
+
+        private final List<Integer> mCalendarDays;
+
+        Order(Integer... calendarDays) {
+            mCalendarDays = Arrays.asList(calendarDays);
+        }
+
+        public List<Integer> getCalendarDays() {
+            return mCalendarDays;
+        }
+    }
 }
diff --git a/src/com/android/deskclock/data/WidgetDAO.java b/app/src/main/java/com/best/deskclock/data/WidgetDAO.java
similarity index 87%
rename from src/com/android/deskclock/data/WidgetDAO.java
rename to app/src/main/java/com/best/deskclock/data/WidgetDAO.java
index 548e6e6eb..0d9a01c20 100644
--- a/src/com/android/deskclock/data/WidgetDAO.java
+++ b/app/src/main/java/com/best/deskclock/data/WidgetDAO.java
@@ -24,14 +24,17 @@ import android.content.SharedPreferences;
  */
 final class WidgetDAO {
 
-    /** Suffix for a key to a preference that stores the instance count for a given widget type. */
+    /**
+     * Suffix for a key to a preference that stores the instance count for a given widget type.
+     */
     private static final String WIDGET_COUNT = "_widget_count";
 
-    private WidgetDAO() {}
+    private WidgetDAO() {
+    }
 
     /**
      * @param widgetProviderClass indicates the type of widget being counted
-     * @param count the number of widgets of the given type
+     * @param count               the number of widgets of the given type
      * @return the delta between the new count and the old count
      */
     static int updateWidgetCount(SharedPreferences prefs, Class widgetProviderClass, int count) {
diff --git a/src/com/android/deskclock/data/WidgetModel.java b/app/src/main/java/com/best/deskclock/data/WidgetModel.java
similarity index 91%
rename from src/com/android/deskclock/data/WidgetModel.java
rename to app/src/main/java/com/best/deskclock/data/WidgetModel.java
index f5c3cafae..eeaebf37f 100644
--- a/src/com/android/deskclock/data/WidgetModel.java
+++ b/app/src/main/java/com/best/deskclock/data/WidgetModel.java
@@ -17,6 +17,7 @@
 package com.best.deskclock.data;
 
 import android.content.SharedPreferences;
+
 import androidx.annotation.StringRes;
 
 import com.best.deskclock.R;
@@ -34,8 +35,8 @@ final class WidgetModel {
     }
 
     /**
-     * @param widgetClass indicates the type of widget being counted
-     * @param count the number of widgets of the given type
+     * @param widgetClass     indicates the type of widget being counted
+     * @param count           the number of widgets of the given type
      * @param eventCategoryId identifies the category of event to send
      */
     void updateWidgetCount(Class widgetClass, int count, @StringRes int eventCategoryId) {
diff --git a/src/com/android/deskclock/events/EventTracker.java b/app/src/main/java/com/best/deskclock/events/EventTracker.java
similarity index 78%
rename from src/com/android/deskclock/events/EventTracker.java
rename to app/src/main/java/com/best/deskclock/events/EventTracker.java
index 291cc35fe..b793c2007 100644
--- a/src/com/android/deskclock/events/EventTracker.java
+++ b/app/src/main/java/com/best/deskclock/events/EventTracker.java
@@ -23,9 +23,9 @@ public interface EventTracker {
      * Record the event in some form or fashion.
      *
      * @param category indicates what entity raised the event: Alarm, Clock, Timer or Stopwatch
-     * @param action indicates how the entity was altered; e.g. create, delete, fire, etc.
-     * @param label indicates where the action originated; e.g. DeskClock (UI), Intent,
-     *      Notification, etc.; 0 indicates no label could be established
+     * @param action   indicates how the entity was altered; e.g. create, delete, fire, etc.
+     * @param label    indicates where the action originated; e.g. DeskClock (UI), Intent,
+     *                 Notification, etc.; 0 indicates no label could be established
      */
     void sendEvent(@StringRes int category, @StringRes int action, @StringRes int label);
 }
diff --git a/src/com/android/deskclock/events/Events.java b/app/src/main/java/com/best/deskclock/events/Events.java
similarity index 84%
rename from src/com/android/deskclock/events/Events.java
rename to app/src/main/java/com/best/deskclock/events/Events.java
index da9068f07..a8a4efbc5 100644
--- a/src/com/android/deskclock/events/Events.java
+++ b/app/src/main/java/com/best/deskclock/events/Events.java
@@ -26,14 +26,16 @@ import com.best.deskclock.controller.Controller;
  */
 public final class Events {
 
-    /** Extra describing the entity responsible for the action being performed. */
+    /**
+     * Extra describing the entity responsible for the action being performed.
+     */
     public static final String EXTRA_EVENT_LABEL = "com.best.deskclock.extra.EVENT_LABEL";
 
     /**
      * Tracks an alarm event.
      *
      * @param action resource id of event action
-     * @param label resource id of event label
+     * @param label  resource id of event label
      */
     public static void sendAlarmEvent(@StringRes int action, @StringRes int label) {
         sendEvent(R.string.category_alarm, action, label);
@@ -43,7 +45,7 @@ public final class Events {
      * Tracks a clock event.
      *
      * @param action resource id of event action
-     * @param label resource id of event label
+     * @param label  resource id of event label
      */
     public static void sendClockEvent(@StringRes int action, @StringRes int label) {
         sendEvent(R.string.category_clock, action, label);
@@ -53,7 +55,7 @@ public final class Events {
      * Tracks a timer event.
      *
      * @param action resource id of event action
-     * @param label resource id of event label
+     * @param label  resource id of event label
      */
     public static void sendTimerEvent(@StringRes int action, @StringRes int label) {
         sendEvent(R.string.category_timer, action, label);
@@ -63,7 +65,7 @@ public final class Events {
      * Tracks a stopwatch event.
      *
      * @param action resource id of event action
-     * @param label resource id of event label
+     * @param label  resource id of event label
      */
     public static void sendStopwatchEvent(@StringRes int action, @StringRes int label) {
         sendEvent(R.string.category_stopwatch, action, label);
@@ -73,7 +75,7 @@ public final class Events {
      * Tracks a screensaver event.
      *
      * @param action resource id of event action
-     * @param label resource id of event label
+     * @param label  resource id of event label
      */
     public static void sendScreensaverEvent(@StringRes int action, @StringRes int label) {
         sendEvent(R.string.category_screensaver, action, label);
@@ -85,11 +87,11 @@ public final class Events {
      * interactions with your application (value is not used in this app).
      *
      * @param category resource id of event category
-     * @param action resource id of event action
-     * @param label resource id of event label
+     * @param action   resource id of event action
+     * @param label    resource id of event label
      */
     public static void sendEvent(@StringRes int category, @StringRes int action,
-            @StringRes int label) {
+                                 @StringRes int label) {
         Controller.getController().sendEvent(category, action, label);
     }
 }
diff --git a/src/com/android/deskclock/events/LogEventTracker.java b/app/src/main/java/com/best/deskclock/events/LogEventTracker.java
similarity index 99%
rename from src/com/android/deskclock/events/LogEventTracker.java
rename to app/src/main/java/com/best/deskclock/events/LogEventTracker.java
index a71661c22..2d74299c5 100644
--- a/src/com/android/deskclock/events/LogEventTracker.java
+++ b/app/src/main/java/com/best/deskclock/events/LogEventTracker.java
@@ -16,6 +16,7 @@
 package com.best.deskclock.events;
 
 import android.content.Context;
+
 import androidx.annotation.StringRes;
 
 import com.best.deskclock.LogUtils;
diff --git a/src/com/android/deskclock/events/ShortcutEventTracker.java b/app/src/main/java/com/best/deskclock/events/ShortcutEventTracker.java
similarity index 99%
rename from src/com/android/deskclock/events/ShortcutEventTracker.java
rename to app/src/main/java/com/best/deskclock/events/ShortcutEventTracker.java
index f4cb5cc72..a231be399 100644
--- a/src/com/android/deskclock/events/ShortcutEventTracker.java
+++ b/app/src/main/java/com/best/deskclock/events/ShortcutEventTracker.java
@@ -20,9 +20,10 @@ import android.annotation.TargetApi;
 import android.content.Context;
 import android.content.pm.ShortcutManager;
 import android.os.Build;
-import androidx.annotation.StringRes;
 import android.util.ArraySet;
 
+import androidx.annotation.StringRes;
+
 import com.best.deskclock.R;
 import com.best.deskclock.uidata.UiDataModel;
 
diff --git a/src/com/android/deskclock/provider/Alarm.java b/app/src/main/java/com/best/deskclock/provider/Alarm.java
similarity index 95%
rename from src/com/android/deskclock/provider/Alarm.java
rename to app/src/main/java/com/best/deskclock/provider/Alarm.java
index 0f88598a4..cf85a4fc0 100644
--- a/src/com/android/deskclock/provider/Alarm.java
+++ b/app/src/main/java/com/best/deskclock/provider/Alarm.java
@@ -27,8 +27,8 @@ import android.media.RingtoneManager;
 import android.net.Uri;
 import android.os.Parcel;
 import android.os.Parcelable;
-import android.os.ParcelUuid;
 
+import androidx.annotation.NonNull;
 
 import com.best.deskclock.R;
 import com.best.deskclock.data.DataModel;
@@ -37,22 +37,36 @@ import com.best.deskclock.data.Weekdays;
 import java.util.Calendar;
 import java.util.LinkedList;
 import java.util.List;
-import java.util.UUID;
 
 public final class Alarm implements Parcelable, ClockContract.AlarmsColumns {
     /**
      * Alarms start with an invalid id when it hasn't been saved to the database.
      */
     public static final long INVALID_ID = -1;
+    public static final int INSTANCE_ID_INDEX = 10;
+    public static final int INSTANCE_YEAR_INDEX = 11;
+    public static final int INSTANCE_MONTH_INDEX = 12;
+    public static final int INSTANCE_DAY_INDEX = 13;
+    public static final int INSTANCE_HOUR_INDEX = 14;
+    public static final int INSTANCE_MINUTE_INDEX = 15;
+    public static final int INSTANCE_LABEL_INDEX = 16;
+    public static final int INSTANCE_VIBRATE_INDEX = 17;
+    public static final Parcelable.Creator<Alarm> CREATOR = new Parcelable.Creator<Alarm>() {
+        public Alarm createFromParcel(Parcel p) {
+            return new Alarm(p);
+        }
 
+        public Alarm[] newArray(int size) {
+            return new Alarm[size];
+        }
+    };
     /**
      * The default sort order for this table
      */
     private static final String DEFAULT_SORT_ORDER =
             ClockDatabaseHelper.ALARMS_TABLE_NAME + "." + HOUR + ", " +
-            ClockDatabaseHelper.ALARMS_TABLE_NAME + "." +  MINUTES + " ASC" + ", " +
-            ClockDatabaseHelper.ALARMS_TABLE_NAME + "." + ClockContract.AlarmsColumns._ID + " DESC";
-
+                    ClockDatabaseHelper.ALARMS_TABLE_NAME + "." + MINUTES + " ASC" + ", " +
+                    ClockDatabaseHelper.ALARMS_TABLE_NAME + "." + ClockContract.AlarmsColumns._ID + " DESC";
     private static final String[] QUERY_COLUMNS = {
             _ID,
             HOUR,
@@ -65,7 +79,6 @@ public final class Alarm implements Parcelable, ClockContract.AlarmsColumns {
             DELETE_AFTER_USE,
             INCREASING_VOLUME,
     };
-
     private static final String[] QUERY_ALARMS_WITH_INSTANCES_COLUMNS = {
             ClockDatabaseHelper.ALARMS_TABLE_NAME + "." + _ID,
             ClockDatabaseHelper.ALARMS_TABLE_NAME + "." + HOUR,
@@ -88,7 +101,6 @@ public final class Alarm implements Parcelable, ClockContract.AlarmsColumns {
             ClockDatabaseHelper.INSTANCES_TABLE_NAME + "." + ClockContract.InstancesColumns.LABEL,
             ClockDatabaseHelper.INSTANCES_TABLE_NAME + "." + ClockContract.InstancesColumns.VIBRATE
     };
-
     /**
      * These save calls to cursor.getColumnIndexOrThrow()
      * THEY MUST BE KEPT IN SYNC WITH ABOVE QUERY COLUMNS
@@ -103,19 +115,78 @@ public final class Alarm implements Parcelable, ClockContract.AlarmsColumns {
     private static final int RINGTONE_INDEX = 7;
     private static final int DELETE_AFTER_USE_INDEX = 8;
     private static final int INCREASING_VOLUME_INDEX = 9;
-
     private static final int INSTANCE_STATE_INDEX = 9;
-    public static final int INSTANCE_ID_INDEX = 10;
-    public static final int INSTANCE_YEAR_INDEX = 11;
-    public static final int INSTANCE_MONTH_INDEX = 12;
-    public static final int INSTANCE_DAY_INDEX = 13;
-    public static final int INSTANCE_HOUR_INDEX = 14;
-    public static final int INSTANCE_MINUTE_INDEX = 15;
-    public static final int INSTANCE_LABEL_INDEX = 16;
-    public static final int INSTANCE_VIBRATE_INDEX = 17;
-
     private static final int COLUMN_COUNT = INCREASING_VOLUME_INDEX + 1;
     private static final int ALARM_JOIN_INSTANCE_COLUMN_COUNT = INSTANCE_VIBRATE_INDEX + 1;
+    // Public fields
+    // TODO: Refactor instance names
+    public long id;
+    public boolean enabled;
+    public int hour;
+    public int minutes;
+    public Weekdays daysOfWeek;
+    public boolean vibrate;
+    public String label;
+    public Uri alert;
+    public boolean deleteAfterUse;
+    public boolean increasingVolume;
+    public int instanceState;
+    public int instanceId;
+
+    // Creates a default alarm at the current time.
+    public Alarm() {
+        this(0, 0);
+    }
+
+    public Alarm(int hour, int minutes) {
+        this.id = INVALID_ID;
+        this.hour = hour;
+        this.minutes = minutes;
+        this.vibrate = true;
+        this.daysOfWeek = Weekdays.NONE;
+        this.label = "";
+        this.alert = DataModel.getDataModel().getDefaultAlarmRingtoneUri();
+        this.deleteAfterUse = false;
+        this.increasingVolume = false;
+    }
+
+    public Alarm(Cursor c) {
+        id = c.getLong(ID_INDEX);
+        enabled = c.getInt(ENABLED_INDEX) == 1;
+        hour = c.getInt(HOUR_INDEX);
+        minutes = c.getInt(MINUTES_INDEX);
+        daysOfWeek = Weekdays.fromBits(c.getInt(DAYS_OF_WEEK_INDEX));
+        vibrate = c.getInt(VIBRATE_INDEX) == 1;
+        label = c.getString(LABEL_INDEX);
+        deleteAfterUse = c.getInt(DELETE_AFTER_USE_INDEX) == 1;
+        increasingVolume = c.getInt(INCREASING_VOLUME_INDEX) == 1;
+
+        if (c.getColumnCount() == ALARM_JOIN_INSTANCE_COLUMN_COUNT) {
+            instanceState = c.getInt(INSTANCE_STATE_INDEX);
+            instanceId = c.getInt(INSTANCE_ID_INDEX);
+        }
+
+        if (c.isNull(RINGTONE_INDEX)) {
+            // Should we be saving this with the current ringtone or leave it null
+            // so it changes when user changes default ringtone?
+            alert = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_ALARM);
+        } else {
+            alert = Uri.parse(c.getString(RINGTONE_INDEX));
+        }
+    }
+
+    Alarm(Parcel p) {
+        id = p.readLong();
+        enabled = p.readInt() == 1;
+        hour = p.readInt();
+        minutes = p.readInt();
+        daysOfWeek = Weekdays.fromBits(p.readInt());
+        vibrate = p.readInt() == 1;
+        label = p.readString();
+        alert = p.readParcelable(null);
+        deleteAfterUse = p.readInt() == 1;
+        increasingVolume = p.readInt() == 1;
+    }
 
     public static ContentValues createContentValues(Alarm alarm) {
         ContentValues values = new ContentValues(COLUMN_COUNT);
@@ -191,7 +262,7 @@ public final class Alarm implements Parcelable, ClockContract.AlarmsColumns {
     /**
      * Get alarm by id.
      *
-     * @param cr provides access to the content model
+     * @param cr      provides access to the content model
      * @param alarmId for the desired alarm.
      * @return alarm if found, null otherwise
      */
@@ -204,10 +275,11 @@ public final class Alarm implements Parcelable, ClockContract.AlarmsColumns {
 
         return null;
     }
+
     /**
      * Get alarm for the {@code contentUri}.
      *
-     * @param cr provides access to the content model
+     * @param cr         provides access to the content model
      * @param contentUri the {@link #getContentUri deeplink} for the desired alarm
      * @return instance if found, null otherwise
      */
@@ -218,17 +290,17 @@ public final class Alarm implements Parcelable, ClockContract.AlarmsColumns {
     /**
      * Get all alarms given conditions.
      *
-     * @param cr provides access to the content model
-     * @param selection A filter declaring which rows to return, formatted as an
-     *         SQL WHERE clause (excluding the WHERE itself). Passing null will
-     *         return all rows for the given URI.
+     * @param cr            provides access to the content model
+     * @param selection     A filter declaring which rows to return, formatted as an
+     *                      SQL WHERE clause (excluding the WHERE itself). Passing null will
+     *                      return all rows for the given URI.
      * @param selectionArgs You may include ?s in selection, which will be
-     *         replaced by the values from selectionArgs, in the order that they
-     *         appear in the selection. The values will be bound as Strings.
+     *                      replaced by the values from selectionArgs, in the order that they
+     *                      appear in the selection. The values will be bound as Strings.
      * @return list of alarms matching where clause or empty list if none found.
      */
     public static List<Alarm> getAlarms(ContentResolver cr, String selection,
-            String... selectionArgs) {
+                                        String... selectionArgs) {
         final List<Alarm> result = new LinkedList<>();
         try (Cursor cursor = cr.query(CONTENT_URI, QUERY_COLUMNS, selection, selectionArgs, null)) {
             if (cursor != null && cursor.moveToFirst()) {
@@ -271,86 +343,6 @@ public final class Alarm implements Parcelable, ClockContract.AlarmsColumns {
         return deletedRows == 1;
     }
 
-    public static final Parcelable.Creator<Alarm> CREATOR = new Parcelable.Creator<Alarm>() {
-        public Alarm createFromParcel(Parcel p) {
-            return new Alarm(p);
-        }
-
-        public Alarm[] newArray(int size) {
-            return new Alarm[size];
-        }
-    };
-
-    // Public fields
-    // TODO: Refactor instance names
-    public long id;
-    public boolean enabled;
-    public int hour;
-    public int minutes;
-    public Weekdays daysOfWeek;
-    public boolean vibrate;
-    public String label;
-    public Uri alert;
-    public boolean deleteAfterUse;
-    public boolean increasingVolume;
-    public int instanceState;
-    public int instanceId;
-
-    // Creates a default alarm at the current time.
-    public Alarm() {
-        this(0, 0);
-    }
-
-    public Alarm(int hour, int minutes) {
-        this.id = INVALID_ID;
-        this.hour = hour;
-        this.minutes = minutes;
-        this.vibrate = true;
-        this.daysOfWeek = Weekdays.NONE;
-        this.label = "";
-        this.alert = DataModel.getDataModel().getDefaultAlarmRingtoneUri();
-        this.deleteAfterUse = false;
-        this.increasingVolume = false;
-    }
-
-    public Alarm(Cursor c) {
-        id = c.getLong(ID_INDEX);
-        enabled = c.getInt(ENABLED_INDEX) == 1;
-        hour = c.getInt(HOUR_INDEX);
-        minutes = c.getInt(MINUTES_INDEX);
-        daysOfWeek = Weekdays.fromBits(c.getInt(DAYS_OF_WEEK_INDEX));
-        vibrate = c.getInt(VIBRATE_INDEX) == 1;
-        label = c.getString(LABEL_INDEX);
-        deleteAfterUse = c.getInt(DELETE_AFTER_USE_INDEX) == 1;
-        increasingVolume = c.getInt(INCREASING_VOLUME_INDEX) == 1;
-
-        if (c.getColumnCount() == ALARM_JOIN_INSTANCE_COLUMN_COUNT) {
-            instanceState = c.getInt(INSTANCE_STATE_INDEX);
-            instanceId = c.getInt(INSTANCE_ID_INDEX);
-        }
-
-        if (c.isNull(RINGTONE_INDEX)) {
-            // Should we be saving this with the current ringtone or leave it null
-            // so it changes when user changes default ringtone?
-            alert = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_ALARM);
-        } else {
-            alert = Uri.parse(c.getString(RINGTONE_INDEX));
-        }
-    }
-
-    Alarm(Parcel p) {
-        id = p.readLong();
-        enabled = p.readInt() == 1;
-        hour = p.readInt();
-        minutes = p.readInt();
-        daysOfWeek = Weekdays.fromBits(p.readInt());
-        vibrate = p.readInt() == 1;
-        label = p.readString();
-        alert = p.readParcelable(null);
-        deleteAfterUse = p.readInt() == 1;
-        increasingVolume = p.readInt() == 1;
-    }
-
     /**
      * @return the deeplink that identifies this alarm
      */
@@ -401,7 +393,6 @@ public final class Alarm implements Parcelable, ClockContract.AlarmsColumns {
     }
 
     /**
-     *
      * @param currentTime the current time
      * @return previous firing time, or null if this is a one-time alarm.
      */
@@ -465,6 +456,7 @@ public final class Alarm implements Parcelable, ClockContract.AlarmsColumns {
         return Long.valueOf(id).hashCode();
     }
 
+    @NonNull
     @Override
     public String toString() {
         return "Alarm{" +
diff --git a/src/com/android/deskclock/provider/AlarmInstance.java b/app/src/main/java/com/best/deskclock/provider/AlarmInstance.java
similarity index 91%
rename from src/com/android/deskclock/provider/AlarmInstance.java
rename to app/src/main/java/com/best/deskclock/provider/AlarmInstance.java
index 9884417f0..3c765eec1 100644
--- a/src/com/android/deskclock/provider/AlarmInstance.java
+++ b/app/src/main/java/com/best/deskclock/provider/AlarmInstance.java
@@ -25,6 +25,8 @@ import android.database.Cursor;
 import android.media.RingtoneManager;
 import android.net.Uri;
 
+import androidx.annotation.NonNull;
+
 import com.best.deskclock.LogUtils;
 import com.best.deskclock.R;
 import com.best.deskclock.alarms.AlarmStateManager;
@@ -33,7 +35,6 @@ import com.best.deskclock.data.DataModel;
 import java.util.Calendar;
 import java.util.LinkedList;
 import java.util.List;
-import java.util.UUID;
 
 public final class AlarmInstance implements ClockContract.InstancesColumns {
     /**
@@ -45,17 +46,14 @@ public final class AlarmInstance implements ClockContract.InstancesColumns {
      * Offset from alarm time to show high priority notification
      */
     public static final int HIGH_NOTIFICATION_MINUTE_OFFSET = -30;
-
-    /**
-     * Offset from alarm time to stop showing missed notification.
-     */
-    private static final int MISSED_TIME_TO_LIVE_HOUR_OFFSET = 12;
-
     /**
      * AlarmInstances start with an invalid id when it hasn't been saved to the database.
      */
     public static final long INVALID_ID = -1;
-
+    /**
+     * Offset from alarm time to stop showing missed notification.
+     */
+    private static final int MISSED_TIME_TO_LIVE_HOUR_OFFSET = 12;
     private static final String[] QUERY_COLUMNS = {
             _ID,
             YEAR,
@@ -89,6 +87,84 @@ public final class AlarmInstance implements ClockContract.InstancesColumns {
     private static final int INCREASING_VOLUME_INDEX = 11;
 
     private static final int COLUMN_COUNT = INCREASING_VOLUME_INDEX + 1;
+    // Public fields
+    public long mId;
+    public int mYear;
+    public int mMonth;
+    public int mDay;
+    public int mHour;
+    public int mMinute;
+    public String mLabel;
+    public boolean mVibrate;
+    public Uri mRingtone;
+    public Long mAlarmId;
+    public int mAlarmState;
+    public boolean mIncreasingVolume;
+
+    public AlarmInstance(Calendar calendar, Long alarmId) {
+        this(calendar);
+        mAlarmId = alarmId;
+    }
+
+    public AlarmInstance(Calendar calendar) {
+        mId = INVALID_ID;
+        setAlarmTime(calendar);
+        mLabel = "";
+        mVibrate = false;
+        mRingtone = null;
+        mAlarmState = SILENT_STATE;
+        mIncreasingVolume = false;
+    }
+
+    public AlarmInstance(AlarmInstance instance) {
+        this.mId = instance.mId;
+        this.mYear = instance.mYear;
+        this.mMonth = instance.mMonth;
+        this.mDay = instance.mDay;
+        this.mHour = instance.mHour;
+        this.mMinute = instance.mMinute;
+        this.mLabel = instance.mLabel;
+        this.mVibrate = instance.mVibrate;
+        this.mRingtone = instance.mRingtone;
+        this.mAlarmId = instance.mAlarmId;
+        this.mAlarmState = instance.mAlarmState;
+        this.mIncreasingVolume = instance.mIncreasingVolume;
+    }
+
+    public AlarmInstance(Cursor c, boolean joinedTable) {
+        if (joinedTable) {
+            mId = c.getLong(Alarm.INSTANCE_ID_INDEX);
+            mYear = c.getInt(Alarm.INSTANCE_YEAR_INDEX);
+            mMonth = c.getInt(Alarm.INSTANCE_MONTH_INDEX);
+            mDay = c.getInt(Alarm.INSTANCE_DAY_INDEX);
+            mHour = c.getInt(Alarm.INSTANCE_HOUR_INDEX);
+            mMinute = c.getInt(Alarm.INSTANCE_MINUTE_INDEX);
+            mLabel = c.getString(Alarm.INSTANCE_LABEL_INDEX);
+            mVibrate = c.getInt(Alarm.INSTANCE_VIBRATE_INDEX) == 1;
+        } else {
+            mId = c.getLong(ID_INDEX);
+            mYear = c.getInt(YEAR_INDEX);
+            mMonth = c.getInt(MONTH_INDEX);
+            mDay = c.getInt(DAY_INDEX);
+            mHour = c.getInt(HOUR_INDEX);
+            mMinute = c.getInt(MINUTES_INDEX);
+            mLabel = c.getString(LABEL_INDEX);
+            mVibrate = c.getInt(VIBRATE_INDEX) == 1;
+        }
+        if (c.isNull(RINGTONE_INDEX)) {
+            // Should we be saving this with the current ringtone or leave it null
+            // so it changes when user changes default ringtone?
+            mRingtone = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_ALARM);
+        } else {
+            mRingtone = Uri.parse(c.getString(RINGTONE_INDEX));
+        }
+
+        if (!c.isNull(ALARM_ID_INDEX)) {
+            mAlarmId = c.getLong(ALARM_ID_INDEX);
+        }
+        mAlarmState = c.getInt(ALARM_STATE_INDEX);
+        mIncreasingVolume = c.getInt(INCREASING_VOLUME_INDEX) == 1;
+    }
 
     public static ContentValues createContentValues(AlarmInstance instance) {
         ContentValues values = new ContentValues(COLUMN_COUNT);
@@ -139,7 +215,7 @@ public final class AlarmInstance implements ClockContract.InstancesColumns {
     /**
      * Get alarm instance from instanceId.
      *
-     * @param cr provides access to the content model
+     * @param cr         provides access to the content model
      * @param instanceId for the desired instance.
      * @return instance if found, null otherwise
      */
@@ -156,7 +232,7 @@ public final class AlarmInstance implements ClockContract.InstancesColumns {
     /**
      * Get alarm instance for the {@code contentUri}.
      *
-     * @param cr provides access to the content model
+     * @param cr         provides access to the content model
      * @param contentUri the {@link #getContentUri deeplink} for the desired instance
      * @return instance if found, null otherwise
      */
@@ -169,18 +245,19 @@ public final class AlarmInstance implements ClockContract.InstancesColumns {
      * Get an alarm instances by alarmId.
      *
      * @param contentResolver provides access to the content model
-     * @param alarmId of instances desired.
+     * @param alarmId         of instances desired.
      * @return list of alarms instances that are owned by alarmId.
      */
     public static List<AlarmInstance> getInstancesByAlarmId(ContentResolver contentResolver,
-            long alarmId) {
+                                                            long alarmId) {
         return getInstances(contentResolver, ALARM_ID + "=" + alarmId);
     }
 
     /**
      * Get the next instance of an alarm given its alarmId
+     *
      * @param contentResolver provides access to the content model
-     * @param alarmId of instance desired
+     * @param alarmId         of instance desired
      * @return the next instance of an alarm by alarmId.
      */
     public static AlarmInstance getNextUpcomingInstanceByAlarmId(ContentResolver contentResolver,
@@ -218,13 +295,13 @@ public final class AlarmInstance implements ClockContract.InstancesColumns {
     /**
      * Get a list of instances given selection.
      *
-     * @param cr provides access to the content model
-     * @param selection A filter declaring which rows to return, formatted as an
-     *         SQL WHERE clause (excluding the WHERE itself). Passing null will
-     *         return all rows for the given URI.
+     * @param cr            provides access to the content model
+     * @param selection     A filter declaring which rows to return, formatted as an
+     *                      SQL WHERE clause (excluding the WHERE itself). Passing null will
+     *                      return all rows for the given URI.
      * @param selectionArgs You may include ?s in selection, which will be
-     *         replaced by the values from selectionArgs, in the order that they
-     *         appear in the selection. The values will be bound as Strings.
+     *                      replaced by the values from selectionArgs, in the order that they
+     *                      appear in the selection. The values will be bound as Strings.
      * @return list of alarms matching where clause or empty list if none found.
      */
     public static List<AlarmInstance> getInstances(ContentResolver cr, String selection,
@@ -242,7 +319,7 @@ public final class AlarmInstance implements ClockContract.InstancesColumns {
     }
 
     public static AlarmInstance addInstance(ContentResolver contentResolver,
-            AlarmInstance instance) {
+                                            AlarmInstance instance) {
         // Make sure we are not adding a duplicate instances. This is not a
         // fix and should never happen. This is only a safe guard against bad code, and you
         // should fix the root issue if you see the error message.
@@ -278,7 +355,7 @@ public final class AlarmInstance implements ClockContract.InstancesColumns {
     }
 
     public static void deleteOtherInstances(Context context, ContentResolver contentResolver,
-            long alarmId, long instanceId) {
+                                            long alarmId, long instanceId) {
         final List<AlarmInstance> instances = getInstancesByAlarmId(contentResolver, alarmId);
         for (AlarmInstance instance : instances) {
             if (instance.mId != instanceId) {
@@ -288,85 +365,6 @@ public final class AlarmInstance implements ClockContract.InstancesColumns {
         }
     }
 
-    // Public fields
-    public long mId;
-    public int mYear;
-    public int mMonth;
-    public int mDay;
-    public int mHour;
-    public int mMinute;
-    public String mLabel;
-    public boolean mVibrate;
-    public Uri mRingtone;
-    public Long mAlarmId;
-    public int mAlarmState;
-    public boolean mIncreasingVolume;
-
-    public AlarmInstance(Calendar calendar, Long alarmId) {
-        this(calendar);
-        mAlarmId = alarmId;
-    }
-
-    public AlarmInstance(Calendar calendar) {
-        mId = INVALID_ID;
-        setAlarmTime(calendar);
-        mLabel = "";
-        mVibrate = false;
-        mRingtone = null;
-        mAlarmState = SILENT_STATE;
-        mIncreasingVolume = false;
-    }
-
-    public AlarmInstance(AlarmInstance instance) {
-         this.mId = instance.mId;
-         this.mYear = instance.mYear;
-         this.mMonth = instance.mMonth;
-         this.mDay = instance.mDay;
-         this.mHour = instance.mHour;
-         this.mMinute = instance.mMinute;
-         this.mLabel = instance.mLabel;
-         this.mVibrate = instance.mVibrate;
-         this.mRingtone = instance.mRingtone;
-         this.mAlarmId = instance.mAlarmId;
-         this.mAlarmState = instance.mAlarmState;
-         this.mIncreasingVolume = instance.mIncreasingVolume;
-    }
-
-    public AlarmInstance(Cursor c, boolean joinedTable) {
-        if (joinedTable) {
-            mId = c.getLong(Alarm.INSTANCE_ID_INDEX);
-            mYear = c.getInt(Alarm.INSTANCE_YEAR_INDEX);
-            mMonth = c.getInt(Alarm.INSTANCE_MONTH_INDEX);
-            mDay = c.getInt(Alarm.INSTANCE_DAY_INDEX);
-            mHour = c.getInt(Alarm.INSTANCE_HOUR_INDEX);
-            mMinute = c.getInt(Alarm.INSTANCE_MINUTE_INDEX);
-            mLabel = c.getString(Alarm.INSTANCE_LABEL_INDEX);
-            mVibrate = c.getInt(Alarm.INSTANCE_VIBRATE_INDEX) == 1;
-        } else {
-            mId = c.getLong(ID_INDEX);
-            mYear = c.getInt(YEAR_INDEX);
-            mMonth = c.getInt(MONTH_INDEX);
-            mDay = c.getInt(DAY_INDEX);
-            mHour = c.getInt(HOUR_INDEX);
-            mMinute = c.getInt(MINUTES_INDEX);
-            mLabel = c.getString(LABEL_INDEX);
-            mVibrate = c.getInt(VIBRATE_INDEX) == 1;
-        }
-        if (c.isNull(RINGTONE_INDEX)) {
-            // Should we be saving this with the current ringtone or leave it null
-            // so it changes when user changes default ringtone?
-            mRingtone = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_ALARM);
-        } else {
-            mRingtone = Uri.parse(c.getString(RINGTONE_INDEX));
-        }
-
-        if (!c.isNull(ALARM_ID_INDEX)) {
-            mAlarmId = c.getLong(ALARM_ID_INDEX);
-        }
-        mAlarmState = c.getInt(ALARM_STATE_INDEX);
-        mIncreasingVolume = c.getInt(INCREASING_VOLUME_INDEX) == 1;
-    }
-
     /**
      * @return the deeplink that identifies this alarm instance
      */
@@ -378,14 +376,6 @@ public final class AlarmInstance implements ClockContract.InstancesColumns {
         return mLabel.isEmpty() ? context.getString(R.string.default_label) : mLabel;
     }
 
-    public void setAlarmTime(Calendar calendar) {
-        mYear = calendar.get(Calendar.YEAR);
-        mMonth = calendar.get(Calendar.MONTH);
-        mDay = calendar.get(Calendar.DAY_OF_MONTH);
-        mHour = calendar.get(Calendar.HOUR_OF_DAY);
-        mMinute = calendar.get(Calendar.MINUTE);
-    }
-
     /**
      * Return the time when a alarm should fire.
      *
@@ -403,6 +393,14 @@ public final class AlarmInstance implements ClockContract.InstancesColumns {
         return calendar;
     }
 
+    public void setAlarmTime(Calendar calendar) {
+        mYear = calendar.get(Calendar.YEAR);
+        mMonth = calendar.get(Calendar.MONTH);
+        mDay = calendar.get(Calendar.DAY_OF_MONTH);
+        mHour = calendar.get(Calendar.HOUR_OF_DAY);
+        mMinute = calendar.get(Calendar.MINUTE);
+    }
+
     /**
      * Return the time when a low priority notification should be shown.
      *
@@ -466,6 +464,7 @@ public final class AlarmInstance implements ClockContract.InstancesColumns {
         return Long.valueOf(mId).hashCode();
     }
 
+    @NonNull
     @Override
     public String toString() {
         return "AlarmInstance{" +
diff --git a/src/com/android/deskclock/provider/ClockContract.java b/app/src/main/java/com/best/deskclock/provider/ClockContract.java
similarity index 97%
rename from src/com/android/deskclock/provider/ClockContract.java
rename to app/src/main/java/com/best/deskclock/provider/ClockContract.java
index c7d27a303..f97593755 100644
--- a/src/com/android/deskclock/provider/ClockContract.java
+++ b/app/src/main/java/com/best/deskclock/provider/ClockContract.java
@@ -47,7 +47,8 @@ public final class ClockContract {
     /**
      * This utility class cannot be instantiated
      */
-    private ClockContract() {}
+    private ClockContract() {
+    }
 
     /**
      * Constants for tables with AlarmSettings.
@@ -89,7 +90,7 @@ public final class ClockContract {
          * True if alarm should start off quiet and slowly increase volume
          * <P>Type: BOOLEAN</P>
          */
-        public static final String INCREASING_VOLUME = "incvol";
+        String INCREASING_VOLUME = "incvol";
     }
 
     /**
@@ -123,7 +124,7 @@ public final class ClockContract {
         /**
          * Days of the week encoded as a bit set.
          * <p>Type: INTEGER</p>
-         *
+         * <p>
          * {@link com.best.deskclock.data.Weekdays}
          */
         String DAYS_OF_WEEK = "daysofweek";
@@ -152,7 +153,7 @@ public final class ClockContract {
 
         /**
          * Alarm state when to show no notification.
-         *
+         * <p>
          * Can transitions to:
          * LOW_NOTIFICATION_STATE
          */
@@ -160,7 +161,7 @@ public final class ClockContract {
 
         /**
          * Alarm state to show low priority alarm notification.
-         *
+         * <p>
          * Can transitions to:
          * HIDE_NOTIFICATION_STATE
          * HIGH_NOTIFICATION_STATE
@@ -170,7 +171,7 @@ public final class ClockContract {
 
         /**
          * Alarm state to hide low priority alarm notification.
-         *
+         * <p>
          * Can transitions to:
          * HIGH_NOTIFICATION_STATE
          */
@@ -178,7 +179,7 @@ public final class ClockContract {
 
         /**
          * Alarm state to show high priority alarm notification.
-         *
+         * <p>
          * Can transitions to:
          * DISMISSED_STATE
          * FIRED_STATE
@@ -187,7 +188,7 @@ public final class ClockContract {
 
         /**
          * Alarm state when alarm is in snooze.
-         *
+         * <p>
          * Can transitions to:
          * DISMISSED_STATE
          * FIRED_STATE
@@ -196,7 +197,7 @@ public final class ClockContract {
 
         /**
          * Alarm state when alarm is being fired.
-         *
+         * <p>
          * Can transitions to:
          * DISMISSED_STATE
          * SNOOZED_STATE
@@ -206,7 +207,7 @@ public final class ClockContract {
 
         /**
          * Alarm state when alarm has been missed.
-         *
+         * <p>
          * Can transitions to:
          * DISMISSED_STATE
          */
diff --git a/src/com/android/deskclock/provider/ClockDatabaseHelper.java b/app/src/main/java/com/best/deskclock/provider/ClockDatabaseHelper.java
similarity index 98%
rename from src/com/android/deskclock/provider/ClockDatabaseHelper.java
rename to app/src/main/java/com/best/deskclock/provider/ClockDatabaseHelper.java
index 3c461b6ee..aa538563a 100644
--- a/src/com/android/deskclock/provider/ClockDatabaseHelper.java
+++ b/app/src/main/java/com/best/deskclock/provider/ClockDatabaseHelper.java
@@ -16,7 +16,6 @@
 
 package com.best.deskclock.provider;
 
-import android.content.ContentResolver;
 import android.content.ContentValues;
 import android.content.Context;
 import android.database.Cursor;
@@ -30,63 +29,57 @@ import com.best.deskclock.LogUtils;
 import com.best.deskclock.data.Weekdays;
 
 import java.util.Calendar;
-import java.util.UUID;
 
 /**
  * Helper class for opening the database from multiple providers.  Also provides
  * some common functionality.
  */
 class ClockDatabaseHelper extends SQLiteOpenHelper {
+    // Database and table names
+    static final String DATABASE_NAME = "alarms.db";
+    static final String OLD_ALARMS_TABLE_NAME = "alarms";
+    static final String ALARMS_TABLE_NAME = "alarm_templates";
+    static final String INSTANCES_TABLE_NAME = "alarm_instances";
     /**
      * Original Clock Database.
      **/
     private static final int VERSION_5 = 5;
-
     /**
      * Added alarm_instances table
      * Added selected_cities table
      * Added DELETE_AFTER_USE column to alarms table
      */
     private static final int VERSION_6 = 6;
-
     /**
      * Added alarm settings to instance table.
      */
     private static final int VERSION_7 = 7;
-
     /**
      * Removed selected_cities table.
      */
     private static final int VERSION_8 = 8;
-
     /**
      * Added increasing alarm volume mode
      */
     private static final int VERSION_9 = 10;
-
     /**
      * Added change profile
      */
     private static final int VERSION_10 = 11;
-
     /**
      * Removed change profile
      */
     private static final int VERSION_11 = 12;
-
     // This creates a default alarm at 8:30 for every Mon,Tue,Wed,Thu,Fri
     private static final String DEFAULT_ALARM_1 = "(8, 30, 31, 0, 1, '', NULL, 0, 0);";
-
     // This creates a default alarm at 9:30 for every Sat,Sun
     private static final String DEFAULT_ALARM_2 = "(9, 00, 96, 0, 1, '', NULL, 0, 0);";
-
-    // Database and table names
-    static final String DATABASE_NAME = "alarms.db";
-    static final String OLD_ALARMS_TABLE_NAME = "alarms";
-    static final String ALARMS_TABLE_NAME = "alarm_templates";
-    static final String INSTANCES_TABLE_NAME = "alarm_instances";
     private static final String SELECTED_CITIES_TABLE_NAME = "selected_cities";
 
+    public ClockDatabaseHelper(Context context) {
+        super(context, DATABASE_NAME, null, VERSION_11);
+    }
+
     private static void createAlarmsTable(SQLiteDatabase db, String alarmsTableName) {
         db.execSQL("CREATE TABLE " + alarmsTableName + " (" +
                 ClockContract.AlarmsColumns._ID + " INTEGER PRIMARY KEY," +
@@ -115,16 +108,12 @@ class ClockDatabaseHelper extends SQLiteOpenHelper {
                 ClockContract.InstancesColumns.RINGTONE + " TEXT, " +
                 ClockContract.InstancesColumns.ALARM_STATE + " INTEGER NOT NULL, " +
                 ClockContract.InstancesColumns.ALARM_ID + " INTEGER REFERENCES " +
-                    ALARMS_TABLE_NAME + "(" + ClockContract.AlarmsColumns._ID + ") " +
-                    "ON UPDATE CASCADE ON DELETE CASCADE, " +
+                ALARMS_TABLE_NAME + "(" + ClockContract.AlarmsColumns._ID + ") " +
+                "ON UPDATE CASCADE ON DELETE CASCADE, " +
                 ClockContract.InstancesColumns.INCREASING_VOLUME + " INTEGER NOT NULL DEFAULT 0);");
         LogUtils.i("Instance table created");
     }
 
-    public ClockDatabaseHelper(Context context) {
-        super(context, DATABASE_NAME, null, VERSION_11);
-    }
-
     @Override
     public void onCreate(SQLiteDatabase db) {
         createAlarmsTable(db, ALARMS_TABLE_NAME);
@@ -279,7 +268,7 @@ class ClockDatabaseHelper extends SQLiteOpenHelper {
         // insert an already used id?
         final SQLiteDatabase db = getWritableDatabase();
         db.beginTransaction();
-        long rowId = -1;
+        long rowId;
         try {
             // Check if we are trying to re-use an existing id.
             final Object value = values.get(ClockContract.AlarmsColumns._ID);
diff --git a/src/com/android/deskclock/provider/ClockProvider.java b/app/src/main/java/com/best/deskclock/provider/ClockProvider.java
similarity index 97%
rename from src/com/android/deskclock/provider/ClockProvider.java
rename to app/src/main/java/com/best/deskclock/provider/ClockProvider.java
index d392b48fd..788563967 100644
--- a/src/com/android/deskclock/provider/ClockProvider.java
+++ b/app/src/main/java/com/best/deskclock/provider/ClockProvider.java
@@ -16,6 +16,11 @@
 
 package com.best.deskclock.provider;
 
+import static com.best.deskclock.provider.ClockContract.AlarmsColumns;
+import static com.best.deskclock.provider.ClockContract.InstancesColumns;
+import static com.best.deskclock.provider.ClockDatabaseHelper.ALARMS_TABLE_NAME;
+import static com.best.deskclock.provider.ClockDatabaseHelper.INSTANCES_TABLE_NAME;
+
 import android.annotation.TargetApi;
 import android.content.ContentProvider;
 import android.content.ContentResolver;
@@ -28,34 +33,42 @@ import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteQueryBuilder;
 import android.net.Uri;
 import android.os.Build;
-import androidx.annotation.NonNull;
 import android.text.TextUtils;
 import android.util.ArrayMap;
 
+import androidx.annotation.NonNull;
+
 import com.best.deskclock.LogUtils;
 import com.best.deskclock.Utils;
 
 import java.util.Map;
 
-import static com.best.deskclock.provider.ClockContract.AlarmsColumns;
-import static com.best.deskclock.provider.ClockContract.InstancesColumns;
-import static com.best.deskclock.provider.ClockDatabaseHelper.ALARMS_TABLE_NAME;
-import static com.best.deskclock.provider.ClockDatabaseHelper.INSTANCES_TABLE_NAME;
-
 public class ClockProvider extends ContentProvider {
 
-    private ClockDatabaseHelper mOpenHelper;
-
     private static final int ALARMS = 1;
     private static final int ALARMS_ID = 2;
     private static final int INSTANCES = 3;
     private static final int INSTANCES_ID = 4;
     private static final int ALARMS_WITH_INSTANCES = 5;
-
     /**
      * Projection map used by query for snoozed alarms.
      */
     private static final Map<String, String> sAlarmsWithInstancesProjection = new ArrayMap<>();
+    private static final String ALARM_JOIN_INSTANCE_TABLE_STATEMENT =
+            ALARMS_TABLE_NAME + " LEFT JOIN " + INSTANCES_TABLE_NAME + " ON (" +
+                    ALARMS_TABLE_NAME + "." + AlarmsColumns._ID + " = " + InstancesColumns.ALARM_ID + ")";
+    private static final String ALARM_JOIN_INSTANCE_WHERE_STATEMENT =
+            INSTANCES_TABLE_NAME + "." + InstancesColumns._ID + " IS NULL OR " +
+                    INSTANCES_TABLE_NAME + "." + InstancesColumns._ID + " = (" +
+                    "SELECT " + InstancesColumns._ID +
+                    " FROM " + INSTANCES_TABLE_NAME +
+                    " WHERE " + InstancesColumns.ALARM_ID +
+                    " = " + ALARMS_TABLE_NAME + "." + AlarmsColumns._ID +
+                    " ORDER BY " + InstancesColumns.ALARM_STATE + ", " +
+                    InstancesColumns.YEAR + ", " + InstancesColumns.MONTH + ", " +
+                    InstancesColumns.DAY + " LIMIT 1)";
+    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);
+
     static {
         sAlarmsWithInstancesProjection.put(ALARMS_TABLE_NAME + "." + AlarmsColumns._ID,
                 ALARMS_TABLE_NAME + "." + AlarmsColumns._ID);
@@ -78,7 +91,7 @@ public class ClockProvider extends ContentProvider {
         sAlarmsWithInstancesProjection.put(ALARMS_TABLE_NAME + "." + AlarmsColumns.INCREASING_VOLUME,
                 ALARMS_TABLE_NAME + "." + AlarmsColumns.INCREASING_VOLUME);
         sAlarmsWithInstancesProjection.put(INSTANCES_TABLE_NAME + "."
-                + InstancesColumns.ALARM_STATE,
+                        + InstancesColumns.ALARM_STATE,
                 INSTANCES_TABLE_NAME + "." + InstancesColumns.ALARM_STATE);
         sAlarmsWithInstancesProjection.put(INSTANCES_TABLE_NAME + "." + InstancesColumns._ID,
                 INSTANCES_TABLE_NAME + "." + InstancesColumns._ID);
@@ -98,22 +111,6 @@ public class ClockProvider extends ContentProvider {
                 INSTANCES_TABLE_NAME + "." + InstancesColumns.VIBRATE);
     }
 
-    private static final String ALARM_JOIN_INSTANCE_TABLE_STATEMENT =
-            ALARMS_TABLE_NAME + " LEFT JOIN " + INSTANCES_TABLE_NAME + " ON (" +
-            ALARMS_TABLE_NAME + "." + AlarmsColumns._ID + " = " + InstancesColumns.ALARM_ID + ")";
-
-    private static final String ALARM_JOIN_INSTANCE_WHERE_STATEMENT =
-            INSTANCES_TABLE_NAME + "." + InstancesColumns._ID + " IS NULL OR " +
-            INSTANCES_TABLE_NAME + "." + InstancesColumns._ID + " = (" +
-                    "SELECT " + InstancesColumns._ID +
-                    " FROM " + INSTANCES_TABLE_NAME +
-                    " WHERE " + InstancesColumns.ALARM_ID +
-                    " = " + ALARMS_TABLE_NAME + "." + AlarmsColumns._ID +
-                    " ORDER BY " + InstancesColumns.ALARM_STATE + ", " +
-                    InstancesColumns.YEAR + ", " + InstancesColumns.MONTH + ", " +
-                    InstancesColumns.DAY + " LIMIT 1)";
-
-    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);
     static {
         sURIMatcher.addURI(ClockContract.AUTHORITY, "alarms", ALARMS);
         sURIMatcher.addURI(ClockContract.AUTHORITY, "alarms/#", ALARMS_ID);
@@ -122,6 +119,8 @@ public class ClockProvider extends ContentProvider {
         sURIMatcher.addURI(ClockContract.AUTHORITY, "alarms_with_instances", ALARMS_WITH_INSTANCES);
     }
 
+    private ClockDatabaseHelper mOpenHelper;
+
     public ClockProvider() {
     }
 
@@ -148,7 +147,7 @@ public class ClockProvider extends ContentProvider {
 
     @Override
     public Cursor query(@NonNull Uri uri, String[] projectionIn, String selection,
-            String[] selectionArgs, String sort) {
+                        String[] selectionArgs, String sort) {
         SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
         SQLiteDatabase db = mOpenHelper.getReadableDatabase();
 
diff --git a/src/com/android/deskclock/ringtone/AddCustomRingtoneHolder.java b/app/src/main/java/com/best/deskclock/ringtone/AddCustomRingtoneHolder.java
similarity index 100%
rename from src/com/android/deskclock/ringtone/AddCustomRingtoneHolder.java
rename to app/src/main/java/com/best/deskclock/ringtone/AddCustomRingtoneHolder.java
index c7859445f..4237fa3b3 100644
--- a/src/com/android/deskclock/ringtone/AddCustomRingtoneHolder.java
+++ b/app/src/main/java/com/best/deskclock/ringtone/AddCustomRingtoneHolder.java
@@ -16,12 +16,12 @@
 
 package com.best.deskclock.ringtone;
 
+import static androidx.recyclerview.widget.RecyclerView.NO_ID;
+
 import android.net.Uri;
 
 import com.best.deskclock.ItemAdapter;
 
-import static androidx.recyclerview.widget.RecyclerView.NO_ID;
-
 final class AddCustomRingtoneHolder extends ItemAdapter.ItemHolder<Uri> {
 
     AddCustomRingtoneHolder() {
diff --git a/src/com/android/deskclock/ringtone/AddCustomRingtoneViewHolder.java b/app/src/main/java/com/best/deskclock/ringtone/AddCustomRingtoneViewHolder.java
similarity index 92%
rename from src/com/android/deskclock/ringtone/AddCustomRingtoneViewHolder.java
rename to app/src/main/java/com/best/deskclock/ringtone/AddCustomRingtoneViewHolder.java
index 753666d81..aecdb0168 100644
--- a/src/com/android/deskclock/ringtone/AddCustomRingtoneViewHolder.java
+++ b/app/src/main/java/com/best/deskclock/ringtone/AddCustomRingtoneViewHolder.java
@@ -16,6 +16,8 @@
 
 package com.best.deskclock.ringtone;
 
+import static android.view.View.GONE;
+
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
@@ -25,8 +27,6 @@ import android.widget.TextView;
 import com.best.deskclock.ItemAdapter.ItemViewHolder;
 import com.best.deskclock.R;
 
-import static android.view.View.GONE;
-
 final class AddCustomRingtoneViewHolder extends ItemViewHolder<AddCustomRingtoneHolder>
         implements View.OnClickListener {
 
@@ -40,11 +40,11 @@ final class AddCustomRingtoneViewHolder extends ItemViewHolder<AddCustomRingtone
         final View selectedView = itemView.findViewById(R.id.sound_image_selected);
         selectedView.setVisibility(GONE);
 
-        final TextView nameView = (TextView) itemView.findViewById(R.id.ringtone_name);
+        final TextView nameView = itemView.findViewById(R.id.ringtone_name);
         nameView.setText(itemView.getContext().getString(R.string.add_new_sound));
         nameView.setAlpha(0.63f);
 
-        final ImageView imageView = (ImageView) itemView.findViewById(R.id.ringtone_image);
+        final ImageView imageView = itemView.findViewById(R.id.ringtone_image);
         imageView.setImageResource(R.drawable.ic_add_24dp);
         imageView.setAlpha(0.63f);
     }
diff --git a/src/com/android/deskclock/ringtone/CustomRingtoneHolder.java b/app/src/main/java/com/best/deskclock/ringtone/CustomRingtoneHolder.java
similarity index 100%
rename from src/com/android/deskclock/ringtone/CustomRingtoneHolder.java
rename to app/src/main/java/com/best/deskclock/ringtone/CustomRingtoneHolder.java
diff --git a/src/com/android/deskclock/ringtone/HeaderHolder.java b/app/src/main/java/com/best/deskclock/ringtone/HeaderHolder.java
similarity index 92%
rename from src/com/android/deskclock/ringtone/HeaderHolder.java
rename to app/src/main/java/com/best/deskclock/ringtone/HeaderHolder.java
index 37a4f73bf..4906196d0 100644
--- a/src/com/android/deskclock/ringtone/HeaderHolder.java
+++ b/app/src/main/java/com/best/deskclock/ringtone/HeaderHolder.java
@@ -16,23 +16,26 @@
 
 package com.best.deskclock.ringtone;
 
+import static androidx.recyclerview.widget.RecyclerView.NO_ID;
+
 import android.net.Uri;
+
 import androidx.annotation.StringRes;
 
 import com.best.deskclock.ItemAdapter;
 
-import static androidx.recyclerview.widget.RecyclerView.NO_ID;
-
 final class HeaderHolder extends ItemAdapter.ItemHolder<Uri> {
 
-    private final @StringRes int mTextResId;
+    private final @StringRes
+    int mTextResId;
 
     HeaderHolder(@StringRes int textResId) {
         super(null, NO_ID);
         mTextResId = textResId;
     }
 
-    @StringRes int getTextResId() {
+    @StringRes
+    int getTextResId() {
         return mTextResId;
     }
 
diff --git a/src/com/android/deskclock/ringtone/HeaderViewHolder.java b/app/src/main/java/com/best/deskclock/ringtone/HeaderViewHolder.java
similarity index 95%
rename from src/com/android/deskclock/ringtone/HeaderViewHolder.java
rename to app/src/main/java/com/best/deskclock/ringtone/HeaderViewHolder.java
index ac1328499..3ab0964f4 100644
--- a/src/com/android/deskclock/ringtone/HeaderViewHolder.java
+++ b/app/src/main/java/com/best/deskclock/ringtone/HeaderViewHolder.java
@@ -32,7 +32,7 @@ final class HeaderViewHolder extends ItemAdapter.ItemViewHolder<HeaderHolder> {
 
     private HeaderViewHolder(View itemView) {
         super(itemView);
-        mItemHeader = (TextView) itemView.findViewById(R.id.ringtone_item_header);
+        mItemHeader = itemView.findViewById(R.id.ringtone_item_header);
     }
 
     @Override
diff --git a/src/com/android/deskclock/ringtone/RingtoneHolder.java b/app/src/main/java/com/best/deskclock/ringtone/RingtoneHolder.java
similarity index 73%
rename from src/com/android/deskclock/ringtone/RingtoneHolder.java
rename to app/src/main/java/com/best/deskclock/ringtone/RingtoneHolder.java
index 45e9f3a62..99de23668 100644
--- a/src/com/android/deskclock/ringtone/RingtoneHolder.java
+++ b/app/src/main/java/com/best/deskclock/ringtone/RingtoneHolder.java
@@ -16,14 +16,14 @@
 
 package com.best.deskclock.ringtone;
 
+import static androidx.recyclerview.widget.RecyclerView.NO_ID;
+
 import android.net.Uri;
 
 import com.best.deskclock.ItemAdapter;
 import com.best.deskclock.Utils;
 import com.best.deskclock.data.DataModel;
 
-import static androidx.recyclerview.widget.RecyclerView.NO_ID;
-
 abstract class RingtoneHolder extends ItemAdapter.ItemHolder<Uri> {
 
     private final String mName;
@@ -41,17 +41,37 @@ abstract class RingtoneHolder extends ItemAdapter.ItemHolder<Uri> {
         mHasPermissions = hasPermissions;
     }
 
-    long getId() { return itemId; }
-    boolean hasPermissions() { return mHasPermissions; }
-    Uri getUri() { return item; }
+    long getId() {
+        return itemId;
+    }
+
+    boolean hasPermissions() {
+        return mHasPermissions;
+    }
+
+    Uri getUri() {
+        return item;
+    }
+
+    boolean isSilent() {
+        return Utils.RINGTONE_SILENT.equals(getUri());
+    }
+
+    boolean isSelected() {
+        return mSelected;
+    }
 
-    boolean isSilent() { return Utils.RINGTONE_SILENT.equals(getUri()); }
+    void setSelected(boolean selected) {
+        mSelected = selected;
+    }
 
-    boolean isSelected() { return mSelected; }
-    void setSelected(boolean selected) { mSelected = selected; }
+    boolean isPlaying() {
+        return mPlaying;
+    }
 
-    boolean isPlaying() { return mPlaying; }
-    void setPlaying(boolean playing) { mPlaying = playing; }
+    void setPlaying(boolean playing) {
+        mPlaying = playing;
+    }
 
     String getName() {
         return mName != null ? mName : DataModel.getDataModel().getRingtoneTitle(getUri());
diff --git a/src/com/android/deskclock/ringtone/RingtoneLoader.java b/app/src/main/java/com/best/deskclock/ringtone/RingtoneLoader.java
similarity index 99%
rename from src/com/android/deskclock/ringtone/RingtoneLoader.java
rename to app/src/main/java/com/best/deskclock/ringtone/RingtoneLoader.java
index 90d408f2c..2d8a8fe4a 100644
--- a/src/com/android/deskclock/ringtone/RingtoneLoader.java
+++ b/app/src/main/java/com/best/deskclock/ringtone/RingtoneLoader.java
@@ -16,6 +16,9 @@
 
 package com.best.deskclock.ringtone;
 
+import static android.media.AudioManager.STREAM_ALARM;
+import static com.best.deskclock.Utils.RINGTONE_SILENT;
+
 import android.content.AsyncTaskLoader;
 import android.content.Context;
 import android.database.Cursor;
@@ -32,9 +35,6 @@ import com.best.deskclock.data.DataModel;
 import java.util.ArrayList;
 import java.util.List;
 
-import static android.media.AudioManager.STREAM_ALARM;
-import static com.best.deskclock.Utils.RINGTONE_SILENT;
-
 /**
  * Assembles the list of ItemHolders that back the RecyclerView used to choose a ringtone.
  */
@@ -73,7 +73,7 @@ class RingtoneLoader extends AsyncTaskLoader<List<ItemAdapter.ItemHolder<Uri>>>
             systemRingtoneCursor = ringtoneManager.getCursor();
         } catch (Exception e) {
             LogUtils.e("Could not get system ringtone cursor");
-            systemRingtoneCursor = new MatrixCursor(new String[] {});
+            systemRingtoneCursor = new MatrixCursor(new String[]{});
         }
         final int systemRingtoneCount = systemRingtoneCursor.getCount();
         // item count = # system ringtones + # custom ringtones + 2 headers + Add new music item
diff --git a/src/com/android/deskclock/ringtone/RingtonePickerActivity.java b/app/src/main/java/com/best/deskclock/ringtone/RingtonePickerActivity.java
similarity index 91%
rename from src/com/android/deskclock/ringtone/RingtonePickerActivity.java
rename to app/src/main/java/com/best/deskclock/ringtone/RingtonePickerActivity.java
index c4309bbee..c09acbf81 100644
--- a/src/com/android/deskclock/ringtone/RingtonePickerActivity.java
+++ b/app/src/main/java/com/best/deskclock/ringtone/RingtonePickerActivity.java
@@ -16,6 +16,16 @@
 
 package com.best.deskclock.ringtone;
 
+import static android.content.Intent.FLAG_GRANT_READ_URI_PERMISSION;
+import static android.media.RingtoneManager.TYPE_ALARM;
+import static android.provider.OpenableColumns.DISPLAY_NAME;
+import static com.best.deskclock.ItemAdapter.ItemViewHolder.Factory;
+import static com.best.deskclock.ringtone.AddCustomRingtoneViewHolder.VIEW_TYPE_ADD_NEW;
+import static com.best.deskclock.ringtone.HeaderViewHolder.VIEW_TYPE_ITEM_HEADER;
+import static com.best.deskclock.ringtone.RingtoneViewHolder.VIEW_TYPE_CUSTOM_SOUND;
+import static com.best.deskclock.ringtone.RingtoneViewHolder.VIEW_TYPE_SYSTEM_SOUND;
+
+import android.annotation.SuppressLint;
 import android.app.Dialog;
 import android.app.DialogFragment;
 import android.app.FragmentManager;
@@ -32,14 +42,15 @@ import android.net.Uri;
 import android.os.AsyncTask;
 import android.os.Bundle;
 import android.provider.MediaStore;
+import android.view.LayoutInflater;
+import android.view.Menu;
+import android.view.MenuItem;
+
+import androidx.annotation.NonNull;
 import androidx.annotation.VisibleForTesting;
 import androidx.appcompat.app.AlertDialog;
 import androidx.recyclerview.widget.LinearLayoutManager;
 import androidx.recyclerview.widget.RecyclerView;
-import android.view.LayoutInflater;
-import android.view.Menu;
-import android.view.MenuItem;
-import android.view.View;
 
 import com.best.deskclock.BaseActivity;
 import com.best.deskclock.DropShadowController;
@@ -57,15 +68,6 @@ import com.best.deskclock.provider.Alarm;
 
 import java.util.List;
 
-import static android.content.Intent.FLAG_GRANT_READ_URI_PERMISSION;
-import static android.media.RingtoneManager.TYPE_ALARM;
-import static android.provider.OpenableColumns.DISPLAY_NAME;
-import static com.best.deskclock.ItemAdapter.ItemViewHolder.Factory;
-import static com.best.deskclock.ringtone.AddCustomRingtoneViewHolder.VIEW_TYPE_ADD_NEW;
-import static com.best.deskclock.ringtone.HeaderViewHolder.VIEW_TYPE_ITEM_HEADER;
-import static com.best.deskclock.ringtone.RingtoneViewHolder.VIEW_TYPE_CUSTOM_SOUND;
-import static com.best.deskclock.ringtone.RingtoneViewHolder.VIEW_TYPE_SYSTEM_SOUND;
-
 /**
  * This activity presents a set of ringtones from which the user may select one. The set includes:
  * <ul>
@@ -77,58 +79,85 @@ import static com.best.deskclock.ringtone.RingtoneViewHolder.VIEW_TYPE_SYSTEM_SO
  */
 public class RingtonePickerActivity extends BaseActivity
         implements LoaderManager.LoaderCallbacks<List<ItemAdapter.ItemHolder<Uri>>> {
-
-    /** Key to an extra that defines resource id to the title of this activity. */
+    /**
+     * Key to an extra that defines resource id to the title of this activity.
+     */
     private static final String EXTRA_TITLE = "extra_title";
 
-    /** Key to an extra that identifies the alarm to which the selected ringtone is attached. */
+    /**
+     * Key to an extra that identifies the alarm to which the selected ringtone is attached.
+     */
     private static final String EXTRA_ALARM_ID = "extra_alarm_id";
 
-    /** Key to an extra that identifies the selected ringtone. */
+    /**
+     * Key to an extra that identifies the selected ringtone.
+     */
     private static final String EXTRA_RINGTONE_URI = "extra_ringtone_uri";
 
-    /** Key to an extra that defines the uri representing the default ringtone. */
+    /**
+     * Key to an extra that defines the uri representing the default ringtone.
+     */
     private static final String EXTRA_DEFAULT_RINGTONE_URI = "extra_default_ringtone_uri";
 
-    /** Key to an extra that defines the name of the default ringtone. */
+    /**
+     * Key to an extra that defines the name of the default ringtone.
+     */
     private static final String EXTRA_DEFAULT_RINGTONE_NAME = "extra_default_ringtone_name";
 
-    /** Key to an instance state value indicating if the selected ringtone is currently playing. */
+    /**
+     * Key to an instance state value indicating if the selected ringtone is currently playing.
+     */
     private static final String STATE_KEY_PLAYING = "extra_is_playing";
 
-    /** The controller that shows the drop shadow when content is not scrolled to the top. */
+    /**
+     * The controller that shows the drop shadow when content is not scrolled to the top.
+     */
     private DropShadowController mDropShadowController;
 
-    /** Generates the items in the activity context menu. */
+    /**
+     * Generates the items in the activity context menu.
+     */
     private OptionsMenuManager mOptionsMenuManager;
 
-    /** Displays a set of selectable ringtones. */
-    private RecyclerView mRecyclerView;
-
-    /** Stores the set of ItemHolders that wrap the selectable ringtones. */
+    /**
+     * Stores the set of ItemHolders that wrap the selectable ringtones.
+     */
     private ItemAdapter<ItemAdapter.ItemHolder<Uri>> mRingtoneAdapter;
 
-    /** The title of the default ringtone. */
+    /**
+     * The title of the default ringtone.
+     */
     private String mDefaultRingtoneTitle;
 
-    /** The uri of the default ringtone. */
+    /**
+     * The uri of the default ringtone.
+     */
     private Uri mDefaultRingtoneUri;
 
-    /** The uri of the ringtone to select after data is loaded. */
+    /**
+     * The uri of the ringtone to select after data is loaded.
+     */
     private Uri mSelectedRingtoneUri;
 
-    /** {@code true} indicates the {@link #mSelectedRingtoneUri} must be played after data load. */
+    /**
+     * {@code true} indicates the {@link #mSelectedRingtoneUri} must be played after data load.
+     */
     private boolean mIsPlaying;
 
-    /** Identifies the alarm to receive the selected ringtone; -1 indicates there is no alarm. */
+    /**
+     * Identifies the alarm to receive the selected ringtone; -1 indicates there is no alarm.
+     */
     private long mAlarmId;
 
-    /** The location of the custom ringtone to be removed. */
+    /**
+     * The location of the custom ringtone to be removed.
+     */
     private int mIndexOfRingtoneToRemove = RecyclerView.NO_POSITION;
+    private RecyclerView mRecyclerView;
 
     /**
      * @return an intent that launches the ringtone picker to edit the ringtone of the given
-     *      {@code alarm}
+     * {@code alarm}
      */
     public static Intent createAlarmRingtonePickerIntent(Context context, Alarm alarm) {
         return new Intent(context, RingtonePickerActivity.class)
@@ -153,6 +182,13 @@ public class RingtonePickerActivity extends BaseActivity
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
+        DataModel.ThemeButtonBehavior mThemeBehavior = DataModel.getDataModel().getThemeButtonBehavior();
+        if (mThemeBehavior == DataModel.ThemeButtonBehavior.DARK) {
+            getTheme().applyStyle(R.style.Theme_DeskClock_Actionbar_Dark, true);
+        }
+        if (mThemeBehavior == DataModel.ThemeButtonBehavior.LIGHT) {
+            getTheme().applyStyle(R.style.Theme_DeskClock_Actionbar_Light, true);
+        }
         super.onCreate(savedInstanceState);
         setContentView(R.layout.ringtone_picker);
         setVolumeControlStream(AudioManager.STREAM_ALARM);
@@ -190,6 +226,9 @@ public class RingtonePickerActivity extends BaseActivity
                 .withViewTypes(ringtoneFactory, listener, VIEW_TYPE_SYSTEM_SOUND)
                 .withViewTypes(ringtoneFactory, listener, VIEW_TYPE_CUSTOM_SOUND);
 
+        /**
+         * Displays a set of selectable ringtones.
+         */
         mRecyclerView = (RecyclerView) findViewById(R.id.ringtone_content);
         mRecyclerView.setLayoutManager(new LinearLayoutManager(context));
         mRecyclerView.setAdapter(mRingtoneAdapter);
@@ -197,7 +236,7 @@ public class RingtonePickerActivity extends BaseActivity
 
         mRecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() {
             @Override
-            public void onScrollStateChanged(RecyclerView recyclerView, int newState) {
+            public void onScrollStateChanged(@NonNull RecyclerView recyclerView, int newState) {
                 if (mIndexOfRingtoneToRemove != RecyclerView.NO_POSITION) {
                     closeContextMenu();
                 }
@@ -215,15 +254,11 @@ public class RingtonePickerActivity extends BaseActivity
     @Override
     protected void onResume() {
         super.onResume();
-
-        final View dropShadow = findViewById(R.id.drop_shadow);
-        mDropShadowController = new DropShadowController(dropShadow, mRecyclerView);
     }
 
+    @SuppressLint("StaticFieldLeak")
     @Override
     protected void onPause() {
-        mDropShadowController.stop();
-        mDropShadowController = null;
 
         if (mSelectedRingtoneUri != null) {
             if (mAlarmId != -1) {
@@ -268,7 +303,7 @@ public class RingtonePickerActivity extends BaseActivity
     }
 
     @Override
-    protected void onSaveInstanceState(Bundle outState) {
+    protected void onSaveInstanceState(@NonNull Bundle outState) {
         super.onSaveInstanceState(outState);
 
         outState.putBoolean(STATE_KEY_PLAYING, mIsPlaying);
@@ -300,7 +335,7 @@ public class RingtonePickerActivity extends BaseActivity
 
     @Override
     public void onLoadFinished(Loader<List<ItemAdapter.ItemHolder<Uri>>> loader,
-            List<ItemAdapter.ItemHolder<Uri>> itemHolders) {
+                               List<ItemAdapter.ItemHolder<Uri>> itemHolders) {
         // Update the adapter with fresh data.
         mRingtoneAdapter.setItems(itemHolders);
 
@@ -324,10 +359,12 @@ public class RingtonePickerActivity extends BaseActivity
     }
 
     @Override
-    public void onLoaderReset(Loader<List<ItemAdapter.ItemHolder<Uri>>> loader) {}
+    public void onLoaderReset(Loader<List<ItemAdapter.ItemHolder<Uri>>> loader) {
+    }
 
     @Override
     protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
         if (resultCode != RESULT_OK) {
             return;
         }
@@ -374,7 +411,7 @@ public class RingtonePickerActivity extends BaseActivity
         return null;
     }
 
-    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+    @VisibleForTesting()
     RingtoneHolder getSelectedRingtoneHolder() {
         return getRingtoneHolder(mSelectedRingtoneUri);
     }
@@ -400,7 +437,7 @@ public class RingtonePickerActivity extends BaseActivity
     /**
      * @param ringtone the ringtone to stop playing
      * @param deselect {@code true} indicates the ringtone should also be deselected;
-     *      {@code false} indicates its selection state should remain unchanged
+     *                 {@code false} indicates its selection state should remain unchanged
      */
     private void stopPlayingRingtone(RingtoneHolder ringtone, boolean deselect) {
         if (ringtone == null) {
diff --git a/src/com/android/deskclock/ringtone/RingtoneViewHolder.java b/app/src/main/java/com/best/deskclock/ringtone/RingtoneViewHolder.java
similarity index 94%
rename from src/com/android/deskclock/ringtone/RingtoneViewHolder.java
rename to app/src/main/java/com/best/deskclock/ringtone/RingtoneViewHolder.java
index 567ca2a75..f83095fa8 100644
--- a/src/com/android/deskclock/ringtone/RingtoneViewHolder.java
+++ b/app/src/main/java/com/best/deskclock/ringtone/RingtoneViewHolder.java
@@ -16,8 +16,12 @@
 
 package com.best.deskclock.ringtone;
 
+import static android.view.View.GONE;
+import static android.view.View.OnClickListener;
+import static android.view.View.OnCreateContextMenuListener;
+import static android.view.View.VISIBLE;
+
 import android.graphics.PorterDuff;
-import androidx.core.content.ContextCompat;
 import android.view.ContextMenu;
 import android.view.LayoutInflater;
 import android.view.Menu;
@@ -26,17 +30,14 @@ import android.view.ViewGroup;
 import android.widget.ImageView;
 import android.widget.TextView;
 
+import androidx.core.content.ContextCompat;
+
 import com.best.deskclock.AnimatorUtils;
 import com.best.deskclock.ItemAdapter;
 import com.best.deskclock.R;
 import com.best.deskclock.ThemeUtils;
 import com.best.deskclock.Utils;
 
-import static android.view.View.GONE;
-import static android.view.View.OnClickListener;
-import static android.view.View.OnCreateContextMenuListener;
-import static android.view.View.VISIBLE;
-
 final class RingtoneViewHolder extends ItemAdapter.ItemViewHolder<RingtoneHolder>
         implements OnClickListener, OnCreateContextMenuListener {
 
@@ -55,8 +56,8 @@ final class RingtoneViewHolder extends ItemAdapter.ItemViewHolder<RingtoneHolder
         itemView.setOnClickListener(this);
 
         mSelectedView = itemView.findViewById(R.id.sound_image_selected);
-        mNameView = (TextView) itemView.findViewById(R.id.ringtone_name);
-        mImageView = (ImageView) itemView.findViewById(R.id.ringtone_image);
+        mNameView = itemView.findViewById(R.id.ringtone_name);
+        mImageView = itemView.findViewById(R.id.ringtone_image);
     }
 
     @Override
@@ -72,7 +73,7 @@ final class RingtoneViewHolder extends ItemAdapter.ItemViewHolder<RingtoneHolder
             if (!itemHolder.hasPermissions()) {
                 mImageView.setImageResource(R.drawable.ic_ringtone_not_found);
                 final int colorAccent = ThemeUtils.resolveColor(itemView.getContext(),
-                        R.attr.colorAccent);
+                        androidx.appcompat.R.attr.colorAccent);
                 mImageView.setColorFilter(colorAccent, PorterDuff.Mode.SRC_ATOP);
             } else {
                 mImageView.setImageResource(R.drawable.ic_placeholder_album_artwork);
@@ -105,7 +106,7 @@ final class RingtoneViewHolder extends ItemAdapter.ItemViewHolder<RingtoneHolder
 
     @Override
     public void onCreateContextMenu(ContextMenu contextMenu, View view,
-            ContextMenu.ContextMenuInfo contextMenuInfo) {
+                                    ContextMenu.ContextMenuInfo contextMenuInfo) {
         notifyItemClicked(RingtoneViewHolder.CLICK_LONG_PRESS);
         contextMenu.add(Menu.NONE, 0, Menu.NONE, R.string.remove_sound);
     }
diff --git a/src/com/android/deskclock/ringtone/SystemRingtoneHolder.java b/app/src/main/java/com/best/deskclock/ringtone/SystemRingtoneHolder.java
similarity index 100%
rename from src/com/android/deskclock/ringtone/SystemRingtoneHolder.java
rename to app/src/main/java/com/best/deskclock/ringtone/SystemRingtoneHolder.java
diff --git a/src/com/android/deskclock/settings/AlarmVolumePreference.java b/app/src/main/java/com/best/deskclock/settings/AlarmVolumePreference.java
similarity index 97%
rename from src/com/android/deskclock/settings/AlarmVolumePreference.java
rename to app/src/main/java/com/best/deskclock/settings/AlarmVolumePreference.java
index 8af34cde7..03bf43001 100644
--- a/src/com/android/deskclock/settings/AlarmVolumePreference.java
+++ b/app/src/main/java/com/best/deskclock/settings/AlarmVolumePreference.java
@@ -16,6 +16,10 @@
 
 package com.best.deskclock.settings;
 
+import static android.content.Context.AUDIO_SERVICE;
+import static android.content.Context.NOTIFICATION_SERVICE;
+import static android.media.AudioManager.STREAM_ALARM;
+
 import android.annotation.TargetApi;
 import android.app.NotificationManager;
 import android.content.Context;
@@ -23,22 +27,20 @@ import android.database.ContentObserver;
 import android.media.AudioManager;
 import android.os.Build;
 import android.provider.Settings;
-import androidx.preference.Preference;
-import androidx.preference.PreferenceViewHolder;
 import android.util.AttributeSet;
 import android.view.View;
 import android.widget.ImageView;
 import android.widget.SeekBar;
 
+import androidx.annotation.NonNull;
+import androidx.preference.Preference;
+import androidx.preference.PreferenceViewHolder;
+
 import com.best.deskclock.R;
 import com.best.deskclock.RingtonePreviewKlaxon;
 import com.best.deskclock.Utils;
 import com.best.deskclock.data.DataModel;
 
-import static android.content.Context.AUDIO_SERVICE;
-import static android.content.Context.NOTIFICATION_SERVICE;
-import static android.media.AudioManager.STREAM_ALARM;
-
 public class AlarmVolumePreference extends Preference {
 
     private static final long ALARM_PREVIEW_DURATION_MS = 2000;
@@ -52,7 +54,7 @@ public class AlarmVolumePreference extends Preference {
     }
 
     @Override
-    public void onBindViewHolder(PreferenceViewHolder holder) {
+    public void onBindViewHolder(@NonNull PreferenceViewHolder holder) {
         super.onBindViewHolder(holder);
 
         final Context context = getContext();
diff --git a/src/com/android/deskclock/settings/ScreensaverSettingsActivity.java b/app/src/main/java/com/best/deskclock/settings/ScreensaverSettingsActivity.java
similarity index 80%
rename from src/com/android/deskclock/settings/ScreensaverSettingsActivity.java
rename to app/src/main/java/com/best/deskclock/settings/ScreensaverSettingsActivity.java
index ad608f9aa..953bf4bf2 100644
--- a/src/com/android/deskclock/settings/ScreensaverSettingsActivity.java
+++ b/app/src/main/java/com/best/deskclock/settings/ScreensaverSettingsActivity.java
@@ -22,34 +22,41 @@ import android.os.Bundle;
 import android.preference.ListPreference;
 import android.preference.Preference;
 import android.preference.PreferenceFragment;
-import androidx.appcompat.app.AppCompatActivity;
 import android.view.MenuItem;
 
+import androidx.appcompat.app.AppCompatActivity;
+
 import com.best.deskclock.R;
 import com.best.deskclock.Utils;
+import com.best.deskclock.data.DataModel;
+import com.best.deskclock.data.DataModel.ThemeButtonBehavior;
 
 /**
  * Settings for Clock screen saver
  */
 public final class ScreensaverSettingsActivity extends AppCompatActivity {
-
     public static final String KEY_CLOCK_STYLE = "screensaver_clock_style";
     public static final String KEY_NIGHT_MODE = "screensaver_night_mode";
+    private ThemeButtonBehavior mThemeBehavior;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
+        mThemeBehavior = DataModel.getDataModel().getThemeButtonBehavior();
+        if (mThemeBehavior == DataModel.ThemeButtonBehavior.DARK) {
+            getTheme().applyStyle(R.style.Theme_DeskClock_Actionbar_Dark, true);
+        }
+        if (mThemeBehavior == DataModel.ThemeButtonBehavior.LIGHT) {
+            getTheme().applyStyle(R.style.Theme_DeskClock_Actionbar_Light, true);
+        }
         super.onCreate(savedInstanceState);
         setContentView(R.layout.screensaver_settings);
     }
 
     @Override
-    public boolean onOptionsItemSelected (MenuItem item) {
-        switch (item.getItemId()) {
-            case android.R.id.home:
-                finish();
-                return true;
-            default:
-                break;
+    public boolean onOptionsItemSelected(MenuItem item) {
+        if (item.getItemId() == android.R.id.home) {
+            finish();
+            return true;
         }
         return super.onOptionsItemSelected(item);
     }
diff --git a/src/com/android/deskclock/settings/SettingsActivity.java b/app/src/main/java/com/best/deskclock/settings/SettingsActivity.java
similarity index 76%
rename from src/com/android/deskclock/settings/SettingsActivity.java
rename to app/src/main/java/com/best/deskclock/settings/SettingsActivity.java
index 122b59226..31e0bfae1 100644
--- a/src/com/android/deskclock/settings/SettingsActivity.java
+++ b/app/src/main/java/com/best/deskclock/settings/SettingsActivity.java
@@ -23,35 +23,38 @@ import android.hardware.SensorManager;
 import android.os.Bundle;
 import android.os.Vibrator;
 import android.provider.Settings;
+import android.view.Menu;
+import android.view.MenuItem;
+
+import androidx.annotation.NonNull;
+import androidx.preference.DropDownPreference;
 import androidx.preference.ListPreference;
 import androidx.preference.ListPreferenceDialogFragmentCompat;
 import androidx.preference.Preference;
 import androidx.preference.PreferenceDialogFragmentCompat;
 import androidx.preference.PreferenceFragmentCompat;
 import androidx.preference.TwoStatePreference;
-import android.view.Menu;
-import android.view.MenuItem;
-import android.view.View;
 
 import com.best.deskclock.BaseActivity;
-import com.best.deskclock.DropShadowController;
 import com.best.deskclock.R;
 import com.best.deskclock.Utils;
 import com.best.deskclock.actionbarmenu.MenuItemControllerFactory;
 import com.best.deskclock.actionbarmenu.NavUpMenuItemController;
 import com.best.deskclock.actionbarmenu.OptionsMenuManager;
 import com.best.deskclock.data.DataModel;
+import com.best.deskclock.data.DataModel.ThemeButtonBehavior;
 import com.best.deskclock.data.TimeZones;
 import com.best.deskclock.data.Weekdays;
 import com.best.deskclock.ringtone.RingtonePickerActivity;
 
 import java.util.List;
+import java.util.Objects;
 
 /**
  * Settings for the Alarm Clock.
  */
 public final class SettingsActivity extends BaseActivity {
-
+    public static final String KEY_THEME = "key_theme";
     public static final String KEY_ALARM_SNOOZE = "snooze_duration";
     public static final String KEY_ALARM_CRESCENDO = "alarm_crescendo_duration";
     public static final String KEY_TIMER_CRESCENDO = "timer_crescendo_duration";
@@ -68,28 +71,35 @@ public final class SettingsActivity extends BaseActivity {
     public static final String KEY_WEEK_START = "week_start";
     public static final String KEY_FLIP_ACTION = "flip_action";
     public static final String KEY_SHAKE_ACTION = "shake_action";
-
     public static final String DEFAULT_VOLUME_BEHAVIOR = "0";
     public static final String VOLUME_BEHAVIOR_SNOOZE = "1";
     public static final String VOLUME_BEHAVIOR_DISMISS = "2";
-
+    public static final String SYSTEM_THEME_BEHAVIOR = "0";
+    public static final String THEME_BEHAVIOR_DARK = "1";
+    public static final String THEME_BEHAVIOR_LIGHT = "2";
     public static final String DEFAULT_POWER_BEHAVIOR = "0";
     public static final String POWER_BEHAVIOR_SNOOZE = "1";
     public static final String POWER_BEHAVIOR_DISMISS = "2";
-    
     public static final String PREFS_FRAGMENT_TAG = "prefs_fragment";
     public static final String PREFERENCE_DIALOG_FRAGMENT_TAG = "preference_dialog";
-
     private final OptionsMenuManager mOptionsMenuManager = new OptionsMenuManager();
+    private ThemeButtonBehavior mThemeBehavior;
 
     /**
      * The controller that shows the drop shadow when content is not scrolled to the top.
      */
-    private DropShadowController mDropShadowController;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
+        mThemeBehavior = DataModel.getDataModel().getThemeButtonBehavior();
+        if (mThemeBehavior == DataModel.ThemeButtonBehavior.DARK) {
+            getTheme().applyStyle(R.style.Theme_DeskClock_Actionbar_Dark, true);
+        }
+        if (mThemeBehavior == DataModel.ThemeButtonBehavior.LIGHT) {
+            getTheme().applyStyle(R.style.Theme_DeskClock_Actionbar_Light, true);
+        }
         super.onCreate(savedInstanceState);
+
         setContentView(R.layout.settings);
 
         mOptionsMenuManager.addMenuItemController(new NavUpMenuItemController(this))
@@ -109,15 +119,11 @@ public final class SettingsActivity extends BaseActivity {
     protected void onResume() {
         super.onResume();
 
-        final View dropShadow = findViewById(R.id.drop_shadow);
-        final PrefsFragment fragment =
-                (PrefsFragment) getSupportFragmentManager().findFragmentById(R.id.main);
-        mDropShadowController = new DropShadowController(dropShadow, fragment.getListView());
+        getSupportFragmentManager().findFragmentById(R.id.main);
     }
 
     @Override
     protected void onPause() {
-        mDropShadowController.stop();
         super.onPause();
     }
 
@@ -148,7 +154,7 @@ public final class SettingsActivity extends BaseActivity {
             getPreferenceManager().setStorageDeviceProtected();
             addPreferencesFromResource(R.xml.settings);
             final Preference timerVibrate = findPreference(KEY_TIMER_VIBRATE);
-            final boolean hasVibrator = ((Vibrator) timerVibrate.getContext()
+            final boolean hasVibrator = ((Vibrator) Objects.requireNonNull(timerVibrate).getContext()
                     .getSystemService(VIBRATOR_SERVICE)).hasVibrator();
             timerVibrate.setVisible(hasVibrator);
             loadTimeZoneList();
@@ -159,7 +165,7 @@ public final class SettingsActivity extends BaseActivity {
             super.onActivityCreated(savedInstanceState);
 
             // By default, do not recreate the DeskClock activity
-            getActivity().setResult(RESULT_CANCELED);
+            requireActivity().setResult(RESULT_CANCELED);
         }
 
         @Override
@@ -171,6 +177,7 @@ public final class SettingsActivity extends BaseActivity {
         @Override
         public boolean onPreferenceChange(Preference pref, Object newValue) {
             switch (pref.getKey()) {
+                case KEY_THEME:
                 case KEY_ALARM_CRESCENDO:
                 case KEY_HOME_TZ:
                 case KEY_ALARM_SNOOZE:
@@ -183,9 +190,9 @@ public final class SettingsActivity extends BaseActivity {
                 case KEY_WEEK_START:
                 case KEY_VOLUME_BUTTONS:
                 case KEY_FLIP_ACTION:
-                case KEY_POWER_BUTTONS:  
+                case KEY_POWER_BUTTONS:
                 case KEY_SHAKE_ACTION:
-                    final SimpleMenuPreference simpleMenuPreference = (SimpleMenuPreference) pref;
+                    final DropDownPreference simpleMenuPreference = (DropDownPreference) pref;
                     final int i = simpleMenuPreference.findIndexOfValue((String) newValue);
                     pref.setSummary(simpleMenuPreference.getEntries()[i]);
                     break;
@@ -199,7 +206,7 @@ public final class SettingsActivity extends BaseActivity {
                 case KEY_AUTO_HOME_CLOCK:
                     final boolean autoHomeClockEnabled = ((TwoStatePreference) pref).isChecked();
                     final Preference homeTimeZonePref = findPreference(KEY_HOME_TZ);
-                    homeTimeZonePref.setEnabled(!autoHomeClockEnabled);
+                    Objects.requireNonNull(homeTimeZonePref).setEnabled(!autoHomeClockEnabled);
                     break;
                 case KEY_TIMER_VIBRATE:
                     final TwoStatePreference timerVibratePref = (TwoStatePreference) pref;
@@ -210,12 +217,13 @@ public final class SettingsActivity extends BaseActivity {
                     break;
             }
             // Set result so DeskClock knows to refresh itself
-            getActivity().setResult(RESULT_OK);
+            requireActivity().setResult(RESULT_OK);
             return true;
         }
 
+
         @Override
-        public boolean onPreferenceClick(Preference pref) {
+        public boolean onPreferenceClick(@NonNull Preference pref) {
             final Context context = getActivity();
             if (context == null) {
                 return false;
@@ -236,7 +244,7 @@ public final class SettingsActivity extends BaseActivity {
         }
 
         @Override
-        public void onDisplayPreferenceDialog(Preference preference) {
+        public void onDisplayPreferenceDialog(@NonNull Preference preference) {
             // Only single-selection lists are currently supported.
             final PreferenceDialogFragmentCompat f;
             if (preference instanceof ListPreference) {
@@ -249,7 +257,7 @@ public final class SettingsActivity extends BaseActivity {
 
         private void showDialog(PreferenceDialogFragmentCompat fragment) {
             // Don't show dialog if one is already shown.
-            if (getFragmentManager().findFragmentByTag(PREFERENCE_DIALOG_FRAGMENT_TAG) != null) {
+            if (requireFragmentManager().findFragmentByTag(PREFERENCE_DIALOG_FRAGMENT_TAG) != null) {
                 return;
             }
             // Always set the target fragment, this is required by PreferenceDialogFragment
@@ -265,8 +273,8 @@ public final class SettingsActivity extends BaseActivity {
          */
         private void loadTimeZoneList() {
             final TimeZones timezones = DataModel.getDataModel().getTimeZones();
-            final ListPreference homeTimezonePref = (ListPreference) findPreference(KEY_HOME_TZ);
-            homeTimezonePref.setEntryValues(timezones.getTimeZoneIds());
+            final ListPreference homeTimezonePref = findPreference(KEY_HOME_TZ);
+            Objects.requireNonNull(homeTimezonePref).setEntryValues(timezones.getTimeZoneIds());
             homeTimezonePref.setEntries(timezones.getTimeZoneNames());
             homeTimezonePref.setSummary(homeTimezonePref.getEntry());
             homeTimezonePref.setOnPreferenceChangeListener(this);
@@ -274,65 +282,65 @@ public final class SettingsActivity extends BaseActivity {
 
         private void refresh() {
             final ListPreference autoSilencePref =
-                    (ListPreference) findPreference(KEY_AUTO_SILENCE);
-            String delay = autoSilencePref.getValue();
+                    findPreference(KEY_AUTO_SILENCE);
+            String delay = Objects.requireNonNull(autoSilencePref).getValue();
             updateAutoSnoozeSummary(autoSilencePref, delay);
             autoSilencePref.setOnPreferenceChangeListener(this);
 
-            final SimpleMenuPreference clockStylePref = (SimpleMenuPreference)
-                    findPreference(KEY_CLOCK_STYLE);
-            clockStylePref.setSummary(clockStylePref.getEntry());
+            final DropDownPreference clockStylePref = findPreference(KEY_CLOCK_STYLE);
+            Objects.requireNonNull(clockStylePref).setSummary(clockStylePref.getEntry());
             clockStylePref.setOnPreferenceChangeListener(this);
 
-            final SimpleMenuPreference volumeButtonsPref = (SimpleMenuPreference)
-                    findPreference(KEY_VOLUME_BUTTONS);
-            volumeButtonsPref.setSummary(volumeButtonsPref.getEntry());
+            final DropDownPreference volumeButtonsPref = findPreference(KEY_VOLUME_BUTTONS);
+            Objects.requireNonNull(volumeButtonsPref).setSummary(volumeButtonsPref.getEntry());
             volumeButtonsPref.setOnPreferenceChangeListener(this);
 
-            final SimpleMenuPreference powerButtonsPref = (SimpleMenuPreference)
-                    findPreference(KEY_POWER_BUTTONS);
-            powerButtonsPref.setSummary(powerButtonsPref.getEntry());
+            final DropDownPreference themeButtonsPref = findPreference(KEY_THEME);
+            Objects.requireNonNull(themeButtonsPref).setSummary(themeButtonsPref.getEntry());
+            themeButtonsPref.setOnPreferenceChangeListener(this);
+
+            final DropDownPreference powerButtonsPref = findPreference(KEY_POWER_BUTTONS);
+            Objects.requireNonNull(powerButtonsPref).setSummary(powerButtonsPref.getEntry());
             powerButtonsPref.setOnPreferenceChangeListener(this);
 
             final Preference clockSecondsPref = findPreference(KEY_CLOCK_DISPLAY_SECONDS);
-            clockSecondsPref.setOnPreferenceChangeListener(this);
+            Objects.requireNonNull(clockSecondsPref).setOnPreferenceChangeListener(this);
 
             final Preference autoHomeClockPref = findPreference(KEY_AUTO_HOME_CLOCK);
             final boolean autoHomeClockEnabled =
-                    ((TwoStatePreference) autoHomeClockPref).isChecked();
+                    ((TwoStatePreference) Objects.requireNonNull(autoHomeClockPref)).isChecked();
             autoHomeClockPref.setOnPreferenceChangeListener(this);
 
-            final ListPreference homeTimezonePref = (ListPreference) findPreference(KEY_HOME_TZ);
-            homeTimezonePref.setEnabled(autoHomeClockEnabled);
+            final ListPreference homeTimezonePref = findPreference(KEY_HOME_TZ);
+            Objects.requireNonNull(homeTimezonePref).setEnabled(autoHomeClockEnabled);
             refreshListPreference(homeTimezonePref);
 
-            refreshListPreference((ListPreference) findPreference(KEY_ALARM_CRESCENDO));
-            refreshListPreference((ListPreference) findPreference(KEY_TIMER_CRESCENDO));
-            refreshListPreference((ListPreference) findPreference(KEY_ALARM_SNOOZE));
+            refreshListPreference(Objects.requireNonNull(findPreference(KEY_ALARM_CRESCENDO)));
+            refreshListPreference(Objects.requireNonNull(findPreference(KEY_TIMER_CRESCENDO)));
+            refreshListPreference(Objects.requireNonNull(findPreference(KEY_ALARM_SNOOZE)));
 
             final Preference dateAndTimeSetting = findPreference(KEY_DATE_TIME);
-            dateAndTimeSetting.setOnPreferenceClickListener(this);
+            Objects.requireNonNull(dateAndTimeSetting).setOnPreferenceClickListener(this);
 
-            final SimpleMenuPreference weekStartPref = (SimpleMenuPreference)
-                    findPreference(KEY_WEEK_START);
+            final DropDownPreference weekStartPref = findPreference(KEY_WEEK_START);
             // Set the default value programmatically
             final Weekdays.Order weekdayOrder = DataModel.getDataModel().getWeekdayOrder();
             final Integer firstDay = weekdayOrder.getCalendarDays().get(0);
             final String value = String.valueOf(firstDay);
-            final int idx = weekStartPref.findIndexOfValue(value);
+            final int idx = Objects.requireNonNull(weekStartPref).findIndexOfValue(value);
             weekStartPref.setValueIndex(idx);
             weekStartPref.setSummary(weekStartPref.getEntries()[idx]);
             weekStartPref.setOnPreferenceChangeListener(this);
 
             final Preference timerRingtonePref = findPreference(KEY_TIMER_RINGTONE);
-            timerRingtonePref.setOnPreferenceClickListener(this);
+            Objects.requireNonNull(timerRingtonePref).setOnPreferenceClickListener(this);
             timerRingtonePref.setSummary(DataModel.getDataModel().getTimerRingtoneTitle());
 
             SensorManager sensorManager = (SensorManager)
-                    getActivity().getSystemService(Context.SENSOR_SERVICE);
+                    requireActivity().getSystemService(Context.SENSOR_SERVICE);
 
-            final SimpleMenuPreference flipActionPref =
-                    (SimpleMenuPreference) findPreference(KEY_FLIP_ACTION);
+            final DropDownPreference flipActionPref =
+                    findPreference(KEY_FLIP_ACTION);
             if (flipActionPref != null) {
                 List<Sensor> sensorList = sensorManager.getSensorList(Sensor.TYPE_ORIENTATION);
                 if (sensorList.size() < 1) { // This will be true if no orientation sensor
@@ -343,8 +351,8 @@ public final class SettingsActivity extends BaseActivity {
                 }
             }
 
-            final SimpleMenuPreference shakeActionPref =
-                    (SimpleMenuPreference) findPreference(KEY_SHAKE_ACTION);
+            final DropDownPreference shakeActionPref =
+                    findPreference(KEY_SHAKE_ACTION);
             if (shakeActionPref != null) {
                 List<Sensor> sensorList = sensorManager.getSensorList(Sensor.TYPE_ACCELEROMETER);
                 if (sensorList.size() < 1) { // This will be true if no accelerometer sensor
@@ -366,7 +374,7 @@ public final class SettingsActivity extends BaseActivity {
             if (i == -1) {
                 listPref.setSummary(R.string.auto_silence_never);
             } else {
-                listPref.setSummary(Utils.getNumberFormattedQuantityString(getActivity(),
+                listPref.setSummary(Utils.getNumberFormattedQuantityString(requireActivity(),
                         R.plurals.auto_silence_summary, i));
             }
         }
diff --git a/src/com/android/deskclock/settings/SimpleMenuPreference.java b/app/src/main/java/com/best/deskclock/settings/SimpleMenuPreference.java
similarity index 92%
rename from src/com/android/deskclock/settings/SimpleMenuPreference.java
rename to app/src/main/java/com/best/deskclock/settings/SimpleMenuPreference.java
index 4c2d3202f..c066ec485 100644
--- a/src/com/android/deskclock/settings/SimpleMenuPreference.java
+++ b/app/src/main/java/com/best/deskclock/settings/SimpleMenuPreference.java
@@ -17,14 +17,15 @@
 package com.best.deskclock.settings;
 
 import android.content.Context;
-import androidx.annotation.NonNull;
-import androidx.core.content.ContextCompat;
-import androidx.preference.DropDownPreference;
 import android.util.AttributeSet;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ArrayAdapter;
 
+import androidx.annotation.NonNull;
+import androidx.core.content.ContextCompat;
+import androidx.preference.DropDownPreference;
+
 import com.best.deskclock.R;
 import com.best.deskclock.Utils;
 
@@ -41,7 +42,7 @@ public class SimpleMenuPreference extends DropDownPreference {
     }
 
     public SimpleMenuPreference(Context context, AttributeSet attrs) {
-        this(context, attrs, R.attr.dropdownPreferenceStyle);
+        this(context, attrs, androidx.preference.R.attr.dropdownPreferenceStyle);
     }
 
     public SimpleMenuPreference(Context context, AttributeSet attrs, int defStyle) {
@@ -49,18 +50,12 @@ public class SimpleMenuPreference extends DropDownPreference {
     }
 
     public SimpleMenuPreference(Context context, AttributeSet attrs, int defStyleAttr,
-            int defStyleRes) {
+                                int defStyleRes) {
         super(context, attrs, defStyleAttr, defStyleRes);
     }
 
-    @Override
-    protected ArrayAdapter createAdapter() {
-        mAdapter = new SimpleMenuAdapter(getContext(), R.layout.simple_menu_dropdown_item);
-        return mAdapter;
-    }
-
     private static void restoreOriginalOrder(CharSequence[] array,
-            int lastSelectedOriginalPosition) {
+                                             int lastSelectedOriginalPosition) {
         final CharSequence item = array[0];
         System.arraycopy(array, 1, array, 0, lastSelectedOriginalPosition);
         array[lastSelectedOriginalPosition] = item;
@@ -73,13 +68,20 @@ public class SimpleMenuPreference extends DropDownPreference {
     }
 
     private static void setSelectedPosition(CharSequence[] array, int lastSelectedOriginalPosition,
-            int position) {
+                                            int position) {
         final CharSequence item = array[position];
         restoreOriginalOrder(array, lastSelectedOriginalPosition);
         final int originalPosition = Utils.indexOf(array, item);
         swapSelectedToFront(array, originalPosition);
     }
 
+    @NonNull
+    @Override
+    protected ArrayAdapter createAdapter() {
+        mAdapter = new SimpleMenuAdapter(getContext(), R.layout.simple_menu_dropdown_item);
+        return mAdapter;
+    }
+
     @Override
     public void setSummary(CharSequence summary) {
         final CharSequence[] entries = getEntries();
@@ -96,7 +98,9 @@ public class SimpleMenuPreference extends DropDownPreference {
 
     private final static class SimpleMenuAdapter extends ArrayAdapter<CharSequence> {
 
-        /** The original position of the last selected element */
+        /**
+         * The original position of the last selected element
+         */
         private int mLastSelectedOriginalPosition = 0;
 
         SimpleMenuAdapter(Context context, int resource) {
diff --git a/src/com/android/deskclock/stopwatch/LapsAdapter.java b/app/src/main/java/com/best/deskclock/stopwatch/LapsAdapter.java
similarity index 90%
rename from src/com/android/deskclock/stopwatch/LapsAdapter.java
rename to app/src/main/java/com/best/deskclock/stopwatch/LapsAdapter.java
index 703200d8b..1f227d929 100644
--- a/src/com/android/deskclock/stopwatch/LapsAdapter.java
+++ b/app/src/main/java/com/best/deskclock/stopwatch/LapsAdapter.java
@@ -17,9 +17,6 @@
 package com.best.deskclock.stopwatch;
 
 import android.content.Context;
-import androidx.annotation.VisibleForTesting;
-import androidx.recyclerview.widget.RecyclerView;
-
 import android.os.Vibrator;
 import android.text.format.DateUtils;
 import android.view.LayoutInflater;
@@ -27,6 +24,10 @@ import android.view.View;
 import android.view.ViewGroup;
 import android.widget.TextView;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.VisibleForTesting;
+import androidx.recyclerview.widget.RecyclerView;
+
 import com.best.deskclock.R;
 import com.best.deskclock.data.DataModel;
 import com.best.deskclock.data.Lap;
@@ -47,19 +48,27 @@ class LapsAdapter extends RecyclerView.Adapter<LapsAdapter.LapItemHolder> {
     private static final long TEN_HOURS = 10 * HOUR;
     private static final long HUNDRED_HOURS = 100 * HOUR;
 
-    /** A single space preceded by a zero-width LRM; This groups adjacent chars left-to-right. */
+    /**
+     * A single space preceded by a zero-width LRM; This groups adjacent chars left-to-right.
+     */
     private static final String LRM_SPACE = "\u200E ";
 
-    /** Reusable StringBuilder that assembles a formatted time; alleviates memory churn. */
+    /**
+     * Reusable StringBuilder that assembles a formatted time; alleviates memory churn.
+     */
     private static final StringBuilder sTimeBuilder = new StringBuilder(12);
 
     private final LayoutInflater mInflater;
     private final Context mContext;
 
-    /** Used to determine when the time format for the lap time column has changed length. */
+    /**
+     * Used to determine when the time format for the lap time column has changed length.
+     */
     private int mLastFormattedLapTimeLength;
 
-    /** Used to determine when the time format for the total time column has changed length. */
+    /**
+     * Used to determine when the time format for the total time column has changed length.
+     */
     private int mLastFormattedAccumulatedTimeLength;
 
     LapsAdapter(Context context) {
@@ -68,6 +77,63 @@ class LapsAdapter extends RecyclerView.Adapter<LapsAdapter.LapItemHolder> {
         setHasStableIds(true);
     }
 
+    /**
+     * @param maxTime   the maximum amount of time; used to choose a time format
+     * @param time      the time to format guaranteed not to exceed {@code maxTime}
+     * @param separator displayed between hours and minutes as well as minutes and seconds
+     * @return a formatted version of the time
+     */
+    @VisibleForTesting
+    static String formatTime(long maxTime, long time, String separator) {
+        final int hours, minutes, seconds, hundredths;
+        if (time <= 0) {
+            // A negative time should be impossible, but is tolerated to avoid crashing the app.
+            hours = minutes = seconds = hundredths = 0;
+        } else {
+            hours = (int) (time / DateUtils.HOUR_IN_MILLIS);
+            int remainder = (int) (time % DateUtils.HOUR_IN_MILLIS);
+
+            minutes = (int) (remainder / DateUtils.MINUTE_IN_MILLIS);
+            remainder = (int) (remainder % DateUtils.MINUTE_IN_MILLIS);
+
+            seconds = (int) (remainder / DateUtils.SECOND_IN_MILLIS);
+            remainder = (int) (remainder % DateUtils.SECOND_IN_MILLIS);
+
+            hundredths = remainder / 10;
+        }
+
+        final char decimalSeparator = DecimalFormatSymbols.getInstance().getDecimalSeparator();
+
+        sTimeBuilder.setLength(0);
+
+        // The display of hours and minutes varies based on maxTime.
+        if (maxTime < TEN_MINUTES) {
+            sTimeBuilder.append(UiDataModel.getUiDataModel().getFormattedNumber(minutes, 1));
+        } else if (maxTime < HOUR) {
+            sTimeBuilder.append(UiDataModel.getUiDataModel().getFormattedNumber(minutes, 2));
+        } else if (maxTime < TEN_HOURS) {
+            sTimeBuilder.append(UiDataModel.getUiDataModel().getFormattedNumber(hours, 1));
+            sTimeBuilder.append(separator);
+            sTimeBuilder.append(UiDataModel.getUiDataModel().getFormattedNumber(minutes, 2));
+        } else if (maxTime < HUNDRED_HOURS) {
+            sTimeBuilder.append(UiDataModel.getUiDataModel().getFormattedNumber(hours, 2));
+            sTimeBuilder.append(separator);
+            sTimeBuilder.append(UiDataModel.getUiDataModel().getFormattedNumber(minutes, 2));
+        } else {
+            sTimeBuilder.append(UiDataModel.getUiDataModel().getFormattedNumber(hours, 3));
+            sTimeBuilder.append(separator);
+            sTimeBuilder.append(UiDataModel.getUiDataModel().getFormattedNumber(minutes, 2));
+        }
+
+        // The display of seconds and hundredths-of-a-second is constant.
+        sTimeBuilder.append(separator);
+        sTimeBuilder.append(UiDataModel.getUiDataModel().getFormattedNumber(seconds, 2));
+        sTimeBuilder.append(decimalSeparator);
+        sTimeBuilder.append(UiDataModel.getUiDataModel().getFormattedNumber(hundredths, 2));
+
+        return sTimeBuilder.toString();
+    }
+
     /**
      * After recording the first lap, there is always a "current lap" in progress.
      *
@@ -80,14 +146,15 @@ class LapsAdapter extends RecyclerView.Adapter<LapsAdapter.LapItemHolder> {
         return currentLapCount + lapCount;
     }
 
+    @NonNull
     @Override
-    public LapItemHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+    public LapItemHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
         final View v = mInflater.inflate(R.layout.lap_view, parent, false /* attachToRoot */);
         return new LapItemHolder(v);
     }
 
     @Override
-    public void onBindViewHolder(LapItemHolder viewHolder, int position) {
+    public void onBindViewHolder(@NonNull LapItemHolder viewHolder, int position) {
         final long lapTime;
         final int lapNumber;
         final long totalTime;
@@ -123,7 +190,7 @@ class LapsAdapter extends RecyclerView.Adapter<LapsAdapter.LapItemHolder> {
     }
 
     /**
-     * @param rv the RecyclerView that contains the {@code childView}
+     * @param rv        the RecyclerView that contains the {@code childView}
      * @param totalTime time accumulated for the current lap and all prior laps
      */
     void updateCurrentLap(RecyclerView rv, long totalTime) {
@@ -228,7 +295,7 @@ class LapsAdapter extends RecyclerView.Adapter<LapsAdapter.LapItemHolder> {
     }
 
     /**
-     * @param lapCount the total number of recorded laps
+     * @param lapCount  the total number of recorded laps
      * @param lapNumber the number of the lap being formatted
      * @return e.g. "# 7" if {@code lapCount} less than 10; "# 07" if {@code lapCount} is 10 or more
      */
@@ -242,64 +309,7 @@ class LapsAdapter extends RecyclerView.Adapter<LapsAdapter.LapItemHolder> {
     }
 
     /**
-     * @param maxTime the maximum amount of time; used to choose a time format
-     * @param time the time to format guaranteed not to exceed {@code maxTime}
-     * @param separator displayed between hours and minutes as well as minutes and seconds
-     * @return a formatted version of the time
-     */
-    @VisibleForTesting
-    static String formatTime(long maxTime, long time, String separator) {
-        final int hours, minutes, seconds, hundredths;
-        if (time <= 0) {
-            // A negative time should be impossible, but is tolerated to avoid crashing the app.
-            hours = minutes = seconds = hundredths = 0;
-        } else {
-            hours = (int) (time / DateUtils.HOUR_IN_MILLIS);
-            int remainder = (int) (time % DateUtils.HOUR_IN_MILLIS);
-
-            minutes = (int) (remainder / DateUtils.MINUTE_IN_MILLIS);
-            remainder = (int) (remainder % DateUtils.MINUTE_IN_MILLIS);
-
-            seconds = (int) (remainder / DateUtils.SECOND_IN_MILLIS);
-            remainder = (int) (remainder % DateUtils.SECOND_IN_MILLIS);
-
-            hundredths = remainder / 10;
-        }
-
-        final char decimalSeparator = DecimalFormatSymbols.getInstance().getDecimalSeparator();
-
-        sTimeBuilder.setLength(0);
-
-        // The display of hours and minutes varies based on maxTime.
-        if (maxTime < TEN_MINUTES) {
-            sTimeBuilder.append(UiDataModel.getUiDataModel().getFormattedNumber(minutes, 1));
-        } else if (maxTime < HOUR) {
-            sTimeBuilder.append(UiDataModel.getUiDataModel().getFormattedNumber(minutes, 2));
-        } else if (maxTime < TEN_HOURS) {
-            sTimeBuilder.append(UiDataModel.getUiDataModel().getFormattedNumber(hours, 1));
-            sTimeBuilder.append(separator);
-            sTimeBuilder.append(UiDataModel.getUiDataModel().getFormattedNumber(minutes, 2));
-        } else if (maxTime < HUNDRED_HOURS) {
-            sTimeBuilder.append(UiDataModel.getUiDataModel().getFormattedNumber(hours, 2));
-            sTimeBuilder.append(separator);
-            sTimeBuilder.append(UiDataModel.getUiDataModel().getFormattedNumber(minutes, 2));
-        } else {
-            sTimeBuilder.append(UiDataModel.getUiDataModel().getFormattedNumber(hours, 3));
-            sTimeBuilder.append(separator);
-            sTimeBuilder.append(UiDataModel.getUiDataModel().getFormattedNumber(minutes, 2));
-        }
-
-        // The display of seconds and hundredths-of-a-second is constant.
-        sTimeBuilder.append(separator);
-        sTimeBuilder.append(UiDataModel.getUiDataModel().getFormattedNumber(seconds, 2));
-        sTimeBuilder.append(decimalSeparator);
-        sTimeBuilder.append(UiDataModel.getUiDataModel().getFormattedNumber(hundredths, 2));
-
-        return sTimeBuilder.toString();
-    }
-
-    /**
-     * @param lapTime the lap time to be formatted
+     * @param lapTime   the lap time to be formatted
      * @param isBinding if the lap time is requested so it can be bound avoid notifying of data
      *                  set changes; they are not allowed to occur during bind
      * @return a formatted version of the lap time
@@ -321,8 +331,8 @@ class LapsAdapter extends RecyclerView.Adapter<LapsAdapter.LapItemHolder> {
 
     /**
      * @param accumulatedTime the accumulated time to be formatted
-     * @param isBinding if the lap time is requested so it can be bound avoid notifying of data
-     *                  set changes; they are not allowed to occur during bind
+     * @param isBinding       if the lap time is requested so it can be bound avoid notifying of data
+     *                        set changes; they are not allowed to occur during bind
      * @return a formatted version of the accumulated time
      */
     private String formatAccumulatedTime(long accumulatedTime, boolean isBinding) {
@@ -360,9 +370,9 @@ class LapsAdapter extends RecyclerView.Adapter<LapsAdapter.LapItemHolder> {
         LapItemHolder(View itemView) {
             super(itemView);
 
-            lapTime = (TextView) itemView.findViewById(R.id.lap_time);
-            lapNumber = (TextView) itemView.findViewById(R.id.lap_number);
-            accumulatedTime = (TextView) itemView.findViewById(R.id.lap_total);
+            lapTime = itemView.findViewById(R.id.lap_time);
+            lapNumber = itemView.findViewById(R.id.lap_number);
+            accumulatedTime = itemView.findViewById(R.id.lap_total);
         }
     }
 }
diff --git a/src/com/android/deskclock/stopwatch/StopwatchCircleView.java b/app/src/main/java/com/best/deskclock/stopwatch/StopwatchCircleView.java
similarity index 81%
rename from src/com/android/deskclock/stopwatch/StopwatchCircleView.java
rename to app/src/main/java/com/best/deskclock/stopwatch/StopwatchCircleView.java
index a0b4b3460..078136e37 100644
--- a/src/com/android/deskclock/stopwatch/StopwatchCircleView.java
+++ b/app/src/main/java/com/best/deskclock/stopwatch/StopwatchCircleView.java
@@ -19,7 +19,6 @@ package com.best.deskclock.stopwatch;
 import android.content.Context;
 import android.content.res.Resources;
 import android.graphics.Canvas;
-import android.graphics.Color;
 import android.graphics.Paint;
 import android.graphics.RectF;
 import android.util.AttributeSet;
@@ -39,25 +38,39 @@ import java.util.List;
  */
 public final class StopwatchCircleView extends View {
 
-    /** The size of the dot indicating the user's position within the reference lap. */
+    /**
+     * The size of the dot indicating the user's position within the reference lap.
+     */
     private final float mDotRadius;
 
-    /** An amount to subtract from the true radius to account for drawing thicknesses. */
+    /**
+     * An amount to subtract from the true radius to account for drawing thicknesses.
+     */
     private final float mRadiusOffset;
 
-    /** Used to scale the width of the marker to make it similarly visible on all screens. */
+    /**
+     * Used to scale the width of the marker to make it similarly visible on all screens.
+     */
     private final float mScreenDensity;
 
-    /** The color indicating the remaining portion of the current lap. */
+    /**
+     * The color indicating the remaining portion of the current lap.
+     */
     private final int mRemainderColor;
 
-    /** The color indicating the completed portion of the lap. */
+    /**
+     * The color indicating the completed portion of the lap.
+     */
     private final int mCompletedColor;
 
-    /** The size of the stroke that paints the lap circle. */
+    /**
+     * The size of the stroke that paints the lap circle.
+     */
     private final float mStrokeSize;
 
-    /** The size of the stroke that paints the marker for the end of the prior lap. */
+    /**
+     * The size of the stroke that paints the marker for the end of the prior lap.
+     */
     private final float mMarkerStrokeSize;
 
     private final Paint mPaint = new Paint();
@@ -81,8 +94,8 @@ public final class StopwatchCircleView extends View {
         mMarkerStrokeSize = resources.getDimension(R.dimen.circletimer_marker_size);
         mRadiusOffset = Utils.calculateRadiusOffset(mStrokeSize, dotDiameter, mMarkerStrokeSize);
 
-        mRemainderColor = ThemeUtils.resolveColor(context, R.attr.colorControlNormal);
-        mCompletedColor = ThemeUtils.resolveColor(context, R.attr.colorAccent);
+        mRemainderColor = ThemeUtils.resolveColor(context, androidx.appcompat.R.attr.colorControlNormal);
+        mCompletedColor = ThemeUtils.resolveColor(context, androidx.appcompat.R.attr.colorAccent);
 
         mPaint.setAntiAlias(true);
         mPaint.setStyle(Paint.Style.STROKE);
@@ -132,7 +145,7 @@ public final class StopwatchCircleView extends View {
         // Draw a combination of red and white arcs to create a circle.
         mArcRect.top = yCenter - radius;
         mArcRect.bottom = yCenter + radius;
-        mArcRect.left =  xCenter - radius;
+        mArcRect.left = xCenter - radius;
         mArcRect.right = xCenter + radius;
         final float redPercent = (float) currentLapTime / (float) firstLapTime;
         final float whitePercent = 1 - (redPercent > 1 ? 1 : redPercent);
@@ -142,7 +155,7 @@ public final class StopwatchCircleView extends View {
 
         // Draw a red arc to indicate the amount of reference lap completed.
         mPaint.setColor(mCompletedColor);
-        canvas.drawArc(mArcRect, 270, redPercent * 360 , false, mPaint);
+        canvas.drawArc(mArcRect, 270, redPercent * 360, false, mPaint);
 
         // Starting on lap 2, a marker can be drawn indicating where the prior lap ended.
         if (lapCount > 1) {
@@ -154,13 +167,6 @@ public final class StopwatchCircleView extends View {
             canvas.drawArc(mArcRect, startAngle, sweepAngle, false, mPaint);
         }
 
-        // Draw a red dot to indicate current position relative to reference lap.
-        final float dotAngleDegrees = 270 + redPercent * 360;
-        final double dotAngleRadians = Math.toRadians(dotAngleDegrees);
-        final float dotX = xCenter + (float) (radius * Math.cos(dotAngleRadians));
-        final float dotY = yCenter + (float) (radius * Math.sin(dotAngleRadians));
-        canvas.drawCircle(dotX, dotY, mDotRadius, mFill);
-
         // If the stopwatch is not running it does not require continuous updates.
         if (stopwatch.isRunning()) {
             postInvalidateOnAnimation();
diff --git a/src/com/android/deskclock/stopwatch/StopwatchFragment.java b/app/src/main/java/com/best/deskclock/stopwatch/StopwatchFragment.java
similarity index 91%
rename from src/com/android/deskclock/stopwatch/StopwatchFragment.java
rename to app/src/main/java/com/best/deskclock/stopwatch/StopwatchFragment.java
index 3a36c865f..0848fdeef 100644
--- a/src/com/android/deskclock/stopwatch/StopwatchFragment.java
+++ b/app/src/main/java/com/best/deskclock/stopwatch/StopwatchFragment.java
@@ -16,6 +16,14 @@
 
 package com.best.deskclock.stopwatch;
 
+import static android.R.attr.state_activated;
+import static android.R.attr.state_pressed;
+import static android.graphics.drawable.GradientDrawable.Orientation.TOP_BOTTOM;
+import static android.view.View.GONE;
+import static android.view.View.INVISIBLE;
+import static android.view.View.VISIBLE;
+import static com.best.deskclock.uidata.UiDataModel.Tab.STOPWATCH;
+
 import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.content.ActivityNotFoundException;
@@ -26,13 +34,6 @@ import android.content.res.Resources;
 import android.graphics.Canvas;
 import android.graphics.drawable.GradientDrawable;
 import android.os.Bundle;
-import androidx.annotation.ColorInt;
-import androidx.annotation.NonNull;
-import androidx.core.graphics.ColorUtils;
-import androidx.recyclerview.widget.LinearLayoutManager;
-import androidx.recyclerview.widget.RecyclerView;
-import androidx.recyclerview.widget.SimpleItemAnimator;
-
 import android.os.Vibrator;
 import android.transition.TransitionManager;
 import android.view.LayoutInflater;
@@ -44,6 +45,13 @@ import android.widget.Button;
 import android.widget.ImageView;
 import android.widget.TextView;
 
+import androidx.annotation.ColorInt;
+import androidx.annotation.NonNull;
+import androidx.core.graphics.ColorUtils;
+import androidx.recyclerview.widget.LinearLayoutManager;
+import androidx.recyclerview.widget.RecyclerView;
+import androidx.recyclerview.widget.SimpleItemAnimator;
+
 import com.best.deskclock.AnimatorUtils;
 import com.best.deskclock.DeskClockFragment;
 import com.best.deskclock.LogUtils;
@@ -60,62 +68,86 @@ import com.best.deskclock.uidata.TabListener;
 import com.best.deskclock.uidata.UiDataModel;
 import com.best.deskclock.uidata.UiDataModel.Tab;
 
-import static android.R.attr.state_activated;
-import static android.R.attr.state_pressed;
-import static android.graphics.drawable.GradientDrawable.Orientation.TOP_BOTTOM;
-import static android.view.View.GONE;
-import static android.view.View.INVISIBLE;
-import static android.view.View.VISIBLE;
-import static com.best.deskclock.uidata.UiDataModel.Tab.STOPWATCH;
+import java.util.Objects;
 
 /**
  * Fragment that shows the stopwatch and recorded laps.
  */
 public final class StopwatchFragment extends DeskClockFragment {
 
-    /** Milliseconds between redraws while running. */
+    /**
+     * Milliseconds between redraws while running.
+     */
     private static final int REDRAW_PERIOD_RUNNING = 25;
 
-    /** Milliseconds between redraws while paused. */
+    /**
+     * Milliseconds between redraws while paused.
+     */
     private static final int REDRAW_PERIOD_PAUSED = 500;
 
-    /** Keep the screen on when this tab is selected. */
+    /**
+     * Keep the screen on when this tab is selected.
+     */
     private final TabListener mTabWatcher = new TabWatcher();
 
-    /** Scheduled to update the stopwatch time and current lap time while stopwatch is running. */
+    /**
+     * Scheduled to update the stopwatch time and current lap time while stopwatch is running.
+     */
     private final Runnable mTimeUpdateRunnable = new TimeUpdateRunnable();
 
-    /** Updates the user interface in response to stopwatch changes. */
+    /**
+     * Updates the user interface in response to stopwatch changes.
+     */
     private final StopwatchListener mStopwatchWatcher = new StopwatchWatcher();
 
-    /** Draws a gradient over the bottom of the {@link #mLapsList} to reduce clash with the fab. */
+    /**
+     * Draws a gradient over the bottom of the {@link #mLapsList} to reduce clash with the fab.
+     */
     private GradientItemDecoration mGradientItemDecoration;
 
-    /** The data source for {@link #mLapsList}. */
+    /**
+     * The data source for {@link #mLapsList}.
+     */
     private LapsAdapter mLapsAdapter;
 
-    /** The layout manager for the {@link #mLapsAdapter}. */
+    /**
+     * The layout manager for the {@link #mLapsAdapter}.
+     */
     private LinearLayoutManager mLapsLayoutManager;
 
-    /** Draws the reference lap while the stopwatch is running. */
+    /**
+     * Draws the reference lap while the stopwatch is running.
+     */
     private StopwatchCircleView mTime;
 
-    /** The View containing both TextViews of the stopwatch. */
+    /**
+     * The View containing both TextViews of the stopwatch.
+     */
     private View mStopwatchWrapper;
 
-    /** Displays the recorded lap times. */
+    /**
+     * Displays the recorded lap times.
+     */
     private RecyclerView mLapsList;
 
-    /** Displays the current stopwatch time (seconds and above only). */
+    /**
+     * Displays the current stopwatch time (seconds and above only).
+     */
     private TextView mMainTimeText;
 
-    /** Displays the current stopwatch time (hundredths only). */
+    /**
+     * Displays the current stopwatch time (hundredths only).
+     */
     private TextView mHundredthsTimeText;
 
-    /** Formats and displays the text in the stopwatch. */
+    /**
+     * Formats and displays the text in the stopwatch.
+     */
     private StopwatchTextController mStopwatchTextController;
 
-    /** The public no-arg constructor required by all fragments. */
+    /**
+     * The public no-arg constructor required by all fragments.
+     */
     public StopwatchFragment() {
         super(STOPWATCH);
     }
@@ -127,9 +159,9 @@ public final class StopwatchFragment extends DeskClockFragment {
         mGradientItemDecoration = new GradientItemDecoration(getActivity());
 
         final View v = inflater.inflate(R.layout.stopwatch_fragment, container, false);
-        mTime = (StopwatchCircleView) v.findViewById(R.id.stopwatch_circle);
-        mLapsList = (RecyclerView) v.findViewById(R.id.laps_list);
-        ((SimpleItemAnimator) mLapsList.getItemAnimator()).setSupportsChangeAnimations(false);
+        mTime = v.findViewById(R.id.stopwatch_circle);
+        mLapsList = v.findViewById(R.id.laps_list);
+        ((SimpleItemAnimator) Objects.requireNonNull(mLapsList.getItemAnimator())).setSupportsChangeAnimations(false);
         mLapsList.setLayoutManager(mLapsLayoutManager);
         mLapsList.addItemDecoration(mGradientItemDecoration);
 
@@ -145,8 +177,8 @@ public final class StopwatchFragment extends DeskClockFragment {
         mLapsList.setAdapter(mLapsAdapter);
 
         // Timer text serves as a virtual start/stop button.
-        mMainTimeText = (TextView) v.findViewById(R.id.stopwatch_time_text);
-        mHundredthsTimeText = (TextView) v.findViewById(R.id.stopwatch_hundredths_text);
+        mMainTimeText = v.findViewById(R.id.stopwatch_time_text);
+        mHundredthsTimeText = v.findViewById(R.id.stopwatch_hundredths_text);
         mStopwatchTextController = new StopwatchTextController(mMainTimeText, mHundredthsTimeText);
         mStopwatchWrapper = v.findViewById(R.id.stopwatch_time_wrapper);
 
@@ -158,11 +190,11 @@ public final class StopwatchFragment extends DeskClockFragment {
         }
 
         final Context c = mMainTimeText.getContext();
-        final int colorAccent = ThemeUtils.resolveColor(c, R.attr.colorAccent);
+        final int colorAccent = ThemeUtils.resolveColor(c, androidx.appcompat.R.attr.colorAccent);
         final int textColorPrimary = ThemeUtils.resolveColor(c, android.R.attr.textColorPrimary);
         final ColorStateList timeTextColor = new ColorStateList(
-                new int[][] { { -state_activated, -state_pressed }, {} },
-                new int[] { textColorPrimary, colorAccent });
+                new int[][]{{-state_activated, -state_pressed}, {}},
+                new int[]{textColorPrimary, colorAccent});
         mMainTimeText.setTextColor(timeTextColor);
         mHundredthsTimeText.setTextColor(timeTextColor);
 
@@ -296,7 +328,6 @@ public final class StopwatchFragment extends DeskClockFragment {
         }
     }
 
-    
 
     /**
      * @param color the newly installed app window color
@@ -362,9 +393,7 @@ public final class StopwatchFragment extends DeskClockFragment {
         final String subject = subjects[(int) (Math.random() * subjects.length)];
         final String text = mLapsAdapter.getShareText();
 
-        @SuppressLint("InlinedApi")
-        @SuppressWarnings("deprecation")
-        final Intent shareIntent = new Intent(Intent.ACTION_SEND)
+        @SuppressLint("InlinedApi") final Intent shareIntent = new Intent(Intent.ACTION_SEND)
                 .addFlags(Utils.isLOrLater() ? Intent.FLAG_ACTIVITY_NEW_DOCUMENT
                         : Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET)
                 .putExtra(Intent.EXTRA_SUBJECT, subject)
@@ -537,6 +566,92 @@ public final class StopwatchFragment extends DeskClockFragment {
         updateFab(updateTypes);
     }
 
+    /**
+     * Draws a tinting gradient over the bottom of the stopwatch laps list. This reduces the
+     * contrast between floating buttons and the laps list content.
+     */
+    private static final class GradientItemDecoration extends RecyclerView.ItemDecoration {
+
+        //  0% -  25% of gradient length -> opacity changes from 0% to 50%
+        // 25% -  90% of gradient length -> opacity changes from 50% to 100%
+        // 90% - 100% of gradient length -> opacity remains at 100%
+        private static final int[] ALPHAS = {
+                0x00, // 0%
+                0x1A, // 10%
+                0x33, // 20%
+                0x4D, // 30%
+                0x66, // 40%
+                0x80, // 50%
+                0x89, // 53.8%
+                0x93, // 57.6%
+                0x9D, // 61.5%
+                0xA7, // 65.3%
+                0xB1, // 69.2%
+                0xBA, // 73.0%
+                0xC4, // 76.9%
+                0xCE, // 80.7%
+                0xD8, // 84.6%
+                0xE2, // 88.4%
+                0xEB, // 92.3%
+                0xF5, // 96.1%
+                0xFF, // 100%
+                0xFF, // 100%
+                0xFF, // 100%
+        };
+
+        /**
+         * A reusable array of control point colors that define the gradient. It is based on the
+         * background color of the window and thus recomputed each time that color is changed.
+         */
+        private final int[] mGradientColors = new int[ALPHAS.length];
+
+        /**
+         * The drawable that produces the tinting gradient effect of this decoration.
+         */
+        private final GradientDrawable mGradient = new GradientDrawable();
+
+        /**
+         * The height of the gradient; sized relative to the fab height.
+         */
+        private final int mGradientHeight;
+
+        GradientItemDecoration(Context context) {
+            mGradient.setOrientation(TOP_BOTTOM);
+            updateGradientColors(ThemeUtils.resolveColor(context, android.R.attr.colorBackground));
+
+            final Resources resources = context.getResources();
+            final float fabHeight = resources.getDimensionPixelSize(R.dimen.fab_height);
+            mGradientHeight = Math.round(fabHeight * 1.2f);
+        }
+
+        @Override
+        public void onDrawOver(@NonNull Canvas c, @NonNull RecyclerView parent, @NonNull RecyclerView.State state) {
+            super.onDrawOver(c, parent, state);
+
+            final int w = parent.getWidth();
+            final int h = parent.getHeight();
+
+            mGradient.setBounds(0, h - mGradientHeight, w, h);
+            mGradient.draw(c);
+        }
+
+        /**
+         * Given a {@code baseColor}, compute a gradient of tinted colors that define the fade
+         * effect to apply to the bottom of the lap list.
+         *
+         * @param baseColor a base color to which the gradient tint should be applied
+         */
+        void updateGradientColors(@ColorInt int baseColor) {
+            // Compute the tinted colors that form the gradient.
+            for (int i = 0; i < mGradientColors.length; i++) {
+                mGradientColors[i] = ColorUtils.setAlphaComponent(baseColor, ALPHAS[i]);
+            }
+
+            // Set the gradient colors into the drawable.
+            mGradient.setColors(mGradientColors);
+        }
+    }
+
     /**
      * This runnable periodically updates times throughout the UI. It stops these updates when the
      * stopwatch is no longer running.
@@ -653,96 +768,14 @@ public final class StopwatchFragment extends DeskClockFragment {
     private final class ScrollPositionWatcher extends RecyclerView.OnScrollListener
             implements View.OnLayoutChangeListener {
         @Override
-        public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
+        public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) {
             setTabScrolledToTop(Utils.isScrolledToTop(mLapsList));
         }
 
         @Override
         public void onLayoutChange(View v, int left, int top, int right, int bottom,
-                int oldLeft, int oldTop, int oldRight, int oldBottom) {
+                                   int oldLeft, int oldTop, int oldRight, int oldBottom) {
             setTabScrolledToTop(Utils.isScrolledToTop(mLapsList));
         }
     }
-
-    /**
-     * Draws a tinting gradient over the bottom of the stopwatch laps list. This reduces the
-     * contrast between floating buttons and the laps list content.
-     */
-    private static final class GradientItemDecoration extends RecyclerView.ItemDecoration {
-
-        //  0% -  25% of gradient length -> opacity changes from 0% to 50%
-        // 25% -  90% of gradient length -> opacity changes from 50% to 100%
-        // 90% - 100% of gradient length -> opacity remains at 100%
-        private static final int[] ALPHAS = {
-                0x00, // 0%
-                0x1A, // 10%
-                0x33, // 20%
-                0x4D, // 30%
-                0x66, // 40%
-                0x80, // 50%
-                0x89, // 53.8%
-                0x93, // 57.6%
-                0x9D, // 61.5%
-                0xA7, // 65.3%
-                0xB1, // 69.2%
-                0xBA, // 73.0%
-                0xC4, // 76.9%
-                0xCE, // 80.7%
-                0xD8, // 84.6%
-                0xE2, // 88.4%
-                0xEB, // 92.3%
-                0xF5, // 96.1%
-                0xFF, // 100%
-                0xFF, // 100%
-                0xFF, // 100%
-        };
-
-        /**
-         * A reusable array of control point colors that define the gradient. It is based on the
-         * background color of the window and thus recomputed each time that color is changed.
-         */
-        private final int[] mGradientColors = new int[ALPHAS.length];
-
-        /** The drawable that produces the tinting gradient effect of this decoration. */
-        private final GradientDrawable mGradient = new GradientDrawable();
-
-        /** The height of the gradient; sized relative to the fab height. */
-        private final int mGradientHeight;
-
-        GradientItemDecoration(Context context) {
-            mGradient.setOrientation(TOP_BOTTOM);
-            updateGradientColors(ThemeUtils.resolveColor(context, android.R.attr.colorBackground));
-
-            final Resources resources = context.getResources();
-            final float fabHeight = resources.getDimensionPixelSize(R.dimen.fab_height);
-            mGradientHeight = Math.round(fabHeight * 1.2f);
-        }
-
-        @Override
-        public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) {
-            super.onDrawOver(c, parent, state);
-
-            final int w = parent.getWidth();
-            final int h = parent.getHeight();
-
-            mGradient.setBounds(0, h - mGradientHeight, w, h);
-            mGradient.draw(c);
-        }
-
-        /**
-         * Given a {@code baseColor}, compute a gradient of tinted colors that define the fade
-         * effect to apply to the bottom of the lap list.
-         *
-         * @param baseColor a base color to which the gradient tint should be applied
-         */
-        void updateGradientColors(@ColorInt int baseColor) {
-            // Compute the tinted colors that form the gradient.
-            for (int i = 0; i < mGradientColors.length; i++) {
-                mGradientColors[i] = ColorUtils.setAlphaComponent(baseColor, ALPHAS[i]);
-            }
-
-            // Set the gradient colors into the drawable.
-            mGradient.setColors(mGradientColors);
-        }
-    }
 }
diff --git a/src/com/android/deskclock/stopwatch/StopwatchLandscapeLayout.java b/app/src/main/java/com/best/deskclock/stopwatch/StopwatchLandscapeLayout.java
similarity index 99%
rename from src/com/android/deskclock/stopwatch/StopwatchLandscapeLayout.java
rename to app/src/main/java/com/best/deskclock/stopwatch/StopwatchLandscapeLayout.java
index 0036d2275..58bd6f112 100644
--- a/src/com/android/deskclock/stopwatch/StopwatchLandscapeLayout.java
+++ b/app/src/main/java/com/best/deskclock/stopwatch/StopwatchLandscapeLayout.java
@@ -16,6 +16,10 @@
 
 package com.best.deskclock.stopwatch;
 
+import static android.view.View.MeasureSpec.AT_MOST;
+import static android.view.View.MeasureSpec.EXACTLY;
+import static android.view.View.MeasureSpec.UNSPECIFIED;
+
 import android.content.Context;
 import android.util.AttributeSet;
 import android.view.View;
@@ -23,14 +27,10 @@ import android.view.ViewGroup;
 
 import com.best.deskclock.R;
 
-import static android.view.View.MeasureSpec.AT_MOST;
-import static android.view.View.MeasureSpec.EXACTLY;
-import static android.view.View.MeasureSpec.UNSPECIFIED;
-
 /**
  * Dynamically apportions size the stopwatch circle depending on the preferred width of the laps
  * list and the container size. Layouts fall into two different buckets:
- *
+ * <p>
  * When the width of the laps list is less than half the container width, the laps list and
  * stopwatch display are each centered within half the container.
  * <pre>
@@ -42,7 +42,7 @@ import static android.view.View.MeasureSpec.UNSPECIFIED;
  *     |                                    |               Lap 1                |
  *     ---------------------------------------------------------------------------
  * </pre>
- *
+ * <p>
  * When the width of the laps list is greater than half the container width, the laps list is
  * granted all of the space it requires and the stopwatch display is centered within the remaining
  * container width.
diff --git a/src/com/android/deskclock/stopwatch/StopwatchService.java b/app/src/main/java/com/best/deskclock/stopwatch/StopwatchService.java
similarity index 100%
rename from src/com/android/deskclock/stopwatch/StopwatchService.java
rename to app/src/main/java/com/best/deskclock/stopwatch/StopwatchService.java
index f0ee08ed1..9caef76d7 100644
--- a/src/com/android/deskclock/stopwatch/StopwatchService.java
+++ b/app/src/main/java/com/best/deskclock/stopwatch/StopwatchService.java
@@ -16,6 +16,8 @@
 
 package com.best.deskclock.stopwatch;
 
+import static com.best.deskclock.uidata.UiDataModel.Tab.STOPWATCH;
+
 import android.app.Service;
 import android.content.Intent;
 import android.os.IBinder;
@@ -26,8 +28,6 @@ import com.best.deskclock.data.DataModel;
 import com.best.deskclock.events.Events;
 import com.best.deskclock.uidata.UiDataModel;
 
-import static com.best.deskclock.uidata.UiDataModel.Tab.STOPWATCH;
-
 /**
  * This service exists solely to allow the stopwatch notification to alter the state of the
  * stopwatch without disturbing the notification shade. If an activity were used instead (even one
diff --git a/src/com/android/deskclock/timer/ExpiredTimersActivity.java b/app/src/main/java/com/best/deskclock/timer/ExpiredTimersActivity.java
similarity index 94%
rename from src/com/android/deskclock/timer/ExpiredTimersActivity.java
rename to app/src/main/java/com/best/deskclock/timer/ExpiredTimersActivity.java
index 62ae47b16..53d348f70 100644
--- a/src/com/android/deskclock/timer/ExpiredTimersActivity.java
+++ b/app/src/main/java/com/best/deskclock/timer/ExpiredTimersActivity.java
@@ -18,7 +18,6 @@ import android.content.Intent;
 import android.content.pm.ActivityInfo;
 import android.os.Bundle;
 import android.os.SystemClock;
-import androidx.annotation.NonNull;
 import android.text.TextUtils;
 import android.transition.AutoTransition;
 import android.transition.TransitionManager;
@@ -30,6 +29,8 @@ import android.view.WindowManager;
 import android.widget.FrameLayout;
 import android.widget.TextView;
 
+import androidx.annotation.NonNull;
+
 import com.best.deskclock.BaseActivity;
 import com.best.deskclock.LogUtils;
 import com.best.deskclock.R;
@@ -46,16 +47,24 @@ import java.util.List;
  */
 public class ExpiredTimersActivity extends BaseActivity {
 
-    /** Scheduled to update the timers while at least one is expired. */
+    /**
+     * Scheduled to update the timers while at least one is expired.
+     */
     private final Runnable mTimeUpdateRunnable = new TimeUpdateRunnable();
 
-    /** Updates the timers displayed in this activity as the backing data changes. */
+    /**
+     * Updates the timers displayed in this activity as the backing data changes.
+     */
     private final TimerListener mTimerChangeWatcher = new TimerChangeWatcher();
 
-    /** The scene root for transitions when expired timers are added/removed from this container. */
+    /**
+     * The scene root for transitions when expired timers are added/removed from this container.
+     */
     private ViewGroup mExpiredTimersScrollView;
 
-    /** Displays the expired timers. */
+    /**
+     * Displays the expired timers.
+     */
     private ViewGroup mExpiredTimersView;
 
     @Override
@@ -73,8 +82,8 @@ public class ExpiredTimersActivity extends BaseActivity {
 
         setContentView(R.layout.expired_timers_activity);
 
-        mExpiredTimersView = (ViewGroup) findViewById(R.id.expired_timers_list);
-        mExpiredTimersScrollView = (ViewGroup) findViewById(R.id.expired_timers_scroll);
+        mExpiredTimersView = findViewById(R.id.expired_timers_list);
+        mExpiredTimersScrollView = findViewById(R.id.expired_timers_scroll);
 
         findViewById(R.id.fab).setOnClickListener(new FabClickListener());
 
@@ -169,7 +178,7 @@ public class ExpiredTimersActivity extends BaseActivity {
         mExpiredTimersView.addView(timerItem);
 
         // Hide the label hint for expired timers.
-        final TextView labelView = (TextView) timerItem.findViewById(R.id.timer_label);
+        final TextView labelView = timerItem.findViewById(R.id.timer_label);
         labelView.setHint(null);
         labelView.setVisibility(TextUtils.isEmpty(timer.getLabel()) ? View.GONE : View.VISIBLE);
 
diff --git a/src/com/android/deskclock/timer/TimerCircleView.java b/app/src/main/java/com/best/deskclock/timer/TimerCircleView.java
similarity index 80%
rename from src/com/android/deskclock/timer/TimerCircleView.java
rename to app/src/main/java/com/best/deskclock/timer/TimerCircleView.java
index e79f8e3a0..d9edd51d6 100644
--- a/src/com/android/deskclock/timer/TimerCircleView.java
+++ b/app/src/main/java/com/best/deskclock/timer/TimerCircleView.java
@@ -19,7 +19,6 @@ package com.best.deskclock.timer;
 import android.content.Context;
 import android.content.res.Resources;
 import android.graphics.Canvas;
-import android.graphics.Color;
 import android.graphics.Paint;
 import android.graphics.RectF;
 import android.util.AttributeSet;
@@ -35,19 +34,29 @@ import com.best.deskclock.data.Timer;
  */
 public final class TimerCircleView extends View {
 
-    /** The size of the dot indicating the progress through the timer. */
+    /**
+     * The size of the dot indicating the progress through the timer.
+     */
     private final float mDotRadius;
 
-    /** An amount to subtract from the true radius to account for drawing thicknesses. */
+    /**
+     * An amount to subtract from the true radius to account for drawing thicknesses.
+     */
     private final float mRadiusOffset;
 
-    /** The color indicating the remaining portion of the timer. */
+    /**
+     * The color indicating the remaining portion of the timer.
+     */
     private final int mRemainderColor;
 
-    /** The color indicating the completed portion of the timer. */
+    /**
+     * The color indicating the completed portion of the timer.
+     */
     private final int mCompletedColor;
 
-    /** The size of the stroke that paints the timer circle. */
+    /**
+     * The size of the stroke that paints the timer circle.
+     */
     private final float mStrokeSize;
 
     private final Paint mPaint = new Paint();
@@ -71,8 +80,8 @@ public final class TimerCircleView extends View {
         mStrokeSize = resources.getDimension(R.dimen.circletimer_circle_size);
         mRadiusOffset = Utils.calculateRadiusOffset(mStrokeSize, dotDiameter, 0);
 
-        mRemainderColor = ThemeUtils.resolveColor(context, R.attr.colorControlNormal);;
-        mCompletedColor = ThemeUtils.resolveColor(context, R.attr.colorAccent);
+        mRemainderColor = ThemeUtils.resolveColor(context, androidx.appcompat.R.attr.colorControlNormal);
+        mCompletedColor = ThemeUtils.resolveColor(context, androidx.appcompat.R.attr.colorAccent);
 
         mPaint.setAntiAlias(true);
         mPaint.setStyle(Paint.Style.STROKE);
@@ -134,16 +143,9 @@ public final class TimerCircleView extends View {
 
             // Draw a red arc to indicate the amount of timer completed.
             mPaint.setColor(mCompletedColor);
-            canvas.drawArc(mArcRect, 270, -redPercent * 360 , false, mPaint);
+            canvas.drawArc(mArcRect, 270, -redPercent * 360, false, mPaint);
         }
 
-        // Draw a red dot to indicate current progress through the timer.
-        final float dotAngleDegrees = 270 - redPercent * 360;
-        final double dotAngleRadians = Math.toRadians(dotAngleDegrees);
-        final float dotX = xCenter + (float) (radius * Math.cos(dotAngleRadians));
-        final float dotY = yCenter + (float) (radius * Math.sin(dotAngleRadians));
-        canvas.drawCircle(dotX, dotY, mDotRadius, mFill);
-
         if (mTimer.isRunning()) {
             postInvalidateOnAnimation();
         }
diff --git a/src/com/android/deskclock/timer/TimerFragment.java b/app/src/main/java/com/best/deskclock/timer/TimerFragment.java
similarity index 95%
rename from src/com/android/deskclock/timer/TimerFragment.java
rename to app/src/main/java/com/best/deskclock/timer/TimerFragment.java
index 69637602d..58750a428 100644
--- a/src/com/android/deskclock/timer/TimerFragment.java
+++ b/app/src/main/java/com/best/deskclock/timer/TimerFragment.java
@@ -16,6 +16,13 @@
 
 package com.best.deskclock.timer;
 
+import static android.view.View.ALPHA;
+import static android.view.View.GONE;
+import static android.view.View.INVISIBLE;
+import static android.view.View.TRANSLATION_Y;
+import static android.view.View.VISIBLE;
+import static com.best.deskclock.uidata.UiDataModel.Tab.TIMERS;
+
 import android.animation.Animator;
 import android.animation.AnimatorListenerAdapter;
 import android.animation.AnimatorSet;
@@ -24,9 +31,6 @@ import android.content.Context;
 import android.content.Intent;
 import android.os.Bundle;
 import android.os.SystemClock;
-import androidx.annotation.NonNull;
-import androidx.annotation.VisibleForTesting;
-import androidx.viewpager.widget.ViewPager;
 import android.view.KeyEvent;
 import android.view.LayoutInflater;
 import android.view.View;
@@ -37,11 +41,14 @@ import android.view.animation.DecelerateInterpolator;
 import android.widget.Button;
 import android.widget.ImageView;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.VisibleForTesting;
+import androidx.viewpager.widget.ViewPager;
+
 import com.best.deskclock.AnimatorUtils;
 import com.best.deskclock.DeskClock;
 import com.best.deskclock.DeskClockFragment;
 import com.best.deskclock.R;
-import com.best.deskclock.Utils;
 import com.best.deskclock.data.DataModel;
 import com.best.deskclock.data.Timer;
 import com.best.deskclock.data.TimerListener;
@@ -52,13 +59,6 @@ import com.best.deskclock.uidata.UiDataModel;
 import java.io.Serializable;
 import java.util.Arrays;
 
-import static android.view.View.ALPHA;
-import static android.view.View.GONE;
-import static android.view.View.INVISIBLE;
-import static android.view.View.TRANSLATION_Y;
-import static android.view.View.VISIBLE;
-import static com.best.deskclock.uidata.UiDataModel.Tab.TIMERS;
-
 /**
  * Displays a vertical list of timers in all states.
  */
@@ -68,13 +68,19 @@ public final class TimerFragment extends DeskClockFragment {
 
     private static final String KEY_TIMER_SETUP_STATE = "timer_setup_input";
 
-    /** Notified when the user swipes vertically to change the visible timer. */
+    /**
+     * Notified when the user swipes vertically to change the visible timer.
+     */
     private final TimerPageChangeListener mTimerPageChangeListener = new TimerPageChangeListener();
 
-    /** Scheduled to update the timers while at least one is running. */
+    /**
+     * Scheduled to update the timers while at least one is running.
+     */
     private final Runnable mTimeUpdateRunnable = new TimeUpdateRunnable();
 
-    /** Updates the {@link #mPageIndicators} in response to timers being added or removed. */
+    /**
+     * Updates the {@link #mPageIndicators} in response to timers being added or removed.
+     */
     private final TimerListener mTimerWatcher = new TimerWatcher();
 
     private TimerSetupView mCreateTimerView;
@@ -86,9 +92,18 @@ public final class TimerFragment extends DeskClockFragment {
 
     private Serializable mTimerSetupState;
 
-    /** {@code true} while this fragment is creating a new timer; {@code false} otherwise. */
+    /**
+     * {@code true} while this fragment is creating a new timer; {@code false} otherwise.
+     */
     private boolean mCreatingTimer;
 
+    /**
+     * The public no-arg constructor required by all fragments.
+     */
+    public TimerFragment() {
+        super(TIMERS);
+    }
+
     /**
      * @return an Intent that selects the timers tab with the setup screen for a new timer in place.
      */
@@ -96,29 +111,80 @@ public final class TimerFragment extends DeskClockFragment {
         return new Intent(context, DeskClock.class).putExtra(EXTRA_TIMER_SETUP, true);
     }
 
-    /** The public no-arg constructor required by all fragments. */
-    public TimerFragment() {
-        super(TIMERS);
+    /**
+     * @param page               the selected page; value between 0 and {@code pageCount}
+     * @param pageIndicatorCount the number of indicators displaying the {@code page} location
+     * @param pageCount          the number of pages that exist
+     * @return an array of length {@code pageIndicatorCount} specifying which image to display for
+     * each page indicator or 0 if the page indicator should be hidden
+     */
+    @VisibleForTesting
+    static int[] computePageIndicatorStates(int page, int pageIndicatorCount, int pageCount) {
+        // Compute the number of page indicators that will be visible.
+        final int rangeSize = Math.min(pageIndicatorCount, pageCount);
+
+        // Compute the inclusive range of pages to indicate centered around the selected page.
+        int rangeStart = page - (rangeSize / 2);
+        int rangeEnd = rangeStart + rangeSize - 1;
+
+        // Clamp the range of pages if they extend beyond the last page.
+        if (rangeEnd >= pageCount) {
+            rangeEnd = pageCount - 1;
+            rangeStart = rangeEnd - rangeSize + 1;
+        }
+
+        // Clamp the range of pages if they extend beyond the first page.
+        if (rangeStart < 0) {
+            rangeStart = 0;
+            rangeEnd = rangeSize - 1;
+        }
+
+        // Build the result with all page indicators initially hidden.
+        final int[] states = new int[pageIndicatorCount];
+        Arrays.fill(states, 0);
+
+        // If 0 or 1 total pages exist, all page indicators must remain hidden.
+        if (rangeSize < 2) {
+            return states;
+        }
+
+        // Initialize the visible page indicators to be dark.
+        Arrays.fill(states, 0, rangeSize, R.drawable.ic_swipe_circle_dark);
+
+        // If more pages exist before the first page indicator, make it a fade-in gradient.
+        if (rangeStart > 0) {
+            states[0] = R.drawable.ic_swipe_circle_top;
+        }
+
+        // If more pages exist after the last page indicator, make it a fade-out gradient.
+        if (rangeEnd < pageCount - 1) {
+            states[rangeSize - 1] = R.drawable.ic_swipe_circle_bottom;
+        }
+
+        // Set the indicator of the selected page to be light.
+        states[page - rangeStart] = R.drawable.ic_swipe_circle_light;
+
+        return states;
     }
 
     @Override
     public View onCreateView(LayoutInflater inflater, ViewGroup container,
-            Bundle savedInstanceState) {
+                             Bundle savedInstanceState) {
         final View view = inflater.inflate(R.layout.timer_fragment, container, false);
 
         mAdapter = new TimerPagerAdapter(getFragmentManager());
-        mViewPager = (ViewPager) view.findViewById(R.id.vertical_view_pager);
+        mViewPager = view.findViewById(R.id.vertical_view_pager);
         mViewPager.setAdapter(mAdapter);
         mViewPager.addOnPageChangeListener(mTimerPageChangeListener);
 
         mTimersView = view.findViewById(R.id.timer_view);
-        mCreateTimerView = (TimerSetupView) view.findViewById(R.id.timer_setup);
+        mCreateTimerView = view.findViewById(R.id.timer_setup);
         mCreateTimerView.setFabContainer(this);
-        mPageIndicators = new ImageView[] {
-                (ImageView) view.findViewById(R.id.page_indicator0),
-                (ImageView) view.findViewById(R.id.page_indicator1),
-                (ImageView) view.findViewById(R.id.page_indicator2),
-                (ImageView) view.findViewById(R.id.page_indicator3)
+        mPageIndicators = new ImageView[]{
+                view.findViewById(R.id.page_indicator0),
+                view.findViewById(R.id.page_indicator1),
+                view.findViewById(R.id.page_indicator2),
+                view.findViewById(R.id.page_indicator3)
         };
 
         DataModel.getDataModel().addTimerListener(mAdapter);
@@ -236,7 +302,6 @@ public final class TimerFragment extends DeskClockFragment {
         }
     }
 
-    
     private void updateFab(@NonNull ImageView fab) {
         if (mCurrentView == mTimersView) {
             final Timer timer = getTimer();
@@ -434,62 +499,6 @@ public final class TimerFragment extends DeskClockFragment {
         }
     }
 
-    /**
-     * @param page the selected page; value between 0 and {@code pageCount}
-     * @param pageIndicatorCount the number of indicators displaying the {@code page} location
-     * @param pageCount the number of pages that exist
-     * @return an array of length {@code pageIndicatorCount} specifying which image to display for
-     *      each page indicator or 0 if the page indicator should be hidden
-     */
-    @VisibleForTesting
-    static int[] computePageIndicatorStates(int page, int pageIndicatorCount, int pageCount) {
-        // Compute the number of page indicators that will be visible.
-        final int rangeSize = Math.min(pageIndicatorCount, pageCount);
-
-        // Compute the inclusive range of pages to indicate centered around the selected page.
-        int rangeStart = page - (rangeSize / 2);
-        int rangeEnd = rangeStart + rangeSize - 1;
-
-        // Clamp the range of pages if they extend beyond the last page.
-        if (rangeEnd >= pageCount) {
-            rangeEnd = pageCount - 1;
-            rangeStart = rangeEnd - rangeSize + 1;
-        }
-
-        // Clamp the range of pages if they extend beyond the first page.
-        if (rangeStart < 0) {
-            rangeStart = 0;
-            rangeEnd = rangeSize - 1;
-        }
-
-        // Build the result with all page indicators initially hidden.
-        final int[] states = new int[pageIndicatorCount];
-        Arrays.fill(states, 0);
-
-        // If 0 or 1 total pages exist, all page indicators must remain hidden.
-        if (rangeSize < 2) {
-            return states;
-        }
-
-        // Initialize the visible page indicators to be dark.
-        Arrays.fill(states, 0, rangeSize, R.drawable.ic_swipe_circle_dark);
-
-        // If more pages exist before the first page indicator, make it a fade-in gradient.
-        if (rangeStart > 0) {
-            states[0] = R.drawable.ic_swipe_circle_top;
-        }
-
-        // If more pages exist after the last page indicator, make it a fade-out gradient.
-        if (rangeEnd < pageCount - 1) {
-            states[rangeSize - 1] = R.drawable.ic_swipe_circle_bottom;
-        }
-
-        // Set the indicator of the selected page to be light.
-        states[page - rangeStart] = R.drawable.ic_swipe_circle_light;
-
-        return states;
-    }
-
     /**
      * Display the view that creates a new timer.
      */
@@ -556,13 +565,13 @@ public final class TimerFragment extends DeskClockFragment {
     }
 
     /**
-     * @param toView one of {@link #mTimersView} or {@link #mCreateTimerView}
+     * @param toView        one of {@link #mTimersView} or {@link #mCreateTimerView}
      * @param timerToRemove the timer to be removed during the animation; {@code null} if no timer
-     *      should be removed
-     * @param animateDown {@code true} if the views should animate upwards, otherwise downwards
+     *                      should be removed
+     * @param animateDown   {@code true} if the views should animate upwards, otherwise downwards
      */
     private void animateToView(final View toView, final Timer timerToRemove,
-            final boolean animateDown) {
+                               final boolean animateDown) {
         if (mCurrentView == toView) {
             return;
         }
diff --git a/src/com/android/deskclock/timer/TimerItem.java b/app/src/main/java/com/best/deskclock/timer/TimerItem.java
similarity index 74%
rename from src/com/android/deskclock/timer/TimerItem.java
rename to app/src/main/java/com/best/deskclock/timer/TimerItem.java
index 487ca236d..017486636 100644
--- a/src/com/android/deskclock/timer/TimerItem.java
+++ b/app/src/main/java/com/best/deskclock/timer/TimerItem.java
@@ -16,48 +16,60 @@
 
 package com.best.deskclock.timer;
 
+import static android.R.attr.state_activated;
+import static android.R.attr.state_pressed;
+
 import android.content.Context;
 import android.content.res.ColorStateList;
 import android.os.SystemClock;
-import androidx.core.view.ViewCompat;
 import android.text.TextUtils;
 import android.util.AttributeSet;
 import android.view.View;
-import android.view.ViewGroup;
 import android.widget.Button;
-import android.widget.LinearLayout;
 import android.widget.TextView;
 
+import androidx.constraintlayout.widget.ConstraintLayout;
+import androidx.core.view.ViewCompat;
+
 import com.best.deskclock.R;
 import com.best.deskclock.ThemeUtils;
 import com.best.deskclock.TimerTextController;
 import com.best.deskclock.Utils.ClickAccessibilityDelegate;
 import com.best.deskclock.data.Timer;
 
-import static android.R.attr.state_activated;
-import static android.R.attr.state_pressed;
-
 /**
  * This view is a visual representation of a {@link Timer}.
  */
-public class TimerItem extends LinearLayout {
+public class TimerItem extends ConstraintLayout {
 
-    /** Displays the remaining time or time since expiration. */
+    /**
+     * Displays the remaining time or time since expiration.
+     */
     private TextView mTimerText;
 
-    /** Formats and displays the text in the timer. */
+    /**
+     * Formats and displays the text in the timer.
+     */
     private TimerTextController mTimerTextController;
 
-    /** Displays timer progress as a color circle that changes from white to red. */
+    /**
+     * Displays timer progress as a color circle that changes from white to red.
+     */
     private TimerCircleView mCircleView;
 
-    /** A button that either resets the timer or adds time to it, depending on its state. */
+    /**
+     * A button that either resets the timer or adds time to it, depending on its state.
+     */
     private Button mResetAddButton;
 
-    /** Displays the label associated with the timer. Tapping it presents an edit dialog. */
+    /**
+     * Displays the label associated with the timer. Tapping it presents an edit dialog.
+     */
     private TextView mLabelView;
 
-    /** The last state of the timer that was rendered; used to avoid expensive operations. */
+    /**
+     * The last state of the timer that was rendered; used to avoid expensive operations.
+     */
     private Timer.State mLastState;
 
     public TimerItem(Context context) {
@@ -71,26 +83,18 @@ public class TimerItem extends LinearLayout {
     @Override
     protected void onFinishInflate() {
         super.onFinishInflate();
-        mLabelView = (TextView) findViewById(R.id.timer_label);
-
-        mResetAddButton = (Button) findViewById(R.id.reset_add);
-        mCircleView = (TimerCircleView) findViewById(R.id.timer_time);
-        mTimerText = (TextView) findViewById(R.id.timer_time_text);
+        mLabelView = findViewById(R.id.timer_label);
+        mResetAddButton = findViewById(R.id.reset_add);
+        mCircleView = findViewById(R.id.timer_time);
+        mTimerText = findViewById(R.id.timer_time_text);
         mTimerTextController = new TimerTextController(mTimerText);
 
         final Context c = mTimerText.getContext();
-        final int colorAccent = ThemeUtils.resolveColor(c, R.attr.colorAccent);
+        final int colorAccent = ThemeUtils.resolveColor(c, androidx.appcompat.R.attr.colorAccent);
         final int textColorPrimary = ThemeUtils.resolveColor(c, android.R.attr.textColorPrimary);
         mTimerText.setTextColor(new ColorStateList(
-                new int[][] { { -state_activated, -state_pressed }, {} },
-                new int[] { textColorPrimary, colorAccent }));
-
-        mLabelView.setBackground(ThemeUtils.resolveDrawable(c, android.R.attr.selectableItemBackgroundBorderless));
-        mLabelView.getLayoutParams().height=c.getResources().getDimensionPixelSize(R.dimen.timer_label_size);
-        mLabelView.getLayoutParams().width=c.getResources().getDimensionPixelSize(R.dimen.timer_label_size);
-        mResetAddButton.setBackground(ThemeUtils.resolveDrawable(c, android.R.attr.selectableItemBackgroundBorderless));
-        mResetAddButton.getLayoutParams().height=c.getResources().getDimensionPixelSize(R.dimen.timer_label_size);
-        mResetAddButton.getLayoutParams().width=c.getResources().getDimensionPixelSize(R.dimen.timer_label_size);
+                new int[][]{{-state_activated, -state_pressed}, {}},
+                new int[]{textColorPrimary, colorAccent}));
     }
 
     /**
@@ -125,10 +129,13 @@ public class TimerItem extends LinearLayout {
 
         // Update some potentially expensive areas of the user interface only on state changes.
         if (timer.getState() != mLastState) {
+            mResetAddButton.setVisibility(View.VISIBLE);
             mLastState = timer.getState();
             final Context context = getContext();
             switch (mLastState) {
                 case RESET:
+                    mResetAddButton.setVisibility(View.GONE);
+                    break;
                 case PAUSED: {
                     mResetAddButton.setText(R.string.timer_reset);
                     mResetAddButton.setContentDescription(null);
@@ -163,4 +170,4 @@ public class TimerItem extends LinearLayout {
             }
         }
     }
-}
+}
\ No newline at end of file
diff --git a/src/com/android/deskclock/timer/TimerItemFragment.java b/app/src/main/java/com/best/deskclock/timer/TimerItemFragment.java
similarity index 96%
rename from src/com/android/deskclock/timer/TimerItemFragment.java
rename to app/src/main/java/com/best/deskclock/timer/TimerItemFragment.java
index f4fd5dff1..608e3681a 100644
--- a/src/com/android/deskclock/timer/TimerItemFragment.java
+++ b/app/src/main/java/com/best/deskclock/timer/TimerItemFragment.java
@@ -23,7 +23,6 @@ import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 
-
 import com.best.deskclock.LabelDialogFragment;
 import com.best.deskclock.R;
 import com.best.deskclock.data.DataModel;
@@ -36,8 +35,11 @@ public class TimerItemFragment extends Fragment {
     private static final String KEY_TIMER_ID = "KEY_TIMER_ID";
     private int mTimerId;
 
-    /** The public no-arg constructor required by all fragments. */
-    public TimerItemFragment() {}
+    /**
+     * The public no-arg constructor required by all fragments.
+     */
+    public TimerItemFragment() {
+    }
 
     public static TimerItemFragment newInstance(Timer timer) {
         final TimerItemFragment fragment = new TimerItemFragment();
@@ -56,7 +58,7 @@ public class TimerItemFragment extends Fragment {
 
     @Override
     public View onCreateView(LayoutInflater inflater, ViewGroup container,
-            Bundle savedInstanceState) {
+                             Bundle savedInstanceState) {
         final Timer timer = getTimer();
         if (timer == null) {
             return null;
diff --git a/src/com/android/deskclock/timer/TimerKlaxon.java b/app/src/main/java/com/best/deskclock/timer/TimerKlaxon.java
similarity index 100%
rename from src/com/android/deskclock/timer/TimerKlaxon.java
rename to app/src/main/java/com/best/deskclock/timer/TimerKlaxon.java
diff --git a/src/com/android/deskclock/timer/TimerPagerAdapter.java b/app/src/main/java/com/best/deskclock/timer/TimerPagerAdapter.java
similarity index 86%
rename from src/com/android/deskclock/timer/TimerPagerAdapter.java
rename to app/src/main/java/com/best/deskclock/timer/TimerPagerAdapter.java
index dc85013fa..e9975cf81 100644
--- a/src/com/android/deskclock/timer/TimerPagerAdapter.java
+++ b/app/src/main/java/com/best/deskclock/timer/TimerPagerAdapter.java
@@ -20,12 +20,13 @@ import android.annotation.SuppressLint;
 import android.app.Fragment;
 import android.app.FragmentManager;
 import android.app.FragmentTransaction;
-import androidx.legacy.app.FragmentCompat;
-import androidx.viewpager.widget.PagerAdapter;
 import android.util.ArrayMap;
 import android.view.View;
 import android.view.ViewGroup;
 
+import androidx.annotation.NonNull;
+import androidx.legacy.app.FragmentCompat;
+import androidx.viewpager.widget.PagerAdapter;
 
 import com.best.deskclock.data.DataModel;
 import com.best.deskclock.data.Timer;
@@ -41,31 +42,42 @@ class TimerPagerAdapter extends PagerAdapter implements TimerListener {
 
     private final FragmentManager mFragmentManager;
 
-    /** Maps each timer id to the corresponding {@link TimerItemFragment} that draws it. */
+    /**
+     * Maps each timer id to the corresponding {@link TimerItemFragment} that draws it.
+     */
     private final Map<Integer, TimerItemFragment> mFragments = new ArrayMap<>();
 
-    /** The current fragment transaction in play or {@code null}. */
+    /**
+     * The current fragment transaction in play or {@code null}.
+     */
     private FragmentTransaction mCurrentTransaction;
 
-    /** The {@link TimerItemFragment} that is current visible on screen. */
+    /**
+     * The {@link TimerItemFragment} that is current visible on screen.
+     */
     private Fragment mCurrentPrimaryItem;
 
     public TimerPagerAdapter(FragmentManager fragmentManager) {
         mFragmentManager = fragmentManager;
     }
 
+    private static void setItemVisible(Fragment item, boolean visible) {
+        FragmentCompat.setMenuVisibility(item, visible);
+        FragmentCompat.setUserVisibleHint(item, visible);
+    }
+
     @Override
     public int getCount() {
         return getTimers().size();
     }
 
     @Override
-    public boolean isViewFromObject(View view, Object object) {
+    public boolean isViewFromObject(@NonNull View view, @NonNull Object object) {
         return ((Fragment) object).getView() == view;
     }
 
     @Override
-    public int getItemPosition(Object object) {
+    public int getItemPosition(@NonNull Object object) {
         final TimerItemFragment fragment = (TimerItemFragment) object;
         final Timer timer = fragment.getTimer();
 
@@ -73,9 +85,10 @@ class TimerPagerAdapter extends PagerAdapter implements TimerListener {
         return position == -1 ? POSITION_NONE : position;
     }
 
+    @NonNull
     @Override
     @SuppressLint("CommitTransaction")
-    public Fragment instantiateItem(ViewGroup container, int position) {
+    public Fragment instantiateItem(@NonNull ViewGroup container, int position) {
         if (mCurrentTransaction == null) {
             mCurrentTransaction = mFragmentManager.beginTransaction();
         }
@@ -106,7 +119,7 @@ class TimerPagerAdapter extends PagerAdapter implements TimerListener {
 
     @Override
     @SuppressLint("CommitTransaction")
-    public void destroyItem(ViewGroup container, int position, Object object) {
+    public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) {
         final TimerItemFragment fragment = (TimerItemFragment) object;
 
         if (mCurrentTransaction == null) {
@@ -118,7 +131,7 @@ class TimerPagerAdapter extends PagerAdapter implements TimerListener {
     }
 
     @Override
-    public void setPrimaryItem(ViewGroup container, int position, Object object) {
+    public void setPrimaryItem(@NonNull ViewGroup container, int position, @NonNull Object object) {
         final Fragment fragment = (Fragment) object;
         if (fragment != mCurrentPrimaryItem) {
             if (mCurrentPrimaryItem != null) {
@@ -134,7 +147,7 @@ class TimerPagerAdapter extends PagerAdapter implements TimerListener {
     }
 
     @Override
-    public void finishUpdate(ViewGroup container) {
+    public void finishUpdate(@NonNull ViewGroup container) {
         if (mCurrentTransaction != null) {
             mCurrentTransaction.commitAllowingStateLoss();
             mCurrentTransaction = null;
@@ -181,9 +194,4 @@ class TimerPagerAdapter extends PagerAdapter implements TimerListener {
     private List<Timer> getTimers() {
         return DataModel.getDataModel().getTimers();
     }
-
-    private static void setItemVisible(Fragment item, boolean visible) {
-        FragmentCompat.setMenuVisibility(item, visible);
-        FragmentCompat.setUserVisibleHint(item, visible);
-    }
 }
diff --git a/src/com/android/deskclock/timer/TimerReceiver.java b/app/src/main/java/com/best/deskclock/timer/TimerReceiver.java
similarity index 100%
rename from src/com/android/deskclock/timer/TimerReceiver.java
rename to app/src/main/java/com/best/deskclock/timer/TimerReceiver.java
diff --git a/src/com/android/deskclock/timer/TimerService.java b/app/src/main/java/com/best/deskclock/timer/TimerService.java
similarity index 91%
rename from src/com/android/deskclock/timer/TimerService.java
rename to app/src/main/java/com/best/deskclock/timer/TimerService.java
index c81c7f088..7a1fa5bee 100644
--- a/src/com/android/deskclock/timer/TimerService.java
+++ b/app/src/main/java/com/best/deskclock/timer/TimerService.java
@@ -16,6 +16,8 @@
 
 package com.best.deskclock.timer;
 
+import static com.best.deskclock.uidata.UiDataModel.Tab.TIMERS;
+
 import android.app.Service;
 import android.content.Context;
 import android.content.Intent;
@@ -28,8 +30,6 @@ import com.best.deskclock.data.Timer;
 import com.best.deskclock.events.Events;
 import com.best.deskclock.uidata.UiDataModel;
 
-import static com.best.deskclock.uidata.UiDataModel.Tab.TIMERS;
-
 /**
  * <p>This service exists solely to allow {@link android.app.AlarmManager} and timer notifications
  * to alter the state of timers without disturbing the notification shade. If an activity were used
@@ -43,22 +43,31 @@ import static com.best.deskclock.uidata.UiDataModel.Tab.TIMERS;
  */
 public final class TimerService extends Service {
 
+    /**
+     * Extra for many actions specific to a given timer.
+     */
+    public static final String EXTRA_TIMER_ID = "com.best.deskclock.extra.TIMER_ID";
     private static final String ACTION_PREFIX = "com.best.deskclock.action.";
-
-    /** Shows the tab with timers; scrolls to a specific timer. */
+    /**
+     * Shows the tab with timers; scrolls to a specific timer.
+     */
     public static final String ACTION_SHOW_TIMER = ACTION_PREFIX + "SHOW_TIMER";
-    /** Pauses running timers; resets expired timers. */
+    /**
+     * Pauses running timers; resets expired timers.
+     */
     public static final String ACTION_PAUSE_TIMER = ACTION_PREFIX + "PAUSE_TIMER";
-    /** Starts the sole timer. */
+    /**
+     * Starts the sole timer.
+     */
     public static final String ACTION_START_TIMER = ACTION_PREFIX + "START_TIMER";
-    /** Resets the timer. */
+    /**
+     * Resets the timer.
+     */
     public static final String ACTION_RESET_TIMER = ACTION_PREFIX + "RESET_TIMER";
-    /** Adds an extra minute to the timer. */
+    /**
+     * Adds an extra minute to the timer.
+     */
     public static final String ACTION_ADD_MINUTE_TIMER = ACTION_PREFIX + "ADD_MINUTE_TIMER";
-
-    /** Extra for many actions specific to a given timer. */
-    public static final String EXTRA_TIMER_ID = "com.best.deskclock.extra.TIMER_ID";
-
     private static final String ACTION_TIMER_EXPIRED =
             ACTION_PREFIX + "TIMER_EXPIRED";
     private static final String ACTION_UPDATE_NOTIFICATION =
@@ -157,22 +166,27 @@ public final class TimerService extends Service {
                             .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                     startActivity(showTimers);
                     break;
-                } case ACTION_START_TIMER: {
+                }
+                case ACTION_START_TIMER: {
                     Events.sendTimerEvent(R.string.action_start, label);
                     DataModel.getDataModel().startTimer(this, timer);
                     break;
-                } case ACTION_PAUSE_TIMER: {
+                }
+                case ACTION_PAUSE_TIMER: {
                     Events.sendTimerEvent(R.string.action_pause, label);
                     DataModel.getDataModel().pauseTimer(timer);
                     break;
-                } case ACTION_ADD_MINUTE_TIMER: {
+                }
+                case ACTION_ADD_MINUTE_TIMER: {
                     Events.sendTimerEvent(R.string.action_add_minute, label);
                     DataModel.getDataModel().addTimerMinute(timer);
                     break;
-                } case ACTION_RESET_TIMER: {
+                }
+                case ACTION_RESET_TIMER: {
                     DataModel.getDataModel().resetOrDeleteTimer(timer, label);
                     break;
-                } case ACTION_TIMER_EXPIRED: {
+                }
+                case ACTION_TIMER_EXPIRED: {
                     Events.sendTimerEvent(R.string.action_fire, label);
                     DataModel.getDataModel().expireTimer(this, timer);
                     break;
diff --git a/src/com/android/deskclock/timer/TimerSetupView.java b/app/src/main/java/com/best/deskclock/timer/TimerSetupView.java
similarity index 90%
rename from src/com/android/deskclock/timer/TimerSetupView.java
rename to app/src/main/java/com/best/deskclock/timer/TimerSetupView.java
index de35d6a70..c068743aa 100644
--- a/src/com/android/deskclock/timer/TimerSetupView.java
+++ b/app/src/main/java/com/best/deskclock/timer/TimerSetupView.java
@@ -16,13 +16,11 @@
 
 package com.best.deskclock.timer;
 
+import static com.best.deskclock.FabContainer.FAB_REQUEST_FOCUS;
+import static com.best.deskclock.FabContainer.FAB_SHRINK_AND_EXPAND;
+
 import android.content.Context;
-import android.content.res.ColorStateList;
 import android.content.res.Resources;
-import android.graphics.PorterDuff;
-import androidx.annotation.IdRes;
-import androidx.core.view.ViewCompat;
-
 import android.os.Vibrator;
 import android.text.BidiFormatter;
 import android.text.TextUtils;
@@ -35,34 +33,30 @@ import android.view.View;
 import android.widget.LinearLayout;
 import android.widget.TextView;
 
+import androidx.annotation.IdRes;
+
 import com.best.deskclock.FabContainer;
 import com.best.deskclock.FormattedTextUtils;
 import com.best.deskclock.R;
-import com.best.deskclock.ThemeUtils;
 import com.best.deskclock.uidata.UiDataModel;
 
 import java.io.Serializable;
 import java.util.Arrays;
 
-import static com.best.deskclock.FabContainer.FAB_REQUEST_FOCUS;
-import static com.best.deskclock.FabContainer.FAB_SHRINK_AND_EXPAND;
-
 public class TimerSetupView extends LinearLayout implements View.OnClickListener,
         View.OnLongClickListener {
 
-    private final int[] mInput = { 0, 0, 0, 0, 0, 0 };
-
+    final Vibrator vibrator = (Vibrator) getContext().getSystemService(Context.VIBRATOR_SERVICE);
+    private final int[] mInput = {0, 0, 0, 0, 0, 0};
+    private final CharSequence mTimeTemplate;
     private int mInputPointer = -1;
-    private CharSequence mTimeTemplate;
-
     private TextView mTimeView;
     private View mDeleteView;
     private View mDigitViews00;
     private TextView[] mDigitViews;
-
-    final Vibrator vibrator = (Vibrator) getContext().getSystemService(Context.VIBRATOR_SERVICE);
-
-    /** Updates to the fab are requested via this container. */
+    /**
+     * Updates to the fab are requested via this container.
+     */
     private FabContainer mFabContainer;
 
     public TimerSetupView(Context context) {
@@ -93,20 +87,20 @@ public class TimerSetupView extends LinearLayout implements View.OnClickListener
     protected void onFinishInflate() {
         super.onFinishInflate();
 
-        mTimeView = (TextView) findViewById(R.id.timer_setup_time);
+        mTimeView = findViewById(R.id.timer_setup_time);
         mDeleteView = findViewById(R.id.timer_setup_delete);
         mDigitViews00 = findViewById(R.id.timer_setup_digit_00);
-        mDigitViews = new TextView[] {
-                (TextView) findViewById(R.id.timer_setup_digit_0),
-                (TextView) findViewById(R.id.timer_setup_digit_1),
-                (TextView) findViewById(R.id.timer_setup_digit_2),
-                (TextView) findViewById(R.id.timer_setup_digit_3),
-                (TextView) findViewById(R.id.timer_setup_digit_4),
-                (TextView) findViewById(R.id.timer_setup_digit_5),
-                (TextView) findViewById(R.id.timer_setup_digit_6),
-                (TextView) findViewById(R.id.timer_setup_digit_7),
-                (TextView) findViewById(R.id.timer_setup_digit_8),
-                (TextView) findViewById(R.id.timer_setup_digit_9),
+        mDigitViews = new TextView[]{
+                findViewById(R.id.timer_setup_digit_0),
+                findViewById(R.id.timer_setup_digit_1),
+                findViewById(R.id.timer_setup_digit_2),
+                findViewById(R.id.timer_setup_digit_3),
+                findViewById(R.id.timer_setup_digit_4),
+                findViewById(R.id.timer_setup_digit_5),
+                findViewById(R.id.timer_setup_digit_6),
+                findViewById(R.id.timer_setup_digit_7),
+                findViewById(R.id.timer_setup_digit_8),
+                findViewById(R.id.timer_setup_digit_9),
         };
 
         // Initialize the digit buttons.
@@ -153,7 +147,7 @@ public class TimerSetupView extends LinearLayout implements View.OnClickListener
     public void onClick(View view) {
         if (view == mDeleteView) {
             delete();
-        } else if (view == mDigitViews00){
+        } else if (view == mDigitViews00) {
             append(0);
             append(0);
         } else {
diff --git a/src/com/android/deskclock/uidata/FormattedStringModel.java b/app/src/main/java/com/best/deskclock/uidata/FormattedStringModel.java
similarity index 80%
rename from src/com/android/deskclock/uidata/FormattedStringModel.java
rename to app/src/main/java/com/best/deskclock/uidata/FormattedStringModel.java
index e4bfac86e..006fd2b65 100644
--- a/src/com/android/deskclock/uidata/FormattedStringModel.java
+++ b/app/src/main/java/com/best/deskclock/uidata/FormattedStringModel.java
@@ -16,6 +16,8 @@
 
 package com.best.deskclock.uidata;
 
+import static java.util.Calendar.JULY;
+
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
@@ -29,14 +31,14 @@ import java.util.GregorianCalendar;
 import java.util.Locale;
 import java.util.Map;
 
-import static java.util.Calendar.JULY;
-
 /**
  * All formatted strings that are cached for performance are accessed via this model.
  */
 final class FormattedStringModel {
 
-    /** Clears data structures containing data that is locale-sensitive. */
+    /**
+     * Clears data structures containing data that is locale-sensitive.
+     */
     @SuppressWarnings("FieldCanBeLocal")
     private final BroadcastReceiver mLocaleChangedReceiver = new LocaleChangedReceiver();
 
@@ -47,10 +49,14 @@ final class FormattedStringModel {
      */
     private final SparseArray<SparseArray<String>> mNumberFormatCache = new SparseArray<>(3);
 
-    /** Single-character version of weekday names; e.g.: 'S', 'M', 'T', 'W', 'T', 'F', 'S' */
+    /**
+     * Single-character version of weekday names; e.g.: 'S', 'M', 'T', 'W', 'T', 'F', 'S'
+     */
     private Map<Integer, String> mShortWeekdayNames;
 
-    /** Full weekday names; e.g.: 'Sunday', 'Monday', 'Tuesday', etc. */
+    /**
+     * Full weekday names; e.g.: 'Sunday', 'Monday', 'Tuesday', etc.
+     */
     private Map<Integer, String> mLongWeekdayNames;
 
     FormattedStringModel(Context context) {
@@ -78,10 +84,10 @@ final class FormattedStringModel {
      * update loop of a timer or stopwatch. It returns cached results when possible in order to
      * provide speed and limit garbage to be collected by the virtual machine.
      *
-     * @param value a positive integer to format as a String
+     * @param value  a positive integer to format as a String
      * @param length the length of the String; zeroes are padded to match this length
      * @return the {@code value} formatted as a String in the current locale and padded to the
-     *      requested {@code length}
+     * requested {@code length}
      * @throws IllegalArgumentException if {@code value} is negative
      */
     String getFormattedNumber(int value, int length) {
@@ -94,12 +100,12 @@ final class FormattedStringModel {
      * provide speed and limit garbage to be collected by the virtual machine.
      *
      * @param negative force a minus sign (-) onto the display, even if {@code value} is {@code 0}
-     * @param value a positive integer to format as a String
-     * @param length the length of the String; zeroes are padded to match this length. If
-     *      {@code negative} is {@code true} the return value will contain a minus sign and a total
-     *      length of {@code length + 1}.
+     * @param value    a positive integer to format as a String
+     * @param length   the length of the String; zeroes are padded to match this length. If
+     *                 {@code negative} is {@code true} the return value will contain a minus sign and a total
+     *                 length of {@code length + 1}.
      * @return the {@code value} formatted as a String in the current locale and padded to the
-     *      requested {@code length}
+     * requested {@code length}
      * @throws IllegalArgumentException if {@code value} is negative
      */
     String getFormattedNumber(boolean negative, int value, int length) {
@@ -128,15 +134,15 @@ final class FormattedStringModel {
 
     /**
      * @param calendarDay any of the following values
-     *                     <ul>
-     *                     <li>{@link Calendar#SUNDAY}</li>
-     *                     <li>{@link Calendar#MONDAY}</li>
-     *                     <li>{@link Calendar#TUESDAY}</li>
-     *                     <li>{@link Calendar#WEDNESDAY}</li>
-     *                     <li>{@link Calendar#THURSDAY}</li>
-     *                     <li>{@link Calendar#FRIDAY}</li>
-     *                     <li>{@link Calendar#SATURDAY}</li>
-     *                     </ul>
+     *                    <ul>
+     *                    <li>{@link Calendar#SUNDAY}</li>
+     *                    <li>{@link Calendar#MONDAY}</li>
+     *                    <li>{@link Calendar#TUESDAY}</li>
+     *                    <li>{@link Calendar#WEDNESDAY}</li>
+     *                    <li>{@link Calendar#THURSDAY}</li>
+     *                    <li>{@link Calendar#FRIDAY}</li>
+     *                    <li>{@link Calendar#SATURDAY}</li>
+     *                    </ul>
      * @return single-character weekday name; e.g.: 'S', 'M', 'T', 'W', 'T', 'F', 'S'
      */
     String getShortWeekday(int calendarDay) {
@@ -156,15 +162,15 @@ final class FormattedStringModel {
 
     /**
      * @param calendarDay any of the following values
-     *                     <ul>
-     *                     <li>{@link Calendar#SUNDAY}</li>
-     *                     <li>{@link Calendar#MONDAY}</li>
-     *                     <li>{@link Calendar#TUESDAY}</li>
-     *                     <li>{@link Calendar#WEDNESDAY}</li>
-     *                     <li>{@link Calendar#THURSDAY}</li>
-     *                     <li>{@link Calendar#FRIDAY}</li>
-     *                     <li>{@link Calendar#SATURDAY}</li>
-     *                     </ul>
+     *                    <ul>
+     *                    <li>{@link Calendar#SUNDAY}</li>
+     *                    <li>{@link Calendar#MONDAY}</li>
+     *                    <li>{@link Calendar#TUESDAY}</li>
+     *                    <li>{@link Calendar#WEDNESDAY}</li>
+     *                    <li>{@link Calendar#THURSDAY}</li>
+     *                    <li>{@link Calendar#FRIDAY}</li>
+     *                    <li>{@link Calendar#SATURDAY}</li>
+     *                    </ul>
      * @return full weekday name; e.g.: 'Sunday', 'Monday', 'Tuesday', etc.
      */
     String getLongWeekday(int calendarDay) {
diff --git a/src/com/android/deskclock/uidata/PeriodicCallbackModel.java b/app/src/main/java/com/best/deskclock/uidata/PeriodicCallbackModel.java
similarity index 94%
rename from src/com/android/deskclock/uidata/PeriodicCallbackModel.java
rename to app/src/main/java/com/best/deskclock/uidata/PeriodicCallbackModel.java
index a8ba8396f..019d36581 100644
--- a/src/com/android/deskclock/uidata/PeriodicCallbackModel.java
+++ b/app/src/main/java/com/best/deskclock/uidata/PeriodicCallbackModel.java
@@ -16,11 +16,24 @@
 
 package com.best.deskclock.uidata;
 
+import static android.content.Intent.ACTION_DATE_CHANGED;
+import static android.content.Intent.ACTION_TIMEZONE_CHANGED;
+import static android.content.Intent.ACTION_TIME_CHANGED;
+import static android.text.format.DateUtils.HOUR_IN_MILLIS;
+import static android.text.format.DateUtils.MINUTE_IN_MILLIS;
+import static com.best.deskclock.Utils.enforceMainLooper;
+import static java.util.Calendar.DATE;
+import static java.util.Calendar.HOUR_OF_DAY;
+import static java.util.Calendar.MILLISECOND;
+import static java.util.Calendar.MINUTE;
+import static java.util.Calendar.SECOND;
+
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.os.Handler;
+
 import androidx.annotation.VisibleForTesting;
 
 import com.best.deskclock.LogUtils;
@@ -29,18 +42,6 @@ import java.util.Calendar;
 import java.util.List;
 import java.util.concurrent.CopyOnWriteArrayList;
 
-import static android.content.Intent.ACTION_DATE_CHANGED;
-import static android.content.Intent.ACTION_TIMEZONE_CHANGED;
-import static android.content.Intent.ACTION_TIME_CHANGED;
-import static android.text.format.DateUtils.HOUR_IN_MILLIS;
-import static android.text.format.DateUtils.MINUTE_IN_MILLIS;
-import static com.best.deskclock.Utils.enforceMainLooper;
-import static java.util.Calendar.DATE;
-import static java.util.Calendar.HOUR_OF_DAY;
-import static java.util.Calendar.MILLISECOND;
-import static java.util.Calendar.MINUTE;
-import static java.util.Calendar.SECOND;
-
 /**
  * All callbacks to be delivered at requested times on the main thread if the application is in the
  * foreground when the callback time passes.
@@ -48,18 +49,13 @@ import static java.util.Calendar.SECOND;
 final class PeriodicCallbackModel {
 
     private static final LogUtils.Logger LOGGER = new LogUtils.Logger("Periodic");
-
-    @VisibleForTesting
-    enum Period {MINUTE, QUARTER_HOUR, HOUR, MIDNIGHT}
-
     private static final long QUARTER_HOUR_IN_MILLIS = 15 * MINUTE_IN_MILLIS;
-
     private static Handler sHandler;
-
-    /** Reschedules callbacks when the device time changes. */
+    /**
+     * Reschedules callbacks when the device time changes.
+     */
     @SuppressWarnings("FieldCanBeLocal")
     private final BroadcastReceiver mTimeChangedReceiver = new TimeChangedReceiver();
-
     private final List<PeriodicRunnable> mPeriodicRunnables = new CopyOnWriteArrayList<>();
 
     PeriodicCallbackModel(Context context) {
@@ -71,9 +67,61 @@ final class PeriodicCallbackModel {
         context.registerReceiver(mTimeChangedReceiver, timeChangedBroadcastFilter);
     }
 
+    /**
+     * Return the delay until the given {@code period} elapses adjusted by the given {@code offset}.
+     *
+     * @param now    the current time
+     * @param period the frequency with which callbacks should be given
+     * @param offset an offset to add to the normal period; allows the callback to be made relative
+     *               to the normally scheduled period end
+     * @return the time delay from {@code now} to schedule the callback
+     */
+    @VisibleForTesting
+    static long getDelay(long now, Period period, long offset) {
+        final long periodStart = now - offset;
+
+        switch (period) {
+            case MINUTE:
+                final long lastMinute = periodStart - (periodStart % MINUTE_IN_MILLIS);
+                final long nextMinute = lastMinute + MINUTE_IN_MILLIS;
+                return nextMinute - now + offset;
+
+            case QUARTER_HOUR:
+                final long lastQuarterHour = periodStart - (periodStart % QUARTER_HOUR_IN_MILLIS);
+                final long nextQuarterHour = lastQuarterHour + QUARTER_HOUR_IN_MILLIS;
+                return nextQuarterHour - now + offset;
+
+            case HOUR:
+                final long lastHour = periodStart - (periodStart % HOUR_IN_MILLIS);
+                final long nextHour = lastHour + HOUR_IN_MILLIS;
+                return nextHour - now + offset;
+
+            case MIDNIGHT:
+                final Calendar nextMidnight = Calendar.getInstance();
+                nextMidnight.setTimeInMillis(periodStart);
+                nextMidnight.add(DATE, 1);
+                nextMidnight.set(HOUR_OF_DAY, 0);
+                nextMidnight.set(MINUTE, 0);
+                nextMidnight.set(SECOND, 0);
+                nextMidnight.set(MILLISECOND, 0);
+                return nextMidnight.getTimeInMillis() - now + offset;
+
+            default:
+                throw new IllegalArgumentException("unexpected period: " + period);
+        }
+    }
+
+    private static Handler getHandler() {
+        enforceMainLooper();
+        if (sHandler == null) {
+            sHandler = new Handler();
+        }
+        return sHandler;
+    }
+
     /**
      * @param runnable to be called every minute
-     * @param offset an offset applied to the minute to control when the callback occurs
+     * @param offset   an offset applied to the minute to control when the callback occurs
      */
     void addMinuteCallback(Runnable runnable, long offset) {
         addPeriodicCallback(runnable, Period.MINUTE, offset);
@@ -81,7 +129,7 @@ final class PeriodicCallbackModel {
 
     /**
      * @param runnable to be called every quarter-hour
-     * @param offset an offset applied to the quarter-hour to control when the callback occurs
+     * @param offset   an offset applied to the quarter-hour to control when the callback occurs
      */
     void addQuarterHourCallback(Runnable runnable, long offset) {
         addPeriodicCallback(runnable, Period.QUARTER_HOUR, offset);
@@ -89,7 +137,7 @@ final class PeriodicCallbackModel {
 
     /**
      * @param runnable to be called every hour
-     * @param offset an offset applied to the hour to control when the callback occurs
+     * @param offset   an offset applied to the hour to control when the callback occurs
      */
     void addHourCallback(Runnable runnable, long offset) {
         addPeriodicCallback(runnable, Period.HOUR, offset);
@@ -97,7 +145,7 @@ final class PeriodicCallbackModel {
 
     /**
      * @param runnable to be called every midnight
-     * @param offset an offset applied to the midnight to control when the callback occurs
+     * @param offset   an offset applied to the midnight to control when the callback occurs
      */
     void addMidnightCallback(Runnable runnable, long offset) {
         addPeriodicCallback(runnable, Period.MIDNIGHT, offset);
@@ -125,57 +173,8 @@ final class PeriodicCallbackModel {
         }
     }
 
-    /**
-     * Return the delay until the given {@code period} elapses adjusted by the given {@code offset}.
-     *
-     * @param now the current time
-     * @param period the frequency with which callbacks should be given
-     * @param offset an offset to add to the normal period; allows the callback to be made relative
-     *      to the normally scheduled period end
-     * @return the time delay from {@code now} to schedule the callback
-     */
     @VisibleForTesting
-    static long getDelay(long now, Period period, long offset) {
-        final long periodStart = now - offset;
-
-        switch (period) {
-            case MINUTE:
-                final long lastMinute = periodStart - (periodStart % MINUTE_IN_MILLIS);
-                final long nextMinute = lastMinute + MINUTE_IN_MILLIS;
-                return nextMinute - now + offset;
-
-            case QUARTER_HOUR:
-                final long lastQuarterHour = periodStart - (periodStart % QUARTER_HOUR_IN_MILLIS);
-                final long nextQuarterHour = lastQuarterHour + QUARTER_HOUR_IN_MILLIS;
-                return nextQuarterHour - now + offset;
-
-            case HOUR:
-                final long lastHour = periodStart - (periodStart % HOUR_IN_MILLIS);
-                final long nextHour = lastHour + HOUR_IN_MILLIS;
-                return nextHour - now + offset;
-
-            case MIDNIGHT:
-                final Calendar nextMidnight = Calendar.getInstance();
-                nextMidnight.setTimeInMillis(periodStart);
-                nextMidnight.add(DATE, 1);
-                nextMidnight.set(HOUR_OF_DAY, 0);
-                nextMidnight.set(MINUTE, 0);
-                nextMidnight.set(SECOND, 0);
-                nextMidnight.set(MILLISECOND, 0);
-                return nextMidnight.getTimeInMillis() - now + offset;
-
-            default:
-                throw new IllegalArgumentException("unexpected period: " + period);
-        }
-    }
-
-    private static Handler getHandler() {
-        enforceMainLooper();
-        if (sHandler == null) {
-            sHandler = new Handler();
-        }
-        return sHandler;
-    }
+    enum Period {MINUTE, QUARTER_HOUR, HOUR, MIDNIGHT}
 
     /**
      * Schedules the execution of the given delegate Runnable at the next callback time.
diff --git a/src/com/android/deskclock/uidata/TabDAO.java b/app/src/main/java/com/best/deskclock/uidata/TabDAO.java
similarity index 92%
rename from src/com/android/deskclock/uidata/TabDAO.java
rename to app/src/main/java/com/best/deskclock/uidata/TabDAO.java
index ef6946fa5..ff2433da9 100644
--- a/src/com/android/deskclock/uidata/TabDAO.java
+++ b/app/src/main/java/com/best/deskclock/uidata/TabDAO.java
@@ -16,19 +16,22 @@
 
 package com.best.deskclock.uidata;
 
-import android.content.SharedPreferences;
-
 import static com.best.deskclock.uidata.UiDataModel.Tab;
 
+import android.content.SharedPreferences;
+
 /**
  * This class encapsulates the storage of tab data in {@link SharedPreferences}.
  */
 final class TabDAO {
 
-    /** Key to a preference that stores the ordinal of the selected tab. */
+    /**
+     * Key to a preference that stores the ordinal of the selected tab.
+     */
     private static final String KEY_SELECTED_TAB = "selected_tab";
 
-    private TabDAO() {}
+    private TabDAO() {
+    }
 
     /**
      * @return an enumerated value indicating the currently selected primary tab
diff --git a/src/com/android/deskclock/uidata/TabListener.java b/app/src/main/java/com/best/deskclock/uidata/TabListener.java
similarity index 100%
rename from src/com/android/deskclock/uidata/TabListener.java
rename to app/src/main/java/com/best/deskclock/uidata/TabListener.java
diff --git a/src/com/android/deskclock/uidata/TabModel.java b/app/src/main/java/com/best/deskclock/uidata/TabModel.java
similarity index 92%
rename from src/com/android/deskclock/uidata/TabModel.java
rename to app/src/main/java/com/best/deskclock/uidata/TabModel.java
index 7e101bbc7..458c18fd1 100644
--- a/src/com/android/deskclock/uidata/TabModel.java
+++ b/app/src/main/java/com/best/deskclock/uidata/TabModel.java
@@ -16,6 +16,9 @@
 
 package com.best.deskclock.uidata;
 
+import static android.view.View.LAYOUT_DIRECTION_RTL;
+import static com.best.deskclock.uidata.UiDataModel.Tab;
+
 import android.content.SharedPreferences;
 import android.text.TextUtils;
 
@@ -24,9 +27,6 @@ import java.util.Arrays;
 import java.util.List;
 import java.util.Locale;
 
-import static android.view.View.LAYOUT_DIRECTION_RTL;
-import static com.best.deskclock.uidata.UiDataModel.Tab;
-
 /**
  * All tab data is accessed via this model.
  */
@@ -34,16 +34,24 @@ final class TabModel {
 
     private final SharedPreferences mPrefs;
 
-    /** The listeners to notify when the selected tab is changed. */
+    /**
+     * The listeners to notify when the selected tab is changed.
+     */
     private final List<TabListener> mTabListeners = new ArrayList<>();
 
-    /** The listeners to notify when the vertical scroll state of the selected tab is changed. */
+    /**
+     * The listeners to notify when the vertical scroll state of the selected tab is changed.
+     */
     private final List<TabScrollListener> mTabScrollListeners = new ArrayList<>();
 
-    /** The scrolled-to-top state of each tab. */
+    /**
+     * The scrolled-to-top state of each tab.
+     */
     private final boolean[] mTabScrolledToTop = new boolean[Tab.values().length];
 
-    /** An enumerated value indicating the currently selected tab. */
+    /**
+     * An enumerated value indicating the currently selected tab.
+     */
     private Tab mSelectedTab;
 
     TabModel(SharedPreferences prefs) {
@@ -153,7 +161,7 @@ final class TabModel {
     /**
      * Updates the scrolling state in the {@link UiDataModel} for this tab.
      *
-     * @param tab an enumerated value indicating the tab reporting its vertical scroll position
+     * @param tab           an enumerated value indicating the tab reporting its vertical scroll position
      * @param scrolledToTop {@code true} iff the vertical scroll position of this tab is at the top
      */
     void setTabScrolledToTop(Tab tab, boolean scrolledToTop) {
diff --git a/src/com/android/deskclock/uidata/TabScrollListener.java b/app/src/main/java/com/best/deskclock/uidata/TabScrollListener.java
similarity index 94%
rename from src/com/android/deskclock/uidata/TabScrollListener.java
rename to app/src/main/java/com/best/deskclock/uidata/TabScrollListener.java
index 0e5ab13a0..c772363df 100644
--- a/src/com/android/deskclock/uidata/TabScrollListener.java
+++ b/app/src/main/java/com/best/deskclock/uidata/TabScrollListener.java
@@ -31,7 +31,7 @@ import com.best.deskclock.uidata.UiDataModel.Tab;
 public interface TabScrollListener {
 
     /**
-     * @param selectedTab an enumerated value indicating the current selected tab
+     * @param selectedTab   an enumerated value indicating the current selected tab
      * @param scrolledToTop indicates whether the current selected tab is scrolled to its top
      */
     void selectedTabScrollToTopChanged(Tab selectedTab, boolean scrolledToTop);
diff --git a/src/com/android/deskclock/uidata/UiDataModel.java b/app/src/main/java/com/best/deskclock/uidata/UiDataModel.java
similarity index 79%
rename from src/com/android/deskclock/uidata/UiDataModel.java
rename to app/src/main/java/com/best/deskclock/uidata/UiDataModel.java
index 88d7981bb..8ea87546c 100644
--- a/src/com/android/deskclock/uidata/UiDataModel.java
+++ b/app/src/main/java/com/best/deskclock/uidata/UiDataModel.java
@@ -16,9 +16,12 @@
 
 package com.best.deskclock.uidata;
 
+import static com.best.deskclock.Utils.enforceMainLooper;
+
 import android.content.Context;
 import android.content.SharedPreferences;
 import android.graphics.Typeface;
+
 import androidx.annotation.IntegerRes;
 import androidx.annotation.StringRes;
 
@@ -30,54 +33,35 @@ import com.best.deskclock.timer.TimerFragment;
 
 import java.util.Calendar;
 
-import static com.best.deskclock.Utils.enforceMainLooper;
-
 /**
  * All application-wide user interface data is accessible through this singleton.
  */
 public final class UiDataModel {
 
-    /** Identifies each of the primary tabs within the application. */
-    public enum Tab {
-        ALARMS(AlarmClockFragment.class, R.id.page_alarm, R.string.menu_alarm),
-        CLOCKS(ClockFragment.class, R.id.page_clock, R.string.menu_clock),
-        TIMERS(TimerFragment.class, R.id.page_timer, R.string.menu_timer),
-        STOPWATCH(StopwatchFragment.class, R.id.page_stopwatch, R.string.menu_stopwatch);
-
-        private final String mFragmentClassName;
-        private final @IntegerRes int mPageResId;
-        private final @StringRes int mLabelResId;
-
-        Tab(Class fragmentClass, @IntegerRes int pageResId, @StringRes int labelResId) {
-            mFragmentClassName = fragmentClass.getName();
-            mPageResId = pageResId;
-            mLabelResId = labelResId;
-        }
-
-        public String getFragmentClassName() { return mFragmentClassName; }
-        public @IntegerRes int getPageResId() { return mPageResId; }
-        public @StringRes int getLabelResId() { return mLabelResId; }
-    }
-
-    /** The single instance of this data model that exists for the life of the application. */
+    /**
+     * The single instance of this data model that exists for the life of the application.
+     */
     private static final UiDataModel sUiDataModel = new UiDataModel();
-
-    public static UiDataModel getUiDataModel() {
-        return sUiDataModel;
-    }
-
     private Context mContext;
-
-    /** The model from which tab data are fetched. */
+    /**
+     * The model from which tab data are fetched.
+     */
     private TabModel mTabModel;
-
-    /** The model from which formatted strings are fetched. */
+    /**
+     * The model from which formatted strings are fetched.
+     */
     private FormattedStringModel mFormattedStringModel;
-
-    /** The model from which timed callbacks originate. */
+    /**
+     * The model from which timed callbacks originate.
+     */
     private PeriodicCallbackModel mPeriodicCallbackModel;
 
-    private UiDataModel() {}
+    private UiDataModel() {
+    }
+
+    public static UiDataModel getUiDataModel() {
+        return sUiDataModel;
+    }
 
     /**
      * The context may be set precisely once during the application life.
@@ -101,10 +85,6 @@ public final class UiDataModel {
         return Typeface.createFromAsset(mContext.getAssets(), "fonts/clock.ttf");
     }
 
-    //
-    // Formatted Strings
-    //
-
     /**
      * This method is intended to be used when formatting numbers occurs in a hotspot such as the
      * update loop of a timer or stopwatch. It returns cached results when possible in order to
@@ -119,15 +99,19 @@ public final class UiDataModel {
         return mFormattedStringModel.getFormattedNumber(value);
     }
 
+    //
+    // Formatted Strings
+    //
+
     /**
      * This method is intended to be used when formatting numbers occurs in a hotspot such as the
      * update loop of a timer or stopwatch. It returns cached results when possible in order to
      * provide speed and limit garbage to be collected by the virtual machine.
      *
-     * @param value a positive integer to format as a String
+     * @param value  a positive integer to format as a String
      * @param length the length of the String; zeroes are padded to match this length
      * @return the {@code value} formatted as a String in the current locale and padded to the
-     *      requested {@code length}
+     * requested {@code length}
      * @throws IllegalArgumentException if {@code value} is negative
      */
     public String getFormattedNumber(int value, int length) {
@@ -141,12 +125,12 @@ public final class UiDataModel {
      * provide speed and limit garbage to be collected by the virtual machine.
      *
      * @param negative force a minus sign (-) onto the display, even if {@code value} is {@code 0}
-     * @param value a positive integer to format as a String
-     * @param length the length of the String; zeroes are padded to match this length. If
-     *      {@code negative} is {@code true} the return value will contain a minus sign and a total
-     *      length of {@code length + 1}.
+     * @param value    a positive integer to format as a String
+     * @param length   the length of the String; zeroes are padded to match this length. If
+     *                 {@code negative} is {@code true} the return value will contain a minus sign and a total
+     *                 length of {@code length + 1}.
      * @return the {@code value} formatted as a String in the current locale and padded to the
-     *      requested {@code length}
+     * requested {@code length}
      * @throws IllegalArgumentException if {@code value} is negative
      */
     public String getFormattedNumber(boolean negative, int value, int length) {
@@ -156,15 +140,15 @@ public final class UiDataModel {
 
     /**
      * @param calendarDay any of the following values
-     *                     <ul>
-     *                     <li>{@link Calendar#SUNDAY}</li>
-     *                     <li>{@link Calendar#MONDAY}</li>
-     *                     <li>{@link Calendar#TUESDAY}</li>
-     *                     <li>{@link Calendar#WEDNESDAY}</li>
-     *                     <li>{@link Calendar#THURSDAY}</li>
-     *                     <li>{@link Calendar#FRIDAY}</li>
-     *                     <li>{@link Calendar#SATURDAY}</li>
-     *                     </ul>
+     *                    <ul>
+     *                    <li>{@link Calendar#SUNDAY}</li>
+     *                    <li>{@link Calendar#MONDAY}</li>
+     *                    <li>{@link Calendar#TUESDAY}</li>
+     *                    <li>{@link Calendar#WEDNESDAY}</li>
+     *                    <li>{@link Calendar#THURSDAY}</li>
+     *                    <li>{@link Calendar#FRIDAY}</li>
+     *                    <li>{@link Calendar#SATURDAY}</li>
+     *                    </ul>
      * @return single-character version of weekday name; e.g.: 'S', 'M', 'T', 'W', 'T', 'F', 'S'
      */
     public String getShortWeekday(int calendarDay) {
@@ -174,15 +158,15 @@ public final class UiDataModel {
 
     /**
      * @param calendarDay any of the following values
-     *                     <ul>
-     *                     <li>{@link Calendar#SUNDAY}</li>
-     *                     <li>{@link Calendar#MONDAY}</li>
-     *                     <li>{@link Calendar#TUESDAY}</li>
-     *                     <li>{@link Calendar#WEDNESDAY}</li>
-     *                     <li>{@link Calendar#THURSDAY}</li>
-     *                     <li>{@link Calendar#FRIDAY}</li>
-     *                     <li>{@link Calendar#SATURDAY}</li>
-     *                     </ul>
+     *                    <ul>
+     *                    <li>{@link Calendar#SUNDAY}</li>
+     *                    <li>{@link Calendar#MONDAY}</li>
+     *                    <li>{@link Calendar#TUESDAY}</li>
+     *                    <li>{@link Calendar#WEDNESDAY}</li>
+     *                    <li>{@link Calendar#THURSDAY}</li>
+     *                    <li>{@link Calendar#FRIDAY}</li>
+     *                    <li>{@link Calendar#SATURDAY}</li>
+     *                    </ul>
      * @return full weekday name; e.g.: 'Sunday', 'Monday', 'Tuesday', etc.
      */
     public String getLongWeekday(int calendarDay) {
@@ -190,10 +174,6 @@ public final class UiDataModel {
         return mFormattedStringModel.getLongWeekday(calendarDay);
     }
 
-    //
-    // Animations
-    //
-
     /**
      * @return the duration in milliseconds of short animations
      */
@@ -202,6 +182,10 @@ public final class UiDataModel {
         return mContext.getResources().getInteger(android.R.integer.config_shortAnimTime);
     }
 
+    //
+    // Animations
+    //
+
     /**
      * @return the duration in milliseconds of long animations
      */
@@ -210,10 +194,6 @@ public final class UiDataModel {
         return mContext.getResources().getInteger(android.R.integer.config_longAnimTime);
     }
 
-    //
-    // Tabs
-    //
-
     /**
      * @param tabListener to be notified when the selected tab changes
      */
@@ -222,6 +202,10 @@ public final class UiDataModel {
         mTabModel.addTabListener(tabListener);
     }
 
+    //
+    // Tabs
+    //
+
     /**
      * @param tabListener to no longer be notified when the selected tab changes
      */
@@ -291,7 +275,7 @@ public final class UiDataModel {
     /**
      * Updates the scrolling state in the {@link UiDataModel} for this tab.
      *
-     * @param tab an enumerated value indicating the tab reporting its vertical scroll position
+     * @param tab           an enumerated value indicating the tab reporting its vertical scroll position
      * @param scrolledToTop {@code true} iff the vertical scroll position of the tab is at the top
      */
     public void setTabScrolledToTop(Tab tab, boolean scrolledToTop) {
@@ -307,13 +291,9 @@ public final class UiDataModel {
         return mTabModel.isTabScrolledToTop(getSelectedTab());
     }
 
-    //
-    // Shortcut Ids
-    //
-
     /**
      * @param category which category of shortcut of which to get the id
-     * @param action the desired action to perform
+     * @param action   the desired action to perform
      * @return the id of the shortcut
      */
     public String getShortcutId(@StringRes int category, @StringRes int action) {
@@ -324,21 +304,25 @@ public final class UiDataModel {
     }
 
     //
-    // Timed Callbacks
+    // Shortcut Ids
     //
 
     /**
      * @param runnable to be called every minute
-     * @param offset an offset applied to the minute to control when the callback occurs
+     * @param offset   an offset applied to the minute to control when the callback occurs
      */
     public void addMinuteCallback(Runnable runnable, long offset) {
         enforceMainLooper();
         mPeriodicCallbackModel.addMinuteCallback(runnable, offset);
     }
 
+    //
+    // Timed Callbacks
+    //
+
     /**
      * @param runnable to be called every quarter-hour
-     * @param offset an offset applied to the quarter-hour to control when the callback occurs
+     * @param offset   an offset applied to the quarter-hour to control when the callback occurs
      */
     public void addQuarterHourCallback(Runnable runnable, long offset) {
         enforceMainLooper();
@@ -347,7 +331,7 @@ public final class UiDataModel {
 
     /**
      * @param runnable to be called every hour
-     * @param offset an offset applied to the hour to control when the callback occurs
+     * @param offset   an offset applied to the hour to control when the callback occurs
      */
     public void addHourCallback(Runnable runnable, long offset) {
         enforceMainLooper();
@@ -356,7 +340,7 @@ public final class UiDataModel {
 
     /**
      * @param runnable to be called every midnight
-     * @param offset an offset applied to the midnight to control when the callback occurs
+     * @param offset   an offset applied to the midnight to control when the callback occurs
      */
     public void addMidnightCallback(Runnable runnable, long offset) {
         enforceMainLooper();
@@ -370,4 +354,40 @@ public final class UiDataModel {
         enforceMainLooper();
         mPeriodicCallbackModel.removePeriodicCallback(runnable);
     }
+
+    /**
+     * Identifies each of the primary tabs within the application.
+     */
+    public enum Tab {
+        ALARMS(AlarmClockFragment.class, R.id.page_alarm, R.string.menu_alarm),
+        CLOCKS(ClockFragment.class, R.id.page_clock, R.string.menu_clock),
+        TIMERS(TimerFragment.class, R.id.page_timer, R.string.menu_timer),
+        STOPWATCH(StopwatchFragment.class, R.id.page_stopwatch, R.string.menu_stopwatch);
+
+        private final String mFragmentClassName;
+        private final @IntegerRes
+        int mPageResId;
+        private final @StringRes
+        int mLabelResId;
+
+        Tab(Class fragmentClass, @IntegerRes int pageResId, @StringRes int labelResId) {
+            mFragmentClassName = fragmentClass.getName();
+            mPageResId = pageResId;
+            mLabelResId = labelResId;
+        }
+
+        public String getFragmentClassName() {
+            return mFragmentClassName;
+        }
+
+        public @IntegerRes
+        int getPageResId() {
+            return mPageResId;
+        }
+
+        public @StringRes
+        int getLabelResId() {
+            return mLabelResId;
+        }
+    }
 }
diff --git a/src/com/android/deskclock/widget/AutoSizingTextClock.java b/app/src/main/java/com/best/deskclock/widget/AutoSizingTextClock.java
similarity index 92%
rename from src/com/android/deskclock/widget/AutoSizingTextClock.java
rename to app/src/main/java/com/best/deskclock/widget/AutoSizingTextClock.java
index 367adc4f3..3cb2d008a 100644
--- a/src/com/android/deskclock/widget/AutoSizingTextClock.java
+++ b/app/src/main/java/com/best/deskclock/widget/AutoSizingTextClock.java
@@ -21,7 +21,7 @@ import android.util.AttributeSet;
 import android.widget.TextClock;
 
 /**
- *  Wrapper around TextClock that automatically re-sizes itself to fit within the given bounds.
+ * Wrapper around TextClock that automatically re-sizes itself to fit within the given bounds.
  */
 public class AutoSizingTextClock extends TextClock {
 
@@ -69,7 +69,7 @@ public class AutoSizingTextClock extends TextClock {
 
     @Override
     public void requestLayout() {
-        if (mTextSizeHelper == null || !mTextSizeHelper.shouldIgnoreRequestLayout()) {
+        if (mTextSizeHelper == null || mTextSizeHelper.shouldIgnoreRequestLayout()) {
             if (!mSuppressLayout) {
                 super.requestLayout();
             }
diff --git a/src/com/android/deskclock/widget/AutoSizingTextView.java b/app/src/main/java/com/best/deskclock/widget/AutoSizingTextView.java
similarity index 95%
rename from src/com/android/deskclock/widget/AutoSizingTextView.java
rename to app/src/main/java/com/best/deskclock/widget/AutoSizingTextView.java
index e7830bf25..21b01c0bb 100644
--- a/src/com/android/deskclock/widget/AutoSizingTextView.java
+++ b/app/src/main/java/com/best/deskclock/widget/AutoSizingTextView.java
@@ -17,9 +17,10 @@
 package com.best.deskclock.widget;
 
 import android.content.Context;
-import androidx.appcompat.widget.AppCompatTextView;
 import android.util.AttributeSet;
 
+import androidx.appcompat.widget.AppCompatTextView;
+
 /**
  * A TextView which automatically re-sizes its text to fit within its boundaries.
  */
@@ -58,7 +59,7 @@ public class AutoSizingTextView extends AppCompatTextView {
 
     @Override
     public void requestLayout() {
-        if (mTextSizeHelper == null || !mTextSizeHelper.shouldIgnoreRequestLayout()) {
+        if (mTextSizeHelper == null || mTextSizeHelper.shouldIgnoreRequestLayout()) {
             super.requestLayout();
         }
     }
diff --git a/src/com/android/deskclock/widget/CircleView.java b/app/src/main/java/com/best/deskclock/widget/CircleView.java
similarity index 93%
rename from src/com/android/deskclock/widget/CircleView.java
rename to app/src/main/java/com/best/deskclock/widget/CircleView.java
index 05399144f..b9767b594 100644
--- a/src/com/android/deskclock/widget/CircleView.java
+++ b/app/src/main/java/com/best/deskclock/widget/CircleView.java
@@ -40,16 +40,16 @@ public class CircleView extends View {
      */
     public final static Property<CircleView, Integer> FILL_COLOR =
             new Property<CircleView, Integer>(Integer.class, "fillColor") {
-        @Override
-        public Integer get(CircleView view) {
-            return view.getFillColor();
-        }
+                @Override
+                public Integer get(CircleView view) {
+                    return view.getFillColor();
+                }
 
-        @Override
-        public void set(CircleView view, Integer value) {
-            view.setFillColor(value);
-        }
-    };
+                @Override
+                public void set(CircleView view, Integer value) {
+                    view.setFillColor(value);
+                }
+            };
 
     /**
      * A Property wrapper around the radius functionality handled by the
@@ -57,16 +57,16 @@ public class CircleView extends View {
      */
     public final static Property<CircleView, Float> RADIUS =
             new Property<CircleView, Float>(Float.class, "radius") {
-        @Override
-        public Float get(CircleView view) {
-            return view.getRadius();
-        }
+                @Override
+                public Float get(CircleView view) {
+                    return view.getRadius();
+                }
 
-        @Override
-        public void set(CircleView view, Float value) {
-            view.setRadius(value);
-        }
-    };
+                @Override
+                public void set(CircleView view, Float value) {
+                    view.setRadius(value);
+                }
+            };
 
     /**
      * The {@link Paint} used to draw the circle.
@@ -284,7 +284,7 @@ public class CircleView extends View {
      * and size of the circle depending on the resolved {@link Gravity} flags. Also invalidates the
      * affected area if necessary.
      *
-     * @param gravity the {@link Gravity} the {@link Gravity} flags to use
+     * @param gravity         the {@link Gravity} the {@link Gravity} flags to use
      * @param layoutDirection the layout direction used to resolve the absolute gravity
      */
     @SuppressLint("RtlHardcoded")
diff --git a/src/com/android/deskclock/widget/EllipsizeLayout.java b/app/src/main/java/com/best/deskclock/widget/EllipsizeLayout.java
similarity index 98%
rename from src/com/android/deskclock/widget/EllipsizeLayout.java
rename to app/src/main/java/com/best/deskclock/widget/EllipsizeLayout.java
index 438afb383..6e7991ba7 100644
--- a/src/com/android/deskclock/widget/EllipsizeLayout.java
+++ b/app/src/main/java/com/best/deskclock/widget/EllipsizeLayout.java
@@ -55,7 +55,7 @@ public class EllipsizeLayout extends LinearLayout {
      *     reduced.</li>
      * </ul>
      *
-     * @param widthMeasureSpec horizontal space requirements as imposed by the parent
+     * @param widthMeasureSpec  horizontal space requirements as imposed by the parent
      * @param heightMeasureSpec vertical space requirements as imposed by the parent
      */
     @Override
diff --git a/src/com/android/deskclock/widget/EmptyViewController.java b/app/src/main/java/com/best/deskclock/widget/EmptyViewController.java
similarity index 94%
rename from src/com/android/deskclock/widget/EmptyViewController.java
rename to app/src/main/java/com/best/deskclock/widget/EmptyViewController.java
index 2eb6303d0..57d5a8448 100644
--- a/src/com/android/deskclock/widget/EmptyViewController.java
+++ b/app/src/main/java/com/best/deskclock/widget/EmptyViewController.java
@@ -42,8 +42,8 @@ public final class EmptyViewController {
     /**
      * Constructor of the controller.
      *
-     * @param contentView  The view that should be displayed when empty view is hidden.
-     * @param emptyView The view that should be displayed when main view is empty.
+     * @param contentView The view that should be displayed when empty view is hidden.
+     * @param emptyView   The view that should be displayed when main view is empty.
      */
     public EmptyViewController(ViewGroup mainLayout, View contentView, View emptyView) {
         mMainLayout = mainLayout;
diff --git a/src/com/android/deskclock/widget/TextSizeHelper.java b/app/src/main/java/com/best/deskclock/widget/TextSizeHelper.java
similarity index 98%
rename from src/com/android/deskclock/widget/TextSizeHelper.java
rename to app/src/main/java/com/best/deskclock/widget/TextSizeHelper.java
index 31a68bd58..e884808d4 100644
--- a/src/com/android/deskclock/widget/TextSizeHelper.java
+++ b/app/src/main/java/com/best/deskclock/widget/TextSizeHelper.java
@@ -16,14 +16,14 @@
 
 package com.best.deskclock.widget;
 
+import static java.lang.Integer.MAX_VALUE;
+
 import android.text.Layout;
 import android.text.TextPaint;
 import android.util.TypedValue;
 import android.view.View;
 import android.widget.TextView;
 
-import static java.lang.Integer.MAX_VALUE;
-
 /**
  * A TextView which automatically re-sizes its text to fit within its boundaries.
  */
@@ -36,7 +36,7 @@ public final class TextSizeHelper {
     private final TextPaint mMeasurePaint = new TextPaint();
 
     // The maximum size the text is allowed to be (in pixels).
-    private float mMaxTextSize;
+    private final float mMaxTextSize;
 
     // The maximum width the text is allowed to be (in pixels).
     private int mWidthConstraint = MAX_VALUE;
@@ -84,7 +84,7 @@ public final class TextSizeHelper {
     }
 
     public boolean shouldIgnoreRequestLayout() {
-        return mIgnoreRequestLayout;
+        return !mIgnoreRequestLayout;
     }
 
     private void adjustTextSize() {
diff --git a/src/com/android/deskclock/widget/TextTime.java b/app/src/main/java/com/best/deskclock/widget/TextTime.java
similarity index 97%
rename from src/com/android/deskclock/widget/TextTime.java
rename to app/src/main/java/com/best/deskclock/widget/TextTime.java
index c7b62175f..e5fa63db6 100644
--- a/src/com/android/deskclock/widget/TextTime.java
+++ b/app/src/main/java/com/best/deskclock/widget/TextTime.java
@@ -16,40 +16,41 @@
 
 package com.best.deskclock.widget;
 
+import static java.util.Calendar.HOUR_OF_DAY;
+import static java.util.Calendar.MINUTE;
+
 import android.content.ContentResolver;
 import android.content.Context;
 import android.database.ContentObserver;
 import android.net.Uri;
 import android.os.Handler;
 import android.provider.Settings;
-import androidx.annotation.VisibleForTesting;
 import android.text.format.DateFormat;
 import android.util.AttributeSet;
 import android.widget.TextView;
 
+import androidx.annotation.VisibleForTesting;
+
 import com.best.deskclock.Utils;
 import com.best.deskclock.data.DataModel;
 
 import java.util.Calendar;
 import java.util.TimeZone;
 
-import static java.util.Calendar.HOUR_OF_DAY;
-import static java.util.Calendar.MINUTE;
-
 /**
  * Based on {@link android.widget.TextClock}, This widget displays a constant time of day using
  * format specifiers. {@link android.widget.TextClock} doesn't support a non-ticking clock.
  */
 public class TextTime extends TextView {
 
-    /** UTC does not have DST rules and will not alter the {@link #mHour} and {@link #mMinute}. */
-    private static final TimeZone UTC = TimeZone.getTimeZone("UTC");
-
     @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
     static final CharSequence DEFAULT_FORMAT_12_HOUR = "h:mm a";
-    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+    @VisibleForTesting()
     static final CharSequence DEFAULT_FORMAT_24_HOUR = "H:mm";
-
+    /**
+     * UTC does not have DST rules and will not alter the {@link #mHour} and {@link #mMinute}.
+     */
+    private static final TimeZone UTC = TimeZone.getTimeZone("UTC");
     private CharSequence mFormat12;
     private CharSequence mFormat24;
     private CharSequence mFormat;
diff --git a/src/com/android/deskclock/widget/selector/AlarmSelection.java b/app/src/main/java/com/best/deskclock/widget/selector/AlarmSelection.java
similarity index 100%
rename from src/com/android/deskclock/widget/selector/AlarmSelection.java
rename to app/src/main/java/com/best/deskclock/widget/selector/AlarmSelection.java
diff --git a/src/com/android/deskclock/widget/selector/AlarmSelectionAdapter.java b/app/src/main/java/com/best/deskclock/widget/selector/AlarmSelectionAdapter.java
similarity index 87%
rename from src/com/android/deskclock/widget/selector/AlarmSelectionAdapter.java
rename to app/src/main/java/com/best/deskclock/widget/selector/AlarmSelectionAdapter.java
index 3f5269a30..39c6d6b3a 100644
--- a/src/com/android/deskclock/widget/selector/AlarmSelectionAdapter.java
+++ b/app/src/main/java/com/best/deskclock/widget/selector/AlarmSelectionAdapter.java
@@ -16,14 +16,15 @@
 package com.best.deskclock.widget.selector;
 
 import android.content.Context;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ArrayAdapter;
 import android.widget.TextView;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
 import com.best.deskclock.R;
 import com.best.deskclock.data.DataModel;
 import com.best.deskclock.data.Weekdays;
@@ -40,8 +41,9 @@ public class AlarmSelectionAdapter extends ArrayAdapter<AlarmSelection> {
     }
 
     @Override
-    public @NonNull View getView(int position, @Nullable View convertView,
-            @NonNull ViewGroup parent) {
+    public @NonNull
+    View getView(int position, @Nullable View convertView,
+                 @NonNull ViewGroup parent) {
         final Context context = getContext();
         View row = convertView;
         if (row == null) {
@@ -52,10 +54,10 @@ public class AlarmSelectionAdapter extends ArrayAdapter<AlarmSelection> {
         final AlarmSelection selection = getItem(position);
         final Alarm alarm = selection.getAlarm();
 
-        final TextTime alarmTime = (TextTime) row.findViewById(R.id.digital_clock);
+        final TextTime alarmTime = row.findViewById(R.id.digital_clock);
         alarmTime.setTime(alarm.hour, alarm.minutes);
 
-        final TextView alarmLabel = (TextView) row.findViewById(R.id.label);
+        final TextView alarmLabel = row.findViewById(R.id.label);
         alarmLabel.setText(alarm.label);
 
         // find days when alarm is firing
@@ -69,7 +71,7 @@ public class AlarmSelectionAdapter extends ArrayAdapter<AlarmSelection> {
             daysOfWeek = alarm.daysOfWeek.toString(context, weekdayOrder);
         }
 
-        final TextView daysOfWeekView = (TextView) row.findViewById(R.id.daysOfWeek);
+        final TextView daysOfWeekView = row.findViewById(R.id.daysOfWeek);
         daysOfWeekView.setText(daysOfWeek);
 
         return row;
diff --git a/src/com/android/deskclock/widget/toast/SnackbarManager.java b/app/src/main/java/com/best/deskclock/widget/toast/SnackbarManager.java
similarity index 97%
rename from src/com/android/deskclock/widget/toast/SnackbarManager.java
rename to app/src/main/java/com/best/deskclock/widget/toast/SnackbarManager.java
index 8428b962d..e761cf570 100644
--- a/src/com/android/deskclock/widget/toast/SnackbarManager.java
+++ b/app/src/main/java/com/best/deskclock/widget/toast/SnackbarManager.java
@@ -27,7 +27,8 @@ public final class SnackbarManager {
 
     private static WeakReference<Snackbar> sSnackbar = null;
 
-    private SnackbarManager() {}
+    private SnackbarManager() {
+    }
 
     public static void show(Snackbar snackbar) {
         sSnackbar = new WeakReference<>(snackbar);
diff --git a/src/com/android/deskclock/widget/toast/SnackbarSlidingBehavior.java b/app/src/main/java/com/best/deskclock/widget/toast/SnackbarSlidingBehavior.java
similarity index 77%
rename from src/com/android/deskclock/widget/toast/SnackbarSlidingBehavior.java
rename to app/src/main/java/com/best/deskclock/widget/toast/SnackbarSlidingBehavior.java
index b82acf9fe..866138cc2 100644
--- a/src/com/android/deskclock/widget/toast/SnackbarSlidingBehavior.java
+++ b/app/src/main/java/com/best/deskclock/widget/toast/SnackbarSlidingBehavior.java
@@ -17,11 +17,14 @@
 package com.best.deskclock.widget.toast;
 
 import android.content.Context;
+import android.util.AttributeSet;
+import android.view.View;
+
 import androidx.annotation.Keep;
+import androidx.annotation.NonNull;
 import androidx.coordinatorlayout.widget.CoordinatorLayout;
+
 import com.google.android.material.snackbar.Snackbar;
-import android.util.AttributeSet;
-import android.view.View;
 
 /**
  * Custom {@link CoordinatorLayout.Behavior} that slides with the {@link Snackbar}.
@@ -33,23 +36,23 @@ public final class SnackbarSlidingBehavior extends CoordinatorLayout.Behavior<Vi
     }
 
     @Override
-    public boolean layoutDependsOn(CoordinatorLayout parent, View child, View dependency) {
+    public boolean layoutDependsOn(@NonNull CoordinatorLayout parent, @NonNull View child, @NonNull View dependency) {
         return dependency instanceof Snackbar.SnackbarLayout;
     }
 
     @Override
-    public boolean onDependentViewChanged(CoordinatorLayout parent, View child, View dependency) {
+    public boolean onDependentViewChanged(@NonNull CoordinatorLayout parent, @NonNull View child, @NonNull View dependency) {
         updateTranslationY(parent, child);
         return false;
     }
 
     @Override
-    public void onDependentViewRemoved(CoordinatorLayout parent, View child, View dependency) {
+    public void onDependentViewRemoved(@NonNull CoordinatorLayout parent, @NonNull View child, @NonNull View dependency) {
         updateTranslationY(parent, child);
     }
 
     @Override
-    public boolean onLayoutChild(CoordinatorLayout parent, View child, int layoutDirection) {
+    public boolean onLayoutChild(@NonNull CoordinatorLayout parent, @NonNull View child, int layoutDirection) {
         updateTranslationY(parent, child);
         return false;
     }
diff --git a/src/com/android/deskclock/widget/toast/ToastManager.java b/app/src/main/java/com/best/deskclock/widget/toast/ToastManager.java
similarity index 100%
rename from src/com/android/deskclock/widget/toast/ToastManager.java
rename to app/src/main/java/com/best/deskclock/widget/toast/ToastManager.java
diff --git a/src/com/android/deskclock/worldclock/CitySelectionActivity.java b/app/src/main/java/com/best/deskclock/worldclock/CitySelectionActivity.java
similarity index 95%
rename from src/com/android/deskclock/worldclock/CitySelectionActivity.java
rename to app/src/main/java/com/best/deskclock/worldclock/CitySelectionActivity.java
index e724a8f13..d510fd0af 100644
--- a/src/com/android/deskclock/worldclock/CitySelectionActivity.java
+++ b/app/src/main/java/com/best/deskclock/worldclock/CitySelectionActivity.java
@@ -16,9 +16,10 @@
 
 package com.best.deskclock.worldclock;
 
+import static android.view.Menu.NONE;
+
 import android.content.Context;
 import android.os.Bundle;
-import androidx.appcompat.widget.SearchView;
 import android.text.TextUtils;
 import android.text.format.DateFormat;
 import android.util.ArraySet;
@@ -35,8 +36,10 @@ import android.widget.ListView;
 import android.widget.SectionIndexer;
 import android.widget.TextView;
 
+import androidx.annotation.NonNull;
+import androidx.appcompat.widget.SearchView;
+
 import com.best.deskclock.BaseActivity;
-import com.best.deskclock.DropShadowController;
 import com.best.deskclock.R;
 import com.best.deskclock.Utils;
 import com.best.deskclock.actionbarmenu.MenuItemController;
@@ -47,6 +50,7 @@ import com.best.deskclock.actionbarmenu.SearchMenuItemController;
 import com.best.deskclock.actionbarmenu.SettingsMenuItemController;
 import com.best.deskclock.data.City;
 import com.best.deskclock.data.DataModel;
+import com.best.deskclock.data.DataModel.ThemeButtonBehavior;
 
 import java.util.ArrayList;
 import java.util.Calendar;
@@ -55,11 +59,10 @@ import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
 import java.util.Locale;
+import java.util.Objects;
 import java.util.Set;
 import java.util.TimeZone;
 
-import static android.view.Menu.NONE;
-
 /**
  * This activity allows the user to alter the cities selected for display.
  * <p/>
@@ -75,38 +78,42 @@ import static android.view.Menu.NONE;
  */
 public final class CitySelectionActivity extends BaseActivity {
 
+    /**
+     * Manages all action bar menu display and click handling.
+     */
+    private final OptionsMenuManager mOptionsMenuManager = new OptionsMenuManager();
     /**
      * The list of all selected and unselected cities, indexed and possibly filtered.
      */
     private ListView mCitiesList;
-
     /**
      * The adapter that presents all of the selected and unselected cities.
      */
     private CityAdapter mCitiesAdapter;
-
-    /**
-     * Manages all action bar menu display and click handling.
-     */
-    private final OptionsMenuManager mOptionsMenuManager = new OptionsMenuManager();
-
     /**
      * Menu item controller for search view.
      */
     private SearchMenuItemController mSearchMenuItemController;
+    private ThemeButtonBehavior mThemeBehavior;
 
     /**
      * The controller that shows the drop shadow when content is not scrolled to the top.
      */
-    private DropShadowController mDropShadowController;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
+        mThemeBehavior = DataModel.getDataModel().getThemeButtonBehavior();
+        if (mThemeBehavior == DataModel.ThemeButtonBehavior.DARK) {
+            getTheme().applyStyle(R.style.Theme_DeskClock_Actionbar_Dark, true);
+        }
+        if (mThemeBehavior == DataModel.ThemeButtonBehavior.LIGHT) {
+            getTheme().applyStyle(R.style.Theme_DeskClock_Actionbar_Light, true);
+        }
         super.onCreate(savedInstanceState);
 
         setContentView(R.layout.cities_activity);
         mSearchMenuItemController =
-                new SearchMenuItemController(getSupportActionBar().getThemedContext(),
+                new SearchMenuItemController(Objects.requireNonNull(getSupportActionBar()).getThemedContext(),
                         new SearchView.OnQueryTextListener() {
                             @Override
                             public boolean onQueryTextSubmit(String query) {
@@ -127,14 +134,14 @@ public final class CitySelectionActivity extends BaseActivity {
                 .addMenuItemController(new SettingsMenuItemController(this))
                 .addMenuItemController(MenuItemControllerFactory.getInstance()
                         .buildMenuItemControllers(this));
-        mCitiesList = (ListView) findViewById(R.id.cities_list);
+        mCitiesList = findViewById(R.id.cities_list);
         mCitiesList.setAdapter(mCitiesAdapter);
 
         updateFastScrolling();
     }
 
     @Override
-    public void onSaveInstanceState(Bundle bundle) {
+    public void onSaveInstanceState(@NonNull Bundle bundle) {
         super.onSaveInstanceState(bundle);
         mSearchMenuItemController.saveInstance(bundle);
     }
@@ -146,16 +153,12 @@ public final class CitySelectionActivity extends BaseActivity {
         // Recompute the contents of the adapter before displaying on screen.
         mCitiesAdapter.refresh();
 
-        final View dropShadow = findViewById(R.id.drop_shadow);
-        mDropShadowController = new DropShadowController(dropShadow, mCitiesList);
     }
 
     @Override
     public void onPause() {
         super.onPause();
 
-        mDropShadowController.stop();
-
         // Save the selected cities.
         DataModel.getDataModel().setSelectedCities(mCitiesAdapter.getSelectedCities());
     }
@@ -240,47 +243,39 @@ public final class CitySelectionActivity extends BaseActivity {
          * The 24-hour time pattern for the current locale.
          */
         private final String mPattern24;
-
-        /**
-         * {@code true} time should honor {@link #mPattern24}; {@link #mPattern12} otherwise.
-         */
-        private boolean mIs24HoursMode;
-
         /**
          * A calendar used to format time in a particular timezone.
          */
         private final Calendar mCalendar;
-
-        /**
-         * The list of cities which may be filtered by a search term.
-         */
-        private List<City> mFilteredCities = Collections.emptyList();
-
         /**
          * A mutable set of cities currently selected by the user.
          */
         private final Set<City> mUserSelectedCities = new ArraySet<>();
-
+        /**
+         * Menu item controller for search. Search query is maintained here.
+         */
+        private final SearchMenuItemController mSearchMenuItemController;
+        /**
+         * {@code true} time should honor {@link #mPattern24}; {@link #mPattern12} otherwise.
+         */
+        private boolean mIs24HoursMode;
+        /**
+         * The list of cities which may be filtered by a search term.
+         */
+        private List<City> mFilteredCities = Collections.emptyList();
         /**
          * The number of user selections at the top of the adapter to avoid indexing.
          */
         private int mOriginalUserSelectionCount;
-
         /**
          * The precomputed section headers.
          */
         private String[] mSectionHeaders;
-
         /**
          * The corresponding location of each precomputed section header.
          */
         private Integer[] mSectionHeaderPositions;
 
-        /**
-         * Menu item controller for search. Search query is maintained here.
-         */
-        private final SearchMenuItemController mSearchMenuItemController;
-
         public CityAdapter(Context context, SearchMenuItemController searchMenuItemController) {
             mContext = context;
             mSearchMenuItemController = searchMenuItemController;
@@ -349,10 +344,10 @@ public final class CitySelectionActivity extends BaseActivity {
                     // Inflate a new view if necessary.
                     if (view == null) {
                         view = mInflater.inflate(R.layout.city_list_item, parent, false);
-                        final TextView index = (TextView) view.findViewById(R.id.index);
-                        final TextView name = (TextView) view.findViewById(R.id.city_name);
-                        final TextView time = (TextView) view.findViewById(R.id.city_time);
-                        final CheckBox selected = (CheckBox) view.findViewById(R.id.city_onoff);
+                        final TextView index = view.findViewById(R.id.index);
+                        final TextView name = view.findViewById(R.id.city_name);
+                        final TextView time = view.findViewById(R.id.city_time);
+                        final CheckBox selected = view.findViewById(R.id.city_onoff);
                         view.setTag(new CityItemHolder(index, name, time, selected));
                     }
 
@@ -416,7 +411,7 @@ public final class CitySelectionActivity extends BaseActivity {
 
         @Override
         public void onClick(View v) {
-            final CheckBox b = (CheckBox) v.findViewById(R.id.city_onoff);
+            final CheckBox b = v.findViewById(R.id.city_onoff);
             b.setChecked(!b.isChecked());
         }
 
