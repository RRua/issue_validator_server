diff --git a/src/main/java/com/eightsines/esmediadtor/Mediadtor.java b/src/main/java/com/eightsines/esmediadtor/Mediadtor.java
new file mode 100644
index 0000000..8d9b0ac
--- /dev/null
+++ b/src/main/java/com/eightsines/esmediadtor/Mediadtor.java
@@ -0,0 +1,239 @@
+package com.eightsines.esmediadtor;
+
+import android.Manifest;
+import android.app.Activity;
+import android.content.pm.PackageManager;
+import android.os.Build;
+import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.view.Gravity;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.FrameLayout;
+import com.appodeal.ads.Appodeal;
+import com.appodeal.ads.BannerView;
+import com.appodeal.ads.RewardedVideoCallbacks;
+import com.appodeal.ads.utils.Log;
+import com.eightsines.espromo.PromoView;
+
+public class Mediadtor {
+    private static final long ROTATE_INTERVAL_APPODEAL = 30L * 1000L;
+    private static final long ROTATE_INTERVAL_ESPROMO = 15L * 1000L;
+    private static final long RECHECK_INTERVAL = 5000L;
+
+    private String applicationKey;
+    private boolean isConsentGiven;
+    private boolean isTesting;
+    private Handler handler;
+    private MediadtorListener listener;
+    private Activity bannerActivity;
+    private ViewGroup bannerContainerView;
+    private View[] bannerViews;
+    private int bannerIndex;
+
+    private RewardedVideoCallbacks rewardedVideoCallbacks = new RewardedVideoCallbacks() {
+        @Override
+        public void onRewardedVideoLoaded(boolean isPrecache) {
+            // ignore
+        }
+
+        @Override
+        public void onRewardedVideoFailedToLoad() {
+            // ignore
+        }
+
+        @Override
+        public void onRewardedVideoShown() {
+            // ignore
+        }
+
+        @Override
+        public void onRewardedVideoFinished(double amount, String name) {
+            // ignore
+        }
+
+        @Override
+        public void onRewardedVideoClosed(boolean finished) {
+            listener.onRewardedVideoClosed(true);
+        }
+
+        @Override
+        public void onRewardedVideoExpired() {
+            // ignore
+        }
+    };
+
+    private Runnable rotateBannerRunnable = new Runnable() {
+        @Override
+        public void run() {
+            handler.removeCallbacks(rotateBannerRunnable);
+
+            if (bannerActivity == null || bannerContainerView == null || bannerViews == null) {
+                return;
+            }
+
+            for (View view : bannerViews) {
+                bannerContainerView.removeView(view);
+            }
+
+            int bannersCount = bannerViews.length;
+
+            if (bannersCount == 0) {
+                return;
+            }
+
+            if (bannerIndex < 0 || bannerIndex > bannersCount) {
+                bannerIndex = 0;
+            }
+
+            View bannerView = bannerViews[bannerIndex];
+
+            boolean isBannerLoaded = false;
+            long delayInterval = RECHECK_INTERVAL;
+
+            //noinspection ForLoopReplaceableByForEach
+            for (int i = 0; i < bannersCount; i++) {
+                if ((bannerView instanceof BannerView) && Appodeal.isLoaded(Appodeal.BANNER)) {
+                    isBannerLoaded = true;
+                    delayInterval = ROTATE_INTERVAL_APPODEAL;
+                    break;
+                }
+
+                if ((bannerView instanceof PromoView) && ((PromoView)bannerView).isActivePromoLoaded()) {
+                    isBannerLoaded = true;
+                    delayInterval = ROTATE_INTERVAL_ESPROMO;
+                    break;
+                }
+
+                bannerIndex = (bannerIndex + 1) % bannersCount;
+                bannerView = bannerViews[bannerIndex];
+            }
+
+            bannerContainerView.addView(bannerView);
+
+            if (bannerView instanceof BannerView) {
+                Appodeal.show(bannerActivity, Appodeal.BANNER_VIEW);
+            }
+
+            if (isBannerLoaded) {
+                bannerIndex = (bannerIndex + 1) % bannersCount;
+            }
+
+            handler.postDelayed(rotateBannerRunnable, delayInterval);
+        }
+    };
+
+    public Mediadtor(@NonNull String applicationKey, boolean isConsentGiven, boolean isTesting) {
+        this.applicationKey = applicationKey;
+        this.isConsentGiven = isConsentGiven;
+        this.isTesting = isTesting;
+
+        handler = new Handler();
+    }
+
+    public void onActivityCreate(@NonNull Activity activity, @NonNull MediadtorListener listener) {
+        this.listener = listener;
+
+        Appodeal.disableLocationPermissionCheck();
+        Appodeal.setTesting(isTesting);
+        Appodeal.setLogLevel(isTesting ? Log.LogLevel.debug : Log.LogLevel.none);
+
+        if (!isTesting) {
+            Appodeal.disableWriteExternalStoragePermissionCheck();
+        }
+
+        // https://www.appodeal.com/sdk/documentation?framework=1&full=1&platform=1
+        //
+        // Appodeal.setChildDirectedTreatment(true);
+        // Appodeal.muteVideosIfCallsMuted(true);
+
+        Appodeal.initialize(
+                activity,
+                applicationKey,
+                Appodeal.INTERSTITIAL | Appodeal.REWARDED_VIDEO | Appodeal.BANNER,
+                isConsentGiven);
+
+        Appodeal.setRewardedVideoCallbacks(rewardedVideoCallbacks);
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M
+                && activity.checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE)
+                != PackageManager.PERMISSION_GRANTED) {
+
+            Appodeal.requestAndroidMPermissions(activity, null);
+        }
+    }
+
+    public void onActivityResume(@NonNull Activity activity) {
+        if (bannerContainerView != null && bannerViews != null) {
+            Appodeal.onResume(activity, Appodeal.BANNER);
+            handler.postDelayed(rotateBannerRunnable, ROTATE_INTERVAL_APPODEAL);
+        }
+    }
+
+    public void onActivityPause() {
+        handler.removeCallbacks(rotateBannerRunnable);
+    }
+
+    public boolean isInterstitialLoaded() {
+        return Appodeal.isLoaded(Appodeal.INTERSTITIAL);
+    }
+
+    public void showInterstitial(@NonNull Activity activity) {
+        Appodeal.show(activity, Appodeal.INTERSTITIAL);
+    }
+
+    public boolean isRewardedVideoLoaded() {
+        return Appodeal.isLoaded(Appodeal.REWARDED_VIDEO);
+    }
+
+    public void showRewardedVideo(@NonNull Activity activity) {
+        Appodeal.show(activity, Appodeal.REWARDED_VIDEO);
+    }
+
+    public void showBanner(@NonNull Activity activity, @NonNull ViewGroup containerView) {
+        hideBanner(activity);
+
+        bannerActivity = activity;
+        bannerContainerView = containerView;
+
+        bannerViews = new View[] {
+                Appodeal.getBannerView(activity),
+                new PromoView(activity) };
+
+        if (containerView instanceof FrameLayout) {
+            for (View view : bannerViews) {
+                boolean isAppodealBanner = (view instanceof BannerView);
+
+                FrameLayout.LayoutParams lp = new FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
+                        isAppodealBanner ? ViewGroup.LayoutParams.WRAP_CONTENT : ViewGroup.LayoutParams.MATCH_PARENT);
+
+                if (isAppodealBanner) {
+                    lp.gravity = Gravity.CENTER_VERTICAL;
+                }
+
+                view.setLayoutParams(lp);
+            }
+        }
+
+        rotateBannerRunnable.run();
+    }
+
+    public void hideBanner(@NonNull Activity activity) {
+        handler.removeCallbacks(rotateBannerRunnable);
+        Appodeal.hide(activity, Appodeal.BANNER);
+
+        if (bannerActivity != null && activity != bannerActivity) {
+            Appodeal.hide(bannerActivity, Appodeal.BANNER);
+        }
+
+        if (bannerContainerView != null && bannerViews != null) {
+            for (View view : bannerViews) {
+                bannerContainerView.removeView(view);
+            }
+        }
+
+        bannerActivity = null;
+        bannerContainerView = null;
+        bannerViews = null;
+    }
+}
diff --git a/src/main/java/com/eightsines/esmediadtor/MediadtorListener.java b/src/main/java/com/eightsines/esmediadtor/MediadtorListener.java
new file mode 100644
index 0000000..0305d65
--- /dev/null
+++ b/src/main/java/com/eightsines/esmediadtor/MediadtorListener.java
@@ -0,0 +1,5 @@
+package com.eightsines.esmediadtor;
+
+public interface MediadtorListener {
+    void onRewardedVideoClosed(boolean shouldGiveReward);
+}
diff --git a/src/main/java/zame/promo/PromoView.java b/src/main/java/com/eightsines/espromo/PromoView.java
similarity index 72%
rename from src/main/java/zame/promo/PromoView.java
rename to src/main/java/com/eightsines/espromo/PromoView.java
index a511021..f53cc7a 100644
--- a/src/main/java/zame/promo/PromoView.java
+++ b/src/main/java/com/eightsines/espromo/PromoView.java
@@ -1,4 +1,4 @@
-package zame.promo;
+package com.eightsines.espromo;
 
 import android.annotation.SuppressLint;
 import android.content.Context;
@@ -9,6 +9,8 @@ import android.net.Uri;
 import android.os.Build;
 import android.os.Handler;
 import android.os.Message;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import android.util.AttributeSet;
 import android.view.View;
@@ -27,73 +29,97 @@ import java.util.Locale;
 import zame.game.BuildConfig;
 
 public class PromoView extends FrameLayout {
-    protected static final String PROMO_URL = "http://mobile.zame-dev.org/promo/index.php?package=";
+    interface Listener {
+        void onActivePromoLoaded();
 
-    protected static final long RELOAD_INTERVAL = 10L * 1000L;
-    protected static final long ROTATE_INTERVAL = 15L * 1000L;
+        void onActivePromoDismissed();
+    }
+
+    private static final String PROMO_URL = "http://mobile.zame-dev.org/promo/index.php?package=";
+
+    private static final long RELOAD_INTERVAL = 10L * 1000L;
+    private static final long ROTATE_INTERVAL = 15L * 1000L;
 
-    protected static final int STATE_INITIALIZED = 0;
-    protected static final int STATE_LOADING = 1;
-    protected static final int STATE_LOADED = 2;
-    protected static final int STATE_DISMISSED = 3;
+    private static final int STATE_INITIALIZED = 0;
+    private static final int STATE_LOADING = 1;
+    private static final int STATE_LOADED = 2;
+    private static final int STATE_DISMISSED = 3;
 
-    protected final Handler handler = new Handler();
-    protected Context context;
-    protected WebView prevWebView;
-    protected WebView currentWebView;
-    protected int state;
+    private final Handler handler = new Handler();
+    private Context context;
+    private WebView prevWebView;
+    private WebView currentWebView;
+    private int state;
+    private boolean activePromoLoaded;
+    private Listener listener;
 
-    protected Runnable loadPromoRunnable = new Runnable() {
+    private Runnable loadPromoRunnable = new Runnable() {
         @Override
         public void run() {
             loadPromo();
         }
     };
 
-    protected Runnable reloadPromoRunnable = new Runnable() {
+    private Runnable reloadPromoRunnable = new Runnable() {
         @Override
         public void run() {
             reloadPromo();
         }
     };
 
-    protected Runnable rotatePromoRunnable = new Runnable() {
+    private Runnable rotatePromoRunnable = new Runnable() {
         @Override
         public void run() {
             rotatePromo();
         }
     };
 
-    protected Runnable promoLoadedRunnable = new Runnable() {
+    private Runnable promoLoadedRunnable = new Runnable() {
         @Override
         public void run() {
             promoLoaded();
         }
     };
 
-    protected Runnable promoDismissedRunnable = new Runnable() {
+    private Runnable promoDismissedRunnable = new Runnable() {
         @Override
         public void run() {
             promoDismissed();
         }
     };
 
-    public PromoView(Context context) {
+    public PromoView(@NonNull Context context) {
         super(context);
         initialize(context);
     }
 
-    public PromoView(Context context, AttributeSet attrs) {
+    public PromoView(@NonNull Context context, @Nullable AttributeSet attrs) {
         super(context, attrs);
         initialize(context);
     }
 
-    public PromoView(Context context, AttributeSet attrs, int defStyle) {
+    public PromoView(@NonNull Context context, @Nullable AttributeSet attrs, int defStyle) {
         super(context, attrs, defStyle);
         initialize(context);
     }
 
-    protected void initialize(Context context) {
+    @SuppressWarnings("unused")
+    public boolean isActivePromoLoaded() {
+        return activePromoLoaded;
+    }
+
+    @SuppressWarnings("unused")
+    @Nullable
+    public Listener getListener() {
+        return listener;
+    }
+
+    @SuppressWarnings("unused")
+    public void setListener(@Nullable Listener listener) {
+        this.listener = listener;
+    }
+
+    private void initialize(@NonNull Context context) {
         this.context = context;
 
         prevWebView = createWebView();
@@ -103,7 +129,8 @@ public class PromoView extends FrameLayout {
     }
 
     @SuppressLint({ "AddJavascriptInterface", "ObsoleteSdkInt", "SetJavaScriptEnabled" })
-    protected WebView createWebView() {
+    @NonNull
+    private WebView createWebView() {
         WebView webView = new WebView(context);
         webView.addJavascriptInterface(new JsApi(), "promoApi");
         webView.setScrollBarStyle(View.SCROLLBARS_OUTSIDE_OVERLAY);
@@ -146,7 +173,7 @@ public class PromoView extends FrameLayout {
         return webView;
     }
 
-    protected void loadPromo() {
+    private void loadPromo() {
         handler.removeCallbacks(loadPromoRunnable);
         handler.removeCallbacks(reloadPromoRunnable);
         handler.removeCallbacks(rotatePromoRunnable);
@@ -172,7 +199,7 @@ public class PromoView extends FrameLayout {
         }
     }
 
-    protected void reloadPromo() {
+    private void reloadPromo() {
         currentWebView.setVisibility(View.INVISIBLE);
         currentWebView.stopLoading();
         currentWebView.loadData("", "text/html", null);
@@ -181,7 +208,7 @@ public class PromoView extends FrameLayout {
         loadPromo();
     }
 
-    protected void rotatePromo() {
+    private void rotatePromo() {
         WebView tmpWebView = prevWebView;
         prevWebView = currentWebView;
         currentWebView = tmpWebView;
@@ -189,7 +216,7 @@ public class PromoView extends FrameLayout {
         reloadPromo();
     }
 
-    protected void promoLoaded() {
+    private void promoLoaded() {
         if (state == STATE_LOADING) {
             currentWebView.setVisibility(View.VISIBLE);
 
@@ -199,10 +226,16 @@ public class PromoView extends FrameLayout {
 
             state = STATE_LOADED;
             handler.postDelayed(rotatePromoRunnable, ROTATE_INTERVAL);
+
+            activePromoLoaded = true;
+
+            if (listener != null) {
+                listener.onActivePromoLoaded();
+            }
         }
     }
 
-    protected void promoDismissed() {
+    private void promoDismissed() {
         if (state == STATE_LOADING || state == STATE_LOADED) {
             prevWebView.setVisibility(View.INVISIBLE);
             prevWebView.stopLoading();
@@ -213,7 +246,13 @@ public class PromoView extends FrameLayout {
             currentWebView.loadData("", "text/html", null);
 
             state = STATE_DISMISSED;
-            handler.postDelayed(rotatePromoRunnable, ROTATE_INTERVAL);
+            handler.post(rotatePromoRunnable); // rotate immediately
+
+            activePromoLoaded = false;
+
+            if (listener != null) {
+                listener.onActivePromoDismissed();
+            }
         }
     }
 
@@ -251,7 +290,7 @@ public class PromoView extends FrameLayout {
         super.onDetachedFromWindow();
     }
 
-    protected boolean isNetworkConnected() {
+    private boolean isNetworkConnected() {
         ConnectivityManager connectivityManager = (ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);
 
         if (connectivityManager == null) {
@@ -262,7 +301,7 @@ public class PromoView extends FrameLayout {
         return (networkInfo != null && networkInfo.isConnected());
     }
 
-    protected void openExternalBrowser(final String uri) {
+    private void openExternalBrowser(@NonNull final String uri) {
         handler.post(new Runnable() {
             @Override
             public void run() {
@@ -280,7 +319,7 @@ public class PromoView extends FrameLayout {
         });
     }
 
-    protected void openExternalIntent(final Intent intent) {
+    private void openExternalIntent(@NonNull final Intent intent) {
         handler.post(new Runnable() {
             @Override
             public void run() {
@@ -288,7 +327,7 @@ public class PromoView extends FrameLayout {
                     context.startActivity(intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET));
                 } catch (Exception ex) {
                     try {
-                        Toast.makeText(context, "Could not start external intent.", Toast.LENGTH_LONG).show();
+                        Toast.makeText(context, "Could not startBatch external intent.", Toast.LENGTH_LONG).show();
                     } catch (Exception inner) {
                         // ignored
                     }
@@ -298,7 +337,7 @@ public class PromoView extends FrameLayout {
     }
 
     @SuppressWarnings("unused")
-    protected class JsApi {
+    private class JsApi {
         @JavascriptInterface
         public void loaded() {
             //noinspection MagicNumber
@@ -311,10 +350,10 @@ public class PromoView extends FrameLayout {
         }
     }
 
-    protected class PromoWebViewClient extends WebViewClient {
+    private class PromoWebViewClient extends WebViewClient {
         @SuppressLint("ObsoleteSdkInt")
         @Override
-        public void onPageFinished(WebView view, String url) {
+        public void onPageFinished(@NonNull WebView view, @NonNull String url) {
             view.setBackgroundColor(0);
 
             if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
@@ -323,12 +362,13 @@ public class PromoView extends FrameLayout {
         }
 
         @Override
-        public boolean shouldOverrideUrlLoading(WebView view, String url) {
+        public boolean shouldOverrideUrlLoading(@NonNull WebView view, @NonNull String url) {
             final String MAILTO_PREFIX = "mailto:";
 
             if (url.startsWith(MAILTO_PREFIX)) {
                 Intent intent = new Intent(Intent.ACTION_SENDTO,
                         Uri.fromParts("mailto", url.replaceFirst(MAILTO_PREFIX, ""), null));
+
                 openExternalIntent(intent);
                 return true;
             }
@@ -337,15 +377,20 @@ public class PromoView extends FrameLayout {
         }
 
         @SuppressLint("NewApi")
+        @Nullable
         @Override
-        public WebResourceResponse shouldInterceptRequest(WebView view, String url) {
+        public WebResourceResponse shouldInterceptRequest(@NonNull WebView view, @NonNull String url) {
             final String ANDROID_ASSET = "file:///android_asset/";
 
             if (url.startsWith(ANDROID_ASSET)) {
                 try {
                     Uri uri = Uri.parse(url.replaceFirst(ANDROID_ASSET, ""));
-                    InputStream stream = view.getContext().getAssets().open(uri.getPath());
-                    return new WebResourceResponse("text/html", "UTF-8", stream);
+                    String path = uri.getPath();
+
+                    if (path != null) {
+                        InputStream stream = view.getContext().getAssets().open(path);
+                        return new WebResourceResponse("text/html", "UTF-8", stream);
+                    }
                 } catch (Exception ex) {
                     // ignored
                 }
@@ -355,7 +400,11 @@ public class PromoView extends FrameLayout {
         }
 
         @Override
-        public void onReceivedError(WebView view, int errorCode, String description, String failingUrl) {
+        public void onReceivedError(@NonNull WebView view,
+                int errorCode,
+                @NonNull String description,
+                @NonNull String failingUrl) {
+
             view.stopLoading();
             view.loadData("", "text/html", null);
 
@@ -363,10 +412,10 @@ public class PromoView extends FrameLayout {
         }
 
         @Override
-        public void onReceivedHttpAuthRequest(WebView view,
-                HttpAuthHandler httpAuthHandler,
-                String host,
-                String realm) {
+        public void onReceivedHttpAuthRequest(@NonNull WebView view,
+                @NonNull HttpAuthHandler httpAuthHandler,
+                @NonNull String host,
+                @NonNull String realm) {
 
             view.stopLoading();
             view.loadData("", "text/html", null);
@@ -375,11 +424,15 @@ public class PromoView extends FrameLayout {
         }
     }
 
-    protected class PromoWebChromeClient extends WebChromeClient {
-        WebView childWebView;
+    private class PromoWebChromeClient extends WebChromeClient {
+        private WebView childWebView;
 
         @Override
-        public boolean onCreateWindow(WebView view, boolean dialog, boolean userGesture, Message resultMsg) {
+        public boolean onCreateWindow(@NonNull WebView view,
+                boolean dialog,
+                boolean userGesture,
+                @NonNull Message resultMsg) {
+
             try {
                 if (childWebView != null) {
                     childWebView.stopLoading();
diff --git a/src/main/java/com/eightsines/estracker/Tracker.java b/src/main/java/com/eightsines/estracker/Tracker.java
new file mode 100644
index 0000000..a112337
--- /dev/null
+++ b/src/main/java/com/eightsines/estracker/Tracker.java
@@ -0,0 +1,20 @@
+package com.eightsines.estracker;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+public interface Tracker {
+    @SuppressWarnings("unused")
+    boolean getCrashedConsent();
+
+    void setCrashesConsent(boolean shouldSendCrashes);
+
+    @SuppressWarnings("unused")
+    boolean getAnalyticsConsent();
+
+    void setAnalyticsConsent(boolean shouldSendAnalytics);
+
+    void trackEvent(@NonNull String name);
+
+    void trackEvent(@NonNull String name, @Nullable String param);
+}
diff --git a/src/main/java/com/eightsines/estracker/TrackerFactory.java b/src/main/java/com/eightsines/estracker/TrackerFactory.java
new file mode 100644
index 0000000..b68a0b5
--- /dev/null
+++ b/src/main/java/com/eightsines/estracker/TrackerFactory.java
@@ -0,0 +1,22 @@
+package com.eightsines.estracker;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.eightsines.estracker.tracker.AppCenterTracker;
+import com.eightsines.estracker.tracker.DummyTracker;
+
+@SuppressWarnings("unused")
+public final class TrackerFactory {
+    private TrackerFactory() {
+    }
+
+    @NonNull
+    public static Tracker create(@NonNull Context context, @Nullable String applicationKey) {
+        if (applicationKey == null) {
+            return new DummyTracker();
+        }
+
+        return new AppCenterTracker(context, applicationKey);
+    }
+}
diff --git a/src/main/java/com/eightsines/estracker/tracker/AbstractTracker.java b/src/main/java/com/eightsines/estracker/tracker/AbstractTracker.java
new file mode 100644
index 0000000..bd7e26a
--- /dev/null
+++ b/src/main/java/com/eightsines/estracker/tracker/AbstractTracker.java
@@ -0,0 +1,46 @@
+package com.eightsines.estracker.tracker;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.eightsines.estracker.Tracker;
+import zame.game.flavour.config.AppConfig;
+
+public abstract class AbstractTracker implements Tracker {
+    @SuppressWarnings("WeakerAccess") protected boolean shouldSendCrashes;
+    @SuppressWarnings("WeakerAccess") protected boolean shouldSendAnalytics;
+
+    @Override
+    public boolean getCrashedConsent() {
+        return shouldSendCrashes;
+    }
+
+    @Override
+    public void setCrashesConsent(boolean shouldSendCrashes) {
+        this.shouldSendCrashes = shouldSendCrashes;
+    }
+
+    @Override
+    public boolean getAnalyticsConsent() {
+        return shouldSendAnalytics;
+    }
+
+    @Override
+    public void setAnalyticsConsent(boolean shouldSendAnalytics) {
+        this.shouldSendAnalytics = shouldSendAnalytics;
+    }
+
+    @Override
+    public void trackEvent(@NonNull String name) {
+        trackEvent(name, null);
+    }
+
+    @Override
+    public void trackEvent(@NonNull String name, @Nullable String param) {
+        if (shouldSendAnalytics) {
+            trackEventInternal(AppConfig.DEBUG ? ("[debug] " + name) : name, param);
+        }
+    }
+
+    @SuppressWarnings("WeakerAccess")
+    protected abstract void trackEventInternal(@NonNull String name, @Nullable String param);
+}
diff --git a/src/main/java/com/eightsines/estracker/tracker/AppCenterTracker.java b/src/main/java/com/eightsines/estracker/tracker/AppCenterTracker.java
new file mode 100644
index 0000000..eacc4d8
--- /dev/null
+++ b/src/main/java/com/eightsines/estracker/tracker/AppCenterTracker.java
@@ -0,0 +1,48 @@
+package com.eightsines.estracker.tracker;
+
+import android.app.Application;
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.microsoft.appcenter.AppCenter;
+import com.microsoft.appcenter.analytics.Analytics;
+import com.microsoft.appcenter.analytics.EventProperties;
+import com.microsoft.appcenter.crashes.AbstractCrashesListener;
+import com.microsoft.appcenter.crashes.Crashes;
+import com.microsoft.appcenter.crashes.model.ErrorReport;
+
+public class AppCenterTracker extends AbstractTracker {
+    private static final String KEY_PARAM = "Param";
+
+    public AppCenterTracker(@NonNull Context context, @NonNull String applicationKey) {
+        super();
+        AppCenter.start((Application)context.getApplicationContext(), applicationKey, Analytics.class, Crashes.class);
+
+        Crashes.setListener(new AbstractCrashesListener() {
+            @Override
+            public boolean shouldProcess(ErrorReport report) {
+                return shouldSendCrashes;
+            }
+        });
+    }
+
+    @Override
+    public void setCrashesConsent(boolean shouldSendCrashes) {
+        super.setCrashesConsent(shouldSendCrashes);
+
+        if (shouldSendCrashes) {
+            Crashes.notifyUserConfirmation(Crashes.ALWAYS_SEND);
+        } else {
+            Crashes.notifyUserConfirmation(Crashes.DONT_SEND);
+        }
+    }
+
+    @Override
+    public void trackEventInternal(@NonNull String name, @Nullable String param) {
+        if (param == null) {
+            Analytics.trackEvent(name);
+        } else {
+            Analytics.trackEvent(name, new EventProperties().set(KEY_PARAM, param));
+        }
+    }
+}
diff --git a/src/main/java/com/eightsines/estracker/tracker/DummyTracker.java b/src/main/java/com/eightsines/estracker/tracker/DummyTracker.java
new file mode 100644
index 0000000..4ec1eed
--- /dev/null
+++ b/src/main/java/com/eightsines/estracker/tracker/DummyTracker.java
@@ -0,0 +1,18 @@
+package com.eightsines.estracker.tracker;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Log;
+
+public class DummyTracker extends AbstractTracker {
+    private static final String TAG = "EsTracker";
+
+    @Override
+    protected void trackEventInternal(@NonNull String name, @Nullable String param) {
+        if (param == null) {
+            Log.e(TAG, name);
+        } else {
+            Log.e(TAG, name + ": " + param);
+        }
+    }
+}
diff --git a/src/main/java/zame/game/App.java b/src/main/java/zame/game/App.java
index 5e75523..afacacf 100644
--- a/src/main/java/zame/game/App.java
+++ b/src/main/java/zame/game/App.java
@@ -1,69 +1,105 @@
 package zame.game;
 
-import android.app.Application;
-import android.content.SharedPreferences;
 import android.graphics.Typeface;
 import android.os.Handler;
+import android.support.multidex.MultiDexApplication;
 import android.support.v4.content.LocalBroadcastManager;
 import android.support.v7.preference.PreferenceManager;
 import android.text.TextUtils;
 import android.widget.Toast;
-import com.crashlytics.android.Crashlytics;
-import io.fabric.sdk.android.Fabric;
+import com.eightsines.esmediadtor.Mediadtor;
+import com.eightsines.estracker.Tracker;
+import com.eightsines.estracker.TrackerFactory;
+import com.jakewharton.processphoenix.ProcessPhoenix;
 import java.io.File;
 import java.io.IOException;
-import zame.game.managers.SoundManager;
-import zame.game.misc.Tracker;
-import zame.game.misc.TrackerDummy;
-import zame.game.providers.CachedTexturesProvider;
-import zame.game.store.Profile;
+import java.util.Locale;
+import zame.game.core.manager.PreferencesManager;
+import zame.game.core.util.Common;
+import zame.game.engine.state.Profile;
+import zame.game.feature.prepare.CachedTexturesProvider;
+import zame.game.feature.sound.SoundManager;
+import zame.game.flavour.config.AppConfig;
+
+public class App extends MultiDexApplication {
+    public static final Locale LOCALE_RU = new Locale("ru", "RU");
 
-public class App extends Application {
     public static App self;
 
     public final Handler handler = new Handler();
-    public boolean isLargeDevice;
+    public final Locale systemDefaultLocale = Locale.getDefault();
+    public Tracker tracker;
     public String internalRoot;
-    public Tracker trackerInst;
-    public SoundManager soundManagerInst;
-    public Profile profile = new Profile();
-    public CachedTexturesProvider.Task cachedTexturesTask;
+    public Profile profile;
+    public PreferencesManager preferences;
+    public boolean isLargeDevice;
+    public float controlsScale;
+    public Mediadtor mediadtor;
     public Typeface cachedTypeface;
+    public SoundManager soundManagerInstance;
+    public CachedTexturesProvider.Task cachedTexturesTask;
     public volatile boolean cachedTexturesReady;
-    public float controlsScale;
-
     private String cachedVersionName;
 
     @Override
     public void onCreate() {
         super.onCreate();
-        Fabric.with(new Fabric.Builder(this).kits(new Crashlytics()).debuggable(BuildConfig.DEBUG).build());
+
+        if (ProcessPhoenix.isPhoenixProcess(this)) {
+            return;
+        }
 
         self = this;
-        isLargeDevice = getResources().getBoolean(R.bool.gloomy_device_large);
+
+        tracker = TrackerFactory.create(this, AppConfig.DEBUG_TRACKER ? null : AppConfig.APPCENTER_KEY);
         internalRoot = getInternalStoragePath() + File.separator;
+        profile = new Profile();
+        preferences = new PreferencesManager();
+        isLargeDevice = getResources().getBoolean(R.bool.gloomy_device_large);
 
-        initPreferences();
-        initTracker();
+        //noinspection MagicNumber
+        controlsScale = isLargeDevice ? 0.75f : 1.0f;
 
-        if (getSharedPreferences().getBoolean("FirstRun", true)) {
-            profile.load(false);
-            profile.save();
+        PreferenceManager.setDefaultValues(getApplicationContext(), R.xml.preferences, false);
 
-            getSharedPreferences().edit().putBoolean("FirstRun", false).apply();
-        } else {
-            profile.load();
+        if (preferences.getInt(R.string.key_rotate_speed) == 0) {
+            preferences.putInt(R.string.key_rotate_speed, isLargeDevice ? 8 : 4);
         }
-    }
 
-    public SharedPreferences getSharedPreferences() {
-        return PreferenceManager.getDefaultSharedPreferences(getApplicationContext());
+        applyConsent();
+        profile.loadInitial(this);
     }
 
-    public LocalBroadcastManager getLocalBroadcastManager() {
+    public LocalBroadcastManager getBroadcastManager() {
         return LocalBroadcastManager.getInstance(getApplicationContext());
     }
 
+    public void applyConsent() {
+        boolean isConsentChosen = preferences.getBoolean(R.string.key_is_consent_chosen);
+
+        tracker.setCrashesConsent(isConsentChosen && preferences.getBoolean(R.string.key_consent_crashes));
+        tracker.setAnalyticsConsent(isConsentChosen && preferences.getBoolean(R.string.key_consent_analytics));
+
+        mediadtor = new Mediadtor(
+                AppConfig.APPODEAL_KEY,
+                isConsentChosen && preferences.getBoolean(R.string.key_consent_ad_personalization),
+                AppConfig.DEBUG_MEDIADTOR);
+    }
+
+    public String getVersionName() {
+        if (cachedVersionName == null) {
+            cachedVersionName = "xxxx.xx.xx.xxxx";
+
+            try {
+                cachedVersionName = getPackageManager().getPackageInfo(getPackageName(), 0).versionName;
+            } catch (Exception ex) {
+                Common.log(ex);
+            }
+        }
+
+        return cachedVersionName;
+    }
+
     private String getInternalStoragePath() {
         String result = "";
         final String errorMessage = "Can't open internal storage";
@@ -85,35 +121,4 @@ public class App extends Application {
 
         return result;
     }
-
-    private void initPreferences() {
-        SharedPreferences sp = getSharedPreferences();
-
-        //noinspection MagicNumber
-        controlsScale = isLargeDevice ? 0.75f : 1.0f;
-
-        if (sp.getInt("RotateSpeed", 0) == 0) {
-            sp.edit().putInt("RotateSpeed", isLargeDevice ? 8 : 4).apply();
-        }
-
-        PreferenceManager.setDefaultValues(getApplicationContext(), R.xml.preferences, false);
-    }
-
-    private void initTracker() {
-        trackerInst = new TrackerDummy();
-    }
-
-    public String getVersionName() {
-        if (cachedVersionName == null) {
-            cachedVersionName = "xxxx.xx.xx.xxxx";
-
-            try {
-                cachedVersionName = getPackageManager().getPackageInfo(getPackageName(), 0).versionName;
-            } catch (Exception ex) {
-                Common.log(ex);
-            }
-        }
-
-        return cachedVersionName;
-    }
 }
diff --git a/src/main/java/zame/game/CommonGPlayHelper.java b/src/main/java/zame/game/CommonGPlayHelper.java
deleted file mode 100644
index 15526a9..0000000
--- a/src/main/java/zame/game/CommonGPlayHelper.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package zame.game;
-
-import android.content.Context;
-import android.content.Intent;
-import android.net.Uri;
-
-public final class CommonGPlayHelper {
-    public static final String RATE_DISLIKE_LINK = "http://eightsines.com/fire-strike/index.php?action=dislike&utm_medium=referral&utm_source=ingame&utm_campaign=ingame&hl=";
-
-    private CommonGPlayHelper() {
-    }
-
-    public static void openMarket(Context context, String packageName) {
-        try {
-            context.startActivity((new Intent(Intent.ACTION_VIEW,
-                    Uri.parse("market://details?id="
-                            + packageName))).addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET));
-        } catch (Exception ex) {
-            Common.log(ex);
-            Common.showToast("Could not launch the market application.");
-        }
-    }
-}
diff --git a/src/main/java/zame/game/MainActivityGPlayHelper.java b/src/main/java/zame/game/MainActivityGPlayHelper.java
deleted file mode 100644
index 0b15d67..0000000
--- a/src/main/java/zame/game/MainActivityGPlayHelper.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package zame.game;
-
-import android.content.Intent;
-import android.content.SharedPreferences;
-import zame.game.fragments.dialogs.RateGameDialogFragment;
-
-class MainActivityGPlayHelper {
-    private RateGameDialogFragment rateGameDialogFragment;
-    @SuppressWarnings("BooleanVariableAlwaysNegated") private boolean rateGameDialogShown;
-
-    void onCreate() {
-        rateGameDialogFragment = RateGameDialogFragment.newInstance(true);
-        rateGameDialogShown = false;
-    }
-
-    boolean onBackPressed(MainActivity activity) {
-        SharedPreferences sp = App.self.getSharedPreferences();
-
-        if (!rateGameDialogShown && sp.getInt("QuitCount", 0) == 3 - 1) {
-            rateGameDialogShown = true;
-            rateGameDialogFragment.show(activity.getSupportFragmentManager());
-            return false;
-        }
-
-        return true;
-    }
-
-    void quitGame() {
-        SharedPreferences sp = App.self.getSharedPreferences();
-        sp.edit().putInt("QuitCount", sp.getInt("QuitCount", 0) + 1).apply();
-    }
-
-    @SuppressWarnings("unused")
-    void onActivityResult(MainActivity activity, int requestCode, int resultCode, Intent data) {
-    }
-}
diff --git a/src/main/java/zame/game/fragments/ActionBarFragment.java b/src/main/java/zame/game/core/app/ActionBarFragment.java
similarity index 80%
rename from src/main/java/zame/game/fragments/ActionBarFragment.java
rename to src/main/java/zame/game/core/app/ActionBarFragment.java
index 3fb7d56..1c30ad7 100644
--- a/src/main/java/zame/game/fragments/ActionBarFragment.java
+++ b/src/main/java/zame/game/core/app/ActionBarFragment.java
@@ -1,4 +1,4 @@
-package zame.game.fragments;
+package zame.game.core.app;
 
 import android.support.v7.app.ActionBar;
 
diff --git a/src/main/java/zame/game/core/app/AppContextWrapper.java b/src/main/java/zame/game/core/app/AppContextWrapper.java
new file mode 100644
index 0000000..3ba3bd1
--- /dev/null
+++ b/src/main/java/zame/game/core/app/AppContextWrapper.java
@@ -0,0 +1,36 @@
+package zame.game.core.app;
+
+import android.content.Context;
+import android.content.ContextWrapper;
+import android.content.res.Configuration;
+import android.content.res.Resources;
+import android.os.Build;
+import android.os.LocaleList;
+import java.util.Locale;
+
+public class AppContextWrapper extends ContextWrapper {
+    public AppContextWrapper(Context base) {
+        super(base);
+    }
+
+    // Based on https://stackoverflow.com/a/40849142
+    public static AppContextWrapper wrap(Context context, Locale newLocale) {
+        Resources res = context.getResources();
+        Configuration configuration = res.getConfiguration();
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
+            LocaleList localeList = new LocaleList(newLocale);
+            LocaleList.setDefault(localeList);
+            configuration.setLocales(localeList);
+            context = context.createConfigurationContext(configuration);
+        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
+            configuration.setLocale(newLocale);
+            context = context.createConfigurationContext(configuration);
+        } else {
+            configuration.locale = newLocale;
+            res.updateConfiguration(configuration, res.getDisplayMetrics());
+        }
+
+        return new AppContextWrapper(context);
+    }
+}
diff --git a/src/main/java/zame/game/core/app/BackPressedHandler.java b/src/main/java/zame/game/core/app/BackPressedHandler.java
new file mode 100644
index 0000000..64366d2
--- /dev/null
+++ b/src/main/java/zame/game/core/app/BackPressedHandler.java
@@ -0,0 +1,5 @@
+package zame.game.core.app;
+
+public interface BackPressedHandler {
+    boolean onBackPressed();
+}
diff --git a/src/main/java/zame/game/core/app/BaseActivity.java b/src/main/java/zame/game/core/app/BaseActivity.java
new file mode 100644
index 0000000..b3b6bf0
--- /dev/null
+++ b/src/main/java/zame/game/core/app/BaseActivity.java
@@ -0,0 +1,66 @@
+package zame.game.core.app;
+
+import android.content.Context;
+import android.os.Build;
+import android.support.v7.app.AppCompatActivity;
+import android.view.View;
+import java.util.Locale;
+import zame.game.App;
+import zame.game.R;
+
+public abstract class BaseActivity extends AppCompatActivity {
+    @Override
+    protected void attachBaseContext(Context newBase) {
+        super.attachBaseContext(wrapBaseContext(newBase));
+    }
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+        ensureImmersive();
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        ensureImmersive();
+    }
+
+    @Override
+    public void onWindowFocusChanged(boolean hasFocus) {
+        super.onWindowFocusChanged(hasFocus);
+
+        if (hasFocus) {
+            ensureImmersive();
+        }
+    }
+
+    protected void ensureImmersive() {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+            View decorView = getWindow().getDecorView();
+
+            // Just for case
+            if (decorView != null) {
+                decorView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_IMMERSIVE
+                        | View.SYSTEM_UI_FLAG_FULLSCREEN
+                        | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION);
+            }
+        }
+    }
+
+    protected Context wrapBaseContext(Context newBase) {
+        String language = App.self.preferences.getString(R.string.key_language, R.string.val_language_sys);
+        Locale currentLocale;
+
+        if (App.self.getString(R.string.val_language_en).equals(language)) {
+            currentLocale = Locale.US;
+        } else if (App.self.getString(R.string.val_language_ru).equals(language)) {
+            currentLocale = App.LOCALE_RU;
+        } else {
+            currentLocale = App.self.systemDefaultLocale;
+        }
+
+        Locale.setDefault(currentLocale);
+        return AppContextWrapper.wrap(newBase, currentLocale);
+    }
+}
diff --git a/src/main/java/zame/game/fragments/dialogs/BaseDialogFragment.java b/src/main/java/zame/game/core/app/BaseDialogFragment.java
similarity index 57%
rename from src/main/java/zame/game/fragments/dialogs/BaseDialogFragment.java
rename to src/main/java/zame/game/core/app/BaseDialogFragment.java
index 1d32eb6..937588a 100644
--- a/src/main/java/zame/game/fragments/dialogs/BaseDialogFragment.java
+++ b/src/main/java/zame/game/core/app/BaseDialogFragment.java
@@ -1,16 +1,19 @@
-package zame.game.fragments.dialogs;
+package zame.game.core.app;
 
 import android.content.Context;
 import android.content.DialogInterface;
+import android.os.Build;
 import android.support.v4.app.DialogFragment;
 import android.support.v4.app.FragmentManager;
+import android.view.View;
 import android.view.Window;
-import zame.game.Common;
-import zame.game.managers.SoundManager;
-import zame.game.managers.WindowCallbackManager;
+import zame.game.core.manager.WindowCallbackManager;
+import zame.game.core.util.Common;
+import zame.game.feature.sound.SoundManager;
 
 public abstract class BaseDialogFragment extends DialogFragment {
-    protected Window window;
+    private Window window;
+
     protected SoundManager soundManager;
     protected boolean shouldSoundPauseInstantlyOnDismiss;
 
@@ -41,12 +44,33 @@ public abstract class BaseDialogFragment extends DialogFragment {
     public void onStart() {
         super.onStart();
 
-        if (getDialog() != null) {
+        if (getDialog() == null) {
+            return;
+        }
+
+        if (isCancelable()) {
             getDialog().setCanceledOnTouchOutside(true);
+        }
+
+        if (window == getDialog().getWindow()) {
+            return;
+        }
 
-            if (window != getDialog().getWindow()) {
-                window = getDialog().getWindow();
-                WindowCallbackManager.attachWindowCallback(window, soundManager, getFocusMask());
+        window = getDialog().getWindow();
+
+        if (window == null) {
+            return;
+        }
+
+        WindowCallbackManager.attachWindowCallback(window, soundManager, getFocusMask());
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+            View decorView = window.getDecorView();
+
+            if (decorView != null) {
+                decorView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_IMMERSIVE
+                        | View.SYSTEM_UI_FLAG_FULLSCREEN
+                        | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION);
             }
         }
     }
@@ -54,6 +78,7 @@ public abstract class BaseDialogFragment extends DialogFragment {
     @Override
     public void onDismiss(DialogInterface dialog) {
         super.onDismiss(dialog);
+
         soundManager.instantPause = shouldSoundPauseInstantlyOnDismiss;
         soundManager.onWindowFocusChanged(false, getFocusMask());
     }
diff --git a/src/main/java/zame/game/core/app/BaseFragment.java b/src/main/java/zame/game/core/app/BaseFragment.java
new file mode 100644
index 0000000..9534855
--- /dev/null
+++ b/src/main/java/zame/game/core/app/BaseFragment.java
@@ -0,0 +1,35 @@
+package zame.game.core.app;
+
+import android.content.Context;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.v4.app.Fragment;
+import android.view.View;
+import zame.game.App;
+import zame.game.feature.main.MainActivity;
+
+public abstract class BaseFragment extends Fragment {
+    protected MainActivity activity;
+
+    @Override
+    public void onAttach(Context context) {
+        super.onAttach(context);
+
+        this.activity = (MainActivity)context;
+        this.activity.setupTabs();
+    }
+
+    @Override
+    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
+        super.onViewCreated(view, savedInstanceState);
+        onShowBanner();
+    }
+
+    protected void onShowBanner() {
+        App.self.mediadtor.hideBanner(activity);
+    }
+
+    public void onWindowFocusChanged(boolean hasWindowFocus) {
+    }
+}
diff --git a/src/main/java/zame/game/core/manager/PreferencesManager.java b/src/main/java/zame/game/core/manager/PreferencesManager.java
new file mode 100644
index 0000000..6f17a56
--- /dev/null
+++ b/src/main/java/zame/game/core/manager/PreferencesManager.java
@@ -0,0 +1,49 @@
+package zame.game.core.manager;
+
+import android.content.SharedPreferences;
+import android.support.annotation.Nullable;
+import android.support.v7.preference.PreferenceManager;
+import zame.game.App;
+import zame.game.R;
+
+public class PreferencesManager {
+    public boolean getBoolean(int keyResId) {
+        return getPreferences().getBoolean(getRes(keyResId), false);
+    }
+
+    public boolean getBoolean(int keyResId, boolean defValue) {
+        return getPreferences().getBoolean(getRes(keyResId), defValue);
+    }
+
+    public void putBoolean(int keyResId, boolean value) {
+        getPreferences().edit().putBoolean(getRes(keyResId), value).apply();
+    }
+
+    public int getInt(int keyResId) {
+        return getPreferences().getInt(getRes(keyResId), 0);
+    }
+
+    public int getInt(int keyResId, int defValue) {
+        return getPreferences().getInt(getRes(keyResId), defValue);
+    }
+
+    public void putInt(int keyResId, int value) {
+        getPreferences().edit().putInt(getRes(keyResId), value).apply();
+    }
+
+    public String getString(int keyResId, @Nullable String defValue) {
+        return getPreferences().getString(getRes(keyResId), defValue);
+    }
+
+    public String getString(int keyResId, int defValueResId) {
+        return getPreferences().getString(getRes(keyResId), getRes(defValueResId));
+    }
+
+    private String getRes(int keyResId) {
+        return App.self.getString(keyResId);
+    }
+
+    private SharedPreferences getPreferences() {
+        return PreferenceManager.getDefaultSharedPreferences(App.self.getApplicationContext());
+    }
+}
diff --git a/src/main/java/zame/game/managers/WindowCallbackManager.java b/src/main/java/zame/game/core/manager/WindowCallbackManager.java
similarity index 98%
rename from src/main/java/zame/game/managers/WindowCallbackManager.java
rename to src/main/java/zame/game/core/manager/WindowCallbackManager.java
index 8189bef..c2aa1ce 100644
--- a/src/main/java/zame/game/managers/WindowCallbackManager.java
+++ b/src/main/java/zame/game/core/manager/WindowCallbackManager.java
@@ -1,4 +1,4 @@
-package zame.game.managers;
+package zame.game.core.manager;
 
 import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
@@ -17,6 +17,7 @@ import android.view.Window;
 import android.view.WindowManager;
 import android.view.accessibility.AccessibilityEvent;
 import java.util.List;
+import zame.game.feature.sound.SoundManager;
 
 public final class WindowCallbackManager {
     private WindowCallbackManager() {}
diff --git a/src/main/java/zame/game/core/preference/CheckBoxPreference.java b/src/main/java/zame/game/core/preference/CheckBoxPreference.java
new file mode 100644
index 0000000..72f6379
--- /dev/null
+++ b/src/main/java/zame/game/core/preference/CheckBoxPreference.java
@@ -0,0 +1,35 @@
+package zame.game.core.preference;
+
+import android.content.Context;
+import android.support.v7.preference.PreferenceViewHolder;
+import android.util.AttributeSet;
+import android.widget.TextView;
+
+public class CheckBoxPreference extends android.support.v7.preference.CheckBoxPreference {
+    public CheckBoxPreference(Context context) {
+        super(context);
+    }
+
+    public CheckBoxPreference(Context context, AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    public CheckBoxPreference(Context context, AttributeSet attrs, int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+    }
+
+    public CheckBoxPreference(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
+        super(context, attrs, defStyleAttr, defStyleRes);
+    }
+
+    @Override
+    public void onBindViewHolder(PreferenceViewHolder holder) {
+        final TextView summaryView = (TextView)holder.findViewById(android.R.id.summary);
+
+        if (summaryView != null) {
+            summaryView.setMaxLines(Integer.MAX_VALUE);
+        }
+
+        super.onBindViewHolder(holder);
+    }
+}
diff --git a/src/main/java/zame/game/libs/KeyMapPreference.java b/src/main/java/zame/game/core/preference/KeyMapPreference.java
similarity index 93%
rename from src/main/java/zame/game/libs/KeyMapPreference.java
rename to src/main/java/zame/game/core/preference/KeyMapPreference.java
index 1642290..ad32f02 100644
--- a/src/main/java/zame/game/libs/KeyMapPreference.java
+++ b/src/main/java/zame/game/core/preference/KeyMapPreference.java
@@ -1,4 +1,4 @@
-package zame.game.libs;
+package zame.game.core.preference;
 
 import android.content.Context;
 import android.content.res.TypedArray;
@@ -14,7 +14,7 @@ public class KeyMapPreference extends DialogPreference {
                 KeyMapPreferenceDialogFragmentCompat.class);
     }
 
-    int mValue;
+    private int value;
 
     @SuppressWarnings("unused")
     public KeyMapPreference(Context context) {
@@ -25,10 +25,18 @@ public class KeyMapPreference extends DialogPreference {
     public KeyMapPreference(Context context, AttributeSet attrs) {
         super(context, attrs);
 
-        setPositiveButtonText(R.string.lib_clear);
+        setPositiveButtonText(R.string.core_preference_clear);
         updateSummary();
     }
 
+    public int getValue() {
+        return value;
+    }
+
+    public void setValue(int value) {
+        this.value = value;
+    }
+
     @Override
     protected Object onGetDefaultValue(TypedArray a, int index) {
         return a.getInteger(index, 0);
@@ -38,20 +46,20 @@ public class KeyMapPreference extends DialogPreference {
     protected void onSetInitialValue(boolean restore, Object defaultValue) {
         super.onSetInitialValue(restore, defaultValue);
 
-        mValue = (restore ? getPersistedInt(mValue) : ((defaultValue == null) ? mValue : (Integer)defaultValue));
+        value = (restore ? getPersistedInt(value) : ((defaultValue == null) ? value : (Integer)defaultValue));
 
         if (!restore && shouldPersist()) {
-            persistInt(mValue);
+            persistInt(value);
         }
 
         updateSummary();
     }
 
     void updateSummary() {
-        if (mValue == 0) {
-            setSummary(R.string.lib_none);
+        if (value == 0) {
+            setSummary(R.string.core_preference_none);
         } else {
-            setSummary(getKeyNameByCode(mValue));
+            setSummary(getKeyNameByCode(value));
         }
     }
 
@@ -332,7 +340,7 @@ public class KeyMapPreference extends DialogPreference {
                 return "MENU";
         }
 
-        return "<UNKNOWN>";
+        return "<UNKNOWN:" + keyCode + ">";
     }
 
     @Override
diff --git a/src/main/java/zame/game/libs/KeyMapPreferenceDialogFragmentCompat.java b/src/main/java/zame/game/core/preference/KeyMapPreferenceDialogFragmentCompat.java
similarity index 87%
rename from src/main/java/zame/game/libs/KeyMapPreferenceDialogFragmentCompat.java
rename to src/main/java/zame/game/core/preference/KeyMapPreferenceDialogFragmentCompat.java
index febef31..3833877 100644
--- a/src/main/java/zame/game/libs/KeyMapPreferenceDialogFragmentCompat.java
+++ b/src/main/java/zame/game/core/preference/KeyMapPreferenceDialogFragmentCompat.java
@@ -1,4 +1,4 @@
-package zame.game.libs;
+package zame.game.core.preference;
 
 import android.content.Context;
 import android.content.DialogInterface;
@@ -9,7 +9,7 @@ import android.view.KeyEvent;
 import android.view.View;
 import android.widget.LinearLayout;
 import android.widget.TextView;
-import zame.game.Common;
+import zame.game.core.util.Common;
 import zame.game.R;
 
 public class KeyMapPreferenceDialogFragmentCompat extends PreferenceDialogFragmentCompat {
@@ -25,7 +25,7 @@ public class KeyMapPreferenceDialogFragmentCompat extends PreferenceDialogFragme
         TextView text = new TextView(context);
         text.setGravity(Gravity.CENTER_HORIZONTAL);
         text.setTextSize(HELP_TEXT_SIZE);
-        text.setText(R.string.lib_press_key);
+        text.setText(R.string.core_preference_press_key);
 
         LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.FILL_PARENT,
                 LinearLayout.LayoutParams.WRAP_CONTENT);
@@ -42,11 +42,11 @@ public class KeyMapPreferenceDialogFragmentCompat extends PreferenceDialogFragme
                 if (Common.canUseKey(keyCode)) {
                     KeyMapPreference pref = (KeyMapPreference)getPreference();
 
-                    pref.mValue = keyCode;
+                    pref.setValue(keyCode);
                     pref.updateSummary();
 
                     if (pref.shouldPersist()) {
-                        pref.persistInt(pref.mValue);
+                        pref.persistInt(pref.getValue());
                     }
 
                     getDialog().dismiss();
@@ -63,11 +63,11 @@ public class KeyMapPreferenceDialogFragmentCompat extends PreferenceDialogFragme
         if (positiveResult) {
             KeyMapPreference pref = (KeyMapPreference)getPreference();
 
-            pref.mValue = 0;
+            pref.setValue(0);
             pref.updateSummary();
 
             if (pref.shouldPersist()) {
-                pref.persistInt(pref.mValue);
+                pref.persistInt(pref.getValue());
             }
         }
     }
diff --git a/src/main/java/zame/game/libs/SeekBarPreference.java b/src/main/java/zame/game/core/preference/SeekBarPreference.java
similarity index 73%
rename from src/main/java/zame/game/libs/SeekBarPreference.java
rename to src/main/java/zame/game/core/preference/SeekBarPreference.java
index 686b4a2..5bb024b 100644
--- a/src/main/java/zame/game/libs/SeekBarPreference.java
+++ b/src/main/java/zame/game/core/preference/SeekBarPreference.java
@@ -11,7 +11,7 @@
  *
  */
 
-package zame.game.libs;
+package zame.game.core.preference;
 
 import android.content.Context;
 import android.content.res.TypedArray;
@@ -27,17 +27,18 @@ public class SeekBarPreference extends DialogPreference {
                 SeekBarPreferenceDialogFragmentCompat.class);
     }
 
-    int mMin;
-    int mMax;
-    int mValue;
-    String mSummary = "%s/%s";
+    static final String SUMMARY_FORMAT = "%s/%s";
+
+    private int min;
+    private int max;
+    private int progress;
 
     public SeekBarPreference(Context context, AttributeSet attrs) {
         super(context, attrs);
 
         TypedArray app = context.obtainStyledAttributes(attrs, R.styleable.SeekBarPreference);
-        mMin = app.getInt(R.styleable.SeekBarPreference_xmin, 0);
-        mMax = app.getInt(R.styleable.SeekBarPreference_xmax, 100);
+        min = app.getInt(R.styleable.SeekBarPreference_xmin, 0);
+        max = app.getInt(R.styleable.SeekBarPreference_xmax, 100);
         app.recycle();
     }
 
@@ -50,37 +51,37 @@ public class SeekBarPreference extends DialogPreference {
     protected void onSetInitialValue(boolean restore, Object defaultValue) {
         super.onSetInitialValue(restore, defaultValue);
 
-        mValue = (restore ? getPersistedInt(mValue) : ((defaultValue == null) ? mValue : (Integer)defaultValue));
+        progress = (restore ? getPersistedInt(progress) : ((defaultValue == null) ? progress : (Integer)defaultValue));
 
         if (!restore && shouldPersist()) {
-            persistInt(mValue);
+            persistInt(progress);
         }
 
-        setSummary(String.format(Locale.US, mSummary, String.valueOf(mValue), String.valueOf(mMax)));
+        setSummary(String.format(Locale.US, SUMMARY_FORMAT, String.valueOf(progress), String.valueOf(max)));
     }
 
     public void setMin(int min) {
-        mMin = min;
+        this.min = min;
     }
 
     public int getMin() {
-        return mMin;
+        return min;
     }
 
     public void setMax(int max) {
-        mMax = max;
+        this.max = max;
     }
 
     public int getMax() {
-        return mMax;
+        return max;
     }
 
     public void setProgress(int progress) {
-        mValue = progress;
+        this.progress = progress;
     }
 
     public int getProgress() {
-        return mValue;
+        return progress;
     }
 
     @Override
diff --git a/src/main/java/zame/game/libs/SeekBarPreferenceDialogFragmentCompat.java b/src/main/java/zame/game/core/preference/SeekBarPreferenceDialogFragmentCompat.java
similarity index 78%
rename from src/main/java/zame/game/libs/SeekBarPreferenceDialogFragmentCompat.java
rename to src/main/java/zame/game/core/preference/SeekBarPreferenceDialogFragmentCompat.java
index 5409a74..ac4865a 100644
--- a/src/main/java/zame/game/libs/SeekBarPreferenceDialogFragmentCompat.java
+++ b/src/main/java/zame/game/core/preference/SeekBarPreferenceDialogFragmentCompat.java
@@ -1,4 +1,4 @@
-package zame.game.libs;
+package zame.game.core.preference;
 
 import android.content.Context;
 import android.support.v7.preference.PreferenceDialogFragmentCompat;
@@ -43,9 +43,9 @@ public class SeekBarPreferenceDialogFragmentCompat extends PreferenceDialogFragm
                 new LinearLayout.LayoutParams(LinearLayout.LayoutParams.FILL_PARENT,
                         LinearLayout.LayoutParams.WRAP_CONTENT));
 
-        mSeekBar.setMax(pref.mMax - pref.mMin);
-        mSeekBar.setProgress(pref.mValue - pref.mMin);
-        mValueText.setText(String.valueOf(pref.mValue));
+        mSeekBar.setMax(pref.getMax() - pref.getMin());
+        mSeekBar.setProgress(pref.getProgress() - pref.getMin());
+        mValueText.setText(String.valueOf(pref.getProgress()));
 
         return layout;
     }
@@ -55,23 +55,23 @@ public class SeekBarPreferenceDialogFragmentCompat extends PreferenceDialogFragm
         super.onBindDialogView(v);
 
         SeekBarPreference pref = (SeekBarPreference)getPreference();
-        mSeekBar.setMax(pref.mMax - pref.mMin);
-        mSeekBar.setProgress(pref.mValue - pref.mMin);
+        mSeekBar.setMax(pref.getMax() - pref.getMin());
+        mSeekBar.setProgress(pref.getProgress() - pref.getMin());
     }
 
     @Override
     public void onDialogClosed(boolean positiveResult) {
         if (positiveResult && (mSeekBar != null)) {
             SeekBarPreference pref = (SeekBarPreference)getPreference();
-            pref.mValue = mSeekBar.getProgress() + pref.mMin;
+            pref.setProgress(mSeekBar.getProgress() + pref.getMin());
 
             getPreference().setSummary(String.format(Locale.US,
-                    pref.mSummary,
-                    String.valueOf(pref.mValue),
-                    String.valueOf(pref.mMax)));
+                    SeekBarPreference.SUMMARY_FORMAT,
+                    String.valueOf(pref.getProgress()),
+                    String.valueOf(pref.getMax())));
 
             if (pref.shouldPersist()) {
-                pref.persistInt(pref.mValue);
+                pref.persistInt(pref.getProgress());
             }
         }
     }
@@ -79,7 +79,7 @@ public class SeekBarPreferenceDialogFragmentCompat extends PreferenceDialogFragm
     @Override
     public void onProgressChanged(SeekBar seek, int value, boolean fromTouch) {
         SeekBarPreference pref = (SeekBarPreference)getPreference();
-        value += pref.mMin;
+        value += pref.getMin();
 
         mValueText.setText(String.valueOf(value));
         getPreference().callChangeListener(value);
diff --git a/src/main/java/zame/game/engine/data/DataItem.java b/src/main/java/zame/game/core/serializer/DataItem.java
similarity index 81%
rename from src/main/java/zame/game/engine/data/DataItem.java
rename to src/main/java/zame/game/core/serializer/DataItem.java
index 51193a7..d16ea49 100644
--- a/src/main/java/zame/game/engine/data/DataItem.java
+++ b/src/main/java/zame/game/core/serializer/DataItem.java
@@ -1,4 +1,4 @@
-package zame.game.engine.data;
+package zame.game.core.serializer;
 
 import java.io.IOException;
 
diff --git a/src/main/java/zame/game/engine/data/DataList.java b/src/main/java/zame/game/core/serializer/DataList.java
similarity index 75%
rename from src/main/java/zame/game/engine/data/DataList.java
rename to src/main/java/zame/game/core/serializer/DataList.java
index ca4caf7..a589c15 100644
--- a/src/main/java/zame/game/engine/data/DataList.java
+++ b/src/main/java/zame/game/core/serializer/DataList.java
@@ -1,20 +1,23 @@
-package zame.game.engine.data;
+package zame.game.core.serializer;
 
+import java.lang.reflect.Array;
+
+@SuppressWarnings({ "rawtypes", "unchecked" })
 public class DataList<T extends DataListItem> {
-    private DataListItem firstPtr;
-    private DataListItem lastPtr;
-    private DataListItem freePtr;
+    private T firstPtr;
+    private T lastPtr;
+    private T freePtr;
     private int itemsCount;
 
-    public DataListItem[] buffer;
+    public T[] buffer;
 
-    @SuppressWarnings({ "unchecked" })
+    @SuppressWarnings("unchecked")
     public DataList(Class<T> theClass, int capacity) {
-        buffer = new DataListItem[capacity];
+        buffer = (T[])Array.newInstance(theClass, capacity);
 
         for (int i = 0; i < capacity; i++) {
             try {
-                buffer[i] = theClass.newInstance();
+                buffer[i] = DataUtils.instantiate(theClass);
             } catch (Exception ex) {
                 throw new RuntimeException(ex);
             }
@@ -40,17 +43,15 @@ public class DataList<T extends DataListItem> {
         itemsCount = 0;
     }
 
-    @SuppressWarnings({ "unchecked" })
     public T first() {
-        return (T)firstPtr;
+        return firstPtr;
     }
 
-    @SuppressWarnings({ "unchecked", "unused" })
+    @SuppressWarnings({ "unused" })
     public T last() {
-        return (T)lastPtr;
+        return lastPtr;
     }
 
-    @SuppressWarnings("WeakerAccess")
     public int count() {
         return itemsCount;
     }
@@ -59,14 +60,14 @@ public class DataList<T extends DataListItem> {
         return (freePtr != null);
     }
 
-    @SuppressWarnings({ "unchecked" })
+    @SuppressWarnings("unchecked")
     public T take() {
         if (freePtr == null) {
             return null;
         }
 
-        DataListItem item = freePtr;
-        freePtr = freePtr.next;
+        T item = freePtr;
+        freePtr = (T)freePtr.next;
 
         if (freePtr != null) {
             freePtr.prev = null;
@@ -86,20 +87,21 @@ public class DataList<T extends DataListItem> {
         }
 
         itemsCount++;
-        return (T)item;
+        return item;
     }
 
+    @SuppressWarnings("unchecked")
     public void release(T item) {
         if (item.prev != null) {
             item.prev.next = item.next;
         } else {
-            firstPtr = item.next;
+            firstPtr = (T)item.next;
         }
 
         if (item.next != null) {
             item.next.prev = item.prev;
         } else {
-            lastPtr = item.prev;
+            lastPtr = (T)item.prev;
         }
 
         item.prev = null;
diff --git a/src/main/java/zame/game/core/serializer/DataListItem.java b/src/main/java/zame/game/core/serializer/DataListItem.java
new file mode 100644
index 0000000..067f61c
--- /dev/null
+++ b/src/main/java/zame/game/core/serializer/DataListItem.java
@@ -0,0 +1,6 @@
+package zame.game.core.serializer;
+
+public class DataListItem<T extends DataListItem<?>> {
+    public T prev;
+    public T next;
+}
diff --git a/src/main/java/zame/game/engine/data/DataReader.java b/src/main/java/zame/game/core/serializer/DataReader.java
similarity index 95%
rename from src/main/java/zame/game/engine/data/DataReader.java
rename to src/main/java/zame/game/core/serializer/DataReader.java
index 81d3cf7..503df86 100644
--- a/src/main/java/zame/game/engine/data/DataReader.java
+++ b/src/main/java/zame/game/core/serializer/DataReader.java
@@ -1,4 +1,4 @@
-package zame.game.engine.data;
+package zame.game.core.serializer;
 
 import android.util.SparseArray;
 import java.io.IOException;
@@ -14,7 +14,7 @@ public class DataReader {
 
         SignaturedObjectInputStream(ObjectInputStream is) {
             this.is = is;
-            crc32.update(Common.INITIAL_SIGNATURE_VALUE);
+            crc32.update(DataUtils.INITIAL_SIGNATURE_VALUE);
         }
 
         boolean readAndCheckSignature() {
@@ -120,11 +120,14 @@ public class DataReader {
         }
     }
 
-    public static int readFrom(ObjectInputStream ois, DataItem item) throws IOException, UnknownSignatureException {
-        return readFrom(ois, item, 1);
+    public static int readFrom(ObjectInputStream ois, DataItem item, String signature) throws
+            IOException,
+            UnknownSignatureException {
+
+        return readFrom(ois, item, signature, 1);
     }
 
-    public static int readFrom(ObjectInputStream ois, DataItem item, int maxSupportedVersion) throws
+    public static int readFrom(ObjectInputStream ois, DataItem item, String signature, int maxSupportedVersion) throws
             IOException,
             UnknownSignatureException {
 
@@ -137,12 +140,12 @@ public class DataReader {
             throw new UnknownSignatureException(UnknownSignatureException.INVALID_SIGNATURE);
         }
 
-        if (!signatureAndVersion.startsWith(Common.SIGNATURE + ".")) {
+        if (!signatureAndVersion.startsWith(signature + ".")) {
             throw new UnknownSignatureException(UnknownSignatureException.UNKNOWN_SIGNATURE);
         }
 
         try {
-            version = Integer.parseInt(signatureAndVersion.substring(Common.SIGNATURE.length() + 1));
+            version = Integer.parseInt(signatureAndVersion.substring(signature.length() + 1));
         } catch (NumberFormatException ex) {
             throw new UnknownSignatureException(UnknownSignatureException.INVALID_VERSION, ex);
         }
@@ -166,22 +169,21 @@ public class DataReader {
         return version;
     }
 
-    @SuppressWarnings({ "unchecked" })
     private static DataReader readInnerObject(SignaturedObjectInputStream is) throws IOException {
         DataReader reader = new DataReader();
 
         for (; ; ) {
             short id = is.readShort();
 
-            if (id == Common.MARKER_END) {
+            if (id == DataUtils.MARKER_END) {
                 break;
             }
 
-            int arrayType = ((int)id & Common.MASK_ARRAY) >> Common.SHIFT_ARRAY;
-            int dataType = ((int)id & Common.MASK_TYPE) >> Common.SHIFT_TYPE;
-            int fieldId = (int)id & Common.MASK_FIELD_ID;
+            int arrayType = ((int)id & DataUtils.MASK_ARRAY) >> DataUtils.SHIFT_ARRAY;
+            int dataType = ((int)id & DataUtils.MASK_TYPE) >> DataUtils.SHIFT_TYPE;
+            int fieldId = (int)id & DataUtils.MASK_FIELD_ID;
 
-            if (arrayType == Common.ARRAY_1D) {
+            if (arrayType == DataUtils.ARRAY_1D) {
                 int length = is.readInt();
                 ArrayList1d<Object> list = new ArrayList1d<>(length);
                 reader.values.put(fieldId, list);
@@ -189,7 +191,7 @@ public class DataReader {
                 for (int i = 0; i < length; i++) {
                     list.add(readInnerValue(dataType, is));
                 }
-            } else if (arrayType == Common.ARRAY_2D) {
+            } else if (arrayType == DataUtils.ARRAY_2D) {
                 int height = is.readInt();
                 int width = is.readInt();
                 ArrayList2d<Object> list = new ArrayList2d<>(height);
@@ -203,7 +205,7 @@ public class DataReader {
                         line.add(readInnerValue(dataType, is));
                     }
                 }
-            } else if (arrayType == Common.ARRAY_2DV) {
+            } else if (arrayType == DataUtils.ARRAY_2DV) {
                 int length = is.readInt();
                 ArrayList2dv<Object> list = new ArrayList2dv<>(length);
                 reader.values.put(fieldId, list);
@@ -227,37 +229,37 @@ public class DataReader {
 
     private static Object readInnerValue(int dataType, SignaturedObjectInputStream is) throws IOException {
         switch (dataType) {
-            case Common.TYPE_OBJECT:
+            case DataUtils.TYPE_OBJECT:
                 return readInnerObject(is);
 
-            case Common.TYPE_BYTE:
+            case DataUtils.TYPE_BYTE:
                 return is.readByte();
 
-            case Common.TYPE_SHORT:
+            case DataUtils.TYPE_SHORT:
                 return is.readShort();
 
-            case Common.TYPE_INT:
+            case DataUtils.TYPE_INT:
                 return is.readInt();
 
-            case Common.TYPE_LONG:
+            case DataUtils.TYPE_LONG:
                 return is.readLong();
 
-            case Common.TYPE_FLOAT:
+            case DataUtils.TYPE_FLOAT:
                 return is.readFloat();
 
-            case Common.TYPE_DOUBLE:
+            case DataUtils.TYPE_DOUBLE:
                 return is.readDouble();
 
-            case Common.TYPE_BOOLEAN:
+            case DataUtils.TYPE_BOOLEAN:
                 return is.readBoolean();
 
-            case Common.TYPE_CHAR:
+            case DataUtils.TYPE_CHAR:
                 return is.readChar();
 
-            case Common.TYPE_STRING:
+            case DataUtils.TYPE_STRING:
                 return is.readUTF();
 
-            case Common.TYPE_NULL:
+            case DataUtils.TYPE_NULL:
                 return null;
         }
 
@@ -299,7 +301,7 @@ public class DataReader {
         }
     }
 
-    public void readDataList(int fieldId, DataList<?> dataList) {
+    public <T extends DataListItem<?> & DataItem> void readDataList(int fieldId, DataList<T> dataList) {
         Object val = values.get(fieldId);
         dataList.clear();
 
@@ -308,7 +310,7 @@ public class DataReader {
             int length = list.size();
 
             for (int i = 0; i < length; i++) {
-                DataItem item = (DataItem)dataList.take();
+                DataItem item = dataList.take();
 
                 if (item == null) {
                     break;
@@ -320,8 +322,8 @@ public class DataReader {
         }
     }
 
-    @SuppressWarnings({ "unchecked", "unused" })
-    public void readList(int fieldId, List<DataItem> resultList, Class<?> theClass) {
+    @SuppressWarnings({ "unused" })
+    public <T extends DataItem> void readList(int fieldId, List<DataItem> resultList, Class<T> theClass) {
         Object val = values.get(fieldId);
         resultList.clear();
 
@@ -333,7 +335,7 @@ public class DataReader {
                 Object v = list.get(i);
 
                 try {
-                    DataItem inst = (DataItem)theClass.newInstance();
+                    DataItem inst = theClass.newInstance();
                     inst.readFrom(v instanceof DataReader ? (DataReader)v : emptyDataReader);
                     resultList.add(inst);
                 } catch (Exception ex) {
@@ -343,8 +345,7 @@ public class DataReader {
         }
     }
 
-    @SuppressWarnings({ "unchecked" })
-    public <T extends DataItem> void readList2d(int fieldId, List<ArrayList<T>> resultList, Class<?> theClass) {
+    public <T extends DataItem> void readList2d(int fieldId, List<List<T>> resultList, Class<T> theClass) {
         Object val = values.get(fieldId);
         resultList.clear();
 
@@ -355,6 +356,7 @@ public class DataReader {
             for (int i = 0; i < length; i++) {
                 ArrayList<?> line = (ArrayList<?>)list.get(i);
                 int lineLength = line.size();
+
                 ArrayList<T> resultLine = new ArrayList<>(lineLength);
                 resultList.add(resultLine);
 
@@ -362,9 +364,9 @@ public class DataReader {
                     Object v = line.get(j);
 
                     try {
-                        DataItem inst = (DataItem)theClass.newInstance();
+                        T inst = theClass.newInstance();
                         inst.readFrom(v instanceof DataReader ? (DataReader)v : emptyDataReader);
-                        resultLine.add((T)inst);
+                        resultLine.add(inst);
                     } catch (Exception ex) {
                         throw new RuntimeException(ex);
                     }
diff --git a/src/main/java/zame/game/core/serializer/DataUtils.java b/src/main/java/zame/game/core/serializer/DataUtils.java
new file mode 100644
index 0000000..a22635e
--- /dev/null
+++ b/src/main/java/zame/game/core/serializer/DataUtils.java
@@ -0,0 +1,64 @@
+package zame.game.core.serializer;
+
+final class DataUtils {
+    static final int INITIAL_SIGNATURE_VALUE = 594828924;
+    static final short MARKER_END = -1;
+    static final int MASK_ARRAY = 0xC000;
+    static final int SHIFT_ARRAY = 14;
+    static final int MASK_TYPE = 0x3C00;
+    static final int SHIFT_TYPE = 10;
+    static final int MASK_FIELD_ID = 0x03FF;
+    static final int ARRAY_1D = 1;
+    static final int ARRAY_2D = 2;
+    static final int ARRAY_2DV = 3;
+    static final int TYPE_OBJECT = 0;
+    static final int TYPE_BYTE = 1;
+    static final int TYPE_SHORT = 2;
+    static final int TYPE_INT = 3;
+    static final int TYPE_LONG = 4;
+    static final int TYPE_FLOAT = 5;
+    static final int TYPE_DOUBLE = 6;
+    static final int TYPE_BOOLEAN = 7;
+    static final int TYPE_CHAR = 8;
+    static final int TYPE_STRING = 9;
+    static final int TYPE_NULL = 10;
+
+    private DataUtils() {}
+
+    @SuppressWarnings("unchecked")
+    static <T> T instantiate(Class<T> theClass) throws IllegalAccessException, InstantiationException {
+        if (Byte.class.equals(theClass)) {
+            return (T)Byte.valueOf((byte)0);
+        }
+
+        if (Short.class.equals(theClass)) {
+            return (T)Short.valueOf((short)0);
+        }
+
+        if (Integer.class.equals(theClass)) {
+            return (T)Integer.valueOf(0);
+        }
+
+        if (Long.class.equals(theClass)) {
+            return (T)Long.valueOf(0L);
+        }
+
+        if (Float.class.equals(theClass)) {
+            return (T)Float.valueOf(0.0f);
+        }
+
+        if (Double.class.equals(theClass)) {
+            return (T)Double.valueOf(0.0);
+        }
+
+        if (Boolean.class.equals(theClass)) {
+            return (T)Boolean.valueOf(false);
+        }
+
+        if (Character.class.equals(theClass)) {
+            return (T)Character.valueOf(' ');
+        }
+
+        return theClass.newInstance();
+    }
+}
diff --git a/src/main/java/zame/game/engine/data/DataVector.java b/src/main/java/zame/game/core/serializer/DataVector.java
similarity index 76%
rename from src/main/java/zame/game/engine/data/DataVector.java
rename to src/main/java/zame/game/core/serializer/DataVector.java
index d0440dc..5d02b9c 100644
--- a/src/main/java/zame/game/engine/data/DataVector.java
+++ b/src/main/java/zame/game/core/serializer/DataVector.java
@@ -1,10 +1,10 @@
-package zame.game.engine.data;
+package zame.game.core.serializer;
 
 import java.lang.reflect.Array;
 
 public class DataVector<T> {
     public T[] data;
-    @SuppressWarnings("WeakerAccess") public int count;
+    public int count;
 
     @SuppressWarnings({ "unchecked" })
     public DataVector(Class<T> theClass, int capacity) {
@@ -13,7 +13,7 @@ public class DataVector<T> {
 
         for (int i = 0; i < capacity; i++) {
             try {
-                data[i] = theClass.newInstance();
+                data[i] = DataUtils.instantiate(theClass);
             } catch (Exception ex) {
                 throw new RuntimeException(ex);
             }
diff --git a/src/main/java/zame/game/engine/data/DataWriter.java b/src/main/java/zame/game/core/serializer/DataWriter.java
similarity index 67%
rename from src/main/java/zame/game/engine/data/DataWriter.java
rename to src/main/java/zame/game/core/serializer/DataWriter.java
index 2284c03..daa46d7 100644
--- a/src/main/java/zame/game/engine/data/DataWriter.java
+++ b/src/main/java/zame/game/core/serializer/DataWriter.java
@@ -1,4 +1,4 @@
-package zame.game.engine.data;
+package zame.game.core.serializer;
 
 import java.io.IOException;
 import java.io.ObjectOutputStream;
@@ -12,7 +12,7 @@ public class DataWriter {
 
         SignaturedObjectOutputStream(ObjectOutputStream os) {
             this.os = os;
-            crc32.update(Common.INITIAL_SIGNATURE_VALUE);
+            crc32.update(DataUtils.INITIAL_SIGNATURE_VALUE);
         }
 
         void writeSignature() throws IOException {
@@ -82,17 +82,19 @@ public class DataWriter {
 
     protected SignaturedObjectOutputStream os;
 
-    public static void writeTo(ObjectOutputStream oos, DataItem item) throws IOException {
-        writeTo(oos, item, 1);
+    public static void writeTo(ObjectOutputStream oos, DataItem item, String signature) throws IOException {
+        writeTo(oos, item, signature, 1);
     }
 
-    public static void writeTo(ObjectOutputStream oos, DataItem item, int version) throws IOException {
+    public static void writeTo(ObjectOutputStream oos, DataItem item, String signature, int version) throws
+            IOException {
+
         SignaturedObjectOutputStream os = new SignaturedObjectOutputStream(oos);
         DataWriter writer = new DataWriter(os);
 
-        os.writeUTF(Common.SIGNATURE + "." + String.valueOf(version));
+        os.writeUTF(signature + "." + String.valueOf(version));
         item.writeTo(writer);
-        os.writeShort(Common.MARKER_END);
+        os.writeShort(DataUtils.MARKER_END);
         os.writeSignature();
     }
 
@@ -102,64 +104,64 @@ public class DataWriter {
 
     public void write(int fieldId, DataItem value) throws IOException {
         //noinspection PointlessBitwiseExpression
-        os.writeShort((Common.TYPE_OBJECT << Common.SHIFT_TYPE) | fieldId);
+        os.writeShort((DataUtils.TYPE_OBJECT << DataUtils.SHIFT_TYPE) | fieldId);
 
         value.writeTo(this);
-        os.writeShort(Common.MARKER_END);
+        os.writeShort(DataUtils.MARKER_END);
     }
 
     public void write(int fieldId, byte value) throws IOException {
-        os.writeShort((Common.TYPE_BYTE << Common.SHIFT_TYPE) | fieldId);
+        os.writeShort((DataUtils.TYPE_BYTE << DataUtils.SHIFT_TYPE) | fieldId);
         os.writeByte(value);
     }
 
     public void write(int fieldId, short value) throws IOException {
-        os.writeShort((Common.TYPE_SHORT << Common.SHIFT_TYPE) | fieldId);
+        os.writeShort((DataUtils.TYPE_SHORT << DataUtils.SHIFT_TYPE) | fieldId);
         os.writeShort(value);
     }
 
     public void write(int fieldId, int value) throws IOException {
-        os.writeShort((Common.TYPE_INT << Common.SHIFT_TYPE) | fieldId);
+        os.writeShort((DataUtils.TYPE_INT << DataUtils.SHIFT_TYPE) | fieldId);
         os.writeInt(value);
     }
 
     public void write(int fieldId, long value) throws IOException {
-        os.writeShort((Common.TYPE_LONG << Common.SHIFT_TYPE) | fieldId);
+        os.writeShort((DataUtils.TYPE_LONG << DataUtils.SHIFT_TYPE) | fieldId);
         os.writeLong(value);
     }
 
     public void write(int fieldId, float value) throws IOException {
-        os.writeShort((Common.TYPE_FLOAT << Common.SHIFT_TYPE) | fieldId);
+        os.writeShort((DataUtils.TYPE_FLOAT << DataUtils.SHIFT_TYPE) | fieldId);
         os.writeFloat(value);
     }
 
     public void write(int fieldId, double value) throws IOException {
-        os.writeShort((Common.TYPE_DOUBLE << Common.SHIFT_TYPE) | fieldId);
+        os.writeShort((DataUtils.TYPE_DOUBLE << DataUtils.SHIFT_TYPE) | fieldId);
         os.writeDouble(value);
     }
 
     public void write(int fieldId, boolean value) throws IOException {
-        os.writeShort((Common.TYPE_BOOLEAN << Common.SHIFT_TYPE) | fieldId);
+        os.writeShort((DataUtils.TYPE_BOOLEAN << DataUtils.SHIFT_TYPE) | fieldId);
         os.writeBoolean(value);
     }
 
     public void write(int fieldId, char value) throws IOException {
-        os.writeShort((Common.TYPE_CHAR << Common.SHIFT_TYPE) | fieldId);
+        os.writeShort((DataUtils.TYPE_CHAR << DataUtils.SHIFT_TYPE) | fieldId);
         os.writeChar(value);
     }
 
     public void write(int fieldId, String value) throws IOException {
-        os.writeShort((Common.TYPE_STRING << Common.SHIFT_TYPE) | fieldId);
+        os.writeShort((DataUtils.TYPE_STRING << DataUtils.SHIFT_TYPE) | fieldId);
         os.writeUTF(value);
     }
 
     public void write(int fieldId, DataItem[] list) throws IOException {
         if (list == null) {
-            os.writeShort((Common.TYPE_NULL << Common.SHIFT_TYPE) | fieldId);
+            os.writeShort((DataUtils.TYPE_NULL << DataUtils.SHIFT_TYPE) | fieldId);
         } else {
             //noinspection PointlessBitwiseExpression
-            os.writeShort((Common.TYPE_OBJECT << Common.SHIFT_TYPE)
-                    | (Common.ARRAY_1D << Common.SHIFT_ARRAY)
+            os.writeShort((DataUtils.TYPE_OBJECT << DataUtils.SHIFT_TYPE)
+                    | (DataUtils.ARRAY_1D << DataUtils.SHIFT_ARRAY)
                     | fieldId);
 
             int length = list.length;
@@ -168,45 +170,45 @@ public class DataWriter {
             //noinspection ForLoopReplaceableByForEach
             for (int i = 0; i < length; i++) {
                 list[i].writeTo(this);
-                os.writeShort(Common.MARKER_END);
+                os.writeShort(DataUtils.MARKER_END);
             }
         }
     }
 
     public void write(int fieldId, DataVector<?> list) throws IOException {
         //noinspection PointlessBitwiseExpression
-        os.writeShort((Common.TYPE_OBJECT << Common.SHIFT_TYPE) | (Common.ARRAY_1D << Common.SHIFT_ARRAY) | fieldId);
+        os.writeShort((DataUtils.TYPE_OBJECT << DataUtils.SHIFT_TYPE) | (DataUtils.ARRAY_1D << DataUtils.SHIFT_ARRAY) | fieldId);
 
         int length = list.count;
         os.writeInt(length);
 
         for (int i = 0; i < length; i++) {
             ((DataItem)list.data[i]).writeTo(this);
-            os.writeShort(Common.MARKER_END);
+            os.writeShort(DataUtils.MARKER_END);
         }
     }
 
-    public void write(int fieldId, DataList<?> list) throws IOException {
+    public <T extends DataListItem<T> & DataItem> void write(int fieldId, DataList<T> list) throws IOException {
         //noinspection PointlessBitwiseExpression
-        os.writeShort((Common.TYPE_OBJECT << Common.SHIFT_TYPE) | (Common.ARRAY_1D << Common.SHIFT_ARRAY) | fieldId);
+        os.writeShort((DataUtils.TYPE_OBJECT << DataUtils.SHIFT_TYPE) | (DataUtils.ARRAY_1D << DataUtils.SHIFT_ARRAY) | fieldId);
 
         int length = list.count();
         os.writeInt(length);
 
-        for (DataListItem item = list.first(); item != null; item = item.next) {
-            ((DataItem)item).writeTo(this);
-            os.writeShort(Common.MARKER_END);
+        for (T item = list.first(); item != null; item = item.next) {
+            item.writeTo(this);
+            os.writeShort(DataUtils.MARKER_END);
         }
     }
 
     @SuppressWarnings("unused")
     public void writeList(int fieldId, List<?> list) throws IOException {
         if (list == null) {
-            os.writeShort((Common.TYPE_NULL << Common.SHIFT_TYPE) | fieldId);
+            os.writeShort((DataUtils.TYPE_NULL << DataUtils.SHIFT_TYPE) | fieldId);
         } else {
             //noinspection PointlessBitwiseExpression
-            os.writeShort((Common.TYPE_OBJECT << Common.SHIFT_TYPE)
-                    | (Common.ARRAY_1D << Common.SHIFT_ARRAY)
+            os.writeShort((DataUtils.TYPE_OBJECT << DataUtils.SHIFT_TYPE)
+                    | (DataUtils.ARRAY_1D << DataUtils.SHIFT_ARRAY)
                     | fieldId);
 
             int length = list.size();
@@ -214,18 +216,18 @@ public class DataWriter {
 
             for (int i = 0; i < length; i++) {
                 ((DataItem)list.get(i)).writeTo(this);
-                os.writeShort(Common.MARKER_END);
+                os.writeShort(DataUtils.MARKER_END);
             }
         }
     }
 
     public void writeList2d(int fieldId, List<?> list) throws IOException {
         if (list == null) {
-            os.writeShort((Common.TYPE_NULL << Common.SHIFT_TYPE) | fieldId);
+            os.writeShort((DataUtils.TYPE_NULL << DataUtils.SHIFT_TYPE) | fieldId);
         } else {
             //noinspection PointlessBitwiseExpression
-            os.writeShort((Common.TYPE_OBJECT << Common.SHIFT_TYPE)
-                    | (Common.ARRAY_2DV << Common.SHIFT_ARRAY)
+            os.writeShort((DataUtils.TYPE_OBJECT << DataUtils.SHIFT_TYPE)
+                    | (DataUtils.ARRAY_2DV << DataUtils.SHIFT_ARRAY)
                     | fieldId);
 
             int length = list.size();
@@ -238,7 +240,7 @@ public class DataWriter {
 
                 for (int j = 0; j < lineLength; j++) {
                     ((DataItem)line.get(j)).writeTo(this);
-                    os.writeShort(Common.MARKER_END);
+                    os.writeShort(DataUtils.MARKER_END);
                 }
             }
         }
@@ -246,9 +248,9 @@ public class DataWriter {
 
     public void write(int fieldId, byte[] list) throws IOException {
         if (list == null) {
-            os.writeShort((Common.TYPE_NULL << Common.SHIFT_TYPE) | fieldId);
+            os.writeShort((DataUtils.TYPE_NULL << DataUtils.SHIFT_TYPE) | fieldId);
         } else {
-            os.writeShort((Common.TYPE_BYTE << Common.SHIFT_TYPE) | (Common.ARRAY_1D << Common.SHIFT_ARRAY) | fieldId);
+            os.writeShort((DataUtils.TYPE_BYTE << DataUtils.SHIFT_TYPE) | (DataUtils.ARRAY_1D << DataUtils.SHIFT_ARRAY) | fieldId);
             int length = list.length;
             os.writeInt(length);
 
@@ -261,9 +263,9 @@ public class DataWriter {
 
     public void write(int fieldId, short[] list) throws IOException {
         if (list == null) {
-            os.writeShort((Common.TYPE_NULL << Common.SHIFT_TYPE) | fieldId);
+            os.writeShort((DataUtils.TYPE_NULL << DataUtils.SHIFT_TYPE) | fieldId);
         } else {
-            os.writeShort((Common.TYPE_SHORT << Common.SHIFT_TYPE) | (Common.ARRAY_1D << Common.SHIFT_ARRAY) | fieldId);
+            os.writeShort((DataUtils.TYPE_SHORT << DataUtils.SHIFT_TYPE) | (DataUtils.ARRAY_1D << DataUtils.SHIFT_ARRAY) | fieldId);
             int length = list.length;
             os.writeInt(length);
 
@@ -276,9 +278,9 @@ public class DataWriter {
 
     public void write(int fieldId, int[] list) throws IOException {
         if (list == null) {
-            os.writeShort((Common.TYPE_NULL << Common.SHIFT_TYPE) | fieldId);
+            os.writeShort((DataUtils.TYPE_NULL << DataUtils.SHIFT_TYPE) | fieldId);
         } else {
-            os.writeShort((Common.TYPE_INT << Common.SHIFT_TYPE) | (Common.ARRAY_1D << Common.SHIFT_ARRAY) | fieldId);
+            os.writeShort((DataUtils.TYPE_INT << DataUtils.SHIFT_TYPE) | (DataUtils.ARRAY_1D << DataUtils.SHIFT_ARRAY) | fieldId);
             int length = list.length;
             os.writeInt(length);
 
@@ -291,9 +293,9 @@ public class DataWriter {
 
     public void write(int fieldId, long[] list) throws IOException {
         if (list == null) {
-            os.writeShort((Common.TYPE_NULL << Common.SHIFT_TYPE) | fieldId);
+            os.writeShort((DataUtils.TYPE_NULL << DataUtils.SHIFT_TYPE) | fieldId);
         } else {
-            os.writeShort((Common.TYPE_LONG << Common.SHIFT_TYPE) | (Common.ARRAY_1D << Common.SHIFT_ARRAY) | fieldId);
+            os.writeShort((DataUtils.TYPE_LONG << DataUtils.SHIFT_TYPE) | (DataUtils.ARRAY_1D << DataUtils.SHIFT_ARRAY) | fieldId);
             int length = list.length;
             os.writeInt(length);
 
@@ -306,9 +308,9 @@ public class DataWriter {
 
     public void write(int fieldId, float[] list) throws IOException {
         if (list == null) {
-            os.writeShort((Common.TYPE_NULL << Common.SHIFT_TYPE) | fieldId);
+            os.writeShort((DataUtils.TYPE_NULL << DataUtils.SHIFT_TYPE) | fieldId);
         } else {
-            os.writeShort((Common.TYPE_FLOAT << Common.SHIFT_TYPE) | (Common.ARRAY_1D << Common.SHIFT_ARRAY) | fieldId);
+            os.writeShort((DataUtils.TYPE_FLOAT << DataUtils.SHIFT_TYPE) | (DataUtils.ARRAY_1D << DataUtils.SHIFT_ARRAY) | fieldId);
             int length = list.length;
             os.writeInt(length);
 
@@ -321,10 +323,10 @@ public class DataWriter {
 
     public void write(int fieldId, double[] list) throws IOException {
         if (list == null) {
-            os.writeShort((Common.TYPE_NULL << Common.SHIFT_TYPE) | fieldId);
+            os.writeShort((DataUtils.TYPE_NULL << DataUtils.SHIFT_TYPE) | fieldId);
         } else {
-            os.writeShort((Common.TYPE_DOUBLE << Common.SHIFT_TYPE)
-                    | (Common.ARRAY_1D << Common.SHIFT_ARRAY)
+            os.writeShort((DataUtils.TYPE_DOUBLE << DataUtils.SHIFT_TYPE)
+                    | (DataUtils.ARRAY_1D << DataUtils.SHIFT_ARRAY)
                     | fieldId);
 
             int length = list.length;
@@ -339,10 +341,10 @@ public class DataWriter {
 
     public void write(int fieldId, boolean[] list) throws IOException {
         if (list == null) {
-            os.writeShort((Common.TYPE_NULL << Common.SHIFT_TYPE) | fieldId);
+            os.writeShort((DataUtils.TYPE_NULL << DataUtils.SHIFT_TYPE) | fieldId);
         } else {
-            os.writeShort((Common.TYPE_BOOLEAN << Common.SHIFT_TYPE)
-                    | (Common.ARRAY_1D << Common.SHIFT_ARRAY)
+            os.writeShort((DataUtils.TYPE_BOOLEAN << DataUtils.SHIFT_TYPE)
+                    | (DataUtils.ARRAY_1D << DataUtils.SHIFT_ARRAY)
                     | fieldId);
 
             int length = list.length;
@@ -357,9 +359,9 @@ public class DataWriter {
 
     public void write(int fieldId, char[] list) throws IOException {
         if (list == null) {
-            os.writeShort((Common.TYPE_NULL << Common.SHIFT_TYPE) | fieldId);
+            os.writeShort((DataUtils.TYPE_NULL << DataUtils.SHIFT_TYPE) | fieldId);
         } else {
-            os.writeShort((Common.TYPE_CHAR << Common.SHIFT_TYPE) | (Common.ARRAY_1D << Common.SHIFT_ARRAY) | fieldId);
+            os.writeShort((DataUtils.TYPE_CHAR << DataUtils.SHIFT_TYPE) | (DataUtils.ARRAY_1D << DataUtils.SHIFT_ARRAY) | fieldId);
             int length = list.length;
             os.writeInt(length);
 
@@ -372,10 +374,10 @@ public class DataWriter {
 
     public void write(int fieldId, String[] list) throws IOException {
         if (list == null) {
-            os.writeShort((Common.TYPE_NULL << Common.SHIFT_TYPE) | fieldId);
+            os.writeShort((DataUtils.TYPE_NULL << DataUtils.SHIFT_TYPE) | fieldId);
         } else {
-            os.writeShort((Common.TYPE_STRING << Common.SHIFT_TYPE)
-                    | (Common.ARRAY_1D << Common.SHIFT_ARRAY)
+            os.writeShort((DataUtils.TYPE_STRING << DataUtils.SHIFT_TYPE)
+                    | (DataUtils.ARRAY_1D << DataUtils.SHIFT_ARRAY)
                     | fieldId);
 
             int length = list.length;
@@ -390,9 +392,9 @@ public class DataWriter {
 
     public void write(int fieldId, byte[][] list) throws IOException {
         if (list == null) {
-            os.writeShort((Common.TYPE_NULL << Common.SHIFT_TYPE) | fieldId);
+            os.writeShort((DataUtils.TYPE_NULL << DataUtils.SHIFT_TYPE) | fieldId);
         } else {
-            os.writeShort((Common.TYPE_BYTE << Common.SHIFT_TYPE) | (Common.ARRAY_2D << Common.SHIFT_ARRAY) | fieldId);
+            os.writeShort((DataUtils.TYPE_BYTE << DataUtils.SHIFT_TYPE) | (DataUtils.ARRAY_2D << DataUtils.SHIFT_ARRAY) | fieldId);
             int height = list.length;
             int width = list[0].length;
             os.writeInt(height);
@@ -409,9 +411,9 @@ public class DataWriter {
 
     public void write(int fieldId, short[][] list) throws IOException {
         if (list == null) {
-            os.writeShort((Common.TYPE_NULL << Common.SHIFT_TYPE) | fieldId);
+            os.writeShort((DataUtils.TYPE_NULL << DataUtils.SHIFT_TYPE) | fieldId);
         } else {
-            os.writeShort((Common.TYPE_SHORT << Common.SHIFT_TYPE) | (Common.ARRAY_2D << Common.SHIFT_ARRAY) | fieldId);
+            os.writeShort((DataUtils.TYPE_SHORT << DataUtils.SHIFT_TYPE) | (DataUtils.ARRAY_2D << DataUtils.SHIFT_ARRAY) | fieldId);
             int height = list.length;
             int width = list[0].length;
             os.writeInt(height);
@@ -428,9 +430,9 @@ public class DataWriter {
 
     public void write(int fieldId, int[][] list) throws IOException {
         if (list == null) {
-            os.writeShort((Common.TYPE_NULL << Common.SHIFT_TYPE) | fieldId);
+            os.writeShort((DataUtils.TYPE_NULL << DataUtils.SHIFT_TYPE) | fieldId);
         } else {
-            os.writeShort((Common.TYPE_INT << Common.SHIFT_TYPE) | (Common.ARRAY_2D << Common.SHIFT_ARRAY) | fieldId);
+            os.writeShort((DataUtils.TYPE_INT << DataUtils.SHIFT_TYPE) | (DataUtils.ARRAY_2D << DataUtils.SHIFT_ARRAY) | fieldId);
             int height = list.length;
             int width = list[0].length;
             os.writeInt(height);
@@ -447,9 +449,9 @@ public class DataWriter {
 
     public void write(int fieldId, long[][] list) throws IOException {
         if (list == null) {
-            os.writeShort((Common.TYPE_NULL << Common.SHIFT_TYPE) | fieldId);
+            os.writeShort((DataUtils.TYPE_NULL << DataUtils.SHIFT_TYPE) | fieldId);
         } else {
-            os.writeShort((Common.TYPE_LONG << Common.SHIFT_TYPE) | (Common.ARRAY_2D << Common.SHIFT_ARRAY) | fieldId);
+            os.writeShort((DataUtils.TYPE_LONG << DataUtils.SHIFT_TYPE) | (DataUtils.ARRAY_2D << DataUtils.SHIFT_ARRAY) | fieldId);
             int height = list.length;
             int width = list[0].length;
             os.writeInt(height);
@@ -466,9 +468,9 @@ public class DataWriter {
 
     public void write(int fieldId, float[][] list) throws IOException {
         if (list == null) {
-            os.writeShort((Common.TYPE_NULL << Common.SHIFT_TYPE) | fieldId);
+            os.writeShort((DataUtils.TYPE_NULL << DataUtils.SHIFT_TYPE) | fieldId);
         } else {
-            os.writeShort((Common.TYPE_FLOAT << Common.SHIFT_TYPE) | (Common.ARRAY_2D << Common.SHIFT_ARRAY) | fieldId);
+            os.writeShort((DataUtils.TYPE_FLOAT << DataUtils.SHIFT_TYPE) | (DataUtils.ARRAY_2D << DataUtils.SHIFT_ARRAY) | fieldId);
             int height = list.length;
             int width = list[0].length;
             os.writeInt(height);
@@ -485,10 +487,10 @@ public class DataWriter {
 
     public void write(int fieldId, double[][] list) throws IOException {
         if (list == null) {
-            os.writeShort((Common.TYPE_NULL << Common.SHIFT_TYPE) | fieldId);
+            os.writeShort((DataUtils.TYPE_NULL << DataUtils.SHIFT_TYPE) | fieldId);
         } else {
-            os.writeShort((Common.TYPE_DOUBLE << Common.SHIFT_TYPE)
-                    | (Common.ARRAY_2D << Common.SHIFT_ARRAY)
+            os.writeShort((DataUtils.TYPE_DOUBLE << DataUtils.SHIFT_TYPE)
+                    | (DataUtils.ARRAY_2D << DataUtils.SHIFT_ARRAY)
                     | fieldId);
 
             int height = list.length;
@@ -507,10 +509,10 @@ public class DataWriter {
 
     public void write(int fieldId, boolean[][] list) throws IOException {
         if (list == null) {
-            os.writeShort((Common.TYPE_NULL << Common.SHIFT_TYPE) | fieldId);
+            os.writeShort((DataUtils.TYPE_NULL << DataUtils.SHIFT_TYPE) | fieldId);
         } else {
-            os.writeShort((Common.TYPE_BOOLEAN << Common.SHIFT_TYPE)
-                    | (Common.ARRAY_2D << Common.SHIFT_ARRAY)
+            os.writeShort((DataUtils.TYPE_BOOLEAN << DataUtils.SHIFT_TYPE)
+                    | (DataUtils.ARRAY_2D << DataUtils.SHIFT_ARRAY)
                     | fieldId);
 
             int height = list.length;
@@ -529,9 +531,9 @@ public class DataWriter {
 
     public void write(int fieldId, char[][] list) throws IOException {
         if (list == null) {
-            os.writeShort((Common.TYPE_NULL << Common.SHIFT_TYPE) | fieldId);
+            os.writeShort((DataUtils.TYPE_NULL << DataUtils.SHIFT_TYPE) | fieldId);
         } else {
-            os.writeShort((Common.TYPE_CHAR << Common.SHIFT_TYPE) | (Common.ARRAY_2D << Common.SHIFT_ARRAY) | fieldId);
+            os.writeShort((DataUtils.TYPE_CHAR << DataUtils.SHIFT_TYPE) | (DataUtils.ARRAY_2D << DataUtils.SHIFT_ARRAY) | fieldId);
             int height = list.length;
             int width = list[0].length;
             os.writeInt(height);
@@ -548,10 +550,10 @@ public class DataWriter {
 
     public void write(int fieldId, String[][] list) throws IOException {
         if (list == null) {
-            os.writeShort((Common.TYPE_NULL << Common.SHIFT_TYPE) | fieldId);
+            os.writeShort((DataUtils.TYPE_NULL << DataUtils.SHIFT_TYPE) | fieldId);
         } else {
-            os.writeShort((Common.TYPE_STRING << Common.SHIFT_TYPE)
-                    | (Common.ARRAY_2D << Common.SHIFT_ARRAY)
+            os.writeShort((DataUtils.TYPE_STRING << DataUtils.SHIFT_TYPE)
+                    | (DataUtils.ARRAY_2D << DataUtils.SHIFT_ARRAY)
                     | fieldId);
 
             int height = list.length;
diff --git a/src/main/java/zame/game/core/serializer/UnknownSignatureException.java b/src/main/java/zame/game/core/serializer/UnknownSignatureException.java
new file mode 100644
index 0000000..c902f02
--- /dev/null
+++ b/src/main/java/zame/game/core/serializer/UnknownSignatureException.java
@@ -0,0 +1,20 @@
+package zame.game.core.serializer;
+
+@SuppressWarnings("WeakerAccess")
+public class UnknownSignatureException extends Exception {
+    private static final long serialVersionUID = 0L;
+
+    static final String INVALID_SIGNATURE = "Invalid signature";
+    static final String UNKNOWN_SIGNATURE = "Unknown signature";
+    static final String INVALID_VERSION = "Invalid version";
+    static final String UNSUPPORTED_VERSION = "Unsupported version";
+    static final String INVALID_CHECKSUM = "Invalid checksum";
+
+    UnknownSignatureException(String detailMessage) {
+        super(detailMessage);
+    }
+
+    UnknownSignatureException(String detailMessage, Throwable throwable) {
+        super(detailMessage, throwable);
+    }
+}
diff --git a/src/main/java/zame/game/Common.java b/src/main/java/zame/game/core/util/Common.java
similarity index 88%
rename from src/main/java/zame/game/Common.java
rename to src/main/java/zame/game/core/util/Common.java
index 9124ef2..2d2a82b 100644
--- a/src/main/java/zame/game/Common.java
+++ b/src/main/java/zame/game/core/util/Common.java
@@ -1,10 +1,9 @@
-package zame.game;
+package zame.game.core.util;
 
 import android.content.Context;
 import android.content.Intent;
 import android.content.pm.PackageManager;
 import android.content.pm.ResolveInfo;
-import android.content.res.AssetManager;
 import android.graphics.Bitmap;
 import android.graphics.Typeface;
 import android.net.Uri;
@@ -18,16 +17,13 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.net.URLEncoder;
 import java.util.List;
-import java.util.Locale;
+import zame.game.App;
+import zame.game.R;
+import zame.game.flavour.config.AppConfig;
 
 // http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/2.3_r1/android/os/FileUtils.java#FileUtils
 
 public final class Common {
-    private static final String TAG = "FSR";
-
-    public static final String WEB_LINK = "https://eightsines.com/fire-strike/index.php?utm_medium=referral&utm_source=ingame&utm_campaign=ingame&hl=";
-    public static final String HELP_LINK = "https://eightsines.com/fire-strike/index.php?action=help&utm_medium=referral&utm_source=ingame&utm_campaign=ingame&hl=";
-
     private Common() {}
 
     public static int dpToPx(Context context, int dp) {
@@ -36,9 +32,13 @@ public final class Common {
                 context.getResources().getDisplayMetrics());
     }
 
+    /*
     public static String getLocalizedAssetPath(AssetManager assetManager,
             @SuppressWarnings("SameParameterValue") String pathTemplate) {
-        String path = String.format(Locale.US, pathTemplate, "-" + Locale.getDefault().getLanguage().toLowerCase());
+
+        String path = String.format(Locale.US,
+                pathTemplate,
+                "-" + Locale.getDefault().getLanguage().toLowerCase(Locale.US));
 
         try {
             InputStream is = assetManager.open(path);
@@ -49,6 +49,7 @@ public final class Common {
 
         return "file:///android_asset/" + path;
     }
+    */
 
     @SuppressWarnings("UnusedReturnValue")
     public static boolean openBrowser(Context context, String uri) {
@@ -82,6 +83,19 @@ public final class Common {
         return false;
     }
 
+    public static void openViewIntent(Context context, String uriString) {
+        Uri uri;
+
+        try {
+            uri = Uri.parse(uriString);
+        } catch (Exception ex) {
+            Common.log(ex);
+            return;
+        }
+
+        openExternalIntent(context, new Intent(Intent.ACTION_VIEW, uri));
+    }
+
     public static void openExternalIntent(Context context, Intent intent) {
         openExternalIntent(context, intent, true);
     }
@@ -97,7 +111,7 @@ public final class Common {
                 log(ex);
             }
 
-            showToast("Could not start external intent.");
+            showToast("Could not startBatch external intent.");
         }
 
     }
@@ -125,15 +139,15 @@ public final class Common {
     }
 
     public static void log(String message) {
-        Log.e(TAG, message);
+        Log.e(AppConfig.TAG, message);
     }
 
     public static void log(Throwable tr) {
-        Log.e(TAG, "Exception: " + tr, tr);
+        Log.e(AppConfig.TAG, "Exception: " + tr, tr);
     }
 
     public static void log(String message, Throwable tr) {
-        Log.e(TAG, message, tr);
+        Log.e(AppConfig.TAG, message, tr);
     }
 
     public static boolean canUseKey(int keyCode) {
@@ -173,12 +187,9 @@ public final class Common {
             if (mins < 10) {
                 sb.append("0");
             }
-
-            sb.append(mins);
-        } else {
-            sb.append(mins);
         }
 
+        sb.append(mins);
         sb.append(":");
 
         if (secs < 10) {
@@ -203,10 +214,10 @@ public final class Common {
         return (obj == null ? def : obj);
     }
 
-    public static Typeface loadIngameTypeface() {
+    public static Typeface loadIngameTypeface(Context context) {
         if (App.self.cachedTypeface == null) {
             try {
-                App.self.cachedTypeface = ResourcesCompat.getFont(App.self, R.font.ingame);
+                App.self.cachedTypeface = ResourcesCompat.getFont(context, R.font.ingame);
             } catch (Exception ex) {
                 log(ex);
                 App.self.cachedTypeface = Typeface.DEFAULT;
@@ -233,13 +244,13 @@ public final class Common {
         }
     }
 
-    public static void showToast(final int resourceId) {
+    public static void showToast(final Context context, final int resourceId) {
         try {
             App.self.handler.post(new Runnable() {
                 @Override
                 public void run() {
                     try {
-                        Toast.makeText(App.self, resourceId, Toast.LENGTH_LONG).show();
+                        Toast.makeText(App.self, context.getResources().getText(resourceId), Toast.LENGTH_LONG).show();
                     } catch (Throwable innerFatality) {
                         // ignored
                     }
diff --git a/src/main/java/zame/game/misc/IntentProvider.java b/src/main/java/zame/game/core/util/IntentProvider.java
similarity index 63%
rename from src/main/java/zame/game/misc/IntentProvider.java
rename to src/main/java/zame/game/core/util/IntentProvider.java
index 8e652d7..a4cfdb9 100644
--- a/src/main/java/zame/game/misc/IntentProvider.java
+++ b/src/main/java/zame/game/core/util/IntentProvider.java
@@ -1,29 +1,27 @@
-package zame.game.misc;
+package zame.game.core.util;
 
 import android.content.Context;
 import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.content.pm.ResolveInfo;
 import android.net.Uri;
-import java.util.List;
-import zame.game.Common;
 import zame.game.R;
 
 public final class IntentProvider {
     private IntentProvider() {
     }
 
-    public static Intent getTwitterIntent(Context context, String title, String url) {
+    /*
+    public static Intent getTwitterShareIntent(Context context, String title, String url) {
         Intent intent = null;
         String text = url + " - " + title;
 
         final String[] twitterApps = { "com.twitter.android",
                 "com.twidroid",
                 "com.handmark.tweetcaster",
-                "com.thedeck.android", };
+                "com.thedeck.android" };
 
         Intent checkIntent = new Intent();
         checkIntent.setType("text/plain");
+
         final List<ResolveInfo> list = context.getPackageManager()
                 .queryIntentActivities(checkIntent, PackageManager.MATCH_DEFAULT_ONLY);
 
@@ -49,13 +47,14 @@ public final class IntentProvider {
         return intent;
     }
 
-    public static Intent getFacebookIntent(Context context, String title, String url) {
+    public static Intent getFacebookShareIntent(Context context, String title, String url) {
         Intent intent = null;
 
-        final String[] facebookApps = { "com.facebook.katana", };
+        final String[] facebookApps = { "com.facebook.katana" };
 
         Intent checkIntent = new Intent();
         checkIntent.setType("text/plain");
+
         final List<ResolveInfo> list = context.getPackageManager()
                 .queryIntentActivities(checkIntent, PackageManager.MATCH_DEFAULT_ONLY);
 
@@ -82,58 +81,24 @@ public final class IntentProvider {
         return intent;
     }
 
-    public static Intent getGooglePlusIntent(Context context, String title, String url) {
-        Intent intent = null;
-
-        final String[] plusApps = { "com.google.android.apps.plus", };
-
-        Intent checkIntent = new Intent(Intent.ACTION_SEND);
-        checkIntent.setType("text/plain");
-        final List<ResolveInfo> list = context.getPackageManager()
-                .queryIntentActivities(checkIntent, PackageManager.MATCH_DEFAULT_ONLY);
-
-        outer:
-        for (String appPackage : plusApps) {
-            for (ResolveInfo resolveInfo : list) {
-                String packageName = resolveInfo.activityInfo.packageName;
-
-                if (packageName != null && packageName.startsWith(appPackage)) {
-                    checkIntent.setPackage(packageName);
-                    checkIntent.putExtra(Intent.EXTRA_TEXT, title + "\n\n" + url);
-                    intent = checkIntent;
-                    break outer;
-                }
-            }
-        }
-
-        if (intent == null) {
-            intent = new Intent(Intent.ACTION_VIEW,
-                    Uri.parse("https://plus.google.com/share?url=" + Common.urlEncode(url)));
-        }
-
-        return intent;
-    }
-
-    @SuppressWarnings("unused")
-    public static Intent getVkIntent(Context context, String title, String url) {
+    public static Intent getVkShareIntent(Context context, String title, String url) {
         return new Intent(Intent.ACTION_VIEW, Uri.parse("http://vk.com/share.php?url=" + Common.urlEncode(url)));
     }
 
-    @SuppressWarnings("WeakerAccess")
-    public static Intent getEmailIntent(Context context, String email) {
+    public static Intent getEmailIntent(Context context, String email, String subject, String body) {
         Intent intent = new Intent(Intent.ACTION_SENDTO,
-                Uri.fromParts("mailto", email, null)).putExtra(Intent.EXTRA_SUBJECT,
-                context.getString(R.string.app_name));
+                Uri.fromParts("mailto", email, null)).putExtra(Intent.EXTRA_SUBJECT, subject)
+                .putExtra(Intent.EXTRA_TEXT, body);
 
-        return Intent.createChooser(intent, context.getString(R.string.send_email_using));
+        return Intent.createChooser(intent, context.getString(R.string.core_send_email_using));
     }
+    */
 
-    @SuppressWarnings("unused")
-    public static Intent getEmailIntent(Context context, String email, String subject, String body) {
+    public static Intent getEmailIntent(Context context, String email) {
         Intent intent = new Intent(Intent.ACTION_SENDTO,
-                Uri.fromParts("mailto", email, null)).putExtra(Intent.EXTRA_SUBJECT, subject)
-                .putExtra(Intent.EXTRA_TEXT, body);
+                Uri.fromParts("mailto", email, null)).putExtra(Intent.EXTRA_SUBJECT,
+                context.getString(R.string.core_app_name));
 
-        return Intent.createChooser(intent, context.getString(R.string.send_email_using));
+        return Intent.createChooser(intent, context.getString(R.string.core_send_email_using));
     }
 }
diff --git a/src/main/java/zame/game/libs/AbsoluteLayout.java b/src/main/java/zame/game/core/widget/AbsoluteLayout.java
similarity index 99%
rename from src/main/java/zame/game/libs/AbsoluteLayout.java
rename to src/main/java/zame/game/core/widget/AbsoluteLayout.java
index 13b94a3..c4ab098 100644
--- a/src/main/java/zame/game/libs/AbsoluteLayout.java
+++ b/src/main/java/zame/game/core/widget/AbsoluteLayout.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package zame.game.libs;
+package zame.game.core.widget;
 
 import android.content.Context;
 import android.content.res.TypedArray;
diff --git a/src/main/java/zame/game/libs/FrameLayout.java b/src/main/java/zame/game/core/widget/FrameLayout.java
similarity index 93%
rename from src/main/java/zame/game/libs/FrameLayout.java
rename to src/main/java/zame/game/core/widget/FrameLayout.java
index a03fbf0..ba66110 100644
--- a/src/main/java/zame/game/libs/FrameLayout.java
+++ b/src/main/java/zame/game/core/widget/FrameLayout.java
@@ -1,4 +1,4 @@
-package zame.game.libs;
+package zame.game.core.widget;
 
 import android.content.Context;
 import android.util.AttributeSet;
@@ -27,7 +27,7 @@ public class FrameLayout extends android.widget.FrameLayout {
     }
 
     protected boolean getRotateSetting() {
-        return App.self.getSharedPreferences().getBoolean("RotateScreen", false);
+        return App.self.preferences.getBoolean(R.string.key_rotate_screen);
     }
 
     @Override
diff --git a/src/main/java/zame/game/libs/GLSurfaceView21.java b/src/main/java/zame/game/core/widget/GLSurfaceView21.java
similarity index 99%
rename from src/main/java/zame/game/libs/GLSurfaceView21.java
rename to src/main/java/zame/game/core/widget/GLSurfaceView21.java
index 772e198..247f041 100644
--- a/src/main/java/zame/game/libs/GLSurfaceView21.java
+++ b/src/main/java/zame/game/core/widget/GLSurfaceView21.java
@@ -19,7 +19,7 @@
 // but today I found http://groups.google.com/group/android-developers/browse_thread/thread/fc5482b800bc925d
 // so I decide make an easy fix and just use GLSurfaceView from android 2.1
 
-package zame.game.libs;
+package zame.game.core.widget;
 
 import android.content.Context;
 import android.opengl.GLDebugHelper;
@@ -126,7 +126,7 @@ import javax.microedition.khronos.opengles.GL;
  *
  *     private MyRenderer mMyRenderer;
  *
- *     public void start() {
+ *     public void startBatch() {
  *         mMyRenderer = ...;
  *         setRenderer(mMyRenderer);
  *     }
@@ -254,7 +254,7 @@ public class GLSurfaceView21 extends SurfaceView implements SurfaceHolder.Callba
 
     /**
      * Set the renderer associated with this view. Also starts the thread that
-     * will call the renderer, which in turn causes the rendering to start.
+     * will call the renderer, which in turn causes the rendering to startBatch.
      * <p>This method should be called once and only once in the life-cycle of
      * a GLSurfaceView.
      * <p>The following GLSurfaceView methods can only be called <em>before</em>
@@ -553,7 +553,7 @@ public class GLSurfaceView21 extends SurfaceView implements SurfaceHolder.Callba
          * be lost when the Android device awakes after going to sleep.
          * <p>
          * Since this method is called at the beginning of rendering, as well as
-         * every time the EGL context is lost, this method is a convenient place to put
+         * every time the EGL context is lost, this method is a convenient place to set
          * code to create resources that need to be created when the rendering
          * starts, and that need to be recreated when the EGL context is lost.
          * Textures are an example of a resource that you might want to create
@@ -597,7 +597,7 @@ public class GLSurfaceView21 extends SurfaceView implements SurfaceHolder.Callba
         void onSurfaceChanged(GL10 gl, int width, int height);
 
         /**
-         * Called to draw the current frame.
+         * Called to batch the current frame.
          * <p>
          * This method is responsible for drawing the current frame.
          * <p>
@@ -1067,7 +1067,7 @@ public class GLSurfaceView21 extends SurfaceView implements SurfaceHolder.Callba
                                 sGLThreadManager.notifyAll();
                             }
 
-                            // Ready to draw?
+                            // Ready to batch?
                             if ((!mPaused) && mHasSurface
                                 && (mWidth > 0) && (mHeight > 0)
                                 && (mRequestRender || (mRenderMode == RENDERMODE_CONTINUOUSLY))) {
@@ -1089,7 +1089,7 @@ public class GLSurfaceView21 extends SurfaceView implements SurfaceHolder.Callba
                                         wantRenderNotification = true;
 
                                         if (DRAW_TWICE_AFTER_SIZE_CHANGED) {
-                                            // We keep mRequestRender true so that we draw twice after the size changes.
+                                            // We keep mRequestRender true so that we batch twice after the size changes.
                                             // (Once because of mSizeChanged, the second time because of mRequestRender.)
                                             // This forces the updated graphics onto the screen.
                                         } else {
@@ -1110,7 +1110,7 @@ public class GLSurfaceView21 extends SurfaceView implements SurfaceHolder.Callba
                             }
                             sGLThreadManager.wait();
                         }
-                    } // end of synchronized(sGLThreadManager)
+                    } // pop of synchronized(sGLThreadManager)
 
                     if (event != null) {
                         event.run();
diff --git a/src/main/java/zame/game/libs/WeightedLayout.java b/src/main/java/zame/game/core/widget/WeightedLayout.java
similarity index 99%
rename from src/main/java/zame/game/libs/WeightedLayout.java
rename to src/main/java/zame/game/core/widget/WeightedLayout.java
index 709acf4..184979e 100644
--- a/src/main/java/zame/game/libs/WeightedLayout.java
+++ b/src/main/java/zame/game/core/widget/WeightedLayout.java
@@ -1,4 +1,4 @@
-package zame.game.libs;
+package zame.game.core.widget;
 
 import android.content.Context;
 import android.content.res.TypedArray;
diff --git a/src/main/java/zame/game/engine/Config.java b/src/main/java/zame/game/engine/Config.java
index 75d8081..bb8e21c 100644
--- a/src/main/java/zame/game/engine/Config.java
+++ b/src/main/java/zame/game/engine/Config.java
@@ -1,9 +1,10 @@
 package zame.game.engine;
 
-import android.content.SharedPreferences;
 import android.view.KeyEvent;
 import zame.game.App;
-import zame.game.engine.controls.Controls;
+import zame.game.R;
+import zame.game.core.manager.PreferencesManager;
+import zame.game.engine.visual.Controls;
 
 public class Config implements EngineObject {
     protected Engine engine;
@@ -23,17 +24,17 @@ public class Config implements EngineObject {
     public int[] keyMappings;
     public boolean rotateScreen;
 
-    float gamma;
+    public float gamma;
     boolean showCrosshair;
     @SuppressWarnings("MagicNumber") float wpDim = 0.5f;
 
     @Override
-    public void setEngine(Engine engine) {
+    public void onCreate(Engine engine) {
         this.engine = engine;
     }
 
-    private void updateKeyMap(SharedPreferences sp, String key, int type) {
-        int keyCode = sp.getInt(key, 0);
+    private void updateKeyMap(int keyResId, int type) {
+        int keyCode = App.self.preferences.getInt(keyResId);
 
         if (keyCode > 0 && keyCode < keyMappings.length) {
             keyMappings[keyCode] = type;
@@ -63,26 +64,35 @@ public class Config implements EngineObject {
 
     @SuppressWarnings("MagicNumber")
     public void reload() {
-        SharedPreferences sp = App.self.getSharedPreferences();
-        String controlSchemeStr = sp.getString("ControlsScheme", "StaticMovePad");
+        PreferencesManager preferences = App.self.preferences;
 
-        if ("FreeMovePad".equals(controlSchemeStr)) {
+        String controlSchemeStr = preferences.getString(R.string.key_controls_scheme,
+                R.string.val_scheme_static_move_pad);
+
+        if (App.self.getString(R.string.val_scheme_free_move_pad).equals(controlSchemeStr)) {
             controlScheme = Controls.SCHEME_FREE_MOVE_PAD;
         } else {
             controlScheme = Controls.SCHEME_STATIC_MOVE_PAD;
         }
 
-        moveSpeed = getAccel(sp.getInt("MoveSpeed", 8), 1, 8, 15, 0.25f, 0.5f, 1.0f);
-        strafeSpeed = getAccel(sp.getInt("StrafeSpeed", 8), 1, 8, 15, 0.25f, 0.5f, 1.0f) * 0.5f;
-        rotateSpeed = getAccel(sp.getInt("RotateSpeed", 8), 1, 8, 15, 0.5f, 1.0f, 2.0f);
-        verticalLookMult = (sp.getBoolean("InvertVerticalLook", false) ? -1.0f : 1.0f);
-        horizontalLookMult = (sp.getBoolean("InvertHorizontalLook", false) ? -1.0f : 1.0f);
-        leftHandAim = sp.getBoolean("LeftHandAim", false);
-        fireButtonAtTop = sp.getBoolean("FireButtonAtTop", false);
-        controlsAlpha = 0.1f * (float)sp.getInt("ControlsAlpha", 5);
-        accelerometerEnabled = sp.getBoolean("AccelerometerEnabled", false);
-        accelerometerAcceleration = (float)sp.getInt("AccelerometerAcceleration", 5);
-        trackballAcceleration = getAccel(sp.getInt("TrackballAcceleration", 5), 1, 5, 9, 0.1f, 1.0f, 10.0f);
+        moveSpeed = getAccel(preferences.getInt(R.string.key_move_speed, 8), 1, 8, 15, 0.25f, 0.5f, 1.0f);
+        strafeSpeed = getAccel(preferences.getInt(R.string.key_strafe_speed, 8), 1, 8, 15, 0.25f, 0.5f, 1.0f) * 0.5f;
+        rotateSpeed = getAccel(preferences.getInt(R.string.key_rotate_speed, 8), 1, 8, 15, 0.5f, 1.0f, 2.0f);
+        verticalLookMult = preferences.getBoolean(R.string.key_invert_vertical_look) ? -1.0f : 1.0f;
+        horizontalLookMult = preferences.getBoolean(R.string.key_invert_horizontal_look) ? -1.0f : 1.0f;
+        leftHandAim = preferences.getBoolean(R.string.key_left_hand_aim);
+        fireButtonAtTop = preferences.getBoolean(R.string.key_fire_button_at_top);
+        controlsAlpha = 0.1f * (float)preferences.getInt(R.string.key_controls_alpha, 5);
+        accelerometerEnabled = preferences.getBoolean(R.string.key_accelerometer_enabled);
+        accelerometerAcceleration = (float)preferences.getInt(R.string.key_accelerometer_acceleration, 5);
+
+        trackballAcceleration = getAccel(preferences.getInt(R.string.key_trackball_acceleration, 5),
+                1,
+                5,
+                9,
+                0.1f,
+                1.0f,
+                10.0f);
 
         keyMappings = new int[KeyEvent.getMaxKeyCode()];
 
@@ -90,19 +100,18 @@ public class Config implements EngineObject {
             keyMappings[i] = 0;
         }
 
-        updateKeyMap(sp, "KeyForward", Controls.FORWARD);
-        updateKeyMap(sp, "KeyBackward", Controls.BACKWARD);
-        updateKeyMap(sp, "KeyRotateLeft", Controls.ROTATE_LEFT);
-        updateKeyMap(sp, "KeyRotateRight", Controls.ROTATE_RIGHT);
-        updateKeyMap(sp, "KeyStrafeLeft", Controls.STRAFE_LEFT);
-        updateKeyMap(sp, "KeyStrafeRight", Controls.STRAFE_RIGHT);
-        updateKeyMap(sp, "KeyFire", Controls.FIRE);
-        updateKeyMap(sp, "KeyNextWeapon", Controls.NEXT_WEAPON);
-        // updateKeyMap(sp, "KeyToggleMap", Controls.TOGGLE_MAP);
-        updateKeyMap(sp, "KeyStrafeMode", Controls.STRAFE_MODE);
-
-        gamma = (float)sp.getInt("Gamma", 1) * 0.04f;
-        showCrosshair = sp.getBoolean("ShowCrosshair", true);
-        rotateScreen = sp.getBoolean("RotateScreen", false);
+        updateKeyMap(R.string.key_hwkey_forward, Controls.FORWARD);
+        updateKeyMap(R.string.key_hwkey_backward, Controls.BACKWARD);
+        updateKeyMap(R.string.key_hwkey_rotate_left, Controls.ROTATE_LEFT);
+        updateKeyMap(R.string.key_hwkey_rotate_right, Controls.ROTATE_RIGHT);
+        updateKeyMap(R.string.key_hwkey_strafe_left, Controls.STRAFE_LEFT);
+        updateKeyMap(R.string.key_hwkey_strafe_right, Controls.STRAFE_RIGHT);
+        updateKeyMap(R.string.key_hwkey_fire, Controls.FIRE);
+        updateKeyMap(R.string.key_hwkey_next_weapon, Controls.NEXT_WEAPON);
+        updateKeyMap(R.string.key_hwkey_strafe_mode, Controls.STRAFE_MODE);
+
+        gamma = (float)preferences.getInt(R.string.key_gamma, 1) * 0.04f;
+        showCrosshair = preferences.getBoolean(R.string.key_show_crosshair, true);
+        rotateScreen = preferences.getBoolean(R.string.key_rotate_screen);
     }
 }
diff --git a/src/main/java/zame/game/engine/Engine.java b/src/main/java/zame/game/engine/Engine.java
index 2006560..8406088 100644
--- a/src/main/java/zame/game/engine/Engine.java
+++ b/src/main/java/zame/game/engine/Engine.java
@@ -1,101 +1,102 @@
 package zame.game.engine;
 
-import android.content.Intent;
 import android.os.SystemClock;
 import android.text.TextUtils;
 import java.io.File;
 import java.util.Random;
 import javax.microedition.khronos.opengles.GL10;
-import javax.microedition.khronos.opengles.GL11ExtensionPack;
 import zame.game.App;
-import zame.game.MainActivity;
-import zame.game.engine.hud.AutoMap;
-import zame.game.engine.hud.Stats;
-import zame.game.fragments.GameFragment;
-import zame.game.managers.SoundManager;
-import zame.game.misc.DummyRewardedVideoActivity;
-import zame.game.store.Profile;
-
-// According to qualcomm docs, you need to glclear after every glbindframebuffer,
-// this is a problem related to tiled architecture, if you are switching framebuffers,
-// data need to get copied from fastmem to normal memory to save current framebuffer
-// and from slowmem to fast mem to get contents of newly binded frame, in case you are
-// clearing just after glbind no data is copied from slowmem to fastmem and you are saving time,
-// but you need to redesign your render pipeline often, so it will avoid reading data back
-// and forth between slow and fast memory, so try to do glclear after each bind
+import zame.game.core.util.Common;
+import zame.game.engine.controller.HeroController;
+import zame.game.engine.graphics.Labels;
+import zame.game.engine.graphics.Renderer;
+import zame.game.engine.graphics.TextureLoader;
+import zame.game.engine.level.Level;
+import zame.game.engine.level.LevelRenderer;
+import zame.game.engine.state.Profile;
+import zame.game.engine.state.ProfileLevel;
+import zame.game.engine.state.State;
+import zame.game.engine.visual.AutoMap;
+import zame.game.engine.visual.EndLevel;
+import zame.game.engine.visual.GameOver;
+import zame.game.engine.visual.Overlay;
+import zame.game.engine.visual.Stats;
+import zame.game.engine.visual.Weapons;
+import zame.game.feature.main.MainActivity;
+import zame.game.feature.sound.SoundManager;
+import zame.game.flavour.config.AppConfig;
 
 public class Engine {
-    static final int FRAMES_PER_SECOND = 40;
-    static final int FRAMES_PER_SECOND_D10 = FRAMES_PER_SECOND / 10; // must be >= 1
+    private static final long INTERSTITIAL_MIN_INTERVAL_MS = 3L * 60L * 1000L;
 
+    static final int FRAMES_PER_SECOND = 40;
+    public static final int FRAMES_PER_SECOND_D10 = FRAMES_PER_SECOND / 10; // must be >= 1
     private static final int UPDATE_INTERVAL = 1000 / FRAMES_PER_SECOND;
     private static final int FPS_AVG_LEN = 2;
 
-    static final int VIEW_TYPE_SELECT_EPISODE = 1;
-    static final int VIEW_TYPE_GAME_MENU = 2;
-    static final int VIEW_TYPE_REWARDED_VIDEO = 3;
+    static final int VIEW_TYPE_GAME_MENU = 1;
+    static final int VIEW_TYPE_SELECT_EPISODE = 2;
+    public static final int VIEW_TYPE_REWARDED_VIDEO = 3;
 
     static final String DGB_SAVE_PREFIX = "debug_";
 
-    protected MainActivity activity;
-    @SuppressWarnings("FieldAccessedSynchronizedAndUnsynchronized") private long startTime;
-    @SuppressWarnings("FieldAccessedSynchronizedAndUnsynchronized") private long lastTime;
-    @SuppressWarnings("FieldAccessedSynchronizedAndUnsynchronized") private boolean isPaused;
-    private int createdTexturesCount;
-    private int totalTexturesCount;
-    private int frames;
-    private long prevRenderTime;
-    private int[] fpsList = new int[FPS_AVG_LEN];
-    private int currFpsPtr;
-    @SuppressWarnings("FieldAccessedSynchronizedAndUnsynchronized") private boolean callResumeAfterSurfaceCreated;
-
+    public final Random random = new Random();
+    public MainActivity activity;
     public boolean inWallpaperMode;
-    public boolean renderBlackScreen;
-    public boolean gameViewActive = true;
-    @SuppressWarnings("FieldAccessedSynchronizedAndUnsynchronized") public long elapsedTime;
-    public int width = 1;
-    public int height = 1;
-    public float ratio = 1.0f;
-    public float heroCs; // cos of angle
-    public float heroSn; // sin of angle
-    public boolean interacted;
-    public String instantName;
 
-    boolean fboSupported;
-    Random random = new Random();
-    float heroAr; // angle in radians
-    boolean showFps;
+    public String instantName;
     String autosaveName;
-    float healthHitMonsterMult;
-    float healthHitHeroMult;
-
-    private int screenWidth = 1;
-    private int screenHeight = 1;
-    private boolean renderToTexture;
-    private int[] framebuffers = new int[1];
-    private int[] depthbuffers = new int[1];
-    private boolean fboComplete;
-
     public Profile profile;
+    public SoundManager soundManager;
+    public HeroController heroController;
     public Config config = new Config();
-    @SuppressWarnings("FieldAccessedSynchronizedAndUnsynchronized") public Game game = new Game();
-    @SuppressWarnings("FieldAccessedSynchronizedAndUnsynchronized") public State state = new State();
+    public Game game = new Game();
+    public State state = new State();
     public Labels labels = new Labels();
     public Overlay overlay = new Overlay();
-    public TextureLoader textureLoader = new TextureLoader();
+    private TextureLoader textureLoader = new TextureLoader();
     public Level level = new Level();
     public Weapons weapons = new Weapons();
     public Renderer renderer = new Renderer();
     public LevelRenderer levelRenderer = new LevelRenderer();
     public Stats stats = new Stats();
     public AutoMap autoMap = new AutoMap();
-
     EndLevel endLevel = new EndLevel();
     GameOver gameOver = new GameOver();
 
-    public HeroController heroController;
-    public SoundManager soundManager;
-    // public Tracker tracker;
+    private boolean renderToTexture;
+    private int screenWidth = 1;
+    private int screenHeight = 1;
+    public int width = 1;
+    public int height = 1;
+    public float ratio = 1.0f;
+
+    public boolean interacted;
+    public boolean gameViewActive = true;
+    public boolean renderBlackScreen;
+    private boolean callResumeAfterSurfaceCreated;
+    private volatile boolean isPaused;
+    private volatile long pausedTime;
+    private long startTime;
+    private long lastTime;
+    public long elapsedTime;
+
+    private int createdTexturesCount;
+    private int totalTexturesCount;
+
+    private int fpsFrames;
+    private long fpsPrevRenderTime;
+    private int[] fpsList = new int[FPS_AVG_LEN];
+    private int fpsCurrentIndex;
+
+    private boolean isInterstitialPending;
+    private long lastInterstitialShownAt;
+    public boolean canShowRewardedVideo;
+
+    public float heroAr; // angle in radians
+    public float heroCs; // cos of angle
+    public float heroSn; // sin of angle
+    boolean showFps;
 
     public Engine(MainActivity activity) {
         this.activity = activity;
@@ -106,34 +107,29 @@ public class Engine {
 
         profile = App.self.profile;
         soundManager = SoundManager.getInstance(inWallpaperMode);
-        // tracker = Tracker.getInstance(inWallpaperMode);
         heroController = HeroController.newInstance(inWallpaperMode);
 
-        config.setEngine(this);
-        game.setEngine(this);
-        state.setEngine(this);
-        labels.setEngine(this);
-        overlay.setEngine(this);
-        textureLoader.setEngine(this);
-        level.setEngine(this);
-        levelRenderer.setEngine(this);
-        weapons.setEngine(this);
-        renderer.setEngine(this);
-        stats.setEngine(this);
-        autoMap.setEngine(this);
-        heroController.setEngine(this);
-        endLevel.setEngine(this);
-        gameOver.setEngine(this);
+        config.onCreate(this);
+        game.onCreate(this);
+        state.onCreate(this);
+        labels.onCreate(this);
+        overlay.onCreate(this);
+        textureLoader.onCreate(this);
+        level.onCreate(this);
+        levelRenderer.onCreate(this);
+        weapons.onCreate(this);
+        renderer.onCreate(this);
+        stats.onCreate(this);
+        autoMap.onCreate(this);
+        heroController.onCreate(this);
+        endLevel.onCreate(this);
+        gameOver.onCreate(this);
     }
 
-    public void init() {
-        healthHitMonsterMult = 1.0f;
-        healthHitHeroMult = 1.0f;
-
+    public void onActivated() {
         config.reload();
-        renderer.init();
-        game.init();
         heroController.reload();
+        game.onActivated();
 
         interacted = false;
         gameViewActive = true;
@@ -142,11 +138,12 @@ public class Engine {
         startTime = SystemClock.elapsedRealtime();
     }
 
-    void updateAfterLevelLoadedOrCreated() {
-        level.updateMaps();
-        levelRenderer.updateAfterLoadOrCreate();
-        heroController.updateAfterLoadOrCreate();
-        weapons.updateWeapon();
+    public void updateAfterLevelLoadedOrCreated() {
+        canShowRewardedVideo = (profile.getLevel(state.levelName).adLevel >= ProfileLevel.AD_REWARDED);
+        level.updateAfterLevelLoadedOrCreated();
+        levelRenderer.updateAfterLevelLoadedOrCreated();
+        heroController.updateAfterLevelLoadedOrCreated();
+        weapons.setHeroWeaponImmediate(state.heroWeapon);
     }
 
     void createAutosave() {
@@ -155,7 +152,7 @@ public class Engine {
         }
     }
 
-    String getSavePathBySaveName(String name) {
+    public String getSavePathBySaveName(String name) {
         return App.self.internalRoot + name + ".save";
     }
 
@@ -176,7 +173,6 @@ public class Engine {
         }
 
         // also delete wallpaper instant save
-
         instant = new File(App.self.internalRoot + "winstant.save");
 
         if (instant.exists()) {
@@ -185,7 +181,7 @@ public class Engine {
         }
     }
 
-    void changeView(int viewType) {
+    public void changeView(int viewType) {
         switch (viewType) {
             case VIEW_TYPE_GAME_MENU:
                 if (activity != null) {
@@ -197,132 +193,87 @@ public class Engine {
                 if (activity != null) {
                     gameViewActive = false;
                     renderBlackScreen = true;
+
+                    String prevLevelName = profile.getLevel(state.levelName).getPrevLevelName();
+                    ProfileLevel prevProfileLevel = profile.getLevel(prevLevelName);
+
+                    boolean shouldShowInterstitial = (isInterstitialPending
+                            || prevProfileLevel.adLevel >= ProfileLevel.AD_INTERSTITIAL);
+
+                    long lastShowInterval = SystemClock.elapsedRealtime() - lastInterstitialShownAt;
+
+                    if (shouldShowInterstitial && (!App.self.mediadtor.isInterstitialLoaded()
+                            || lastShowInterval < INTERSTITIAL_MIN_INTERVAL_MS)) {
+
+                        shouldShowInterstitial = false;
+                        isInterstitialPending = true;
+                    }
+
+                    if (AppConfig.DEBUG) {
+                        Common.log("Interstitial: prevLevelName = "
+                                + prevLevelName
+                                + ", adLevel = "
+                                + prevProfileLevel.adLevel
+                                + ", isInterstitialPending = "
+                                + isInterstitialPending
+                                + ", isInterstitialLoaded = "
+                                + App.self.mediadtor.isInterstitialLoaded()
+                                + ", lastShowInterval = "
+                                + lastShowInterval
+                                + " (INTERSTITIAL_MIN_INTERVAL_MS = "
+                                + INTERSTITIAL_MIN_INTERVAL_MS
+                                + "), shouldShowInterstitial = "
+                                + shouldShowInterstitial);
+                    }
+
+                    if (shouldShowInterstitial) {
+                        forceStateSave();
+                    }
+
                     activity.showFragment(activity.selectEpisodeFragment);
+
+                    if (shouldShowInterstitial) {
+                        isInterstitialPending = false;
+                        lastInterstitialShownAt = SystemClock.elapsedRealtime();
+                        App.self.mediadtor.showInterstitial(activity);
+                    }
                 } else {
-                    createdTexturesCount = 0;
+                    createdTexturesCount = 0; // WHY?
                 }
                 break;
 
             case VIEW_TYPE_REWARDED_VIDEO:
-                if (activity != null) {
-                    onPause(); // to ensure that state is saved
-
-                    activity.gameFragment.startActivityForResult(new Intent(activity, DummyRewardedVideoActivity.class),
-                            GameFragment.REQ_DUMMY_REWARDED_VIDEO_ACTIVITY);
+                if (activity != null && App.self.mediadtor.isRewardedVideoLoaded()) {
+                    forceStateSave();
+                    lastInterstitialShownAt = SystemClock.elapsedRealtime();
+                    App.self.mediadtor.showRewardedVideo(activity);
+                } else {
+                    game.loadLevel(Game.LOAD_LEVEL_NORMAL);
                 }
                 break;
         }
     }
 
-    void heroAngleUpdated() {
-        //noinspection MagicNumber
-        state.heroA = (360.0f + (state.heroA % 360.0f)) % 360.0f;
-
-        heroAr = state.heroA * GameMath.G2RAD_F;
-        heroCs = (float)Math.cos(heroAr);
-        heroSn = (float)Math.sin(heroAr);
+    public void onRewardedVideoClosed(boolean shouldGiveReward) {
+        game.isRewardedVideoWatched = shouldGiveReward;
+        gameViewActive = false;
+        renderBlackScreen = true;
     }
 
-    int getRealHits(int maxHits, float dist) {
+    public int getRealHits(int maxHits, float dist) {
         //noinspection MagicNumber
         float div = Math.max(1.0f, dist * 0.35f);
 
         int minHits = Math.max(1, (int)((float)maxHits / div));
-
         return (random.nextInt(maxHits - minHits + 1) + minHits);
     }
 
-    // modified Level_CheckLine from wolf3d for iphone by Carmack
-    boolean traceLine(float x1, float y1, float x2, float y2, int mask) {
-        int cx1 = (int)x1;
-        int cy1 = (int)y1;
-        int cx2 = (int)x2;
-        int cy2 = (int)y2;
-        int maxX = state.levelWidth - 1;
-        int maxY = state.levelHeight - 1;
-
-        // level has one-cell border
-        if (cx1 <= 0 || cx1 >= maxX || cy1 <= 0 || cy1 >= maxY || cx2 <= 0 || cx2 >= maxX || cy2 <= 0 || cy2 >= maxY) {
-            return false;
-        }
-
-        int[][] localPassableMap = state.passableMap;
-
-        if (cx1 != cx2) {
-            int stepX;
-            float partial;
-
-            if (cx2 > cx1) {
-                partial = 1.0f - (x1 - (float)((int)x1));
-                stepX = 1;
-            } else {
-                partial = x1 - (float)((int)x1);
-                stepX = -1;
-            }
-
-            float dx = ((x2 >= x1) ? (x2 - x1) : (x1 - x2));
-            float stepY = (y2 - y1) / dx;
-            float y = y1 + (stepY * partial);
-
-            cx1 += stepX;
-            cx2 += stepX;
-
-            do {
-                if ((localPassableMap[(int)y][cx1] & mask) != 0) {
-                    return false;
-                }
-
-                y += stepY;
-                cx1 += stepX;
-            } while (cx1 != cx2);
-        }
-
-        if (cy1 != cy2) {
-            int stepY;
-            float partial;
-
-            if (cy2 > cy1) {
-                partial = 1.0f - (y1 - (float)((int)y1));
-                stepY = 1;
-            } else {
-                partial = y1 - (float)((int)y1);
-                stepY = -1;
-            }
-
-            float dy = ((y2 >= y1) ? (y2 - y1) : (y1 - y2));
-            float stepX = (x2 - x1) / dy;
-            float x = x1 + (stepX * partial);
-
-            cy1 += stepY;
-            cy2 += stepY;
-
-            do {
-                if ((localPassableMap[cy1][(int)x] & mask) != 0) {
-                    return false;
-                }
-
-                x += stepX;
-                cy1 += stepY;
-            } while (cy1 != cy2);
-        }
-
-        return true;
-    }
-
     public void onSurfaceCreated(GL10 gl) {
-        fboSupported = ((" " + gl.glGetString(GL10.GL_EXTENSIONS) + " ").contains(" GL_OES_framebuffer_object "));
-        gl.glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
-
-        gl.glEnable(GL10.GL_CULL_FACE);
-        gl.glFrontFace(GL10.GL_CCW);
-        gl.glCullFace(GL10.GL_BACK);
-        gl.glDisable(GL10.GL_DITHER);
-        gl.glTexEnvf(GL10.GL_TEXTURE_ENV, GL10.GL_TEXTURE_ENV_MODE, GL10.GL_MODULATE);
-        gl.glDepthFunc(GL10.GL_LESS); // GL10.GL_LEQUAL
+        renderer.onSurfaceCreated(gl);
 
         createdTexturesCount = 0;
         totalTexturesCount = TextureLoader.TEXTURES_TO_LOAD.length + 1;
-        textureLoader.onSurfaceCreated(gl);
+        textureLoader.onSurfaceCreated();
 
         if (callResumeAfterSurfaceCreated) {
             callResumeAfterSurfaceCreated = false;
@@ -333,70 +284,29 @@ public class Engine {
     public void onSurfaceChanged(GL10 gl, int width, int height) {
         this.screenWidth = (width < 1 ? 1 : width); // just for case
         this.screenHeight = (height < 1 ? 1 : height); // just for case
-        renderToTexture = (inWallpaperMode && width < height);
-        fboComplete = false;
-
-        if (renderToTexture && fboSupported) {
-            GL11ExtensionPack gl11ep = (GL11ExtensionPack)gl;
-            gl11ep.glGenFramebuffersOES(1, framebuffers, 0);
-            gl11ep.glBindFramebufferOES(GL11ExtensionPack.GL_FRAMEBUFFER_OES, framebuffers[0]);
-            gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT | GL10.GL_STENCIL_BUFFER_BIT);
-
-            gl11ep.glGenRenderbuffersOES(1, depthbuffers, 0);
-            gl11ep.glBindRenderbufferOES(GL11ExtensionPack.GL_RENDERBUFFER_OES, depthbuffers[0]);
-
-            gl11ep.glRenderbufferStorageOES(GL11ExtensionPack.GL_RENDERBUFFER_OES,
-                    GL11ExtensionPack.GL_DEPTH_COMPONENT16,
-                    TextureLoader.RENDER_TO_FBO_SIZE,
-                    TextureLoader.RENDER_TO_FBO_SIZE);
-
-            gl11ep.glFramebufferRenderbufferOES(GL11ExtensionPack.GL_FRAMEBUFFER_OES,
-                    GL11ExtensionPack.GL_DEPTH_ATTACHMENT_OES,
-                    GL11ExtensionPack.GL_RENDERBUFFER_OES,
-                    depthbuffers[0]);
-
-            gl11ep.glFramebufferTexture2DOES(GL11ExtensionPack.GL_FRAMEBUFFER_OES,
-                    GL11ExtensionPack.GL_COLOR_ATTACHMENT0_OES,
-                    GL10.GL_TEXTURE_2D,
-                    textureLoader.textures[TextureLoader.TEXTURE_RENDER_TO_FBO],
-                    0);
-
-            int status = gl11ep.glCheckFramebufferStatusOES(GL11ExtensionPack.GL_FRAMEBUFFER_OES);
-
-            if (status == GL11ExtensionPack.GL_FRAMEBUFFER_COMPLETE_OES) {
-                fboComplete = true;
-            }
 
-            gl11ep.glBindFramebufferOES(GL11ExtensionPack.GL_FRAMEBUFFER_OES, 0);
-            gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT | GL10.GL_STENCIL_BUFFER_BIT);
-        }
+        renderer.onSurfaceChanged(gl);
+        renderToTexture = (inWallpaperMode && width < height);
 
         if (renderToTexture) {
-            this.width = (fboComplete ? TextureLoader.RENDER_TO_FBO_SIZE : TextureLoader.RENDER_TO_SIZE);
-            this.height = (fboComplete ? TextureLoader.RENDER_TO_FBO_SIZE : TextureLoader.RENDER_TO_SIZE);
+            renderer.prepareFramebuffer();
+            this.width = renderer.getRenderToTextureSize();
+
+            //noinspection SuspiciousNameCombination
+            this.height = this.width;
         } else {
             this.width = screenWidth;
             this.height = screenHeight;
         }
 
-        gl.glViewport(0, 0, this.width, this.height);
+        renderer.useViewport(this.width, this.height);
         ratio = (float)(this.width < 1 ? 1 : this.width) / (float)(this.height < 1 ? 1 : this.height);
 
-        levelRenderer.surfaceSizeChanged(gl);
         heroController.surfaceSizeChanged();
         stats.surfaceSizeChanged();
     }
 
-    public void onPause() {
-        if (!isPaused) {
-            isPaused = true;
-            state.tempElapsedTime = elapsedTime;
-            state.tempLastTime = lastTime;
-            state.save(instantName);
-        }
-    }
-
-    public synchronized void onResume() {
+    public void onResume() {
         if (callResumeAfterSurfaceCreated) {
             // wait for created surface
             return;
@@ -408,15 +318,31 @@ public class Engine {
             lastTime = state.tempLastTime;
             startTime = SystemClock.elapsedRealtime() - elapsedTime;
         }
+    }
 
-        game.resume();
+    public void onPause() {
+        if (!isPaused) {
+            pausedTime = SystemClock.elapsedRealtime();
+            isPaused = true;
+            forceStateSave();
+        }
     }
 
-    private boolean texturesLoaded() {
-        return (createdTexturesCount >= totalTexturesCount);
+    private void forceStateSave() {
+        state.tempElapsedTime = elapsedTime;
+        state.tempLastTime = lastTime;
+        state.save(instantName);
     }
 
     public void onDrawFrame(GL10 gl) {
+        //noinspection MagicNumber
+        if (isPaused && (SystemClock.elapsedRealtime() - pausedTime) < 1000L) {
+            // Fix visual glitch when game menu appears
+            return;
+        }
+
+        renderer.onDrawFrame(gl);
+
         if (isPaused) {
             render(gl);
             return;
@@ -439,7 +365,7 @@ public class Engine {
                 lastTime += UPDATE_INTERVAL * count;
             }
 
-            if (texturesLoaded()) {
+            if (createdTexturesCount >= totalTexturesCount) {
                 while (count > 0 && !renderBlackScreen) {
                     game.update();
                     count--;
@@ -451,70 +377,46 @@ public class Engine {
     }
 
     @SuppressWarnings("MagicNumber")
-    private void drawPreloader(GL10 gl) {
-        renderer.initOrtho(gl, true, false, -ratio, ratio, 1.0f, -1.0f, 0.0f, 1.0f);
-        renderer.init();
-
-        gl.glShadeModel(GL10.GL_FLAT);
-        gl.glDisable(GL10.GL_DEPTH_TEST);
-        gl.glDisable(GL10.GL_BLEND);
-        gl.glDisable(GL10.GL_CULL_FACE);
-
-        renderer.setQuadRGBA(1.0f, 1.0f, 1.0f, 1.0f);
-        renderer.setQuadOrthoCoords(-0.5f, -0.5f, 0.5f, 0.5f);
-        renderer.setQuadTexCoords(0, 0, 1 << 16, 1 << 16);
-        renderer.drawQuad();
-
-        renderer.bindTextureBlur(gl, textureLoader.textures[TextureLoader.TEXTURE_LOADING]);
-        renderer.flush(gl);
-
-        gl.glEnable(GL10.GL_CULL_FACE);
-        gl.glMatrixMode(GL10.GL_PROJECTION);
-        gl.glPopMatrix();
+    private void renderPreloader() {
+        renderer.useOrtho(-ratio, ratio, 1.0f, -1.0f, 0.0f, 1.0f);
+        renderer.startBatch();
+        renderer.setColorQuadRGBA(1.0f, 1.0f, 1.0f, 1.0f);
+        renderer.setCoordsQuadRectFlat(-0.5f, -0.5f, 0.5f, 0.5f);
+        renderer.setTexRect(0, 0, 1 << 16, 1 << 16);
+        renderer.batchQuad();
+        renderer.renderBatch(0, Renderer.TEXTURE_LOADING);
     }
 
-    private void renderDimLayer(GL10 gl) {
-        renderer.initOrtho(gl, true, false, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f);
-        renderer.init();
-
-        renderer.setQuadRGBA(0.0f, 0.0f, 0.0f, config.wpDim);
-        renderer.setQuadOrthoCoords(0.0f, 0.0f, 1.0f, 1.0f);
-        renderer.drawQuad();
-
-        gl.glShadeModel(GL10.GL_FLAT);
-        gl.glDisable(GL10.GL_DEPTH_TEST);
-        gl.glEnable(GL10.GL_BLEND);
-        gl.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);
-        renderer.flush(gl, false);
-
-        gl.glMatrixMode(GL10.GL_PROJECTION);
-        gl.glPopMatrix();
+    private void renderDimLayer() {
+        renderer.useOrtho(0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f);
+        renderer.startBatch();
+        renderer.setColorQuadRGBA(0.0f, 0.0f, 0.0f, config.wpDim);
+        renderer.setCoordsQuadRectFlat(0.0f, 0.0f, 1.0f, 1.0f);
+        renderer.batchQuad();
+        renderer.renderBatch(Renderer.FLAG_BLEND);
     }
 
     @SuppressWarnings("MagicNumber")
     protected void render(GL10 gl) {
-        GL11ExtensionPack gl11ep = null;
-
         if (renderBlackScreen) {
-            gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT | GL10.GL_STENCIL_BUFFER_BIT);
+            renderer.clear();
             return;
         }
 
-        if (renderToTexture && fboComplete) {
-            gl11ep = (GL11ExtensionPack)gl;
-            gl11ep.glBindFramebufferOES(GL11ExtensionPack.GL_FRAMEBUFFER_OES, framebuffers[0]);
+        if (renderToTexture) {
+            renderer.startRenderToTexture();
+        } else {
+            renderer.clear();
         }
 
-        gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT | GL10.GL_STENCIL_BUFFER_BIT);
-
         if (createdTexturesCount < totalTexturesCount) {
-            drawPreloader(gl);
+            renderPreloader();
 
             if (createdTexturesCount == 0) {
-                labels.createLabels(gl);
+                labels.createLabels();
                 createdTexturesCount++;
             } else if (App.self.cachedTexturesReady) {
-                textureLoader.loadTexture(gl, createdTexturesCount - 1);
+                textureLoader.loadTexture(createdTexturesCount - 1);
                 createdTexturesCount++;
             }
 
@@ -522,7 +424,7 @@ public class Engine {
                 System.gc();
             }
         } else {
-            game.render(gl);
+            game.render();
         }
 
         if (inWallpaperMode || isPaused) {
@@ -535,7 +437,7 @@ public class Engine {
         }
 
         if (inWallpaperMode) {
-            renderDimLayer(gl);
+            renderDimLayer();
         }
 
         // http://stackoverflow.com/questions/10729352/framebuffer-fbo-render-to-texture-is-very-slow-using-opengl-es-2-0-on-android
@@ -543,60 +445,55 @@ public class Engine {
         // http://www.gamedev.net/topic/590324-fbo-set-up-on-android/
 
         if (renderToTexture) {
-            if (gl11ep != null) {
-                gl11ep.glBindFramebufferOES(GL11ExtensionPack.GL_FRAMEBUFFER_OES, 0);
-                gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT | GL10.GL_STENCIL_BUFFER_BIT);
-                renderer.bindTextureBlur(gl, textureLoader.textures[TextureLoader.TEXTURE_RENDER_TO_FBO]);
-            } else {
-                renderer.bindTextureBlur(gl, textureLoader.textures[TextureLoader.TEXTURE_RENDER_TO]);
-                gl.glCopyTexImage2D(GL10.GL_TEXTURE_2D, 0, GL10.GL_RGB, 0, 0, width, height, 0);
-            }
+            renderer.finishRenderToTexture(width, height);
 
-            gl.glViewport(0, 0, screenWidth, screenHeight);
-            gl.glShadeModel(GL10.GL_FLAT);
-            gl.glDisable(GL10.GL_DEPTH_TEST);
-            gl.glDisable(GL10.GL_BLEND);
-
-            float widthD2 = (float)screenWidth * 0.5f;
-            float heightD2 = (float)screenHeight * 0.5f;
-
-            gl.glMatrixMode(GL10.GL_PROJECTION);
-            gl.glPushMatrix();
-            gl.glLoadIdentity();
-            gl.glOrthof(-widthD2, widthD2, -heightD2, heightD2, 0.0f, 1.0f);
-            gl.glMatrixMode(GL10.GL_MODELVIEW);
-            gl.glLoadIdentity();
-
-            renderer.init();
-            renderer.setQuadRGBA(1.0f, 1.0f, 1.0f, 1.0f);
-            renderer.setQuadTexCoords(0, 0, 1 << 16, 1 << 16);
-            renderer.setQuadOrthoCoords(-heightD2, -heightD2, heightD2, heightD2);
-            renderer.drawQuad();
-            renderer.flush(gl);
-
-            gl.glMatrixMode(GL10.GL_PROJECTION);
-            gl.glPopMatrix();
+            float halfScreenWidth = (float)screenWidth * 0.5f;
+            float halfScreenHeight = (float)screenHeight * 0.5f;
 
-            //noinspection SuspiciousNameCombination
-            gl.glViewport(0, 0, height, width);
+            renderer.startBatch();
+            renderer.setColorQuadRGBA(1.0f, 1.0f, 1.0f, 1.0f);
+            renderer.setTexRect(0, 0, 1 << 16, 1 << 16);
+            renderer.setCoordsQuadRectFlat(-halfScreenHeight, -halfScreenHeight, halfScreenHeight, halfScreenHeight);
+            renderer.batchQuad();
+
+            gl.glViewport(0, 0, screenWidth, screenHeight);
+            renderer.useOrtho(-halfScreenWidth, halfScreenWidth, -halfScreenHeight, halfScreenHeight, 0.0f, 1.0f);
+            renderer.renderBatch(0, Renderer.TEXTURE_RTT);
+            gl.glViewport(0, 0, width, height);
         }
     }
 
+    void renderFps() {
+        labels.startBatch();
+        renderer.setColorQuadRGBA(1.0f, 1.0f, 1.0f, 1.0f);
+
+        //noinspection MagicNumber
+        labels.batch(-ratio + 0.01f,
+                -1.0f + 0.01f,
+                ratio,
+                1.0f,
+                String.format(labels.map[Labels.LABEL_FPS], getAvgFps()),
+                0.125f,
+                Labels.ALIGN_BL);
+
+        labels.renderBatch();
+    }
+
     @SuppressWarnings("MagicNumber")
     private int getAvgFps() {
-        frames++;
+        fpsFrames++;
 
         long time = SystemClock.elapsedRealtime();
-        long diff = time - prevRenderTime;
+        long diff = time - fpsPrevRenderTime;
 
         if (diff > 1000) {
             int seconds = (int)(diff / 1000L);
-            prevRenderTime += (long)seconds * 1000L;
+            fpsPrevRenderTime += (long)seconds * 1000L;
 
-            fpsList[currFpsPtr] = frames / seconds;
-            currFpsPtr = (currFpsPtr + 1) % FPS_AVG_LEN;
+            fpsList[fpsCurrentIndex] = fpsFrames / seconds;
+            fpsCurrentIndex = (fpsCurrentIndex + 1) % FPS_AVG_LEN;
 
-            frames = 0;
+            fpsFrames = 0;
         }
 
         int sum = 0;
@@ -607,23 +504,4 @@ public class Engine {
 
         return (sum / FPS_AVG_LEN);
     }
-
-    void drawFps(GL10 gl) {
-        int fps = getAvgFps();
-        renderer.setQuadRGBA(1.0f, 1.0f, 1.0f, 1.0f);
-
-        labels.beginDrawing(gl);
-
-        //noinspection MagicNumber
-        labels.draw(gl,
-                -ratio + 0.01f,
-                -1.0f + 0.01f,
-                ratio,
-                1.0f,
-                String.format(labels.map[Labels.LABEL_FPS], fps),
-                0.125f,
-                Labels.ALIGN_BL);
-
-        labels.endDrawing(gl);
-    }
 }
diff --git a/src/main/java/zame/game/engine/EngineObject.java b/src/main/java/zame/game/engine/EngineObject.java
index b865a46..2886584 100644
--- a/src/main/java/zame/game/engine/EngineObject.java
+++ b/src/main/java/zame/game/engine/EngineObject.java
@@ -1,5 +1,5 @@
 package zame.game.engine;
 
 public interface EngineObject {
-    void setEngine(Engine engine);
+    void onCreate(Engine engine);
 }
diff --git a/src/main/java/zame/game/engine/Game.java b/src/main/java/zame/game/engine/Game.java
index bfb9924..6fcf1fb 100644
--- a/src/main/java/zame/game/engine/Game.java
+++ b/src/main/java/zame/game/engine/Game.java
@@ -1,22 +1,42 @@
 package zame.game.engine;
 
 import android.text.TextUtils;
-import javax.microedition.khronos.opengles.GL10;
 import zame.game.App;
-import zame.game.Common;
 import zame.game.R;
-import zame.game.engine.hud.AutoMap;
-import zame.game.managers.SoundManager;
-import zame.game.store.Achievements;
-import zame.game.store.Profile;
+import zame.game.core.util.Common;
+import zame.game.engine.controller.HeroController;
+import zame.game.engine.entity.Bullet;
+import zame.game.engine.entity.Door;
+import zame.game.engine.entity.Explosion;
+import zame.game.engine.entity.LookPoint;
+import zame.game.engine.entity.Mark;
+import zame.game.engine.entity.Monster;
+import zame.game.engine.entity.ObjectContainer;
+import zame.game.engine.entity.Timeout;
+import zame.game.engine.graphics.Labels;
+import zame.game.engine.graphics.Renderer;
+import zame.game.engine.graphics.TextureLoader;
+import zame.game.engine.level.Level;
+import zame.game.engine.level.LevelRenderer;
+import zame.game.engine.state.Profile;
+import zame.game.engine.state.State;
+import zame.game.engine.util.GameMath;
+import zame.game.engine.visual.AutoMap;
+import zame.game.engine.visual.EndLevel;
+import zame.game.engine.visual.GameOver;
+import zame.game.engine.visual.Overlay;
+import zame.game.engine.visual.Weapons;
+import zame.game.feature.achievements.Achievements;
+import zame.game.feature.sound.SoundManager;
+import zame.game.flavour.config.GameConfig;
 
 public class Game implements EngineObject {
     public static final int RENDER_MODE_GAME = 1;
     public static final int RENDER_MODE_END_LEVEL = 2;
     public static final int RENDER_MODE_GAME_OVER = 4;
-    public static final int RENDER_MODE_ALL = RENDER_MODE_GAME | RENDER_MODE_END_LEVEL | RENDER_MODE_GAME_OVER;
+    public static final int RENDER_MODE_ALL = RENDER_MODE_GAME | RENDER_MODE_END_LEVEL;
 
-    static final float WALK_WALL_DIST = 0.2f;
+    public static final float WALK_WALL_DIST = 0.2f;
     private static final float USE_IGNORE_THRESHOLD = 0.5f;
     private static final int LOAD_LEVEL_JUST_NEXT_NAME = 4;
     private static final float CROSSHAIR_SIZE = 0.005f;
@@ -28,9 +48,9 @@ public class Game implements EngineObject {
     private static final String PGT = P + G + T; // Please Give The
     private static final String PD = P + D; // Please Debug
 
-    static final int LOAD_LEVEL_NORMAL = 1;
-    @SuppressWarnings("WeakerAccess") static final int LOAD_LEVEL_NEXT = 2;
-    static final int LOAD_LEVEL_RELOAD = 3;
+    public static final int LOAD_LEVEL_NORMAL = 1;
+    private static final int LOAD_LEVEL_NEXT = 2;
+    public static final int LOAD_LEVEL_RELOAD = 3;
 
     private Engine engine;
     private Config config;
@@ -64,23 +84,26 @@ public class Game implements EngineObject {
     private int maxAmmoClip;
     private int maxAmmoShell;
     private int maxAmmoGrenade;
+    public float healthHitMonsterMult;
+    public float healthHitHeroMult;
     private long firstTouchTime;
     private boolean hasMoved;
 
-    long killedTime;
+    public long killedTime;
 
     public int actionFire;
     public boolean actionGameMenu;
     public boolean actionNextWeapon;
     public boolean[] actionQuickWeapons = { false, false, false };
-    public boolean actionUpgradeButton;
+    public boolean actionRestartButton;
+    public boolean actionContinueButton;
     public String savedGameParam = "";
     public String unprocessedGameCode = "";
     public int renderMode;
-    public boolean isRewardedVideoWatched;
+    boolean isRewardedVideoWatched;
 
     @Override
-    public void setEngine(Engine engine) {
+    public void onCreate(Engine engine) {
         this.engine = engine;
         this.config = engine.config;
         this.state = engine.state;
@@ -98,7 +121,7 @@ public class Game implements EngineObject {
         this.gameOver = engine.gameOver;
     }
 
-    private void setStartValues() {
+    private void reload() {
         nextLevelTime = 0;
         killedTime = 0;
         isGameOverFlag = false;
@@ -107,23 +130,23 @@ public class Game implements EngineObject {
         firstTouchTime = -1;
     }
 
-    public void init() {
-        setStartValues();
+    void onActivated() {
         renderMode = RENDER_MODE_GAME;
         soundManager.setPlaylist(SoundManager.LIST_MAIN);
 
-        labels.init();
-        overlay.init();
-        state.init();
-        level.init();
-        weapons.init();
+        reload();
+        labels.reload();
+        overlay.reload();
+        state.reload();
+        level.reload();
+        weapons.reload();
 
         if (TextUtils.isEmpty(savedGameParam)) {
             loadLevel(LOAD_LEVEL_NORMAL);
             playStartLevelSound = true;
 
             if (State.LEVEL_INITIAL.equals(state.levelName)) {
-                App.self.trackerInst.send("JustStarted");
+                App.self.tracker.trackEvent("JustStarted");
             }
         } else {
             int result = state.load(savedGameParam);
@@ -145,11 +168,13 @@ public class Game implements EngineObject {
     }
 
     private void updatePurchases() {
-        maxHealth = GameParams.HEALTH_MAX;
-        maxArmor = GameParams.ARMOR_MAX;
-        maxAmmoClip = GameParams.AMMO_MAX_CLIP;
-        maxAmmoShell = GameParams.AMMO_MAX_SHELL;
-        maxAmmoGrenade = GameParams.AMMO_MAX_GRENADE;
+        maxHealth = GameConfig.HEALTH_MAX;
+        maxArmor = GameConfig.ARMOR_MAX;
+        maxAmmoClip = GameConfig.AMMO_MAX_CLIP;
+        maxAmmoShell = GameConfig.AMMO_MAX_SHELL;
+        maxAmmoGrenade = GameConfig.AMMO_MAX_GRENADE;
+        healthHitMonsterMult = 1.0f;
+        healthHitHeroMult = 1.0f;
     }
 
     private void processGameCode(String codes) {
@@ -181,7 +206,7 @@ public class Game implements EngineObject {
                     state.heroAmmo[Weapons.AMMO_SHELL] = maxAmmoShell;
                     state.heroAmmo[Weapons.AMMO_GRENADE] = maxAmmoGrenade;
                 } else {
-                    Common.showToast(R.string.msg_cheats_disabled);
+                    Common.showToast(engine.activity, R.string.engine_cheats_disabled);
                 }
             } else if ((PGT + "h").equals(code)) {
                 if (!state.cheatsDisabled) {
@@ -189,11 +214,12 @@ public class Game implements EngineObject {
                     state.heroHealth = maxHealth;
                     state.heroArmor = maxArmor;
                 } else {
-                    Common.showToast(R.string.msg_cheats_disabled);
+                    Common.showToast(engine.activity, R.string.engine_cheats_disabled);
                 }
             } else if ((PGT + "k").equals(code)) {
                 // Please Give The Keys
                 state.heroKeysMask = 7;
+                level.requestBuildPathToWave();
             } else if ((P + "lnl").equals(code)) {
                 // Please Load Next Level
                 loadLevel(LOAD_LEVEL_NEXT);
@@ -202,7 +228,7 @@ public class Game implements EngineObject {
                     // Please Give God Mode
                     state.godMode = !state.godMode;
                 } else {
-                    Common.showToast(R.string.msg_cheats_disabled);
+                    Common.showToast(engine.activity, R.string.engine_cheats_disabled);
                 }
             } else if ("iddqd".equals(code) || "iwgm".equals(code) || "gmgm".equals(code)) {
                 state.godMode = false;
@@ -216,6 +242,20 @@ public class Game implements EngineObject {
                 engine.showFps = !engine.showFps;
             } else if ((PD + "rl").equals(code)) {
                 // Please Debug Reload Level
+                loadLevel(LOAD_LEVEL_RELOAD);
+            } else if ((PD + "rli").equals(code)) {
+                // Please Debug Reload Level Initial
+                for (int i = 0; i < Weapons.WEAPON_LAST; i++) {
+                    state.heroHasWeapon[i] = false;
+                }
+
+                for (int i = 0; i < Weapons.AMMO_LAST; i++) {
+                    state.heroAmmo[i] = 0;
+                }
+
+                state.heroHasWeapon[Weapons.WEAPON_KNIFE] = true;
+                state.heroArmor = GameConfig.ARMOR_ADD_GREEN;
+
                 loadLevel(LOAD_LEVEL_RELOAD);
             } else if ((PD + "oa").equals(code)) {
                 // Please Debug On Automap
@@ -230,9 +270,9 @@ public class Game implements EngineObject {
                 if (engine.hasGameSave(Engine.DGB_SAVE_PREFIX + saveName)) {
                     if (state.load(Engine.DGB_SAVE_PREFIX + saveName) == State.LOAD_RESULT_SUCCESS) {
                         engine.updateAfterLevelLoadedOrCreated();
-                        Common.showToast(R.string.msg_dbg_loaded);
+                        Common.showToast(engine.activity, R.string.engine_dbg_loaded);
                     } else {
-                        Common.showToast(R.string.msg_cant_load_state);
+                        Common.showToast(engine.activity, R.string.engine_state_cant_load);
                     }
                 }
             } else if (code.startsWith(PD + "s")) {
@@ -241,7 +281,7 @@ public class Game implements EngineObject {
 
                 if (saveName.matches("^[0-9]+$")) {
                     state.save(Engine.DGB_SAVE_PREFIX + saveName);
-                    Common.showToast(R.string.msg_dbg_saved);
+                    Common.showToast(engine.activity, R.string.engine_dbg_saved);
                 }
             } else if (code.startsWith(P + "m")) {
                 // Please Map ...
@@ -259,7 +299,7 @@ public class Game implements EngineObject {
         }
     }
 
-    void loadLevel(int loadLevelType) {
+    public void loadLevel(int loadLevelType) {
         if (loadLevelType == LOAD_LEVEL_NEXT || loadLevelType == LOAD_LEVEL_JUST_NEXT_NAME) {
             String nextLevelName = profile.getLevel(state.levelName).getNextLevelName();
 
@@ -272,7 +312,7 @@ public class Game implements EngineObject {
         }
 
         if (loadLevelType != LOAD_LEVEL_JUST_NEXT_NAME) {
-            setStartValues();
+            reload();
             state.mustReload = false;
 
             if (state.mustLoadAutosave) {
@@ -281,14 +321,14 @@ public class Game implements EngineObject {
                     engine.updateAfterLevelLoadedOrCreated();
                 } else {
                     level.load(state.levelName);
-                    state.heroWeapon = weapons.getBestWeapon();
+                    weapons.setHeroWeaponImmediate(weapons.getBestWeapon(-1));
                 }
 
                 updatePurchases();
                 renderMode = RENDER_MODE_GAME;
             } else {
                 level.load(state.levelName);
-                state.heroWeapon = weapons.getBestWeapon();
+                weapons.setHeroWeaponImmediate(weapons.getBestWeapon(-1));
                 engine.createAutosave();
             }
         } else {
@@ -309,8 +349,12 @@ public class Game implements EngineObject {
         }
 
         state.mustLoadAutosave = true;
+        state.overallDeaths++;
+
         renderMode = RENDER_MODE_GAME_OVER;
-        App.self.trackerInst.send("GameOver", state.levelName);
+        engine.heroController.reload(); // To properly show / hide "resurrect" button
+
+        App.self.tracker.trackEvent("GameOver", state.levelName);
     }
 
     private void showEndLevelScreen() {
@@ -320,17 +364,11 @@ public class Game implements EngineObject {
             return;
         }
 
-        App.self.trackerInst.send("LevelCompleted", state.levelName);
+        App.self.tracker.trackEvent("LevelCompleted", state.levelName);
 
         loadLevel(LOAD_LEVEL_JUST_NEXT_NAME);
         renderMode = RENDER_MODE_END_LEVEL;
 
-        if (state.pickedItems > state.totalItems) {
-            state.pickedItems = state.totalItems;
-            Common.log("Game.showEndLevelScreen: state.pickedItems > state.totalItems");
-        }
-
-        state.overallItems += state.pickedItems;
         state.overallMonsters += state.killedMonsters;
         state.overallSecrets += state.foundSecrets;
         state.overallSeconds += state.timeInTicks / Engine.FRAMES_PER_SECOND;
@@ -339,11 +377,11 @@ public class Game implements EngineObject {
         profile.exp += state.levelExp;
 
         if (!profile.alreadyCompletedLevels.contains(state.levelName)) {
-            profile.exp += GameParams.EXP_END_LEVEL;
+            profile.exp += GameConfig.EXP_END_LEVEL;
             profile.alreadyCompletedLevels.add(state.levelName);
         }
 
-        profile.update();
+        profile.update(engine.activity);
         state.levelExp = 0;
 
         if (state.totalMonsters != 0 && state.killedMonsters == state.totalMonsters) {
@@ -352,12 +390,6 @@ public class Game implements EngineObject {
             Achievements.resetStat(Achievements.STAT_P100_KILLS_ROW, profile, engine, state);
         }
 
-        if (state.totalItems != 0 && state.pickedItems == state.totalItems) {
-            Achievements.updateStat(Achievements.STAT_P100_ITEMS_ROW, profile, engine, state);
-        } else {
-            Achievements.resetStat(Achievements.STAT_P100_ITEMS_ROW, profile, engine, state);
-        }
-
         if (state.totalSecrets != 0 && state.foundSecrets == state.totalSecrets) {
             Achievements.updateStat(Achievements.STAT_P100_SECRETS_ROW, profile, engine, state);
         } else {
@@ -365,16 +397,15 @@ public class Game implements EngineObject {
         }
 
         if (profile.isUnsavedUpdates) {
-            profile.save();
+            profile.save(engine.activity);
         }
 
         endLevel.init((state.totalMonsters == 0 ? -1 : (state.killedMonsters * 100 / state.totalMonsters)),
-                (state.totalItems == 0 ? -1 : (state.pickedItems * 100 / state.totalItems)),
                 (state.totalSecrets == 0 ? -1 : (state.foundSecrets * 100 / state.totalSecrets)),
                 (state.timeInTicks / Engine.FRAMES_PER_SECOND));
     }
 
-    void nextLevel(@SuppressWarnings("SameParameterValue") boolean isTutorial) {
+    public void nextLevel(@SuppressWarnings("SameParameterValue") boolean isTutorial) {
         skipEndLevelScreenOnce = isTutorial;
         nextLevelTime = engine.elapsedTime;
 
@@ -385,7 +416,7 @@ public class Game implements EngineObject {
         }
     }
 
-    void hitHero(int hits, Monster mon) {
+    public void hitHero(int hits, Monster mon) {
         if (killedTime > 0) {
             return;
         }
@@ -399,9 +430,9 @@ public class Game implements EngineObject {
         if (!state.godMode && nextLevelTime == 0) {
             if (state.heroArmor > 0) {
                 state.heroArmor = Math.max(0,
-                        state.heroArmor - Math.max(1, (int)((double)hits * GameParams.ARMOR_HIT_TAKER)));
+                        state.heroArmor - Math.max(1, (int)((double)hits * GameConfig.ARMOR_HIT_TAKER)));
 
-                state.heroHealth -= Math.max(1, (int)((double)hits * GameParams.ARMOR_HEALTH_SAVER));
+                state.heroHealth -= Math.max(1, (int)((double)hits * GameConfig.ARMOR_HEALTH_SAVER));
             } else {
                 state.heroHealth -= hits;
             }
@@ -440,11 +471,6 @@ public class Game implements EngineObject {
                 if (door.requiredKey == 0) {
                     overlay.showLabel(Labels.LABEL_CANT_OPEN);
                     soundManager.playSound(SoundManager.SOUND_NO_WAY);
-
-                    // if (door.mark != null) {
-                    //     processOneMarkById(100 + door.mark.id);
-                    // }
-
                     return true;
                 }
 
@@ -457,10 +483,6 @@ public class Game implements EngineObject {
                         overlay.showLabel(Labels.LABEL_NEED_BLUE_KEY);
                     }
 
-                    // if (door.mark != null) {
-                    //     processOneMarkById(100 + door.mark.id);
-                    // }
-
                     soundManager.playSound(SoundManager.SOUND_NO_WAY);
                     return true;
                 }
@@ -470,7 +492,7 @@ public class Game implements EngineObject {
 
             if (door.open()) {
                 if ((state.passableMap[door.y][door.x] & Level.PASSABLE_IS_DOOR_OPENED_BY_HERO) == 0) {
-                    state.levelExp += GameParams.EXP_OPEN_DOOR;
+                    state.levelExp += GameConfig.EXP_OPEN_DOOR;
                     Achievements.updateStat(Achievements.STAT_DOORS_OPENED, profile, engine, state);
                 }
 
@@ -486,6 +508,11 @@ public class Game implements EngineObject {
             return false;
         }
 
+        //      ,    (    )
+        if ((state.passableMap[y][x] & Level.PASSABLE_IS_OBJECT) != 0) {
+            return false;
+        }
+
         //noinspection SimplifiableIfStatement
         if (level.marksMap[y][x] != null) {
             return processOneMark(level.marksMap[y][x]);
@@ -519,43 +546,6 @@ public class Game implements EngineObject {
         return false;
     }
 
-    private void processShoot() {
-        // just for case
-        if (weapons.hasNoAmmo(state.heroWeapon)) {
-            weapons.selectBestWeapon();
-        }
-
-        Weapons.WeaponParams localParams = weapons.currentParams;
-
-        //noinspection BooleanVariableAlwaysNegated
-        boolean hitOrShoot = Bullet.shootOrPunch(state,
-                state.heroX,
-                state.heroY,
-                engine.heroAr,
-                null,
-                localParams.ammoIdx,
-                localParams.hits,
-                localParams.hitTimeout);
-
-        if (weapons.currentCycle[weapons.shootCycle] > -1000) {
-            soundManager.playSound((localParams.noHitSoundIdx != 0 && !hitOrShoot)
-                    ? localParams.noHitSoundIdx
-                    : localParams.soundIdx);
-        }
-
-        if (localParams.ammoIdx >= 0) {
-            state.heroAmmo[localParams.ammoIdx] -= localParams.needAmmo;
-
-            if (state.heroAmmo[localParams.ammoIdx] < localParams.needAmmo) {
-                if (state.heroAmmo[localParams.ammoIdx] < 0) {
-                    state.heroAmmo[localParams.ammoIdx] = 0;
-                }
-
-                weapons.selectBestWeapon();
-            }
-        }
-    }
-
     @SuppressWarnings({ "UnusedReturnValue", "MagicNumber" })
     public boolean updateHeroPosition(float dx, float dy, float accel) {
         if (accel < -0.9f) {
@@ -617,24 +607,29 @@ public class Game implements EngineObject {
         return positionUpdated;
     }
 
-    void resume() {
+    public void update() {
         if (isRewardedVideoWatched) {
             isRewardedVideoWatched = false;
             isGameOverFlag = false;
             killedTime = 0L;
 
-            state.heroHealth = GameParams.HEALTH_MAX;
-            state.heroArmor = Math.min(GameParams.ARMOR_MAX, state.heroArmor + GameParams.ARMOR_ADD_GREEN);
+            state.heroHealth = GameConfig.HEALTH_MAX;
+            state.heroArmor = Math.min(GameConfig.ARMOR_MAX, state.heroArmor + GameConfig.ARMOR_ADD_GREEN);
 
             if (state.heroHasWeapon[Weapons.WEAPON_PISTOL] || state.heroHasWeapon[Weapons.WEAPON_DBLPISTOL]) {
-                state.heroAmmo[Weapons.AMMO_CLIP] = Math.min(GameParams.AMMO_MAX_CLIP,
-                        state.heroAmmo[Weapons.AMMO_CLIP] + GameParams.AMMO_ADD_CBOX);
+                state.heroAmmo[Weapons.AMMO_CLIP] = Math.min(GameConfig.AMMO_MAX_CLIP,
+                        state.heroAmmo[Weapons.AMMO_CLIP] + GameConfig.AMMO_ADD_CBOX);
             }
 
-            if (state.heroHasWeapon[Weapons.WEAPON_AK47] || state.heroHasWeapon[Weapons.WEAPON_TMP] || state.heroHasWeapon[Weapons.WEAPON_WINCHESTER]) {
-                state.heroAmmo[Weapons.AMMO_SHELL] = Math.min(GameParams.AMMO_MAX_SHELL,
-                        state.heroAmmo[Weapons.AMMO_SHELL] + GameParams.AMMO_ADD_SBOX);
+            if (state.heroHasWeapon[Weapons.WEAPON_AK47]
+                    || state.heroHasWeapon[Weapons.WEAPON_TMP]
+                    || state.heroHasWeapon[Weapons.WEAPON_WINCHESTER]) {
+
+                state.heroAmmo[Weapons.AMMO_SHELL] = Math.min(GameConfig.AMMO_MAX_SHELL,
+                        state.heroAmmo[Weapons.AMMO_SHELL] + GameConfig.AMMO_ADD_SBOX);
             }
+
+            state.overallResurrects++;
         }
 
         if (engine.gameViewActive && !TextUtils.isEmpty(unprocessedGameCode)) {
@@ -645,21 +640,21 @@ public class Game implements EngineObject {
         if (engine.gameViewActive) {
             state.showEpisodeSelector = false;
         }
-    }
 
-    public void update() {
         if (level.buildPathToWavePending) {
             level.buildPathToWavePending = false;
             level.buildPathToWaveMap();
             autoMap.updatePathTo();
         }
 
-        if (renderMode == RENDER_MODE_END_LEVEL) {
-            endLevel.update();
-            return;
-        } else if (renderMode == RENDER_MODE_GAME_OVER) {
-            gameOver.update();
-            return;
+        switch (renderMode) {
+            case RENDER_MODE_END_LEVEL:
+                endLevel.update();
+                return;
+
+            case RENDER_MODE_GAME_OVER:
+                gameOver.update();
+                return;
         }
 
         state.timeInTicks++;
@@ -675,16 +670,16 @@ public class Game implements EngineObject {
 
         hasMoved = false;
 
-        for (Door door = state.doors.first(); door != null; door = (Door)door.next) {
+        for (Door door = state.doors.first(); door != null; door = door.next) {
             door.tryClose();
         }
 
-        for (Monster mon = state.monsters.first(); mon != null; mon = (Monster)mon.next) {
+        for (Monster mon = state.monsters.first(); mon != null; mon = mon.next) {
             mon.update();
         }
 
         for (Bullet bullet = state.bullets.first(); bullet != null; ) {
-            Bullet nextBullet = (Bullet)bullet.next;
+            Bullet nextBullet = bullet.next;
             bullet.update();
 
             if (bullet.bulletState == Bullet.STATE_RELEASE) {
@@ -696,7 +691,7 @@ public class Game implements EngineObject {
         }
 
         for (Explosion explosion = state.explosions.first(); explosion != null; ) {
-            Explosion nextExplosion = (Explosion)explosion.next;
+            Explosion nextExplosion = explosion.next;
 
             if (!explosion.update()) {
                 state.explosions.release(explosion);
@@ -707,7 +702,7 @@ public class Game implements EngineObject {
         }
 
         for (Timeout timeout = state.timeouts.first(); timeout != null; ) {
-            Timeout nextTimeout = (Timeout)timeout.next;
+            Timeout nextTimeout = timeout.next;
 
             if (timeout.delay <= 0) {
                 level.executeActions(timeout.markId);
@@ -721,7 +716,7 @@ public class Game implements EngineObject {
         }
 
         for (LookPoint lookPoint = state.lookPoints.first(); lookPoint != null; ) {
-            LookPoint nextLookPoint = (LookPoint)lookPoint.next;
+            LookPoint nextLookPoint = lookPoint.next;
 
             if (levelRenderer.awTouchedCellsMap[lookPoint.y][lookPoint.x]) {
                 processOneMarkById(lookPoint.markId);
@@ -732,39 +727,21 @@ public class Game implements EngineObject {
             lookPoint = nextLookPoint;
         }
 
-        if ((nextLevelTime > 0) || (killedTime > 0)) {
-            if (weapons.shootCycle > 0) {
-                weapons.shootCycle = (weapons.shootCycle + 1) % weapons.currentCycle.length;
-            }
-
-            return;
-        }
+        weapons.update(nextLevelTime <= 0 && killedTime <= 0);
 
-        if (weapons.currentCycle[weapons.shootCycle] < 0) {
-            processShoot();
-        }
-
-        if (weapons.shootCycle > 0) {
-            weapons.shootCycle = (weapons.shootCycle + 1) % weapons.currentCycle.length;
-        }
-
-        if (actionNextWeapon && weapons.shootCycle == 0 && weapons.changeWeaponDir == 0) {
-            weapons.nextWeapon();
+        if (actionNextWeapon && weapons.switchToNextWeapon()) {
             actionNextWeapon = false;
         }
 
         for (int i = 0, len = actionQuickWeapons.length; i < len; i++) {
             if (actionQuickWeapons[i]) {
-                if (state.heroWeapon != state.lastWeapons[i]) {
-                    weapons.switchWeapon(state.lastWeapons[i]);
-                }
-
+                weapons.switchWeapon(state.lastWeapons[i]);
                 actionQuickWeapons[i] = false;
             }
         }
 
-        if (actionFire != 0 && weapons.shootCycle == 0 && weapons.changeWeaponDir == 0) {
-            weapons.shootCycle++;
+        if (actionFire != 0) {
+            weapons.fire();
         }
 
         if (actionGameMenu) {
@@ -789,21 +766,21 @@ public class Game implements EngineObject {
             heroCellX = (int)state.heroX;
             heroCellY = (int)state.heroY;
 
-            processMarks();
-            pickObjects();
+            pickObjects(); //  -  
+            processMarks(); //  -   (  PathTo  )
             autoMap.updatePathTo();
         }
     }
 
     private boolean processOneMark(Mark mark) {
-        return (mark.enabled && processOneMarkById(mark.id));
+        return (!mark.unmarked && mark.enabled && processOneMarkById(mark.id));
     }
 
     private boolean processOneMarkById(int markId) {
         int soundIdx = level.executeActions(markId);
 
         if (soundIdx >= 0) {
-            // if this is *not* end level switch, play sound
+            // if this is *not* pop level switch, play sound
             if (nextLevelTime == 0) {
                 soundManager.playSound(soundIdx);
                 overlay.showOverlay(Overlay.MARK);
@@ -831,88 +808,81 @@ public class Game implements EngineObject {
             return;
         }
 
-        if ((state.passableMap[cy][cx] & Level.PASSABLE_IS_OBJECT_DONT_COUNT) == 0) {
-            // count every object (even if user didn't pick it) to allow 100% items at the end of level
-            state.pickedItems++;
-        }
+        ObjectContainer container = state.objectsMap.get(cy).get(cx);
+        boolean soundWasNotPlayed = true;
+
+        for (int i = 0; i < container.count; ) {
+            int tex = container.get(i);
+
+            if (!shouldPickOneObject(tex)) {
+                //noinspection AssignmentToForLoopParameter
+                i++;
+
+                continue;
+            }
+
+            if (soundWasNotPlayed) {
+                soundWasNotPlayed = false;
 
-        state.passableMap[cy][cx] |= Level.PASSABLE_IS_OBJECT_DONT_COUNT;
+                playOneObjectSound(tex);
+                overlay.showOverlay(Overlay.ITEM);
+            }
 
-        // decide shall we pick object or not
+            pickOneObject(tex);
+            container.removeAt(i);
+        }
 
-        switch (state.objectsMap[cy][cx]) {
+        if (container.count == 0) {
+            state.passableMap[cy][cx] &= ~Level.PASSABLE_MASK_OBJECT;
+            levelRenderer.modLightMap(cx, cy, -LevelRenderer.LIGHT_OBJECT);
+        }
+    }
+
+    private boolean shouldPickOneObject(int tex) {
+        switch (tex) {
             case TextureLoader.OBJ_ARMOR_GREEN:
             case TextureLoader.OBJ_ARMOR_RED:
-                if (state.heroArmor >= maxArmor) {
-                    return;
-                }
-                break;
+                return (state.heroArmor < maxArmor);
 
             case TextureLoader.OBJ_STIM:
             case TextureLoader.OBJ_MEDI:
-                if (state.heroHealth >= maxHealth) {
-                    return;
-                }
-                break;
+                return (state.heroHealth < maxHealth);
 
             case TextureLoader.OBJ_CLIP:
             case TextureLoader.OBJ_CBOX:
-                if (state.heroAmmo[Weapons.AMMO_CLIP] >= maxAmmoClip) {
-                    return;
-                }
-                break;
+                return (state.heroAmmo[Weapons.AMMO_CLIP] < maxAmmoClip);
 
             case TextureLoader.OBJ_SHELL:
             case TextureLoader.OBJ_SBOX:
-                if (state.heroAmmo[Weapons.AMMO_SHELL] >= maxAmmoShell) {
-                    return;
-                }
-                break;
+                return (state.heroAmmo[Weapons.AMMO_SHELL] < maxAmmoShell);
 
             case TextureLoader.OBJ_GRENADE:
             case TextureLoader.OBJ_GBOX:
-                if (state.heroAmmo[Weapons.AMMO_GRENADE] >= maxAmmoGrenade) {
-                    return;
-                }
-                break;
+                return (state.heroAmmo[Weapons.AMMO_GRENADE] < maxAmmoGrenade);
 
             case TextureLoader.OBJ_BPACK:
-                if (state.heroHealth >= maxHealth
-                        && state.heroAmmo[Weapons.AMMO_CLIP] >= maxAmmoClip
-                        && state.heroAmmo[Weapons.AMMO_SHELL] >= maxAmmoShell) {
-
-                    return;
-                }
-                break;
+                return (state.heroHealth < maxHealth
+                        || state.heroAmmo[Weapons.AMMO_CLIP] < maxAmmoClip
+                        || state.heroAmmo[Weapons.AMMO_SHELL] < maxAmmoShell);
 
             case TextureLoader.OBJ_DBLPIST:
-                if (shouldNotPickWeapon(Weapons.WEAPON_DBLPISTOL)) {
-                    return;
-                }
-                break;
+                return (shouldPickWeapon(Weapons.WEAPON_DBLPISTOL));
 
             case TextureLoader.OBJ_AK47:
-                if (shouldNotPickWeapon(Weapons.WEAPON_AK47)) {
-                    return;
-                }
-                break;
+                return (shouldPickWeapon(Weapons.WEAPON_AK47));
 
             case TextureLoader.OBJ_TMP:
-                if (shouldNotPickWeapon(Weapons.WEAPON_TMP)) {
-                    return;
-                }
-                break;
+                return (shouldPickWeapon(Weapons.WEAPON_TMP));
 
             case TextureLoader.OBJ_WINCHESTER:
-                if (shouldNotPickWeapon(Weapons.WEAPON_WINCHESTER)) {
-                    return;
-                }
-                break;
+                return (shouldPickWeapon(Weapons.WEAPON_WINCHESTER));
         }
 
-        // play sounds
+        return true;
+    }
 
-        switch (state.objectsMap[cy][cx]) {
+    private void playOneObjectSound(int tex) {
+        switch (tex) {
             case TextureLoader.OBJ_CLIP:
             case TextureLoader.OBJ_CBOX:
             case TextureLoader.OBJ_SHELL:
@@ -934,30 +904,31 @@ public class Game implements EngineObject {
                 soundManager.playSound(SoundManager.SOUND_PICK_ITEM);
                 break;
         }
+    }
 
-        // add healh/armor/wepons/bullets
-
-        int bestWeapon = (state.autoSelectWeapon ? -1 : weapons.getBestWeapon());
-
-        switch (state.objectsMap[cy][cx]) {
+    private void pickOneObject(int tex) {
+        switch (tex) {
             case TextureLoader.OBJ_ARMOR_GREEN:
-                state.heroArmor = Math.min(state.heroArmor + GameParams.ARMOR_ADD_GREEN, maxArmor);
+                state.heroArmor = Math.min(state.heroArmor + GameConfig.ARMOR_ADD_GREEN, maxArmor);
                 break;
 
             case TextureLoader.OBJ_ARMOR_RED:
-                state.heroArmor = Math.min(state.heroArmor + GameParams.ARMOR_ADD_RED, maxArmor);
+                state.heroArmor = Math.min(state.heroArmor + GameConfig.ARMOR_ADD_RED, maxArmor);
                 break;
 
             case TextureLoader.OBJ_KEY_BLUE:
                 state.heroKeysMask |= 1;
+                level.requestBuildPathToWave();
                 break;
 
             case TextureLoader.OBJ_KEY_RED:
                 state.heroKeysMask |= 2;
+                level.requestBuildPathToWave();
                 break;
 
             case TextureLoader.OBJ_KEY_GREEN:
                 state.heroKeysMask |= 4;
+                level.requestBuildPathToWave();
                 break;
 
             case TextureLoader.OBJ_OPENMAP:
@@ -965,208 +936,171 @@ public class Game implements EngineObject {
                 break;
 
             case TextureLoader.OBJ_STIM:
-                state.heroHealth = Math.min(state.heroHealth + GameParams.HEALTH_ADD_STIM, maxHealth);
+                state.heroHealth = Math.min(state.heroHealth + GameConfig.HEALTH_ADD_STIM, maxHealth);
                 break;
 
             case TextureLoader.OBJ_MEDI:
-                state.heroHealth = Math.min(state.heroHealth + GameParams.HEALTH_ADD_MEDI, maxHealth);
+                state.heroHealth = Math.min(state.heroHealth + GameConfig.HEALTH_ADD_MEDI, maxHealth);
                 break;
 
             case TextureLoader.OBJ_CLIP:
-                pickAmmo(Weapons.AMMO_CLIP, GameParams.AMMO_ADD_CLIP, bestWeapon);
+                pickAmmo(Weapons.AMMO_CLIP, GameConfig.AMMO_ADD_CLIP);
                 break;
 
             case TextureLoader.OBJ_CBOX:
-                pickAmmo(Weapons.AMMO_CLIP, GameParams.AMMO_ADD_CBOX, bestWeapon);
+                pickAmmo(Weapons.AMMO_CLIP, GameConfig.AMMO_ADD_CBOX);
                 break;
 
             case TextureLoader.OBJ_SHELL:
-                pickAmmo(Weapons.AMMO_SHELL, GameParams.AMMO_ADD_SHELL, bestWeapon);
+                pickAmmo(Weapons.AMMO_SHELL, GameConfig.AMMO_ADD_SHELL);
                 break;
 
             case TextureLoader.OBJ_SBOX:
-                pickAmmo(Weapons.AMMO_SHELL, GameParams.AMMO_ADD_SBOX, bestWeapon);
+                pickAmmo(Weapons.AMMO_SHELL, GameConfig.AMMO_ADD_SBOX);
                 break;
 
             case TextureLoader.OBJ_GRENADE:
-                pickAmmo(Weapons.AMMO_GRENADE, GameParams.AMMO_ADD_GRENADE, bestWeapon);
+                pickAmmo(Weapons.AMMO_GRENADE, GameConfig.AMMO_ADD_GRENADE);
                 break;
 
             case TextureLoader.OBJ_GBOX:
-                pickAmmo(Weapons.AMMO_GRENADE, GameParams.AMMO_ADD_GBOX, bestWeapon);
+                pickAmmo(Weapons.AMMO_GRENADE, GameConfig.AMMO_ADD_GBOX);
                 break;
 
             case TextureLoader.OBJ_BPACK:
-                state.heroHealth = Math.min(state.heroHealth + GameParams.HEALTH_ADD_STIM, maxHealth);
+                state.heroHealth = Math.min(state.heroHealth + GameConfig.HEALTH_ADD_STIM, maxHealth);
 
-                state.heroAmmo[Weapons.AMMO_CLIP] = Math.min(state.heroAmmo[Weapons.AMMO_CLIP]
-                        + GameParams.AMMO_ADD_CLIP, maxAmmoClip);
+                state.heroAmmo[Weapons.AMMO_CLIP] = Math.min(
+                        state.heroAmmo[Weapons.AMMO_CLIP] + GameConfig.AMMO_ADD_CLIP,
+                        maxAmmoClip);
 
-                state.heroAmmo[Weapons.AMMO_SHELL] = Math.min(state.heroAmmo[Weapons.AMMO_SHELL]
-                        + GameParams.AMMO_ADD_SHELL, maxAmmoShell);
+                state.heroAmmo[Weapons.AMMO_SHELL] = Math.min(
+                        state.heroAmmo[Weapons.AMMO_SHELL] + GameConfig.AMMO_ADD_SHELL,
+                        maxAmmoShell);
 
-                // do not check if AK47 existing (than, if it didn't exists, pistol or double pistol will be selected)
-                // why AK47? because it is the first weapon which use AMMO_SHELL
-                if (bestWeapon < Weapons.WEAPON_AK47) {
-                    weapons.selectBestWeapon();
-                    state.autoSelectWeapon = true;
-                }
+                weapons.selectBestWeapon(-1);
                 break;
 
             case TextureLoader.OBJ_DBLPIST:
-                pickWeapon(Weapons.WEAPON_DBLPISTOL, GameParams.AMMO_ADD_DBLPIST, bestWeapon);
+                pickWeapon(Weapons.WEAPON_DBLPISTOL, GameConfig.AMMO_ADD_DBLPIST);
                 break;
 
             case TextureLoader.OBJ_AK47:
-                pickWeapon(Weapons.WEAPON_AK47, GameParams.AMMO_ADD_AK47, bestWeapon);
+                pickWeapon(Weapons.WEAPON_AK47, GameConfig.AMMO_ADD_AK47);
                 break;
 
             case TextureLoader.OBJ_TMP:
-                pickWeapon(Weapons.WEAPON_TMP, GameParams.AMMO_ADD_TMP, bestWeapon);
+                pickWeapon(Weapons.WEAPON_TMP, GameConfig.AMMO_ADD_TMP);
                 break;
 
             case TextureLoader.OBJ_WINCHESTER:
-                pickWeapon(Weapons.WEAPON_WINCHESTER, GameParams.AMMO_ADD_WINCHESTER, bestWeapon);
+                pickWeapon(Weapons.WEAPON_WINCHESTER, GameConfig.AMMO_ADD_WINCHESTER);
                 break;
         }
 
-        state.levelExp += GameParams.EXP_PICK_OBJECT;
-
-        // remove picked objects from map
-        state.objectsMap[cy][cx] = 0;
-        state.passableMap[cy][cx] &= ~Level.PASSABLE_MASK_OBJECT;
-        levelRenderer.modLightMap(cx, cy, -LevelRenderer.LIGHT_OBJECT);
-
-        overlay.showOverlay(Overlay.ITEM);
+        state.levelExp += GameConfig.EXP_PICK_OBJECT;
     }
 
-    private boolean shouldNotPickWeapon(int weapon) {
+    private boolean shouldPickWeapon(int weapon) {
         int ammoIdx = Weapons.WEAPONS[weapon].ammoIdx;
 
         int maxAmmo = (ammoIdx == Weapons.AMMO_CLIP
                 ? maxAmmoClip
                 : (ammoIdx == Weapons.AMMO_SHELL ? maxAmmoShell : maxAmmoGrenade));
 
-        return (state.heroHasWeapon[weapon] && state.heroAmmo[ammoIdx] >= maxAmmo);
+        return (!state.heroHasWeapon[weapon] || state.heroAmmo[ammoIdx] < maxAmmo);
     }
 
-    private void pickAmmo(int ammoIdx, int ammoAdd, int bestWeapon) {
+    private void pickAmmo(int ammoIdx, int ammoAdd) {
         int maxAmmo = (ammoIdx == Weapons.AMMO_CLIP
                 ? maxAmmoClip
                 : (ammoIdx == Weapons.AMMO_SHELL ? maxAmmoShell : maxAmmoGrenade));
 
-        int weapon = (ammoIdx == Weapons.AMMO_CLIP
-                ? Weapons.WEAPON_PISTOL
-                : (ammoIdx == Weapons.AMMO_SHELL ? Weapons.WEAPON_TMP : Weapons.WEAPON_GRENADE));
-
         if (ammoIdx == Weapons.AMMO_GRENADE) {
             state.heroHasWeapon[Weapons.WEAPON_GRENADE] = true;
         }
 
         state.heroAmmo[ammoIdx] = Math.min(state.heroAmmo[ammoIdx] + ammoAdd, maxAmmo);
-
-        if (state.heroHasWeapon[weapon] && bestWeapon < weapon) {
-            weapons.selectBestWeapon();
-            state.autoSelectWeapon = true;
-        }
+        weapons.selectBestWeapon(ammoIdx);
     }
 
-    private void pickWeapon(int weapon, int ammoAdd, int bestWeapon) {
-        int ammoIdx = Weapons.WEAPONS[weapon].ammoIdx;
+    private void pickWeapon(int weaponIdx, int ammoAdd) {
+        int ammoIdx = Weapons.WEAPONS[weaponIdx].ammoIdx;
 
         int maxAmmo = (ammoIdx == Weapons.AMMO_CLIP
                 ? maxAmmoClip
                 : (ammoIdx == Weapons.AMMO_SHELL ? maxAmmoShell : maxAmmoGrenade));
 
-        state.heroHasWeapon[weapon] = true;
+        state.heroHasWeapon[weaponIdx] = true;
         state.heroAmmo[ammoIdx] = Math.min(state.heroAmmo[ammoIdx] + ammoAdd, maxAmmo);
 
-        if (bestWeapon < weapon) {
-            weapons.selectBestWeapon();
-            state.autoSelectWeapon = true;
+        if (state.heroWeapon < weaponIdx) {
+            weapons.switchWeapon(weaponIdx);
         }
     }
 
     @SuppressWarnings("MagicNumber")
-    private void drawCrosshair(GL10 gl) {
-        renderer.initOrtho(gl, true, false, -engine.ratio, engine.ratio, -1.0f, 1.0f, 0.0f, 1.0f);
-        renderer.init();
+    private void renderCrosshair() {
+        renderer.startBatch();
+        renderer.setColorQuadRGBA(1.0f, 1.0f, 1.0f, 0.5f);
 
-        renderer.setQuadRGBA(1.0f, 1.0f, 1.0f, 0.5f);
+        renderer.setCoordsQuadRectFlat(-CROSSHAIR_SIZE, 0.03f, CROSSHAIR_SIZE, 0.08f); // up
+        renderer.batchQuad();
 
-        renderer.setQuadOrthoCoords(-CROSSHAIR_SIZE, 0.03f, CROSSHAIR_SIZE, 0.08f); // up
-        renderer.drawQuad();
+        renderer.setCoordsQuadRectFlat(CROSSHAIR_SIZE, -0.03f, -CROSSHAIR_SIZE, -0.08f); // down
+        renderer.batchQuad();
 
-        renderer.setQuadOrthoCoords(CROSSHAIR_SIZE, -0.03f, -CROSSHAIR_SIZE, -0.08f); // down
-        renderer.drawQuad();
+        renderer.setCoordsQuadRectFlat(0.03f, -CROSSHAIR_SIZE, 0.08f, CROSSHAIR_SIZE); // right
+        renderer.batchQuad();
 
-        renderer.setQuadOrthoCoords(0.03f, -CROSSHAIR_SIZE, 0.08f, CROSSHAIR_SIZE); // right
-        renderer.drawQuad();
+        renderer.setCoordsQuadRectFlat(-0.03f, CROSSHAIR_SIZE, -0.08f, -CROSSHAIR_SIZE); // left
+        renderer.batchQuad();
 
-        renderer.setQuadOrthoCoords(-0.03f, CROSSHAIR_SIZE, -0.08f, -CROSSHAIR_SIZE); // left
-        renderer.drawQuad();
-
-        gl.glDisable(GL10.GL_DEPTH_TEST);
-        gl.glEnable(GL10.GL_BLEND);
-        gl.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);
-        renderer.flush(gl, false);
-
-        gl.glMatrixMode(GL10.GL_PROJECTION);
-        gl.glPopMatrix();
+        renderer.useOrtho(-engine.ratio, engine.ratio, -1.0f, 1.0f, 0.0f, 1.0f);
+        renderer.renderBatch(Renderer.FLAG_BLEND);
     }
 
     @SuppressWarnings("MagicNumber")
-    private void drawSky(GL10 gl) {
-        gl.glDisable(GL10.GL_DEPTH_TEST);
-        gl.glDisable(GL10.GL_BLEND);
-        gl.glDisable(GL10.GL_ALPHA_TEST);
-        gl.glDisable(GL10.GL_CULL_FACE);
-        gl.glShadeModel(GL10.GL_FLAT);
-
-        renderer.initOrtho(gl, true, false, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f);
+    private void renderSky() {
+        renderer.useOrtho(0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f);
 
-        if (GameParams.COLOR_SKY > 0) {
-            float r = (float)((GameParams.COLOR_SKY >> 16) & 0xff) / 255.0f;
-            float g = (float)((GameParams.COLOR_SKY >> 8) & 0xff) / 255.0f;
-            float b = (float)(GameParams.COLOR_SKY & 0xff) / 255.0f;
+        if (GameConfig.COLOR_SKY > 0) {
+            float r = (float)((GameConfig.COLOR_SKY >> 16) & 0xff) / 255.0f;
+            float g = (float)((GameConfig.COLOR_SKY >> 8) & 0xff) / 255.0f;
+            float b = (float)(GameConfig.COLOR_SKY & 0xff) / 255.0f;
 
-            renderer.init();
-            renderer.setQuadRGBA(r, g, b, 1.0f);
-            renderer.setQuadOrthoCoords(0.0f, 1.0f, 1.0f, 0.0f);
-            renderer.drawQuad();
-            renderer.flush(gl, false);
+            renderer.startBatch();
+            renderer.setColorQuadRGBA(r, g, b, 1.0f);
+            renderer.setCoordsQuadRectFlat(0.0f, 1.0f, 1.0f, 0.0f);
+            renderer.batchQuad();
+            renderer.renderBatch(0);
         }
 
         float ox = (float)Math.sin((state.heroA % 30.0f) * GameMath.G2RAD_F);
         float oy = (float)Math.sin(state.heroVertA * GameMath.G2RAD_F);
 
-        renderer.init();
-        renderer.setQuadRGBA(1.0f, 1.0f, 1.0f, 1.0f);
-        renderer.setQuadTexCoords(0, 0, 4 << 16, 1 << 16);
-        renderer.setQuadOrthoCoords(ox - 1.0f, 1.1f - oy, ox + 1.0f, 0.15f - oy);
-        renderer.drawQuad();
-        renderer.bindTextureRep(gl, engine.textureLoader.textures[TextureLoader.TEXTURE_SKY]);
-        renderer.flush(gl);
-
-        if (GameParams.COLOR_SKY > 0) {
-            float r = (float)((GameParams.COLOR_SKY >> 16) & 0xff) / 255.0f;
-            float g = (float)((GameParams.COLOR_SKY >> 8) & 0xff) / 255.0f;
-            float b = (float)(GameParams.COLOR_SKY & 0xff) / 255.0f;
-
-            renderer.init();
-            renderer.setQuadRGBA(r, g, b, 1.0f);
-            renderer.setQuadOrthoCoords(ox - 1.0f, 1.09f - oy, ox + 1.0f, 1.11f - oy);
-            renderer.drawQuad();
-            renderer.flush(gl, false);
-        }
-
-        gl.glMatrixMode(GL10.GL_PROJECTION);
-        gl.glPopMatrix();
-        gl.glEnable(GL10.GL_CULL_FACE);
+        renderer.startBatch();
+        renderer.setColorQuadRGBA(1.0f, 1.0f, 1.0f, 1.0f);
+        renderer.setTexRect(0, 0, 4 << 16, 1 << 16);
+        renderer.setCoordsQuadRectFlat(ox - 1.0f, 1.1f - oy, ox + 1.0f, 0.15f - oy);
+        renderer.batchQuad();
+        renderer.renderBatch(Renderer.FLAG_TEX_REPEAT, Renderer.TEXTURE_SKY);
+
+        if (GameConfig.COLOR_SKY > 0) {
+            float r = (float)((GameConfig.COLOR_SKY >> 16) & 0xff) / 255.0f;
+            float g = (float)((GameConfig.COLOR_SKY >> 8) & 0xff) / 255.0f;
+            float b = (float)(GameConfig.COLOR_SKY & 0xff) / 255.0f;
+
+            renderer.startBatch();
+            renderer.setColorQuadRGBA(r, g, b, 1.0f);
+            renderer.setCoordsQuadRectFlat(ox - 1.0f, 1.09f - oy, ox + 1.0f, 1.11f - oy);
+            renderer.batchQuad();
+            renderer.renderBatch(0);
+        }
     }
 
     @SuppressWarnings("MagicNumber")
-    protected void render(GL10 gl) {
+    protected void render() {
         long walkTime = 0;
 
         if (hasMoved) {
@@ -1179,62 +1113,62 @@ public class Game implements EngineObject {
             prevMovedTime = 0;
         }
 
-        float yoff = LevelRenderer.HALF_WALL / 8.0f
+        float offY = LevelRenderer.HALF_WALL / 8.0f
                 + (float)Math.sin((float)walkTime / 100.0f) * LevelRenderer.HALF_WALL / 16.0f;
 
-        float xrot = state.heroVertA;
+        float rotX = state.heroVertA;
 
         if (killedTime > 0) {
             float killedRatio = Math.min(1.0f, (float)(engine.elapsedTime - killedTime) / 1000.0f);
 
-            yoff += killedRatio * (LevelRenderer.HALF_WALL * 0.5f - yoff);
-            xrot += killedRatio * (-45.0f - xrot);
+            offY += killedRatio * (LevelRenderer.HALF_WALL * 0.5f - offY);
+            rotX += killedRatio * (-45.0f - rotX);
             state.setHeroA(killedHeroAngle + (killedAngle - killedHeroAngle) * killedRatio);
         }
 
-        drawSky(gl);
-        levelRenderer.render(gl, engine.elapsedTime, -yoff, -90.0f - xrot);
+        renderSky();
+        levelRenderer.render(engine.elapsedTime, -offY, -90.0f - rotX);
 
         if (config.showCrosshair && !engine.inWallpaperMode) {
-            drawCrosshair(gl);
+            renderCrosshair();
         }
 
-        weapons.render(gl, walkTime);
-        autoMap.render(gl);
-
-        overlay.renderOverlay(gl);
-        overlay.renderHitSide(gl);
+        weapons.render(walkTime);
+        autoMap.render();
+        overlay.renderOverlay();
 
         if (!engine.inWallpaperMode) {
-            engine.stats.render(gl);
+            overlay.renderHitSide();
+            engine.stats.render();
 
             if (renderMode == RENDER_MODE_GAME) {
-                heroController.renderControls(gl,
-                        true,
+                heroController.render(true,
                         (firstTouchTime >= 0 ? firstTouchTime : engine.elapsedTime));
             }
         }
 
         if (nextLevelTime > 0) {
-            overlay.renderEndLevelLayer(gl, (float)(engine.elapsedTime - nextLevelTime) / 500.0f);
+            overlay.renderEndLevelLayer((float)(engine.elapsedTime - nextLevelTime) / 500.0f);
         }
 
         if (renderMode == RENDER_MODE_END_LEVEL) {
-            endLevel.render(gl);
-            heroController.renderControls(gl, false, 0L);
+            endLevel.render();
+            heroController.render(false, 0L);
         } else if (renderMode == RENDER_MODE_GAME_OVER) {
-            gameOver.render(gl);
-            heroController.renderControls(gl, false, 0L);
+            gameOver.render();
+            heroController.render(false, 0L);
         }
 
-        overlay.renderLabels(gl);
+        if (!engine.inWallpaperMode) {
+            overlay.renderLabels();
+        }
 
         if (config.gamma > 0.01f) {
-            overlay.renderGammaLayer(gl);
+            overlay.renderGammaLayer();
         }
 
         if (engine.showFps) {
-            engine.drawFps(gl);
+            engine.renderFps();
         }
 
         if (renderMode == RENDER_MODE_GAME) {
diff --git a/src/main/java/zame/game/engine/GameMath.java b/src/main/java/zame/game/engine/GameMath.java
deleted file mode 100644
index e2f3d76..0000000
--- a/src/main/java/zame/game/engine/GameMath.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package zame.game.engine;
-
-public final class GameMath {
-    public static final float PI_F = (float)Math.PI;
-    static final float PI_M2F = (float)(Math.PI * 2.0);
-    static final float PI_D2F = (float)(Math.PI / 2.0);
-    public static final float G2RAD_F = (float)(Math.PI / 180.0);
-    static final float RAD2G_F = (float)(180.0 / Math.PI);
-    static final float EPSILON = 0.000000001f;
-    static final float LITTLE = 0.0001f;
-    static final float ONE_MINUS_LITTLE = 1.0f - LITTLE;
-
-    private GameMath() {}
-
-    static float getAngle(float dx, float dy) {
-        float l = (float)Math.sqrt(dx * dx + dy * dy);
-        float a = (float)Math.acos(dx / (l < EPSILON ? EPSILON : l));
-
-        return (dy < 0 ? a : (PI_M2F - a));
-    }
-
-    static float getAngle(float dx, float dy, float l) {
-        float a = (float)Math.acos(dx / (l < EPSILON ? EPSILON : l));
-        return (dy < 0 ? a : (PI_M2F - a));
-    }
-}
diff --git a/src/main/java/zame/game/engine/GameOver.java b/src/main/java/zame/game/engine/GameOver.java
deleted file mode 100644
index 2d5f09f..0000000
--- a/src/main/java/zame/game/engine/GameOver.java
+++ /dev/null
@@ -1,51 +0,0 @@
-package zame.game.engine;
-
-import javax.microedition.khronos.opengles.GL10;
-import zame.game.App;
-import zame.game.managers.SoundManager;
-
-public class GameOver implements EngineObject {
-    private Engine engine;
-    private Renderer renderer;
-    private Labels labels;
-    private SoundManager soundManager;
-    private Game game;
-
-    @Override
-    public void setEngine(Engine engine) {
-        this.engine = engine;
-        this.renderer = engine.renderer;
-        this.labels = engine.labels;
-        this.soundManager = engine.soundManager;
-        this.game = engine.game;
-    }
-
-    public void update() {
-        if (game.actionUpgradeButton) {
-            App.self.trackerInst.send("Upgrade.GameOver", engine.state.levelName);
-            soundManager.playSound(SoundManager.SOUND_BTN_PRESS);
-            soundManager.setPlaylist(SoundManager.LIST_MAIN);
-            engine.state.mustLoadAutosave = false;
-            engine.changeView(Engine.VIEW_TYPE_REWARDED_VIDEO);
-        }
-
-        if (game.actionFire != 0) {
-            soundManager.playSound(SoundManager.SOUND_BTN_PRESS);
-            soundManager.setPlaylist(SoundManager.LIST_MAIN);
-            game.loadLevel(Game.LOAD_LEVEL_NORMAL);
-        }
-    }
-
-    @SuppressWarnings("MagicNumber")
-    public void render(GL10 gl) {
-        labels.beginDrawing(gl);
-        renderer.setQuadRGBA(1.0f, 1.0f, 1.0f, 1.0f);
-
-        float sx = -engine.ratio + 0.1f;
-        float ex = engine.ratio - 0.1f;
-
-        labels.draw(gl, sx, 0.1f, ex, 0.5f, labels.map[Labels.LABEL_GAMEOVER], 0.25f, Labels.ALIGN_CC);
-        labels.draw(gl, sx, -0.25f, ex, 0.1f, labels.map[Labels.LABEL_GAMEOVER_LOAD_AUTOSAVE], 0.25f, Labels.ALIGN_CC);
-        labels.endDrawing(gl);
-    }
-}
diff --git a/src/main/java/zame/game/engine/GameParams.java b/src/main/java/zame/game/engine/GameParams.java
deleted file mode 100644
index 3826e01..0000000
--- a/src/main/java/zame/game/engine/GameParams.java
+++ /dev/null
@@ -1,69 +0,0 @@
-package zame.game.engine;
-
-@SuppressWarnings("PointlessArithmeticExpression")
-final class GameParams {
-    static final int COLOR_SKY = 0x45a7f2;
-
-    static final int MAX_MONSTER_TYPES = 5;
-
-    static final int HEALTH_MAX = 100;
-    static final int HEALTH_ADD_STIM = 10;
-    static final int HEALTH_ADD_MEDI = 50;
-
-    static final int HEALTH_BARREL = 25;
-
-    static final int HEALTH_HIT_KNIFE = 1; // 2 hits per second -> 2 dmg per second
-    static final int HEALTH_HIT_PISTOL = 2; // 2 hits per second -> 4 dmg per second
-    static final int HEALTH_HIT_DBLPISTOL = 2; // 4 hits per second -> 8 dmg per second
-    static final int HEALTH_HIT_AK47 = 6; // 2 hits per second -> 12 dmg per second
-    static final int HEALTH_HIT_TMP = 5; // 4 hits per second -> 20 dmg per second
-    static final int HEALTH_HIT_WINCHESTER = 32; // 1 hit per second -> 32 dmg per second
-    static final int HEALTH_HIT_GRENADE = 52; // 1 hit per second -> 52 dmg per second
-    static final int HEALTH_HIT_BARREL = 40; //      ,       
-
-    static final double ARMOR_HEALTH_SAVER = 0.25; // if hero has armor, than it take only (hits * saver) damage
-    static final double ARMOR_HIT_TAKER = 0.75; // if hero has armor, than it loose (hits * taker) armor
-
-    // 1 frame = 1s / Engine.FRAMES_PER_SECOND = 1s / 40 = 0.025s
-    // 1s = 40 frames
-
-    static final int STUN_KNIFE = 5; // 2 hits per second -> 5 * 2 / 40 -> 0.25 stn per second
-    static final int STUN_PISTOL = 5; // 2 hits per second -> 5 * 2 / 40 -> 0.25 stn per second
-    static final int STUN_DBLPISTOL = 5; // 4 hits per second -> 5 * 4 / 40 -> 0.5 stn per second
-    static final int STUN_AK47 = 5; // 2 hits per second -> 5 * 2 / 40 -> 0.25 stn per second
-    static final int STUN_TMP = 5; // 4 hits per second -> 5 * 4 / 40 -> 0.5 stn per second
-    static final int STUN_WINCHESTER = 10; // 1 hit per second -> 10 / 40 -> 0.25 stn per second
-    static final int STUN_GRENADE = 30; // 1 hit per second -> 25 / 40 -> 0.75 stn per second
-
-    static final int ARMOR_MAX = 200;
-    static final int ARMOR_ADD_GREEN = 100;
-    static final int ARMOR_ADD_RED = 200;
-
-    static final int AMMO_MAX_CLIP = 150;
-    static final int AMMO_MAX_SHELL = 75;
-    static final int AMMO_MAX_GRENADE = 50;
-
-    static final int AMMO_ENSURED_CLIP = 50;
-    static final int AMMO_ENSURED_SHELL = 25;
-    static final int AMMO_ENSURED_GRENADE = 5;
-
-    static final int AMMO_ADD_CLIP = 5;
-    static final int AMMO_ADD_CBOX = 20;
-    static final int AMMO_ADD_SHELL = 5;
-    static final int AMMO_ADD_SBOX = 15;
-    static final int AMMO_ADD_GRENADE = 1;
-    static final int AMMO_ADD_GBOX = 5;
-
-    static final int AMMO_ADD_DBLPIST = 20;
-    static final int AMMO_ADD_AK47 = 30;
-    static final int AMMO_ADD_TMP = 3;
-    static final int AMMO_ADD_WINCHESTER = 6;
-
-    static final int EXP_OPEN_DOOR = 1 * 5;
-    static final int EXP_PICK_OBJECT = 5 * 5;
-    static final int EXP_KILL_MONSTER = 25 * 5;
-    static final int EXP_SECRET_FOUND = 50 * 5;
-    static final int EXP_END_LEVEL = 100 * 5;
-
-    private GameParams() {}
-}
diff --git a/src/main/java/zame/game/engine/HeroControllerHuman.java b/src/main/java/zame/game/engine/HeroControllerHuman.java
deleted file mode 100644
index 9a7d8a8..0000000
--- a/src/main/java/zame/game/engine/HeroControllerHuman.java
+++ /dev/null
@@ -1,77 +0,0 @@
-package zame.game.engine;
-
-import android.view.MotionEvent;
-import javax.microedition.khronos.opengles.GL10;
-import zame.game.engine.controls.AccelerometerController;
-import zame.game.engine.controls.Controls;
-import zame.game.engine.controls.KeysController;
-
-public class HeroControllerHuman extends HeroController {
-	private Engine engine;
-	private Controls controls = new Controls();
-	private AccelerometerController accelerometerController = new AccelerometerController();
-	private KeysController keysController = new KeysController();
-
-	@Override
-	public void setEngine(Engine engine) {
-		this.engine = engine;
-
-		controls.setEngine(engine);
-		accelerometerController.setEngine(engine);
-		keysController.setEngine(engine);
-	}
-
-	@Override
-	public void onDrawFrame() {
-		keysController.onDrawFrame();
-	}
-
-	@Override
-	public void updateHero() {
-		controls.updateHero();
-		accelerometerController.updateHero();
-		keysController.updateHero();
-	}
-
-	@Override
-	public void reload() {
-		controls.reload();
-		accelerometerController.reload();
-		keysController.reload();
-	}
-
-	@Override
-	public void surfaceSizeChanged() {
-		controls.surfaceSizeChanged();
-	}
-
-	@Override
-	public void renderControls(GL10 gl, boolean canRenderHelp, long firstTouchTime) {
-		controls.render(gl, canRenderHelp, engine.elapsedTime, firstTouchTime);
-	}
-
-	@Override
-	public boolean onKeyUp(int keyCode) {
-		return keysController.onKeyUp(keyCode);
-	}
-
-	@Override
-	public boolean onKeyDown(int keyCode) {
-		return keysController.onKeyDown(keyCode);
-	}
-
-	@Override
-	public void onTouchEvent(MotionEvent event) {
-		controls.touchEvent(event);
-	}
-
-	@Override
-	public void onTrackballEvent(MotionEvent event) {
-		keysController.onTrackballEvent(event);
-	}
-
-	@Override
-	public void setAccelerometerValues(float accelerometerX, float accelerometerY) {
-		accelerometerController.setAccelerometerValues(accelerometerX, accelerometerY);
-	}
-}
diff --git a/src/main/java/zame/game/engine/Labels.java b/src/main/java/zame/game/engine/Labels.java
deleted file mode 100644
index 4c692a6..0000000
--- a/src/main/java/zame/game/engine/Labels.java
+++ /dev/null
@@ -1,422 +0,0 @@
-package zame.game.engine;
-
-import android.graphics.Bitmap;
-import android.graphics.Canvas;
-import android.graphics.Paint;
-import android.graphics.Rect;
-import android.graphics.Typeface;
-import android.opengl.GLUtils;
-import java.util.HashMap;
-import javax.microedition.khronos.opengles.GL10;
-import zame.game.Common;
-import zame.game.App;
-import zame.game.R;
-import zame.game.store.Achievements;
-
-public class Labels implements EngineObject {
-	private static final int TEX_WIDTH = 1024;
-	private static final int TEX_HEIGHT = 1024;
-	private static final int TEX_WIDTH_LOW = 512;
-	private static final int TEX_HEIGHT_LOW = 512;
-
-	@SuppressWarnings("WeakerAccess") public static final int ALIGN_BL = 0; // bottom left
-	public static final int ALIGN_CC = 1; // center center
-	public static final int ALIGN_CL = 2; // center left
-	public static final int ALIGN_CR = 3; // center left
-
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_FPS = 0;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_CANT_OPEN = 1;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_NEED_BLUE_KEY = 2;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_NEED_RED_KEY = 3;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_NEED_GREEN_KEY = 4;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_SECRET_FOUND = 5;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_ENDL_KILLS = 6;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_ENDL_ITEMS = 7;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_ENDL_SECRETS = 8;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_ENDL_TIME = 9;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_GAMEOVER = 10;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_GAMEOVER_LOAD_AUTOSAVE = 11;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_ACHIEVEMENT_UNLOCKED = 12;
-
-	public static final int LABEL_HELP_MOVE = 13;
-	public static final int LABEL_HELP_ROTATE = 14;
-	public static final int LABEL_HELP_FIRE = 15;
-	public static final int LABEL_HELP_WEAPONS = 16;
-	public static final int LABEL_HELP_QUICK_WEAPONS = 17;
-	public static final int LABEL_HELP_MINIMAP = 18;
-	public static final int LABEL_HELP_STATS_HEALTH = 19;
-	public static final int LABEL_HELP_STATS_AMMO = 20;
-	public static final int LABEL_HELP_STATS_ARMOR = 21;
-	public static final int LABEL_HELP_STATS_KEYS = 22;
-	public static final int LABEL_HELP_DO_NOT_ROTATE = 23;
-
-    @SuppressWarnings("WeakerAccess") public static final int LABEL_MESSAGE_USE_MOVE_PAD_TO_FOLLOW_ARROWS = 24;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_MESSAGE_DOING_WELL = 25;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_MESSAGE_SLIDE_TO_ROTATE_TO_LEFT = 26;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_MESSAGE_THAN_ROTATE_TO_RIGHT = 27;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_MESSAGE_MOVE_AND_ROTATE_TO_FOLLOW_ARROWS = 28;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_MESSAGE_FINE = 29;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_MESSAGE_USE_MINIMAP_TO_RETURN_TO_START = 30;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_MESSAGE_WELL_DONE = 31;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_MESSAGE_TO_OPEN_DOOR_GO_THROUGH_IT = 32;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_MESSAGE_NEXT_DOOR_IS_CLOSED_USE_SWITCH = 33;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_MESSAGE_TO_ACTIVATE_SWITCH_GO_UP_TO_HIM = 34;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_MESSAGE_THIS_IS_WINDOW = 35;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_MESSAGE_TO_OPEN_DOOR_PICKUP_KEY = 36;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_MESSAGE_USE_FIRE_AND_KILL_ENEMY = 37;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_MESSAGE_PICKUP_MEDI = 38;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_MESSAGE_OPEN_WEAPON_MENU_AND_SELECT_PISTOL = 39;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_MESSAGE_3 = 40;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_MESSAGE_2 = 41;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_MESSAGE_1 = 42;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_MESSAGE_PICKUP_AMMO = 43;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_MESSAGE_QUICK_CHANGE_WEAPON = 44;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_MESSAGE_AFTER_QUICK_CHANGE_WEAPON = 45;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_MESSAGE_PICKUP_ARMOR = 46;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_MESSAGE_AFTER_PICKUP_ARMOR = 47;
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_MESSAGE_PRESS_END_LEVEL = 48;
-
-	@SuppressWarnings("WeakerAccess") public static final int LABEL_LAST = 49;
-
-	public String[] map = new String[LABEL_LAST];
-
-	private Engine engine;
-	private Renderer renderer;
-	private TextureLoader textureLoader;
-	private Paint paint;
-	private HashMap<Character, Rect> charMap = new HashMap<>();
-	@SuppressWarnings("MagicNumber") private Rect[] numberMap = new Rect[11];
-	private int lastTexX;
-	private int lastTexY;
-	private int textAscent;
-	private int textHeight;
-	private int spaceWidth;
-
-	@Override
-	public void setEngine(Engine engine) {
-		this.engine = engine;
-		this.renderer = engine.renderer;
-		this.textureLoader = engine.textureLoader;
-	}
-
-	@SuppressWarnings("MagicNumber")
-	public void init() {
-		Typeface typeface = Common.loadIngameTypeface();
-
-		if (typeface == null) {
-			typeface = Typeface.DEFAULT;
-		}
-
-		paint = new Paint();
-		paint.setTypeface(typeface);
-		paint.setAntiAlias(true);
-		paint.setARGB(0xFF, 0xFF, 0xFF, 0xFF);
-		paint.setTextSize(64);
-	}
-
-	void createLabels(GL10 gl) {
-		Bitmap bitmap = Common.createBitmap(TEX_WIDTH, TEX_HEIGHT, TEX_WIDTH_LOW, TEX_HEIGHT_LOW, "Can't alloc bitmap for labels");
-		Canvas canvas = new Canvas(bitmap);
-		canvas.setDensity(Bitmap.DENSITY_NONE);
-
-		App context = App.self;
-		charMap.clear();
-		lastTexX = 0;
-		lastTexY = 0;
-
-		textAscent = (int)Math.ceil(-paint.ascent()); // Paint.ascent is negative, so negate it
-		textHeight = textAscent + (int)Math.ceil(paint.descent());
-		spaceWidth = (int)Math.ceil(paint.measureText(" "));
-
-		appendChars(canvas, "0123456789-");
-
-		map[LABEL_FPS] = appendChars(canvas, context.getString(R.string.lbl_fps));
-		map[LABEL_CANT_OPEN] = appendChars(canvas, context.getString(R.string.lbl_cant_open_door));
-		map[LABEL_NEED_BLUE_KEY] = appendChars(canvas, context.getString(R.string.lbl_need_blue_key));
-		map[LABEL_NEED_RED_KEY] = appendChars(canvas, context.getString(R.string.lbl_need_red_key));
-		map[LABEL_NEED_GREEN_KEY] = appendChars(canvas, context.getString(R.string.lbl_need_green_key));
-		map[LABEL_SECRET_FOUND] = appendChars(canvas, context.getString(R.string.lbl_secret_found));
-		map[LABEL_ENDL_KILLS] = appendChars(canvas, context.getString(R.string.lbl_endl_kills));
-		map[LABEL_ENDL_ITEMS] = appendChars(canvas, context.getString(R.string.lbl_endl_items));
-		map[LABEL_ENDL_SECRETS] = appendChars(canvas, context.getString(R.string.lbl_endl_secrets));
-		map[LABEL_ENDL_TIME] = appendChars(canvas, context.getString(R.string.lbl_endl_time));
-		map[LABEL_GAMEOVER] = appendChars(canvas, context.getString(R.string.lbl_gameover));
-		map[LABEL_GAMEOVER_LOAD_AUTOSAVE] = appendChars(canvas, context.getString(R.string.lbl_gameover_load_autosave));
-		map[LABEL_ACHIEVEMENT_UNLOCKED] = appendChars(canvas, context.getString(R.string.ac_unlocked));
-
-        map[LABEL_HELP_MOVE] = appendChars(canvas, context.getString(R.string.lblh_move));
-        map[LABEL_HELP_ROTATE] = appendChars(canvas, context.getString(R.string.lblh_rotate));
-        map[LABEL_HELP_FIRE] = appendChars(canvas, context.getString(R.string.lblh_fire));
-        map[LABEL_HELP_WEAPONS] = appendChars(canvas, context.getString(R.string.lblh_weapons));
-        map[LABEL_HELP_QUICK_WEAPONS] = appendChars(canvas, context.getString(R.string.lblh_quick_weapons));
-        map[LABEL_HELP_MINIMAP] = appendChars(canvas, context.getString(R.string.lblh_minimap));
-        map[LABEL_HELP_STATS_HEALTH] = appendChars(canvas, context.getString(R.string.lblh_stats_health));
-        map[LABEL_HELP_STATS_AMMO] = appendChars(canvas, context.getString(R.string.lblh_stats_ammo));
-        map[LABEL_HELP_STATS_ARMOR] = appendChars(canvas, context.getString(R.string.lblh_stats_armor));
-        map[LABEL_HELP_STATS_KEYS] = appendChars(canvas, context.getString(R.string.lblh_stats_keys));
-        map[LABEL_HELP_DO_NOT_ROTATE] = appendChars(canvas, context.getString(R.string.lblh_do_not_rotate));
-
-        map[LABEL_MESSAGE_USE_MOVE_PAD_TO_FOLLOW_ARROWS] = appendChars(canvas, context.getString(R.string.lblm_use_move_pad_to_follow_arrows));
-        map[LABEL_MESSAGE_DOING_WELL] = appendChars(canvas, context.getString(R.string.lblm_doing_well));
-        map[LABEL_MESSAGE_SLIDE_TO_ROTATE_TO_LEFT] = appendChars(canvas, context.getString(R.string.lblm_slide_to_rotate_to_left));
-        map[LABEL_MESSAGE_THAN_ROTATE_TO_RIGHT] = appendChars(canvas, context.getString(R.string.lblm_than_rotate_to_right));
-        map[LABEL_MESSAGE_MOVE_AND_ROTATE_TO_FOLLOW_ARROWS] = appendChars(canvas, context.getString(R.string.lblm_move_and_rotate_to_follow_arrows));
-        map[LABEL_MESSAGE_FINE] = appendChars(canvas, context.getString(R.string.lblm_fine));
-        map[LABEL_MESSAGE_USE_MINIMAP_TO_RETURN_TO_START] = appendChars(canvas, context.getString(R.string.lblm_use_minimap_to_return_to_start));
-        map[LABEL_MESSAGE_WELL_DONE] = appendChars(canvas, context.getString(R.string.lblm_well_done));
-        map[LABEL_MESSAGE_TO_OPEN_DOOR_GO_THROUGH_IT] = appendChars(canvas, context.getString(R.string.lblm_to_open_door_go_through_it));
-        map[LABEL_MESSAGE_NEXT_DOOR_IS_CLOSED_USE_SWITCH] = appendChars(canvas, context.getString(R.string.lblm_next_door_is_closed_use_switch));
-        map[LABEL_MESSAGE_TO_ACTIVATE_SWITCH_GO_UP_TO_HIM] = appendChars(canvas, context.getString(R.string.lblm_to_activate_switch_go_up_to_him));
-        map[LABEL_MESSAGE_THIS_IS_WINDOW] = appendChars(canvas, context.getString(R.string.lblm_this_is_window));
-        map[LABEL_MESSAGE_TO_OPEN_DOOR_PICKUP_KEY] = appendChars(canvas, context.getString(R.string.lblm_to_open_door_pickup_key));
-        map[LABEL_MESSAGE_USE_FIRE_AND_KILL_ENEMY] = appendChars(canvas, context.getString(R.string.lblm_use_fire_and_kill_enemy));
-        map[LABEL_MESSAGE_PICKUP_MEDI] = appendChars(canvas, context.getString(R.string.lblm_pickup_medi));
-        map[LABEL_MESSAGE_OPEN_WEAPON_MENU_AND_SELECT_PISTOL] = appendChars(canvas, context.getString(R.string.lblm_open_weapon_menu_and_select_pistol));
-        map[LABEL_MESSAGE_3] = appendChars(canvas, context.getString(R.string.lblm_3));
-        map[LABEL_MESSAGE_2] = appendChars(canvas, context.getString(R.string.lblm_2));
-        map[LABEL_MESSAGE_1] = appendChars(canvas, context.getString(R.string.lblm_1));
-        map[LABEL_MESSAGE_PICKUP_AMMO] = appendChars(canvas, context.getString(R.string.lblm_pickup_ammo));
-        map[LABEL_MESSAGE_QUICK_CHANGE_WEAPON] = appendChars(canvas, context.getString(R.string.lblm_quick_change_weapon));
-        map[LABEL_MESSAGE_AFTER_QUICK_CHANGE_WEAPON] = appendChars(canvas, context.getString(R.string.lblm_after_quick_change_weapon));
-        map[LABEL_MESSAGE_PICKUP_ARMOR] = appendChars(canvas, context.getString(R.string.lblm_pickup_armor));
-        map[LABEL_MESSAGE_AFTER_PICKUP_ARMOR] = appendChars(canvas, context.getString(R.string.lblm_after_pickup_armor));
-        map[LABEL_MESSAGE_PRESS_END_LEVEL] = appendChars(canvas, context.getString(R.string.lblm_press_end_level));
-
-		for (int i = 0, len = Achievements.LIST.length; i < len; i++) {
-			appendChars(canvas, Achievements.cleanupTitle(context.getString(Achievements.LIST[i].titleResourceId)));
-		}
-
-		gl.glBindTexture(GL10.GL_TEXTURE_2D, textureLoader.textures[TextureLoader.TEXTURE_LABELS]);
-		GLUtils.texImage2D(GL10.GL_TEXTURE_2D, 0, bitmap, 0);
-
-		//noinspection UnusedAssignment
-		canvas = null;
-
-		bitmap.recycle();
-
-		//noinspection UnusedAssignment
-		bitmap = null;
-
-		System.gc();
-	}
-
-	private String appendChars(Canvas canvas, String str) {
-		for (int i = 0, len = str.length(); i < len; i++) {
-			char ch = str.charAt(i);
-
-			if (ch != ' ' && !charMap.containsKey(ch)) {
-				String chStr = String.valueOf(ch);
-				int textWidth = (int)Math.ceil(paint.measureText(chStr));
-
-				if ((lastTexX + textWidth + 1) >= TEX_WIDTH) {
-					if ((lastTexY + textHeight + 1) >= TEX_HEIGHT) {
-						Common.log("Labels.appendChars: no free texture space");
-						continue;
-					}
-
-					lastTexX = 0;
-					lastTexY += (textHeight + 2);
-				}
-
-				Rect rect = new Rect(lastTexX + 1, lastTexY + 1, lastTexX + textWidth + 1, lastTexY + textHeight + 1);
-				canvas.drawText(chStr, (float)(lastTexX + 1), (float)(lastTexY + textAscent + 1), paint);
-				lastTexX += textWidth + 2;
-
-				charMap.put(ch, rect);
-
-				if (ch == '-') {
-					numberMap[10] = rect;
-				} else if (ch >= '0' && ch <= '9') {
-					numberMap[Character.digit(ch, 10)] = rect;
-				}
-			}
-		}
-
-		return str;
-	}
-
-	private float drawCharacter(Rect rect, float xpos, float ypos, float scale) {
-		if (rect == null) {
-			return (float)spaceWidth * scale;
-		}
-
-		//noinspection MagicNumber
-		renderer.setQuadTexCoords(
-			(rect.left << 16) / TEX_WIDTH,
-			(rect.bottom << 16) / TEX_HEIGHT,
-			(rect.right << 16) / TEX_WIDTH,
-			(rect.top << 16) / TEX_HEIGHT
-		);
-
-		renderer.setQuadOrthoCoords(
-			xpos,
-			ypos,
-			xpos + (float)(rect.width() - 1) * scale,
-			ypos + (float)(textHeight - 1) * scale
-		);
-
-		renderer.drawQuad();
-		return (float)rect.width() * scale;
-	}
-
-	void beginDrawing(GL10 gl) {
-		beginDrawing(gl, false);
-	}
-
-	public void beginDrawing(GL10 gl, boolean customGlConfig) {
-		if (!customGlConfig) {
-			renderer.initOrtho(gl, true, true, -engine.ratio, engine.ratio, -1.0f, 1.0f, 0.0f, 1.0f);
-			gl.glShadeModel(GL10.GL_FLAT);
-			gl.glEnable(GL10.GL_BLEND);
-			gl.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);
-			gl.glDisable(GL10.GL_DEPTH_TEST);
-		}
-
-		renderer.init();
-	}
-
-	@SuppressWarnings("MagicNumber")
-	public void draw(
-		@SuppressWarnings("unused") GL10 gl,
-		float sx, float sy, float ex, float ey,
-		String str, float desiredHeight, int align
-	) {
-		float scale = desiredHeight / (float)textHeight;
-		float width = (float)getWidth(str);
-
-		if ((width * scale) > (ex - sx)) {
-			scale = (ex - sx) / width;
-		}
-
-		if (align == ALIGN_CC || align == ALIGN_CL || align == ALIGN_CR) {
-			sy += (ey - sy - (float)textHeight * scale) * 0.5f;
-		}
-
-		if (align == ALIGN_CC) {
-			sx += (ex - sx - width * scale) * 0.5f;
-		} else if (align == ALIGN_CR) {
-			sx = ex - width * scale;
-		}
-
-		for (int i = 0, len = str.length(); i < len; i++) {
-			char ch = str.charAt(i);
-			sx += drawCharacter((ch == ' ' ? null : charMap.get(ch)), sx, sy, scale);
-		}
-	}
-
-	@SuppressWarnings("MagicNumber")
-	public void draw(
-		@SuppressWarnings("unused") GL10 gl,
-		float sx, float sy, float ex, float ey,
-		int value, float desiredHeight, int align
-	) {
-		float scale = desiredHeight / (float)textHeight;
-		float width = (float)getWidth(value);
-
-		if ((width * scale) > (ex - sx)) {
-			scale = (ex - sx) / width;
-		}
-
-		if (align == ALIGN_CC || align == ALIGN_CL || align == ALIGN_CR) {
-			sy += (ey - sy - (float)textHeight * scale) * 0.5f;
-		}
-
-		if (align == ALIGN_CC) {
-			sx += (ex - sx - width * scale) * 0.5f;
-		} else if (align == ALIGN_CR) {
-			sx = ex - width * scale;
-		}
-
-		if (value == 0) {
-			drawCharacter(numberMap[0], sx, sy, scale);
-			return;
-		}
-
-		if (value < 0) {
-			sx += drawCharacter(numberMap[10], sx, sy, scale);
-			value = -value;
-		}
-
-		int divider = 1;
-		int tmpValue = value / 10;
-
-		while (tmpValue > 0) {
-			divider *= 10;
-			tmpValue /= 10;
-		}
-
-		while (divider > 0) {
-			sx += drawCharacter(numberMap[(value / divider) % 10], sx, sy, scale);
-			divider /= 10;
-		}
-	}
-
-	void endDrawing(GL10 gl) {
-		endDrawing(gl, false);
-	}
-
-	public void endDrawing(GL10 gl, boolean customGlConfig) {
-		renderer.bindTextureBlur(gl, textureLoader.textures[TextureLoader.TEXTURE_LABELS]);
-		renderer.flush(gl);
-
-		if (!customGlConfig) {
-			gl.glMatrixMode(GL10.GL_MODELVIEW);
-			gl.glPopMatrix();
-
-			gl.glMatrixMode(GL10.GL_PROJECTION);
-			gl.glPopMatrix();
-		}
-	}
-
-	public float getScaledWidth(String str, @SuppressWarnings("SameParameterValue") float desiredHeight) {
-		float scale = desiredHeight / (float)textHeight;
-		float width = (float)getWidth(str);
-
-		return width * scale;
-	}
-
-	private int getWidth(String str) {
-		int result = 0;
-
-		for (int i = 0, len = str.length(); i < len; i++) {
-			char ch = str.charAt(i);
-
-			if (ch == ' ') {
-				result += spaceWidth;
-			} else {
-				Rect rect = charMap.get(ch);
-				result += (rect == null ? spaceWidth : rect.width());
-			}
-		}
-
-		return result;
-	}
-
-	@SuppressWarnings("unused")
-	public float getScaledWidth(int value, float desiredHeight) {
-		float scale = desiredHeight / (float)textHeight;
-		float width = (float)getWidth(value);
-
-		return width * scale;
-	}
-
-	private int getWidth(int value) {
-		if (value == 0) {
-			return numberMap[0].width();
-		}
-
-		int result = 0;
-
-		if (value < 0) {
-			result += numberMap[10].width();
-			value = -value;
-		}
-
-		while (value > 0) {
-			result += numberMap[value % 10].width();
-			value /= 10;
-		}
-
-		return result;
-	}
-}
diff --git a/src/main/java/zame/game/engine/LevelRenderer.java b/src/main/java/zame/game/engine/LevelRenderer.java
deleted file mode 100644
index c730ba3..0000000
--- a/src/main/java/zame/game/engine/LevelRenderer.java
+++ /dev/null
@@ -1,1634 +0,0 @@
-package zame.game.engine;
-
-import javax.microedition.khronos.opengles.GL10;
-import zame.game.engine.data.DataList;
-
-public class LevelRenderer implements EngineObject {
-    private static final int MAX_LIGHT_TAB = 1000;
-    private static final int LAST_LIGHT_TAB = MAX_LIGHT_TAB - 1;
-    private static final float LIGHT_TAB_MULT = MAX_LIGHT_TAB / 10.0f;
-
-    public static final int AUTO_WALL_TYPE_WALL = 0;
-    public static final int AUTO_WALL_TYPE_TRANSP = 1;
-    public static final int AUTO_WALL_TYPE_DOOR = 2;
-
-    public static final int AUTO_WALL_MASK_HORIZONTAL = 1;
-    public static final int AUTO_WALL_MASK_VERTICAL = 2;
-    public static final int AUTO_WALL_MASK_DOOR = 4;
-
-    static final int MAX_AUTO_WALLS = Level.MAX_WIDTH * Level.MAX_HEIGHT * 2;
-    static final int MAX_AW_CELLS = Level.MAX_WIDTH * Level.MAX_HEIGHT;
-    static final float HALF_WALL = 0.4f;
-    static final float LIGHT_OBJECT = 1.0f;
-
-    private static final float HALF_WALL_PLUS_EXTRUDE = HALF_WALL + 0.05f;
-    private static final float HALF_DOOR_WIDTH = 0.025f;
-    private static final float LIGHT_DOOR = 0.5f;
-    private static final float LIGHT_LAMP = 1.0f;
-    private static final float LIGHT_ARROW = 1.0f;
-    private static final float MONSTER_SIZE_MULT = 0.75f;
-    private static final float EXTRUDE_LIGHT_MULT = 0.5f;
-
-    public PortalTracer tracer = new PortalTracer();
-
-    public boolean debugOnAutomap;
-    public boolean[][] awTouchedCellsMap = new boolean[Level.MAX_HEIGHT][Level.MAX_WIDTH];
-    public DataList<TraceInfo> tracesInfo = new DataList<>(TraceInfo.class, Level.MAX_BULLETS * 3);
-
-    private Engine engine;
-    private State state;
-    private Renderer renderer;
-    private Level level;
-    private TextureLoader textureLoader;
-    private float flatObjDx;
-    private float flatObjDy;
-    private float[] lightTab = new float[MAX_LIGHT_TAB];
-    public float currentHeroX;
-    public float currentHeroY;
-    public float currentHeroA;
-    private float currentHeroCs;
-    private float currentHeroSn;
-    private float[][] lightMap = new float[Level.MAX_HEIGHT * 2 + 1][Level.MAX_WIDTH * 2 + 1];
-
-    LevelRenderer() {
-        final float ambient = 0.5f;
-        final float heroLightness = 0.2f;
-
-        for (int i = 0; i < MAX_LIGHT_TAB; i++) {
-            lightTab[i] = (float)Math.sin(((float)i / (float)MAX_LIGHT_TAB) * GameMath.PI_F + GameMath.PI_D2F)
-                    * heroLightness + ambient;
-        }
-    }
-
-    @Override
-    public void setEngine(Engine engine) {
-        this.engine = engine;
-        this.state = engine.state;
-        this.renderer = engine.renderer;
-        this.level = engine.level;
-        this.textureLoader = engine.textureLoader;
-
-        tracer.setEngine(engine);
-    }
-
-    void updateAfterLoadOrCreate() {
-        for (AutoWall aw = state.autoWalls.first(); aw != null; aw = (AutoWall)aw.next) {
-            if (aw.doorUid >= 0) {
-                for (Door door = state.doors.first(); door != null; door = (Door)door.next) {
-                    if (door.uid == aw.doorUid) {
-                        aw.door = door;
-                        break;
-                    }
-                }
-
-                if (aw.door == null) {
-                    aw.doorUid = -1;
-                }
-            }
-        }
-
-        for (Bullet bullet = state.bullets.first(); bullet != null; bullet = (Bullet)bullet.next) {
-            if (bullet.monUid >= 0) {
-                for (Monster mon = state.monsters.first(); mon != null; mon = (Monster)mon.next) {
-                    if (mon.uid == bullet.monUid) {
-                        bullet.mon = mon;
-                        break;
-                    }
-                }
-            }
-        }
-
-        for (Explosion explosion = state.explosions.first(); explosion != null; explosion = (Explosion)explosion.next) {
-            if (explosion.monUid >= 0) {
-                for (Monster mon = state.monsters.first(); mon != null; mon = (Monster)mon.next) {
-                    if (mon.uid == explosion.monUid) {
-                        explosion.mon = mon;
-                        break;
-                    }
-                }
-            }
-        }
-
-        for (int i = 0, levelHeight = state.levelHeight; i < levelHeight; i++) {
-            for (int j = 0, levelWidth = state.levelWidth; j < levelWidth; j++) {
-                awTouchedCellsMap[i][j] = false;
-            }
-        }
-
-        for (TouchedCell tc = state.awTouchedCells.first(); tc != null; tc = (TouchedCell)tc.next) {
-            awTouchedCellsMap[tc.y][tc.x] = true;
-        }
-
-        for (int ly = 0, maxLy = state.levelHeight * 2 + 1; ly < maxLy; ly++) {
-            for (int lx = 0, maxLx = state.levelWidth * 2 + 1; lx < maxLx; lx++) {
-                lightMap[ly][lx] = 0.0f;
-            }
-        }
-
-        for (int y = 0, levelHeight = state.levelHeight; y < levelHeight; y++) {
-            for (int x = 0, levelWidth = state.levelWidth; x < levelWidth; x++) {
-                modLightMap(x, y, getLightMapValue(x, y));
-            }
-        }
-    }
-
-    float getLightMapValue(int x, int y) {
-        float value = 0.0f;
-        int pass = state.passableMap[y][x];
-
-        if (level.doorsMap[y][x] != null) {
-            value += LIGHT_DOOR;
-        } else if ((pass & Level.PASSABLE_IS_OBJECT) != 0) {
-            value += LIGHT_OBJECT;
-        } else if ((pass & Level.PASSABLE_IS_DECOR_LAMP) != 0) {
-            int tex = state.texMap[y][x];
-
-            for (int i = 0, len = TextureLoader.DLAMP_LIGHTS.length; i < len; i++) {
-                if (TextureLoader.DLAMP_LIGHTS[i] == tex) {
-                    value += LIGHT_LAMP;
-                    break;
-                }
-            }
-        } else if ((pass & Level.PASSABLE_IS_WALL) != 0) {
-            int tex = state.wallsMap[y][x];
-
-            for (int i = 0, len = TextureLoader.WALL_LIGHTS.length; i < len; i++) {
-                if (TextureLoader.WALL_LIGHTS[i] == tex) {
-                    value += LIGHT_LAMP;
-                    break;
-                }
-            }
-        } else if ((pass & Level.PASSABLE_IS_DECOR_ITEM) != 0) {
-            int tex = state.texMap[y][x];
-
-            for (int i = 0, len = TextureLoader.DITEM_LIGHTS.length; i < len; i++) {
-                if (TextureLoader.DITEM_LIGHTS[i] == tex) {
-                    value += LIGHT_LAMP;
-                    break;
-                }
-            }
-        }
-
-        int ceil1 = state.ceilMap1[y][x];
-        int ceil2 = state.ceilMap2[y][x];
-        int ceil3 = state.ceilMap3[y][x];
-        int ceil4 = state.ceilMap4[y][x];
-
-        for (int i = 0, len = TextureLoader.CEIL_LIGHTS.length; i < len; i++) {
-            int cl = TextureLoader.CEIL_LIGHTS[i];
-
-            if (ceil1 == cl || ceil2 == cl || ceil3 == cl || ceil4 == cl) {
-                value += LIGHT_LAMP;
-                break;
-            }
-        }
-
-        if (state.arrowsMap[y][x] != 0) {
-            value += LIGHT_ARROW;
-        }
-
-        return value;
-    }
-
-    void modLightMap(int cx, int cy, float val) {
-        int lx = cx * 2;
-        int ly = cy * 2;
-
-        lightMap[ly][lx] += val;
-        lightMap[ly][lx + 1] += val;
-        lightMap[ly][lx + 2] += val;
-
-        ly++;
-        lightMap[ly][lx] += val;
-        lightMap[ly][lx + 1] += val;
-        lightMap[ly][lx + 2] += val;
-
-        ly++;
-        lightMap[ly][lx] += val;
-        lightMap[ly][lx + 1] += val;
-        lightMap[ly][lx + 2] += val;
-    }
-
-    @SuppressWarnings("MagicNumber")
-    private void updateDoors(long elapsedTime) {
-        for (Door door = state.doors.first(); door != null; door = (Door)door.next) {
-            if (door.dir != 0) {
-                if (door.dir > 0) {
-                    door.openPos = (float)(elapsedTime - door.lastTime) / 300.0f;
-                } else {
-                    door.openPos = Door.OPEN_POS_MAX - (float)(elapsedTime - door.lastTime) / 200.0f;
-                }
-
-                door.update(elapsedTime);
-            }
-        }
-    }
-
-    @SuppressWarnings("MagicNumber")
-    private float getLightness(float x, float y) {
-        int d = (int)(((x - currentHeroX) * currentHeroCs - (y - currentHeroY) * currentHeroSn - 0.5f)
-                * LIGHT_TAB_MULT);
-
-        try {
-            return lightTab[d < 0 ? 0 : (d > LAST_LIGHT_TAB ? LAST_LIGHT_TAB : d)] + lightMap[(int)((y + 0.25f)
-                    * 2.0f)][(int)((x + 0.25f) * 2.0f)];
-        } catch (ArrayIndexOutOfBoundsException ex) {
-            return 0.0f;
-        }
-    }
-
-    private void setObjLighting(float x, float y) {
-        float l = getLightness(x, y);
-
-        renderer.r1 = l;
-        renderer.g1 = l;
-        renderer.b1 = l;
-        renderer.r2 = l;
-        renderer.g2 = l;
-        renderer.b2 = l;
-        renderer.r3 = l;
-        renderer.g3 = l;
-        renderer.b3 = l;
-        renderer.r4 = l;
-        renderer.g4 = l;
-        renderer.b4 = l;
-    }
-
-    @SuppressWarnings("MagicNumber")
-    private void setWallLighting(float fromX, float fromY, float toX, float toY, boolean vert) {
-        int ang = ((int)currentHeroA + (vert ? 0 : 270)) % 360;
-
-        if (ang > 90) {
-            if (ang < 180) {
-                ang = 180 - ang;
-            } else if (ang < 270) {
-                ang = ang - 180;
-            } else {
-                ang = 360 - ang;
-            }
-        }
-
-        float l = 1.0f - 0.5f * (float)ang / 90.0f;
-
-        float l1 = getLightness(fromX, fromY) * l;
-        renderer.r1 = l1;
-        renderer.g1 = l1;
-        renderer.b1 = l1;
-        renderer.r2 = l1;
-        renderer.g2 = l1;
-        renderer.b2 = l1;
-
-        float l2 = getLightness(toX, toY) * l;
-        renderer.r3 = l2;
-        renderer.g3 = l2;
-        renderer.b3 = l2;
-        renderer.r4 = l2;
-        renderer.g4 = l2;
-        renderer.b4 = l2;
-    }
-
-    // This method:
-    // did *not* check for available space (MAX_AUTO_WALLS),
-    // did *not* check if wall already exists,
-    // did *not* append wall mask,
-    // did *not* add doors
-    public void appendAutoWall(int fromX, int fromY, int toX, int toY, int type) {
-        AutoWall foundAw = null;
-        boolean vert = (fromX == toX);
-
-        for (AutoWall aw = state.autoWalls.first(); aw != null; aw = (AutoWall)aw.next) {
-            if ((aw.door != null) || (aw.vert != vert) || (aw.type != type)) {
-                continue;
-            }
-
-            if ((int)aw.fromX == fromX && (int)aw.fromY == fromY) {
-                aw.fromX = (float)toX;
-                aw.fromY = (float)toY;
-                foundAw = aw;
-                break;
-            } else if ((int)aw.toX == fromX && (int)aw.toY == fromY) {
-                aw.toX = (float)toX;
-                aw.toY = (float)toY;
-                foundAw = aw;
-                break;
-            } else if ((int)aw.fromX == toX && (int)aw.fromY == toY) {
-                aw.fromX = (float)fromX;
-                aw.fromY = (float)fromY;
-                foundAw = aw;
-                break;
-            } else if ((int)aw.toX == toX && (int)aw.toY == toY) {
-                aw.toX = (float)fromX;
-                aw.toY = (float)fromY;
-                foundAw = aw;
-                break;
-            }
-        }
-
-        if (foundAw == null) {
-            AutoWall aw = state.autoWalls.take();
-
-            aw.fromX = (float)fromX;
-            aw.fromY = (float)fromY;
-            aw.toX = (float)toX;
-            aw.toY = (float)toY;
-            aw.vert = vert;
-            aw.type = type;
-            aw.doorUid = -1;
-            aw.door = null;
-
-            return;
-        }
-
-        for (; ; ) {
-            AutoWall nextFoundAw = null;
-
-            for (AutoWall aw = state.autoWalls.first(); aw != null; aw = (AutoWall)aw.next) {
-                if ((aw == foundAw) || (aw.door != null) || (aw.vert != foundAw.vert) || (aw.type != foundAw.type)) {
-                    continue;
-                }
-
-                if ((int)aw.fromX == (int)foundAw.fromX && (int)aw.fromY == (int)foundAw.fromY) {
-                    aw.fromX = foundAw.toX;
-                    aw.fromY = foundAw.toY;
-                    nextFoundAw = aw;
-                    break;
-                } else if ((int)aw.toX == (int)foundAw.fromX && (int)aw.toY == (int)foundAw.fromY) {
-                    aw.toX = foundAw.toX;
-                    aw.toY = foundAw.toY;
-                    nextFoundAw = aw;
-                    break;
-                } else if ((int)aw.fromX == (int)foundAw.toX && (int)aw.fromY == (int)foundAw.toY) {
-                    aw.fromX = foundAw.fromX;
-                    aw.fromY = foundAw.fromY;
-                    nextFoundAw = aw;
-                    break;
-                } else if ((int)aw.toX == (int)foundAw.toX && (int)aw.toY == (int)foundAw.toY) {
-                    aw.toX = foundAw.fromX;
-                    aw.toY = foundAw.fromY;
-                    nextFoundAw = aw;
-                    break;
-                }
-            }
-
-            if (nextFoundAw == null) {
-                break;
-            }
-
-            state.autoWalls.release(foundAw);
-            foundAw = nextFoundAw;
-        }
-    }
-
-    private void renderLevel() {
-        renderer.z1 = -HALF_WALL;
-        renderer.z2 = HALF_WALL;
-        renderer.z3 = HALF_WALL;
-        renderer.z4 = -HALF_WALL;
-
-        PortalTracer.Wall[] localWalls = tracer.walls;
-        Door[][] localDoorsMap = level.doorsMap;
-        int[][] localDrawedAutoWalls = state.drawnAutoWalls;
-
-        for (int i = 0, len = tracer.wallsCount; i < len; i++) {
-            int autoWallMask;
-            Door door;
-            PortalTracer.Wall wall = localWalls[i];
-
-            if (wall.fromX == wall.toX) {
-                door = (wall.fromY < wall.toY
-                        ? localDoorsMap[wall.fromY][wall.fromX - 1]
-                        : localDoorsMap[wall.toY][wall.fromX]);
-
-                autoWallMask = AUTO_WALL_MASK_VERTICAL;
-            } else {
-                door = (wall.fromX < wall.toX
-                        ? localDoorsMap[wall.fromY][wall.fromX]
-                        : localDoorsMap[wall.fromY - 1][wall.toX]);
-
-                autoWallMask = AUTO_WALL_MASK_HORIZONTAL;
-            }
-
-            // by the way, mx and my *not* always equal to wall.cellX and wall.cellY
-            int mx = (wall.fromX < wall.toX ? wall.fromX : wall.toX);
-            int my = (wall.fromY < wall.toY ? wall.fromY : wall.toY);
-
-            if (((localDrawedAutoWalls[my][mx] & autoWallMask) == 0) && state.autoWalls.canTake()) {
-                localDrawedAutoWalls[my][mx] |= autoWallMask;
-                appendAutoWall(wall.fromX, wall.fromY, wall.toX, wall.toY, AUTO_WALL_TYPE_WALL);
-            }
-
-            renderer.x1 = (float)wall.fromX;
-            renderer.y1 = -(float)wall.fromY;
-            renderer.x2 = (float)wall.fromX;
-            renderer.y2 = -(float)wall.fromY;
-            renderer.x3 = (float)wall.toX;
-            renderer.y3 = -(float)wall.toY;
-            renderer.x4 = (float)wall.toX;
-            renderer.y4 = -(float)wall.toY;
-
-            setWallLighting((float)wall.fromX,
-                    (float)wall.fromY,
-                    (float)wall.toX,
-                    (float)wall.toY,
-                    (wall.fromX == wall.toX));
-
-            if (door != null) {
-                renderer.drawQuad(door.texture + TextureLoader.BASE_DOORS_S);
-            } else if (wall.flipTexture) {
-                renderer.drawQuadFlipLR(wall.texture);
-            } else {
-                renderer.drawQuad(wall.texture);
-            }
-        }
-
-        TouchedCell[] localTouchedCells = tracer.touchedCells;
-
-        for (int i = 0, len = tracer.touchedCellsCountPriorToPostProcess; i < len; i++) {
-            TouchedCell tc = localTouchedCells[i];
-
-            if (!awTouchedCellsMap[tc.y][tc.x] && state.awTouchedCells.canTake()) {
-                awTouchedCellsMap[tc.y][tc.x] = true;
-                state.awTouchedCells.take().copyFrom(tc);
-            }
-        }
-    }
-
-    @SuppressWarnings("MagicNumber")
-    private void renderDoors() {
-        TouchedCell[] localTouchedCells = tracer.touchedCells;
-        Door[][] localDoorsMap = level.doorsMap;
-        int[][] localDrawnAutoWalls = state.drawnAutoWalls;
-
-        for (int i = 0, len = tracer.touchedCellsCount; i < len; i++) {
-            TouchedCell tc = localTouchedCells[i];
-            Door door = localDoorsMap[tc.y][tc.x];
-
-            if (door == null) {
-                continue;
-            }
-
-            float fromX;
-            float fromY;
-            float toX;
-            float toY;
-
-            float fromX1;
-            float fromY1;
-            float toX1;
-            float toY1;
-
-            float fromX2;
-            float fromY2;
-            float toX2;
-            float toY2;
-
-            if (door.vert) {
-                fromX = (float)door.x + 0.5f;
-                toX = fromX;
-                fromY = (float)door.y;
-                toY = fromY + 1.0f;
-            } else {
-                fromX = (float)door.x;
-                toX = fromX + 1.0f;
-                fromY = (float)door.y + 0.5f;
-                toY = fromY;
-            }
-
-            if (((localDrawnAutoWalls[door.y][door.x] & AUTO_WALL_MASK_DOOR) == 0) && state.autoWalls.canTake()) {
-                localDrawnAutoWalls[door.y][door.x] |= AUTO_WALL_MASK_DOOR;
-                AutoWall aw = state.autoWalls.take();
-
-                aw.fromX = fromX;
-                aw.fromY = fromY;
-                aw.toX = toX;
-                aw.toY = toY;
-                aw.vert = door.vert;
-                aw.type = AUTO_WALL_TYPE_DOOR;
-                aw.doorUid = door.uid;
-                aw.door = door;
-            }
-
-            if (door.vert) {
-                fromY += door.openPos;
-                toY += door.openPos;
-
-                fromX1 = fromX - HALF_DOOR_WIDTH;
-                toX1 = fromX1;
-                fromY1 = -fromY;
-                toY1 = -toY;
-
-                fromX2 = fromX + HALF_DOOR_WIDTH;
-                toX2 = fromX2;
-                fromY2 = -fromY;
-                toY2 = -toY;
-            } else {
-                fromX += door.openPos;
-                toX += door.openPos;
-
-                fromX1 = fromX;
-                toX1 = toX;
-                fromY1 = -(fromY - HALF_DOOR_WIDTH);
-                toY1 = fromY1;
-
-                fromX2 = fromX;
-                toX2 = toX;
-                fromY2 = -(fromY + HALF_DOOR_WIDTH);
-                toY2 = fromY2;
-            }
-
-            setWallLighting(fromX, fromY, toX, toY, door.vert);
-
-            renderer.x1 = fromX1;
-            renderer.y1 = fromY1;
-            renderer.x2 = fromX1;
-            renderer.y2 = fromY1;
-            renderer.x3 = toX1;
-            renderer.y3 = toY1;
-            renderer.x4 = toX1;
-            renderer.y4 = toY1;
-            renderer.drawQuad(door.texture + TextureLoader.BASE_DOORS_F);
-
-            renderer.x1 = fromX2;
-            renderer.y1 = fromY2;
-            renderer.x2 = fromX2;
-            renderer.y2 = fromY2;
-            renderer.x3 = toX2;
-            renderer.y3 = toY2;
-            renderer.x4 = toX2;
-            renderer.y4 = toY2;
-            renderer.drawQuad(door.texture + TextureLoader.BASE_DOORS_F);
-
-            setWallLighting(fromX1, -fromY1, fromX2, -fromY2, !door.vert);
-
-            renderer.r1 *= EXTRUDE_LIGHT_MULT;
-            renderer.g1 *= EXTRUDE_LIGHT_MULT;
-            renderer.b1 *= EXTRUDE_LIGHT_MULT;
-            renderer.r2 *= EXTRUDE_LIGHT_MULT;
-            renderer.g2 *= EXTRUDE_LIGHT_MULT;
-            renderer.b2 *= EXTRUDE_LIGHT_MULT;
-            renderer.r3 *= EXTRUDE_LIGHT_MULT;
-            renderer.g3 *= EXTRUDE_LIGHT_MULT;
-            renderer.b3 *= EXTRUDE_LIGHT_MULT;
-            renderer.r4 *= EXTRUDE_LIGHT_MULT;
-            renderer.g4 *= EXTRUDE_LIGHT_MULT;
-            renderer.b4 *= EXTRUDE_LIGHT_MULT;
-
-            renderer.x1 = fromX1;
-            renderer.y1 = fromY1;
-            renderer.x2 = fromX1;
-            renderer.y2 = fromY1;
-            renderer.x3 = fromX2;
-            renderer.y3 = fromY2;
-            renderer.x4 = fromX2;
-            renderer.y4 = fromY2;
-            renderer.drawQuadExtruded(door.texture + TextureLoader.BASE_DOORS_S);
-        }
-
-        renderer.z1 = -HALF_WALL;
-        renderer.z2 = HALF_WALL;
-        renderer.z3 = HALF_WALL;
-        renderer.z4 = -HALF_WALL;
-    }
-
-    // render objects, decorations and transparents
-    @SuppressWarnings("MagicNumber")
-    private void renderObjects() {
-        TouchedCell[] localTouchedCells = tracer.touchedCells;
-        int[][] localPassableMap = state.passableMap;
-        int[][] localTexMap = state.texMap;
-        int[][] localDrawnAutoWalls = state.drawnAutoWalls;
-
-        for (int i = 0, len = tracer.touchedCellsCount; i < len; i++) {
-            TouchedCell tc = localTouchedCells[i];
-            int pass = localPassableMap[tc.y][tc.x];
-            int tex = localTexMap[tc.y][tc.x];
-
-            if ((pass & Level.PASSABLE_MASK_OBJ_OR_DECOR) != 0) {
-                float mx = (float)tc.x + 0.5f;
-                float my = (float)tc.y + 0.5f;
-
-                float fromX = mx + flatObjDy;
-                float toX = mx - flatObjDy;
-                float fromY = my - flatObjDx;
-                float toY = my + flatObjDx;
-
-                renderer.x1 = fromX;
-                renderer.y1 = -fromY;
-                renderer.x2 = fromX;
-                renderer.y2 = -fromY;
-                renderer.x3 = toX;
-                renderer.y3 = -toY;
-                renderer.x4 = toX;
-                renderer.y4 = -toY;
-
-                setObjLighting(mx, my);
-
-                if ((pass & Level.PASSABLE_IS_OBJECT) != 0) {
-                    renderer.drawQuad(state.objectsMap[tc.y][tc.x]);
-                }
-
-                if ((pass & Level.PASSABLE_MASK_DECORATION) != 0) {
-                    renderer.drawQuad(tex);
-                }
-            }
-
-            if ((pass & Level.PASSABLE_IS_TRANSP_WINDOW) != 0) {
-                float fromX;
-                float fromY;
-                float toX;
-                float toY;
-
-                boolean vert = ((pass & Level.PASSABLE_IS_TRANSP_WINDOW_VERT) != 0);
-
-                if (vert) {
-                    fromX = (float)tc.x + 0.5f;
-                    toX = fromX;
-                    fromY = (float)tc.y;
-                    toY = fromY + 1.0f;
-                } else {
-                    fromX = (float)tc.x;
-                    toX = fromX + 1.0f;
-                    fromY = (float)tc.y + 0.5f;
-                    toY = fromY;
-                }
-
-                if (((localDrawnAutoWalls[tc.y][tc.x] & AUTO_WALL_MASK_DOOR) == 0) && state.autoWalls.canTake()) {
-                    localDrawnAutoWalls[tc.y][tc.x] |= AUTO_WALL_MASK_DOOR;
-                    AutoWall aw = state.autoWalls.take();
-
-                    aw.fromX = fromX;
-                    aw.fromY = fromY;
-                    aw.toX = toX;
-                    aw.toY = toY;
-                    aw.vert = vert;
-                    aw.type = AUTO_WALL_TYPE_TRANSP;
-                    aw.doorUid = -1;
-                    aw.door = null;
-                }
-
-                renderer.x1 = fromX;
-                renderer.y1 = -fromY;
-                renderer.x2 = fromX;
-                renderer.y2 = -fromY;
-                renderer.x3 = toX;
-                renderer.y3 = -toY;
-                renderer.x4 = toX;
-                renderer.y4 = -toY;
-
-                setWallLighting(fromX, fromY, toX, toY, vert);
-                renderer.drawQuad(tex);
-            } else if (((pass & Level.PASSABLE_IS_TRANSP) != 0) && ((pass & Level.PASSABLE_IS_NOTRANS) == 0) && (tex
-                    != 0)) {
-
-                for (int s = 0; s < 4; s++) {
-                    if ((localPassableMap[tc.y + PortalTracer.Y_CELL_ADD[s]][tc.x + PortalTracer.X_CELL_ADD[s]]
-                            & Level.PASSABLE_MASK_WALL_N_TRANSP) == 0) {
-
-                        int fromX = tc.x + PortalTracer.X_ADD[s];
-                        int fromY = tc.y + PortalTracer.Y_ADD[s];
-                        int toX = tc.x + PortalTracer.X_ADD[(s + 1) % 4];
-                        int toY = tc.y + PortalTracer.Y_ADD[(s + 1) % 4];
-
-                        renderer.x1 = (float)fromX;
-                        renderer.y1 = -(float)fromY;
-                        renderer.x2 = (float)fromX;
-                        renderer.y2 = -(float)fromY;
-                        renderer.x3 = (float)toX;
-                        renderer.y3 = -(float)toY;
-                        renderer.x4 = (float)toX;
-                        renderer.y4 = -(float)toY;
-
-                        int mx = (fromX < toX ? fromX : toX);
-                        int my = (fromY < toY ? fromY : toY);
-                        int autoWallMask = ((s == 1 || s == 3) ? AUTO_WALL_MASK_VERTICAL : AUTO_WALL_MASK_HORIZONTAL);
-
-                        if (((localDrawnAutoWalls[my][mx] & autoWallMask) == 0) && state.autoWalls.canTake()) {
-                            localDrawnAutoWalls[my][mx] |= autoWallMask;
-                            appendAutoWall(fromX, fromY, toX, toY, AUTO_WALL_TYPE_TRANSP);
-                        }
-
-                        setWallLighting((float)fromX, (float)fromY, (float)toX, (float)toY, (s == 1 || s == 3));
-
-                        if (s == 0 || s == 3) {
-                            renderer.drawQuadFlipLR(tex);
-                        } else {
-                            renderer.drawQuad(tex);
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    @SuppressWarnings("MagicNumber")
-    private void renderMonsters(long elapsedTime, int texIdx, boolean deadCorpses) {
-        renderer.z1 = -HALF_WALL;
-        renderer.z2 = HALF_WALL * MONSTER_SIZE_MULT;
-        renderer.z3 = HALF_WALL * MONSTER_SIZE_MULT;
-        renderer.z4 = -HALF_WALL;
-
-        int fromTex = texIdx * TextureLoader.MONSTERS_IN_TEXTURE * TextureLoader.COUNT_MONSTER;
-        int toTex = fromTex + TextureLoader.MONSTERS_IN_TEXTURE * TextureLoader.COUNT_MONSTER - 1;
-
-        boolean[][] localTouchedCellsMap = tracer.touchedCellsMap;
-
-        for (Monster mon = state.monsters.first(); mon != null; mon = (Monster)mon.next) {
-            if ((deadCorpses && mon.health > 0)
-                    || (!deadCorpses && mon.health <= 0)
-                    || (mon.texture < fromTex)
-                    || (mon.texture > toTex)
-                    || !(localTouchedCellsMap[mon.prevY][mon.prevX] || localTouchedCellsMap[mon.cellY][mon.cellX])) {
-
-                continue;
-            }
-
-            float fromX = mon.x + flatObjDy * MONSTER_SIZE_MULT;
-            float toX = mon.x - flatObjDy * MONSTER_SIZE_MULT;
-            float fromY = mon.y - flatObjDx * MONSTER_SIZE_MULT;
-            float toY = mon.y + flatObjDx * MONSTER_SIZE_MULT;
-
-            int tex = mon.texture - fromTex;
-            setObjLighting(mon.x, mon.y);
-
-            renderer.x1 = fromX;
-            renderer.y1 = -fromY;
-            renderer.x2 = fromX;
-            renderer.y2 = -fromY;
-            renderer.x3 = toX;
-            renderer.y3 = -toY;
-            renderer.x4 = toX;
-            renderer.y4 = -toY;
-
-            if (mon.health > 0) {
-                if ((mon.hitTimeout <= 0) && (mon.attackTimeout > 0)) {
-                    tex += 15;
-                } else {
-                    if (mon.isAimedOnHero) {
-                        tex += 2;
-                    } else if (mon.chaseMode) {
-                        tex += ((((int)currentHeroA + 360 + 45 - mon.dir * 90) % 360) / 90);
-                    }
-
-                    if (mon.hitTimeout > 0) {
-                        tex += 8;
-                    } else if (!mon.isInAttackState && ((elapsedTime % 800) > 400)) {
-                        tex += 4;
-                    }
-                }
-            } else {
-                if (mon.dieTime == 0) {
-                    mon.dieTime = elapsedTime;
-                }
-
-                tex += 12 + (mon.dieTime < 0 ? 2 : Math.min(2, (elapsedTime - mon.dieTime) / 150));
-            }
-
-            renderer.drawQuadMon(tex);
-        }
-    }
-
-    private void renderFloorArrows() {
-        renderer.z1 = -HALF_WALL + GameMath.EPSILON;
-        renderer.z2 = -HALF_WALL + GameMath.EPSILON;
-        renderer.z3 = -HALF_WALL + GameMath.EPSILON;
-        renderer.z4 = -HALF_WALL + GameMath.EPSILON;
-
-        TouchedCell[] localTouchedCells = tracer.touchedCells;
-        int[][] localWallsMap = state.wallsMap;
-        int[][] localArrowsMap = state.arrowsMap;
-
-        for (int i = 0, len = tracer.touchedCellsCount; i < len; i++) {
-            TouchedCell tc = localTouchedCells[i];
-            int arrowTex = localArrowsMap[tc.y][tc.x];
-
-            if ((localWallsMap[tc.y][tc.x] > 0) || (arrowTex == 0)) {
-                continue;
-            }
-
-            float fx = (float)tc.x;
-            float tx = (float)(tc.x + 1);
-            float fy = (float)tc.y;
-            float ty = (float)(tc.y + 1);
-
-            float lff = getLightness(fx, fy);
-            float lft = getLightness(fx, ty);
-            float ltf = getLightness(tx, fy);
-            float ltt = getLightness(tx, ty);
-
-            renderer.r1 = lft;
-            renderer.g1 = lft;
-            renderer.b1 = lft;
-            renderer.r2 = lff;
-            renderer.g2 = lff;
-            renderer.b2 = lff;
-            renderer.r3 = ltf;
-            renderer.g3 = ltf;
-            renderer.b3 = ltf;
-            renderer.r4 = ltt;
-            renderer.g4 = ltt;
-            renderer.b4 = ltt;
-
-            renderer.x1 = fx;
-            renderer.y1 = -ty;
-            renderer.x2 = fx;
-            renderer.y2 = -fy;
-            renderer.x3 = tx;
-            renderer.y3 = -fy;
-            renderer.x4 = tx;
-            renderer.y4 = -ty;
-
-            renderer.drawQuad(arrowTex);
-        }
-    }
-
-    @SuppressWarnings({ "MagicNumber", "ConstantConditions" })
-    private void renderFloorAndCeil() {
-        TouchedCell[] localTouchedCells = tracer.touchedCells;
-        int[][] localWallsMap = state.wallsMap;
-        int[][] localFloorMap1 = state.floorMap1;
-        int[][] localFloorMap2 = state.floorMap2;
-        int[][] localFloorMap3 = state.floorMap3;
-        int[][] localFloorMap4 = state.floorMap4;
-        int[][] localCeilMap1 = state.ceilMap1;
-        int[][] localCeilMap2 = state.ceilMap2;
-        int[][] localCeilMap3 = state.ceilMap3;
-        int[][] localCeilMap4 = state.ceilMap4;
-
-        for (int i = 0, len = tracer.touchedCellsCount; i < len; i++) {
-            TouchedCell tc = localTouchedCells[i];
-
-            // calc params
-
-            int floorTex1 = localFloorMap1[tc.y][tc.x];
-            int floorTex2 = localFloorMap2[tc.y][tc.x];
-            int floorTex3 = localFloorMap3[tc.y][tc.x];
-            int floorTex4 = localFloorMap4[tc.y][tc.x];
-            int ceilTex1 = localCeilMap1[tc.y][tc.x];
-            int ceilTex2 = localCeilMap2[tc.y][tc.x];
-            int ceilTex3 = localCeilMap3[tc.y][tc.x];
-            int ceilTex4 = localCeilMap4[tc.y][tc.x];
-
-            float fx = (float)tc.x;
-            float tx = (float)(tc.x + 1);
-            float fy = (float)tc.y;
-            float ty = (float)(tc.y + 1);
-            float mx = fx + 0.5f;
-            float my = fy + 0.5f;
-
-            float lff = getLightness(fx, fy);
-            float lft = getLightness(fx, ty);
-            float ltf = getLightness(tx, fy);
-            float ltt = getLightness(tx, ty);
-            float lfm = getLightness(fx, my);
-            float lmf = getLightness(mx, fy);
-            float lmm = getLightness(mx, my);
-            float lmt = getLightness(mx, ty);
-            float ltm = getLightness(tx, my);
-
-            fy = -fy;
-            ty = -ty;
-            my = -my;
-
-            if (localWallsMap[tc.y][tc.x] <= 0) {
-                // render floor
-
-                renderer.z1 = -HALF_WALL;
-                renderer.z2 = -HALF_WALL;
-                renderer.z3 = -HALF_WALL;
-                renderer.z4 = -HALF_WALL;
-
-                if (floorTex1 == floorTex2 && floorTex1 == floorTex3 && floorTex1 == floorTex4) {
-                    if (floorTex1 != 0) {
-                        renderer.r1 = lft;
-                        renderer.g1 = lft;
-                        renderer.b1 = lft;
-                        renderer.r2 = lff;
-                        renderer.g2 = lff;
-                        renderer.b2 = lff;
-                        renderer.r3 = ltf;
-                        renderer.g3 = ltf;
-                        renderer.b3 = ltf;
-                        renderer.r4 = ltt;
-                        renderer.g4 = ltt;
-                        renderer.b4 = ltt;
-
-                        renderer.x1 = fx;
-                        renderer.y1 = ty;
-                        renderer.x2 = fx;
-                        renderer.y2 = fy;
-                        renderer.x3 = tx;
-                        renderer.y3 = fy;
-                        renderer.x4 = tx;
-                        renderer.y4 = ty;
-
-                        renderer.drawQuad(floorTex1);
-                    }
-                } else {
-                    if (floorTex1 != 0) {
-                        renderer.r1 = lfm;
-                        renderer.g1 = lfm;
-                        renderer.b1 = lfm;
-                        renderer.r2 = lff;
-                        renderer.g2 = lff;
-                        renderer.b2 = lff;
-                        renderer.r3 = lmf;
-                        renderer.g3 = lmf;
-                        renderer.b3 = lmf;
-                        renderer.r4 = lmm;
-                        renderer.g4 = lmm;
-                        renderer.b4 = lmm;
-
-                        renderer.x1 = fx;
-                        renderer.y1 = my;
-                        renderer.x2 = fx;
-                        renderer.y2 = fy;
-                        renderer.x3 = mx;
-                        renderer.y3 = fy;
-                        renderer.x4 = mx;
-                        renderer.y4 = my;
-
-                        renderer.drawQuad1(floorTex1);
-                    }
-
-                    if (floorTex2 != 0) {
-                        renderer.r1 = lmm;
-                        renderer.g1 = lmm;
-                        renderer.b1 = lmm;
-                        renderer.r2 = lmf;
-                        renderer.g2 = lmf;
-                        renderer.b2 = lmf;
-                        renderer.r3 = ltf;
-                        renderer.g3 = ltf;
-                        renderer.b3 = ltf;
-                        renderer.r4 = ltm;
-                        renderer.g4 = ltm;
-                        renderer.b4 = ltm;
-
-                        renderer.x1 = mx;
-                        renderer.y1 = my;
-                        renderer.x2 = mx;
-                        renderer.y2 = fy;
-                        renderer.x3 = tx;
-                        renderer.y3 = fy;
-                        renderer.x4 = tx;
-                        renderer.y4 = my;
-
-                        renderer.drawQuad2(floorTex2);
-                    }
-
-                    if (floorTex3 != 0) {
-                        renderer.r1 = lft;
-                        renderer.g1 = lft;
-                        renderer.b1 = lft;
-                        renderer.r2 = lfm;
-                        renderer.g2 = lfm;
-                        renderer.b2 = lfm;
-                        renderer.r3 = lmm;
-                        renderer.g3 = lmm;
-                        renderer.b3 = lmm;
-                        renderer.r4 = lmt;
-                        renderer.g4 = lmt;
-                        renderer.b4 = lmt;
-
-                        renderer.x1 = fx;
-                        renderer.y1 = ty;
-                        renderer.x2 = fx;
-                        renderer.y2 = my;
-                        renderer.x3 = mx;
-                        renderer.y3 = my;
-                        renderer.x4 = mx;
-                        renderer.y4 = ty;
-
-                        renderer.drawQuad3(floorTex3);
-                    }
-
-                    if (floorTex4 != 0) {
-                        renderer.r1 = lmt;
-                        renderer.g1 = lmt;
-                        renderer.b1 = lmt;
-                        renderer.r2 = lmm;
-                        renderer.g2 = lmm;
-                        renderer.b2 = lmm;
-                        renderer.r3 = ltm;
-                        renderer.g3 = ltm;
-                        renderer.b3 = ltm;
-                        renderer.r4 = ltt;
-                        renderer.g4 = ltt;
-                        renderer.b4 = ltt;
-
-                        renderer.x1 = mx;
-                        renderer.y1 = ty;
-                        renderer.x2 = mx;
-                        renderer.y2 = my;
-                        renderer.x3 = tx;
-                        renderer.y3 = my;
-                        renderer.x4 = tx;
-                        renderer.y4 = ty;
-
-                        renderer.drawQuad4(floorTex4);
-                    }
-                }
-
-                // render ceil
-
-                renderer.z1 = HALF_WALL;
-                renderer.z2 = HALF_WALL;
-                renderer.z3 = HALF_WALL;
-                renderer.z4 = HALF_WALL;
-
-                if (ceilTex1 == ceilTex2 && ceilTex1 == ceilTex3 && ceilTex1 == ceilTex4) {
-                    if (ceilTex1 != 0) {
-                        renderer.r1 = ltt;
-                        renderer.g1 = ltt;
-                        renderer.b1 = ltt;
-                        renderer.r2 = ltf;
-                        renderer.g2 = ltf;
-                        renderer.b2 = ltf;
-                        renderer.r3 = lff;
-                        renderer.g3 = lff;
-                        renderer.b3 = lff;
-                        renderer.r4 = lft;
-                        renderer.g4 = lft;
-                        renderer.b4 = lft;
-
-                        renderer.x1 = tx;
-                        renderer.y1 = ty;
-                        renderer.x2 = tx;
-                        renderer.y2 = fy;
-                        renderer.x3 = fx;
-                        renderer.y3 = fy;
-                        renderer.x4 = fx;
-                        renderer.y4 = ty;
-
-                        renderer.drawQuadFlipLR(ceilTex1);
-                    }
-                } else {
-                    if (ceilTex1 != 0) {
-                        renderer.r1 = lmm;
-                        renderer.g1 = lmm;
-                        renderer.b1 = lmm;
-                        renderer.r2 = lmf;
-                        renderer.g2 = lmf;
-                        renderer.b2 = lmf;
-                        renderer.r3 = lff;
-                        renderer.g3 = lff;
-                        renderer.b3 = lff;
-                        renderer.r4 = lmt;
-                        renderer.g4 = lmt;
-                        renderer.b4 = lmt;
-
-                        renderer.x1 = mx;
-                        renderer.y1 = my;
-                        renderer.x2 = mx;
-                        renderer.y2 = fy;
-                        renderer.x3 = fx;
-                        renderer.y3 = fy;
-                        renderer.x4 = fx;
-                        renderer.y4 = my;
-
-                        renderer.drawQuadFlipLR1(ceilTex1);
-                    }
-
-                    if (ceilTex2 != 0) {
-                        renderer.r1 = ltm;
-                        renderer.g1 = ltm;
-                        renderer.b1 = ltm;
-                        renderer.r2 = ltf;
-                        renderer.g2 = ltf;
-                        renderer.b2 = ltf;
-                        renderer.r3 = lmf;
-                        renderer.g3 = lmf;
-                        renderer.b3 = lmf;
-                        renderer.r4 = lmm;
-                        renderer.g4 = lmm;
-                        renderer.b4 = lmm;
-
-                        renderer.x1 = tx;
-                        renderer.y1 = my;
-                        renderer.x2 = tx;
-                        renderer.y2 = fy;
-                        renderer.x3 = mx;
-                        renderer.y3 = fy;
-                        renderer.x4 = mx;
-                        renderer.y4 = my;
-
-                        renderer.drawQuadFlipLR2(ceilTex2);
-                    }
-
-                    if (ceilTex3 != 0) {
-                        renderer.r1 = lmt;
-                        renderer.g1 = lmt;
-                        renderer.b1 = lmt;
-                        renderer.r2 = lmm;
-                        renderer.g2 = lmm;
-                        renderer.b2 = lmm;
-                        renderer.r3 = lfm;
-                        renderer.g3 = lfm;
-                        renderer.b3 = lfm;
-                        renderer.r4 = lft;
-                        renderer.g4 = lft;
-                        renderer.b4 = lft;
-
-                        renderer.x1 = mx;
-                        renderer.y1 = ty;
-                        renderer.x2 = mx;
-                        renderer.y2 = my;
-                        renderer.x3 = fx;
-                        renderer.y3 = my;
-                        renderer.x4 = fx;
-                        renderer.y4 = ty;
-
-                        renderer.drawQuadFlipLR3(ceilTex3);
-                    }
-
-                    if (ceilTex4 != 0) {
-                        renderer.r1 = ltt;
-                        renderer.g1 = ltt;
-                        renderer.b1 = ltt;
-                        renderer.r2 = ltm;
-                        renderer.g2 = ltm;
-                        renderer.b2 = ltm;
-                        renderer.r3 = lmm;
-                        renderer.g3 = lmm;
-                        renderer.b3 = lmm;
-                        renderer.r4 = lmt;
-                        renderer.g4 = lmt;
-                        renderer.b4 = lmt;
-
-                        renderer.x1 = tx;
-                        renderer.y1 = ty;
-                        renderer.x2 = tx;
-                        renderer.y2 = my;
-                        renderer.x3 = mx;
-                        renderer.y3 = my;
-                        renderer.x4 = mx;
-                        renderer.y4 = ty;
-
-                        renderer.drawQuadFlipLR4(ceilTex4);
-                    }
-                }
-            }
-
-            // render extrude
-
-            // 2l | 1  2
-            // 4l | 3  4
-            // ---+------
-            //    | 1d 2d
-
-            renderer.z1 = HALF_WALL_PLUS_EXTRUDE;
-            renderer.z2 = HALF_WALL_PLUS_EXTRUDE;
-            renderer.z3 = HALF_WALL;
-            renderer.z4 = HALF_WALL;
-
-            lff *= EXTRUDE_LIGHT_MULT;
-            lft *= EXTRUDE_LIGHT_MULT;
-            // ltf *= EXTRUDE_LIGHT_MULT;
-            ltt *= EXTRUDE_LIGHT_MULT;
-            lfm *= EXTRUDE_LIGHT_MULT;
-            lmf *= EXTRUDE_LIGHT_MULT;
-            lmm *= EXTRUDE_LIGHT_MULT;
-            lmt *= EXTRUDE_LIGHT_MULT;
-            ltm *= EXTRUDE_LIGHT_MULT;
-
-            if (tc.x > 0) {
-                int ceilTex2l = localCeilMap2[tc.y][tc.x - 1];
-                int ceilTex4l = localCeilMap4[tc.y][tc.x - 1];
-
-                if ((ceilTex2l == 0 && ceilTex1 != 0) || (ceilTex2l != 0 && ceilTex1 == 0)) {
-                    renderer.x1 = fx;
-                    renderer.y1 = fy;
-                    renderer.x2 = fx;
-                    renderer.y2 = my;
-                    renderer.x3 = fx;
-                    renderer.y3 = my;
-                    renderer.x4 = fx;
-                    renderer.y4 = fy;
-
-                    renderer.r1 = lff;
-                    renderer.g1 = lff;
-                    renderer.b1 = lff;
-                    renderer.r2 = lfm;
-                    renderer.g2 = lfm;
-                    renderer.b2 = lfm;
-                    renderer.r3 = lfm;
-                    renderer.g3 = lfm;
-                    renderer.b3 = lfm;
-                    renderer.r4 = lff;
-                    renderer.g4 = lff;
-                    renderer.b4 = lff;
-
-                    if (ceilTex1 != 0) {
-                        renderer.drawQuad1(ceilTex1);
-                    } else {
-                        renderer.drawQuad2(ceilTex2l);
-                    }
-                }
-
-                if ((ceilTex4l == 0 && ceilTex3 != 0) || (ceilTex4l != 0 && ceilTex3 == 0)) {
-                    renderer.x1 = fx;
-                    renderer.y1 = my;
-                    renderer.x2 = fx;
-                    renderer.y2 = ty;
-                    renderer.x3 = fx;
-                    renderer.y3 = ty;
-                    renderer.x4 = fx;
-                    renderer.y4 = my;
-
-                    renderer.r1 = lfm;
-                    renderer.g1 = lfm;
-                    renderer.b1 = lfm;
-                    renderer.r2 = lft;
-                    renderer.g2 = lft;
-                    renderer.b2 = lft;
-                    renderer.r3 = lft;
-                    renderer.g3 = lft;
-                    renderer.b3 = lft;
-                    renderer.r4 = lfm;
-                    renderer.g4 = lfm;
-                    renderer.b4 = lfm;
-
-                    if (ceilTex3 != 0) {
-                        renderer.drawQuad3(ceilTex3);
-                    } else {
-                        renderer.drawQuad4(ceilTex4l);
-                    }
-                }
-            }
-
-            if (tc.y < (state.levelHeight - 1)) {
-                int ceilTex1d = localCeilMap1[tc.y + 1][tc.x];
-                int ceilTex2d = localCeilMap2[tc.y + 1][tc.x];
-
-                if ((ceilTex1d == 0 && ceilTex3 != 0) || (ceilTex1d != 0 && ceilTex3 == 0)) {
-                    renderer.x1 = fx;
-                    renderer.y1 = ty;
-                    renderer.x2 = mx;
-                    renderer.y2 = ty;
-                    renderer.x3 = mx;
-                    renderer.y3 = ty;
-                    renderer.x4 = fx;
-                    renderer.y4 = ty;
-
-                    renderer.r1 = lft;
-                    renderer.g1 = lft;
-                    renderer.b1 = lft;
-                    renderer.r2 = lmt;
-                    renderer.g2 = lmt;
-                    renderer.b2 = lmt;
-                    renderer.r3 = lmt;
-                    renderer.g3 = lmt;
-                    renderer.b3 = lmt;
-                    renderer.r4 = lft;
-                    renderer.g4 = lft;
-                    renderer.b4 = lft;
-
-                    if (ceilTex3 != 0) {
-                        renderer.drawQuad3(ceilTex3);
-                    } else {
-                        renderer.drawQuad3(ceilTex1d);
-                    }
-                }
-
-                if ((ceilTex2d == 0 && ceilTex4 != 0) || (ceilTex2d != 0 && ceilTex4 == 0)) {
-                    renderer.x1 = mx;
-                    renderer.y1 = ty;
-                    renderer.x2 = tx;
-                    renderer.y2 = ty;
-                    renderer.x3 = tx;
-                    renderer.y3 = ty;
-                    renderer.x4 = mx;
-                    renderer.y4 = ty;
-
-                    renderer.r1 = lmt;
-                    renderer.g1 = lmt;
-                    renderer.b1 = lmt;
-                    renderer.r2 = ltt;
-                    renderer.g2 = ltt;
-                    renderer.b2 = ltt;
-                    renderer.r3 = ltt;
-                    renderer.g3 = ltt;
-                    renderer.b3 = ltt;
-                    renderer.r4 = lmt;
-                    renderer.g4 = lmt;
-                    renderer.b4 = lmt;
-
-                    if (ceilTex4 != 0) {
-                        renderer.drawQuad4(ceilTex4);
-                    } else {
-                        renderer.drawQuad2(ceilTex2d);
-                    }
-                }
-            }
-
-            if ((ceilTex1 == 0 && ceilTex2 != 0) || (ceilTex1 != 0 && ceilTex2 == 0)) {
-                renderer.x1 = mx;
-                renderer.y1 = fy;
-                renderer.x2 = mx;
-                renderer.y2 = my;
-                renderer.x3 = mx;
-                renderer.y3 = my;
-                renderer.x4 = mx;
-                renderer.y4 = fy;
-
-                renderer.r1 = lmf;
-                renderer.g1 = lmf;
-                renderer.b1 = lmf;
-                renderer.r2 = lmm;
-                renderer.g2 = lmm;
-                renderer.b2 = lmm;
-                renderer.r3 = lmm;
-                renderer.g3 = lmm;
-                renderer.b3 = lmm;
-                renderer.r4 = lmf;
-                renderer.g4 = lmf;
-                renderer.b4 = lmf;
-
-                if (ceilTex2 != 0) {
-                    renderer.drawQuad2(ceilTex2);
-                } else {
-                    renderer.drawQuad1(ceilTex1);
-                }
-            }
-
-            if ((ceilTex3 == 0 && ceilTex4 != 0) || (ceilTex3 != 0 && ceilTex4 == 0)) {
-                renderer.x1 = mx;
-                renderer.y1 = my;
-                renderer.x2 = mx;
-                renderer.y2 = ty;
-                renderer.x3 = mx;
-                renderer.y3 = ty;
-                renderer.x4 = mx;
-                renderer.y4 = my;
-
-                renderer.r1 = lmm;
-                renderer.g1 = lmm;
-                renderer.b1 = lmm;
-                renderer.r2 = lmt;
-                renderer.g2 = lmt;
-                renderer.b2 = lmt;
-                renderer.r3 = lmt;
-                renderer.g3 = lmt;
-                renderer.b3 = lmt;
-                renderer.r4 = lmm;
-                renderer.g4 = lmm;
-                renderer.b4 = lmm;
-
-                if (ceilTex4 != 0) {
-                    renderer.drawQuad4(ceilTex4);
-                } else {
-                    renderer.drawQuad3(ceilTex3);
-                }
-            }
-
-            if ((ceilTex1 == 0 && ceilTex3 != 0) || (ceilTex1 != 0 && ceilTex3 == 0)) {
-                renderer.x1 = fx;
-                renderer.y1 = my;
-                renderer.x2 = mx;
-                renderer.y2 = my;
-                renderer.x3 = mx;
-                renderer.y3 = my;
-                renderer.x4 = fx;
-                renderer.y4 = my;
-
-                renderer.r1 = lfm;
-                renderer.g1 = lfm;
-                renderer.b1 = lfm;
-                renderer.r2 = lmm;
-                renderer.g2 = lmm;
-                renderer.b2 = lmm;
-                renderer.r3 = lmm;
-                renderer.g3 = lmm;
-                renderer.b3 = lmm;
-                renderer.r4 = lfm;
-                renderer.g4 = lfm;
-                renderer.b4 = lfm;
-
-                if (ceilTex3 != 0) {
-                    renderer.drawQuad3(ceilTex3);
-                } else {
-                    renderer.drawQuad1(ceilTex1);
-                }
-            }
-
-            if ((ceilTex2 == 0 && ceilTex4 != 0) || (ceilTex2 != 0 && ceilTex4 == 0)) {
-                renderer.x1 = mx;
-                renderer.y1 = my;
-                renderer.x2 = tx;
-                renderer.y2 = my;
-                renderer.x3 = tx;
-                renderer.y3 = my;
-                renderer.x4 = mx;
-                renderer.y4 = my;
-
-                renderer.r1 = lmm;
-                renderer.g1 = lmm;
-                renderer.b1 = lmm;
-                renderer.r2 = ltm;
-                renderer.g2 = ltm;
-                renderer.b2 = ltm;
-                renderer.r3 = ltm;
-                renderer.g3 = ltm;
-                renderer.b3 = ltm;
-                renderer.r4 = lmm;
-                renderer.g4 = lmm;
-                renderer.b4 = lmm;
-
-                if (ceilTex4 != 0) {
-                    renderer.drawQuad4(ceilTex4);
-                } else {
-                    renderer.drawQuad2(ceilTex2);
-                }
-            }
-        }
-    }
-
-    @SuppressWarnings("MagicNumber")
-    private void renderBullets() {
-        boolean[][] localTouchedCellsMap = tracer.touchedCellsMap;
-
-        for (Bullet bullet = state.bullets.first(); bullet != null; bullet = (Bullet)bullet.next) {
-            int tex = bullet.getTexture();
-
-            if (tex < 0 || !localTouchedCellsMap[(int)bullet.y][(int)bullet.x]) {
-                continue;
-            }
-
-            float fromX = bullet.x + flatObjDy;
-            float toX = bullet.x - flatObjDy;
-            float fromY = bullet.y - flatObjDx;
-            float toY = bullet.y + flatObjDx;
-
-            renderer.x1 = fromX;
-            renderer.y1 = -fromY;
-            renderer.x2 = fromX;
-            renderer.y2 = -fromY;
-            renderer.x3 = toX;
-            renderer.y3 = -toY;
-            renderer.x4 = toX;
-            renderer.y4 = -toY;
-
-            float zoff = HALF_WALL * 0.5f * (float)Math.sin(bullet.dist / bullet.params.maxDist * Math.PI * 1.5);
-
-            renderer.z1 = -HALF_WALL + zoff;
-            renderer.z2 = HALF_WALL + zoff;
-            renderer.z3 = HALF_WALL + zoff;
-            renderer.z4 = -HALF_WALL + zoff;
-
-            setObjLighting(bullet.x, bullet.y);
-            renderer.drawQuad(TextureLoader.BASE_BULLETS + tex);
-        }
-    }
-
-    private void renderExplosions() {
-        boolean[][] localTouchedCellsMap = tracer.touchedCellsMap;
-
-        for (Explosion explosion = state.explosions.first(); explosion != null; explosion = (Explosion)explosion.next) {
-            int tex = explosion.getTexture();
-
-            if (tex < 0 || !localTouchedCellsMap[(int)explosion.y][(int)explosion.x]) {
-                continue;
-            }
-
-            float fromX = explosion.x + flatObjDy;
-            float toX = explosion.x - flatObjDy;
-            float fromY = explosion.y - flatObjDx;
-            float toY = explosion.y + flatObjDx;
-
-            renderer.x1 = fromX;
-            renderer.y1 = -fromY;
-            renderer.x2 = fromX;
-            renderer.y2 = -fromY;
-            renderer.x3 = toX;
-            renderer.y3 = -toY;
-            renderer.x4 = toX;
-            renderer.y4 = -toY;
-
-            setObjLighting(explosion.x, explosion.y);
-            renderer.drawQuad(TextureLoader.BASE_EXPLOSIONS + tex);
-        }
-    }
-
-    @SuppressWarnings("MagicNumber")
-    public void render(GL10 gl, long elapsedTime, float ypos, float xrot) {
-        updateDoors(elapsedTime);
-
-        currentHeroX = state.heroX;
-        currentHeroY = state.heroY;
-        currentHeroA = state.heroA;
-        currentHeroCs = engine.heroCs;
-        currentHeroSn = engine.heroSn;
-
-        float currentHeroAr = engine.heroAr;
-
-        tracer.trace(currentHeroX, currentHeroY, currentHeroAr, 44.0f * GameMath.G2RAD_F);
-        renderer.frustrumModelIdentity(gl);
-
-        gl.glShadeModel(GL10.GL_SMOOTH);
-        gl.glDisable(GL10.GL_BLEND);
-        gl.glEnable(GL10.GL_DEPTH_TEST);
-
-        gl.glTranslatef(0.0f, ypos, -0.1f);
-        gl.glRotatef(xrot, 1.0f, 0.0f, 0.0f);
-        gl.glRotatef(90.0f - currentHeroA, 0.0f, 0.0f, 1.0f);
-        gl.glTranslatef(-currentHeroX, currentHeroY, 0.0f);
-
-        renderer.a1 = 1.0f;
-        renderer.a2 = 1.0f;
-        renderer.a3 = 1.0f;
-        renderer.a4 = 1.0f;
-
-        // Arrows on floor
-
-        renderer.init();
-        renderFloorArrows();
-        gl.glEnable(GL10.GL_ALPHA_TEST);
-        gl.glAlphaFunc(GL10.GL_GREATER, Renderer.ALPHA_VALUE);
-        renderer.bindTexture(gl, textureLoader.textures[TextureLoader.TEXTURE_MAIN]);
-        renderer.flush(gl);
-        gl.glDisable(GL10.GL_ALPHA_TEST);
-
-        // Floor and Ceiling
-
-        renderer.init();
-        renderFloorAndCeil();
-        gl.glDisable(GL10.GL_CULL_FACE); // necessary for extrude, and has no affect on floor and ceil
-        renderer.flush(gl);
-        gl.glEnable(GL10.GL_CULL_FACE);
-
-        // Walls and Door Sides
-
-        renderer.init();
-        renderLevel();
-        renderer.flush(gl);
-
-        // Doors
-
-        renderer.init();
-        renderDoors();
-
-        gl.glDisable(GL10.GL_CULL_FACE); // necessary for doors and transparents, and has no affect on monsters and objects
-        renderer.flush(gl);
-
-        // Monsters, Objects & Transparents
-
-        flatObjDx = (float)Math.cos(-currentHeroAr) * 0.5f;
-        flatObjDy = (float)Math.sin(-currentHeroAr) * 0.5f;
-
-        gl.glEnable(GL10.GL_ALPHA_TEST);
-        gl.glAlphaFunc(GL10.GL_GREATER, Renderer.ALPHA_VALUE);
-
-        // objects rendered after monsters (so if monster stay in cell with object, monster will be in front)
-        // or reverse order, but set appropriate depth test function
-
-        renderer.init();
-        renderMonsters(elapsedTime, 0, false);
-        renderer.bindTexture(gl, textureLoader.textures[TextureLoader.TEXTURE_MONSTERS_1]);
-        renderer.flush(gl);
-
-        renderer.init();
-        renderMonsters(elapsedTime, 1, false);
-        renderer.bindTexture(gl, textureLoader.textures[TextureLoader.TEXTURE_MONSTERS_2]);
-        renderer.flush(gl);
-
-        renderer.z1 = -HALF_WALL;
-        renderer.z2 = HALF_WALL;
-        renderer.z3 = HALF_WALL;
-        renderer.z4 = -HALF_WALL;
-
-        renderer.init();
-        renderExplosions();
-        renderBullets();
-
-        renderer.z1 = -HALF_WALL;
-        renderer.z2 = HALF_WALL;
-        renderer.z3 = HALF_WALL;
-        renderer.z4 = -HALF_WALL;
-
-        renderObjects();
-        renderer.bindTexture(gl, textureLoader.textures[TextureLoader.TEXTURE_MAIN]);
-        renderer.flush(gl);
-
-        // dead corpses rendered to be in back
-
-        renderer.init();
-        renderMonsters(elapsedTime, 0, true);
-        renderer.bindTexture(gl, textureLoader.textures[TextureLoader.TEXTURE_MONSTERS_1]);
-        renderer.flush(gl);
-
-        renderer.init();
-        renderMonsters(elapsedTime, 1, true);
-        renderer.bindTexture(gl, textureLoader.textures[TextureLoader.TEXTURE_MONSTERS_2]);
-        renderer.flush(gl);
-
-        gl.glDisable(GL10.GL_ALPHA_TEST);
-        gl.glEnable(GL10.GL_CULL_FACE);
-    }
-
-    @SuppressWarnings("MagicNumber")
-    public void surfaceSizeChanged(GL10 gl) {
-        float size = 0.1f * (float)Math.tan(Math.toRadians(50.0) / 2);
-        renderer.initFrustum(gl, -size, size, -size / engine.ratio, size / engine.ratio, 0.1f, 100.0f);
-        gl.glHint(GL10.GL_PERSPECTIVE_CORRECTION_HINT, GL10.GL_NICEST);
-    }
-}
diff --git a/src/main/java/zame/game/engine/OnChangeWeaponAction.java b/src/main/java/zame/game/engine/OnChangeWeaponAction.java
deleted file mode 100644
index e0f9042..0000000
--- a/src/main/java/zame/game/engine/OnChangeWeaponAction.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package zame.game.engine;
-
-import java.io.IOException;
-import zame.game.engine.data.DataItem;
-import zame.game.engine.data.DataListItem;
-import zame.game.engine.data.DataReader;
-import zame.game.engine.data.DataWriter;
-
-public class OnChangeWeaponAction extends DataListItem implements DataItem {
-    private static final int FIELD_MARK_ID = 1;
-
-    int markId;
-
-    @Override
-    public void writeTo(DataWriter writer) throws IOException {
-        writer.write(FIELD_MARK_ID, markId);
-    }
-
-    @Override
-    public void readFrom(DataReader reader) {
-        markId = reader.readInt(FIELD_MARK_ID);
-    }
-}
diff --git a/src/main/java/zame/game/engine/Renderer.java b/src/main/java/zame/game/engine/Renderer.java
deleted file mode 100644
index f54a832..0000000
--- a/src/main/java/zame/game/engine/Renderer.java
+++ /dev/null
@@ -1,569 +0,0 @@
-package zame.game.engine;
-
-import javax.microedition.khronos.opengles.GL10;
-
-// http://stackoverflow.com/questions/1848886/jni-c-library-passing-byte-ptr
-// http://groups.google.com/group/android-ndk/tree/browse_frm/month/2010-01?_done=/group/android-ndk/browse_frm/month/2010-01%3F&
-
-// Native buffers (aka ByteBuffer, ShortBuffer and FloatBuffer) suck in DalvikVM. It is terribly slow.
-// So native code used to render. It's up to 4x faster than java code with native buffers.
-
-@SuppressWarnings("MagicNumber")
-public class Renderer implements EngineObject {
-    static {
-        System.loadLibrary("renderer");
-    }
-
-    private static native void renderTriangles(float[] vertexBuf,
-            float[] colorsBuf,
-            int[] textureBuf,
-            short[] indicesBuf,
-            int indicesBufPos);
-
-    private static native void renderLines(float[] vertexBuf, float[] colorsBuf, int vertexCount);
-
-    private static final int MAX_QUADS = 64 * 64 * 2; // (64*64*2 * (12*4 + 16*4 + 8*4 + 6*2 + 4*4 + 8*4))
-    private static final int TEXTURE_FILTER_LEVEL = GL10.GL_LINEAR;
-    private static final int TEXTURE_FILTER_WEAPONS = GL10.GL_LINEAR;
-
-    static final float ALPHA_VALUE = 0.5f;
-
-    private float[] vertexBuffer = new float[MAX_QUADS * 12];
-    private float[] colorsBuffer = new float[MAX_QUADS * 16];
-    private int[] textureBuffer = new int[MAX_QUADS * 8];
-    private short[] indicesBuffer = new short[MAX_QUADS * 6];
-    private float[] lineVertexBuffer = new float[MAX_QUADS * 4];
-    private float[] lineColorsBuffer = new float[MAX_QUADS * 8];
-
-    private int vertexBufferPos;
-    private int colorsBufferPos;
-    private int textureBufferPos;
-    private int indicesBufferPos;
-    private int lineVertexBufferPos;
-    private int lineColorsBufferPos;
-
-    private short vertexCount;
-    private short lineVertexCount;
-
-    protected Engine engine;
-    protected Config config;
-
-    @Override
-    public void setEngine(Engine engine) {
-        this.engine = engine;
-        this.config = engine.config;
-    }
-
-    public void init() {
-        vertexCount = 0;
-        lineVertexCount = 0;
-
-        vertexBufferPos = 0;
-        colorsBufferPos = 0;
-        textureBufferPos = 0;
-        indicesBufferPos = 0;
-        lineVertexBufferPos = 0;
-        lineColorsBufferPos = 0;
-    }
-
-    public void flush(GL10 gl) {
-        flush(gl, true);
-    }
-
-    public void flush(GL10 gl, boolean useTextures) {
-        gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
-        gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
-
-        if (indicesBufferPos != 0) {
-            if (useTextures) {
-                gl.glEnable(GL10.GL_TEXTURE_2D);
-                gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
-            } else {
-                gl.glDisable(GL10.GL_TEXTURE_2D);
-                gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
-            }
-
-            renderTriangles(vertexBuffer,
-                    colorsBuffer,
-                    (useTextures ? textureBuffer : null),
-                    indicesBuffer,
-                    indicesBufferPos);
-        }
-
-        if (lineVertexCount != 0) {
-            gl.glDisable(GL10.GL_TEXTURE_2D);
-            gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
-
-            renderLines(lineVertexBuffer, lineColorsBuffer, lineVertexCount);
-        }
-    }
-
-    public void bindTexture(GL10 gl, int tex) {
-        gl.glBindTexture(GL10.GL_TEXTURE_2D, tex);
-        gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MIN_FILTER, TEXTURE_FILTER_LEVEL);
-        gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MAG_FILTER, TEXTURE_FILTER_LEVEL);
-        gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_S, GL10.GL_CLAMP_TO_EDGE);
-        gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_T, GL10.GL_CLAMP_TO_EDGE);
-    }
-
-    void bindTextureRep(GL10 gl, int tex) {
-        gl.glBindTexture(GL10.GL_TEXTURE_2D, tex);
-        gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MIN_FILTER, TEXTURE_FILTER_LEVEL);
-        gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MAG_FILTER, TEXTURE_FILTER_LEVEL);
-        gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_S, GL10.GL_REPEAT);
-        gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_T, GL10.GL_REPEAT);
-    }
-
-    public void bindTextureCtl(GL10 gl, int tex) {
-        gl.glBindTexture(GL10.GL_TEXTURE_2D, tex);
-        gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MIN_FILTER, TEXTURE_FILTER_WEAPONS);
-        gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MAG_FILTER, TEXTURE_FILTER_WEAPONS);
-        gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_S, GL10.GL_CLAMP_TO_EDGE);
-        gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_T, GL10.GL_CLAMP_TO_EDGE);
-    }
-
-    @SuppressWarnings("unused")
-    public void bindTextureCtlRep(GL10 gl, int tex) {
-        gl.glBindTexture(GL10.GL_TEXTURE_2D, tex);
-        gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MIN_FILTER, TEXTURE_FILTER_WEAPONS);
-        gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MAG_FILTER, TEXTURE_FILTER_WEAPONS);
-        gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_S, GL10.GL_REPEAT);
-        gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_T, GL10.GL_REPEAT);
-    }
-
-    public void bindTextureBlur(GL10 gl, int tex) {
-        gl.glBindTexture(GL10.GL_TEXTURE_2D, tex);
-        gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MIN_FILTER, GL10.GL_LINEAR);
-        gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MAG_FILTER, GL10.GL_LINEAR);
-        gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_S, GL10.GL_CLAMP_TO_EDGE);
-        gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_T, GL10.GL_CLAMP_TO_EDGE);
-    }
-
-    public void initOrtho(GL10 gl,
-            @SuppressWarnings("SameParameterValue") boolean pushProjection,
-            boolean pushModel,
-            float left,
-            float right,
-            float bottom,
-            float top,
-            float near,
-            @SuppressWarnings("SameParameterValue") float far) {
-
-        gl.glMatrixMode(GL10.GL_PROJECTION);
-
-        if (pushProjection) {
-            gl.glPushMatrix();
-        }
-
-        gl.glLoadIdentity();
-
-        if (!engine.inWallpaperMode && config.rotateScreen) {
-            gl.glOrthof(right, left, top, bottom, near, far);
-        } else {
-            gl.glOrthof(left, right, bottom, top, near, far);
-        }
-
-        gl.glMatrixMode(GL10.GL_MODELVIEW);
-
-        if (pushModel) {
-            gl.glPushMatrix();
-        }
-
-        gl.glLoadIdentity();
-    }
-
-    void initFrustum(GL10 gl,
-            float left,
-            float right,
-            float bottom,
-            float top,
-            @SuppressWarnings("SameParameterValue") float near,
-            @SuppressWarnings("SameParameterValue") float far) {
-
-        gl.glMatrixMode(GL10.GL_PROJECTION);
-        gl.glLoadIdentity();
-
-        if (!engine.inWallpaperMode && config.rotateScreen) {
-            gl.glFrustumf(right, left, top, bottom, near, far);
-        } else {
-            gl.glFrustumf(left, right, bottom, top, near, far);
-        }
-    }
-
-    void frustrumModelIdentity(GL10 gl) {
-        gl.glMatrixMode(GL10.GL_MODELVIEW);
-        gl.glLoadIdentity();
-    }
-
-    public float x1;
-    public float y1;
-    public float z1;
-    public int u1;
-    public int v1;
-    public float r1;
-    @SuppressWarnings("WeakerAccess") public float g1;
-    @SuppressWarnings("WeakerAccess") public float b1;
-    public float a1;
-
-    public float x2;
-    public float y2;
-    public float z2;
-    public int u2;
-    @SuppressWarnings("WeakerAccess") public int v2;
-    public float r2;
-    @SuppressWarnings("WeakerAccess") public float g2;
-    @SuppressWarnings("WeakerAccess") public float b2;
-    public float a2;
-
-    public float x3;
-    public float y3;
-    public float z3;
-    @SuppressWarnings("WeakerAccess") public int u3;
-    @SuppressWarnings("WeakerAccess") public int v3;
-    public float r3;
-    @SuppressWarnings("WeakerAccess") public float g3;
-    @SuppressWarnings("WeakerAccess") public float b3;
-    public float a3;
-
-    public float x4;
-    public float y4;
-    public float z4;
-    @SuppressWarnings("WeakerAccess") public int u4;
-    public int v4;
-    public float r4;
-    @SuppressWarnings("WeakerAccess") public float g4;
-    @SuppressWarnings("WeakerAccess") public float b4;
-    public float a4;
-
-    // In-game:
-    //
-    //	1 | 2
-    // ---+--->
-    //	4 | 3
-    //	  v
-    //
-    // Ortho:
-    //
-    //  2 | 3
-    // ---+--->
-    //  1 | 4
-    //    v
-    //
-    public void drawQuad() {
-        int vertexBufferPosL = vertexBufferPos;
-        int colorsBufferPosL = colorsBufferPos;
-        int textureBufferPosL = textureBufferPos;
-        int indicesBufferPosL = indicesBufferPos;
-        short vertexCountL = vertexCount;
-
-        float[] vertexBufferL = vertexBuffer;
-        float[] colorsBufferL = colorsBuffer;
-        int[] textureBufferL = textureBuffer;
-        short[] indicesBufferL = indicesBuffer;
-
-        vertexBufferL[vertexBufferPosL] = x1;
-        vertexBufferL[vertexBufferPosL + 1] = y1;
-        vertexBufferL[vertexBufferPosL + 2] = z1;
-        vertexBufferL[vertexBufferPosL + 3] = x2;
-        vertexBufferL[vertexBufferPosL + 4] = y2;
-        vertexBufferL[vertexBufferPosL + 5] = z2;
-        vertexBufferL[vertexBufferPosL + 6] = x3;
-        vertexBufferL[vertexBufferPosL + 7] = y3;
-        vertexBufferL[vertexBufferPosL + 8] = z3;
-        vertexBufferL[vertexBufferPosL + 9] = x4;
-        vertexBufferL[vertexBufferPosL + 10] = y4;
-        vertexBufferL[vertexBufferPosL + 11] = z4;
-
-        colorsBufferL[colorsBufferPosL] = r1;
-        colorsBufferL[colorsBufferPosL + 1] = g1;
-        colorsBufferL[colorsBufferPosL + 2] = b1;
-        colorsBufferL[colorsBufferPosL + 3] = a1;
-        colorsBufferL[colorsBufferPosL + 4] = r2;
-        colorsBufferL[colorsBufferPosL + 5] = g2;
-        colorsBufferL[colorsBufferPosL + 6] = b2;
-        colorsBufferL[colorsBufferPosL + 7] = a2;
-        colorsBufferL[colorsBufferPosL + 8] = r3;
-        colorsBufferL[colorsBufferPosL + 9] = g3;
-        colorsBufferL[colorsBufferPosL + 10] = b3;
-        colorsBufferL[colorsBufferPosL + 11] = a3;
-        colorsBufferL[colorsBufferPosL + 12] = r4;
-        colorsBufferL[colorsBufferPosL + 13] = g4;
-        colorsBufferL[colorsBufferPosL + 14] = b4;
-        colorsBufferL[colorsBufferPosL + 15] = a4;
-
-        textureBufferL[textureBufferPosL] = u1;
-        textureBufferL[textureBufferPosL + 1] = v1;
-        textureBufferL[textureBufferPosL + 2] = u2;
-        textureBufferL[textureBufferPosL + 3] = v2;
-        textureBufferL[textureBufferPosL + 4] = u3;
-        textureBufferL[textureBufferPosL + 5] = v3;
-        textureBufferL[textureBufferPosL + 6] = u4;
-        textureBufferL[textureBufferPosL + 7] = v4;
-
-        indicesBufferL[indicesBufferPosL] = vertexCountL;
-        indicesBufferL[indicesBufferPosL + 1] = (short)(vertexCountL + 2);
-        indicesBufferL[indicesBufferPosL + 2] = (short)(vertexCountL + 1);
-        indicesBufferL[indicesBufferPosL + 3] = vertexCountL;
-        indicesBufferL[indicesBufferPosL + 4] = (short)(vertexCountL + 3);
-        indicesBufferL[indicesBufferPosL + 5] = (short)(vertexCountL + 2);
-
-        vertexBufferPos = vertexBufferPosL + 12;
-        colorsBufferPos = colorsBufferPosL + 16;
-        textureBufferPos = textureBufferPos + 8;
-        indicesBufferPos = indicesBufferPosL + 6;
-        vertexCount = (short)(vertexCountL + 4);
-    }
-
-    public static final int TILE_SIZE = 128;
-    private static final int TILE_MON_SIZE = 256;
-
-    private static final int TEX_CELL_X = ((TILE_SIZE + 2) << 16) / 2048;
-    private static final int TEX_CELL_Y = ((TILE_SIZE + 2) << 16) / 2048;
-    private static final int TEX_MON_CELL_X = ((TILE_MON_SIZE + 2) << 16) / 2048;
-    private static final int TEX_MON_CELL_Y = ((TILE_MON_SIZE + 2) << 16) / 2048;
-    private static final int TEX_1PX_X = (1 << 16) / 2048;
-    private static final int TEX_1PX_Y = (1 << 16) / 2048;
-    private static final int TEX_SIZE_X = (TILE_SIZE << 16) / 2048;
-    private static final int TEX_SIZE_Y = (TILE_SIZE << 16) / 2048;
-    private static final int TEX_MON_SIZE_X = (TILE_MON_SIZE << 16) / 2048;
-    private static final int TEX_MON_SIZE_Y = (TILE_MON_SIZE << 16) / 2048;
-    private static final int TEX_SIZE_X_D2 = ((TILE_SIZE / 2) << 16) / 2048;
-    private static final int TEX_SIZE_Y_D2 = ((TILE_SIZE / 2) << 16) / 2048;
-    private static final int TEX_SIZE_X_D2_1PX = TEX_SIZE_X_D2 + TEX_1PX_X;
-    private static final int TEX_SIZE_Y_D2_1PX = TEX_SIZE_Y_D2 + TEX_1PX_Y;
-    private static final int TEX_SIZE_X_X2 = ((TILE_SIZE * 2) << 16) / 2048;
-    private static final int TEX_SIZE_Y_X2 = ((TILE_SIZE * 2) << 16) / 2048;
-    private static final int TEX_SIZE_X_X4 = ((TILE_SIZE * 4) << 16) / 2048;
-    private static final int TEX_EXTR_X_FROM = ((TILE_SIZE / 2 - TILE_SIZE / 16 / 2) << 16) / 2048;
-    private static final int TEX_EXTR_X_SIZE = ((TILE_SIZE / 16) << 16) / 2048;
-
-    public void drawQuad(int texNum) {
-        u3 = u4 = (u1 = u2 = (texNum % 15) * TEX_CELL_X + TEX_1PX_X) + TEX_SIZE_X;
-        v1 = v4 = (v2 = v3 = (texNum / 15) * TEX_CELL_Y + TEX_1PX_Y) + TEX_SIZE_Y;
-        drawQuad();
-    }
-
-    public void drawQuadMon(int texNum) {
-        u3 = u4 = (u1 = u2 = (texNum % 7) * TEX_MON_CELL_X + TEX_1PX_X) + TEX_MON_SIZE_X;
-        v1 = v4 = (v2 = v3 = (texNum / 7) * TEX_MON_CELL_Y + TEX_1PX_Y) + TEX_MON_SIZE_Y;
-        drawQuad();
-    }
-
-    void drawQuadExtruded(int texNum) {
-        u3 = u4 = (u1 = u2 = (texNum % 15) * TEX_CELL_X + TEX_EXTR_X_FROM) + TEX_EXTR_X_SIZE;
-        v1 = v4 = (v2 = v3 = (texNum / 15) * TEX_CELL_Y + TEX_1PX_Y) + TEX_SIZE_Y;
-        drawQuad();
-    }
-
-    void drawQuad1(int texNum) {
-        u3 = u4 = (u1 = u2 = (texNum % 15) * TEX_CELL_X + TEX_1PX_X) + TEX_SIZE_X_D2;
-        v1 = v4 = (v2 = v3 = (texNum / 15) * TEX_CELL_Y + TEX_1PX_Y) + TEX_SIZE_Y_D2;
-        drawQuad();
-    }
-
-    void drawQuad2(int texNum) {
-        u3 = u4 = (u1 = u2 = (texNum % 15) * TEX_CELL_X + TEX_SIZE_X_D2_1PX) + TEX_SIZE_X_D2;
-        v1 = v4 = (v2 = v3 = (texNum / 15) * TEX_CELL_Y + TEX_1PX_Y) + TEX_SIZE_Y_D2;
-        drawQuad();
-    }
-
-    void drawQuad3(int texNum) {
-        u3 = u4 = (u1 = u2 = (texNum % 15) * TEX_CELL_X + TEX_1PX_X) + TEX_SIZE_X_D2;
-        v1 = v4 = (v2 = v3 = (texNum / 15) * TEX_CELL_Y + TEX_SIZE_Y_D2_1PX) + TEX_SIZE_Y_D2;
-        drawQuad();
-    }
-
-    void drawQuad4(int texNum) {
-        u3 = u4 = (u1 = u2 = (texNum % 15) * TEX_CELL_X + TEX_SIZE_X_D2_1PX) + TEX_SIZE_X_D2;
-        v1 = v4 = (v2 = v3 = (texNum / 15) * TEX_CELL_Y + TEX_SIZE_Y_D2_1PX) + TEX_SIZE_Y_D2;
-        drawQuad();
-    }
-
-    public void drawQuad2x(int texNum) {
-        u3 = u4 = (u1 = u2 = (texNum % 15) * TEX_CELL_X + TEX_1PX_X) + TEX_SIZE_X_X2;
-        v1 = v4 = (v2 = v3 = (texNum / 15) * TEX_CELL_Y + TEX_1PX_Y) + TEX_SIZE_Y_X2;
-        drawQuad();
-    }
-
-    public void drawQuad4x1x(int texNum) {
-        u3 = u4 = (u1 = u2 = (texNum % 15) * TEX_CELL_X + TEX_1PX_X) + TEX_SIZE_X_X4;
-        v1 = v4 = (v2 = v3 = (texNum / 15) * TEX_CELL_Y + TEX_1PX_Y) + TEX_SIZE_Y;
-        drawQuad();
-    }
-
-    void drawQuadFlipLR(int texNum) {
-        u1 = u2 = (u3 = u4 = (texNum % 15) * TEX_CELL_X + TEX_1PX_X) + TEX_SIZE_X;
-        v1 = v4 = (v2 = v3 = (texNum / 15) * TEX_CELL_Y + TEX_1PX_Y) + TEX_SIZE_Y;
-        drawQuad();
-    }
-
-    void drawQuadFlipLR1(int texNum) {
-        u1 = u2 = (u3 = u4 = (texNum % 15) * TEX_CELL_X + TEX_1PX_X) + TEX_SIZE_X_D2;
-        v1 = v4 = (v2 = v3 = (texNum / 15) * TEX_CELL_Y + TEX_1PX_Y) + TEX_SIZE_Y_D2;
-        drawQuad();
-    }
-
-    void drawQuadFlipLR2(int texNum) {
-        u1 = u2 = (u3 = u4 = (texNum % 15) * TEX_CELL_X + TEX_SIZE_X_D2_1PX) + TEX_SIZE_X_D2;
-        v1 = v4 = (v2 = v3 = (texNum / 15) * TEX_CELL_Y + TEX_1PX_Y) + TEX_SIZE_Y_D2;
-        drawQuad();
-    }
-
-    void drawQuadFlipLR3(int texNum) {
-        u1 = u2 = (u3 = u4 = (texNum % 15) * TEX_CELL_X + TEX_1PX_X) + TEX_SIZE_X_D2;
-        v1 = v4 = (v2 = v3 = (texNum / 15) * TEX_CELL_Y + TEX_SIZE_Y_D2_1PX) + TEX_SIZE_Y_D2;
-        drawQuad();
-    }
-
-    void drawQuadFlipLR4(int texNum) {
-        u1 = u2 = (u3 = u4 = (texNum % 15) * TEX_CELL_X + TEX_SIZE_X_D2_1PX) + TEX_SIZE_X_D2;
-        v1 = v4 = (v2 = v3 = (texNum / 15) * TEX_CELL_Y + TEX_SIZE_Y_D2_1PX) + TEX_SIZE_Y_D2;
-        drawQuad();
-    }
-
-    @SuppressWarnings("unused")
-    public void drawLine() {
-        int lineVertexBufferPosL = lineVertexBufferPos;
-        int lineColorsBufferPosL = lineColorsBufferPos;
-        float[] lineVertexBufferL = lineVertexBuffer;
-        float[] lineColorsBufferL = lineColorsBuffer;
-
-        lineVertexBufferL[lineVertexBufferPosL] = x1;
-        lineVertexBufferL[lineVertexBufferPosL + 1] = y1;
-        lineVertexBufferL[lineVertexBufferPosL + 2] = x2;
-        lineVertexBufferL[lineVertexBufferPosL + 3] = y2;
-
-        lineColorsBufferL[lineColorsBufferPosL] = r1;
-        lineColorsBufferL[lineColorsBufferPosL + 1] = g1;
-        lineColorsBufferL[lineColorsBufferPosL + 2] = b1;
-        lineColorsBufferL[lineColorsBufferPosL + 3] = a1;
-        lineColorsBufferL[lineColorsBufferPosL + 4] = r2;
-        lineColorsBufferL[lineColorsBufferPosL + 5] = g2;
-        lineColorsBufferL[lineColorsBufferPosL + 6] = b2;
-        lineColorsBufferL[lineColorsBufferPosL + 7] = a2;
-
-        lineVertexBufferPos = lineVertexBufferPosL + 4;
-        lineColorsBufferPos = lineColorsBufferPosL + 8;
-        lineVertexCount += 2;
-    }
-
-    public void drawLine(float lx1, float ly1, float lx2, float ly2) {
-        int lineVertexBufferPosL = lineVertexBufferPos;
-        int lineColorsBufferPosL = lineColorsBufferPos;
-        float[] lineVertexBufferL = lineVertexBuffer;
-        float[] lineColorsBufferL = lineColorsBuffer;
-
-        lineVertexBufferL[lineVertexBufferPosL] = lx1;
-        lineVertexBufferL[lineVertexBufferPosL + 1] = ly1;
-        lineVertexBufferL[lineVertexBufferPosL + 2] = lx2;
-        lineVertexBufferL[lineVertexBufferPosL + 3] = ly2;
-
-        lineColorsBufferL[lineColorsBufferPosL] = r1;
-        lineColorsBufferL[lineColorsBufferPosL + 1] = g1;
-        lineColorsBufferL[lineColorsBufferPosL + 2] = b1;
-        lineColorsBufferL[lineColorsBufferPosL + 3] = a1;
-        lineColorsBufferL[lineColorsBufferPosL + 4] = r2;
-        lineColorsBufferL[lineColorsBufferPosL + 5] = g2;
-        lineColorsBufferL[lineColorsBufferPosL + 6] = b2;
-        lineColorsBufferL[lineColorsBufferPosL + 7] = a2;
-
-        lineVertexBufferPos = lineVertexBufferPosL + 4;
-        lineColorsBufferPos = lineColorsBufferPosL + 8;
-        lineVertexCount += 2;
-    }
-
-    public void setQuadRGB(float r, float g, float b) {
-        r1 = r;
-        g1 = g;
-        b1 = b;
-        r2 = r;
-        g2 = g;
-        b2 = b;
-        r3 = r;
-        g3 = g;
-        b3 = b;
-        r4 = r;
-        g4 = g;
-        b4 = b;
-    }
-
-    public void setQuadA(float a) {
-        a1 = a;
-        a2 = a;
-        a3 = a;
-        a4 = a;
-    }
-
-    public void setQuadRGBA(float r, float g, float b, float a) {
-        r1 = r;
-        g1 = g;
-        b1 = b;
-        a1 = a;
-        r2 = r;
-        g2 = g;
-        b2 = b;
-        a2 = a;
-        r3 = r;
-        g3 = g;
-        b3 = b;
-        a3 = a;
-        r4 = r;
-        g4 = g;
-        b4 = b;
-        a4 = a;
-    }
-
-    public void setLineRGB(float r, float g, float b) {
-        r1 = r;
-        g1 = g;
-        b1 = b;
-        r2 = r;
-        g2 = g;
-        b2 = b;
-    }
-
-    @SuppressWarnings("unused")
-    public void setLineA(float a) {
-        a1 = a;
-        a2 = a;
-    }
-
-    @SuppressWarnings("unused")
-    public void setLineRGBA(float r, float g, float b, float a) {
-        r1 = r;
-        g1 = g;
-        b1 = b;
-        a1 = a;
-        r2 = r;
-        g2 = g;
-        b2 = b;
-        a2 = a;
-    }
-
-    public void setQuadOrthoCoords(float lx1, float ly1, float lx2, float ly2) {
-        x1 = lx1;
-        y1 = ly1;
-        z1 = 0.0f;
-        x2 = lx1;
-        y2 = ly2;
-        z2 = 0.0f;
-        x3 = lx2;
-        y3 = ly2;
-        z3 = 0.0f;
-        x4 = lx2;
-        y4 = ly1;
-        z4 = 0.0f;
-    }
-
-    @SuppressWarnings("WeakerAccess")
-    public void setQuadTexCoords(int sx, int sy, int ex, int ey) {
-        u1 = sx;
-        v1 = sy;
-        u2 = sx;
-        v2 = ey;
-        u3 = ex;
-        v3 = ey;
-        u4 = ex;
-        v4 = sy;
-    }
-}
diff --git a/src/main/java/zame/game/engine/TextureLoader.java b/src/main/java/zame/game/engine/TextureLoader.java
deleted file mode 100644
index a803822..0000000
--- a/src/main/java/zame/game/engine/TextureLoader.java
+++ /dev/null
@@ -1,409 +0,0 @@
-package zame.game.engine;
-
-import android.annotation.SuppressLint;
-import android.content.res.AssetManager;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.opengl.GLUtils;
-import android.os.Build;
-import javax.microedition.khronos.opengles.GL10;
-import zame.game.App;
-import zame.game.Common;
-import zame.game.providers.CachedTexturesProvider;
-
-public class TextureLoader implements EngineObject {
-    @SuppressWarnings("WeakerAccess") public static final int TEXTURE_LOADING = 0;
-    @SuppressWarnings("WeakerAccess") public static final int TEXTURE_LABELS = TEXTURE_LOADING + 1;
-    @SuppressWarnings("WeakerAccess") public static final int TEXTURE_RENDER_TO = TEXTURE_LABELS + 1;
-    @SuppressWarnings("WeakerAccess") public static final int TEXTURE_RENDER_TO_FBO = TEXTURE_RENDER_TO + 1;
-    public static final int TEXTURE_MAIN = TEXTURE_RENDER_TO_FBO + 1;
-    @SuppressWarnings("WeakerAccess") public static final int TEXTURE_KNIFE = TEXTURE_MAIN + 1;
-    @SuppressWarnings("WeakerAccess") public static final int TEXTURE_PISTOL = TEXTURE_KNIFE + 4;
-    @SuppressWarnings("WeakerAccess") public static final int TEXTURE_DBLPISTOL = TEXTURE_PISTOL + 4;
-    @SuppressWarnings("WeakerAccess") public static final int TEXTURE_SHTG = TEXTURE_DBLPISTOL + 4;
-    @SuppressWarnings("WeakerAccess") public static final int TEXTURE_AK47 = TEXTURE_SHTG + 5;
-    @SuppressWarnings("WeakerAccess") public static final int TEXTURE_TMP = TEXTURE_AK47 + 4;
-    @SuppressWarnings("WeakerAccess") public static final int TEXTURE_GRENADE = TEXTURE_TMP + 4;
-    @SuppressWarnings("WeakerAccess") public static final int TEXTURE_MONSTERS_1 = TEXTURE_GRENADE + 8;
-    @SuppressWarnings("WeakerAccess") public static final int TEXTURE_MONSTERS_2 = TEXTURE_MONSTERS_1 + 1;
-    @SuppressWarnings("WeakerAccess") public static final int TEXTURE_SKY = TEXTURE_MONSTERS_2 + 1;
-    @SuppressWarnings("WeakerAccess") public static final int TEXTURE_LAST = TEXTURE_SKY + 1;
-
-    static final int RENDER_TO_SIZE = 256;
-    static final int RENDER_TO_FBO_SIZE = 512;
-
-    public static final int ROW_COMMON = 0;
-    public static final int ROW_TILES = 6;
-
-    @SuppressWarnings("WeakerAccess") public static final int BASE_ICONS = ROW_COMMON * 15;
-    @SuppressWarnings("WeakerAccess") public static final int BASE_OBJECTS = BASE_ICONS + 10;
-    @SuppressWarnings("WeakerAccess") public static final int BASE_BULLETS = BASE_OBJECTS + 19;
-    @SuppressWarnings("WeakerAccess") public static final int BASE_EXPLOSIONS = BASE_BULLETS + 4;
-    @SuppressWarnings("WeakerAccess") public static final int BASE_ARROWS = BASE_EXPLOSIONS + 3;
-    public static final int BASE_WEAPONS = BASE_ARROWS + 4;
-    public static final int BASE_BACKS = (ROW_COMMON + 4) * 15;
-
-    static final int BASE_WALLS = ROW_TILES * 15; // BASE_WALLS must be greater than 0
-    static final int BASE_TRANSP_WALLS = BASE_WALLS + 44;
-    static final int BASE_TRANSP_WINDOWS = BASE_TRANSP_WALLS + 9;
-    static final int BASE_DOORS_F = BASE_TRANSP_WINDOWS + 8;
-    static final int BASE_DOORS_S = BASE_DOORS_F + 8;
-    static final int BASE_DECOR_ITEM = BASE_DOORS_S + 8;
-    static final int BASE_DECOR_LAMP = BASE_DECOR_ITEM + 10;
-    static final int BASE_FLOOR = BASE_DECOR_LAMP + 2;
-    static final int BASE_CEIL = BASE_FLOOR + 10;
-
-    private static final int PACKED_WALLS = 1 << 16;
-    private static final int PACKED_TRANSP_WALLS = 2 << 16;
-    private static final int PACKED_TRANSP_WINDOWS = 4 << 16;
-    private static final int PACKED_DOORS_F = 5 << 16;
-    private static final int PACKED_DOORS_S = 6 << 16;
-    private static final int PACKED_OBJECTS = 7 << 16;
-    private static final int PACKED_DECOR_ITEM = 8 << 16;
-    private static final int PACKED_DECOR_LAMP = 9 << 16;
-    private static final int PACKED_FLOOR = 10 << 16;
-    private static final int PACKED_CEIL = 11 << 16;
-    private static final int PACKED_BULLETS = 12 << 16;
-    private static final int PACKED_ARROWS = 13 << 16;
-
-    // private static final int PACKED_TEXMAP_MONSTERS = 1 << 16;
-
-    static final int COUNT_MONSTER = 0x10; // block = [up, rt, dn, lt], monster = block[walk_a, walk_b, hit], die[3], shoot
-    static final int MONSTERS_IN_TEXTURE = 3;
-
-    public static final int ICON_JOY = BASE_ICONS;
-    public static final int ICON_MENU = BASE_ICONS + 1;
-    public static final int ICON_SHOOT = BASE_ICONS + 2;
-    @SuppressWarnings("WeakerAccess") public static final int ICON_MAP = BASE_ICONS + 3;
-    @SuppressWarnings("WeakerAccess") public static final int ICON_HEALTH = BASE_ICONS + 4;
-    @SuppressWarnings("WeakerAccess") public static final int ICON_ARMOR = BASE_ICONS + 5;
-    @SuppressWarnings("WeakerAccess") public static final int ICON_AMMO = BASE_ICONS + 6;
-    @SuppressWarnings("WeakerAccess") public static final int ICON_BLUE_KEY = BASE_ICONS + 7;
-    @SuppressWarnings("WeakerAccess") public static final int ICON_RED_KEY = BASE_ICONS + 8;
-    @SuppressWarnings("WeakerAccess") public static final int ICON_GREEN_KEY = BASE_ICONS + 9;
-
-    static final int OBJ_ARMOR_GREEN = BASE_OBJECTS - 1 + 1;
-    static final int OBJ_ARMOR_RED = BASE_OBJECTS - 1 + 2;
-    static final int OBJ_KEY_BLUE = BASE_OBJECTS - 1 + 3;
-    static final int OBJ_KEY_RED = BASE_OBJECTS - 1 + 4;
-    static final int OBJ_STIM = BASE_OBJECTS - 1 + 5;
-    static final int OBJ_MEDI = BASE_OBJECTS - 1 + 6;
-    static final int OBJ_CLIP = BASE_OBJECTS - 1 + 7;
-    static final int OBJ_CBOX = BASE_OBJECTS - 1 + 8;
-    static final int OBJ_SHELL = BASE_OBJECTS - 1 + 9;
-    static final int OBJ_SBOX = BASE_OBJECTS - 1 + 10;
-    static final int OBJ_BPACK = BASE_OBJECTS - 1 + 11;
-    static final int OBJ_WINCHESTER = BASE_OBJECTS - 1 + 12;
-    static final int OBJ_KEY_GREEN = BASE_OBJECTS - 1 + 13;
-    static final int OBJ_AK47 = BASE_OBJECTS - 1 + 14;
-    static final int OBJ_TMP = BASE_OBJECTS - 1 + 15;
-    static final int OBJ_DBLPIST = BASE_OBJECTS - 1 + 16;
-    static final int OBJ_GRENADE = BASE_OBJECTS - 1 + 17;
-    static final int OBJ_GBOX = BASE_OBJECTS - 1 + 18;
-    static final int OBJ_OPENMAP = BASE_OBJECTS - 1 + 19;
-
-    public static final int ARROW_UP = BASE_ARROWS - 1 + 1;
-    public static final int ARROW_RT = BASE_ARROWS - 1 + 2;
-    public static final int ARROW_DN = BASE_ARROWS - 1 + 3;
-    public static final int ARROW_LT = BASE_ARROWS - 1 + 4;
-
-    static final int[] WALL_LIGHTS = { BASE_WALLS - 1 + 7,
-            BASE_WALLS - 1 + 9,
-            BASE_WALLS - 1 + 10,
-            BASE_WALLS - 1 + 12,
-            BASE_WALLS - 1 + 20,
-            BASE_WALLS - 1 + 21,
-            BASE_WALLS - 1 + 22,
-            BASE_WALLS - 1 + 23,
-            BASE_WALLS - 1 + 24,
-            BASE_WALLS - 1 + 25,
-            BASE_WALLS - 1 + 26,
-            BASE_WALLS - 1 + 27,
-            BASE_WALLS - 1 + 28,
-            BASE_WALLS - 1 + 29,
-            BASE_WALLS - 1 + 30,
-            BASE_WALLS - 1 + 31,
-            BASE_WALLS - 1 + 32,
-            BASE_WALLS - 1 + 33,
-            BASE_WALLS - 1 + 34,
-            BASE_WALLS - 1 + 35, };
-
-    static final int[] DITEM_LIGHTS = { BASE_DECOR_ITEM - 1 + 1,
-            BASE_DECOR_ITEM - 1 + 2,
-            BASE_DECOR_ITEM - 1 + 8,
-            BASE_DECOR_ITEM - 1 + 10, };
-
-    static final int[] CEIL_LIGHTS = { BASE_CEIL - 1 + 2, BASE_CEIL - 1 + 4, BASE_CEIL - 1 + 6, };
-
-    static final int[] DLAMP_LIGHTS = { BASE_DECOR_LAMP - 1 + 1, };
-
-    public static class TextureToLoad {
-        @SuppressWarnings("WeakerAccess") public static final int TYPE_RESOURCE = 0;
-        public static final int TYPE_MAIN = 1;
-        public static final int TYPE_MONSTERS_1 = 2;
-        public static final int TYPE_MONSTERS_2 = 3;
-
-        public int tex;
-        public String pixelsName; // used in CachedTexturesProvider
-        public String alphaName; // used in CachedTexturesProvider
-        public int type;
-
-        TextureToLoad(int tex, String pixelsName, String alphaName) {
-            this.tex = tex;
-            this.pixelsName = pixelsName;
-            this.alphaName = alphaName;
-            this.type = TYPE_RESOURCE;
-        }
-
-        TextureToLoad(int tex, String pixelsName, String alphaName, int type) {
-            this.tex = tex;
-            this.pixelsName = pixelsName;
-            this.alphaName = alphaName;
-            this.type = type;
-        }
-    }
-
-    // @formatter:off
-	public static final TextureToLoad[] TEXTURES_TO_LOAD = {
-		new TextureToLoad(TEXTURE_MAIN, null, null, TextureToLoad.TYPE_MAIN),
-		new TextureToLoad(TEXTURE_MONSTERS_1, "texmap_mon_1_p", "texmap_mon_1_a", TextureToLoad.TYPE_MONSTERS_1),
-		new TextureToLoad(TEXTURE_MONSTERS_2, "texmap_mon_2_p", "texmap_mon_2_a", TextureToLoad.TYPE_MONSTERS_2),
-
-		new TextureToLoad(TEXTURE_KNIFE, "hit_knife_1_p", "hit_knife_1_a"),
-		new TextureToLoad(TEXTURE_KNIFE + 1, "hit_knife_2_p", "hit_knife_2_a"),
-		new TextureToLoad(TEXTURE_KNIFE + 2, "hit_knife_3_p", "hit_knife_3_a"),
-		new TextureToLoad(TEXTURE_KNIFE + 3, "hit_knife_4_p", "hit_knife_4_a"),
-
-		new TextureToLoad(TEXTURE_PISTOL, "hit_pist_1_p", "hit_pist_1_a"),
-		new TextureToLoad(TEXTURE_PISTOL + 1, "hit_pist_2_p", "hit_pist_2_a"),
-		new TextureToLoad(TEXTURE_PISTOL + 2, "hit_pist_3_p", "hit_pist_3_a"),
-		new TextureToLoad(TEXTURE_PISTOL + 3, "hit_pist_4_p", "hit_pist_4_a"),
-
-		new TextureToLoad(TEXTURE_DBLPISTOL, "hit_dblpist_1_p", "hit_dblpist_1_a"),
-		new TextureToLoad(TEXTURE_DBLPISTOL + 1, "hit_dblpist_2_p", "hit_dblpist_2_a"),
-		new TextureToLoad(TEXTURE_DBLPISTOL + 2, "hit_dblpist_3_p", "hit_dblpist_3_a"),
-		new TextureToLoad(TEXTURE_DBLPISTOL + 3, "hit_dblpist_4_p", "hit_dblpist_4_a"),
-
-		new TextureToLoad(TEXTURE_SHTG, "hit_shtg_1_p", "hit_shtg_1_a"),
-		new TextureToLoad(TEXTURE_SHTG + 1, "hit_shtg_2_p", "hit_shtg_2_a"),
-		new TextureToLoad(TEXTURE_SHTG + 2, "hit_shtg_3_p", "hit_shtg_3_a"),
-		new TextureToLoad(TEXTURE_SHTG + 3, "hit_shtg_4_p", "hit_shtg_4_a"),
-		new TextureToLoad(TEXTURE_SHTG + 4, "hit_shtg_5_p", "hit_shtg_5_a"),
-
-		new TextureToLoad(TEXTURE_AK47, "hit_ak47_1_p", "hit_ak47_1_a"),
-		new TextureToLoad(TEXTURE_AK47 + 1, "hit_ak47_2_p", "hit_ak47_2_a"),
-		new TextureToLoad(TEXTURE_AK47 + 2, "hit_ak47_3_p", "hit_ak47_3_a"),
-		new TextureToLoad(TEXTURE_AK47 + 3, "hit_ak47_4_p", "hit_ak47_4_a"),
-
-		new TextureToLoad(TEXTURE_TMP, "hit_tmp_1_p", "hit_tmp_1_a"),
-		new TextureToLoad(TEXTURE_TMP + 1, "hit_tmp_2_p", "hit_tmp_2_a"),
-		new TextureToLoad(TEXTURE_TMP + 2, "hit_tmp_3_p", "hit_tmp_3_a"),
-		new TextureToLoad(TEXTURE_TMP + 3, "hit_tmp_4_p", "hit_tmp_4_a"),
-
-		new TextureToLoad(TEXTURE_GRENADE, "hit_rocket_1_p", "hit_rocket_1_a"),
-		new TextureToLoad(TEXTURE_GRENADE + 1, "hit_rocket_2_p", "hit_rocket_2_a"),
-		new TextureToLoad(TEXTURE_GRENADE + 2, "hit_rocket_3_p", "hit_rocket_3_a"),
-		new TextureToLoad(TEXTURE_GRENADE + 3, "hit_rocket_4_p", "hit_rocket_4_a"),
-		new TextureToLoad(TEXTURE_GRENADE + 4, "hit_rocket_5_p", "hit_rocket_5_a"),
-		new TextureToLoad(TEXTURE_GRENADE + 5, "hit_rocket_6_p", "hit_rocket_6_a"),
-		new TextureToLoad(TEXTURE_GRENADE + 6, "hit_rocket_7_p", "hit_rocket_7_a"),
-		new TextureToLoad(TEXTURE_GRENADE + 7, "hit_rocket_8_p", "hit_rocket_8_a"),
-
-		new TextureToLoad(TEXTURE_SKY, "sky_1", null),
-	};
-    // @formatter:on
-
-    private Engine engine;
-    private State state;
-    private AssetManager assetManager;
-    private boolean texturesInitialized;
-    private LevelConfig levelConf;
-
-    public int[] textures = new int[TEXTURE_LAST];
-
-    @Override
-    public void setEngine(Engine engine) {
-        this.engine = engine;
-        this.state = engine.state;
-        this.assetManager = App.self.getAssets();
-    }
-
-    private void loadAndBindTexture(GL10 gl, int tex, int set) {
-        Bitmap img = BitmapFactory.decodeFile(CachedTexturesProvider.getCachePath(tex, set));
-
-        if (img == null) {
-            final String errorMessage = "Can't load cached bitmap";
-            Common.showToast(errorMessage);
-            throw new RuntimeException(errorMessage);
-        }
-
-        gl.glBindTexture(GL10.GL_TEXTURE_2D, textures[tex]);
-        GLUtils.texImage2D(GL10.GL_TEXTURE_2D, 0, img, 0);
-
-        img.recycle();
-
-        //noinspection UnusedAssignment
-        img = null;
-    }
-
-    @SuppressLint("ObsoleteSdkInt")
-    void onSurfaceCreated(GL10 gl) {
-        if (texturesInitialized) {
-            gl.glDeleteTextures(TEXTURE_LAST, textures, 0);
-        }
-
-        texturesInitialized = true;
-        gl.glGenTextures(TEXTURE_LAST, textures, 0);
-
-        //        GPU,    ,
-        //  inPurgeable    ,      -   
-        //     inInputShareable        
-        BitmapFactory.Options bitmapOptions = new BitmapFactory.Options();
-        bitmapOptions.inDither = false;
-        bitmapOptions.inScaled = false;
-        bitmapOptions.inPurgeable = false;
-        bitmapOptions.inInputShareable = false;
-
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
-            //    ,         -null-
-            bitmapOptions.inMutable = true;
-        }
-
-        Bitmap img = CachedTexturesProvider.decodeTexture(assetManager, "tex_loading", bitmapOptions);
-        gl.glBindTexture(GL10.GL_TEXTURE_2D, textures[TEXTURE_LOADING]);
-        GLUtils.texImage2D(GL10.GL_TEXTURE_2D, 0, img, 0);
-        img.recycle();
-
-        //noinspection UnusedAssignment
-        img = null;
-
-        img = Common.createBitmap(RENDER_TO_SIZE, RENDER_TO_SIZE, "Can't alloc bitmap for render buffer");
-        gl.glBindTexture(GL10.GL_TEXTURE_2D, textures[TEXTURE_RENDER_TO]);
-        GLUtils.texImage2D(GL10.GL_TEXTURE_2D, 0, img, 0);
-        img.recycle();
-
-        //noinspection UnusedAssignment
-        img = null;
-
-        if (engine.fboSupported) {
-            gl.glBindTexture(GL10.GL_TEXTURE_2D, textures[TEXTURE_RENDER_TO_FBO]);
-
-            gl.glTexImage2D(GL10.GL_TEXTURE_2D,
-                    0,
-                    GL10.GL_RGBA,
-                    RENDER_TO_FBO_SIZE,
-                    RENDER_TO_FBO_SIZE,
-                    0,
-                    GL10.GL_RGBA,
-                    GL10.GL_UNSIGNED_BYTE,
-                    null);
-        }
-
-        System.gc();
-    }
-
-    @SuppressWarnings("UnusedReturnValue")
-    boolean loadTexture(GL10 gl, int createdTexturesCount) {
-        if (createdTexturesCount >= TEXTURES_TO_LOAD.length) {
-            return false;
-        }
-
-        if (createdTexturesCount == 0) {
-            levelConf = LevelConfig.read(assetManager, state.levelName);
-        }
-
-        TextureToLoad texToLoad = TEXTURES_TO_LOAD[createdTexturesCount];
-
-        if (texToLoad.type == TextureToLoad.TYPE_MAIN) {
-            loadAndBindTexture(gl,
-                    texToLoad.tex,
-                    CachedTexturesProvider.normalizeSetNum(CachedTexturesProvider.mainTexMap, levelConf.graphicsSet));
-        } else {
-            loadAndBindTexture(gl, texToLoad.tex, 0);
-        }
-
-        return true;
-    }
-
-    static int packTexId(int texId) {
-        if (texId >= BASE_CEIL) {
-            return (texId - BASE_CEIL) | PACKED_CEIL;
-        } else if (texId >= BASE_FLOOR) {
-            return (texId - BASE_FLOOR) | PACKED_FLOOR;
-        } else if (texId >= BASE_DECOR_LAMP) {
-            return (texId - BASE_DECOR_LAMP) | PACKED_DECOR_LAMP;
-        } else if (texId >= BASE_DECOR_ITEM) {
-            return (texId - BASE_DECOR_ITEM) | PACKED_DECOR_ITEM;
-        } else if (texId >= BASE_DOORS_S) {
-            return (texId - BASE_DOORS_S) | PACKED_DOORS_S;
-        } else if (texId >= BASE_DOORS_F) {
-            return (texId - BASE_DOORS_F) | PACKED_DOORS_F;
-        } else if (texId >= BASE_TRANSP_WINDOWS) {
-            return (texId - BASE_TRANSP_WINDOWS) | PACKED_TRANSP_WINDOWS;
-        } else if (texId >= BASE_TRANSP_WALLS) {
-            return (texId - BASE_TRANSP_WALLS) | PACKED_TRANSP_WALLS;
-        } else if (texId >= BASE_WALLS) {
-            return (texId - BASE_WALLS) | PACKED_WALLS;
-        } else if (texId >= BASE_ARROWS) {
-            return (texId - BASE_ARROWS) | PACKED_ARROWS;
-        } else if (texId >= BASE_EXPLOSIONS) {
-            return texId; // do not pack explosions, because actually is isn't texture, but animation frame
-        } else if (texId >= BASE_BULLETS) {
-            return (texId - BASE_BULLETS) | PACKED_BULLETS;
-        } else if (texId >= BASE_OBJECTS) {
-            return (texId - BASE_OBJECTS) | PACKED_OBJECTS;
-        } else {
-            return texId;
-        }
-    }
-
-    @SuppressWarnings("MagicNumber")
-    static int unpackTexId(int texId) {
-        if (texId <= 0) {
-            return texId;
-        }
-
-        int texBase = texId & 0xFFFF;
-
-        switch (texId & 0xF0000) {
-            case PACKED_WALLS:
-                return texBase + BASE_WALLS;
-
-            case PACKED_TRANSP_WALLS:
-                return texBase + BASE_TRANSP_WALLS;
-
-            case PACKED_TRANSP_WINDOWS:
-                return texBase + BASE_TRANSP_WINDOWS;
-
-            case PACKED_DOORS_F:
-                return texBase + BASE_DOORS_F;
-
-            case PACKED_DOORS_S:
-                return texBase + BASE_DOORS_S;
-
-            case PACKED_OBJECTS:
-                return texBase + BASE_OBJECTS;
-
-            case PACKED_DECOR_ITEM:
-                return texBase + BASE_DECOR_ITEM;
-
-            case PACKED_DECOR_LAMP:
-                return texBase + BASE_DECOR_LAMP;
-
-            case PACKED_FLOOR:
-                return texBase + BASE_FLOOR;
-
-            case PACKED_CEIL:
-                return texBase + BASE_CEIL;
-
-            case PACKED_BULLETS:
-                return texBase + BASE_BULLETS;
-
-            case PACKED_ARROWS:
-                return texBase + BASE_ARROWS;
-
-            default:
-                return texBase;
-        }
-    }
-}
diff --git a/src/main/java/zame/game/engine/WaveCell.java b/src/main/java/zame/game/engine/WaveCell.java
deleted file mode 100644
index 6d29342..0000000
--- a/src/main/java/zame/game/engine/WaveCell.java
+++ /dev/null
@@ -1,11 +0,0 @@
-package zame.game.engine;
-
-class WaveCell {
-    int x;
-    int y;
-
-    void initFrom(int x, int y) {
-        this.x = x;
-        this.y = y;
-    }
-}
diff --git a/src/main/java/zame/game/engine/Weapons.java b/src/main/java/zame/game/engine/Weapons.java
deleted file mode 100644
index 03ccbea..0000000
--- a/src/main/java/zame/game/engine/Weapons.java
+++ /dev/null
@@ -1,464 +0,0 @@
-package zame.game.engine;
-
-import javax.microedition.khronos.opengles.GL10;
-import zame.game.managers.SoundManager;
-
-public class Weapons implements EngineObject {
-    public static class WeaponParams {
-        int[] cycle;
-        int needAmmo;
-        int hits;
-        int hitTimeout; //    ""   
-        int textureBase;
-        float xmult;
-        float xoff;
-        float hgt;
-        int soundIdx;
-        boolean isNear;
-        int noHitSoundIdx;
-        int hitsPerSecond;
-
-        public int ammoIdx;
-        public String name;
-        public String description;
-
-        WeaponParams(int[] cycle,
-                int ammoIdx,
-                int needAmmo,
-                int hits,
-                int hitTimeout,
-                int textureBase,
-                float xmult,
-                float xoff,
-                float hgt,
-                int soundIdx,
-                boolean isNear,
-                int noHitSoundIdx,
-                int hitsPerSecond,
-                String name) {
-
-            this.cycle = cycle;
-            this.ammoIdx = ammoIdx;
-            this.needAmmo = needAmmo;
-            this.hits = hits;
-            this.hitTimeout = hitTimeout;
-            this.textureBase = textureBase;
-            this.xmult = xmult;
-            this.xoff = xoff;
-            this.hgt = hgt;
-            this.soundIdx = soundIdx;
-            this.isNear = isNear;
-            this.noHitSoundIdx = noHitSoundIdx;
-            this.hitsPerSecond = hitsPerSecond;
-            this.name = name;
-
-            makeDescription();
-        }
-
-        void makeDescription() {
-            StringBuilder sb = new StringBuilder(name);
-
-            if (isNear) {
-                sb.append(" / MELEE");
-            }
-
-            int damage = 0;
-
-            //noinspection ForLoopReplaceableByForEach
-            for (int i = 0; i < cycle.length; i++) {
-                if (cycle[i] < 0) {
-                    damage += hits;
-                }
-            }
-
-            sb.append(" / DPS ");
-            sb.append(hitsPerSecond * damage);
-            sb.append(" / STUN ");
-            sb.append(hitTimeout);
-
-            if (needAmmo > 0) {
-                sb.append(" / AMMO ");
-                sb.append(needAmmo);
-            }
-
-            description = sb.toString();
-        }
-    }
-
-    static final int AMMO_CLIP = 0;
-    static final int AMMO_SHELL = 1;
-    static final int AMMO_GRENADE = 2;
-    static final int AMMO_LAST = 3;
-
-    static final int[] AMMO_OBJ_TEX_MAP = { TextureLoader.OBJ_CLIP,
-            TextureLoader.OBJ_SHELL,
-            TextureLoader.OBJ_GRENADE, };
-
-    public static final int WEAPON_KNIFE = 0; // required to be 0
-    public static final int WEAPON_PISTOL = 1; // AMMO_CLIP
-    public static final int WEAPON_DBLPISTOL = 2; // AMMO_CLIP
-    public static final int WEAPON_AK47 = 3; // AMMO_SHELL
-    public static final int WEAPON_TMP = 4; // AMMO_SHELL
-    public static final int WEAPON_WINCHESTER = 5; // AMMO_SHELL
-    public static final int WEAPON_GRENADE = 6; // AMMO_GRENADE
-    @SuppressWarnings("WeakerAccess") public static final int WEAPON_LAST = 7;
-
-    private static final float WALK_OFFSET_X = 1.0f / 8.0f;
-    private static final float DEFAULT_HEIGHT = 1.5f;
-
-    // 1 frame = 1s / Engine.FRAMES_PER_SECOND = 1s / 40 = 0.025s
-    // 1s = 40 frames
-
-    // @formatter:off
-	public static final WeaponParams[] WEAPONS = {
-		// WEAPON_KNIFE (2 hits per second)
-		new WeaponParams(
-			new int[] {
-				0,
-                3, 3, 3,
-                2, 2, 2,
-                -1, 1, 1,
-                3, 3, 3,
-                0, 0, 0, 0, 0, 0, 0
-			},
-			-1, 0,
-			GameParams.HEALTH_HIT_KNIFE, GameParams.STUN_KNIFE,
-			TextureLoader.TEXTURE_KNIFE, 1.0f, 0.0f, DEFAULT_HEIGHT,
-			SoundManager.SOUND_SHOOT_KNIFE, true, SoundManager.SOUND_NO_WAY,
-			2, "KNIFE"
-		),
-		// WEAPON_PISTOL (2 hits per second)
-		new WeaponParams(
-			new int[] {
-				0,
-				-1, 1, 1, 1, 1,
-				2, 2, 2, 2, 2,
-				3, 3, 3, 3, 3,
-				0, 0, 0, 0
-			},
-			AMMO_CLIP, 1,
-			GameParams.HEALTH_HIT_PISTOL, GameParams.STUN_PISTOL,
-			TextureLoader.TEXTURE_PISTOL, 1.0f, 0.0f, DEFAULT_HEIGHT,
-			SoundManager.SOUND_SHOOT_PISTOL, false, 0,
-			2, "PISTOL"
-		),
-		// WEAPON_DBLPISTOL (4 hits per second = 2 cycles per second)
-		new WeaponParams(
-			new int[] {
-				0,
-				-1, 1, 1, 1, 1,
-				-2, 2, 2, 2, 2,
-				3, 3, 3, 3, 3,
-				0, 0, 0, 0
-			},
-			AMMO_CLIP, 1,
-			GameParams.HEALTH_HIT_DBLPISTOL, GameParams.STUN_DBLPISTOL,
-			TextureLoader.TEXTURE_DBLPISTOL, 1.0f, 0.0f, DEFAULT_HEIGHT,
-			SoundManager.SOUND_SHOOT_DBLPISTOL, false, 0,
-			4, "DOUBLE PISTOL"
-		),
-		// WEAPON_AK47 (2 hits per second)
-		new WeaponParams(
-			new int[] {
-				0,
-				-1, 1,
-				2, 2,
-				3, 3,
-				0
-			},
-			AMMO_SHELL, 1,
-			GameParams.HEALTH_HIT_AK47, GameParams.STUN_AK47,
-			TextureLoader.TEXTURE_AK47, 1.0f, 0.0f, DEFAULT_HEIGHT,
-			SoundManager.SOUND_SHOOT_AK47, false, 0,
-			2, "AK-47"
-		),
-		// WEAPON_TMP (4 hits per second)
-		new WeaponParams(
-			new int[] {
-				0,
-				-1,
-				2,
-				3,
-			},
-			AMMO_SHELL, 1,
-			GameParams.HEALTH_HIT_TMP, GameParams.STUN_TMP,
-			TextureLoader.TEXTURE_TMP, 1.0f, 0.0f, DEFAULT_HEIGHT,
-			SoundManager.SOUND_SHOOT_TMP, false, 0,
-			4, "TMP"
-		),
-		// WEAPON_WINCHESTER (1 hits per second)
-		new WeaponParams(
-			new int[] {
-				0, 0, 0, 0, 0,
-				1, 1, 1, 1, 1,
-				-2, 2, 2, 2, 2,
-				3, 3, 3, 3, 3,
-				4, 4, 4, 4, 4,
-				0, 0, 0, 0, 0,
-				0, 0, 0, 0, 0,
-				0, 0, 0, 0, 0,
-			},
-			AMMO_SHELL, 1,
-			GameParams.HEALTH_HIT_WINCHESTER, GameParams.STUN_WINCHESTER,
-			TextureLoader.TEXTURE_SHTG, 1.0f, 0.0f, DEFAULT_HEIGHT,
-			SoundManager.SOUND_SHOOT_WINCHESTER, false, 0,
-			1, "WINCHESTER"
-		),
-		// WEAPON_GRENADE (1 hit per second)
-		new WeaponParams(
-			new int[] {
-				0,
-				1, 1, 1, 1,
-				2, 2, 2, 2,
-				3, 3, 3, 3,
-				4, 4, 4, 4,
-				5, 5, 5, 5,
-				6, 6, 6, 6,
-				-7, 7, 7, 7,
-				0, 0, 0,
-			},
-			AMMO_GRENADE, 1,
-			GameParams.HEALTH_HIT_GRENADE, GameParams.STUN_GRENADE,
-			TextureLoader.TEXTURE_GRENADE,
-            1.0f + WALK_OFFSET_X, // xmult
-            WALK_OFFSET_X, // xoff
-            DEFAULT_HEIGHT * (1.0f + WALK_OFFSET_X), // hgt
-			SoundManager.SOUND_SHOOT_GRENADE, false, 0,
-			1, "GRENADE"
-		),
-	};
-    // @formatter:on
-
-    private Engine engine;
-    private State state;
-    private Renderer renderer;
-    private TextureLoader textureLoader;
-    private int changeWeaponNext;
-    private long changeWeaponTime;
-
-    public WeaponParams currentParams;
-
-    int[] currentCycle;
-    int shootCycle;
-    int changeWeaponDir;
-
-    @Override
-    public void setEngine(Engine engine) {
-        this.engine = engine;
-        this.state = engine.state;
-        this.renderer = engine.renderer;
-        this.textureLoader = engine.textureLoader;
-    }
-
-    public void init() {
-        shootCycle = 0;
-        changeWeaponDir = 0;
-        updateWeapon();
-    }
-
-    void updateWeapon() {
-        currentParams = WEAPONS[state.heroWeapon];
-        currentCycle = currentParams.cycle;
-        shootCycle = 0;
-    }
-
-    public void switchWeapon(int weaponIdx) {
-        changeWeaponNext = weaponIdx;
-        changeWeaponTime = engine.elapsedTime;
-        changeWeaponDir = -1;
-
-        if (state.heroWeapon != weaponIdx) {
-            for (OnChangeWeaponAction onChangeWeaponAction = state.onChangeWeaponActions.first();
-                    onChangeWeaponAction != null; ) {
-
-                OnChangeWeaponAction nextOnChangeWeaponAction = (OnChangeWeaponAction)onChangeWeaponAction.next;
-                engine.level.executeActions(onChangeWeaponAction.markId);
-                state.onChangeWeaponActions.release(onChangeWeaponAction);
-
-                //noinspection AssignmentToForLoopParameter
-                onChangeWeaponAction = nextOnChangeWeaponAction;
-            }
-        }
-
-        int lastWeaponsLen = state.lastWeapons.length;
-
-        for (int i = 0; i < lastWeaponsLen; i++) {
-            if (state.lastWeapons[i] == weaponIdx) {
-                return;
-            }
-        }
-
-        for (int i = 0; i < lastWeaponsLen; i++) {
-            state.lastWeaponIdx = (state.lastWeaponIdx + 1) % lastWeaponsLen;
-
-            if (state.lastWeapons[state.lastWeaponIdx] < 0) {
-                state.lastWeapons[state.lastWeaponIdx] = weaponIdx;
-                return;
-            }
-        }
-
-        for (int i = 0; i < lastWeaponsLen; i++) {
-            state.lastWeaponIdx = (state.lastWeaponIdx + 1) % lastWeaponsLen;
-
-            if (state.lastWeapons[state.lastWeaponIdx] != state.heroWeapon) {
-                state.lastWeapons[state.lastWeaponIdx] = weaponIdx;
-                return;
-            }
-        }
-    }
-
-    boolean hasNoAmmo(int weaponIdx) {
-        return ((WEAPONS[weaponIdx].ammoIdx >= 0) && (state.heroAmmo[WEAPONS[weaponIdx].ammoIdx]
-                < WEAPONS[weaponIdx].needAmmo));
-    }
-
-    public boolean canSwitch(int weaponIdx) {
-        return (state.heroHasWeapon[weaponIdx] && !hasNoAmmo(weaponIdx));
-    }
-
-    void nextWeapon() {
-        int resWeapon = (state.heroWeapon + 1) % WEAPON_LAST;
-
-        while ((resWeapon != 0) && (!state.heroHasWeapon[resWeapon] || hasNoAmmo(resWeapon))) {
-            resWeapon = (resWeapon + 1) % WEAPON_LAST;
-        }
-
-        switchWeapon(resWeapon);
-    }
-
-    int getBestWeapon() {
-        int resWeapon = WEAPON_LAST - 1;
-
-        while (resWeapon > 0 && (!state.heroHasWeapon[resWeapon]
-                || hasNoAmmo(resWeapon)
-                || WEAPONS[resWeapon].isNear
-                || WEAPONS[resWeapon].ammoIdx == AMMO_GRENADE)) {
-
-            resWeapon--;
-        }
-
-        if (resWeapon == 0) {
-            resWeapon = WEAPON_LAST - 1;
-
-            while (resWeapon > 0 && (!state.heroHasWeapon[resWeapon]
-                    || hasNoAmmo(resWeapon)
-                    || !(WEAPONS[resWeapon].isNear || WEAPONS[resWeapon].ammoIdx == AMMO_GRENADE))) {
-
-                resWeapon--;
-            }
-        }
-
-        return resWeapon;
-    }
-
-    void selectBestWeapon() {
-        int bestWeapon = getBestWeapon();
-
-        if (bestWeapon != state.heroWeapon) {
-            switchWeapon(bestWeapon);
-        }
-    }
-
-    @SuppressWarnings("MagicNumber")
-    public void render(GL10 gl, long walkTime) {
-        renderer.r1 = 1.0f;
-        renderer.g1 = 1.0f;
-        renderer.b1 = 1.0f;
-        renderer.a1 = 1.0f;
-        renderer.r2 = 1.0f;
-        renderer.g2 = 1.0f;
-        renderer.b2 = 1.0f;
-        renderer.a2 = 1.0f;
-        renderer.r3 = 1.0f;
-        renderer.g3 = 1.0f;
-        renderer.b3 = 1.0f;
-        renderer.a3 = 1.0f;
-        renderer.r4 = 1.0f;
-        renderer.g4 = 1.0f;
-        renderer.b4 = 1.0f;
-        renderer.a4 = 1.0f;
-
-        renderer.z1 = 0.0f;
-        renderer.z2 = 0.0f;
-        renderer.z3 = 0.0f;
-        renderer.z4 = 0.0f;
-
-        gl.glDisable(GL10.GL_DEPTH_TEST);
-        gl.glEnable(GL10.GL_BLEND);
-        gl.glBlendFunc(GL10.GL_ONE, GL10.GL_ONE_MINUS_SRC_ALPHA);
-
-        renderer.initOrtho(gl, true, false, -1.0f, 1.0f, 0.0f, 2.0f, 0.0f, 1.0f);
-        gl.glDisable(GL10.GL_ALPHA_TEST);
-
-        renderer.init();
-
-        float yoff = 0;
-
-        if (changeWeaponDir == -1) {
-            yoff = (float)(engine.elapsedTime - changeWeaponTime) / 150.0f;
-
-            if (yoff >= currentParams.hgt + 0.1f) {
-                state.heroWeapon = changeWeaponNext;
-                updateWeapon();
-
-                changeWeaponDir = 1;
-                changeWeaponTime = engine.elapsedTime;
-            }
-        } else if (changeWeaponDir == 1) {
-            yoff = currentParams.hgt + 0.1f - (float)(engine.elapsedTime - changeWeaponTime) / 150.0f;
-
-            if (yoff <= 0.0f) {
-                yoff = 0.0f;
-                changeWeaponDir = 0;
-            }
-        }
-
-        float xoff = (float)Math.sin((float)walkTime / 150.0f) * WALK_OFFSET_X;
-        float xlt = -currentParams.xmult + currentParams.xoff + xoff;
-        float xrt = currentParams.xmult + currentParams.xoff + xoff;
-
-        yoff += Math.abs((float)Math.sin((float)walkTime / 150.0f + GameMath.PI_F / 2.0f)) * 0.1f + 0.05f;
-        float hgt = currentParams.hgt - yoff;
-
-        renderer.x1 = xlt;
-        renderer.y1 = -yoff;
-        renderer.x2 = xlt;
-        renderer.y2 = hgt;
-        renderer.x3 = xrt;
-        renderer.y3 = hgt;
-        renderer.x4 = xrt;
-        renderer.y4 = -yoff;
-
-        renderer.u1 = 0;
-        renderer.v1 = 1 << 16;
-        renderer.u2 = 0;
-        renderer.v2 = 0;
-        renderer.u3 = 1 << 16;
-        renderer.v3 = 0;
-        renderer.u4 = 1 << 16;
-        renderer.v4 = 1 << 16;
-
-        renderer.drawQuad();
-
-        // just for case
-        if (shootCycle > currentCycle.length) {
-            shootCycle = 0;
-        }
-
-        int weaponTexture = currentCycle[shootCycle];
-
-        if (weaponTexture < -1000) {
-            weaponTexture = -1000 - weaponTexture;
-        } else if (weaponTexture < 0) {
-            weaponTexture = -weaponTexture;
-        }
-
-        renderer.bindTextureCtl(gl, textureLoader.textures[currentParams.textureBase + weaponTexture]);
-        renderer.flush(gl);
-
-        gl.glMatrixMode(GL10.GL_PROJECTION);
-        gl.glPopMatrix();
-
-        gl.glDisable(GL10.GL_ALPHA_TEST);
-    }
-}
diff --git a/src/main/java/zame/game/engine/HeroController.java b/src/main/java/zame/game/engine/controller/HeroController.java
similarity index 76%
rename from src/main/java/zame/game/engine/HeroController.java
rename to src/main/java/zame/game/engine/controller/HeroController.java
index 5f34795..0f1f60d 100644
--- a/src/main/java/zame/game/engine/HeroController.java
+++ b/src/main/java/zame/game/engine/controller/HeroController.java
@@ -1,7 +1,7 @@
-package zame.game.engine;
+package zame.game.engine.controller;
 
 import android.view.MotionEvent;
-import javax.microedition.khronos.opengles.GL10;
+import zame.game.engine.EngineObject;
 
 public abstract class HeroController implements EngineObject {
     public static HeroController newInstance(@SuppressWarnings("unused") boolean isWallpaper) {
@@ -19,11 +19,10 @@ public abstract class HeroController implements EngineObject {
     public void onDrawFrame() {
     }
 
-    @SuppressWarnings("WeakerAccess")
-    public void updateAfterLoadOrCreate() {
+    public void updateAfterLevelLoadedOrCreated() {
     }
 
-    public void renderControls(GL10 gl, boolean canRenderHelp, long firstTouchTime) {
+    public void render(boolean canRenderHelp, long firstTouchTime) {
     }
 
     public boolean onKeyUp(int keyCode) {
diff --git a/src/main/java/zame/game/engine/controller/HeroControllerHuman.java b/src/main/java/zame/game/engine/controller/HeroControllerHuman.java
new file mode 100644
index 0000000..302c63a
--- /dev/null
+++ b/src/main/java/zame/game/engine/controller/HeroControllerHuman.java
@@ -0,0 +1,77 @@
+package zame.game.engine.controller;
+
+import android.view.MotionEvent;
+import zame.game.engine.Engine;
+import zame.game.engine.controls.AccelerometerController;
+import zame.game.engine.controls.KeysController;
+import zame.game.engine.visual.Controls;
+
+public class HeroControllerHuman extends HeroController {
+    private Engine engine;
+    private Controls controls = new Controls();
+    private AccelerometerController accelerometerController = new AccelerometerController();
+    private KeysController keysController = new KeysController();
+
+    @Override
+    public void onCreate(Engine engine) {
+        this.engine = engine;
+
+        controls.onCreate(engine);
+        accelerometerController.onCreate(engine);
+        keysController.onCreate(engine);
+    }
+
+    @Override
+    public void onDrawFrame() {
+        keysController.onDrawFrame();
+    }
+
+    @Override
+    public void updateHero() {
+        controls.updateHero();
+        accelerometerController.updateHero();
+        keysController.updateHero();
+    }
+
+    @Override
+    public void reload() {
+        controls.reload();
+        accelerometerController.reload();
+        keysController.reload();
+    }
+
+    @Override
+    public void surfaceSizeChanged() {
+        controls.surfaceSizeChanged();
+    }
+
+    @Override
+    public void render(boolean canRenderHelp, long firstTouchTime) {
+        controls.render(canRenderHelp, engine.elapsedTime, firstTouchTime);
+    }
+
+    @Override
+    public boolean onKeyUp(int keyCode) {
+        return keysController.onKeyUp(keyCode);
+    }
+
+    @Override
+    public boolean onKeyDown(int keyCode) {
+        return keysController.onKeyDown(keyCode);
+    }
+
+    @Override
+    public void onTouchEvent(MotionEvent event) {
+        controls.touchEvent(event);
+    }
+
+    @Override
+    public void onTrackballEvent(MotionEvent event) {
+        keysController.onTrackballEvent(event);
+    }
+
+    @Override
+    public void setAccelerometerValues(float accelerometerX, float accelerometerY) {
+        accelerometerController.setAccelerometerValues(accelerometerX, accelerometerY);
+    }
+}
diff --git a/src/main/java/zame/game/engine/controls/AccelerometerController.java b/src/main/java/zame/game/engine/controls/AccelerometerController.java
index 6577d78..fda7b20 100644
--- a/src/main/java/zame/game/engine/controls/AccelerometerController.java
+++ b/src/main/java/zame/game/engine/controls/AccelerometerController.java
@@ -3,7 +3,8 @@ package zame.game.engine.controls;
 import zame.game.engine.Config;
 import zame.game.engine.Engine;
 import zame.game.engine.EngineObject;
-import zame.game.engine.State;
+import zame.game.engine.state.State;
+import zame.game.engine.visual.Controls;
 
 public class AccelerometerController implements EngineObject {
     private Engine engine;
@@ -12,7 +13,7 @@ public class AccelerometerController implements EngineObject {
     private float accelerometerX;
 
     @Override
-    public void setEngine(Engine engine) {
+    public void onCreate(Engine engine) {
         this.engine = engine;
         this.config = engine.config;
         this.state = engine.state;
diff --git a/src/main/java/zame/game/engine/controls/KeysController.java b/src/main/java/zame/game/engine/controls/KeysController.java
index bb5baaf..e3259e3 100644
--- a/src/main/java/zame/game/engine/controls/KeysController.java
+++ b/src/main/java/zame/game/engine/controls/KeysController.java
@@ -6,7 +6,8 @@ import zame.game.engine.Config;
 import zame.game.engine.Engine;
 import zame.game.engine.EngineObject;
 import zame.game.engine.Game;
-import zame.game.engine.State;
+import zame.game.engine.state.State;
+import zame.game.engine.visual.Controls;
 
 public class KeysController implements EngineObject {
     public static class ControlAcceleration {
@@ -62,7 +63,7 @@ public class KeysController implements EngineObject {
     // @formatter:on
 
     @Override
-    public void setEngine(Engine engine) {
+    public void onCreate(Engine engine) {
         this.engine = engine;
         this.config = engine.config;
         this.game = engine.game;
@@ -87,7 +88,6 @@ public class KeysController implements EngineObject {
         int maskUp;
         int maskDown;
 
-        // TODO: test it
         if (config.rotateScreen) {
             trackballX = -trackballX;
             trackballY = -trackballY;
diff --git a/src/main/java/zame/game/engine/controls/OnScreenButton.java b/src/main/java/zame/game/engine/controls/OnScreenButton.java
index e92943a..961088d 100644
--- a/src/main/java/zame/game/engine/controls/OnScreenButton.java
+++ b/src/main/java/zame/game/engine/controls/OnScreenButton.java
@@ -1,12 +1,18 @@
 package zame.game.engine.controls;
 
-import javax.microedition.khronos.opengles.GL10;
-import zame.game.engine.Labels;
-import zame.game.engine.TextureLoader;
+import zame.game.App;
+import zame.game.engine.Game;
+import zame.game.engine.graphics.Labels;
+import zame.game.engine.graphics.TextureLoader;
+import zame.game.engine.util.GameMath;
+import zame.game.engine.visual.Controls;
 
 public class OnScreenButton extends OnScreenController {
-    static final int TYPE_GAME_MENU = 1;
+    public static final int TYPE_GAME_MENU = 1;
+    public static final int TYPE_RESTART = 2;
+    public static final int TYPE_REWARDED_CONTINUE = 3;
 
+    public boolean isVisible = true;
     private int type;
     private float fromX;
     private float fromY;
@@ -14,16 +20,25 @@ public class OnScreenButton extends OnScreenController {
     private float toY;
     private boolean active;
 
-    OnScreenButton(int position, int type) {
+    public OnScreenButton(int position, int type) {
         super();
 
         this.position = position;
         this.type = type;
 
-        if (type == TYPE_GAME_MENU) {
-            this.renderAnyway = true;
-            this.controlFlags = Controls.CONTROL_WEAPONS;
-            this.helpLabelId = Labels.LABEL_HELP_WEAPONS;
+        switch (type) {
+            case TYPE_GAME_MENU:
+                this.renderAnyway = true;
+                this.controlFlags = Controls.CONTROL_WEAPONS;
+                this.helpLabelId = Labels.LABEL_HELP_WEAPONS;
+                break;
+
+            case TYPE_RESTART:
+                // fallthrough
+
+            case TYPE_REWARDED_CONTINUE:
+                this.renderModeMask = Game.RENDER_MODE_GAME_OVER;
+                break;
         }
     }
 
@@ -32,9 +47,9 @@ public class OnScreenButton extends OnScreenController {
     public void surfaceSizeChanged() {
         super.surfaceSizeChanged();
 
-        float btnOffsetX = owner.iconSize * 0.55f;
-        float btnOffsetY = owner.iconSize * 0.55f;
-        float btnClickArea = owner.iconSize * 0.5f;
+        float btnOffsetX = (type == TYPE_GAME_MENU ? owner.iconSize * 0.55f : owner.iconSize * 2.0f);
+        float btnOffsetY = (type == TYPE_GAME_MENU ? owner.iconSize * 0.55f : owner.iconSize * 1.5f);
+        float btnClickArea = (type == TYPE_GAME_MENU ? owner.iconSize * 0.5f : owner.iconSize * 1.5f);
 
         if ((position & Controls.POSITION_TOP) != 0) {
             startY = btnOffsetY;
@@ -44,6 +59,8 @@ public class OnScreenButton extends OnScreenController {
 
         if ((position & Controls.POSITION_RIGHT) != 0) {
             startX = (float)engine.width - 1.0f - btnOffsetX;
+        } else if ((position & Controls.POSITION_HCENTER) != 0) {
+            startX = ((float)engine.width - 1.0f) * 0.5f;
         } else {
             startX = btnOffsetX;
         }
@@ -56,11 +73,23 @@ public class OnScreenButton extends OnScreenController {
 
     @Override
     public boolean pointerDown(float x, float y) {
+        if (!isVisible || (type == TYPE_REWARDED_CONTINUE && !App.self.mediadtor.isRewardedVideoLoaded())) {
+            return false;
+        }
+
         if (x >= fromX && x <= toX && y >= fromY && y <= toY) {
             switch (type) {
                 case TYPE_GAME_MENU:
                     game.actionGameMenu = true;
                     break;
+
+                case TYPE_RESTART:
+                    game.actionRestartButton = true;
+                    break;
+
+                case TYPE_REWARDED_CONTINUE:
+                    game.actionContinueButton = true;
+                    break;
             }
 
             active = true;
@@ -79,32 +108,64 @@ public class OnScreenButton extends OnScreenController {
             case TYPE_GAME_MENU:
                 game.actionGameMenu = false;
                 break;
+
+            case TYPE_RESTART:
+                game.actionRestartButton = false;
+                break;
+
+            case TYPE_REWARDED_CONTINUE:
+                game.actionContinueButton = false;
+                break;
         }
     }
 
     @SuppressWarnings("MagicNumber")
     @Override
-    public void render(GL10 gl, long elapsedTime, boolean canRenderHelp) {
+    public void render(long elapsedTime, boolean canRenderHelp) {
+        if (!isVisible) {
+            return;
+        }
+
         int tex = 0;
+        float dt = (float)elapsedTime * 0.0025f;
 
         switch (type) {
             case TYPE_GAME_MENU:
                 tex = TextureLoader.ICON_MENU;
                 break;
-        }
 
-        owner.drawIcon(startX, startY, tex, active);
+            case TYPE_RESTART:
+                tex = TextureLoader.BASE_BACKS + 2;
+                break;
 
-        if (canRenderHelp && shouldDrawHelp()) {
-            float dt = (float)elapsedTime * 0.0025f;
+            case TYPE_REWARDED_CONTINUE:
+                tex = TextureLoader.BASE_BACKS + 4;
+                break;
+        }
+
+        if (type == TYPE_GAME_MENU) {
+            owner.batchIcon(startX, startY, tex, active);
+        } else if (type == TYPE_REWARDED_CONTINUE && !App.self.mediadtor.isRewardedVideoLoaded()) {
+            owner.batchBack(startX, startY, tex, false, 0.125f, 1.0f);
+        } else {
+            float ratio = (float)Math.cos(dt * 2.0f + (type == TYPE_RESTART ? GameMath.PI_F : 0.0f));
 
-            owner.drawIcon(startX,
+            owner.batchBack(startX,
                     startY,
-                    TextureLoader.ICON_JOY,
-                    false,
-                    0.5f - (float)Math.cos(dt * 2.0f) * 0.5f,
-                    (float)Math.cos(dt % Math.PI) * 0.5f + 1.5f);
+                    tex,
+                    active,
+                    ratio * 0.25f + 0.75f,
+                    ratio * 0.05f + (type == TYPE_RESTART ? 0.95f : 1.05f));
         }
+
+        // if ((canRenderHelp && shouldRenderHelp()) || (type == TYPE_REWARDED_CONTINUE)) {
+        //     owner.batchIcon(startX,
+        //             startY,
+        //             TextureLoader.ICON_JOY,
+        //             false,
+        //             0.5f - (float)Math.cos(dt * 2.0f) * 0.5f,
+        //             (float)Math.cos(dt % Math.PI) * 0.5f + 1.5f);
+        // }
     }
 
     @Override
diff --git a/src/main/java/zame/game/engine/controls/OnScreenController.java b/src/main/java/zame/game/engine/controls/OnScreenController.java
index dd6b30e..42a3cb7 100644
--- a/src/main/java/zame/game/engine/controls/OnScreenController.java
+++ b/src/main/java/zame/game/engine/controls/OnScreenController.java
@@ -1,10 +1,10 @@
 package zame.game.engine.controls;
 
-import javax.microedition.khronos.opengles.GL10;
 import zame.game.engine.Config;
 import zame.game.engine.Engine;
 import zame.game.engine.Game;
-import zame.game.engine.State;
+import zame.game.engine.state.State;
+import zame.game.engine.visual.Controls;
 
 public abstract class OnScreenController {
     Controls owner;
@@ -20,23 +20,25 @@ public abstract class OnScreenController {
     private float offsetYMinBound;
     private float offsetYMaxBound;
 
-    int pointerId = -1;
+    public int pointerId = -1;
     float startX;
     float startY;
     float offsetX;
     float offsetY;
-    int renderModeMask = Game.RENDER_MODE_GAME;
-    int position;
-    boolean renderAnyway;
-    int controlFlags;
+    public int renderModeMask = Game.RENDER_MODE_GAME;
+    public int position;
+    public boolean renderAnyway;
+    public int controlFlags;
     int helpLabelId = -1;
 
-    void setOwner(Controls owner, Engine engine) {
+    public void setOwner(Controls owner, Engine engine) {
         this.owner = owner;
         this.engine = engine;
         this.config = engine.config;
         this.game = engine.game;
         this.state = engine.state;
+
+        surfaceSizeChanged(); // refresh position for the great justice
     }
 
     @SuppressWarnings("MagicNumber")
@@ -73,7 +75,7 @@ public abstract class OnScreenController {
         prevOffsetY = 0.0f;
     }
 
-    public void render(GL10 gl, long elapsedTime, boolean canRenderHelp) {
+    public void render(long elapsedTime, boolean canRenderHelp) {
     }
 
     public void updateHero() {
@@ -84,20 +86,19 @@ public abstract class OnScreenController {
     }
 
     @SuppressWarnings("BooleanMethodIsAlwaysInverted")
-    boolean shouldDrawHelp() {
+    boolean shouldRenderHelp() {
         return ((renderAnyway || controlFlags == 0 || (state.disabledControlsMask & controlFlags) != controlFlags)
                 && (state.controlsHelpMask & controlFlags) != 0
                 && (renderModeMask & game.renderMode) != 0
                 && helpLabelId >= 0);
     }
 
-    protected void drawHelp(GL10 gl, long elapsedTime) {
-        if (!shouldDrawHelp()) {
+    public void renderHelp(long elapsedTime) {
+        if (!shouldRenderHelp()) {
             return;
         }
 
-        owner.drawHelpArrowWithText(gl,
-                startX,
+        owner.renderHelpArrowWithText(startX,
                 startY,
                 getHelpDiagSize(),
                 (position & Controls.POSITION_RIGHT) == 0,
diff --git a/src/main/java/zame/game/engine/controls/OnScreenFireAndRotate.java b/src/main/java/zame/game/engine/controls/OnScreenFireAndRotate.java
index fe5c212..b236403 100644
--- a/src/main/java/zame/game/engine/controls/OnScreenFireAndRotate.java
+++ b/src/main/java/zame/game/engine/controls/OnScreenFireAndRotate.java
@@ -1,11 +1,11 @@
 package zame.game.engine.controls;
 
-import javax.microedition.khronos.opengles.GL10;
 import zame.game.App;
 import zame.game.engine.Game;
-import zame.game.engine.GameMath;
-import zame.game.engine.Labels;
-import zame.game.engine.TextureLoader;
+import zame.game.engine.graphics.Labels;
+import zame.game.engine.graphics.Renderer;
+import zame.game.engine.graphics.TextureLoader;
+import zame.game.engine.visual.Controls;
 
 public class OnScreenFireAndRotate extends OnScreenController {
     private float fromX;
@@ -20,7 +20,7 @@ public class OnScreenFireAndRotate extends OnScreenController {
     private float heroVertA;
     private boolean fireActive;
 
-    OnScreenFireAndRotate(int position) {
+    public OnScreenFireAndRotate(int position) {
         super();
 
         this.position = position;
@@ -81,7 +81,8 @@ public class OnScreenFireAndRotate extends OnScreenController {
                 && x <= fireToX
                 && y >= fireFromY
                 && y <= fireToY
-                && (state.disabledControlsMask & Controls.CONTROL_FIRE) == 0) {
+                && (game.renderMode != Game.RENDER_MODE_GAME
+                || (state.disabledControlsMask & Controls.CONTROL_FIRE) == 0)) {
 
             game.actionFire |= Controls.ACTION_FIRE_ONSCREEN;
             fireActive = true;
@@ -101,20 +102,20 @@ public class OnScreenFireAndRotate extends OnScreenController {
 
     @SuppressWarnings("MagicNumber")
     @Override
-    public void render(GL10 gl, long elapsedTime, boolean canRenderHelp) {
-        if ((state.disabledControlsMask & Controls.CONTROL_FIRE) == 0) {
-            owner.drawIcon(fireBtnX, fireBtnY, TextureLoader.ICON_SHOOT, fireActive);
+    public void render(long elapsedTime, boolean canRenderHelp) {
+        if (game.renderMode != Game.RENDER_MODE_GAME || (state.disabledControlsMask & Controls.CONTROL_FIRE) == 0) {
+            owner.batchIcon(fireBtnX, fireBtnY, TextureLoader.ICON_SHOOT, fireActive);
         }
 
-        boolean isHelp = canRenderHelp && shouldDrawHelp();
+        boolean isHelp = canRenderHelp && shouldRenderHelp();
 
         if (game.renderMode != Game.RENDER_MODE_GAME || isHelp) {
             float dt = (float)elapsedTime * 0.0025f;
 
             if (isHelp
                     && (state.disabledControlsMask & Controls.CONTROL_ROTATE) == 0
-                    && (state.controlsHelpMask & (Controls.CONTROL_ROTATE
-                    | Controls.CONTROL_ROTATE_LEFT
+                    && (state.controlsHelpMask & (/* Controls.CONTROL_ROTATE
+                    | */ Controls.CONTROL_ROTATE_LEFT
                     | Controls.CONTROL_ROTATE_RIGHT)) != 0) {
 
                 boolean posLeft = (position & Controls.POSITION_RIGHT) == 0;
@@ -122,14 +123,16 @@ public class OnScreenFireAndRotate extends OnScreenController {
 
                 //noinspection IfStatementWithIdenticalBranches
                 if ((state.controlsHelpMask & Controls.CONTROL_ROTATE_RIGHT) != 0) {
-                    off = -off;
-                } else if (((state.controlsHelpMask & Controls.CONTROL_ROTATE) != 0) && (dt % (GameMath.PI_F * 4.0f)
-                        > GameMath.PI_F * 2.0f)) {
-
                     off = -off;
                 }
 
-                owner.drawIcon(((posLeft ? 0.25f : 0.75f) + off) * (float)engine.width,
+                // else if (((state.controlsHelpMask & Controls.CONTROL_ROTATE) != 0) && (dt % (GameMath.PI_F * 4.0f)
+                //        > GameMath.PI_F * 2.0f)) {
+                //
+                //     off = -off;
+                // }
+
+                owner.batchIcon(((posLeft ? 0.25f : 0.75f) + off) * (float)engine.width,
                         (float)engine.height * 0.5f,
                         TextureLoader.ICON_JOY,
                         false,
@@ -139,7 +142,7 @@ public class OnScreenFireAndRotate extends OnScreenController {
             if (game.renderMode != Game.RENDER_MODE_GAME || ((state.disabledControlsMask & Controls.CONTROL_FIRE) == 0
                     && (state.controlsHelpMask & Controls.CONTROL_FIRE) != 0)) {
 
-                owner.drawIcon(fireBtnX,
+                owner.batchIcon(fireBtnX,
                         fireBtnY,
                         TextureLoader.ICON_JOY,
                         false,
@@ -201,8 +204,8 @@ public class OnScreenFireAndRotate extends OnScreenController {
 
     @SuppressWarnings("MagicNumber")
     @Override
-    protected void drawHelp(GL10 gl, long elapsedTime) {
-        if (!shouldDrawHelp()) {
+    public void renderHelp(long elapsedTime) {
+        if (!shouldRenderHelp()) {
             return;
         }
 
@@ -211,8 +214,7 @@ public class OnScreenFireAndRotate extends OnScreenController {
         if ((state.disabledControlsMask & Controls.CONTROL_FIRE) == 0
                 && (state.controlsHelpMask & Controls.CONTROL_FIRE) != 0) {
 
-            owner.drawHelpArrowWithText(gl,
-                    fireBtnX,
+            owner.renderHelpArrowWithText(fireBtnX,
                     fireBtnY,
                     getHelpDiagSize(),
                     posLeft,
@@ -231,18 +233,16 @@ public class OnScreenFireAndRotate extends OnScreenController {
         float sx = ((posLeft ? 0.25f : 0.75f) - 0.2f) * engine.ratio;
         float ex = ((posLeft ? 0.25f : 0.75f) + 0.2f) * engine.ratio;
 
-        engine.renderer.init();
-
-        engine.renderer.setQuadA(0.5f);
-        owner.drawArrow(gl, ex, 0.55f, sx, 0.55f, 0.0f, false);
-        owner.drawArrow(gl, sx, 0.45f, ex, 0.45f, 0.0f, false);
-        engine.renderer.flush(gl, false);
+        engine.renderer.startBatch();
+        owner.batchArrow(ex, 0.55f, sx, 0.55f, 0.0f, false);
+        owner.batchArrow(sx, 0.45f, ex, 0.45f, 0.0f, false);
+        engine.renderer.setColorQuadA(0.5f);
+        engine.renderer.renderBatch(Renderer.FLAG_BLEND);
 
-        engine.labels.beginDrawing(gl, true);
-        engine.renderer.setQuadA(1.0f);
+        engine.labels.startBatch(true);
+        engine.renderer.setColorQuadA(1.0f);
 
-        engine.labels.draw(gl,
-                sx,
+        engine.labels.batch(sx,
                 0.45f,
                 ex,
                 0.55f,
@@ -250,6 +250,6 @@ public class OnScreenFireAndRotate extends OnScreenController {
                 0.04f,
                 Labels.ALIGN_CC);
 
-        engine.labels.endDrawing(gl, true);
+        engine.labels.renderBatch();
     }
 }
diff --git a/src/main/java/zame/game/engine/controls/OnScreenPad.java b/src/main/java/zame/game/engine/controls/OnScreenPad.java
index 16eae26..23c6866 100644
--- a/src/main/java/zame/game/engine/controls/OnScreenPad.java
+++ b/src/main/java/zame/game/engine/controls/OnScreenPad.java
@@ -1,9 +1,8 @@
 package zame.game.engine.controls;
 
-import javax.microedition.khronos.opengles.GL10;
-import zame.game.engine.GameMath;
-import zame.game.engine.Labels;
-import zame.game.engine.TextureLoader;
+import zame.game.engine.graphics.Labels;
+import zame.game.engine.graphics.TextureLoader;
+import zame.game.engine.visual.Controls;
 
 public class OnScreenPad extends OnScreenController {
     private float fromX;
@@ -14,9 +13,9 @@ public class OnScreenPad extends OnScreenController {
     private float maxDist;
     private boolean active;
 
-    boolean dynamic;
+    public boolean dynamic;
 
-    OnScreenPad(int position, boolean dynamic) {
+    public OnScreenPad(int position, boolean dynamic) {
         super();
 
         this.position = position;
@@ -97,11 +96,14 @@ public class OnScreenPad extends OnScreenController {
 
     @SuppressWarnings("MagicNumber")
     @Override
-    public void render(GL10 gl, long elapsedTime, boolean canRenderHelp) {
-        owner.drawBack(startX, startY, TextureLoader.BASE_BACKS, active);
-        owner.drawIcon(startX + offsetX, startY + offsetY, TextureLoader.ICON_JOY, active);
+    public void render(long elapsedTime, boolean canRenderHelp) {
+        owner.batchBack(startX, startY, TextureLoader.BASE_BACKS, active);
+        owner.batchIcon(startX + offsetX, startY + offsetY, TextureLoader.ICON_JOY, active);
+
+        if (canRenderHelp
+                && !active && shouldRenderHelp()
+                && (state.controlsHelpMask & Controls.CONTROL_MOVE) == 0) {
 
-        if (canRenderHelp && !active && shouldDrawHelp()) {
             float dt = (float)elapsedTime * 0.0025f;
             float x = startX;
             float y = startY;
@@ -110,13 +112,15 @@ public class OnScreenPad extends OnScreenController {
                     ? (float)Math.cos(dt) * owner.iconSize
                     : (float)Math.cos(dt % Math.PI) * owner.iconSize;
 
-            if ((state.controlsHelpMask & Controls.CONTROL_MOVE) != 0) {
-                if (dt % (GameMath.PI_F * 4.0f) > GameMath.PI_F * 2.0f) {
-                    x -= off;
-                } else {
-                    y += off;
-                }
-            } else if ((state.controlsHelpMask & Controls.CONTROL_MOVE_UP) != 0) {
+            // if ((state.controlsHelpMask & Controls.CONTROL_MOVE) != 0) {
+            // if (dt % (GameMath.PI_F * 4.0f) > GameMath.PI_F * 2.0f) {
+            //     x -= off;
+            // } else {
+            //     y += off;
+            // }
+            // } else
+
+            if ((state.controlsHelpMask & Controls.CONTROL_MOVE_UP) != 0) {
                 y += off;
             } else if ((state.controlsHelpMask & Controls.CONTROL_MOVE_DOWN) != 0) {
                 y -= off;
@@ -126,7 +130,7 @@ public class OnScreenPad extends OnScreenController {
                 x -= off;
             }
 
-            owner.drawIcon(x, y, TextureLoader.ICON_JOY, false, 0.5f - (float)Math.cos(dt * 2.0f) * 0.5f);
+            owner.batchIcon(x, y, TextureLoader.ICON_JOY, false, 0.5f - (float)Math.cos(dt * 2.0f) * 0.5f);
         }
     }
 
diff --git a/src/main/java/zame/game/engine/controls/OnScreenQuickWeapons.java b/src/main/java/zame/game/engine/controls/OnScreenQuickWeapons.java
index ef4fbc8..3078ff6 100644
--- a/src/main/java/zame/game/engine/controls/OnScreenQuickWeapons.java
+++ b/src/main/java/zame/game/engine/controls/OnScreenQuickWeapons.java
@@ -1,18 +1,18 @@
 package zame.game.engine.controls;
 
-import javax.microedition.khronos.opengles.GL10;
-import zame.game.engine.Labels;
-import zame.game.engine.TextureLoader;
+import zame.game.engine.graphics.Labels;
+import zame.game.engine.graphics.TextureLoader;
+import zame.game.engine.visual.Controls;
 
 public class OnScreenQuickWeapons extends OnScreenController {
-    float direction = 1.0f;
+    public float direction = 1.0f;
 
     private boolean[] active = { false, false, false };
     @SuppressWarnings("MismatchedReadAndWriteOfArray") private int[] mapping = new int[3];
     private float fromY;
     private float toY;
 
-    OnScreenQuickWeapons(int position) {
+    public OnScreenQuickWeapons(int position) {
         super();
 
         this.position = position;
@@ -68,7 +68,7 @@ public class OnScreenQuickWeapons extends OnScreenController {
             float fromX = baseX + btnOffsetX * 2.0f * (float)i * direction - btnClickArea;
             float toX = fromX + btnClickArea * 2.0f;
 
-            if (x >= fromX && x <= toX) {
+            if (x >= fromX && x <= toX && !engine.weapons.hasNoAmmo(state.lastWeapons[mapping[i]])) {
                 active[i] = true;
                 game.actionQuickWeapons[mapping[i]] = true;
                 return true;
@@ -93,7 +93,7 @@ public class OnScreenQuickWeapons extends OnScreenController {
 
     @SuppressWarnings("MagicNumber")
     @Override
-    public void render(GL10 gl, long elapsedTime, boolean canRenderHelp) {
+    public void render(long elapsedTime, boolean canRenderHelp) {
         float btnOffsetX = owner.iconSize * 0.55f;
         int count = 0;
 
@@ -111,16 +111,17 @@ public class OnScreenQuickWeapons extends OnScreenController {
         float baseX = startX - btnOffsetX * (float)(count - 1) * direction;
 
         for (int i = 0; i < count; i++) {
-            owner.drawIcon(baseX + btnOffsetX * 2.0f * (float)i * direction,
+            owner.batchIcon(baseX + btnOffsetX * 2.0f * (float)i * direction,
                     startY,
                     TextureLoader.BASE_WEAPONS + state.lastWeapons[mapping[i]],
-                    active[i]);
+                    active[i],
+                    engine.weapons.hasNoAmmo(state.lastWeapons[mapping[i]]) ? 0.25f : -1.0f);
         }
 
-        if (canRenderHelp && shouldDrawHelp()) {
+        if (canRenderHelp && shouldRenderHelp()) {
             float dt = (float)elapsedTime * 0.0025f;
 
-            owner.drawIcon(baseX + btnOffsetX * 2.0f * (float)((int)(dt / Math.PI) % count) * direction,
+            owner.batchIcon(baseX + btnOffsetX * 2.0f * (float)((int)(dt / Math.PI) % count) * direction,
                     startY,
                     TextureLoader.ICON_JOY,
                     false,
diff --git a/src/main/java/zame/game/engine/controls/OnScreenUpgradeButton.java b/src/main/java/zame/game/engine/controls/OnScreenUpgradeButton.java
deleted file mode 100644
index 2b46031..0000000
--- a/src/main/java/zame/game/engine/controls/OnScreenUpgradeButton.java
+++ /dev/null
@@ -1,63 +0,0 @@
-package zame.game.engine.controls;
-
-import javax.microedition.khronos.opengles.GL10;
-import zame.game.engine.Game;
-import zame.game.engine.TextureLoader;
-
-public class OnScreenUpgradeButton extends OnScreenController {
-	private float fromX;
-	private float fromY;
-	private float toX;
-	private float toY;
-	private boolean active;
-
-	OnScreenUpgradeButton(int position) {
-		super();
-
-		this.position = position;
-		this.renderModeMask = Game.RENDER_MODE_GAME_OVER;
-	}
-
-	@SuppressWarnings("MagicNumber")
-	@Override
-	public void surfaceSizeChanged() {
-		super.surfaceSizeChanged();
-
-		startY = (float)engine.height - 1.0f - owner.iconSize * 1.0f;
-		fromY = startY - owner.iconSize * 0.5f;
-		toY = startY + owner.iconSize * 0.5f;
-
-		if ((position & Controls.POSITION_RIGHT) != 0) {
-			startX = (float)engine.width - 1.0f - owner.iconSize * 3.0f;
-		} else {
-			startX = owner.iconSize * 3.0f;
-		}
-
-		fromX = startX - owner.iconSize * 2.5f;
-		toX = startX + owner.iconSize * 2.5f;
-	}
-
-	@Override
-	public boolean pointerDown(float x, float y) {
-		if (x >= fromX && x <= toX && y >= fromY && y <= toY) {
-			game.actionUpgradeButton = true;
-			active = true;
-			return true;
-		}
-
-		return false;
-	}
-
-	@Override
-	public void pointerUp() {
-		super.pointerUp();
-
-		game.actionUpgradeButton = false;
-		active = false;
-	}
-
-	@Override
-	public void render(GL10 gl, long elapsedTime, boolean canRenderHelp) {
-		owner.drawBtn(startX, startY, TextureLoader.BASE_BACKS + 2, active, true, elapsedTime);
-	}
-}
diff --git a/src/main/java/zame/game/engine/data/Common.java b/src/main/java/zame/game/engine/data/Common.java
deleted file mode 100644
index cc8d1e5..0000000
--- a/src/main/java/zame/game/engine/data/Common.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package zame.game.engine.data;
-
-final class Common {
-	static final String SIGNATURE = "FireStrike3";
-	static final int INITIAL_SIGNATURE_VALUE = 594828924;
-	static final short MARKER_END = -1;
-	static final int MASK_ARRAY = 0xC000;
-	static final int SHIFT_ARRAY = 14;
-	static final int MASK_TYPE = 0x3C00;
-	static final int SHIFT_TYPE = 10;
-	static final int MASK_FIELD_ID = 0x03FF;
-	static final int ARRAY_1D = 1;
-	static final int ARRAY_2D = 2;
-	static final int ARRAY_2DV = 3;
-	static final int TYPE_OBJECT = 0;
-	static final int TYPE_BYTE = 1;
-	static final int TYPE_SHORT = 2;
-	static final int TYPE_INT = 3;
-	static final int TYPE_LONG = 4;
-	static final int TYPE_FLOAT = 5;
-	static final int TYPE_DOUBLE = 6;
-	static final int TYPE_BOOLEAN = 7;
-	static final int TYPE_CHAR = 8;
-	static final int TYPE_STRING = 9;
-	static final int TYPE_NULL = 10;
-
-	private Common() {}
-}
diff --git a/src/main/java/zame/game/engine/data/DataListItem.java b/src/main/java/zame/game/engine/data/DataListItem.java
deleted file mode 100644
index 4be28ba..0000000
--- a/src/main/java/zame/game/engine/data/DataListItem.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package zame.game.engine.data;
-
-public class DataListItem {
-    @SuppressWarnings("WeakerAccess") public DataListItem prev;
-    public DataListItem next;
-}
diff --git a/src/main/java/zame/game/engine/data/UnknownSignatureException.java b/src/main/java/zame/game/engine/data/UnknownSignatureException.java
deleted file mode 100644
index dda520e..0000000
--- a/src/main/java/zame/game/engine/data/UnknownSignatureException.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package zame.game.engine.data;
-
-@SuppressWarnings("WeakerAccess")
-public class UnknownSignatureException extends Exception {
-    private static final long serialVersionUID = 0L;
-
-    public static final String INVALID_SIGNATURE = "Invalid signature";
-    public static final String UNKNOWN_SIGNATURE = "Unknown signature";
-    public static final String INVALID_VERSION = "Invalid version";
-    public static final String UNSUPPORTED_VERSION = "Unsupported version";
-    public static final String INVALID_CHECKSUM = "Invalid checksum";
-
-    public UnknownSignatureException(String detailMessage) {
-        super(detailMessage);
-    }
-
-    public UnknownSignatureException(String detailMessage, Throwable throwable) {
-        super(detailMessage, throwable);
-    }
-}
diff --git a/src/main/java/zame/game/engine/Action.java b/src/main/java/zame/game/engine/entity/Action.java
similarity index 71%
rename from src/main/java/zame/game/engine/Action.java
rename to src/main/java/zame/game/engine/entity/Action.java
index 43a1c32..ef6d7ce 100644
--- a/src/main/java/zame/game/engine/Action.java
+++ b/src/main/java/zame/game/engine/entity/Action.java
@@ -1,18 +1,18 @@
-package zame.game.engine;
+package zame.game.engine.entity;
 
 import java.io.IOException;
-import zame.game.engine.data.DataItem;
-import zame.game.engine.data.DataReader;
-import zame.game.engine.data.DataWriter;
+import zame.game.core.serializer.DataItem;
+import zame.game.core.serializer.DataReader;
+import zame.game.core.serializer.DataWriter;
 
 public class Action implements DataItem {
 	private static final int FIELD_TYPE = 1;
 	private static final int FIELD_MARK_ID = 2;
 	private static final int FIELD_PARAM = 3;
 
-	int type;
-	int markId;
-	int param;
+	public int type;
+	public int markId;
+	public int param;
 
 	@Override
 	public void writeTo(DataWriter writer) throws IOException {
diff --git a/src/main/java/zame/game/engine/entity/AutoMapPathCell.java b/src/main/java/zame/game/engine/entity/AutoMapPathCell.java
new file mode 100644
index 0000000..c44e0fb
--- /dev/null
+++ b/src/main/java/zame/game/engine/entity/AutoMapPathCell.java
@@ -0,0 +1,32 @@
+package zame.game.engine.entity;
+
+import zame.game.core.serializer.DataListItem;
+
+public class AutoMapPathCell extends DataListItem<AutoMapPathCell> {
+    public int x;
+    public int y;
+    public float cx;
+    public float cy;
+    public boolean hasFrom;
+    public boolean hasTo;
+    public float fdx;
+    public float fdy;
+    public float tdx;
+    public float tdy;
+
+    @SuppressWarnings("MagicNumber")
+    public void initFrom(int px, int py, int cx, int cy, int nx, int ny) {
+        x = cx;
+        y = cy;
+        this.cx = (float)cx + 0.5f;
+        this.cy = (float)cy + 0.5f;
+
+        hasFrom = (px != cx || py != cy);
+        hasTo = (nx != cx || ny != cy);
+
+        fdx = (float)(px - cx) * 0.5f;
+        fdy = (float)(py - cy) * 0.5f;
+        tdx = (float)(nx - cx) * 0.5f;
+        tdy = (float)(ny - cy) * 0.5f;
+    }
+}
diff --git a/src/main/java/zame/game/engine/AutoWall.java b/src/main/java/zame/game/engine/entity/AutoWall.java
similarity index 80%
rename from src/main/java/zame/game/engine/AutoWall.java
rename to src/main/java/zame/game/engine/entity/AutoWall.java
index 05eaa34..763ffbe 100644
--- a/src/main/java/zame/game/engine/AutoWall.java
+++ b/src/main/java/zame/game/engine/entity/AutoWall.java
@@ -1,12 +1,12 @@
-package zame.game.engine;
+package zame.game.engine.entity;
 
 import java.io.IOException;
-import zame.game.engine.data.DataItem;
-import zame.game.engine.data.DataListItem;
-import zame.game.engine.data.DataReader;
-import zame.game.engine.data.DataWriter;
+import zame.game.core.serializer.DataItem;
+import zame.game.core.serializer.DataListItem;
+import zame.game.core.serializer.DataReader;
+import zame.game.core.serializer.DataWriter;
 
-public class AutoWall extends DataListItem implements DataItem {
+public class AutoWall extends DataListItem<AutoWall> implements DataItem {
 	private static final int FIELD_FROM_X = 1;
 	private static final int FIELD_FROM_Y = 2;
 	private static final int FIELD_TO_X = 3;
diff --git a/src/main/java/zame/game/engine/Bullet.java b/src/main/java/zame/game/engine/entity/Bullet.java
similarity index 83%
rename from src/main/java/zame/game/engine/Bullet.java
rename to src/main/java/zame/game/engine/entity/Bullet.java
index 329a3da..b38dd0b 100644
--- a/src/main/java/zame/game/engine/Bullet.java
+++ b/src/main/java/zame/game/engine/entity/Bullet.java
@@ -1,21 +1,28 @@
-package zame.game.engine;
+package zame.game.engine.entity;
 
 import java.io.IOException;
-import zame.game.engine.data.DataItem;
-import zame.game.engine.data.DataListItem;
-import zame.game.engine.data.DataReader;
-import zame.game.engine.data.DataWriter;
-
-public class Bullet extends DataListItem implements EngineObject, DataItem {
-    static final float SHOOT_RADIUS = 0.2f;
+import zame.game.core.serializer.DataItem;
+import zame.game.core.serializer.DataListItem;
+import zame.game.core.serializer.DataReader;
+import zame.game.core.serializer.DataWriter;
+import zame.game.engine.Engine;
+import zame.game.engine.EngineObject;
+import zame.game.engine.Game;
+import zame.game.engine.level.Level;
+import zame.game.engine.level.LevelRenderer;
+import zame.game.engine.state.State;
+import zame.game.engine.util.GameMath;
+
+public class Bullet extends DataListItem<Bullet> implements EngineObject, DataItem {
+    private static final float SHOOT_RADIUS = 0.2f;
     private static final float BULLET_RADIUS = 0.1f;
     private static final float SHOOT_RADIUS_SQ = SHOOT_RADIUS * SHOOT_RADIUS; // actual = BULLET_RADIUS + SHOOT_RADIUS
     private static final float HIT_MIN_FLY_DIST_SQ = 0.25f * 0.25f; // must be > than SHOOT_RADIUS_SQ
     private static final float INITIAL_ACCEL = 0.3f; // must be > than SHOOT_RADIUS
 
-    static class BulletParams {
+    public static class BulletParams {
         float speed;
-        float maxDist;
+        public float maxDist;
         int baseTexture;
         boolean explosion;
         boolean boomAfterMaxDist;
@@ -54,7 +61,7 @@ public class Bullet extends DataListItem implements EngineObject, DataItem {
     private static final int FIELD_MON_UID = 4;
     private static final int FIELD_AMMO_IDX = 5;
     private static final int FIELD_HITS = 6;
-    private static final int FIELD_HIT_TIMEOUT = 7;
+    private static final int FIELD_STUN = 7;
     private static final int FIELD_BULLET_STATE = 8;
     private static final int FIELD_DIST = 9;
     private static final int FIELD_SX = 10;
@@ -83,9 +90,9 @@ public class Bullet extends DataListItem implements EngineObject, DataItem {
             // -2 (monster punch)
             new BulletParams(MONSTER_MEELE_MAX_DIST, MONSTER_MEELE_MAX_DIST, -1, false, false), };
 
-    @SuppressWarnings("WeakerAccess") static final int STATE_INITIAL = 0;
-    @SuppressWarnings("WeakerAccess") static final int STATE_FLY = 1;
-    static final int STATE_RELEASE = 2;
+    private static final int STATE_INITIAL = 0;
+    private static final int STATE_FLY = 1;
+    public static final int STATE_RELEASE = 2;
 
     private Engine engine;
     private State state;
@@ -102,29 +109,29 @@ public class Bullet extends DataListItem implements EngineObject, DataItem {
     public float sy;
     public float x;
     public float y;
-    public float dx;
-    public float dy;
+    private float dx;
+    private float dy;
 
-    float dist;
-    int monUid;
-    Monster mon;
-    int bulletState;
-    BulletParams params;
+    public float dist;
+    public int monUid;
+    public Monster mon;
+    public int bulletState;
+    public BulletParams params;
 
     private int angle;
     private float ar;
     private int ammoIdx; // -1 for hero hit
     private int hits;
-    private int hitTimeout;
+    private int stun;
 
-    static boolean shootOrPunch(State state,
+    public static boolean shootOrPunch(State state,
             float x,
             float y,
             float ar,
             Monster mon,
             int ammoIdx,
             int hits,
-            int hitTimeout) {
+            int stun) {
 
         Bullet bullet = state.bullets.take();
 
@@ -134,7 +141,7 @@ public class Bullet extends DataListItem implements EngineObject, DataItem {
             bullet = state.bullets.take();
         }
 
-        bullet.init(x, y, ar, mon, ammoIdx, hits, hitTimeout);
+        bullet.init(x, y, ar, mon, ammoIdx, hits, stun);
         boolean hit = bullet.update();
 
         if (bullet.bulletState == STATE_RELEASE) {
@@ -145,7 +152,7 @@ public class Bullet extends DataListItem implements EngineObject, DataItem {
     }
 
     @Override
-    public void setEngine(Engine engine) {
+    public void onCreate(Engine engine) {
         this.engine = engine;
         this.state = engine.state;
         this.game = engine.game;
@@ -161,7 +168,7 @@ public class Bullet extends DataListItem implements EngineObject, DataItem {
         writer.write(FIELD_MON_UID, monUid);
         writer.write(FIELD_AMMO_IDX, ammoIdx);
         writer.write(FIELD_HITS, hits);
-        writer.write(FIELD_HIT_TIMEOUT, hitTimeout);
+        writer.write(FIELD_STUN, stun);
         writer.write(FIELD_BULLET_STATE, bulletState);
         writer.write(FIELD_DIST, dist);
         writer.write(FIELD_SX, sx);
@@ -176,7 +183,7 @@ public class Bullet extends DataListItem implements EngineObject, DataItem {
         monUid = reader.readInt(FIELD_MON_UID);
         ammoIdx = reader.readInt(FIELD_AMMO_IDX);
         hits = reader.readInt(FIELD_HITS);
-        hitTimeout = reader.readInt(FIELD_HIT_TIMEOUT);
+        stun = reader.readInt(FIELD_STUN);
         bulletState = reader.readInt(FIELD_BULLET_STATE);
         dist = reader.readFloat(FIELD_DIST);
         sx = reader.readFloat(FIELD_SX);
@@ -185,7 +192,7 @@ public class Bullet extends DataListItem implements EngineObject, DataItem {
         updateVars();
     }
 
-    public void init(float x, float y, float ar, Monster mon, int ammoIdx, int hits, int hitTimeout) {
+    public void init(float x, float y, float ar, Monster mon, int ammoIdx, int hits, int stun) {
         this.sx = x;
         this.sy = y;
         this.x = x;
@@ -195,7 +202,7 @@ public class Bullet extends DataListItem implements EngineObject, DataItem {
         this.monUid = (mon == null ? -1 : mon.uid);
         this.ammoIdx = ammoIdx;
         this.hits = hits;
-        this.hitTimeout = hitTimeout;
+        this.stun = stun;
 
         dist = 0.0f;
         bulletState = STATE_INITIAL;
@@ -286,7 +293,7 @@ public class Bullet extends DataListItem implements EngineObject, DataItem {
 
     private void daBoom() {
         if (params.explosion && ammoIdx >= 0) { // "ammoIdx >= 0" just for case
-            Explosion.boom(state, x, y, mon, ammoIdx, hits, hitTimeout);
+            Explosion.boom(state, x, y, mon, ammoIdx, hits, stun);
         }
 
         bulletState = STATE_RELEASE;
@@ -312,14 +319,23 @@ public class Bullet extends DataListItem implements EngineObject, DataItem {
             int resHits = engine.getRealHits(hits, dist);
 
             if (hitParams.hit == HitParams.HIT_MONSTER && hitParams.target != null) {
-                hitParams.target.hit(resHits, hitTimeout);
+                hitParams.target.hit(resHits, stun);
             } else if (hitParams.hit == HitParams.HIT_HERO) {
                 game.hitHero(resHits, mon);
             }
         }
 
-        x = hitParams.tx - dx * GameMath.LITTLE;
-        y = hitParams.ty - dy * GameMath.LITTLE;
+        //      ,        ,
+        //   ,      ** **  .
+        x = hitParams.tx - dx * GameMath.SIGHT_OFFSET;
+        y = hitParams.ty - dy * GameMath.SIGHT_OFFSET;
+
+        //     , ..   ,      -  
+        //
+        // if (mon == null && !params.explosion) {
+        //     BulletTrace.append(engine.random, levelRenderer, x, y, -0.1f);
+        // }
+
         return true;
     }
 
@@ -338,7 +354,7 @@ public class Bullet extends DataListItem implements EngineObject, DataItem {
         float b = 2.0f * (hdx * dx + hdy * dy);
         float c = hdx * hdx + hdy * hdy - SHOOT_RADIUS_SQ;
 
-        // start of bullet vector is out of radius
+        // startBatch of bullet vector is out of radius
         //noinspection SimplifiableIfStatement
         if (b >= 0.0f && c >= 0.0f) {
             return false;
@@ -442,6 +458,11 @@ public class Bullet extends DataListItem implements EngineObject, DataItem {
 
                                 localShootSeqMap[iy][cx1] = localShootSeq;
                                 Explosion.tryBoom(state, cx1, iy, hits);
+
+                                if (mon == null) {
+                                    BulletTrace.append(engine.random, levelRenderer, itemX, itemY, 0.25f);
+                                }
+
                                 // no break
                             }
                         }
@@ -509,19 +530,28 @@ public class Bullet extends DataListItem implements EngineObject, DataItem {
                             tmpHitB.ty = state.heroY;
                             break;
                         }
-                    } else if ((pass & Level.PASSABLE_IS_EXPLOSIVE) != 0) {
-                        float expX = (float)ix + 0.5f;
-                        float expY = (float)cy1 + 0.5f;
+                    } else if ((pass & Level.PASSABLE_IS_EXPLOSIVE) != 0
+                            || (pass & Level.PASSABLE_IS_DECOR_ITEM) != 0) {
+
+                        float itemX = (float)ix + 0.5f;
+                        float itemY = (float)cy1 + 0.5f;
 
-                        if (checkHitRadius(tmpHitB.x, tmpHitB.y, expX, expY)) {
+                        if (checkHitRadius(tmpHitB.x, tmpHitB.y, itemX, itemY)) {
                             if (params.explosion) {
                                 tmpHitB.hit = HitParams.HIT_EXPLOSIVE;
-                                tmpHitB.tx = expX;
-                                tmpHitB.ty = expY;
+                                tmpHitB.tx = itemX;
+                                tmpHitB.ty = itemY;
                                 break;
-                            } else if (localShootSeqMap[cy1][ix] != localShootSeq) {
+                            } else if ((pass & Level.PASSABLE_IS_EXPLOSIVE) != 0
+                                    && localShootSeqMap[cy1][ix] != localShootSeq) {
+
                                 localShootSeqMap[cy1][ix] = localShootSeq;
                                 Explosion.tryBoom(state, ix, cy1, hits);
+
+                                if (mon == null) {
+                                    BulletTrace.append(engine.random, levelRenderer, itemX, itemY, 0.25f);
+                                }
+
                                 // no break
                             }
                         }
@@ -540,7 +570,7 @@ public class Bullet extends DataListItem implements EngineObject, DataItem {
             return tmpHitOut;
         } else if (tmpHitA.hit < HitParams.HIT_WALL && tmpHitB.hit < HitParams.HIT_WALL) {
             if (levelRenderer.debugOnAutomap) {
-                TraceInfo.addInfo(levelRenderer, x1, y1, x2, y2, 0);
+                DebugTraceInfo.addInfo(levelRenderer, x1, y1, x2, y2, 0);
             }
 
             return null;
@@ -548,13 +578,13 @@ public class Bullet extends DataListItem implements EngineObject, DataItem {
 
         if (tmpHitA.hit > HitParams.HIT_OUT && tmpHitB.hit < HitParams.HIT_WALL) {
             if (levelRenderer.debugOnAutomap) {
-                TraceInfo.addInfo(levelRenderer, x1, y1, tmpHitA.x, tmpHitA.y, tmpHitA.hit);
+                DebugTraceInfo.addInfo(levelRenderer, x1, y1, tmpHitA.x, tmpHitA.y, tmpHitA.hit);
             }
 
             return tmpHitA;
         } else if (tmpHitB.hit > HitParams.HIT_OUT && tmpHitA.hit < HitParams.HIT_WALL) {
             if (levelRenderer.debugOnAutomap) {
-                TraceInfo.addInfo(levelRenderer, x1, y1, tmpHitB.x, tmpHitB.y, tmpHitB.hit);
+                DebugTraceInfo.addInfo(levelRenderer, x1, y1, tmpHitB.x, tmpHitB.y, tmpHitB.hit);
             }
 
             return tmpHitB;
@@ -566,13 +596,13 @@ public class Bullet extends DataListItem implements EngineObject, DataItem {
 
             if ((h1dx * h1dx + h1dy * h1dy) < (h2dx * h2dx + h2dy * h2dy)) {
                 if (levelRenderer.debugOnAutomap) {
-                    TraceInfo.addInfo(levelRenderer, x1, y1, tmpHitA.x, tmpHitA.y, tmpHitA.hit);
+                    DebugTraceInfo.addInfo(levelRenderer, x1, y1, tmpHitA.x, tmpHitA.y, tmpHitA.hit);
                 }
 
                 return tmpHitA;
             } else {
                 if (levelRenderer.debugOnAutomap) {
-                    TraceInfo.addInfo(levelRenderer, x1, y1, tmpHitB.x, tmpHitB.y, tmpHitB.hit);
+                    DebugTraceInfo.addInfo(levelRenderer, x1, y1, tmpHitB.x, tmpHitB.y, tmpHitB.hit);
                 }
 
                 return tmpHitB;
diff --git a/src/main/java/zame/game/engine/entity/BulletTrace.java b/src/main/java/zame/game/engine/entity/BulletTrace.java
new file mode 100644
index 0000000..f076f88
--- /dev/null
+++ b/src/main/java/zame/game/engine/entity/BulletTrace.java
@@ -0,0 +1,31 @@
+package zame.game.engine.entity;
+
+import java.util.Random;
+import zame.game.core.serializer.DataListItem;
+import zame.game.engine.level.LevelRenderer;
+
+public class BulletTrace extends DataListItem<BulletTrace> {
+    public static final int MAX_TICKS = 10;
+
+    public float x;
+    public float y;
+    public float z; // 0 - at middle, 0.25 - lower than middle
+    public float off;
+    public long ticks;
+
+    @SuppressWarnings({ "MagicNumber", "SameParameterValue" })
+    static void append(Random random, LevelRenderer levelRenderer, float x, float y, float z) {
+        BulletTrace bulletTrace = levelRenderer.bulletTraces.take();
+
+        if (bulletTrace == null) {
+            levelRenderer.bulletTraces.release(levelRenderer.bulletTraces.first());
+            bulletTrace = levelRenderer.bulletTraces.take();
+        }
+
+        bulletTrace.x = x;
+        bulletTrace.y = y;
+        bulletTrace.z = z + random.nextFloat() * 0.05f - 0.025f;
+        bulletTrace.off = random.nextFloat() * 0.05f - 0.025f;
+        bulletTrace.ticks = MAX_TICKS;
+    }
+}
diff --git a/src/main/java/zame/game/engine/TraceInfo.java b/src/main/java/zame/game/engine/entity/DebugTraceInfo.java
similarity index 52%
rename from src/main/java/zame/game/engine/TraceInfo.java
rename to src/main/java/zame/game/engine/entity/DebugTraceInfo.java
index 8709079..077ac74 100644
--- a/src/main/java/zame/game/engine/TraceInfo.java
+++ b/src/main/java/zame/game/engine/entity/DebugTraceInfo.java
@@ -1,8 +1,9 @@
-package zame.game.engine;
+package zame.game.engine.entity;
 
-import zame.game.engine.data.DataListItem;
+import zame.game.engine.level.LevelRenderer;
+import zame.game.core.serializer.DataListItem;
 
-public class TraceInfo extends DataListItem {
+public class DebugTraceInfo extends DataListItem<DebugTraceInfo> {
     public float sx;
     public float sy;
     public float ex;
@@ -11,11 +12,11 @@ public class TraceInfo extends DataListItem {
     public int ticks;
 
     static void addInfo(LevelRenderer levelRenderer, float sx, float sy, float ex, float ey, int hit) {
-        TraceInfo traceInfo = levelRenderer.tracesInfo.take();
+        DebugTraceInfo traceInfo = levelRenderer.debugTraceInfos.take();
 
         if (traceInfo == null) {
-            levelRenderer.tracesInfo.release(levelRenderer.tracesInfo.first());
-            traceInfo = levelRenderer.tracesInfo.take();
+            levelRenderer.debugTraceInfos.release(levelRenderer.debugTraceInfos.first());
+            traceInfo = levelRenderer.debugTraceInfos.take();
         }
 
         traceInfo.sx = sx;
diff --git a/src/main/java/zame/game/engine/Door.java b/src/main/java/zame/game/engine/entity/Door.java
similarity index 73%
rename from src/main/java/zame/game/engine/Door.java
rename to src/main/java/zame/game/engine/entity/Door.java
index 2700628..d63e611 100644
--- a/src/main/java/zame/game/engine/Door.java
+++ b/src/main/java/zame/game/engine/entity/Door.java
@@ -1,13 +1,18 @@
-package zame.game.engine;
+package zame.game.engine.entity;
 
 import java.io.IOException;
-import zame.game.engine.data.DataItem;
-import zame.game.engine.data.DataListItem;
-import zame.game.engine.data.DataReader;
-import zame.game.engine.data.DataWriter;
-import zame.game.managers.SoundManager;
-
-public class Door extends DataListItem implements EngineObject, DataItem {
+import zame.game.engine.Engine;
+import zame.game.engine.EngineObject;
+import zame.game.engine.level.Level;
+import zame.game.engine.state.State;
+import zame.game.engine.graphics.TextureLoader;
+import zame.game.core.serializer.DataItem;
+import zame.game.core.serializer.DataListItem;
+import zame.game.core.serializer.DataReader;
+import zame.game.core.serializer.DataWriter;
+import zame.game.feature.sound.SoundManager;
+
+public class Door extends DataListItem<Door> implements EngineObject, DataItem {
     private static final int FIELD_X = 1;
     private static final int FIELD_Y = 2;
     private static final int FIELD_TEXTURE = 3;
@@ -18,8 +23,8 @@ public class Door extends DataListItem implements EngineObject, DataItem {
     private static final int FIELD_REQUIRED_KEY = 8;
     private static final int FIELD_UID = 9;
 
-    static final float OPEN_POS_MAX = 0.9f;
-    static final float OPEN_POS_PASSABLE = 0.7f;
+    private static final float OPEN_POS_MAX = 0.9f;
+    public static final float OPEN_POS_PASSABLE = 0.7f;
     private static final int OPEN_TIME = 1000 * 5;
 
     protected Engine engine;
@@ -33,14 +38,14 @@ public class Door extends DataListItem implements EngineObject, DataItem {
     public boolean vert;
     public int uid; // required for save/load for autoWalls
 
-    boolean sticked;
-    int requiredKey;
+    public boolean sticked;
+    public int requiredKey;
 
-    long lastTime;
+    private long lastTime;
     public Mark mark;
 
     @Override
-    public void setEngine(Engine engine) {
+    public void onCreate(Engine engine) {
         this.engine = engine;
         this.state = engine.state;
     }
@@ -84,14 +89,14 @@ public class Door extends DataListItem implements EngineObject, DataItem {
         lastTime = 0;
     }
 
-    void stick(boolean opened, boolean instant) {
+    public void stick(boolean opened, boolean instant) {
         sticked = true;
         dir = (opened ? 1 : -1);
         lastTime = (instant ? 0 : engine.elapsedTime);
         engine.level.requestBuildPathToWave();
     }
 
-    void unstick() {
+    public void unstick() {
         sticked = false;
         engine.level.requestBuildPathToWave();
     }
@@ -117,7 +122,7 @@ public class Door extends DataListItem implements EngineObject, DataItem {
         return true;
     }
 
-    void tryClose() {
+    public void tryClose() {
         if (sticked || (dir != 0) || (openPos < OPEN_POS_MAX)) {
             return;
         } else if ((state.passableMap[y][x] & Level.PASSABLE_MASK_DOOR) != 0) {
@@ -132,14 +137,16 @@ public class Door extends DataListItem implements EngineObject, DataItem {
         engine.soundManager.playSound(SoundManager.SOUND_DOOR_CLOSE, getVolume());
     }
 
-    boolean isOpenedOrCanOpen() {
+    public boolean isOpenedOrCanOpen() {
         return !sticked
                 || (state.passableMap[y][x] & Level.PASSABLE_IS_DOOR) == 0
                 || (requiredKey != 0 && (state.heroKeysMask & requiredKey) != 0);
     }
 
-    public void update(long elapsedTime) {
+    @SuppressWarnings("MagicNumber")
+    public void updateBeforeRender() {
         if (dir > 0) {
+            openPos = (float)(engine.elapsedTime - lastTime) / 300.0f;
             state.wallsMap[y][x] = 0; // clear door mark for PortalTracer
 
             if (openPos >= OPEN_POS_PASSABLE) {
@@ -154,17 +161,27 @@ public class Door extends DataListItem implements EngineObject, DataItem {
                 }
             }
         } else if (dir < 0) {
+            openPos = Door.OPEN_POS_MAX - (float)(engine.elapsedTime - lastTime) / 200.0f;
+
             if (openPos < OPEN_POS_PASSABLE) {
                 if ((dir == -1) && ((state.passableMap[y][x] & Level.PASSABLE_MASK_DOOR) != 0)) {
-                    dir = 1;
-                    lastTime = elapsedTime;
-                } else {
-                    dir = -2;
-
-                    if ((state.passableMap[y][x] & Level.PASSABLE_IS_DOOR) == 0) {
-                        state.passableMap[y][x] |= Level.PASSABLE_IS_DOOR;
-                        engine.level.requestBuildPathToWave();
+                    if (!sticked) {
+                        dir = 1;
+                    }
+
+                    if (openPos <= 0.0f) {
+                        openPos = 0.0f;
                     }
+
+                    lastTime = engine.elapsedTime;
+                    return;
+                }
+
+                dir = -2;
+
+                if ((state.passableMap[y][x] & Level.PASSABLE_IS_DOOR) == 0) {
+                    state.passableMap[y][x] |= Level.PASSABLE_IS_DOOR;
+                    engine.level.requestBuildPathToWave();
                 }
 
                 if (openPos <= 0.0f) {
diff --git a/src/main/java/zame/game/engine/Explosion.java b/src/main/java/zame/game/engine/entity/Explosion.java
similarity index 84%
rename from src/main/java/zame/game/engine/Explosion.java
rename to src/main/java/zame/game/engine/entity/Explosion.java
index 2322a68..ed6cbc1 100644
--- a/src/main/java/zame/game/engine/Explosion.java
+++ b/src/main/java/zame/game/engine/entity/Explosion.java
@@ -1,24 +1,32 @@
-package zame.game.engine;
+package zame.game.engine.entity;
 
 import java.io.IOException;
-import zame.game.engine.data.DataItem;
-import zame.game.engine.data.DataListItem;
-import zame.game.engine.data.DataReader;
-import zame.game.engine.data.DataWriter;
-import zame.game.managers.SoundManager;
-
-public class Explosion extends DataListItem implements EngineObject, DataItem {
+import zame.game.core.serializer.DataItem;
+import zame.game.core.serializer.DataListItem;
+import zame.game.core.serializer.DataReader;
+import zame.game.core.serializer.DataWriter;
+import zame.game.engine.Engine;
+import zame.game.engine.EngineObject;
+import zame.game.engine.Game;
+import zame.game.engine.level.Level;
+import zame.game.engine.level.LevelRenderer;
+import zame.game.engine.state.State;
+import zame.game.feature.achievements.Achievements;
+import zame.game.feature.sound.SoundManager;
+import zame.game.flavour.config.GameConfig;
+
+public class Explosion extends DataListItem<Explosion> implements EngineObject, DataItem {
     private static final int FIELD_X = 1;
     private static final int FIELD_Y = 2;
     private static final int FIELD_MON_UID = 4;
     private static final int FIELD_AMMO_IDX = 5;
     private static final int FIELD_HITS = 6;
-    private static final int FIELD_HIT_TIMEOUT = 7;
+    private static final int FIELD_STUN = 7;
     private static final int FIELD_TICKS_PASSED = 8;
     private static final int FIELD_PREV_TEX_IDX = 9;
 
     private static final int BOOM_ANIMATION_SPEED = 10;
-    private static final int BARREL_HIT_TIMEOUT = 25;
+    private static final int BARREL_STUN = 25;
     private static final int[] barrelBoomTextures = { 1, -2, 3 };
 
     private static final int[][] BOOM_TEXTURES = { null, // AMMO_CLIP
@@ -36,17 +44,17 @@ public class Explosion extends DataListItem implements EngineObject, DataItem {
 
     private int ammoIdx; // -1 for hero hit
     private int hits;
-    private int hitTimeout;
+    private int stun;
     private int ticksPassed;
     private int prevTexIdx;
 
-    int monUid;
-    Monster mon;
+    public int monUid;
+    public Monster mon;
 
     public float x;
     public float y;
 
-    static void boom(State state, float x, float y, Monster mon, int ammoIdx, int hits, int hitTimeout) {
+    static void boom(State state, float x, float y, Monster mon, int ammoIdx, int hits, int stun) {
         if (ammoIdx >= 0 && BOOM_TEXTURES[ammoIdx] == null) {
             return;
         }
@@ -61,7 +69,7 @@ public class Explosion extends DataListItem implements EngineObject, DataItem {
             explosion = state.explosions.take();
         }
 
-        explosion.init(x, y, mon, ammoIdx, hits, hitTimeout);
+        explosion.init(x, y, mon, ammoIdx, hits, stun);
 
         if (!explosion.update()) {
             state.explosions.release(explosion);
@@ -75,11 +83,11 @@ public class Explosion extends DataListItem implements EngineObject, DataItem {
         }
 
         //noinspection MagicNumber
-        boom(state, (float)cx + 0.5f, (float)cy + 0.5f, null, -1, GameParams.HEALTH_HIT_BARREL, BARREL_HIT_TIMEOUT);
+        boom(state, (float)cx + 0.5f, (float)cy + 0.5f, null, -1, GameConfig.HEALTH_HIT_BARREL, BARREL_STUN);
     }
 
     @Override
-    public void setEngine(Engine engine) {
+    public void onCreate(Engine engine) {
         this.engine = engine;
         this.state = engine.state;
         this.game = engine.game;
@@ -94,7 +102,7 @@ public class Explosion extends DataListItem implements EngineObject, DataItem {
         writer.write(FIELD_MON_UID, monUid);
         writer.write(FIELD_AMMO_IDX, ammoIdx);
         writer.write(FIELD_HITS, hits);
-        writer.write(FIELD_HIT_TIMEOUT, hitTimeout);
+        writer.write(FIELD_STUN, stun);
         writer.write(FIELD_TICKS_PASSED, ticksPassed);
         writer.write(FIELD_PREV_TEX_IDX, prevTexIdx);
     }
@@ -106,7 +114,7 @@ public class Explosion extends DataListItem implements EngineObject, DataItem {
         monUid = reader.readInt(FIELD_MON_UID);
         ammoIdx = reader.readInt(FIELD_AMMO_IDX);
         hits = reader.readInt(FIELD_HITS);
-        hitTimeout = reader.readInt(FIELD_HIT_TIMEOUT);
+        stun = reader.readInt(FIELD_STUN);
         ticksPassed = reader.readInt(FIELD_TICKS_PASSED);
         prevTexIdx = reader.readInt(FIELD_PREV_TEX_IDX);
 
@@ -114,14 +122,14 @@ public class Explosion extends DataListItem implements EngineObject, DataItem {
         prevLight = 0.0f;
     }
 
-    public void init(float x, float y, Monster mon, int ammoIdx, int hits, int hitTimeout) {
+    public void init(float x, float y, Monster mon, int ammoIdx, int hits, int stun) {
         this.x = x;
         this.y = y;
         this.mon = mon;
         this.monUid = (mon == null ? -1 : mon.uid);
         this.ammoIdx = ammoIdx;
         this.hits = hits;
-        this.hitTimeout = hitTimeout;
+        this.stun = stun;
 
         ticksPassed = 0;
         prevTexIdx = -1;
@@ -197,6 +205,7 @@ public class Explosion extends DataListItem implements EngineObject, DataItem {
                     | Level.PASSABLE_IS_NOTRANS);
 
             localExplosivesMap[cy][cx] = 0;
+            Achievements.updateStat(Achievements.STAT_BARRELS_EXPLODED, engine.profile, engine, state);
         }
 
         //noinspection BooleanVariableAlwaysNegated
@@ -228,7 +237,7 @@ public class Explosion extends DataListItem implements EngineObject, DataItem {
                     if (target != null) {
                         float dx = target.x - x;
                         float dy = target.y - y;
-                        target.hit(getHits(dx, dy), hitTimeout);
+                        target.hit(getHits(dx, dy), stun);
                     }
                 } else if (((pass & Level.PASSABLE_IS_HERO) != 0) && !alreadyHitHero) {
                     float dx = state.heroX - x;
@@ -269,8 +278,8 @@ public class Explosion extends DataListItem implements EngineObject, DataItem {
                             (float)ty + 0.5f,
                             mon,
                             -1,
-                            GameParams.HEALTH_HIT_BARREL,
-                            BARREL_HIT_TIMEOUT);
+                            GameConfig.HEALTH_HIT_BARREL,
+                            BARREL_STUN);
                 }
             }
         }
diff --git a/src/main/java/zame/game/engine/LookPoint.java b/src/main/java/zame/game/engine/entity/LookPoint.java
similarity index 65%
rename from src/main/java/zame/game/engine/LookPoint.java
rename to src/main/java/zame/game/engine/entity/LookPoint.java
index 9b28006..a7b1161 100644
--- a/src/main/java/zame/game/engine/LookPoint.java
+++ b/src/main/java/zame/game/engine/entity/LookPoint.java
@@ -1,17 +1,17 @@
-package zame.game.engine;
+package zame.game.engine.entity;
 
 import java.io.IOException;
-import zame.game.engine.data.DataItem;
-import zame.game.engine.data.DataListItem;
-import zame.game.engine.data.DataReader;
-import zame.game.engine.data.DataWriter;
+import zame.game.core.serializer.DataItem;
+import zame.game.core.serializer.DataListItem;
+import zame.game.core.serializer.DataReader;
+import zame.game.core.serializer.DataWriter;
 
-public class LookPoint extends DataListItem implements DataItem {
+public class LookPoint extends DataListItem<LookPoint> implements DataItem {
     private static final int FIELD_MARK_ID = 1;
     private static final int FIELD_X = 2;
     private static final int FIELD_Y = 3;
 
-    int markId;
+    public int markId;
     public int x;
     public int y;
 
diff --git a/src/main/java/zame/game/engine/Mark.java b/src/main/java/zame/game/engine/entity/Mark.java
similarity index 55%
rename from src/main/java/zame/game/engine/Mark.java
rename to src/main/java/zame/game/engine/entity/Mark.java
index cbaf62b..1c2a5ab 100644
--- a/src/main/java/zame/game/engine/Mark.java
+++ b/src/main/java/zame/game/engine/entity/Mark.java
@@ -1,21 +1,32 @@
-package zame.game.engine;
+package zame.game.engine.entity;
 
 import java.io.IOException;
-import zame.game.engine.data.DataItem;
-import zame.game.engine.data.DataListItem;
-import zame.game.engine.data.DataReader;
-import zame.game.engine.data.DataWriter;
+import zame.game.core.serializer.DataItem;
+import zame.game.core.serializer.DataListItem;
+import zame.game.core.serializer.DataReader;
+import zame.game.core.serializer.DataWriter;
 
-public class Mark extends DataListItem implements DataItem {
+public class Mark extends DataListItem<Mark> implements DataItem {
     private static final int FIELD_ID = 1;
     private static final int FIELD_X = 2;
     private static final int FIELD_Y = 3;
     private static final int FIELD_ENABLED = 4;
+    private static final int FIELD_UNMARKED = 5;
 
     public int id;
     public int x;
     public int y;
     public boolean enabled = true;
+    public boolean unmarked;
+
+    public void configure(int id, int x, int y) {
+        this.id = id;
+        this.x = x;
+        this.y = y;
+
+        enabled = true;
+        unmarked = false;
+    }
 
     @Override
     public void writeTo(DataWriter writer) throws IOException {
@@ -23,6 +34,7 @@ public class Mark extends DataListItem implements DataItem {
         writer.write(FIELD_X, x);
         writer.write(FIELD_Y, y);
         writer.write(FIELD_ENABLED, enabled);
+        writer.write(FIELD_UNMARKED, unmarked);
     }
 
     @Override
@@ -31,5 +43,6 @@ public class Mark extends DataListItem implements DataItem {
         x = reader.readInt(FIELD_X);
         y = reader.readInt(FIELD_Y);
         enabled = reader.readBoolean(FIELD_ENABLED, true);
+        unmarked = reader.readBoolean(FIELD_UNMARKED);
     }
 }
diff --git a/src/main/java/zame/game/engine/Monster.java b/src/main/java/zame/game/engine/entity/Monster.java
similarity index 80%
rename from src/main/java/zame/game/engine/Monster.java
rename to src/main/java/zame/game/engine/entity/Monster.java
index 0669009..6f6676f 100644
--- a/src/main/java/zame/game/engine/Monster.java
+++ b/src/main/java/zame/game/engine/entity/Monster.java
@@ -1,15 +1,26 @@
-package zame.game.engine;
+package zame.game.engine.entity;
 
 import java.io.IOException;
-import zame.game.engine.data.DataItem;
-import zame.game.engine.data.DataListItem;
-import zame.game.engine.data.DataReader;
-import zame.game.engine.data.DataWriter;
-import zame.game.managers.SoundManager;
-import zame.game.store.Achievements;
-import zame.game.store.Profile;
-
-public class Monster extends DataListItem implements EngineObject, DataItem {
+import zame.game.core.serializer.DataItem;
+import zame.game.core.serializer.DataListItem;
+import zame.game.core.serializer.DataReader;
+import zame.game.core.serializer.DataWriter;
+import zame.game.engine.Engine;
+import zame.game.engine.EngineObject;
+import zame.game.engine.Game;
+import zame.game.engine.graphics.TextureLoader;
+import zame.game.engine.level.Level;
+import zame.game.engine.level.LevelConfig;
+import zame.game.engine.level.LevelRenderer;
+import zame.game.engine.state.Profile;
+import zame.game.engine.state.State;
+import zame.game.engine.util.GameMath;
+import zame.game.engine.visual.Weapons;
+import zame.game.feature.achievements.Achievements;
+import zame.game.feature.sound.SoundManager;
+import zame.game.flavour.config.GameConfig;
+
+public class Monster extends DataListItem<Monster> implements EngineObject, DataItem {
     private static final int FIELD_CELL_X = 1;
     private static final int FIELD_CELL_Y = 2;
     private static final int FIELD_X = 3;
@@ -24,8 +35,8 @@ public class Monster extends DataListItem implements EngineObject, DataItem {
     private static final int FIELD_STEP = 12;
     private static final int FIELD_PREV_X = 13;
     private static final int FIELD_PREV_Y = 14;
-    private static final int FIELD_HIT_TIMEOUT = 15;
-    private static final int FIELD_ATTACK_TIMEOUT = 16;
+    private static final int FIELD_STUN_TICKS = 15;
+    private static final int FIELD_ATTACK_TICKS = 16;
     private static final int FIELD_AROUND_REQ_DIR = 17;
     private static final int FIELD_INVERSE_ROTATION = 18;
     private static final int FIELD_PREV_AROUND_X = 19;
@@ -40,7 +51,11 @@ public class Monster extends DataListItem implements EngineObject, DataItem {
 
     private static final int MAX_STEP = 50;
     private static final int ATTACK_ANIM_TIME = 15;
-    private static final int ATTACK_WAIT_TIME = 40; //       
+
+    private static final int AIM_MIN_TIME = 5; // min aim - 0.125s
+    private static final int AIM_MAX_TIME = 20; // max aim - 0.5s
+    private static final int ATTACK_WAIT_TIME = 40 - AIM_MIN_TIME; // spd ~= 1 hit per second
+
     private static final float VISIBLE_DIST = 32.0f;
     private static final float HEAR_DIST = 5.0f;
 
@@ -56,22 +71,22 @@ public class Monster extends DataListItem implements EngineObject, DataItem {
     public float y;
     public int texture;
     public int dir; // 0 - right, 1 - up, 2 - left, 3 - down
-    public int step;
+    private int step;
     public int health;
     public boolean chaseMode;
     public int shootAngle;
 
-    int uid; // required for save/load for bullets
-    int cellX;
-    int cellY;
-    int prevX = -1;
-    int prevY = -1;
-    int hitTimeout; // hero hits monster
-    int attackTimeout; // attack animation time (not used for anything else)
-    long dieTime;
-    boolean isInAttackState;
-    boolean isAimedOnHero;
-    int onKillActionId = -1;
+    public int uid; // required for save/load for bullets
+    public int cellX;
+    public int cellY;
+    public int prevX = -1;
+    public int prevY = -1;
+    public int stunTicks; // hero hits monster
+    public int attackTicks; // attack animation time (not used for anything else)
+    public long dieTime;
+    public boolean isInAttackState;
+    public boolean isAimedOnHero;
+    public int onKillActionId = -1;
 
     private int hits;
     private int ammoIdx;
@@ -89,7 +104,7 @@ public class Monster extends DataListItem implements EngineObject, DataItem {
     private boolean mustEnableChaseMode;
 
     @Override
-    public void setEngine(Engine engine) {
+    public void onCreate(Engine engine) {
         this.engine = engine;
         this.state = engine.state;
         this.level = engine.level;
@@ -100,14 +115,14 @@ public class Monster extends DataListItem implements EngineObject, DataItem {
     }
 
     @SuppressWarnings("MagicNumber")
-    void configure(int uid, int cellX, int cellY, int monIndex, LevelConfig.MonsterConfig monConf) {
+    public void configure(int uid, int cellX, int cellY, int monIndex, LevelConfig.MonsterConfig monConf) {
         this.uid = uid;
         this.cellX = cellX;
         this.cellY = cellY;
 
         step = 0;
-        hitTimeout = 0;
-        attackTimeout = 0;
+        stunTicks = 0;
+        attackTicks = 0;
         dieTime = 0;
         aroundReqDir = -1;
         inverseRotation = false;
@@ -142,10 +157,10 @@ public class Monster extends DataListItem implements EngineObject, DataItem {
         }
     }
 
-    void postConfigure() {
+    public void postConfigure() {
         int monIndex = texture / TextureLoader.COUNT_MONSTER;
 
-        if (monIndex < 0 || monIndex >= GameParams.MAX_MONSTER_TYPES) {
+        if (monIndex < 0 || monIndex >= GameConfig.MAX_MONSTER_TYPES) {
             monIndex = 0;
         }
 
@@ -169,8 +184,8 @@ public class Monster extends DataListItem implements EngineObject, DataItem {
         writer.write(FIELD_STEP, step);
         writer.write(FIELD_PREV_X, prevX);
         writer.write(FIELD_PREV_Y, prevY);
-        writer.write(FIELD_HIT_TIMEOUT, hitTimeout);
-        writer.write(FIELD_ATTACK_TIMEOUT, attackTimeout);
+        writer.write(FIELD_STUN_TICKS, stunTicks);
+        writer.write(FIELD_ATTACK_TICKS, attackTicks);
         writer.write(FIELD_AROUND_REQ_DIR, aroundReqDir);
         writer.write(FIELD_INVERSE_ROTATION, inverseRotation);
         writer.write(FIELD_PREV_AROUND_X, prevAroundX);
@@ -199,8 +214,8 @@ public class Monster extends DataListItem implements EngineObject, DataItem {
         step = reader.readInt(FIELD_STEP);
         prevX = reader.readInt(FIELD_PREV_X);
         prevY = reader.readInt(FIELD_PREV_Y);
-        hitTimeout = reader.readInt(FIELD_HIT_TIMEOUT);
-        attackTimeout = reader.readInt(FIELD_ATTACK_TIMEOUT);
+        stunTicks = reader.readInt(FIELD_STUN_TICKS);
+        attackTicks = reader.readInt(FIELD_ATTACK_TICKS);
         aroundReqDir = reader.readInt(FIELD_AROUND_REQ_DIR);
         inverseRotation = reader.readBoolean(FIELD_INVERSE_ROTATION);
         prevAroundX = reader.readInt(FIELD_PREV_AROUND_X);
@@ -250,8 +265,8 @@ public class Monster extends DataListItem implements EngineObject, DataItem {
         }
     }
 
-    void hit(int amt, int hitTm) {
-        hitTimeout = hitTm;
+    public void hit(int amt, int stun) {
+        stunTicks += stun; //  STUN,   
         aroundReqDir = -1;
         enableChaseMode();
 
@@ -259,11 +274,11 @@ public class Monster extends DataListItem implements EngineObject, DataItem {
             return;
         }
 
-        health -= Math.max(1, (int)((float)amt * engine.healthHitMonsterMult));
+        health -= Math.max(1, (int)((float)amt * game.healthHitMonsterMult));
 
         if (health <= 0) {
             engine.soundManager.playSound(deathSoundIdx);
-            state.levelExp += GameParams.EXP_KILL_MONSTER;
+            state.levelExp += GameConfig.EXP_KILL_MONSTER;
 
             state.passableMap[cellY][cellX] &= ~Level.PASSABLE_IS_MONSTER;
             state.passableMap[cellY][cellX] |= Level.PASSABLE_IS_DEAD_CORPSE;
@@ -276,27 +291,15 @@ public class Monster extends DataListItem implements EngineObject, DataItem {
             if (ammoIdx >= 0) {
                 int ammoType = Weapons.AMMO_OBJ_TEX_MAP[ammoIdx];
 
-                if ((state.passableMap[cellY][cellX] & Level.PASSABLE_MASK_OBJECT_DROP) == 0) {
-                    state.objectsMap[cellY][cellX] = ammoType;
-
-                    state.passableMap[cellY][cellX] |= Level.PASSABLE_IS_OBJECT
-                            | Level.PASSABLE_IS_OBJECT_DONT_COUNT;
-
-                    levelRenderer.modLightMap(cellX, cellY, LevelRenderer.LIGHT_OBJECT);
-                } else {
+                if (!ObjectContainer.dropAt(ammoType, state, levelRenderer, cellX, cellY)) {
                     outer:
 
                     for (int dy = -1; dy <= 1; dy++) {
                         for (int dx = -1; dx <= 1; dx++) {
-                            if (((dy != 0) || (dx != 0)) && ((state.passableMap[cellY + dy][cellX + dx]
-                                    & Level.PASSABLE_MASK_OBJECT_DROP) == 0)) {
-
-                                state.objectsMap[cellY + dy][cellX + dx] = ammoType;
+                            if (dy != 0
+                                    && dx != 0
+                                    && ObjectContainer.dropAt(ammoType, state, levelRenderer, cellX + dx, cellY + dy)) {
 
-                                state.passableMap[cellY + dy][cellX + dx] |= Level.PASSABLE_IS_OBJECT
-                                        | Level.PASSABLE_IS_OBJECT_DONT_COUNT;
-
-                                levelRenderer.modLightMap(cellX + dx, cellY + dy, LevelRenderer.LIGHT_OBJECT);
                                 break outer;
                             }
                         }
@@ -347,14 +350,14 @@ public class Monster extends DataListItem implements EngineObject, DataItem {
                         GameMath.getAngle(dx, dy, dist),
                         this,
                         ammoIdx,
-                        Math.max(1, (int)((float)hits * engine.healthHitHeroMult)),
+                        Math.max(1, (int)((float)hits * game.healthHitHeroMult)),
                         0);
             }
         }
 
         if (step == 0) {
             boolean tryAround = false;
-            boolean vis = false;
+            boolean isHeroVisibleForShoot = false;
 
             isInAttackState = false;
             isAimedOnHero = false;
@@ -368,18 +371,15 @@ public class Monster extends DataListItem implements EngineObject, DataItem {
             level.monstersPrevMap[prevY][prevX] = this;
 
             if (dist <= VISIBLE_DIST) {
-                if (!chaseMode && ((dist <= HEAR_DIST) || engine.traceLine(x,
-                        y,
-                        state.heroX,
-                        state.heroY,
-                        Level.PASSABLE_MASK_CHASE_WM))) {
+                if (!chaseMode && (dist <= HEAR_DIST
+                        || traceLine(x, y, state.heroX, state.heroY, Level.PASSABLE_MASK_CHASE_WM))) {
 
                     enableChaseMode();
                 }
 
                 // if (chaseMode && ...) - don't additionally traceLine if hero is invisible
-                if (chaseMode && engine.traceLine(x, y, state.heroX, state.heroY, Level.PASSABLE_MASK_SHOOT_WM)) {
-                    vis = true;
+                if (chaseMode && traceLine(x, y, state.heroX, state.heroY, Level.PASSABLE_MASK_SHOOT_WM)) {
+                    isHeroVisibleForShoot = true;
                 }
             }
 
@@ -401,11 +401,7 @@ public class Monster extends DataListItem implements EngineObject, DataItem {
                     tryAround = true;
                 }
 
-                // if (vis) {
-                //     android.util.Log.e("TAG", "dist = " + dist + ", attackDist = " + attackDist + ", x = " + x + ", y = " + y + ", heroX = " + state.heroX + ", heroY = " + state.heroY);
-                // }
-
-                if (vis && (dist <= attackDist)) {
+                if (isHeroVisibleForShoot && dist <= attackDist) {
                     int angleToHero = (int)(GameMath.getAngle(dx, dy, dist) * GameMath.RAD2G_F);
                     int angleDiff = angleToHero - shootAngle;
 
@@ -418,13 +414,13 @@ public class Monster extends DataListItem implements EngineObject, DataItem {
                     angleDiff = (angleDiff < 0 ? -angleDiff : angleDiff);
                     shootAngle = angleToHero;
 
-                    if (!inShootMode || angleDiff > Math.max(1, 15 - (int)(dist * 3.0f))) {
+                    if (!inShootMode || angleDiff > Math.max(1, 15 - (int)(dist * 2.0f))) {
                         inShootMode = true;
-                        step = engine.random.nextInt(20) + 1;
+                        step = engine.random.nextInt(AIM_MAX_TIME - AIM_MIN_TIME) + AIM_MIN_TIME;
                     } else if (inShootMode) {
                         isAimedOnHero = true;
                         shouldShootInHero = true;
-                        attackTimeout = ATTACK_ANIM_TIME;
+                        attackTicks = ATTACK_ANIM_TIME;
                         step = ATTACK_WAIT_TIME;
                     }
 
@@ -512,14 +508,18 @@ public class Monster extends DataListItem implements EngineObject, DataItem {
         x = (float)cellX + ((float)(prevX - cellX) * (float)step / (float)MAX_STEP) + 0.5f;
         y = (float)cellY + ((float)(prevY - cellY) * (float)step / (float)MAX_STEP) + 0.5f;
 
-        if (attackTimeout > 0) {
-            attackTimeout--;
+        if (attackTicks > 0) {
+            attackTicks--;
         }
 
-        if (hitTimeout > 0) {
-            hitTimeout--;
+        if (stunTicks > 0) {
+            stunTicks--;
         } else if (step > 0) {
             step--;
         }
     }
+
+    private boolean traceLine(float x1, float y1, float x2, float y2, int mask) {
+        return GameMath.traceLine(state.levelWidth, state.levelHeight, state.passableMap, x1, y1, x2, y2, mask);
+    }
 }
diff --git a/src/main/java/zame/game/engine/entity/ObjectContainer.java b/src/main/java/zame/game/engine/entity/ObjectContainer.java
new file mode 100644
index 0000000..9ac55fc
--- /dev/null
+++ b/src/main/java/zame/game/engine/entity/ObjectContainer.java
@@ -0,0 +1,86 @@
+package zame.game.engine.entity;
+
+import java.io.IOException;
+import zame.game.core.serializer.DataItem;
+import zame.game.core.serializer.DataListItem;
+import zame.game.core.serializer.DataReader;
+import zame.game.core.serializer.DataWriter;
+import zame.game.engine.level.Level;
+import zame.game.engine.level.LevelRenderer;
+import zame.game.engine.state.State;
+
+public class ObjectContainer extends DataListItem<ObjectContainer> implements DataItem {
+    public static final int MAX_OBJECTS = 8;
+
+    private static final int FIELD_DATA = 1;
+    private static final int FIELD_COUNT = 2;
+
+    public int[] data = new int[MAX_OBJECTS];
+    public int count;
+
+    @Override
+    public void writeTo(DataWriter writer) throws IOException {
+        writer.write(FIELD_DATA, data);
+        writer.write(FIELD_COUNT, count);
+    }
+
+    @Override
+    public void readFrom(DataReader reader) {
+        data = reader.readIntArray(FIELD_DATA, MAX_OBJECTS);
+        count = reader.readInt(FIELD_COUNT);
+    }
+
+    public void clear() {
+        count = 0;
+    }
+
+    public int get(int index) {
+        return data[index];
+    }
+
+    public void set(int index, int value) {
+        data[index] = value;
+    }
+
+    public void removeAt(int index) {
+        for (int i = index, len = count - 1; i < len; i++) {
+            data[i] = data[i + 1];
+        }
+
+        count--;
+    }
+
+    public boolean append(int value) {
+        if (count >= MAX_OBJECTS) {
+            return false;
+        }
+
+        data[count++] = value;
+        return true;
+    }
+
+    static boolean dropAt(int value, State state, LevelRenderer levelRenderer, int cx, int cy) {
+        if (cx < 0
+                || cy < 0
+                || cx >= state.levelWidth
+                || cy >= state.levelHeight
+                || (state.passableMap[cy][cx] & Level.PASSABLE_MASK_OBJECT_DROP) != 0) {
+
+            return false;
+        }
+
+        ObjectContainer container = state.objectsMap.get(cy).get(cx);
+        boolean wasEmpty = container.count == 0;
+
+        if (!container.append(value)) {
+            return false;
+        }
+
+        if (wasEmpty) {
+            state.passableMap[cy][cx] |= Level.PASSABLE_IS_OBJECT;
+            levelRenderer.modLightMap(cx, cy, LevelRenderer.LIGHT_OBJECT);
+        }
+
+        return true;
+    }
+}
diff --git a/src/main/java/zame/game/engine/entity/OnChangeWeaponAction.java b/src/main/java/zame/game/engine/entity/OnChangeWeaponAction.java
new file mode 100644
index 0000000..d27367d
--- /dev/null
+++ b/src/main/java/zame/game/engine/entity/OnChangeWeaponAction.java
@@ -0,0 +1,23 @@
+package zame.game.engine.entity;
+
+import java.io.IOException;
+import zame.game.core.serializer.DataItem;
+import zame.game.core.serializer.DataListItem;
+import zame.game.core.serializer.DataReader;
+import zame.game.core.serializer.DataWriter;
+
+public class OnChangeWeaponAction extends DataListItem<OnChangeWeaponAction> implements DataItem {
+    private static final int FIELD_MARK_ID = 1;
+
+    public int markId;
+
+    @Override
+    public void writeTo(DataWriter writer) throws IOException {
+        writer.write(FIELD_MARK_ID, markId);
+    }
+
+    @Override
+    public void readFrom(DataReader reader) {
+        markId = reader.readInt(FIELD_MARK_ID);
+    }
+}
diff --git a/src/main/java/zame/game/engine/Timeout.java b/src/main/java/zame/game/engine/entity/Timeout.java
similarity index 55%
rename from src/main/java/zame/game/engine/Timeout.java
rename to src/main/java/zame/game/engine/entity/Timeout.java
index 9ce166e..efcef19 100644
--- a/src/main/java/zame/game/engine/Timeout.java
+++ b/src/main/java/zame/game/engine/entity/Timeout.java
@@ -1,17 +1,17 @@
-package zame.game.engine;
+package zame.game.engine.entity;
 
 import java.io.IOException;
-import zame.game.engine.data.DataItem;
-import zame.game.engine.data.DataListItem;
-import zame.game.engine.data.DataReader;
-import zame.game.engine.data.DataWriter;
+import zame.game.core.serializer.DataItem;
+import zame.game.core.serializer.DataListItem;
+import zame.game.core.serializer.DataReader;
+import zame.game.core.serializer.DataWriter;
 
-public class Timeout extends DataListItem implements DataItem {
+public class Timeout extends DataListItem<Timeout> implements DataItem {
 	private static final int FIELD_MARK_ID = 1;
 	private static final int FIELD_DELAY = 2;
 
-	int markId;
-	int delay;
+	public int markId;
+	public int delay;
 
 	@Override
 	public void writeTo(DataWriter writer) throws IOException {
diff --git a/src/main/java/zame/game/engine/TouchedCell.java b/src/main/java/zame/game/engine/entity/TouchedCell.java
similarity index 63%
rename from src/main/java/zame/game/engine/TouchedCell.java
rename to src/main/java/zame/game/engine/entity/TouchedCell.java
index f1b1a41..700a338 100644
--- a/src/main/java/zame/game/engine/TouchedCell.java
+++ b/src/main/java/zame/game/engine/entity/TouchedCell.java
@@ -1,12 +1,12 @@
-package zame.game.engine;
+package zame.game.engine.entity;
 
 import java.io.IOException;
-import zame.game.engine.data.DataItem;
-import zame.game.engine.data.DataListItem;
-import zame.game.engine.data.DataReader;
-import zame.game.engine.data.DataWriter;
+import zame.game.core.serializer.DataItem;
+import zame.game.core.serializer.DataListItem;
+import zame.game.core.serializer.DataReader;
+import zame.game.core.serializer.DataWriter;
 
-public class TouchedCell extends DataListItem implements DataItem {
+public class TouchedCell extends DataListItem<TouchedCell> implements DataItem {
     private static final int FIELD_X = 1;
     private static final int FIELD_Y = 2;
 
@@ -18,7 +18,7 @@ public class TouchedCell extends DataListItem implements DataItem {
         this.y = y;
     }
 
-    void copyFrom(TouchedCell tc) {
+    public void copyFrom(TouchedCell tc) {
         x = tc.x;
         y = tc.y;
     }
diff --git a/src/main/java/zame/game/engine/entity/WaveCell.java b/src/main/java/zame/game/engine/entity/WaveCell.java
new file mode 100644
index 0000000..2cae635
--- /dev/null
+++ b/src/main/java/zame/game/engine/entity/WaveCell.java
@@ -0,0 +1,11 @@
+package zame.game.engine.entity;
+
+public class WaveCell {
+    public int x;
+    public int y;
+
+    public void initFrom(int x, int y) {
+        this.x = x;
+        this.y = y;
+    }
+}
diff --git a/src/main/java/zame/game/engine/graphics/Labels.java b/src/main/java/zame/game/engine/graphics/Labels.java
new file mode 100644
index 0000000..8e04078
--- /dev/null
+++ b/src/main/java/zame/game/engine/graphics/Labels.java
@@ -0,0 +1,460 @@
+package zame.game.engine.graphics;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Rect;
+import android.graphics.Typeface;
+import java.util.HashMap;
+import zame.game.R;
+import zame.game.core.util.Common;
+import zame.game.engine.Engine;
+import zame.game.engine.EngineObject;
+import zame.game.feature.achievements.Achievements;
+
+public class Labels implements EngineObject {
+    private static final int TEX_WIDTH = 1024;
+    private static final int TEX_HEIGHT = 1024;
+    private static final int TEX_WIDTH_LOW = 512;
+    private static final int TEX_HEIGHT_LOW = 512;
+
+    public static final int ALIGN_BL = 0; // bottom left
+    public static final int ALIGN_CC = 1; // center center
+    public static final int ALIGN_CL = 2; // center left
+    public static final int ALIGN_CR = 3; // center left
+
+    public static final int LABEL_FPS = 0;
+    public static final int LABEL_CANT_OPEN = 1;
+    public static final int LABEL_NEED_BLUE_KEY = 2;
+    public static final int LABEL_NEED_RED_KEY = 3;
+    public static final int LABEL_NEED_GREEN_KEY = 4;
+    public static final int LABEL_SECRET_FOUND = 5;
+    public static final int LABEL_ENDL_KILLS = 6;
+    public static final int LABEL_ENDL_SECRETS = 7;
+    public static final int LABEL_ENDL_TIME = 8;
+    public static final int LABEL_GAMEOVER = 9;
+    public static final int LABEL_GAMEOVER_SUBTITLE = 10;
+    public static final int LABEL_GAMEOVER_SUBTITLE_LEFT_HAND_AIM = 11;
+    public static final int LABEL_GAMEOVER_SUBTITLE_JUST_RESTART = 12;
+    public static final int LABEL_ACHIEVEMENT_UNLOCKED = 13;
+
+    public static final int LABEL_HELP_MOVE = 14;
+    public static final int LABEL_HELP_ROTATE = 15;
+    public static final int LABEL_HELP_FIRE = 16;
+    public static final int LABEL_HELP_WEAPONS = 17;
+    public static final int LABEL_HELP_QUICK_WEAPONS = 18;
+    public static final int LABEL_HELP_MINIMAP = 19;
+    public static final int LABEL_HELP_STATS_HEALTH = 20;
+    public static final int LABEL_HELP_STATS_AMMO = 21;
+    public static final int LABEL_HELP_STATS_ARMOR = 22;
+    public static final int LABEL_HELP_STATS_KEYS = 23;
+    public static final int LABEL_HELP_DO_NOT_ROTATE = 24;
+
+    private static final int LABEL_MESSAGE_3 = 25;
+    private static final int LABEL_MESSAGE_2 = 26;
+    private static final int LABEL_MESSAGE_1 = 27;
+    private static final int LABEL_MESSAGE_WELCOME_TO_TRAINING_AREA = 28;
+    private static final int LABEL_MESSAGE_USE_MOVEMENT_PAD_TO_FOLLOW_ARROWS = 29;
+    private static final int LABEL_MESSAGE_DOING_WELL = 30;
+    private static final int LABEL_MESSAGE_SLIDE_TO_ROTATE = 31;
+    private static final int LABEL_MESSAGE_MOVE_AND_ROTATE_TO_FOLLOW_ARROWS = 32;
+    private static final int LABEL_MESSAGE_USE_MINIMAP_TO_FOLLOW_PATH = 33;
+    private static final int LABEL_MESSAGE_TO_OPEN_DOOR_GO_THROUGH_IT = 34;
+    private static final int LABEL_MESSAGE_NEXT_DOOR_IS_CLOSED_USE_SWITCH = 35;
+    private static final int LABEL_MESSAGE_TO_ACTIVATE_SWITCH_GO_UP_TO_HIM = 36;
+    private static final int LABEL_MESSAGE_THIS_IS_WINDOW = 37;
+    private static final int LABEL_MESSAGE_TO_OPEN_DOOR_PICKUP_KEY = 38;
+    private static final int LABEL_MESSAGE_PRESS_END_LEVEL = 39;
+    private static final int LABEL_MESSAGE_USE_FIRE_AND_KILL_ENEMY = 40;
+    private static final int LABEL_MESSAGE_PICKUP_MEDI = 41;
+    private static final int LABEL_MESSAGE_OPEN_WEAPON_MENU_AND_SELECT_PISTOL = 42;
+    private static final int LABEL_MESSAGE_PICKUP_AMMO = 43;
+    private static final int LABEL_MESSAGE_QUICK_CHANGE_WEAPON = 44;
+    private static final int LABEL_MESSAGE_AFTER_QUICK_CHANGE_WEAPON = 45;
+    private static final int LABEL_MESSAGE_PICKUP_ARMOR = 46;
+    private static final int LABEL_MESSAGE_AFTER_PICKUP_ARMOR = 47;
+
+    public static final int LABEL_LAST = 48;
+
+    public String[] map = new String[LABEL_LAST];
+
+    private Engine engine;
+    private Renderer renderer;
+    private Paint paint;
+    private HashMap<Character, Rect> charMap = new HashMap<>();
+    @SuppressWarnings("MagicNumber") private Rect[] numberMap = new Rect[11];
+    private int lastTexX;
+    private int lastTexY;
+    private int textAscent;
+    private int textHeight;
+    private int spaceWidth;
+
+    @Override
+    public void onCreate(Engine engine) {
+        this.engine = engine;
+        this.renderer = engine.renderer;
+    }
+
+    @SuppressWarnings("MagicNumber")
+    public void reload() {
+        Typeface typeface = Common.loadIngameTypeface(engine.activity);
+
+        if (typeface == null) {
+            typeface = Typeface.DEFAULT;
+        }
+
+        paint = new Paint();
+        paint.setTypeface(typeface);
+        paint.setAntiAlias(true);
+        paint.setARGB(0xFF, 0xFF, 0xFF, 0xFF);
+        paint.setTextSize(64);
+    }
+
+    public void createLabels() {
+        Bitmap bitmap = Common.createBitmap(TEX_WIDTH,
+                TEX_HEIGHT,
+                TEX_WIDTH_LOW,
+                TEX_HEIGHT_LOW,
+                "Can't alloc bitmap for labels");
+
+        Canvas canvas = new Canvas(bitmap);
+        canvas.setDensity(Bitmap.DENSITY_NONE);
+
+        Context context = engine.activity;
+        charMap.clear();
+        lastTexX = 0;
+        lastTexY = 0;
+
+        textAscent = (int)Math.ceil(-paint.ascent()); // Paint.ascent is negative, so negate it
+        textHeight = textAscent + (int)Math.ceil(paint.descent());
+        spaceWidth = (int)Math.ceil(paint.measureText(" "));
+
+        appendChars(canvas, "0123456789-");
+
+        map[LABEL_FPS] = appendChars(canvas, context.getString(R.string.engine_lbl_fps));
+        map[LABEL_CANT_OPEN] = appendChars(canvas, context.getString(R.string.engine_lbl_cant_open_door));
+        map[LABEL_NEED_BLUE_KEY] = appendChars(canvas, context.getString(R.string.engine_lbl_need_blue_key));
+        map[LABEL_NEED_RED_KEY] = appendChars(canvas, context.getString(R.string.engine_lbl_need_red_key));
+        map[LABEL_NEED_GREEN_KEY] = appendChars(canvas, context.getString(R.string.engine_lbl_need_green_key));
+        map[LABEL_SECRET_FOUND] = appendChars(canvas, context.getString(R.string.engine_lbl_secret_found));
+        map[LABEL_ENDL_KILLS] = appendChars(canvas, context.getString(R.string.engine_lbl_endl_kills));
+        map[LABEL_ENDL_SECRETS] = appendChars(canvas, context.getString(R.string.engine_lbl_endl_secrets));
+        map[LABEL_ENDL_TIME] = appendChars(canvas, context.getString(R.string.engine_lbl_endl_time));
+        map[LABEL_GAMEOVER] = appendChars(canvas, context.getString(R.string.engine_lbl_gameover));
+
+        map[LABEL_GAMEOVER_SUBTITLE] = appendChars(
+                canvas,
+                context.getString(R.string.engine_lbl_gameover_restart)
+                        + " / "
+                        + context.getString(R.string.engine_lbl_gameover_continue));
+
+        map[LABEL_GAMEOVER_SUBTITLE_LEFT_HAND_AIM] = appendChars(
+                canvas,
+                context.getString(R.string.engine_lbl_gameover_continue)
+                        + " / "
+                        + context.getString(R.string.engine_lbl_gameover_restart));
+
+        map[LABEL_GAMEOVER_SUBTITLE_JUST_RESTART] = appendChars(canvas,
+                context.getString(R.string.engine_lbl_gameover_restart));
+
+        map[LABEL_ACHIEVEMENT_UNLOCKED] = appendChars(canvas,
+                context.getString(R.string.engine_lbl_achievement_unlocked));
+
+        map[LABEL_HELP_MOVE] = appendChars(canvas, context.getString(R.string.engine_lblh_move));
+        map[LABEL_HELP_ROTATE] = appendChars(canvas, context.getString(R.string.engine_lblh_rotate));
+        map[LABEL_HELP_FIRE] = appendChars(canvas, context.getString(R.string.engine_lblh_fire));
+        map[LABEL_HELP_WEAPONS] = appendChars(canvas, context.getString(R.string.engine_lblh_weapons));
+        map[LABEL_HELP_QUICK_WEAPONS] = appendChars(canvas, context.getString(R.string.engine_lblh_quick_weapons));
+        map[LABEL_HELP_MINIMAP] = appendChars(canvas, context.getString(R.string.engine_lblh_minimap));
+        map[LABEL_HELP_STATS_HEALTH] = appendChars(canvas, context.getString(R.string.engine_lblh_stats_health));
+        map[LABEL_HELP_STATS_AMMO] = appendChars(canvas, context.getString(R.string.engine_lblh_stats_ammo));
+        map[LABEL_HELP_STATS_ARMOR] = appendChars(canvas, context.getString(R.string.engine_lblh_stats_armor));
+        map[LABEL_HELP_STATS_KEYS] = appendChars(canvas, context.getString(R.string.engine_lblh_stats_keys));
+        map[LABEL_HELP_DO_NOT_ROTATE] = appendChars(canvas, context.getString(R.string.engine_lblh_do_not_rotate));
+
+        map[LABEL_MESSAGE_3] = appendChars(canvas, context.getString(R.string.engine_lblm_3));
+        map[LABEL_MESSAGE_2] = appendChars(canvas, context.getString(R.string.engine_lblm_2));
+        map[LABEL_MESSAGE_1] = appendChars(canvas, context.getString(R.string.engine_lblm_1));
+
+        map[LABEL_MESSAGE_WELCOME_TO_TRAINING_AREA] = appendChars(canvas,
+                context.getString(R.string.engine_lblm_welcome_to_training_area));
+
+        map[LABEL_MESSAGE_USE_MOVEMENT_PAD_TO_FOLLOW_ARROWS] = appendChars(canvas,
+                context.getString(R.string.engine_lblm_use_move_pad_to_follow_arrows));
+
+        map[LABEL_MESSAGE_DOING_WELL] = appendChars(canvas, context.getString(R.string.engine_lblm_doing_well));
+
+        map[LABEL_MESSAGE_SLIDE_TO_ROTATE] = appendChars(canvas,
+                context.getString(R.string.engine_lblm_slide_to_rotate));
+
+        map[LABEL_MESSAGE_MOVE_AND_ROTATE_TO_FOLLOW_ARROWS] = appendChars(canvas,
+                context.getString(R.string.engine_lblm_move_and_rotate_to_follow_arrows));
+
+        map[LABEL_MESSAGE_USE_MINIMAP_TO_FOLLOW_PATH] = appendChars(canvas,
+                context.getString(R.string.engine_lblm_use_minimap_to_follow_path));
+
+        map[LABEL_MESSAGE_TO_OPEN_DOOR_GO_THROUGH_IT] = appendChars(canvas,
+                context.getString(R.string.engine_lblm_to_open_door_go_through_it));
+
+        map[LABEL_MESSAGE_NEXT_DOOR_IS_CLOSED_USE_SWITCH] = appendChars(canvas,
+                context.getString(R.string.engine_lblm_next_door_is_closed_use_switch));
+
+        map[LABEL_MESSAGE_TO_ACTIVATE_SWITCH_GO_UP_TO_HIM] = appendChars(canvas,
+                context.getString(R.string.engine_lblm_to_activate_switch_go_up_to_him));
+
+        map[LABEL_MESSAGE_THIS_IS_WINDOW] = appendChars(canvas, context.getString(R.string.engine_lblm_this_is_window));
+
+        map[LABEL_MESSAGE_TO_OPEN_DOOR_PICKUP_KEY] = appendChars(canvas,
+                context.getString(R.string.engine_lblm_to_open_door_pickup_key));
+
+        map[LABEL_MESSAGE_PRESS_END_LEVEL] = appendChars(canvas,
+                context.getString(R.string.engine_lblm_press_end_level));
+
+        map[LABEL_MESSAGE_USE_FIRE_AND_KILL_ENEMY] = appendChars(canvas,
+                context.getString(R.string.engine_lblm_use_fire_and_kill_enemy));
+
+        map[LABEL_MESSAGE_PICKUP_MEDI] = appendChars(canvas, context.getString(R.string.engine_lblm_pickup_medi));
+
+        map[LABEL_MESSAGE_OPEN_WEAPON_MENU_AND_SELECT_PISTOL] = appendChars(canvas,
+                context.getString(R.string.engine_lblm_open_weapon_menu_and_select_pistol));
+
+        map[LABEL_MESSAGE_PICKUP_AMMO] = appendChars(canvas, context.getString(R.string.engine_lblm_pickup_ammo));
+
+        map[LABEL_MESSAGE_QUICK_CHANGE_WEAPON] = appendChars(canvas,
+                context.getString(R.string.engine_lblm_quick_change_weapon));
+
+        map[LABEL_MESSAGE_AFTER_QUICK_CHANGE_WEAPON] = appendChars(canvas,
+                context.getString(R.string.engine_lblm_after_quick_change_weapon));
+
+        map[LABEL_MESSAGE_PICKUP_ARMOR] = appendChars(canvas, context.getString(R.string.engine_lblm_pickup_armor));
+
+        map[LABEL_MESSAGE_AFTER_PICKUP_ARMOR] = appendChars(canvas,
+                context.getString(R.string.engine_lblm_after_pickup_armor));
+
+        for (int i = 0, len = Achievements.LIST.length; i < len; i++) {
+            appendChars(canvas, Achievements.cleanupTitle(context.getString(Achievements.LIST[i].titleResourceId)));
+        }
+
+        renderer.bitmapToTexture(Renderer.TEXTURE_LABELS, bitmap);
+
+        //noinspection UnusedAssignment
+        canvas = null;
+
+        bitmap.recycle();
+
+        //noinspection UnusedAssignment
+        bitmap = null;
+
+        System.gc();
+    }
+
+    private String appendChars(Canvas canvas, String str) {
+        for (int i = 0, len = str.length(); i < len; i++) {
+            char ch = str.charAt(i);
+
+            if (ch != ' ' && !charMap.containsKey(ch)) {
+                String chStr = String.valueOf(ch);
+                int textWidth = (int)Math.ceil(paint.measureText(chStr));
+
+                if ((lastTexX + textWidth + 1) >= TEX_WIDTH) {
+                    if ((lastTexY + textHeight + 1) >= TEX_HEIGHT) {
+                        Common.log("Labels.appendChars: no free texture space");
+                        continue;
+                    }
+
+                    lastTexX = 0;
+                    lastTexY += (textHeight + 2);
+                }
+
+                Rect rect = new Rect(lastTexX + 1, lastTexY + 1, lastTexX + textWidth + 1, lastTexY + textHeight + 1);
+                canvas.drawText(chStr, (float)(lastTexX + 1), (float)(lastTexY + textAscent + 1), paint);
+                lastTexX += textWidth + 2;
+
+                charMap.put(ch, rect);
+
+                if (ch == '-') {
+                    numberMap[10] = rect;
+                } else if (ch >= '0' && ch <= '9') {
+                    numberMap[Character.digit(ch, 10)] = rect;
+                }
+            }
+        }
+
+        return str;
+    }
+
+    private float batchCharacter(Rect rect, float xpos, float ypos, float scale) {
+        if (rect == null) {
+            return (float)spaceWidth * scale;
+        }
+
+        //noinspection MagicNumber
+        renderer.setTexRect(
+                (rect.left << 16) / TEX_WIDTH,
+                (rect.bottom << 16) / TEX_HEIGHT,
+                (rect.right << 16) / TEX_WIDTH,
+                (rect.top << 16) / TEX_HEIGHT
+        );
+
+        renderer.setCoordsQuadRectFlat(
+                xpos,
+                ypos,
+                xpos + (float)(rect.width() - 1) * scale,
+                ypos + (float)(textHeight - 1) * scale
+        );
+
+        renderer.batchQuad();
+        return (float)rect.width() * scale;
+    }
+
+    public void startBatch() {
+        startBatch(false);
+    }
+
+    public void startBatch(boolean customMatrices) {
+        if (!customMatrices) {
+            renderer.useOrtho(-engine.ratio, engine.ratio, -1.0f, 1.0f, 0.0f, 1.0f);
+        }
+
+        renderer.startBatch();
+    }
+
+    @SuppressWarnings("MagicNumber")
+    public void batch(float sx,
+            float sy,
+            float ex,
+            float ey,
+            String str,
+            float desiredHeight,
+            int align) {
+
+        float scale = desiredHeight / (float)textHeight;
+        float width = (float)getWidth(str);
+
+        if ((width * scale) > (ex - sx)) {
+            scale = (ex - sx) / width;
+        }
+
+        if (align == ALIGN_CC || align == ALIGN_CL || align == ALIGN_CR) {
+            sy += (ey - sy - (float)textHeight * scale) * 0.5f;
+        }
+
+        if (align == ALIGN_CC) {
+            sx += (ex - sx - width * scale) * 0.5f;
+        } else if (align == ALIGN_CR) {
+            sx = ex - width * scale;
+        }
+
+        for (int i = 0, len = str.length(); i < len; i++) {
+            char ch = str.charAt(i);
+            sx += batchCharacter((ch == ' ' ? null : charMap.get(ch)), sx, sy, scale);
+        }
+    }
+
+    @SuppressWarnings("MagicNumber")
+    public void batch(float sx,
+            float sy,
+            float ex,
+            float ey,
+            int value,
+            float desiredHeight,
+            int align) {
+
+        float scale = desiredHeight / (float)textHeight;
+        float width = (float)getWidth(value);
+
+        if ((width * scale) > (ex - sx)) {
+            scale = (ex - sx) / width;
+        }
+
+        if (align == ALIGN_CC || align == ALIGN_CL || align == ALIGN_CR) {
+            sy += (ey - sy - (float)textHeight * scale) * 0.5f;
+        }
+
+        if (align == ALIGN_CC) {
+            sx += (ex - sx - width * scale) * 0.5f;
+        } else if (align == ALIGN_CR) {
+            sx = ex - width * scale;
+        }
+
+        if (value == 0) {
+            batchCharacter(numberMap[0], sx, sy, scale);
+            return;
+        }
+
+        if (value < 0) {
+            sx += batchCharacter(numberMap[10], sx, sy, scale);
+            value = -value;
+        }
+
+        int divider = 1;
+        int tmpValue = value / 10;
+
+        while (tmpValue > 0) {
+            divider *= 10;
+            tmpValue /= 10;
+        }
+
+        while (divider > 0) {
+            sx += batchCharacter(numberMap[(value / divider) % 10], sx, sy, scale);
+            divider /= 10;
+        }
+    }
+
+    public void renderBatch() {
+        renderer.renderBatch(Renderer.FLAG_BLEND, Renderer.TEXTURE_LABELS);
+    }
+
+    public float getScaledWidth(String str, @SuppressWarnings("SameParameterValue") float desiredHeight) {
+        float scale = desiredHeight / (float)textHeight;
+        float width = (float)getWidth(str);
+
+        return width * scale;
+    }
+
+    private int getWidth(String str) {
+        int result = 0;
+
+        for (int i = 0, len = str.length(); i < len; i++) {
+            char ch = str.charAt(i);
+
+            if (ch == ' ') {
+                result += spaceWidth;
+            } else {
+                Rect rect = charMap.get(ch);
+                result += (rect == null ? spaceWidth : rect.width());
+            }
+        }
+
+        return result;
+    }
+
+    @SuppressWarnings("unused")
+    public float getScaledWidth(int value, float desiredHeight) {
+        float scale = desiredHeight / (float)textHeight;
+        float width = (float)getWidth(value);
+
+        return width * scale;
+    }
+
+    private int getWidth(int value) {
+        if (value == 0) {
+            return numberMap[0].width();
+        }
+
+        int result = 0;
+
+        if (value < 0) {
+            result += numberMap[10].width();
+            value = -value;
+        }
+
+        while (value > 0) {
+            result += numberMap[value % 10].width();
+            value /= 10;
+        }
+
+        return result;
+    }
+}
diff --git a/src/main/java/zame/game/engine/graphics/Renderer.java b/src/main/java/zame/game/engine/graphics/Renderer.java
new file mode 100644
index 0000000..117989c
--- /dev/null
+++ b/src/main/java/zame/game/engine/graphics/Renderer.java
@@ -0,0 +1,993 @@
+package zame.game.engine.graphics;
+
+import android.graphics.Bitmap;
+import android.opengl.GLUtils;
+import javax.microedition.khronos.opengles.GL10;
+import javax.microedition.khronos.opengles.GL11ExtensionPack;
+import zame.game.core.util.Common;
+import zame.game.engine.Config;
+import zame.game.engine.Engine;
+import zame.game.engine.EngineObject;
+
+// http://stackoverflow.com/questions/1848886/jni-c-library-passing-byte-ptr
+// http://groups.google.com/group/android-ndk/tree/browse_frm/month/2010-01?_done=/group/android-ndk/browse_frm/month/2010-01%3F&
+
+// Native buffers (aka ByteBuffer, ShortBuffer and FloatBuffer) suck in DalvikVM. It is terribly slow.
+// So native code used to render. It's up to 4x faster than java code with native buffers.
+
+// According to qualcomm docs, you need to glclear after every glbindframebuffer,
+// this is a problem related to tiled architecture, if you are switching framebuffers,
+// data need to get copied from fastmem to normal memory to save current framebuffer
+// and from slowmem to fast mem to get contents of newly binded frame, in case you are
+// clearing just after glbind no data is copied from slowmem to fastmem and you are saving time,
+// but you need to redesign your render pipeline often, so it will avoid reading data back
+// and forth between slow and fast memory, so try to do glclear after each bind
+
+@SuppressWarnings("MagicNumber")
+public class Renderer implements EngineObject {
+    private static final int MAX_QUADS = 64 * 64 * 2; // (64*64*2 * (12*4 + 16*4 + 8*4 + 6*2 + 4*4 + 8*4))
+
+    private static final int SIZE_RTT_FBO = 512;
+    private static final int SIZE_RTT_FALLBACK = 256;
+
+    public static final int SIZE_TILE = 128;
+    private static final int SIZE_TILE_MON = 256;
+
+    private static final int TEX_CELL_X = ((SIZE_TILE + 2) << 16) / 2048;
+    private static final int TEX_CELL_Y = ((SIZE_TILE + 2) << 16) / 2048;
+    private static final int TEX_MON_CELL_X = ((SIZE_TILE_MON + 2) << 16) / 2048;
+    private static final int TEX_MON_CELL_Y = ((SIZE_TILE_MON + 2) << 16) / 2048;
+    private static final int TEX_1PX_X = (1 << 16) / 2048;
+    private static final int TEX_1PX_Y = (1 << 16) / 2048;
+    private static final int TEX_SIZE_X = (SIZE_TILE << 16) / 2048;
+    private static final int TEX_SIZE_Y = (SIZE_TILE << 16) / 2048;
+    private static final int TEX_MON_SIZE_X = (SIZE_TILE_MON << 16) / 2048;
+    private static final int TEX_MON_SIZE_Y = (SIZE_TILE_MON << 16) / 2048;
+    private static final int TEX_SIZE_X_D2 = ((SIZE_TILE / 2) << 16) / 2048;
+    private static final int TEX_SIZE_Y_D2 = ((SIZE_TILE / 2) << 16) / 2048;
+    private static final int TEX_SIZE_X_D2_1PX = TEX_SIZE_X_D2 + TEX_1PX_X;
+    private static final int TEX_SIZE_Y_D2_1PX = TEX_SIZE_Y_D2 + TEX_1PX_Y;
+    private static final int TEX_SIZE_X_X2 = ((SIZE_TILE * 2) << 16) / 2048;
+    private static final int TEX_SIZE_Y_X2 = ((SIZE_TILE * 2) << 16) / 2048;
+    private static final int TEX_EXTR_X_FROM = ((SIZE_TILE / 2 - SIZE_TILE / 16 / 2) << 16) / 2048;
+    private static final int TEX_EXTR_X_SIZE = ((SIZE_TILE / 16) << 16) / 2048;
+    // private static final int TEX_SIZE_X_X4 = ((SIZE_TILE * 4) << 16) / 2048;
+
+    // ----
+
+    public static final int TEXTURE_LOADING = 0;
+    static final int TEXTURE_LABELS = TEXTURE_LOADING + 1;
+    public static final int TEXTURE_MAIN = TEXTURE_LABELS + 1;
+    public static final int TEXTURE_KNIFE = TEXTURE_MAIN + 1;
+    public static final int TEXTURE_PISTOL = TEXTURE_KNIFE + 4;
+    public static final int TEXTURE_DBLPISTOL = TEXTURE_PISTOL + 4;
+    public static final int TEXTURE_SHTG = TEXTURE_DBLPISTOL + 4;
+    public static final int TEXTURE_AK47 = TEXTURE_SHTG + 5;
+    public static final int TEXTURE_TMP = TEXTURE_AK47 + 4;
+    public static final int TEXTURE_GRENADE = TEXTURE_TMP + 4;
+    public static final int TEXTURE_MONSTERS = TEXTURE_GRENADE + 8;
+    public static final int TEXTURE_SKY = TEXTURE_MONSTERS + 2;
+    public static final int TEXTURE_RTT = TEXTURE_SKY + 1;
+    private static final int TEXTURE_LAST = TEXTURE_RTT + 1;
+
+    // ----
+
+    public static final int FLAG_CULL = 1;
+    public static final int FLAG_DEPTH = 2;
+    public static final int FLAG_ALPHA = 4;
+    public static final int FLAG_ALPHA_LOWER = 8;
+    public static final int FLAG_BLEND = 16;
+    public static final int FLAG_BLEND_GAMMA = 32;
+    public static final int FLAG_SMOOTH = 64;
+    public static final int FLAG_STENCIL_REPLACE = 128;
+    public static final int FLAG_STENCIL_KEEP = 256;
+    public static final int FLAG_TEX_REPEAT = 512;
+
+    private static final int MASK_FLAG_TEX = FLAG_TEX_REPEAT;
+
+    // ----
+
+    private Engine engine;
+    private Config config;
+
+    public GL10 gl;
+    private GL11ExtensionPack gl11ep;
+    @SuppressWarnings("BooleanVariableAlwaysNegated") private boolean isFboSupported;
+    private boolean isTexturesCreated;
+    private int[] textures = new int[TEXTURE_LAST];
+    private boolean isFramebufferPrepared;
+    private int lastRenderFlags = -1;
+    private int lastTexture = -1;
+    private int lastTextureFlags = -1;
+    private int[] frameBuffers = new int[1];
+    private int[] depthBuffers = new int[1];
+
+    private float[] vertexBuffer = new float[MAX_QUADS * 12];
+    private float[] colorsBuffer = new float[MAX_QUADS * 16];
+    private int[] textureBuffer = new int[MAX_QUADS * 8];
+    private short[] indicesBuffer = new short[MAX_QUADS * 6];
+    private float[] lineVertexBuffer = new float[MAX_QUADS * 4];
+    private float[] lineColorsBuffer = new float[MAX_QUADS * 8];
+
+    private short vertexCount;
+    private short lineVertexCount;
+
+    private int vertexBufferPos;
+    private int colorsBufferPos;
+    private int textureBufferPos;
+    private int indicesBufferPos;
+    private int lineVertexBufferPos;
+    private int lineColorsBufferPos;
+
+    // ----
+
+    public float x1;
+    public float y1;
+    public float z1;
+    public int u1;
+    public int v1;
+    public float r1;
+    public float g1;
+    public float b1;
+    public float a1;
+
+    public float x2;
+    public float y2;
+    public float z2;
+    public int u2;
+    public int v2;
+    public float r2;
+    public float g2;
+    public float b2;
+    public float a2;
+
+    public float x3;
+    public float y3;
+    public float z3;
+    private int u3;
+    public int v3;
+    public float r3;
+    public float g3;
+    public float b3;
+    public float a3;
+
+    public float x4;
+    public float y4;
+    public float z4;
+    private int u4;
+    public int v4;
+    public float r4;
+    public float g4;
+    public float b4;
+    public float a4;
+
+    // ----
+
+    static {
+        System.loadLibrary("renderer");
+    }
+
+    private static native void renderTriangles(float[] vertexBuf,
+            float[] colorsBuf,
+            int[] textureBuf,
+            short[] indicesBuf,
+            int indicesBufPos);
+
+    private static native void renderLines(float[] vertexBuf, float[] colorsBuf, int vertexCount);
+
+    // ----
+
+    @Override
+    public void onCreate(Engine engine) {
+        this.engine = engine;
+        this.config = engine.config;
+    }
+
+    public void onSurfaceCreated(GL10 gl) {
+        onSurfaceChanged(gl);
+
+        if (isTexturesCreated) {
+            gl.glDeleteTextures(TEXTURE_LAST, textures, 0);
+        }
+
+        gl.glGenTextures(TEXTURE_LAST, textures, 0);
+        gl.glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
+
+        isTexturesCreated = true;
+        isFboSupported = ((" " + gl.glGetString(GL10.GL_EXTENSIONS) + " ").contains(" GL_OES_framebuffer_object "));
+    }
+
+    public void onSurfaceChanged(GL10 gl) {
+        onDrawFrame(gl);
+        isFramebufferPrepared = false;
+    }
+
+    public void onDrawFrame(GL10 gl) {
+        this.gl = gl;
+        this.gl11ep = (GL11ExtensionPack)gl;
+
+        lastRenderFlags = -1;
+        lastTexture = -1;
+        lastTextureFlags = -1;
+    }
+
+    public void prepareFramebuffer() {
+        if (!isFboSupported || gl11ep == null) {
+            return;
+        }
+
+        bindTexture(TEXTURE_RTT);
+
+        gl.glTexImage2D(GL10.GL_TEXTURE_2D,
+                0,
+                GL10.GL_RGBA,
+                SIZE_RTT_FBO,
+                SIZE_RTT_FBO,
+                0,
+                GL10.GL_RGBA,
+                GL10.GL_UNSIGNED_BYTE,
+                null);
+
+        // ----
+
+        gl11ep.glGenFramebuffersOES(1, frameBuffers, 0);
+        gl11ep.glBindFramebufferOES(GL11ExtensionPack.GL_FRAMEBUFFER_OES, frameBuffers[0]);
+        clear();
+
+        gl11ep.glGenRenderbuffersOES(1, depthBuffers, 0);
+        gl11ep.glBindRenderbufferOES(GL11ExtensionPack.GL_RENDERBUFFER_OES, depthBuffers[0]);
+
+        gl11ep.glRenderbufferStorageOES(GL11ExtensionPack.GL_RENDERBUFFER_OES,
+                GL11ExtensionPack.GL_DEPTH_COMPONENT16,
+                SIZE_RTT_FBO,
+                SIZE_RTT_FBO);
+
+        gl11ep.glFramebufferRenderbufferOES(GL11ExtensionPack.GL_FRAMEBUFFER_OES,
+                GL11ExtensionPack.GL_DEPTH_ATTACHMENT_OES,
+                GL11ExtensionPack.GL_RENDERBUFFER_OES,
+                depthBuffers[0]);
+
+        gl11ep.glFramebufferTexture2DOES(GL11ExtensionPack.GL_FRAMEBUFFER_OES,
+                GL11ExtensionPack.GL_COLOR_ATTACHMENT0_OES,
+                GL10.GL_TEXTURE_2D,
+                textures[TEXTURE_RTT],
+                0);
+
+        if (gl11ep.glCheckFramebufferStatusOES(GL11ExtensionPack.GL_FRAMEBUFFER_OES)
+                != GL11ExtensionPack.GL_FRAMEBUFFER_COMPLETE_OES) {
+
+            Bitmap img = Common.createBitmap(SIZE_RTT_FALLBACK,
+                    SIZE_RTT_FALLBACK, "Can't alloc bitmap for render buffer");
+
+            bitmapToTexture(textures[TEXTURE_RTT], img);
+            img.recycle();
+
+            //noinspection UnusedAssignment
+            img = null;
+
+            return;
+        }
+
+        isFramebufferPrepared = true;
+
+        gl11ep.glBindFramebufferOES(GL11ExtensionPack.GL_FRAMEBUFFER_OES, 0);
+        clear();
+    }
+
+    public int getRenderToTextureSize() {
+        return (isFramebufferPrepared ? SIZE_RTT_FBO : SIZE_RTT_FALLBACK);
+    }
+
+    public void useViewport(int width, int height) {
+        gl.glViewport(0, 0, width, height);
+    }
+
+    public void clear() {
+        gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT | GL10.GL_STENCIL_BUFFER_BIT);
+    }
+
+    void bitmapToTexture(int tex, Bitmap bitmap) {
+        bindTexture(tex);
+        GLUtils.texImage2D(GL10.GL_TEXTURE_2D, 0, bitmap, 0);
+    }
+
+    public void startRenderToTexture() {
+        if (isFramebufferPrepared) {
+            gl11ep.glBindFramebufferOES(GL11ExtensionPack.GL_FRAMEBUFFER_OES, frameBuffers[0]);
+        }
+
+        clear();
+    }
+
+    public void finishRenderToTexture(int width, int height) {
+        if (isFramebufferPrepared) {
+            gl11ep.glBindFramebufferOES(GL11ExtensionPack.GL_FRAMEBUFFER_OES, 0);
+            clear();
+        } else {
+            bindTexture(TEXTURE_RTT);
+            gl.glCopyTexImage2D(GL10.GL_TEXTURE_2D, 0, GL10.GL_RGB, 0, 0, width, height, 0);
+        }
+    }
+
+    public void useOrtho(float left,
+            float right,
+            float bottom,
+            float top,
+            float near,
+            float far) {
+
+        gl.glMatrixMode(GL10.GL_PROJECTION);
+        gl.glLoadIdentity();
+
+        if (!engine.inWallpaperMode && config.rotateScreen) {
+            gl.glOrthof(right, left, top, bottom, near, far);
+        } else {
+            gl.glOrthof(left, right, bottom, top, near, far);
+        }
+
+        gl.glMatrixMode(GL10.GL_MODELVIEW);
+        gl.glLoadIdentity();
+    }
+
+    public void useFrustum(float left,
+            float right,
+            float bottom,
+            float top,
+            @SuppressWarnings("SameParameterValue") float near,
+            @SuppressWarnings("SameParameterValue") float far) {
+
+        gl.glMatrixMode(GL10.GL_PROJECTION);
+        gl.glLoadIdentity();
+
+        if (!engine.inWallpaperMode && config.rotateScreen) {
+            gl.glFrustumf(right, left, top, bottom, near, far);
+        } else {
+            gl.glFrustumf(left, right, bottom, top, near, far);
+        }
+    }
+
+    public void pushModelviewMatrix() {
+        gl.glMatrixMode(GL10.GL_MODELVIEW);
+        gl.glPushMatrix();
+    }
+
+    public void popModelviewMatrix() {
+        gl.glMatrixMode(GL10.GL_MODELVIEW);
+        gl.glPopMatrix();
+    }
+
+    public void startBatch() {
+        vertexCount = 0;
+        lineVertexCount = 0;
+
+        vertexBufferPos = 0;
+        colorsBufferPos = 0;
+        textureBufferPos = 0;
+        indicesBufferPos = 0;
+        lineVertexBufferPos = 0;
+        lineColorsBufferPos = 0;
+    }
+
+    public void renderBatch(int flags) {
+        renderBatch(flags, -1);
+    }
+
+    public void renderBatch(int flags, int tex) {
+        applyRenderFlags(flags);
+        applyTexture(tex, flags);
+
+        gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
+        gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
+
+        if (indicesBufferPos != 0) {
+            if (tex >= 0) {
+                gl.glEnable(GL10.GL_TEXTURE_2D);
+                gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
+            } else {
+                gl.glDisable(GL10.GL_TEXTURE_2D);
+                gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
+            }
+
+            renderTriangles(vertexBuffer,
+                    colorsBuffer,
+                    (tex >= 0 ? textureBuffer : null),
+                    indicesBuffer,
+                    indicesBufferPos);
+        }
+
+        if (lineVertexCount != 0) {
+            gl.glDisable(GL10.GL_TEXTURE_2D);
+            gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
+
+            renderLines(lineVertexBuffer, lineColorsBuffer, lineVertexCount);
+        }
+    }
+
+    private void applyTexture(int tex, int flags) {
+        int textureFlags = (flags & MASK_FLAG_TEX);
+
+        if (tex != lastTexture || textureFlags != lastTextureFlags) {
+            bindTexture(tex, textureFlags);
+        }
+    }
+
+    private void bindTexture(int tex) {
+        bindTexture(tex, -1);
+    }
+
+    private void bindTexture(int tex, int flags) {
+        if (tex < 0) {
+            lastTexture = -1;
+            lastTextureFlags = -1;
+            return;
+        }
+
+        gl.glBindTexture(GL10.GL_TEXTURE_2D, textures[tex]);
+
+        if (flags >= 0) {
+            int wrapValue = ((flags & FLAG_TEX_REPEAT) != 0) ? GL10.GL_REPEAT : GL10.GL_CLAMP_TO_EDGE;
+
+            gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MIN_FILTER, GL10.GL_LINEAR);
+            gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MAG_FILTER, GL10.GL_LINEAR);
+            gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_S, wrapValue);
+            gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_T, wrapValue);
+
+            lastTexture = tex;
+            lastTextureFlags = flags;
+        } else {
+            lastTexture = -1;
+            lastTextureFlags = -1;
+        }
+    }
+
+    @SuppressWarnings("ConstantConditions")
+    private void applyRenderFlags(int flags) {
+        if (flags == lastRenderFlags) {
+            return;
+        }
+
+        boolean useCullFace = (flags & FLAG_CULL) != 0;
+        boolean useDepthTest = (flags & FLAG_DEPTH) != 0;
+        boolean useAlphaTest = (flags & FLAG_ALPHA) != 0;
+        boolean useAlphaRefLower = (flags & FLAG_ALPHA_LOWER) != 0;
+        boolean useBlend = (flags & FLAG_BLEND) != 0;
+        boolean useBlendFuncGamma = (flags & FLAG_BLEND_GAMMA) != 0;
+        boolean useSmoothShadeModel = (flags & FLAG_SMOOTH) != 0;
+        boolean useStencilReplace = (flags & FLAG_STENCIL_REPLACE) != 0;
+        boolean useStencilKeep = (flags & FLAG_STENCIL_KEEP) != 0;
+
+        if (lastRenderFlags < 0) {
+            gl.glTexEnvf(GL10.GL_TEXTURE_ENV, GL10.GL_TEXTURE_ENV_MODE, GL10.GL_MODULATE);
+            gl.glHint(GL10.GL_PERSPECTIVE_CORRECTION_HINT, GL10.GL_NICEST);
+            gl.glDisable(GL10.GL_DITHER);
+            gl.glDepthFunc(GL10.GL_LESS);
+            gl.glFrontFace(GL10.GL_CCW);
+            gl.glCullFace(GL10.GL_BACK);
+        }
+
+        toggleCapacity(GL10.GL_CULL_FACE, useCullFace);
+        toggleCapacity(GL10.GL_DEPTH_TEST, useDepthTest);
+        toggleCapacity(GL10.GL_ALPHA_TEST, useAlphaTest);
+        toggleCapacity(GL10.GL_BLEND, useBlend);
+        toggleCapacity(GL10.GL_STENCIL_TEST, useStencilReplace | useStencilKeep);
+
+        if (useAlphaTest) {
+            gl.glAlphaFunc(GL10.GL_GREATER, useAlphaRefLower ? 0.1f : 0.5f);
+        }
+
+        if (useBlend) {
+            gl.glBlendFunc(GL10.GL_SRC_ALPHA, useBlendFuncGamma ? GL10.GL_ONE : GL10.GL_ONE_MINUS_SRC_ALPHA);
+        }
+
+        gl.glShadeModel(useSmoothShadeModel ? GL10.GL_SMOOTH : GL10.GL_FLAT);
+
+        if (useStencilReplace) {
+            gl.glStencilFunc(GL10.GL_ALWAYS, 1, 0xff);
+            gl.glStencilOp(GL10.GL_REPLACE, GL10.GL_REPLACE, GL10.GL_REPLACE);
+            gl.glStencilMask(0xff);
+
+            gl.glClear(GL10.GL_STENCIL_BUFFER_BIT);
+        }
+
+        if (useStencilKeep) {
+            gl.glStencilFunc(GL10.GL_EQUAL, 1, 0xff);
+            gl.glStencilOp(GL10.GL_KEEP, GL10.GL_KEEP, GL10.GL_KEEP);
+            gl.glStencilMask(0);
+        }
+
+        lastRenderFlags = flags;
+    }
+
+    private void toggleCapacity(int cap, boolean isEnabled) {
+        if (isEnabled) {
+            gl.glEnable(cap);
+        } else {
+            gl.glDisable(cap);
+        }
+    }
+
+    // ----
+
+    // In-game:
+    //
+    //    ^
+    //	1 | 4
+    // ---+--->
+    //	2 | 3
+    //
+    // Ortho:
+    //
+    //    ^
+    //  2 | 3
+    // ---+--->
+    //  1 | 4
+    //
+    public void batchQuad() {
+        int vertexBufferPosL = vertexBufferPos;
+        int colorsBufferPosL = colorsBufferPos;
+        int textureBufferPosL = textureBufferPos;
+        int indicesBufferPosL = indicesBufferPos;
+        short vertexCountL = vertexCount;
+
+        float[] vertexBufferL = vertexBuffer;
+        float[] colorsBufferL = colorsBuffer;
+        int[] textureBufferL = textureBuffer;
+        short[] indicesBufferL = indicesBuffer;
+
+        vertexBufferL[vertexBufferPosL] = x1;
+        vertexBufferL[vertexBufferPosL + 1] = y1;
+        vertexBufferL[vertexBufferPosL + 2] = z1;
+        vertexBufferL[vertexBufferPosL + 3] = x2;
+        vertexBufferL[vertexBufferPosL + 4] = y2;
+        vertexBufferL[vertexBufferPosL + 5] = z2;
+        vertexBufferL[vertexBufferPosL + 6] = x3;
+        vertexBufferL[vertexBufferPosL + 7] = y3;
+        vertexBufferL[vertexBufferPosL + 8] = z3;
+        vertexBufferL[vertexBufferPosL + 9] = x4;
+        vertexBufferL[vertexBufferPosL + 10] = y4;
+        vertexBufferL[vertexBufferPosL + 11] = z4;
+
+        colorsBufferL[colorsBufferPosL] = r1;
+        colorsBufferL[colorsBufferPosL + 1] = g1;
+        colorsBufferL[colorsBufferPosL + 2] = b1;
+        colorsBufferL[colorsBufferPosL + 3] = a1;
+        colorsBufferL[colorsBufferPosL + 4] = r2;
+        colorsBufferL[colorsBufferPosL + 5] = g2;
+        colorsBufferL[colorsBufferPosL + 6] = b2;
+        colorsBufferL[colorsBufferPosL + 7] = a2;
+        colorsBufferL[colorsBufferPosL + 8] = r3;
+        colorsBufferL[colorsBufferPosL + 9] = g3;
+        colorsBufferL[colorsBufferPosL + 10] = b3;
+        colorsBufferL[colorsBufferPosL + 11] = a3;
+        colorsBufferL[colorsBufferPosL + 12] = r4;
+        colorsBufferL[colorsBufferPosL + 13] = g4;
+        colorsBufferL[colorsBufferPosL + 14] = b4;
+        colorsBufferL[colorsBufferPosL + 15] = a4;
+
+        textureBufferL[textureBufferPosL] = u1;
+        textureBufferL[textureBufferPosL + 1] = v1;
+        textureBufferL[textureBufferPosL + 2] = u2;
+        textureBufferL[textureBufferPosL + 3] = v2;
+        textureBufferL[textureBufferPosL + 4] = u3;
+        textureBufferL[textureBufferPosL + 5] = v3;
+        textureBufferL[textureBufferPosL + 6] = u4;
+        textureBufferL[textureBufferPosL + 7] = v4;
+
+        indicesBufferL[indicesBufferPosL] = vertexCountL;
+        indicesBufferL[indicesBufferPosL + 1] = (short)(vertexCountL + 2);
+        indicesBufferL[indicesBufferPosL + 2] = (short)(vertexCountL + 1);
+        indicesBufferL[indicesBufferPosL + 3] = vertexCountL;
+        indicesBufferL[indicesBufferPosL + 4] = (short)(vertexCountL + 3);
+        indicesBufferL[indicesBufferPosL + 5] = (short)(vertexCountL + 2);
+
+        vertexBufferPos = vertexBufferPosL + 12;
+        colorsBufferPos = colorsBufferPosL + 16;
+        textureBufferPos = textureBufferPosL + 8;
+        indicesBufferPos = indicesBufferPosL + 6;
+        vertexCount = (short)(vertexCountL + 4);
+    }
+
+    public void batchTexQuad(int texNum) {
+        u3 = u4 = (u1 = u2 = (texNum % 15) * TEX_CELL_X + TEX_1PX_X) + TEX_SIZE_X;
+        v1 = v4 = (v2 = v3 = (texNum / 15) * TEX_CELL_Y + TEX_1PX_Y) + TEX_SIZE_Y;
+        batchQuad();
+    }
+
+    public void batchTexQuadExtruded(int texNum) {
+        u3 = u4 = (u1 = u2 = (texNum % 15) * TEX_CELL_X + TEX_EXTR_X_FROM) + TEX_EXTR_X_SIZE;
+        v1 = v4 = (v2 = v3 = (texNum / 15) * TEX_CELL_Y + TEX_1PX_Y) + TEX_SIZE_Y;
+        batchQuad();
+    }
+
+    public void batchTexQuadPieceTL(int texNum) {
+        u3 = u4 = (u1 = u2 = (texNum % 15) * TEX_CELL_X + TEX_1PX_X) + TEX_SIZE_X_D2;
+        v1 = v4 = (v2 = v3 = (texNum / 15) * TEX_CELL_Y + TEX_1PX_Y) + TEX_SIZE_Y_D2;
+        batchQuad();
+    }
+
+    public void batchTexQuadPieceTR(int texNum) {
+        u3 = u4 = (u1 = u2 = (texNum % 15) * TEX_CELL_X + TEX_SIZE_X_D2_1PX) + TEX_SIZE_X_D2;
+        v1 = v4 = (v2 = v3 = (texNum / 15) * TEX_CELL_Y + TEX_1PX_Y) + TEX_SIZE_Y_D2;
+        batchQuad();
+    }
+
+    public void batchTexQuadPieceBL(int texNum) {
+        u3 = u4 = (u1 = u2 = (texNum % 15) * TEX_CELL_X + TEX_1PX_X) + TEX_SIZE_X_D2;
+        v1 = v4 = (v2 = v3 = (texNum / 15) * TEX_CELL_Y + TEX_SIZE_Y_D2_1PX) + TEX_SIZE_Y_D2;
+        batchQuad();
+    }
+
+    public void batchTexQuadPieceBR(int texNum) {
+        u3 = u4 = (u1 = u2 = (texNum % 15) * TEX_CELL_X + TEX_SIZE_X_D2_1PX) + TEX_SIZE_X_D2;
+        v1 = v4 = (v2 = v3 = (texNum / 15) * TEX_CELL_Y + TEX_SIZE_Y_D2_1PX) + TEX_SIZE_Y_D2;
+        batchQuad();
+    }
+
+    public void batchTexQuadFlipped(int texNum) {
+        u1 = u2 = (u3 = u4 = (texNum % 15) * TEX_CELL_X + TEX_1PX_X) + TEX_SIZE_X;
+        v1 = v4 = (v2 = v3 = (texNum / 15) * TEX_CELL_Y + TEX_1PX_Y) + TEX_SIZE_Y;
+        batchQuad();
+    }
+
+    public void batchTexQuadFlippedPartTL(int texNum) {
+        u1 = u2 = (u3 = u4 = (texNum % 15) * TEX_CELL_X + TEX_1PX_X) + TEX_SIZE_X_D2;
+        v1 = v4 = (v2 = v3 = (texNum / 15) * TEX_CELL_Y + TEX_1PX_Y) + TEX_SIZE_Y_D2;
+        batchQuad();
+    }
+
+    public void batchTexQuadFlippedPartTR(int texNum) {
+        u1 = u2 = (u3 = u4 = (texNum % 15) * TEX_CELL_X + TEX_SIZE_X_D2_1PX) + TEX_SIZE_X_D2;
+        v1 = v4 = (v2 = v3 = (texNum / 15) * TEX_CELL_Y + TEX_1PX_Y) + TEX_SIZE_Y_D2;
+        batchQuad();
+    }
+
+    public void batchTexQuadFlippedPartBL(int texNum) {
+        u1 = u2 = (u3 = u4 = (texNum % 15) * TEX_CELL_X + TEX_1PX_X) + TEX_SIZE_X_D2;
+        v1 = v4 = (v2 = v3 = (texNum / 15) * TEX_CELL_Y + TEX_SIZE_Y_D2_1PX) + TEX_SIZE_Y_D2;
+        batchQuad();
+    }
+
+    public void batchTexQuadFlippedPartBR(int texNum) {
+        u1 = u2 = (u3 = u4 = (texNum % 15) * TEX_CELL_X + TEX_SIZE_X_D2_1PX) + TEX_SIZE_X_D2;
+        v1 = v4 = (v2 = v3 = (texNum / 15) * TEX_CELL_Y + TEX_SIZE_Y_D2_1PX) + TEX_SIZE_Y_D2;
+        batchQuad();
+    }
+
+    public void batchTexQuad2x(int texNum) {
+        u3 = u4 = (u1 = u2 = (texNum % 15) * TEX_CELL_X + TEX_1PX_X) + TEX_SIZE_X_X2;
+        v1 = v4 = (v2 = v3 = (texNum / 15) * TEX_CELL_Y + TEX_1PX_Y) + TEX_SIZE_Y_X2;
+        batchQuad();
+    }
+
+    // public void batchTexQuad4x1x(int texNum) {
+    //     u3 = u4 = (u1 = u2 = (texNum % 15) * TEX_CELL_X + TEX_1PX_X) + TEX_SIZE_X_X4;
+    //     v1 = v4 = (v2 = v3 = (texNum / 15) * TEX_CELL_Y + TEX_1PX_Y) + TEX_SIZE_Y;
+    //     batchQuad();
+    // }
+
+    public void batchTexQuadMon(int texNum) {
+        u3 = u4 = (u1 = u2 = (texNum % 7) * TEX_MON_CELL_X + TEX_1PX_X) + TEX_MON_SIZE_X;
+        v1 = v4 = (v2 = v3 = (texNum / 7) * TEX_MON_CELL_Y + TEX_1PX_Y) + TEX_MON_SIZE_Y;
+        batchQuad();
+    }
+
+    // public void batchLine() {
+    //     int lineVertexBufferPosL = lineVertexBufferPos;
+    //     int lineColorsBufferPosL = lineColorsBufferPos;
+    //     float[] lineVertexBufferL = lineVertexBuffer;
+    //     float[] lineColorsBufferL = lineColorsBuffer;
+    //
+    //     lineVertexBufferL[lineVertexBufferPosL] = x1;
+    //     lineVertexBufferL[lineVertexBufferPosL + 1] = y1;
+    //     lineVertexBufferL[lineVertexBufferPosL + 2] = x2;
+    //     lineVertexBufferL[lineVertexBufferPosL + 3] = y2;
+    //
+    //     lineColorsBufferL[lineColorsBufferPosL] = r1;
+    //     lineColorsBufferL[lineColorsBufferPosL + 1] = g1;
+    //     lineColorsBufferL[lineColorsBufferPosL + 2] = b1;
+    //     lineColorsBufferL[lineColorsBufferPosL + 3] = a1;
+    //     lineColorsBufferL[lineColorsBufferPosL + 4] = r2;
+    //     lineColorsBufferL[lineColorsBufferPosL + 5] = g2;
+    //     lineColorsBufferL[lineColorsBufferPosL + 6] = b2;
+    //     lineColorsBufferL[lineColorsBufferPosL + 7] = a2;
+    //
+    //     lineVertexBufferPos = lineVertexBufferPosL + 4;
+    //     lineColorsBufferPos = lineColorsBufferPosL + 8;
+    //     lineVertexCount += 2;
+    // }
+
+    public void batchLine(float sx, float sy, float ex, float ey) {
+        int lineVertexBufferPosL = lineVertexBufferPos;
+        int lineColorsBufferPosL = lineColorsBufferPos;
+        float[] lineVertexBufferL = lineVertexBuffer;
+        float[] lineColorsBufferL = lineColorsBuffer;
+
+        lineVertexBufferL[lineVertexBufferPosL] = sx;
+        lineVertexBufferL[lineVertexBufferPosL + 1] = sy;
+        lineVertexBufferL[lineVertexBufferPosL + 2] = ex;
+        lineVertexBufferL[lineVertexBufferPosL + 3] = ey;
+
+        lineColorsBufferL[lineColorsBufferPosL] = r1;
+        lineColorsBufferL[lineColorsBufferPosL + 1] = g1;
+        lineColorsBufferL[lineColorsBufferPosL + 2] = b1;
+        lineColorsBufferL[lineColorsBufferPosL + 3] = a1;
+        lineColorsBufferL[lineColorsBufferPosL + 4] = r2;
+        lineColorsBufferL[lineColorsBufferPosL + 5] = g2;
+        lineColorsBufferL[lineColorsBufferPosL + 6] = b2;
+        lineColorsBufferL[lineColorsBufferPosL + 7] = a2;
+
+        lineVertexBufferPos = lineVertexBufferPosL + 4;
+        lineColorsBufferPos = lineColorsBufferPosL + 8;
+        lineVertexCount += 2;
+    }
+
+    public void setColorLineA(float a) {
+        a1 = a;
+        a2 = a;
+    }
+
+    public void setColorLineRGB(float r, float g, float b) {
+        r1 = r;
+        g1 = g;
+        b1 = b;
+
+        r2 = r;
+        g2 = g;
+        b2 = b;
+    }
+
+    public void setColorLineRGBA(float r, float g, float b, float a) {
+        r1 = r;
+        g1 = g;
+        b1 = b;
+        a1 = a;
+
+        r2 = r;
+        g2 = g;
+        b2 = b;
+        a2 = a;
+    }
+
+    public void setColorQuadA(float a) {
+        a1 = a;
+        a2 = a;
+        a3 = a;
+        a4 = a;
+    }
+
+    public void setColorQuadRGB(float r, float g, float b) {
+        r1 = r;
+        g1 = g;
+        b1 = b;
+
+        r2 = r;
+        g2 = g;
+        b2 = b;
+
+        r3 = r;
+        g3 = g;
+        b3 = b;
+
+        r4 = r;
+        g4 = g;
+        b4 = b;
+    }
+
+    public void setColorQuadRGBA(float r, float g, float b, float a) {
+        r1 = r;
+        g1 = g;
+        b1 = b;
+        a1 = a;
+
+        r2 = r;
+        g2 = g;
+        b2 = b;
+        a2 = a;
+
+        r3 = r;
+        g3 = g;
+        b3 = b;
+        a3 = a;
+
+        r4 = r;
+        g4 = g;
+        b4 = b;
+        a4 = a;
+    }
+
+    public void setColorQuadLight(float l) {
+        r1 = l;
+        g1 = l;
+        b1 = l;
+
+        r2 = l;
+        g2 = l;
+        b2 = l;
+
+        r3 = l;
+        g3 = l;
+        b3 = l;
+
+        r4 = l;
+        g4 = l;
+        b4 = l;
+    }
+
+    public void setColorQuadLight(float lf, float lt) {
+        r1 = lf;
+        g1 = lf;
+        b1 = lf;
+
+        r2 = lf;
+        g2 = lf;
+        b2 = lf;
+
+        r3 = lt;
+        g3 = lt;
+        b3 = lt;
+
+        r4 = lt;
+        g4 = lt;
+        b4 = lt;
+    }
+
+    public void setColorQuadLight(float lft, float lff, float ltf, float ltt) {
+        r1 = lft;
+        g1 = lft;
+        b1 = lft;
+
+        r2 = lff;
+        g2 = lff;
+        b2 = lff;
+
+        r3 = ltf;
+        g3 = ltf;
+        b3 = ltf;
+
+        r4 = ltt;
+        g4 = ltt;
+        b4 = ltt;
+    }
+
+    public void setCoordsQuadZ(float z) {
+        z1 = z;
+        z2 = z;
+        z3 = z;
+        z4 = z;
+    }
+
+    // In-game (sx=fx, sy=ty, ex=tx, ey=fy):
+    //
+    //      ^
+    //  1 S | 4 t
+    // -----+----->
+    //  2 f | 3 E
+    //
+    // Ortho (sx=fx, sy=fy, ex=tx, ey=ty):
+    //
+    //      ^
+    //   2  | 3tE
+    // -----+----->
+    //  1fS |  4
+    //
+    public void setCoordsQuadRect(float sx, float sy, float ex, float ey) {
+        // X Y - -
+        x1 = sx;
+        y1 = sy;
+
+        // X - - Y
+        x2 = sx;
+        y2 = ey;
+
+        // - - X Y
+        x3 = ex;
+        y3 = ey;
+
+        // - Y X -
+        x4 = ex;
+        y4 = sy;
+    }
+
+    // In-game (sx=fx, sy=ty, ex=tx, ey=fy):
+    //
+    //      ^
+    //  1 S | 2 t
+    // -----+----->
+    //  4 f | 3 E
+    //
+    public void setCoordsQuadRectFlip(float sx, float sy, float ex, float ey) {
+        // X Y - -
+        x1 = sx;
+        y1 = sy;
+
+        // - Y X -
+        x2 = ex;
+        y2 = sy;
+
+        // - - X Y
+        x3 = ex;
+        y3 = ey;
+
+        // X - - Y
+        x4 = sx;
+        y4 = ey;
+    }
+
+    // Ortho (sx=fx, sy=fy, ex=tx, ey=ty):
+    //
+    //      ^
+    //   2  | 3tE
+    // -----+----->
+    //  1fS |  4
+    //
+    public void setCoordsQuadRectFlat(float sx, float sy, float ex, float ey) {
+        x1 = sx;
+        y1 = sy;
+        z1 = 0.0f;
+
+        x2 = sx;
+        y2 = ey;
+        z2 = 0.0f;
+
+        x3 = ex;
+        y3 = ey;
+        z3 = 0.0f;
+
+        x4 = ex;
+        y4 = sy;
+        z4 = 0.0f;
+    }
+
+    public void setCoordsQuadBillboardZ(float sz, float ez) {
+        z1 = sz;
+        z2 = ez;
+        z3 = ez;
+        z4 = sz;
+    }
+
+    public void setCoordsQuadBillboard(float sx, float sy, float tx, float ty) {
+        x1 = sx;
+        y1 = -sy;
+
+        x2 = sx;
+        y2 = -sy;
+
+        x3 = tx;
+        y3 = -ty;
+
+        x4 = tx;
+        y4 = -ty;
+    }
+
+    public void setCoordsQuadBillboard(float sx, float sy, float tx, float ty, float sz, float ez) {
+        x1 = sx;
+        y1 = -sy;
+        z1 = sz;
+
+        x2 = sx;
+        y2 = -sy;
+        z2 = ez;
+
+        x3 = tx;
+        y3 = -ty;
+        z3 = ez;
+
+        x4 = tx;
+        y4 = -ty;
+        z4 = sz;
+    }
+
+    public void setTexRect(int sx, int sy, int ex, int ey) {
+        u1 = sx;
+        v1 = sy;
+
+        u2 = sx;
+        v2 = ey;
+
+        u3 = ex;
+        v3 = ey;
+
+        u4 = ex;
+        v4 = sy;
+    }
+}
diff --git a/src/main/java/zame/game/engine/graphics/TextureLoader.java b/src/main/java/zame/game/engine/graphics/TextureLoader.java
new file mode 100644
index 0000000..b33be2e
--- /dev/null
+++ b/src/main/java/zame/game/engine/graphics/TextureLoader.java
@@ -0,0 +1,355 @@
+package zame.game.engine.graphics;
+
+import android.annotation.SuppressLint;
+import android.content.res.AssetManager;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.os.Build;
+import zame.game.App;
+import zame.game.core.util.Common;
+import zame.game.engine.Engine;
+import zame.game.engine.EngineObject;
+import zame.game.engine.level.LevelConfig;
+import zame.game.engine.state.State;
+import zame.game.feature.prepare.CachedTexturesProvider;
+
+public class TextureLoader implements EngineObject {
+    public static final int ROW_COMMON = 0;
+    public static final int ROW_TILES = 6;
+
+    private static final int BASE_ICONS = ROW_COMMON * 15;
+    public static final int BASE_OBJECTS = BASE_ICONS + 10;
+    public static final int BASE_BULLETS = BASE_OBJECTS + 19;
+    public static final int BASE_EXPLOSIONS = BASE_BULLETS + 4;
+    public static final int BASE_ARROWS = BASE_EXPLOSIONS + 3;
+    public static final int BASE_WEAPONS = BASE_ARROWS + 4;
+    public static final int BASE_BACKS = (ROW_COMMON + 4) * 15;
+
+    public static final int BASE_WALLS = ROW_TILES * 15; // BASE_WALLS must be greater than 0
+    public static final int BASE_TRANSP_WALLS = BASE_WALLS + 44;
+    public static final int BASE_TRANSP_WINDOWS = BASE_TRANSP_WALLS + 9;
+    public static final int BASE_DOORS_F = BASE_TRANSP_WINDOWS + 8;
+    public static final int BASE_DOORS_S = BASE_DOORS_F + 8;
+    public static final int BASE_DECOR_ITEM = BASE_DOORS_S + 8;
+    public static final int BASE_DECOR_LAMP = BASE_DECOR_ITEM + 10;
+    public static final int BASE_FLOOR = BASE_DECOR_LAMP + 2;
+    public static final int BASE_CEIL = BASE_FLOOR + 10;
+
+    private static final int PACKED_WALLS = 1 << 16;
+    private static final int PACKED_TRANSP_WALLS = 2 << 16;
+    private static final int PACKED_TRANSP_WINDOWS = 4 << 16;
+    private static final int PACKED_DOORS_F = 5 << 16;
+    private static final int PACKED_DOORS_S = 6 << 16;
+    private static final int PACKED_OBJECTS = 7 << 16;
+    private static final int PACKED_DECOR_ITEM = 8 << 16;
+    private static final int PACKED_DECOR_LAMP = 9 << 16;
+    private static final int PACKED_FLOOR = 10 << 16;
+    private static final int PACKED_CEIL = 11 << 16;
+    private static final int PACKED_BULLETS = 12 << 16;
+    private static final int PACKED_ARROWS = 13 << 16;
+
+    // private static final int PACKED_TEXMAP_MONSTERS = 1 << 16;
+
+    public static final int COUNT_MONSTER = 0x10; // block = [up, rt, dn, lt], monster = block[walk_a, walk_b, hit], die[3], shoot
+    public static final int MONSTERS_IN_TEXTURE = 3;
+
+    public static final int ICON_JOY = BASE_ICONS;
+    public static final int ICON_MENU = BASE_ICONS + 1;
+    public static final int ICON_SHOOT = BASE_ICONS + 2;
+    public static final int ICON_MAP = BASE_ICONS + 3;
+    public static final int ICON_HEALTH = BASE_ICONS + 4;
+    public static final int ICON_ARMOR = BASE_ICONS + 5;
+    public static final int ICON_AMMO = BASE_ICONS + 6;
+    public static final int ICON_BLUE_KEY = BASE_ICONS + 7;
+    public static final int ICON_RED_KEY = BASE_ICONS + 8;
+    public static final int ICON_GREEN_KEY = BASE_ICONS + 9;
+
+    public static final int OBJ_ARMOR_GREEN = BASE_OBJECTS - 1 + 1;
+    public static final int OBJ_ARMOR_RED = BASE_OBJECTS - 1 + 2;
+    public static final int OBJ_KEY_BLUE = BASE_OBJECTS - 1 + 3;
+    public static final int OBJ_KEY_RED = BASE_OBJECTS - 1 + 4;
+    public static final int OBJ_STIM = BASE_OBJECTS - 1 + 5;
+    public static final int OBJ_MEDI = BASE_OBJECTS - 1 + 6;
+    public static final int OBJ_CLIP = BASE_OBJECTS - 1 + 7;
+    public static final int OBJ_CBOX = BASE_OBJECTS - 1 + 8;
+    public static final int OBJ_SHELL = BASE_OBJECTS - 1 + 9;
+    public static final int OBJ_SBOX = BASE_OBJECTS - 1 + 10;
+    public static final int OBJ_BPACK = BASE_OBJECTS - 1 + 11;
+    public static final int OBJ_WINCHESTER = BASE_OBJECTS - 1 + 12;
+    public static final int OBJ_KEY_GREEN = BASE_OBJECTS - 1 + 13;
+    public static final int OBJ_AK47 = BASE_OBJECTS - 1 + 14;
+    public static final int OBJ_TMP = BASE_OBJECTS - 1 + 15;
+    public static final int OBJ_DBLPIST = BASE_OBJECTS - 1 + 16;
+    public static final int OBJ_GRENADE = BASE_OBJECTS - 1 + 17;
+    public static final int OBJ_GBOX = BASE_OBJECTS - 1 + 18;
+    public static final int OBJ_OPENMAP = BASE_OBJECTS - 1 + 19;
+
+    public static final int ARROW_UP = BASE_ARROWS - 1 + 1;
+    public static final int ARROW_RT = BASE_ARROWS - 1 + 2;
+    public static final int ARROW_DN = BASE_ARROWS - 1 + 3;
+    public static final int ARROW_LT = BASE_ARROWS - 1 + 4;
+
+    public static final int[] WALL_LIGHTS = { BASE_WALLS - 1 + 7,
+            BASE_WALLS - 1 + 9,
+            BASE_WALLS - 1 + 10,
+            BASE_WALLS - 1 + 12,
+            BASE_WALLS - 1 + 20,
+            BASE_WALLS - 1 + 21,
+            BASE_WALLS - 1 + 22,
+            BASE_WALLS - 1 + 23,
+            BASE_WALLS - 1 + 24,
+            BASE_WALLS - 1 + 25,
+            BASE_WALLS - 1 + 26,
+            BASE_WALLS - 1 + 27,
+            BASE_WALLS - 1 + 28,
+            BASE_WALLS - 1 + 29,
+            BASE_WALLS - 1 + 30,
+            BASE_WALLS - 1 + 31,
+            BASE_WALLS - 1 + 32,
+            BASE_WALLS - 1 + 33,
+            BASE_WALLS - 1 + 34,
+            BASE_WALLS - 1 + 35, };
+
+    public static final int[] DITEM_LIGHTS = { BASE_DECOR_ITEM - 1 + 1,
+            BASE_DECOR_ITEM - 1 + 2,
+            BASE_DECOR_ITEM - 1 + 8,
+            BASE_DECOR_ITEM - 1 + 10, };
+
+    public static final int[] CEIL_LIGHTS = { BASE_CEIL - 1 + 2, BASE_CEIL - 1 + 4, BASE_CEIL - 1 + 6, };
+
+    public static final int[] DLAMP_LIGHTS = { BASE_DECOR_LAMP - 1 + 1, };
+
+    public static class TextureToLoad {
+        static final int TYPE_RESOURCE = 0;
+        public static final int TYPE_MAIN = 1;
+        public static final int TYPE_MONSTERS_1 = 2;
+        public static final int TYPE_MONSTERS_2 = 3;
+
+        public int tex;
+        public String pixelsName; // used in CachedTexturesProvider
+        public String alphaName; // used in CachedTexturesProvider
+        public int type;
+
+        TextureToLoad(int tex, String pixelsName, String alphaName) {
+            this.tex = tex;
+            this.pixelsName = pixelsName;
+            this.alphaName = alphaName;
+            this.type = TYPE_RESOURCE;
+        }
+
+        TextureToLoad(int tex, String pixelsName, String alphaName, int type) {
+            this.tex = tex;
+            this.pixelsName = pixelsName;
+            this.alphaName = alphaName;
+            this.type = type;
+        }
+    }
+
+    // @formatter:off
+	public static final TextureToLoad[] TEXTURES_TO_LOAD = {
+		new TextureToLoad(Renderer.TEXTURE_MAIN, null, null, TextureToLoad.TYPE_MAIN),
+		new TextureToLoad(Renderer.TEXTURE_MONSTERS, "texmap_mon_1_p", "texmap_mon_1_a", TextureToLoad.TYPE_MONSTERS_1),
+		new TextureToLoad(Renderer.TEXTURE_MONSTERS + 1, "texmap_mon_2_p", "texmap_mon_2_a", TextureToLoad.TYPE_MONSTERS_2),
+
+		new TextureToLoad(Renderer.TEXTURE_KNIFE, "hit_knife_1_p", "hit_knife_1_a"),
+		new TextureToLoad(Renderer.TEXTURE_KNIFE + 1, "hit_knife_2_p", "hit_knife_2_a"),
+		new TextureToLoad(Renderer.TEXTURE_KNIFE + 2, "hit_knife_3_p", "hit_knife_3_a"),
+		new TextureToLoad(Renderer.TEXTURE_KNIFE + 3, "hit_knife_4_p", "hit_knife_4_a"),
+
+		new TextureToLoad(Renderer.TEXTURE_PISTOL, "hit_pist_1_p", "hit_pist_1_a"),
+		new TextureToLoad(Renderer.TEXTURE_PISTOL + 1, "hit_pist_2_p", "hit_pist_2_a"),
+		new TextureToLoad(Renderer.TEXTURE_PISTOL + 2, "hit_pist_3_p", "hit_pist_3_a"),
+		new TextureToLoad(Renderer.TEXTURE_PISTOL + 3, "hit_pist_4_p", "hit_pist_4_a"),
+
+		new TextureToLoad(Renderer.TEXTURE_DBLPISTOL, "hit_dblpist_1_p", "hit_dblpist_1_a"),
+		new TextureToLoad(Renderer.TEXTURE_DBLPISTOL + 1, "hit_dblpist_2_p", "hit_dblpist_2_a"),
+		new TextureToLoad(Renderer.TEXTURE_DBLPISTOL + 2, "hit_dblpist_3_p", "hit_dblpist_3_a"),
+		new TextureToLoad(Renderer.TEXTURE_DBLPISTOL + 3, "hit_dblpist_4_p", "hit_dblpist_4_a"),
+
+		new TextureToLoad(Renderer.TEXTURE_SHTG, "hit_shtg_1_p", "hit_shtg_1_a"),
+		new TextureToLoad(Renderer.TEXTURE_SHTG + 1, "hit_shtg_2_p", "hit_shtg_2_a"),
+		new TextureToLoad(Renderer.TEXTURE_SHTG + 2, "hit_shtg_3_p", "hit_shtg_3_a"),
+		new TextureToLoad(Renderer.TEXTURE_SHTG + 3, "hit_shtg_4_p", "hit_shtg_4_a"),
+		new TextureToLoad(Renderer.TEXTURE_SHTG + 4, "hit_shtg_5_p", "hit_shtg_5_a"),
+
+		new TextureToLoad(Renderer.TEXTURE_AK47, "hit_ak47_1_p", "hit_ak47_1_a"),
+		new TextureToLoad(Renderer.TEXTURE_AK47 + 1, "hit_ak47_2_p", "hit_ak47_2_a"),
+		new TextureToLoad(Renderer.TEXTURE_AK47 + 2, "hit_ak47_3_p", "hit_ak47_3_a"),
+		new TextureToLoad(Renderer.TEXTURE_AK47 + 3, "hit_ak47_4_p", "hit_ak47_4_a"),
+
+		new TextureToLoad(Renderer.TEXTURE_TMP, "hit_tmp_1_p", "hit_tmp_1_a"),
+		new TextureToLoad(Renderer.TEXTURE_TMP + 1, "hit_tmp_2_p", "hit_tmp_2_a"),
+		new TextureToLoad(Renderer.TEXTURE_TMP + 2, "hit_tmp_3_p", "hit_tmp_3_a"),
+		new TextureToLoad(Renderer.TEXTURE_TMP + 3, "hit_tmp_4_p", "hit_tmp_4_a"),
+
+		new TextureToLoad(Renderer.TEXTURE_GRENADE, "hit_rocket_1_p", "hit_rocket_1_a"),
+		new TextureToLoad(Renderer.TEXTURE_GRENADE + 1, "hit_rocket_2_p", "hit_rocket_2_a"),
+		new TextureToLoad(Renderer.TEXTURE_GRENADE + 2, "hit_rocket_3_p", "hit_rocket_3_a"),
+		new TextureToLoad(Renderer.TEXTURE_GRENADE + 3, "hit_rocket_4_p", "hit_rocket_4_a"),
+		new TextureToLoad(Renderer.TEXTURE_GRENADE + 4, "hit_rocket_5_p", "hit_rocket_5_a"),
+		new TextureToLoad(Renderer.TEXTURE_GRENADE + 5, "hit_rocket_6_p", "hit_rocket_6_a"),
+		new TextureToLoad(Renderer.TEXTURE_GRENADE + 6, "hit_rocket_7_p", "hit_rocket_7_a"),
+		new TextureToLoad(Renderer.TEXTURE_GRENADE + 7, "hit_rocket_8_p", "hit_rocket_8_a"),
+
+		new TextureToLoad(Renderer.TEXTURE_SKY, "sky_1", null),
+	};
+    // @formatter:on
+
+    private State state;
+    private Renderer renderer;
+    private AssetManager assetManager;
+    private LevelConfig levelConf;
+
+    @Override
+    public void onCreate(Engine engine) {
+        this.state = engine.state;
+        this.renderer = engine.renderer;
+        this.assetManager = App.self.getAssets();
+    }
+
+    private void loadAndBindTexture(int tex, int set) {
+        Bitmap img = BitmapFactory.decodeFile(CachedTexturesProvider.getCachePath(tex, set));
+
+        if (img == null) {
+            final String errorMessage = "Can't load cached bitmap";
+            Common.showToast(errorMessage);
+            throw new RuntimeException(errorMessage);
+        }
+
+        renderer.bitmapToTexture(tex, img);
+        img.recycle();
+
+        //noinspection UnusedAssignment
+        img = null;
+    }
+
+    @SuppressLint("ObsoleteSdkInt")
+    public void onSurfaceCreated() {
+        //        GPU,    ,
+        //  inPurgeable    ,      -   
+        //     inInputShareable        
+        BitmapFactory.Options bitmapOptions = new BitmapFactory.Options();
+        bitmapOptions.inDither = false;
+        bitmapOptions.inScaled = false;
+        bitmapOptions.inPurgeable = false;
+        bitmapOptions.inInputShareable = false;
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
+            //    ,         -null-
+            bitmapOptions.inMutable = true;
+        }
+
+        Bitmap img = CachedTexturesProvider.decodeTexture(assetManager, "tex_loading", bitmapOptions);
+        renderer.bitmapToTexture(Renderer.TEXTURE_LOADING, img);
+        img.recycle();
+
+        //noinspection UnusedAssignment
+        img = null;
+
+        System.gc();
+    }
+
+    @SuppressWarnings("UnusedReturnValue")
+    public boolean loadTexture(int createdTexturesCount) {
+        if (createdTexturesCount >= TEXTURES_TO_LOAD.length) {
+            return false;
+        }
+
+        if (createdTexturesCount == 0) {
+            levelConf = LevelConfig.read(assetManager, state.levelName);
+        }
+
+        TextureToLoad texToLoad = TEXTURES_TO_LOAD[createdTexturesCount];
+
+        if (texToLoad.type == TextureToLoad.TYPE_MAIN) {
+            loadAndBindTexture(texToLoad.tex,
+                    CachedTexturesProvider.normalizeSetNum(CachedTexturesProvider.mainTexMap, levelConf.graphicsSet));
+        } else {
+            loadAndBindTexture(texToLoad.tex, 0);
+        }
+
+        return true;
+    }
+
+    public static int packTexId(int texId) {
+        if (texId >= BASE_CEIL) {
+            return (texId - BASE_CEIL) | PACKED_CEIL;
+        } else if (texId >= BASE_FLOOR) {
+            return (texId - BASE_FLOOR) | PACKED_FLOOR;
+        } else if (texId >= BASE_DECOR_LAMP) {
+            return (texId - BASE_DECOR_LAMP) | PACKED_DECOR_LAMP;
+        } else if (texId >= BASE_DECOR_ITEM) {
+            return (texId - BASE_DECOR_ITEM) | PACKED_DECOR_ITEM;
+        } else if (texId >= BASE_DOORS_S) {
+            return (texId - BASE_DOORS_S) | PACKED_DOORS_S;
+        } else if (texId >= BASE_DOORS_F) {
+            return (texId - BASE_DOORS_F) | PACKED_DOORS_F;
+        } else if (texId >= BASE_TRANSP_WINDOWS) {
+            return (texId - BASE_TRANSP_WINDOWS) | PACKED_TRANSP_WINDOWS;
+        } else if (texId >= BASE_TRANSP_WALLS) {
+            return (texId - BASE_TRANSP_WALLS) | PACKED_TRANSP_WALLS;
+        } else if (texId >= BASE_WALLS) {
+            return (texId - BASE_WALLS) | PACKED_WALLS;
+        } else if (texId >= BASE_ARROWS) {
+            return (texId - BASE_ARROWS) | PACKED_ARROWS;
+        } else if (texId >= BASE_EXPLOSIONS) {
+            return texId; // do not pack explosions, because actually is isn't texture, but animation frame
+        } else if (texId >= BASE_BULLETS) {
+            return (texId - BASE_BULLETS) | PACKED_BULLETS;
+        } else if (texId >= BASE_OBJECTS) {
+            return (texId - BASE_OBJECTS) | PACKED_OBJECTS;
+        } else {
+            return texId;
+        }
+    }
+
+    @SuppressWarnings("MagicNumber")
+    public static int unpackTexId(int texId) {
+        if (texId <= 0) {
+            return texId;
+        }
+
+        int texBase = texId & 0xFFFF;
+
+        switch (texId & 0xF0000) {
+            case PACKED_WALLS:
+                return texBase + BASE_WALLS;
+
+            case PACKED_TRANSP_WALLS:
+                return texBase + BASE_TRANSP_WALLS;
+
+            case PACKED_TRANSP_WINDOWS:
+                return texBase + BASE_TRANSP_WINDOWS;
+
+            case PACKED_DOORS_F:
+                return texBase + BASE_DOORS_F;
+
+            case PACKED_DOORS_S:
+                return texBase + BASE_DOORS_S;
+
+            case PACKED_OBJECTS:
+                return texBase + BASE_OBJECTS;
+
+            case PACKED_DECOR_ITEM:
+                return texBase + BASE_DECOR_ITEM;
+
+            case PACKED_DECOR_LAMP:
+                return texBase + BASE_DECOR_LAMP;
+
+            case PACKED_FLOOR:
+                return texBase + BASE_FLOOR;
+
+            case PACKED_CEIL:
+                return texBase + BASE_CEIL;
+
+            case PACKED_BULLETS:
+                return texBase + BASE_BULLETS;
+
+            case PACKED_ARROWS:
+                return texBase + BASE_ARROWS;
+
+            default:
+                return texBase;
+        }
+    }
+}
diff --git a/src/main/java/zame/game/engine/hud/AutoMapPathCell.java b/src/main/java/zame/game/engine/hud/AutoMapPathCell.java
deleted file mode 100644
index bbc8c2c..0000000
--- a/src/main/java/zame/game/engine/hud/AutoMapPathCell.java
+++ /dev/null
@@ -1,32 +0,0 @@
-package zame.game.engine.hud;
-
-import zame.game.engine.data.DataListItem;
-
-public class AutoMapPathCell extends DataListItem {
-    int x;
-    int y;
-    float cx;
-    float cy;
-    boolean hasFrom;
-    boolean hasTo;
-    float fdx;
-    float fdy;
-    float tdx;
-    float tdy;
-
-    @SuppressWarnings("MagicNumber")
-    void initFrom(int px, int py, int cx, int cy, int nx, int ny) {
-        x = cx;
-        y = cy;
-        this.cx = (float)cx + 0.5f;
-        this.cy = (float)cy + 0.5f;
-
-        hasFrom = (px != cx || py != cy);
-        hasTo = (nx != cx || ny != cy);
-
-        fdx = (float)(px - cx) * 0.5f;
-        fdy = (float)(py - cy) * 0.5f;
-        tdx = (float)(nx - cx) * 0.5f;
-        tdy = (float)(ny - cy) * 0.5f;
-    }
-}
diff --git a/src/main/java/zame/game/engine/Level.java b/src/main/java/zame/game/engine/level/Level.java
similarity index 85%
rename from src/main/java/zame/game/engine/Level.java
rename to src/main/java/zame/game/engine/level/Level.java
index eed863c..72b8f9d 100644
--- a/src/main/java/zame/game/engine/Level.java
+++ b/src/main/java/zame/game/engine/level/Level.java
@@ -1,4 +1,4 @@
-package zame.game.engine;
+package zame.game.engine.level;
 
 import android.content.res.AssetManager;
 import android.text.TextUtils;
@@ -7,13 +7,28 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.Locale;
 import zame.game.App;
-import zame.game.BuildConfig;
-import zame.game.Common;
-import zame.game.engine.data.DataList;
-import zame.game.engine.hud.AutoMapPathCell;
-import zame.game.managers.SoundManager;
-import zame.game.store.Achievements;
-import zame.game.store.Profile;
+import zame.game.core.serializer.DataList;
+import zame.game.core.util.Common;
+import zame.game.engine.Engine;
+import zame.game.engine.EngineObject;
+import zame.game.engine.Game;
+import zame.game.engine.entity.Action;
+import zame.game.engine.entity.AutoMapPathCell;
+import zame.game.engine.entity.Door;
+import zame.game.engine.entity.LookPoint;
+import zame.game.engine.entity.Mark;
+import zame.game.engine.entity.Monster;
+import zame.game.engine.entity.OnChangeWeaponAction;
+import zame.game.engine.entity.Timeout;
+import zame.game.engine.entity.WaveCell;
+import zame.game.engine.graphics.Labels;
+import zame.game.engine.graphics.TextureLoader;
+import zame.game.engine.state.Profile;
+import zame.game.engine.state.State;
+import zame.game.engine.visual.Weapons;
+import zame.game.feature.achievements.Achievements;
+import zame.game.feature.sound.SoundManager;
+import zame.game.flavour.config.GameConfig;
 
 public class Level implements EngineObject {
     private static final int T_HERO = 1;
@@ -29,16 +44,16 @@ public class Level implements EngineObject {
 
     static final int MAX_WIDTH = 64;
     static final int MAX_HEIGHT = 64;
-    static final int MAX_DOORS = 128;
-    static final int MAX_MONSTERS = 24 * 24;
-    static final int MAX_MARKS = 32 * 32;
+    public static final int MAX_DOORS = 128;
+    public static final int MAX_MONSTERS = 32 * 32;
+    public static final int MAX_MARKS = 32 * 32;
     private static final int MAX_MARK_ID = 253;
-    static final int MAX_ACTIONS = MAX_MARK_ID + 1;
-    static final int MAX_BULLETS = 512;
-    static final int MAX_EXPLOSIONS = 512;
-    static final int MAX_TIMEOUTS = 16;
-    static final int MAX_LOOK_POINTS = 8;
-    static final int MAX_ON_CHANGE_WEAPON_ACTIONS = 4;
+    public static final int MAX_ACTIONS = MAX_MARK_ID + 1;
+    public static final int MAX_BULLETS = 512;
+    public static final int MAX_EXPLOSIONS = 512;
+    public static final int MAX_TIMEOUTS = 16;
+    public static final int MAX_LOOK_POINTS = 8;
+    public static final int MAX_ON_CHANGE_WEAPON_ACTIONS = 4;
     private static final int MAX_AUTOMAP_PATH_CELLS = 32 * 32;
 
     private static final int ACTION_CLOSE = 1;
@@ -70,35 +85,36 @@ public class Level implements EngineObject {
     private static final int ACTION_PATH_TO = 27;
     private static final int ACTION_PATH_CLEAR = 28;
     private static final int ACTION_DISABLE_CHEATS = 29;
+    private static final int ACTION_WITHOUT_NOTIFICATION = 30;
+    private static final int ACTION_TRACK_EVENT = 31;
 
     public static final int PASSABLE_IS_WALL = 1;
-    @SuppressWarnings("WeakerAccess") static final int PASSABLE_IS_TRANSP_WALL = 2;
+    private static final int PASSABLE_IS_TRANSP_WALL = 2;
     public static final int PASSABLE_IS_OBJECT = 4;
     public static final int PASSABLE_IS_DECOR_ITEM = 8;
-    static final int PASSABLE_IS_DOOR = 16;
-    static final int PASSABLE_IS_HERO = 32;
-    static final int PASSABLE_IS_MONSTER = 64;
-    static final int PASSABLE_IS_DEAD_CORPSE = 128;
-    @SuppressWarnings("WeakerAccess") static final int PASSABLE_IS_SECRET = 256; // additional state
+    public static final int PASSABLE_IS_DOOR = 16;
+    public static final int PASSABLE_IS_HERO = 32;
+    public static final int PASSABLE_IS_MONSTER = 64;
+    public static final int PASSABLE_IS_DEAD_CORPSE = 128;
+    private static final int PASSABLE_IS_SECRET = 256; // additional state
     public static final int PASSABLE_IS_TRANSP = 512; // additional state, used in LevelRenderer
-    @SuppressWarnings("WeakerAccess") static final int PASSABLE_IS_OBJECT_KEY = 1024;
-    static final int PASSABLE_IS_DOOR_OPENED_BY_HERO = 2048; // was door opened by hero at least once?
+    private static final int PASSABLE_IS_OBJECT_KEY = 1024;
+    public static final int PASSABLE_IS_DOOR_OPENED_BY_HERO = 2048; // was door opened by hero at least once?
     public static final int PASSABLE_IS_TRANSP_WINDOW = 4096; // additional state, used in LevelRenderer
     public static final int PASSABLE_IS_TRANSP_WINDOW_VERT = 8192; // additional state, used in LevelRenderer
     static final int PASSABLE_IS_DECOR_LAMP = 16384; // additional state, used in LevelRenderer
-    static final int PASSABLE_IS_EXPLOSIVE = 32768;
-    static final int PASSABLE_IS_NOTRANS = 65536;
-    static final int PASSABLE_IS_OBJECT_DONT_COUNT = 131072;
-    @SuppressWarnings("WeakerAccess") static final int PASSABLE_IS_SHOOTABLE_DECOR_ITEM = 262144;
+    public static final int PASSABLE_IS_EXPLOSIVE = 32768;
+    public static final int PASSABLE_IS_NOTRANS = 65536;
+    private static final int PASSABLE_IS_SHOOTABLE_DECOR_ITEM = 131072;
 
-    static final int PASSABLE_MASK_HERO = PASSABLE_IS_WALL
+    public static final int PASSABLE_MASK_HERO = PASSABLE_IS_WALL
             | PASSABLE_IS_TRANSP_WALL
             | PASSABLE_IS_DECOR_ITEM
             | PASSABLE_IS_SHOOTABLE_DECOR_ITEM
             | PASSABLE_IS_DOOR
             | PASSABLE_IS_MONSTER;
 
-    static final int PASSABLE_MASK_MONSTER = PASSABLE_IS_WALL
+    public static final int PASSABLE_MASK_MONSTER = PASSABLE_IS_WALL
             | PASSABLE_IS_TRANSP_WALL
             | PASSABLE_IS_DECOR_ITEM
             | PASSABLE_IS_SHOOTABLE_DECOR_ITEM
@@ -106,7 +122,7 @@ public class Level implements EngineObject {
             | PASSABLE_IS_MONSTER
             | PASSABLE_IS_HERO;
 
-    static final int PASSABLE_MASK_BULLET = PASSABLE_IS_WALL
+    public static final int PASSABLE_MASK_BULLET = PASSABLE_IS_WALL
             | PASSABLE_IS_DOOR
             | PASSABLE_IS_MONSTER
             | PASSABLE_IS_HERO
@@ -114,22 +130,21 @@ public class Level implements EngineObject {
             | PASSABLE_IS_DECOR_ITEM;
 
     // static final int PASSABLE_MASK_BULLET_HERO = PASSABLE_IS_WALL | PASSABLE_IS_DOOR;
-    static final int PASSABLE_MASK_CHASE_WM = PASSABLE_IS_WALL | PASSABLE_IS_DOOR;
+    public static final int PASSABLE_MASK_CHASE_WM = PASSABLE_IS_WALL | PASSABLE_IS_DOOR;
 
-    static final int PASSABLE_MASK_SHOOT_WM = PASSABLE_IS_WALL
+    public static final int PASSABLE_MASK_SHOOT_WM = PASSABLE_IS_WALL
             | PASSABLE_IS_DOOR
             | PASSABLE_IS_DECOR_ITEM
             | PASSABLE_IS_MONSTER;
 
-    static final int PASSABLE_MASK_OBJECT = PASSABLE_IS_OBJECT | PASSABLE_IS_OBJECT_KEY | PASSABLE_IS_OBJECT_DONT_COUNT;
-    static final int PASSABLE_MASK_DOOR = ~PASSABLE_IS_DOOR_OPENED_BY_HERO;
+    public static final int PASSABLE_MASK_OBJECT = PASSABLE_IS_OBJECT | PASSABLE_IS_OBJECT_KEY;
+    public static final int PASSABLE_MASK_DOOR = ~(PASSABLE_IS_DOOR | PASSABLE_IS_DOOR_OPENED_BY_HERO);
 
-    static final int PASSABLE_MASK_OBJECT_DROP = PASSABLE_IS_WALL
+    public static final int PASSABLE_MASK_OBJECT_DROP = PASSABLE_IS_WALL
             | PASSABLE_IS_TRANSP_WALL
             | PASSABLE_IS_DECOR_ITEM
             | PASSABLE_IS_SHOOTABLE_DECOR_ITEM
-            | PASSABLE_IS_DOOR
-            | PASSABLE_IS_OBJECT;
+            | PASSABLE_IS_DOOR;
 
     public static final int PASSABLE_MASK_WALL_N_TRANSP = PASSABLE_IS_WALL
             | PASSABLE_IS_TRANSP; // additional state, used in LevelRenderer
@@ -138,9 +153,6 @@ public class Level implements EngineObject {
             | PASSABLE_IS_SHOOTABLE_DECOR_ITEM
             | PASSABLE_IS_DECOR_LAMP; // additional state, used in LevelRenderer
 
-    static final int PASSABLE_MASK_OBJ_OR_DECOR = PASSABLE_IS_OBJECT
-            | PASSABLE_MASK_DECORATION; // additional state, used in LevelRenderer
-
     private static final int PASSABLE_MASK_ACTION_WALL = PASSABLE_IS_WALL
             | PASSABLE_IS_TRANSP_WALL
             | PASSABLE_IS_OBJECT
@@ -157,12 +169,14 @@ public class Level implements EngineObject {
             | PASSABLE_IS_DECOR_ITEM
             | PASSABLE_IS_SHOOTABLE_DECOR_ITEM;
 
+    public static final int PASSABLE_MASK_AUTOMAP_ITEM = PASSABLE_IS_DECOR_ITEM
+            | PASSABLE_IS_SHOOTABLE_DECOR_ITEM;
+
     private static final int MAX_PATH_TO_WAVE = 65536;
 
     private Engine engine;
     private State state;
     private Level level;
-    private Weapons weapons;
     private LevelRenderer levelRenderer;
     private Profile profile;
     private AssetManager assetManager;
@@ -172,30 +186,29 @@ public class Level implements EngineObject {
     public int[][] pathToWaveMap;
     public DataList<AutoMapPathCell> autoMapPathCells = new DataList<>(AutoMapPathCell.class, MAX_AUTOMAP_PATH_CELLS);
 
-    Mark[][] marksMap;
-    Monster[][] monstersMap;
-    Monster[][] monstersPrevMap;
-    int[][] shootSeqMap;
-    LevelConfig conf;
-    int shootSeq;
-    boolean isInitialUpdate;
-    boolean buildPathToWavePending;
+    public Mark[][] marksMap;
+    public Monster[][] monstersMap;
+    public Monster[][] monstersPrevMap;
+    public int[][] shootSeqMap;
+    public LevelConfig conf;
+    public int shootSeq;
+    public boolean isInitialUpdate;
+    public boolean buildPathToWavePending;
 
     private ArrayList<ArrayList<Mark>> marksHash;
     private WaveCell[][] pathToWaveBuffer;
 
     @Override
-    public void setEngine(Engine engine) {
+    public void onCreate(Engine engine) {
         this.engine = engine;
         this.state = engine.state;
         this.level = engine.level;
-        this.weapons = engine.weapons;
         this.levelRenderer = engine.levelRenderer;
         this.profile = engine.profile;
         this.assetManager = App.self.getAssets();
     }
 
-    public void init() {
+    public void reload() {
         marksHash = new ArrayList<>();
     }
 
@@ -224,13 +237,13 @@ public class Level implements EngineObject {
         }
     }
 
-    void requestBuildPathToWave() {
+    public void requestBuildPathToWave() {
         buildPathToWavePending = true;
     }
 
     @SuppressWarnings({ "MagicNumber", "ConstantConditions" })
     protected void create(byte[] data) {
-        init(); // re-init level. just for case
+        reload(); // re-startBatch level. just for case
         int pos = 1; // skip graphics set
 
         // skip monsters config
@@ -250,7 +263,6 @@ public class Level implements EngineObject {
 
         state.wallsMap = new int[state.levelHeight][state.levelWidth];
         state.texMap = new int[state.levelHeight][state.levelWidth];
-        state.objectsMap = new int[state.levelHeight][state.levelWidth];
         state.passableMap = new int[state.levelHeight][state.levelWidth];
         state.floorMap1 = new int[state.levelHeight][state.levelWidth];
         state.floorMap2 = new int[state.levelHeight][state.levelWidth];
@@ -267,7 +279,7 @@ public class Level implements EngineObject {
             for (int j = 0; j < state.levelWidth; j++) {
                 state.wallsMap[i][j] = 0;
                 state.texMap[i][j] = 0;
-                state.objectsMap[i][j] = 0;
+                state.objectsMap.get(i).get(j).clear();
                 state.passableMap[i][j] = 0;
                 state.floorMap1[i][j] = 0;
                 state.floorMap2[i][j] = 0;
@@ -390,17 +402,16 @@ public class Level implements EngineObject {
                     state.wallsMap[i][j] = (isVert ? -1 : -2); // mark door for PortalTracer
                     state.passableMap[i][j] |= PASSABLE_IS_DOOR;
                 } else if (type == T_OBJ) {
-                    state.objectsMap[i][j] = value - 1 + TextureLoader.BASE_OBJECTS;
+                    int objValue = value - 1 + TextureLoader.BASE_OBJECTS;
+                    state.objectsMap.get(i).get(j).append(objValue);
                     state.passableMap[i][j] |= PASSABLE_IS_OBJECT;
 
-                    if (state.objectsMap[i][j] == TextureLoader.OBJ_KEY_BLUE
-                            || state.objectsMap[i][j] == TextureLoader.OBJ_KEY_RED
-                            || state.objectsMap[i][j] == TextureLoader.OBJ_KEY_GREEN) {
+                    if (objValue == TextureLoader.OBJ_KEY_BLUE
+                            || objValue == TextureLoader.OBJ_KEY_RED
+                            || objValue == TextureLoader.OBJ_KEY_GREEN) {
 
                         state.passableMap[i][j] |= PASSABLE_IS_OBJECT_KEY;
                     }
-
-                    state.totalItems++;
                 } else if (type == T_DITEM) {
                     state.texMap[i][j] = value - 1 + TextureLoader.BASE_DECOR_ITEM;
                     state.passableMap[i][j] |= (value == 3 || value == 10)
@@ -409,7 +420,7 @@ public class Level implements EngineObject {
 
                     if (value == 4) {
                         state.passableMap[i][j] |= PASSABLE_IS_EXPLOSIVE;
-                        state.explosivesMap[i][j] = GameParams.HEALTH_BARREL;
+                        state.explosivesMap[i][j] = GameConfig.HEALTH_BARREL;
                     }
                 } else if (type == T_DLAMP) {
                     state.texMap[i][j] = value - 1 + TextureLoader.BASE_DECOR_LAMP;
@@ -435,18 +446,16 @@ public class Level implements EngineObject {
                 throw new RuntimeException("Too many marks");
             }
 
-            mark.id = (int)data[pos++] & 0xFF;
-            mark.x = (int)data[pos++] & 0xFF;
-            mark.y = (int)data[pos++] & 0xFF;
+            mark.configure((int)data[pos++] & 0xFF, (int)data[pos++] & 0xFF, (int)data[pos++] & 0xFF);
         }
 
         pos++;
-        updateMaps();
+        updateAfterLevelLoadedOrCreated();
         int secretsMask = 0;
 
         while (((int)data[pos] & 0xFF) != 255) {
             int mark = (int)data[pos++] & 0xFF;
-            ArrayList<Action> actions = state.actions.get(mark);
+            List<Action> actions = state.actions.get(mark);
 
             while (((int)data[pos] & 0xFF) != 0) {
                 Action act = new Action();
@@ -459,12 +468,6 @@ public class Level implements EngineObject {
                     ArrayList<Mark> marks = marksHash.get(act.markId);
 
                     for (Mark markObj : marks) {
-                        if (((state.passableMap[markObj.y][markObj.x] & PASSABLE_IS_OBJECT) != 0)
-                                && ((state.passableMap[markObj.y][markObj.x] & PASSABLE_IS_SECRET) == 0)) {
-
-                            state.totalItems--;
-                        }
-
                         state.passableMap[markObj.y][markObj.x] |= PASSABLE_IS_SECRET;
                     }
 
@@ -482,7 +485,7 @@ public class Level implements EngineObject {
 
         isInitialUpdate = true;
 
-        for (Monster mon = state.monsters.first(); mon != null; mon = (Monster)mon.next) {
+        for (Monster mon = state.monsters.first(); mon != null; mon = mon.next) {
             mon.update();
         }
 
@@ -490,8 +493,8 @@ public class Level implements EngineObject {
         isInitialUpdate = false;
     }
 
-    void updateMaps() {
-        for (Door door = state.doors.first(); door != null; door = (Door)door.next) {
+    public void updateAfterLevelLoadedOrCreated() {
+        for (Door door = state.doors.first(); door != null; door = door.next) {
             door.mark = null;
         }
 
@@ -519,13 +522,17 @@ public class Level implements EngineObject {
             }
         }
 
-        for (Door door = state.doors.first(); door != null; door = (Door)door.next) {
+        for (Door door = state.doors.first(); door != null; door = door.next) {
             doorsMap[door.y][door.x] = door;
         }
 
-        for (Mark mark = state.marks.first(); mark != null; mark = (Mark)mark.next) {
+        for (Mark mark = state.marks.first(); mark != null; mark = mark.next) {
             marksHash.get(mark.id).add(mark);
 
+            if (mark.unmarked) {
+                continue;
+            }
+
             if (doorsMap[mark.y][mark.x] == null) {
                 marksMap[mark.y][mark.x] = mark;
             } else {
@@ -533,7 +540,7 @@ public class Level implements EngineObject {
             }
         }
 
-        for (Monster mon = state.monsters.first(); mon != null; mon = (Monster)mon.next) {
+        for (Monster mon = state.monsters.first(); mon != null; mon = mon.next) {
             mon.postConfigure();
             monstersMap[mon.cellY][mon.cellX] = mon;
 
@@ -551,53 +558,26 @@ public class Level implements EngineObject {
 
     private void unmark(Action act, List<Mark> marks) {
         for (Mark mark : marks) {
+            mark.unmarked = true;
             marksMap[mark.y][mark.x] = null;
-
-            if (((state.passableMap[mark.y][mark.x] & PASSABLE_IS_OBJECT) != 0) && ((state.passableMap[mark.y][mark.x]
-                    & PASSABLE_IS_SECRET) != 0)) {
-
-                state.totalItems++;
-            }
-
             state.passableMap[mark.y][mark.x] &= ~PASSABLE_IS_SECRET;
         }
 
-        for (Door door = state.doors.first(); door != null; door = (Door)door.next) {
+        for (Door door = state.doors.first(); door != null; door = door.next) {
             if (door.mark != null && door.mark.id == act.markId) {
                 door.mark = null;
             }
         }
-
-        marksHash.get(act.markId).clear();
-
-        for (Mark mark = state.marks.first(); mark != null; ) {
-            Mark nextMark = (Mark)mark.next;
-
-            if (mark.id == act.markId) {
-                state.marks.release(mark);
-            }
-
-            //noinspection AssignmentToForLoopParameter
-            mark = nextMark;
-        }
     }
 
     @SuppressWarnings("ConstantConditions")
-    int executeActions(int id) {
-        ArrayList<Action> actions = state.actions.get(id);
+    public int executeActions(int id) {
+        List<Action> actions = state.actions.get(id);
 
         if (actions.isEmpty()) {
             return -1;
         }
 
-        if (State.LEVEL_INITIAL.equals(state.levelName)) {
-            App.self.trackerInst.send("Tutorial", "Action." + (id < 10 ? "0" : "") + String.valueOf(id));
-
-            if (BuildConfig.DEBUG) {
-                Common.log("Action." + (id < 10 ? "0" : "") + String.valueOf(id));
-            }
-        }
-
         int resultSoundIdx = SoundManager.SOUND_MARK;
 
         for (Action act : actions) {
@@ -613,7 +593,7 @@ public class Level implements EngineObject {
                     break;
 
                 case ACTION_RESTORE_HEALTH:
-                    state.heroHealth = GameParams.HEALTH_MAX;
+                    state.heroHealth = GameConfig.HEALTH_MAX;
                     break;
 
                 case ACTION_CLOSE:
@@ -629,9 +609,11 @@ public class Level implements EngineObject {
                         if (door != null) {
                             door.stick(act.type == ACTION_OPEN, id == 0);
 
-                            if (act.type == ACTION_OPEN) {
-                                Achievements.updateStat(Achievements.STAT_DOORS_OPENED, profile, engine, state);
-                            }
+                            // Do NOT update STAT_DOORS_OPENED for automatically opened doors
+                            //
+                            // if (act.type == ACTION_OPEN) {
+                            //     Achievements.updateStat(Achievements.STAT_DOORS_OPENED, profile, engine, state);
+                            // }
 
                             if (act.type == ACTION_REQ_KEY) {
                                 door.requiredKey = act.param;
@@ -652,7 +634,7 @@ public class Level implements EngineObject {
 
                     for (Mark mark : marks) {
                         if ((state.passableMap[mark.y][mark.x] & PASSABLE_IS_MONSTER) != 0) {
-                            for (Monster mon = state.monsters.first(); mon != null; mon = (Monster)mon.next) {
+                            for (Monster mon = state.monsters.first(); mon != null; mon = mon.next) {
                                 if (mon.cellX == mark.x && mon.cellY == mark.y) {
                                     state.monsters.release(mon);
                                     break;
@@ -696,7 +678,7 @@ public class Level implements EngineObject {
 
                     for (Mark mark : marks) {
                         if ((state.passableMap[mark.y][mark.x] & PASSABLE_IS_MONSTER) != 0) {
-                            for (Monster mon = state.monsters.first(); mon != null; mon = (Monster)mon.next) {
+                            for (Monster mon = state.monsters.first(); mon != null; mon = mon.next) {
                                 if (mon.cellX == mark.x && mon.cellY == mark.y) {
                                     state.monsters.release(mon);
                                     break;
@@ -795,7 +777,7 @@ public class Level implements EngineObject {
                         state.foundSecretsMask |= act.param;
                         state.foundSecrets++;
                         engine.overlay.showLabel(Labels.LABEL_SECRET_FOUND);
-                        state.levelExp += GameParams.EXP_SECRET_FOUND;
+                        state.levelExp += GameConfig.EXP_SECRET_FOUND;
                         Achievements.updateStat(Achievements.STAT_SECRETS_FOUND, profile, engine, state);
                     }
                     break;
@@ -816,20 +798,19 @@ public class Level implements EngineObject {
                         if (act.param == Weapons.WEAPON_PISTOL
                                 || act.param == Weapons.WEAPON_DBLPISTOL
                                 || act.param == Weapons.WEAPON_TMP) {
-                            if (state.heroAmmo[Weapons.AMMO_CLIP] < GameParams.AMMO_ENSURED_CLIP) {
-                                state.heroAmmo[Weapons.AMMO_CLIP] = GameParams.AMMO_ENSURED_CLIP;
+
+                            if (state.heroAmmo[Weapons.AMMO_CLIP] < GameConfig.AMMO_ENSURED_CLIP) {
+                                state.heroAmmo[Weapons.AMMO_CLIP] = GameConfig.AMMO_ENSURED_CLIP;
                             }
                         } else if (act.param == Weapons.WEAPON_WINCHESTER || act.param == Weapons.WEAPON_AK47) {
-                            if (state.heroAmmo[Weapons.AMMO_SHELL] < GameParams.AMMO_ENSURED_SHELL) {
-                                state.heroAmmo[Weapons.AMMO_SHELL] = GameParams.AMMO_ENSURED_SHELL;
+                            if (state.heroAmmo[Weapons.AMMO_SHELL] < GameConfig.AMMO_ENSURED_SHELL) {
+                                state.heroAmmo[Weapons.AMMO_SHELL] = GameConfig.AMMO_ENSURED_SHELL;
                             }
                         } else { // Weapons.WEAPON_GRENADE
-                            if (state.heroAmmo[Weapons.AMMO_GRENADE] < GameParams.AMMO_ENSURED_GRENADE) {
-                                state.heroAmmo[Weapons.AMMO_GRENADE] = GameParams.AMMO_ENSURED_GRENADE;
+                            if (state.heroAmmo[Weapons.AMMO_GRENADE] < GameConfig.AMMO_ENSURED_GRENADE) {
+                                state.heroAmmo[Weapons.AMMO_GRENADE] = GameConfig.AMMO_ENSURED_GRENADE;
                             }
                         }
-
-                        weapons.updateWeapon();
                     }
                     break;
 
@@ -941,13 +922,21 @@ public class Level implements EngineObject {
                     state.cheatsDisabled = true;
                     state.godMode = false;
                     break;
+
+                case ACTION_WITHOUT_NOTIFICATION:
+                    resultSoundIdx = -1;
+                    break;
+
+                case ACTION_TRACK_EVENT:
+                    App.self.tracker.trackEvent("Scripted", state.levelName + ":" + String.valueOf(act.param));
+                    break;
             }
         }
 
         return resultSoundIdx;
     }
 
-    void setPassable(float x,
+    public void setPassable(float x,
             float y,
             @SuppressWarnings("SameParameterValue") float wallDist,
             @SuppressWarnings("SameParameterValue") int mask) {
@@ -964,7 +953,7 @@ public class Level implements EngineObject {
         }
     }
 
-    void clearPassable(float x,
+    public void clearPassable(float x,
             float y,
             @SuppressWarnings("SameParameterValue") float wallDist,
             @SuppressWarnings("SameParameterValue") int mask) {
@@ -983,7 +972,7 @@ public class Level implements EngineObject {
         }
     }
 
-    void fillInitialInWallMap(float x,
+    public void fillInitialInWallMap(float x,
             float y,
             @SuppressWarnings("SameParameterValue") float wallDist,
             @SuppressWarnings("SameParameterValue") int mask) {
@@ -1008,7 +997,7 @@ public class Level implements EngineObject {
 
     // call fillInitialInWallMap before using isPassable
     @SuppressWarnings("BooleanMethodIsAlwaysInverted")
-    boolean isPassable(float x,
+    public boolean isPassable(float x,
             float y,
             @SuppressWarnings("SameParameterValue") float wallDist,
             @SuppressWarnings("SameParameterValue") int mask) {
@@ -1037,7 +1026,8 @@ public class Level implements EngineObject {
     }
 
     @SuppressWarnings("ConstantConditions")
-    void buildPathToWaveMap() {
+    public void buildPathToWaveMap() {
+        // Common.log(">>>> buildPathToWaveMap " + state.pathToX + ", " + state.pathToY + "; " + state.heroKeysMask);
         int[][] localPathToWaveMap = pathToWaveMap;
 
         for (int cy = 0, levelHeight = state.levelHeight; cy < levelHeight; cy++) {
@@ -1122,5 +1112,21 @@ public class Level implements EngineObject {
             bufferIdx = 1 - bufferIdx;
             waveIdx++;
         }
+
+        // for (int cy = 0, levelHeight = state.levelHeight; cy < levelHeight; cy++) {
+        //     StringBuilder sb = new StringBuilder();
+        //     //
+        //     for (int cx = 0, levelWidth = state.levelWidth; cx < levelWidth; cx++) {
+        //         if (sb.length() != 0) {
+        //             sb.append(' ');
+        //         }
+        //         //
+        //         sb.append(localPathToWaveMap[cy][cx] == MAX_PATH_TO_WAVE
+        //                 ? "--"
+        //                 : String.format(Locale.US, "%02d", localPathToWaveMap[cy][cx]));
+        //     }
+        //     //
+        //     Common.log(sb.toString());
+        // }
     }
 }
diff --git a/src/main/java/zame/game/engine/LevelConfig.java b/src/main/java/zame/game/engine/level/LevelConfig.java
similarity index 79%
rename from src/main/java/zame/game/engine/LevelConfig.java
rename to src/main/java/zame/game/engine/level/LevelConfig.java
index 8af8d73..d1af3c6 100644
--- a/src/main/java/zame/game/engine/LevelConfig.java
+++ b/src/main/java/zame/game/engine/level/LevelConfig.java
@@ -1,19 +1,19 @@
-package zame.game.engine;
+package zame.game.engine.level;
 
 import android.content.res.AssetManager;
 import java.util.Locale;
-import zame.game.Common;
+import zame.game.core.util.Common;
 
 public class LevelConfig {
-    static final int HIT_TYPE_MEELE = 0;
-    static final int HIT_TYPE_CLIP = 1;
-    static final int HIT_TYPE_SHELL = 2;
-    static final int HIT_TYPE_GRENADE = 3;
+    public static final int HIT_TYPE_MEELE = 0;
+    public static final int HIT_TYPE_CLIP = 1;
+    public static final int HIT_TYPE_SHELL = 2;
+    public static final int HIT_TYPE_GRENADE = 3;
 
-    static class MonsterConfig {
-        int health;
-        int hits;
-        int hitType;
+    public static class MonsterConfig {
+        public int health;
+        public int hits;
+        public int hitType;
 
         MonsterConfig(int health, int hits, int hitType) {
             this.health = health;
@@ -23,7 +23,7 @@ public class LevelConfig {
     }
 
     @SuppressWarnings({ "FieldCanBeLocal", "unused" }) private String levelName;
-    int graphicsSet;
+    public int graphicsSet;
     public MonsterConfig[] monsters;
 
     @SuppressWarnings("MagicNumber")
@@ -39,7 +39,7 @@ public class LevelConfig {
     }
 
     @SuppressWarnings("MagicNumber")
-    static LevelConfig read(AssetManager assetManager, String levelName) {
+    public static LevelConfig read(AssetManager assetManager, String levelName) {
         LevelConfig res = new LevelConfig(levelName);
 
         try {
diff --git a/src/main/java/zame/game/engine/level/LevelRenderer.java b/src/main/java/zame/game/engine/level/LevelRenderer.java
new file mode 100644
index 0000000..76f9ccd
--- /dev/null
+++ b/src/main/java/zame/game/engine/level/LevelRenderer.java
@@ -0,0 +1,1194 @@
+package zame.game.engine.level;
+
+import zame.game.core.serializer.DataList;
+import zame.game.engine.Engine;
+import zame.game.engine.EngineObject;
+import zame.game.engine.entity.AutoWall;
+import zame.game.engine.entity.Bullet;
+import zame.game.engine.entity.BulletTrace;
+import zame.game.engine.entity.DebugTraceInfo;
+import zame.game.engine.entity.Door;
+import zame.game.engine.entity.Explosion;
+import zame.game.engine.entity.Monster;
+import zame.game.engine.entity.ObjectContainer;
+import zame.game.engine.entity.TouchedCell;
+import zame.game.engine.graphics.Renderer;
+import zame.game.engine.graphics.TextureLoader;
+import zame.game.engine.state.State;
+import zame.game.engine.util.GameMath;
+
+public class LevelRenderer implements EngineObject {
+    private static final float FRUSTUM_SIZE = 0.1f * (float)Math.tan(Math.toRadians(50.0) / 2);
+
+    private static final int LIGHTTAB_MAX = 1000;
+    private static final int LIGHTTAB_LAST = LIGHTTAB_MAX - 1;
+    private static final float LIGHTTAB_VAL_MIN = 0.25f;
+    private static final float LIGHTTAB_VAL_MAX = 0.75f;
+    private static final float LIGHTTAB_VAL_MID = (LIGHTTAB_VAL_MIN + LIGHTTAB_VAL_MAX) * 0.5f;
+    private static final float LIGHTTAB_VAL_SINMULT = (LIGHTTAB_VAL_MAX - LIGHTTAB_VAL_MIN) * 0.5f;
+    private static final float LIGHTTAB_DIST_MULT = LIGHTTAB_MAX / 10.0f;
+
+    public static final int AUTO_WALL_TYPE_WALL = 0;
+    public static final int AUTO_WALL_TYPE_TRANSP = 1;
+    public static final int AUTO_WALL_TYPE_DOOR = 2;
+
+    public static final int AUTO_WALL_MASK_HORIZONTAL = 1;
+    public static final int AUTO_WALL_MASK_VERTICAL = 2;
+    public static final int AUTO_WALL_MASK_DOOR = 4;
+
+    public static final int MAX_AUTO_WALLS = Level.MAX_WIDTH * Level.MAX_HEIGHT * 2;
+    public static final int MAX_AW_CELLS = Level.MAX_WIDTH * Level.MAX_HEIGHT;
+    public static final float HALF_WALL = 0.4f;
+    public static final float LIGHT_OBJECT = 1.0f;
+
+    private static final float HALF_WALL_PLUS_EXTRUDE = HALF_WALL + 0.05f;
+    private static final float HALF_DOOR_WIDTH = 0.025f;
+    private static final float LIGHT_DOOR = 0.5f;
+    private static final float LIGHT_LAMP = 1.0f;
+    private static final float LIGHT_ARROW = 1.0f;
+    private static final float MONSTER_SIZE_MULT = 0.75f;
+    private static final float EXTRUDE_LIGHT_MULT = 0.5f;
+
+    private static final float BTRACE_MIN_SCALE = 0.005f;
+    private static final float BTRACE_MAX_SCALE = 0.05f;
+    private static final float BTRACE_MAX_DIST = 10.0f;
+
+    public PortalTracer tracer = new PortalTracer();
+
+    public boolean debugOnAutomap;
+    public boolean[][] awTouchedCellsMap = new boolean[Level.MAX_HEIGHT][Level.MAX_WIDTH];
+    public DataList<DebugTraceInfo> debugTraceInfos = new DataList<>(DebugTraceInfo.class, Level.MAX_BULLETS * 3);
+
+    private float[] lightTab = new float[LIGHTTAB_MAX];
+    private Engine engine;
+    private State state;
+    private Renderer renderer;
+    private Level level;
+    private float[][] lightMap = new float[Level.MAX_HEIGHT * 2 + 1][Level.MAX_WIDTH * 2 + 1];
+    public float currentHeroX;
+    public float currentHeroY;
+    public float currentHeroA;
+    private float sightDx;
+    private float sightDy;
+    private float billboardDx;
+    private float billboardDy;
+    public DataList<BulletTrace> bulletTraces = new DataList<>(BulletTrace.class, Level.MAX_BULLETS);
+
+    public LevelRenderer() {
+        //
+        //                  ^
+        //                  |
+        // LIGHTTAB_VAL_MAX | ###
+        //                  |    ##
+        //                  |      #
+        //                  |       ##
+        // LIGHTTAB_VAL_MIN |         ###
+        //                  |
+        // -----------------+-------------------->
+        //                  | 0  LIGHTTAB_LAST
+        //
+
+        for (int i = 0; i < LIGHTTAB_MAX; i++) {
+            float v = (float)Math.sin((float)i / (float)LIGHTTAB_MAX * GameMath.PI_F + GameMath.PI_D2F);
+            lightTab[i] = LIGHTTAB_VAL_MID + LIGHTTAB_VAL_SINMULT * v;
+        }
+    }
+
+    @Override
+    public void onCreate(Engine engine) {
+        this.engine = engine;
+        this.state = engine.state;
+        this.renderer = engine.renderer;
+        this.level = engine.level;
+
+        tracer.onCreate(engine);
+    }
+
+    public void updateAfterLevelLoadedOrCreated() {
+        for (AutoWall aw = state.autoWalls.first(); aw != null; aw = aw.next) {
+            if (aw.doorUid >= 0) {
+                for (Door door = state.doors.first(); door != null; door = door.next) {
+                    if (door.uid == aw.doorUid) {
+                        aw.door = door;
+                        break;
+                    }
+                }
+
+                if (aw.door == null) {
+                    aw.doorUid = -1;
+                }
+            }
+        }
+
+        for (Bullet bullet = state.bullets.first(); bullet != null; bullet = bullet.next) {
+            if (bullet.monUid >= 0) {
+                for (Monster mon = state.monsters.first(); mon != null; mon = mon.next) {
+                    if (mon.uid == bullet.monUid) {
+                        bullet.mon = mon;
+                        break;
+                    }
+                }
+            }
+        }
+
+        for (Explosion explosion = state.explosions.first(); explosion != null; explosion = explosion.next) {
+            if (explosion.monUid >= 0) {
+                for (Monster mon = state.monsters.first(); mon != null; mon = mon.next) {
+                    if (mon.uid == explosion.monUid) {
+                        explosion.mon = mon;
+                        break;
+                    }
+                }
+            }
+        }
+
+        for (int i = 0, levelHeight = state.levelHeight; i < levelHeight; i++) {
+            for (int j = 0, levelWidth = state.levelWidth; j < levelWidth; j++) {
+                awTouchedCellsMap[i][j] = false;
+            }
+        }
+
+        for (TouchedCell tc = state.awTouchedCells.first(); tc != null; tc = tc.next) {
+            awTouchedCellsMap[tc.y][tc.x] = true;
+        }
+
+        for (int ly = 0, maxLy = state.levelHeight * 2 + 1; ly < maxLy; ly++) {
+            for (int lx = 0, maxLx = state.levelWidth * 2 + 1; lx < maxLx; lx++) {
+                lightMap[ly][lx] = 0.0f;
+            }
+        }
+
+        for (int y = 0, levelHeight = state.levelHeight; y < levelHeight; y++) {
+            for (int x = 0, levelWidth = state.levelWidth; x < levelWidth; x++) {
+                modLightMap(x, y, getLightMapValue(x, y));
+            }
+        }
+    }
+
+    float getLightMapValue(int x, int y) {
+        float value = 0.0f;
+        int pass = state.passableMap[y][x];
+
+        if (level.doorsMap[y][x] != null) {
+            value += LIGHT_DOOR;
+        } else if ((pass & Level.PASSABLE_IS_OBJECT) != 0) {
+            value += LIGHT_OBJECT;
+        } else if ((pass & Level.PASSABLE_IS_DECOR_LAMP) != 0) {
+            int tex = state.texMap[y][x];
+
+            for (int i = 0, len = TextureLoader.DLAMP_LIGHTS.length; i < len; i++) {
+                if (TextureLoader.DLAMP_LIGHTS[i] == tex) {
+                    value += LIGHT_LAMP;
+                    break;
+                }
+            }
+        } else if ((pass & Level.PASSABLE_IS_WALL) != 0) {
+            int tex = state.wallsMap[y][x];
+
+            for (int i = 0, len = TextureLoader.WALL_LIGHTS.length; i < len; i++) {
+                if (TextureLoader.WALL_LIGHTS[i] == tex) {
+                    value += LIGHT_LAMP;
+                    break;
+                }
+            }
+        } else if ((pass & Level.PASSABLE_IS_DECOR_ITEM) != 0) {
+            int tex = state.texMap[y][x];
+
+            for (int i = 0, len = TextureLoader.DITEM_LIGHTS.length; i < len; i++) {
+                if (TextureLoader.DITEM_LIGHTS[i] == tex) {
+                    value += LIGHT_LAMP;
+                    break;
+                }
+            }
+        }
+
+        int ceil1 = state.ceilMap1[y][x];
+        int ceil2 = state.ceilMap2[y][x];
+        int ceil3 = state.ceilMap3[y][x];
+        int ceil4 = state.ceilMap4[y][x];
+
+        for (int i = 0, len = TextureLoader.CEIL_LIGHTS.length; i < len; i++) {
+            int cl = TextureLoader.CEIL_LIGHTS[i];
+
+            if (ceil1 == cl || ceil2 == cl || ceil3 == cl || ceil4 == cl) {
+                value += LIGHT_LAMP;
+                break;
+            }
+        }
+
+        if (state.arrowsMap[y][x] != 0) {
+            value += LIGHT_ARROW;
+        }
+
+        return value;
+    }
+
+    public void modLightMap(int cx, int cy, float val) {
+        int lx = cx * 2;
+        int ly = cy * 2;
+
+        lightMap[ly][lx] += val;
+        lightMap[ly][lx + 1] += val;
+        lightMap[ly][lx + 2] += val;
+
+        ly++;
+        lightMap[ly][lx] += val;
+        lightMap[ly][lx + 1] += val;
+        lightMap[ly][lx + 2] += val;
+
+        ly++;
+        lightMap[ly][lx] += val;
+        lightMap[ly][lx + 1] += val;
+        lightMap[ly][lx + 2] += val;
+    }
+
+    @SuppressWarnings("MagicNumber")
+    private float getLightness(float x, float y) {
+        float dx = x - currentHeroX;
+        float dy = y - currentHeroY;
+        int d = (int)((float)Math.sqrt((double)(dx * dx + dy * dy)) * LIGHTTAB_DIST_MULT);
+
+        try {
+            return lightTab[d < 0 ? 0 : (d > LIGHTTAB_LAST ? LIGHTTAB_LAST : d)]
+                    + lightMap[(int)((y + 0.25f) * 2.0f)][(int)((x + 0.25f) * 2.0f)];
+        } catch (ArrayIndexOutOfBoundsException ex) {
+            return 0.0f;
+        }
+    }
+
+    @SuppressWarnings("MagicNumber")
+    private void setWallLighting(float fromX, float fromY, float toX, float toY, boolean vert) {
+        int ang = ((int)currentHeroA + (vert ? 0 : 270)) % 360;
+
+        if (ang > 90) {
+            if (ang < 180) {
+                ang = 180 - ang;
+            } else if (ang < 270) {
+                ang = ang - 180;
+            } else {
+                ang = 360 - ang;
+            }
+        }
+
+        float l = 1.0f - 0.5f * (float)ang / 90.0f;
+        renderer.setColorQuadLight(getLightness(fromX, fromY) * l, getLightness(toX, toY) * l);
+    }
+
+    // This method:
+    // did *not* check for available space (MAX_AUTO_WALLS),
+    // did *not* check if wall already exists,
+    // did *not* append wall mask,
+    // did *not* add doors
+    public void appendAutoWall(int fromX, int fromY, int toX, int toY, int type) {
+        AutoWall foundAw = null;
+        boolean vert = (fromX == toX);
+
+        for (AutoWall aw = state.autoWalls.first(); aw != null; aw = aw.next) {
+            if (aw.door != null || aw.vert != vert || aw.type != type) {
+                continue;
+            }
+
+            if ((int)aw.fromX == fromX && (int)aw.fromY == fromY) {
+                aw.fromX = (float)toX;
+                aw.fromY = (float)toY;
+                foundAw = aw;
+                break;
+            } else if ((int)aw.toX == fromX && (int)aw.toY == fromY) {
+                aw.toX = (float)toX;
+                aw.toY = (float)toY;
+                foundAw = aw;
+                break;
+            } else if ((int)aw.fromX == toX && (int)aw.fromY == toY) {
+                aw.fromX = (float)fromX;
+                aw.fromY = (float)fromY;
+                foundAw = aw;
+                break;
+            } else if ((int)aw.toX == toX && (int)aw.toY == toY) {
+                aw.toX = (float)fromX;
+                aw.toY = (float)fromY;
+                foundAw = aw;
+                break;
+            }
+        }
+
+        if (foundAw == null) {
+            AutoWall aw = state.autoWalls.take();
+
+            aw.fromX = (float)fromX;
+            aw.fromY = (float)fromY;
+            aw.toX = (float)toX;
+            aw.toY = (float)toY;
+            aw.vert = vert;
+            aw.type = type;
+            aw.doorUid = -1;
+            aw.door = null;
+
+            return;
+        }
+
+        for (; ; ) {
+            AutoWall nextFoundAw = null;
+
+            for (AutoWall aw = state.autoWalls.first(); aw != null; aw = aw.next) {
+                if ((aw == foundAw) || (aw.door != null) || (aw.vert != foundAw.vert) || (aw.type != foundAw.type)) {
+                    continue;
+                }
+
+                if ((int)aw.fromX == (int)foundAw.fromX && (int)aw.fromY == (int)foundAw.fromY) {
+                    aw.fromX = foundAw.toX;
+                    aw.fromY = foundAw.toY;
+                    nextFoundAw = aw;
+                    break;
+                } else if ((int)aw.toX == (int)foundAw.fromX && (int)aw.toY == (int)foundAw.fromY) {
+                    aw.toX = foundAw.toX;
+                    aw.toY = foundAw.toY;
+                    nextFoundAw = aw;
+                    break;
+                } else if ((int)aw.fromX == (int)foundAw.toX && (int)aw.fromY == (int)foundAw.toY) {
+                    aw.fromX = foundAw.fromX;
+                    aw.fromY = foundAw.fromY;
+                    nextFoundAw = aw;
+                    break;
+                } else if ((int)aw.toX == (int)foundAw.toX && (int)aw.toY == (int)foundAw.toY) {
+                    aw.toX = foundAw.fromX;
+                    aw.toY = foundAw.fromY;
+                    nextFoundAw = aw;
+                    break;
+                }
+            }
+
+            if (nextFoundAw == null) {
+                break;
+            }
+
+            state.autoWalls.release(foundAw);
+            foundAw = nextFoundAw;
+        }
+    }
+
+    private void renderWalls() {
+        renderer.startBatch();
+        renderer.setCoordsQuadBillboardZ(-HALF_WALL, HALF_WALL);
+
+        PortalTracer.Wall[] localWalls = tracer.walls;
+        Door[][] localDoorsMap = level.doorsMap;
+        int[][] localDrawnAutoWalls = state.drawnAutoWalls;
+
+        for (int i = 0, len = tracer.wallsCount; i < len; i++) {
+            int autoWallMask;
+            Door door;
+            PortalTracer.Wall wall = localWalls[i];
+
+            if (wall.fromX == wall.toX) {
+                door = (wall.fromY < wall.toY
+                        ? localDoorsMap[wall.fromY][wall.fromX - 1]
+                        : localDoorsMap[wall.toY][wall.fromX]);
+
+                autoWallMask = AUTO_WALL_MASK_VERTICAL;
+            } else {
+                door = (wall.fromX < wall.toX
+                        ? localDoorsMap[wall.fromY][wall.fromX]
+                        : localDoorsMap[wall.fromY - 1][wall.toX]);
+
+                autoWallMask = AUTO_WALL_MASK_HORIZONTAL;
+            }
+
+            // by the way, mx and my *not* always equal to wall.cellX and wall.cellY
+            int mx = (wall.fromX < wall.toX ? wall.fromX : wall.toX);
+            int my = (wall.fromY < wall.toY ? wall.fromY : wall.toY);
+
+            if (((localDrawnAutoWalls[my][mx] & autoWallMask) == 0) && state.autoWalls.canTake()) {
+                localDrawnAutoWalls[my][mx] |= autoWallMask;
+                appendAutoWall(wall.fromX, wall.fromY, wall.toX, wall.toY, AUTO_WALL_TYPE_WALL);
+            }
+
+            renderer.setCoordsQuadBillboard((float)wall.fromX, (float)wall.fromY, (float)wall.toX, (float)wall.toY);
+
+            setWallLighting((float)wall.fromX,
+                    (float)wall.fromY,
+                    (float)wall.toX,
+                    (float)wall.toY,
+                    (wall.fromX == wall.toX));
+
+            if (door != null) {
+                renderer.batchTexQuad(door.texture + TextureLoader.BASE_DOORS_S);
+            } else if (wall.flipTexture) {
+                renderer.batchTexQuadFlipped(wall.texture);
+            } else {
+                renderer.batchTexQuad(wall.texture);
+            }
+        }
+
+        TouchedCell[] localTouchedCells = tracer.touchedCells;
+
+        for (int i = 0, len = tracer.touchedCellsCountPriorToPostProcess; i < len; i++) {
+            TouchedCell tc = localTouchedCells[i];
+
+            if (!awTouchedCellsMap[tc.y][tc.x] && state.awTouchedCells.canTake()) {
+                awTouchedCellsMap[tc.y][tc.x] = true;
+                state.awTouchedCells.take().copyFrom(tc);
+            }
+        }
+
+        renderer.renderBatch(Renderer.FLAG_CULL
+                        | Renderer.FLAG_DEPTH
+                        | Renderer.FLAG_ALPHA
+                        | Renderer.FLAG_SMOOTH,
+                Renderer.TEXTURE_MAIN);
+    }
+
+    @SuppressWarnings("MagicNumber")
+    private void renderDoors() {
+        renderer.startBatch();
+        renderer.setCoordsQuadBillboardZ(-HALF_WALL, HALF_WALL);
+
+        TouchedCell[] localTouchedCells = tracer.touchedCells;
+        Door[][] localDoorsMap = level.doorsMap;
+        int[][] localDrawnAutoWalls = state.drawnAutoWalls;
+
+        for (int i = 0, len = tracer.touchedCellsCount; i < len; i++) {
+            TouchedCell tc = localTouchedCells[i];
+            Door door = localDoorsMap[tc.y][tc.x];
+
+            if (door == null) {
+                continue;
+            }
+
+            float fromX;
+            float fromY;
+            float toX;
+            float toY;
+
+            float fromX1;
+            float fromY1;
+            float toX1;
+            float toY1;
+
+            float fromX2;
+            float fromY2;
+            float toX2;
+            float toY2;
+
+            if (door.vert) {
+                fromX = (float)door.x + 0.5f;
+                toX = fromX;
+                fromY = (float)door.y;
+                toY = fromY + 1.0f;
+            } else {
+                fromX = (float)door.x;
+                toX = fromX + 1.0f;
+                fromY = (float)door.y + 0.5f;
+                toY = fromY;
+            }
+
+            if ((localDrawnAutoWalls[door.y][door.x] & AUTO_WALL_MASK_DOOR) == 0 && state.autoWalls.canTake()) {
+                localDrawnAutoWalls[door.y][door.x] |= AUTO_WALL_MASK_DOOR;
+                AutoWall aw = state.autoWalls.take();
+
+                aw.fromX = fromX;
+                aw.fromY = fromY;
+                aw.toX = toX;
+                aw.toY = toY;
+                aw.vert = door.vert;
+                aw.type = AUTO_WALL_TYPE_DOOR;
+                aw.doorUid = door.uid;
+                aw.door = door;
+            }
+
+            if (door.vert) {
+                fromY += door.openPos;
+                toY += door.openPos;
+
+                fromX1 = fromX - HALF_DOOR_WIDTH;
+                fromY1 = fromY;
+                toX1 = fromX1;
+                toY1 = toY;
+
+                fromX2 = fromX + HALF_DOOR_WIDTH;
+                fromY2 = fromY;
+                toX2 = fromX2;
+                toY2 = toY;
+            } else {
+                fromX += door.openPos;
+                toX += door.openPos;
+
+                fromX1 = fromX;
+                fromY1 = fromY - HALF_DOOR_WIDTH;
+                toX1 = toX;
+                toY1 = fromY1;
+
+                fromX2 = fromX;
+                fromY2 = fromY + HALF_DOOR_WIDTH;
+                toX2 = toX;
+                toY2 = fromY2;
+            }
+
+            setWallLighting(fromX, fromY, toX, toY, door.vert);
+
+            renderer.setCoordsQuadBillboard(fromX1, fromY1, toX1, toY1);
+            renderer.batchTexQuad(door.texture + TextureLoader.BASE_DOORS_F);
+
+            renderer.setCoordsQuadBillboard(fromX2, fromY2, toX2, toY2);
+            renderer.batchTexQuad(door.texture + TextureLoader.BASE_DOORS_F);
+
+            setWallLighting(fromX1, fromY1, fromX2, fromY2, !door.vert);
+
+            renderer.r1 *= EXTRUDE_LIGHT_MULT;
+            renderer.g1 *= EXTRUDE_LIGHT_MULT;
+            renderer.b1 *= EXTRUDE_LIGHT_MULT;
+
+            renderer.r2 *= EXTRUDE_LIGHT_MULT;
+            renderer.g2 *= EXTRUDE_LIGHT_MULT;
+            renderer.b2 *= EXTRUDE_LIGHT_MULT;
+
+            renderer.r3 *= EXTRUDE_LIGHT_MULT;
+            renderer.g3 *= EXTRUDE_LIGHT_MULT;
+            renderer.b3 *= EXTRUDE_LIGHT_MULT;
+
+            renderer.r4 *= EXTRUDE_LIGHT_MULT;
+            renderer.g4 *= EXTRUDE_LIGHT_MULT;
+            renderer.b4 *= EXTRUDE_LIGHT_MULT;
+
+            renderer.setCoordsQuadBillboard(fromX1, fromY1, fromX2, fromY2);
+            renderer.batchTexQuadExtruded(door.texture + TextureLoader.BASE_DOORS_S);
+        }
+
+        renderer.renderBatch(Renderer.FLAG_DEPTH | Renderer.FLAG_SMOOTH, Renderer.TEXTURE_MAIN);
+    }
+
+    // render objects, decorations and transparents
+    @SuppressWarnings("MagicNumber")
+    private void batchObjects() {
+        TouchedCell[] localTouchedCells = tracer.touchedCells;
+        int[][] localPassableMap = state.passableMap;
+        int[][] localTexMap = state.texMap;
+        int[][] localDrawnAutoWalls = state.drawnAutoWalls;
+
+        renderer.setCoordsQuadBillboardZ(-HALF_WALL, HALF_WALL);
+
+        float objOffX = -sightDx * GameMath.SIGHT_OFFSET;
+        float objOffY = -sightDy * GameMath.SIGHT_OFFSET;
+
+        for (int i = 0, len = tracer.touchedCellsCount; i < len; i++) {
+            TouchedCell tc = localTouchedCells[i];
+            int pass = localPassableMap[tc.y][tc.x];
+            int tex = localTexMap[tc.y][tc.x];
+
+            if ((pass & Level.PASSABLE_IS_OBJECT) != 0) {
+                ObjectContainer container = state.objectsMap.get(tc.y).get(tc.x);
+                int objectsCount = container.count;
+
+                if (objectsCount == 0) {
+                    // should not happen
+                    continue;
+                }
+
+                float mx = (float)tc.x + 0.5f;
+                float my = (float)tc.y + 0.5f;
+
+                renderer.setColorQuadLight(getLightness(mx, my));
+
+                if (objectsCount == 1) {
+                    renderer.setCoordsQuadBillboard(mx - billboardDx + objOffX,
+                            my - billboardDy + objOffY,
+                            mx + billboardDx + objOffX,
+                            my + billboardDy + objOffY);
+
+                    renderer.batchTexQuad(container.get(0));
+                } else {
+                    for (int objIndex = 0; objIndex < objectsCount; objIndex++) {
+                        float oa = (float)objIndex * GameMath.PI_M2F / (float)objectsCount;
+
+                        float omx = mx + (float)Math.cos(oa) * 0.25f;
+                        float omy = my + (float)Math.sin(oa) * 0.25f;
+
+                        renderer.setCoordsQuadBillboard(omx - billboardDx,
+                                omy - billboardDy,
+                                omx + billboardDx,
+                                omy + billboardDy);
+
+                        renderer.batchTexQuad(container.get(objIndex));
+                    }
+                }
+
+                continue;
+            }
+
+            if ((pass & Level.PASSABLE_MASK_DECORATION) != 0) {
+                float mx = (float)tc.x + 0.5f;
+                float my = (float)tc.y + 0.5f;
+
+                renderer.setCoordsQuadBillboard(mx - billboardDx,
+                        my - billboardDy,
+                        mx + billboardDx,
+                        my + billboardDy);
+
+                renderer.setColorQuadLight(getLightness(mx, my));
+                renderer.batchTexQuad(tex);
+                continue;
+            }
+
+            if ((pass & Level.PASSABLE_IS_TRANSP_WINDOW) != 0) {
+                float fromX;
+                float fromY;
+                float toX;
+                float toY;
+
+                boolean vert = ((pass & Level.PASSABLE_IS_TRANSP_WINDOW_VERT) != 0);
+
+                if (vert) {
+                    fromX = (float)tc.x + 0.5f;
+                    toX = fromX;
+                    fromY = (float)tc.y;
+                    toY = fromY + 1.0f;
+                } else {
+                    fromX = (float)tc.x;
+                    toX = fromX + 1.0f;
+                    fromY = (float)tc.y + 0.5f;
+                    toY = fromY;
+                }
+
+                if ((localDrawnAutoWalls[tc.y][tc.x] & AUTO_WALL_MASK_DOOR) == 0 && state.autoWalls.canTake()) {
+                    localDrawnAutoWalls[tc.y][tc.x] |= AUTO_WALL_MASK_DOOR;
+                    AutoWall aw = state.autoWalls.take();
+
+                    aw.fromX = fromX;
+                    aw.fromY = fromY;
+                    aw.toX = toX;
+                    aw.toY = toY;
+                    aw.vert = vert;
+                    aw.type = AUTO_WALL_TYPE_TRANSP;
+                    aw.doorUid = -1;
+                    aw.door = null;
+                }
+
+                renderer.setCoordsQuadBillboard(fromX, fromY, toX, toY);
+                setWallLighting(fromX, fromY, toX, toY, vert);
+                renderer.batchTexQuad(tex);
+
+                continue;
+            }
+
+            if ((pass & Level.PASSABLE_IS_TRANSP) != 0
+                    && (pass & Level.PASSABLE_IS_NOTRANS) == 0
+                    && tex != 0) {
+
+                for (int s = 0; s < 4; s++) {
+                    if ((localPassableMap[tc.y + PortalTracer.Y_CELL_ADD[s]][tc.x + PortalTracer.X_CELL_ADD[s]]
+                            & Level.PASSABLE_MASK_WALL_N_TRANSP) == 0) {
+
+                        int fromX = tc.x + PortalTracer.X_ADD[s];
+                        int fromY = tc.y + PortalTracer.Y_ADD[s];
+                        int toX = tc.x + PortalTracer.X_ADD[(s + 1) % 4];
+                        int toY = tc.y + PortalTracer.Y_ADD[(s + 1) % 4];
+
+                        renderer.setCoordsQuadBillboard((float)fromX, (float)fromY, (float)toX, (float)toY);
+
+                        int mx = (fromX < toX ? fromX : toX);
+                        int my = (fromY < toY ? fromY : toY);
+                        int autoWallMask = ((s == 1 || s == 3) ? AUTO_WALL_MASK_VERTICAL : AUTO_WALL_MASK_HORIZONTAL);
+
+                        if (((localDrawnAutoWalls[my][mx] & autoWallMask) == 0) && state.autoWalls.canTake()) {
+                            localDrawnAutoWalls[my][mx] |= autoWallMask;
+                            appendAutoWall(fromX, fromY, toX, toY, AUTO_WALL_TYPE_TRANSP);
+                        }
+
+                        setWallLighting((float)fromX, (float)fromY, (float)toX, (float)toY, (s == 1 || s == 3));
+
+                        if (s == 0 || s == 3) {
+                            renderer.batchTexQuadFlipped(tex);
+                        } else {
+                            renderer.batchTexQuad(tex);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings("MagicNumber")
+    private void renderMonsters(long elapsedTime, int texIdx, boolean deadCorpses) {
+        renderer.startBatch();
+        renderer.setCoordsQuadBillboardZ(-HALF_WALL, HALF_WALL * MONSTER_SIZE_MULT);
+
+        int fromTex = texIdx * TextureLoader.MONSTERS_IN_TEXTURE * TextureLoader.COUNT_MONSTER;
+        int toTex = fromTex + TextureLoader.MONSTERS_IN_TEXTURE * TextureLoader.COUNT_MONSTER - 1;
+
+        boolean[][] tcMap = tracer.touchedCellsMap;
+
+        float offX = deadCorpses ? sightDx * GameMath.SIGHT_OFFSET : 0.0f;
+        float offY = deadCorpses ? sightDy * GameMath.SIGHT_OFFSET : 0.0f;
+
+        for (Monster mon = state.monsters.first(); mon != null; mon = mon.next) {
+            if ((deadCorpses && mon.health > 0)
+                    || (!deadCorpses && mon.health <= 0)
+                    || mon.texture < fromTex
+                    || mon.texture > toTex) {
+
+                continue;
+            }
+
+            if (!tcMap[mon.cellY][mon.cellX]
+                    && !(mon.prevY >= 0 && mon.prevX >= 0 && tcMap[mon.prevY][mon.prevX])) {
+
+                continue;
+            }
+
+            int tex = mon.texture - fromTex;
+
+            if (mon.health > 0) {
+                if ((mon.stunTicks <= 0) && (mon.attackTicks > 0)) {
+                    tex += 15;
+                } else {
+                    if (mon.isAimedOnHero) {
+                        tex += 2;
+                    } else if (mon.chaseMode) {
+                        tex += ((((int)currentHeroA + 360 + 45 - mon.dir * 90) % 360) / 90);
+                    }
+
+                    if (mon.stunTicks > 0) {
+                        tex += 8;
+                    } else if (!mon.isInAttackState && ((elapsedTime % 800) > 400)) {
+                        tex += 4;
+                    }
+                }
+            } else {
+                if (mon.dieTime == 0) {
+                    mon.dieTime = elapsedTime;
+                }
+
+                tex += 12 + (mon.dieTime < 0 ? 2 : Math.min(2, (elapsedTime - mon.dieTime) / 150));
+            }
+
+            renderer.setCoordsQuadBillboard(mon.x - billboardDx * MONSTER_SIZE_MULT + offX,
+                    mon.y - billboardDy * MONSTER_SIZE_MULT + offY,
+                    mon.x + billboardDx * MONSTER_SIZE_MULT + offX,
+                    mon.y + billboardDy * MONSTER_SIZE_MULT + offY);
+
+            renderer.setColorQuadLight(getLightness(mon.x, mon.y));
+            renderer.batchTexQuadMon(tex);
+        }
+
+        renderer.renderBatch(Renderer.FLAG_DEPTH | Renderer.FLAG_ALPHA | Renderer.FLAG_SMOOTH,
+                Renderer.TEXTURE_MONSTERS + texIdx);
+    }
+
+    private void renderArrows() {
+        TouchedCell[] localTouchedCells = tracer.touchedCells;
+        int[][] localWallsMap = state.wallsMap;
+        int[][] localArrowsMap = state.arrowsMap;
+
+        renderer.startBatch();
+        renderer.setCoordsQuadZ(-HALF_WALL + GameMath.SIGHT_OFFSET);
+
+        for (int i = 0, len = tracer.touchedCellsCount; i < len; i++) {
+            TouchedCell tc = localTouchedCells[i];
+            int arrowTex = localArrowsMap[tc.y][tc.x];
+
+            if ((localWallsMap[tc.y][tc.x] > 0) || (arrowTex == 0)) {
+                continue;
+            }
+
+            float fx = (float)tc.x;
+            float tx = (float)(tc.x + 1);
+            float fy = (float)tc.y;
+            float ty = (float)(tc.y + 1);
+
+            renderer.setColorQuadLight(getLightness(fx, ty),
+                    getLightness(fx, fy),
+                    getLightness(tx, fy),
+                    getLightness(tx, ty));
+
+            renderer.setCoordsQuadRect(fx, -ty, tx, -fy);
+            renderer.batchTexQuad(arrowTex);
+        }
+
+        renderer.renderBatch(Renderer.FLAG_DEPTH | Renderer.FLAG_ALPHA | Renderer.FLAG_SMOOTH, Renderer.TEXTURE_MAIN);
+    }
+
+    @SuppressWarnings({ "MagicNumber", "ConstantConditions" })
+    private void renderFloorAndCeil() {
+        TouchedCell[] localTouchedCells = tracer.touchedCells;
+        int[][] localWallsMap = state.wallsMap;
+        int[][] localFloorMap1 = state.floorMap1;
+        int[][] localFloorMap2 = state.floorMap2;
+        int[][] localFloorMap3 = state.floorMap3;
+        int[][] localFloorMap4 = state.floorMap4;
+        int[][] localCeilMap1 = state.ceilMap1;
+        int[][] localCeilMap2 = state.ceilMap2;
+        int[][] localCeilMap3 = state.ceilMap3;
+        int[][] localCeilMap4 = state.ceilMap4;
+
+        renderer.startBatch();
+
+        for (int i = 0, len = tracer.touchedCellsCount; i < len; i++) {
+            TouchedCell tc = localTouchedCells[i];
+
+            int floorTex1 = localFloorMap1[tc.y][tc.x];
+            int floorTex2 = localFloorMap2[tc.y][tc.x];
+            int floorTex3 = localFloorMap3[tc.y][tc.x];
+            int floorTex4 = localFloorMap4[tc.y][tc.x];
+
+            int ceilTex1 = localCeilMap1[tc.y][tc.x];
+            int ceilTex2 = localCeilMap2[tc.y][tc.x];
+            int ceilTex3 = localCeilMap3[tc.y][tc.x];
+            int ceilTex4 = localCeilMap4[tc.y][tc.x];
+
+            float fx = (float)tc.x;
+            float tx = (float)(tc.x + 1);
+            float fy = (float)tc.y;
+            float ty = (float)(tc.y + 1);
+            float mx = fx + 0.5f;
+            float my = fy + 0.5f;
+
+            float lff = getLightness(fx, fy);
+            float lft = getLightness(fx, ty);
+            float ltf = getLightness(tx, fy);
+            float ltt = getLightness(tx, ty);
+            float lfm = getLightness(fx, my);
+            float lmf = getLightness(mx, fy);
+            float lmm = getLightness(mx, my);
+            float lmt = getLightness(mx, ty);
+            float ltm = getLightness(tx, my);
+
+            fy = -fy;
+            ty = -ty;
+            my = -my;
+
+            if (localWallsMap[tc.y][tc.x] <= 0) {
+                // render floor
+                renderer.setCoordsQuadZ(-HALF_WALL);
+
+                if (floorTex1 == floorTex2 && floorTex1 == floorTex3 && floorTex1 == floorTex4) {
+                    if (floorTex1 != 0) {
+                        renderer.setColorQuadLight(lft, lff, ltf, ltt);
+                        renderer.setCoordsQuadRect(fx, ty, tx, fy);
+                        renderer.batchTexQuad(floorTex1);
+                    }
+                } else {
+                    if (floorTex1 != 0) {
+                        renderer.setColorQuadLight(lfm, lff, lmf, lmm);
+                        renderer.setCoordsQuadRect(fx, my, mx, fy);
+                        renderer.batchTexQuadPieceTL(floorTex1);
+                    }
+
+                    if (floorTex2 != 0) {
+                        renderer.setColorQuadLight(lmm, lmf, ltf, ltm);
+                        renderer.setCoordsQuadRect(mx, my, tx, fy);
+                        renderer.batchTexQuadPieceTR(floorTex2);
+                    }
+
+                    if (floorTex3 != 0) {
+                        renderer.setColorQuadLight(lft, lfm, lmm, lmt);
+                        renderer.setCoordsQuadRect(fx, ty, mx, my);
+                        renderer.batchTexQuadPieceBL(floorTex3);
+                    }
+
+                    if (floorTex4 != 0) {
+                        renderer.setColorQuadLight(lmt, lmm, ltm, ltt);
+                        renderer.setCoordsQuadRect(mx, ty, tx, my);
+                        renderer.batchTexQuadPieceBR(floorTex4);
+                    }
+                }
+
+                // render ceil
+                renderer.setCoordsQuadZ(HALF_WALL);
+
+                if (ceilTex1 == ceilTex2 && ceilTex1 == ceilTex3 && ceilTex1 == ceilTex4) {
+                    if (ceilTex1 != 0) {
+                        renderer.setColorQuadLight(ltt, ltf, lff, lft);
+                        renderer.setCoordsQuadRect(tx, ty, fx, fy);
+                        renderer.batchTexQuadFlipped(ceilTex1);
+                    }
+                } else {
+                    if (ceilTex1 != 0) {
+                        renderer.setColorQuadLight(lmm, lmf, lff, lmt);
+                        renderer.setCoordsQuadRect(mx, my, fx, fy);
+                        renderer.batchTexQuadFlippedPartTL(ceilTex1);
+                    }
+
+                    if (ceilTex2 != 0) {
+                        renderer.setColorQuadLight(ltm, ltf, lmf, lmm);
+                        renderer.setCoordsQuadRect(tx, my, mx, fy);
+                        renderer.batchTexQuadFlippedPartTR(ceilTex2);
+                    }
+
+                    if (ceilTex3 != 0) {
+                        renderer.setColorQuadLight(lmt, lmm, lfm, lft);
+                        renderer.setCoordsQuadRect(mx, ty, fx, my);
+                        renderer.batchTexQuadFlippedPartBL(ceilTex3);
+                    }
+
+                    if (ceilTex4 != 0) {
+                        renderer.setColorQuadLight(ltt, ltm, lmm, lmt);
+                        renderer.setCoordsQuadRect(tx, ty, mx, my);
+                        renderer.batchTexQuadFlippedPartBR(ceilTex4);
+                    }
+                }
+            }
+
+            // render extrude
+
+            // 2l | 1  2
+            // 4l | 3  4
+            // ---+------
+            //    | 1d 2d
+
+            renderer.z1 = HALF_WALL_PLUS_EXTRUDE;
+            renderer.z2 = HALF_WALL_PLUS_EXTRUDE;
+            renderer.z3 = HALF_WALL;
+            renderer.z4 = HALF_WALL;
+
+            lff *= EXTRUDE_LIGHT_MULT;
+            lft *= EXTRUDE_LIGHT_MULT;
+            // "ltf" is not used below
+            ltt *= EXTRUDE_LIGHT_MULT;
+            lfm *= EXTRUDE_LIGHT_MULT;
+            lmf *= EXTRUDE_LIGHT_MULT;
+            lmm *= EXTRUDE_LIGHT_MULT;
+            lmt *= EXTRUDE_LIGHT_MULT;
+            ltm *= EXTRUDE_LIGHT_MULT;
+
+            if (tc.x > 0) {
+                int ceilTex2l = localCeilMap2[tc.y][tc.x - 1];
+                int ceilTex4l = localCeilMap4[tc.y][tc.x - 1];
+
+                if ((ceilTex2l == 0 && ceilTex1 != 0) || (ceilTex2l != 0 && ceilTex1 == 0)) {
+                    renderer.setColorQuadLight(lff, lfm, lfm, lff);
+                    renderer.setCoordsQuadRect(fx, fy, fx, my);
+
+                    if (ceilTex1 != 0) {
+                        renderer.batchTexQuadPieceTL(ceilTex1);
+                    } else {
+                        renderer.batchTexQuadPieceTR(ceilTex2l);
+                    }
+                }
+
+                if ((ceilTex4l == 0 && ceilTex3 != 0) || (ceilTex4l != 0 && ceilTex3 == 0)) {
+                    renderer.setColorQuadLight(lfm, lft, lft, lfm);
+                    renderer.setCoordsQuadRect(fx, my, fx, ty);
+
+                    if (ceilTex3 != 0) {
+                        renderer.batchTexQuadPieceBL(ceilTex3);
+                    } else {
+                        renderer.batchTexQuadPieceBR(ceilTex4l);
+                    }
+                }
+            }
+
+            if (tc.y < (state.levelHeight - 1)) {
+                int ceilTex1d = localCeilMap1[tc.y + 1][tc.x];
+                int ceilTex2d = localCeilMap2[tc.y + 1][tc.x];
+
+                if ((ceilTex1d == 0 && ceilTex3 != 0) || (ceilTex1d != 0 && ceilTex3 == 0)) {
+                    renderer.setColorQuadLight(lft, lmt, lmt, lft);
+                    renderer.setCoordsQuadRectFlip(fx, ty, mx, ty);
+
+                    if (ceilTex3 != 0) {
+                        renderer.batchTexQuadPieceBL(ceilTex3);
+                    } else {
+                        renderer.batchTexQuadPieceBL(ceilTex1d);
+                    }
+                }
+
+                if ((ceilTex2d == 0 && ceilTex4 != 0) || (ceilTex2d != 0 && ceilTex4 == 0)) {
+                    renderer.setColorQuadLight(lmt, ltt, ltt, lmt);
+                    renderer.setCoordsQuadRectFlip(mx, ty, tx, ty);
+
+                    if (ceilTex4 != 0) {
+                        renderer.batchTexQuadPieceBR(ceilTex4);
+                    } else {
+                        renderer.batchTexQuadPieceTR(ceilTex2d);
+                    }
+                }
+            }
+
+            if ((ceilTex1 == 0 && ceilTex2 != 0) || (ceilTex1 != 0 && ceilTex2 == 0)) {
+                renderer.setColorQuadLight(lmf, lmm, lmm, lmf);
+                renderer.setCoordsQuadRect(mx, fy, mx, my);
+
+                if (ceilTex2 != 0) {
+                    renderer.batchTexQuadPieceTR(ceilTex2);
+                } else {
+                    renderer.batchTexQuadPieceTL(ceilTex1);
+                }
+            }
+
+            if ((ceilTex3 == 0 && ceilTex4 != 0) || (ceilTex3 != 0 && ceilTex4 == 0)) {
+                renderer.setColorQuadLight(lmm, lmt, lmt, lmm);
+                renderer.setCoordsQuadRect(mx, my, mx, ty);
+
+                if (ceilTex4 != 0) {
+                    renderer.batchTexQuadPieceBR(ceilTex4);
+                } else {
+                    renderer.batchTexQuadPieceBL(ceilTex3);
+                }
+            }
+
+            if ((ceilTex1 == 0 && ceilTex3 != 0) || (ceilTex1 != 0 && ceilTex3 == 0)) {
+                renderer.setColorQuadLight(lfm, lmm, lmm, lfm);
+                renderer.setCoordsQuadRectFlip(fx, my, mx, my);
+
+                if (ceilTex3 != 0) {
+                    renderer.batchTexQuadPieceBL(ceilTex3);
+                } else {
+                    renderer.batchTexQuadPieceTL(ceilTex1);
+                }
+            }
+
+            if ((ceilTex2 == 0 && ceilTex4 != 0) || (ceilTex2 != 0 && ceilTex4 == 0)) {
+                renderer.setColorQuadLight(lmm, ltm, ltm, lmm);
+                renderer.setCoordsQuadRectFlip(mx, my, tx, my);
+
+                if (ceilTex4 != 0) {
+                    renderer.batchTexQuadPieceBR(ceilTex4);
+                } else {
+                    renderer.batchTexQuadPieceTR(ceilTex2);
+                }
+            }
+        }
+
+        renderer.renderBatch(Renderer.FLAG_DEPTH | Renderer.FLAG_SMOOTH, Renderer.TEXTURE_MAIN);
+    }
+
+    @SuppressWarnings("MagicNumber")
+    private void batchBullets() {
+        boolean[][] localTouchedCellsMap = tracer.touchedCellsMap;
+
+        for (Bullet bullet = state.bullets.first(); bullet != null; bullet = bullet.next) {
+            int tex = bullet.getTexture();
+
+            if (tex < 0 || !localTouchedCellsMap[(int)bullet.y][(int)bullet.x]) {
+                continue;
+            }
+
+            float offZ = HALF_WALL * 0.5f * (float)Math.sin(bullet.dist / bullet.params.maxDist * Math.PI * 1.5);
+
+            renderer.setCoordsQuadBillboard(bullet.x - billboardDx,
+                    bullet.y - billboardDy,
+                    bullet.x + billboardDx,
+                    bullet.y + billboardDy,
+                    -HALF_WALL + offZ,
+                    HALF_WALL + offZ);
+
+            renderer.setColorQuadLight(getLightness(bullet.x, bullet.y));
+            renderer.batchTexQuad(TextureLoader.BASE_BULLETS + tex);
+        }
+    }
+
+    private void batchExplosions() {
+        boolean[][] localTouchedCellsMap = tracer.touchedCellsMap;
+        renderer.setCoordsQuadBillboardZ(-HALF_WALL, HALF_WALL);
+
+        for (Explosion explosion = state.explosions.first(); explosion != null; explosion = explosion.next) {
+            int tex = explosion.getTexture();
+
+            if (tex < 0 || !localTouchedCellsMap[(int)explosion.y][(int)explosion.x]) {
+                continue;
+            }
+
+            renderer.setCoordsQuadBillboard(explosion.x - billboardDx,
+                    explosion.y - billboardDy,
+                    explosion.x + billboardDx,
+                    explosion.y + billboardDy);
+
+            renderer.setColorQuadLight(getLightness(explosion.x, explosion.y));
+            renderer.batchTexQuad(TextureLoader.BASE_EXPLOSIONS + tex);
+        }
+    }
+
+    @SuppressWarnings("MagicNumber")
+    private void renderBulletTraces() {
+        renderer.startBatch();
+        renderer.setColorQuadRGB(1.0f, 1.0f, 1.0f);
+
+        for (BulletTrace bulletTrace = bulletTraces.first(); bulletTrace != null; ) {
+            BulletTrace nextBulletTrace = bulletTrace.next;
+
+            float dx = bulletTrace.x - currentHeroX;
+            float dy = bulletTrace.y - currentHeroY;
+            float dist = (float)Math.sqrt((double)(dx * dx + dy * dy));
+            float scale = BTRACE_MIN_SCALE + (BTRACE_MAX_SCALE - BTRACE_MIN_SCALE) * (dist / BTRACE_MAX_DIST);
+
+            float x = bulletTrace.x + billboardDx * bulletTrace.off - sightDx * GameMath.SIGHT_OFFSET;
+            float y = bulletTrace.y + billboardDy * bulletTrace.off - sightDy * GameMath.SIGHT_OFFSET;
+            float z = bulletTrace.z * -HALF_WALL;
+
+            renderer.setCoordsQuadBillboard(x - billboardDx * scale,
+                    y - billboardDy * scale,
+                    x + billboardDx * scale,
+                    y + billboardDy * scale,
+                    z - HALF_WALL * scale * 1.25f,
+                    z + HALF_WALL * scale * 1.25f);
+
+            renderer.setColorQuadA((float)bulletTrace.ticks / (float)BulletTrace.MAX_TICKS);
+            renderer.batchQuad();
+
+            bulletTrace.ticks--;
+
+            if (bulletTrace.ticks <= 0) {
+                bulletTraces.release(bulletTrace);
+            }
+
+            //noinspection AssignmentToForLoopParameter
+            bulletTrace = nextBulletTrace;
+        }
+
+        renderer.renderBatch(Renderer.FLAG_DEPTH | Renderer.FLAG_BLEND);
+    }
+
+    @SuppressWarnings("MagicNumber")
+    public void render(long elapsedTime, float ypos, float xrot) {
+        currentHeroX = state.heroX;
+        currentHeroY = state.heroY;
+        currentHeroA = state.heroA;
+
+        sightDx = engine.heroCs; // == cos(-heroAr);
+        sightDy = -engine.heroSn; // == sin(-heroAr);
+
+        billboardDx = sightDy * -0.5f;
+        billboardDy = sightDx * 0.5f;
+
+        for (Door door = state.doors.first(); door != null; door = door.next) {
+            door.updateBeforeRender();
+        }
+
+        tracer.trace(currentHeroX, currentHeroY, engine.heroAr, 44.0f * GameMath.G2RAD_F);
+
+        renderer.useFrustum(-FRUSTUM_SIZE,
+                FRUSTUM_SIZE,
+                -FRUSTUM_SIZE / engine.ratio,
+                FRUSTUM_SIZE / engine.ratio,
+                0.1f,
+                100.0f);
+
+        renderer.gl.glTranslatef(0.0f, ypos, -0.1f);
+        renderer.gl.glRotatef(xrot, 1.0f, 0.0f, 0.0f);
+        renderer.gl.glRotatef(90.0f - currentHeroA, 0.0f, 0.0f, 1.0f);
+        renderer.gl.glTranslatef(-currentHeroX, currentHeroY, 0.0f);
+
+        renderer.setColorQuadA(1.0f);
+
+        renderArrows();
+        renderFloorAndCeil();
+        renderWalls();
+        renderDoors();
+
+        renderMonsters(elapsedTime, 0, false);
+        renderMonsters(elapsedTime, 1, false);
+
+        renderer.startBatch();
+
+        batchExplosions();
+        batchBullets();
+        batchObjects();
+
+        renderer.renderBatch(Renderer.FLAG_DEPTH | Renderer.FLAG_ALPHA | Renderer.FLAG_SMOOTH,
+                Renderer.TEXTURE_MAIN);
+
+        renderMonsters(elapsedTime, 0, true);
+        renderMonsters(elapsedTime, 1, true);
+
+        renderBulletTraces();
+    }
+}
diff --git a/src/main/java/zame/game/engine/PortalTracer.java b/src/main/java/zame/game/engine/level/PortalTracer.java
similarity index 97%
rename from src/main/java/zame/game/engine/PortalTracer.java
rename to src/main/java/zame/game/engine/level/PortalTracer.java
index 798216a..c42ac94 100644
--- a/src/main/java/zame/game/engine/PortalTracer.java
+++ b/src/main/java/zame/game/engine/level/PortalTracer.java
@@ -1,4 +1,10 @@
-package zame.game.engine;
+package zame.game.engine.level;
+
+import zame.game.engine.Engine;
+import zame.game.engine.EngineObject;
+import zame.game.engine.state.State;
+import zame.game.engine.entity.TouchedCell;
+import zame.game.engine.util.GameMath;
 
 public class PortalTracer implements EngineObject {
     public static class Wall {
@@ -38,7 +44,7 @@ public class PortalTracer implements EngineObject {
     private int[][] level;
     private float heroX;
     private float heroY;
-    private int[][] drawedWalls = new int[Level.MAX_HEIGHT][Level.MAX_WIDTH];
+    private int[][] drawnWalls = new int[Level.MAX_HEIGHT][Level.MAX_WIDTH];
     private int tToSide = -1;
     private int tFromSide = -1;
 
@@ -61,18 +67,18 @@ public class PortalTracer implements EngineObject {
     }
 
     @Override
-    public void setEngine(Engine engine) {
+    public void onCreate(Engine engine) {
         this.state = engine.state;
     }
 
     private void addWallToDraw(int cellX, int cellY, int side, int texture) {
         int mask = 2 << side;
 
-        if ((wallsCount >= MAX_WALLS) || ((drawedWalls[cellY][cellX] & mask) != 0)) {
+        if ((wallsCount >= MAX_WALLS) || ((drawnWalls[cellY][cellX] & mask) != 0)) {
             return;
         }
 
-        drawedWalls[cellY][cellX] |= mask;
+        drawnWalls[cellY][cellX] |= mask;
         Wall wall = walls[wallsCount++];
 
         wall.fromX = cellX + X_ADD[side];
@@ -563,7 +569,7 @@ public class PortalTracer implements EngineObject {
 
     // halfFov must be between (10 * PI / 180) and (45 * PI / 180)
     @SuppressWarnings("MagicNumber")
-    void trace(float x, float y, float heroAngle, @SuppressWarnings("SameParameterValue") float halfFov) {
+    public void trace(float x, float y, float heroAngle, @SuppressWarnings("SameParameterValue") float halfFov) {
         level = state.wallsMap;
         levelWidth = state.levelWidth;
         levelHeight = state.levelHeight;
@@ -584,7 +590,7 @@ public class PortalTracer implements EngineObject {
         }
 
         boolean[][] localTouchedCellsMap = touchedCellsMap;
-        int[][] localDrawnWalls = drawedWalls;
+        int[][] localDrawnWalls = drawnWalls;
         TouchedCell[] localTouchedCells = touchedCells;
 
         for (int i = 0, lenI = levelHeight; i < lenI; i++) {
diff --git a/src/main/java/zame/game/engine/BaseState.java b/src/main/java/zame/game/engine/state/BaseState.java
similarity index 74%
rename from src/main/java/zame/game/engine/BaseState.java
rename to src/main/java/zame/game/engine/state/BaseState.java
index 3aec0df..c1bde13 100644
--- a/src/main/java/zame/game/engine/BaseState.java
+++ b/src/main/java/zame/game/engine/state/BaseState.java
@@ -1,4 +1,4 @@
-package zame.game.engine;
+package zame.game.engine.state;
 
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
@@ -6,15 +6,17 @@ import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
-import zame.game.Common;
-import zame.game.engine.data.DataItem;
-import zame.game.engine.data.DataReader;
-import zame.game.engine.data.DataWriter;
+import zame.game.core.util.Common;
+import zame.game.core.serializer.DataItem;
+import zame.game.core.serializer.DataReader;
+import zame.game.core.serializer.DataWriter;
 
 public abstract class BaseState implements DataItem {
+    private static final String SIGNATURE = "FireStrike5";
+
     public static final int LOAD_RESULT_SUCCESS = 0;
-    @SuppressWarnings("WeakerAccess") public static final int LOAD_RESULT_NOT_FOUND = 1;
-    @SuppressWarnings("WeakerAccess") public static final int LOAD_RESULT_ERROR = 2;
+    private static final int LOAD_RESULT_NOT_FOUND = 1;
+    static final int LOAD_RESULT_ERROR = 2;
 
     @Override
     public abstract void writeTo(DataWriter writer) throws IOException;
@@ -36,7 +38,7 @@ public abstract class BaseState implements DataItem {
             FileOutputStream fo = new FileOutputStream(tmpPath, false);
             ObjectOutputStream os = new ObjectOutputStream(fo);
 
-            DataWriter.writeTo(os, this, getVersion());
+            DataWriter.writeTo(os, this, SIGNATURE, getVersion());
 
             os.flush();
             fo.close();
@@ -54,7 +56,7 @@ public abstract class BaseState implements DataItem {
             FileInputStream fi = new FileInputStream(path);
             ObjectInputStream is = new ObjectInputStream(fi);
 
-            versionUpgrade(DataReader.readFrom(is, this, getVersion()));
+            versionUpgrade(DataReader.readFrom(is, this, SIGNATURE, getVersion()));
             return LOAD_RESULT_SUCCESS;
         } catch (FileNotFoundException ex) {
             return LOAD_RESULT_NOT_FOUND;
diff --git a/src/main/java/zame/game/engine/state/Profile.java b/src/main/java/zame/game/engine/state/Profile.java
new file mode 100644
index 0000000..430dfe5
--- /dev/null
+++ b/src/main/java/zame/game/engine/state/Profile.java
@@ -0,0 +1,165 @@
+package zame.game.engine.state;
+
+import android.content.Context;
+import android.support.v4.util.SparseArrayCompat;
+import java.io.File;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import zame.game.App;
+import zame.game.R;
+import zame.game.core.serializer.DataReader;
+import zame.game.core.serializer.DataWriter;
+import zame.game.core.util.Common;
+import zame.game.feature.achievements.Achievements;
+import zame.game.flavour.config.ProfileConfig;
+
+public class Profile extends BaseState {
+    // public static final String BROADCAST_ACTION_UPDATED = "local:Profile.updated";
+
+    private static final String FILE_NAME = "profile.data";
+
+    private static final int FIELD_BUILD = 1;
+    private static final int FIELD_EXP = 2;
+    private static final int FIELD_ACHIEVED = 3;
+    private static final int FIELD_ALREADY_COMPLETED_LEVELS = 4;
+
+    public boolean autoSaveOnUpdate = true;
+    public boolean isUnsavedUpdates;
+
+    public int exp;
+    public boolean[] achieved = new boolean[Achievements.LAST];
+    public HashSet<String> alreadyCompletedLevels = new HashSet<>();
+
+    public ProfileLevel[] levels = ProfileConfig.createLevelsList();
+    private HashMap<String, ProfileLevel> levelsMap = new HashMap<>();
+    private ProfileLevel dummyLevel = new ProfileLevel("", -1, 0, ProfileLevel.AD_NONE);
+    @SuppressWarnings("FieldCanBeLocal") private boolean wasChangedOnVersionUpgrade;
+
+    public Profile() {
+        super();
+        SparseArrayCompat<Integer> episodeIndices = new SparseArrayCompat<>();
+
+        for (int i = 0, len = levels.length; i < len; i++) {
+            int episodeIndex = (episodeIndices.indexOfKey(levels[i].episode) >= 0)
+                    ? episodeIndices.get(levels[i].episode)
+                    : 0;
+
+            episodeIndices.put(levels[i].episode, episodeIndex + 1);
+
+            levels[i].update(
+                    episodeIndex,
+                    (i > 0 ? levels[i - 1] : null),
+                    (i < (len - 1) ? levels[i + 1] : null));
+
+            levelsMap.put(levels[i].name, levels[i]);
+        }
+
+        for (ProfileLevel level : levels) {
+            level.episodeLevelsCount = episodeIndices.get(level.episode);
+        }
+
+        dummyLevel.update(0, null, null);
+    }
+
+    public ProfileLevel getLevel(String name) {
+        ProfileLevel level = levelsMap.get(name);
+        return (level == null ? dummyLevel : level);
+    }
+
+    public void clear(Context context) {
+        autoSaveOnUpdate = false;
+        isUnsavedUpdates = false;
+
+        exp = 0;
+
+        for (int i = 0, len = achieved.length; i < len; i++) {
+            achieved[i] = false;
+        }
+
+        alreadyCompletedLevels.clear();
+        update(context);
+    }
+
+    @Override
+    public void writeTo(DataWriter writer) throws IOException {
+        writer.write(FIELD_BUILD, App.self.getVersionName());
+        writer.write(FIELD_EXP, exp);
+        writer.write(FIELD_ACHIEVED, achieved);
+        writer.write(FIELD_ALREADY_COMPLETED_LEVELS, alreadyCompletedLevels.toArray(new String[0]));
+    }
+
+    @Override
+    public void readFrom(DataReader reader) {
+        exp = reader.readInt(FIELD_EXP);
+        achieved = reader.readBooleanArray(FIELD_ACHIEVED, Achievements.LAST);
+
+        alreadyCompletedLevels.clear();
+
+        alreadyCompletedLevels.addAll(Arrays.asList((String[])Common.defaultize(reader.readStringArray(
+                FIELD_ALREADY_COMPLETED_LEVELS), new String[0])));
+    }
+
+    public void update(Context context) {
+        update(context, true);
+    }
+
+    public void update(Context context, boolean changed) {
+        // Additional profile updates may be here
+
+        if (changed) {
+            if (autoSaveOnUpdate) {
+                save(context);
+            } else {
+                isUnsavedUpdates = true;
+            }
+        }
+
+        // MyApplication.self.getBroadcastManager().sendBroadcast(new Intent(BROADCAST_ACTION_UPDATED));
+    }
+
+    @SuppressWarnings("RedundantMethodOverride")
+    @Override
+    protected int getVersion() {
+        return 1;
+    }
+
+    @SuppressWarnings("RedundantMethodOverride")
+    @Override
+    protected void versionUpgrade(int version) {
+        // wasChangedOnVersionUpgrade = true;
+    }
+
+    public void loadInitial(Context context) {
+        if (new File(App.self.internalRoot + FILE_NAME).exists()) {
+            loadInternal(context);
+        } else {
+            update(context, false);
+            save(context);
+        }
+    }
+
+    private void loadInternal(Context context) {
+        if (isUnsavedUpdates) {
+            save(context);
+        }
+
+        wasChangedOnVersionUpgrade = false;
+
+        if (load(App.self.internalRoot + FILE_NAME) != LOAD_RESULT_SUCCESS) {
+            Common.showToast(context, R.string.engine_profile_cant_load);
+        }
+
+        update(context, wasChangedOnVersionUpgrade);
+    }
+
+    public void save(Context context) {
+        autoSaveOnUpdate = true;
+        isUnsavedUpdates = false;
+
+        if (!save(App.self.internalRoot + FILE_NAME)) {
+            Common.showToast(context, R.string.engine_profile_cant_save);
+        }
+    }
+}
diff --git a/src/main/java/zame/game/engine/state/ProfileLevel.java b/src/main/java/zame/game/engine/state/ProfileLevel.java
new file mode 100644
index 0000000..270e98b
--- /dev/null
+++ b/src/main/java/zame/game/engine/state/ProfileLevel.java
@@ -0,0 +1,38 @@
+package zame.game.engine.state;
+
+public class ProfileLevel {
+    public static final int AD_NONE = 0;
+    public static final int AD_REWARDED = 1; // only rewarded video (on gameover)
+    public static final int AD_INTERSTITIAL = 2; // rewarded video + interstitial
+
+    private ProfileLevel prev;
+    private ProfileLevel next;
+
+    public String name;
+    public int episode;
+    public int characterResId;
+    public int adLevel;
+    public int episodeIndex;
+    public int episodeLevelsCount = 1;
+
+    public ProfileLevel(String name, int episode, int characterResId, int adLevel) {
+        this.name = name;
+        this.episode = episode;
+        this.characterResId = characterResId;
+        this.adLevel = adLevel;
+    }
+
+    public void update(int episodeIndex, ProfileLevel prev, ProfileLevel next) {
+        this.episodeIndex = episodeIndex;
+        this.prev = prev;
+        this.next = next;
+    }
+
+    public String getPrevLevelName() {
+        return (prev == null ? "" : prev.name);
+    }
+
+    public String getNextLevelName() {
+        return (next == null ? "" : next.name);
+    }
+}
diff --git a/src/main/java/zame/game/engine/State.java b/src/main/java/zame/game/engine/state/State.java
similarity index 79%
rename from src/main/java/zame/game/engine/State.java
rename to src/main/java/zame/game/engine/state/State.java
index 02fb56f..5f32034 100644
--- a/src/main/java/zame/game/engine/State.java
+++ b/src/main/java/zame/game/engine/state/State.java
@@ -1,14 +1,36 @@
-package zame.game.engine;
+package zame.game.engine.state;
 
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.List;
 import zame.game.App;
-import zame.game.Common;
 import zame.game.R;
-import zame.game.engine.data.DataList;
-import zame.game.engine.data.DataReader;
-import zame.game.engine.data.DataWriter;
-import zame.game.store.Achievements;
+import zame.game.core.serializer.DataList;
+import zame.game.core.serializer.DataReader;
+import zame.game.core.serializer.DataWriter;
+import zame.game.core.util.Common;
+import zame.game.engine.Engine;
+import zame.game.engine.EngineObject;
+import zame.game.engine.entity.Action;
+import zame.game.engine.entity.AutoWall;
+import zame.game.engine.entity.Bullet;
+import zame.game.engine.entity.Door;
+import zame.game.engine.entity.Explosion;
+import zame.game.engine.entity.LookPoint;
+import zame.game.engine.entity.Mark;
+import zame.game.engine.entity.Monster;
+import zame.game.engine.entity.ObjectContainer;
+import zame.game.engine.entity.OnChangeWeaponAction;
+import zame.game.engine.entity.Timeout;
+import zame.game.engine.entity.TouchedCell;
+import zame.game.engine.graphics.TextureLoader;
+import zame.game.engine.level.Level;
+import zame.game.engine.level.LevelConfig;
+import zame.game.engine.level.LevelRenderer;
+import zame.game.engine.util.GameMath;
+import zame.game.engine.visual.Weapons;
+import zame.game.feature.achievements.Achievements;
+import zame.game.flavour.config.GameConfig;
 
 public class State extends BaseState implements EngineObject {
     public static final String LEVEL_INITIAL = "e00m00";
@@ -24,10 +46,10 @@ public class State extends BaseState implements EngineObject {
     private static final int FIELD_HERO_ARMOR = 9;
     private static final int FIELD_HERO_HAS_WEAPON = 10;
     private static final int FIELD_HERO_AMMO = 11;
-    private static final int FIELD_TOTAL_ITEMS = 12;
+    private static final int FIELD_OVERALL_DEATHS = 12;
     private static final int FIELD_TOTAL_MONSTERS = 13;
     private static final int FIELD_TOTAL_SECRETS = 14;
-    private static final int FIELD_PICKED_ITEMS = 15;
+    private static final int FIELD_OVERALL_RESURRECTS = 15;
     private static final int FIELD_KILLED_MONSTERS = 16;
     private static final int FIELD_FOUND_SECRETS = 17;
     private static final int FIELD_FOUND_SECRETS_MASK = 18;
@@ -41,7 +63,7 @@ public class State extends BaseState implements EngineObject {
     private static final int FIELD_MONSTERS = 26;
     private static final int FIELD_MARKS = 27;
     private static final int FIELD_ACTIONS = 28;
-    private static final int FIELD_DRAWED_AUTO_WALLS = 29;
+    private static final int FIELD_DRAWN_AUTO_WALLS = 29;
     private static final int FIELD_AUTO_WALLS = 30;
     private static final int FIELD_TEMP_ELAPSED_TIME = 31;
     private static final int FIELD_TEMP_LAST_TIME = 32;
@@ -50,10 +72,10 @@ public class State extends BaseState implements EngineObject {
     private static final int FIELD_HIGHLIGHTED_CONTROL_TYPE_MASK = 35;
     private static final int FIELD_SHOWN_MESSAGE_ID = 36;
     private static final int FIELD_HERO_VERT_A = 37;
-    private static final int FIELD_AUTO_SELECT_WEAPON = 38;
+    // private static final int FIELD_AUTO_SELECT_WEAPON = 38;
     private static final int FIELD_AW_TOUCHED_CELLS = 39;
     private static final int FIELD_TIME_IN_TICKS = 40;
-    private static final int FIELD_OVERALL_ITEMS = 41;
+    // private static final int FIELD_OVERALL_ITEMS = 41;
     private static final int FIELD_OVERALL_MONSTERS = 42;
     private static final int FIELD_OVERALL_SECRETS = 43;
     private static final int FIELD_OVERALL_SECONDS = 44;
@@ -93,73 +115,72 @@ public class State extends BaseState implements EngineObject {
     public float heroA;
     public int heroWeapon;
     public int[] lastWeapons = { -1, -1, -1 };
-    @SuppressWarnings("WeakerAccess") public int lastWeaponIdx;
+    public int lastWeaponIdx;
 
-    public int overallItems;
     public int overallMonsters;
     public int overallSecrets;
     public int overallSeconds;
+    public int overallDeaths;
+    public int overallResurrects;
     public int heroKeysMask;
     public int heroHealth;
     public int heroArmor;
     public int[] heroAmmo = new int[Weapons.AMMO_LAST];
 
-    boolean mustReload;
-    boolean mustLoadAutosave;
+    public boolean mustReload;
+    public boolean mustLoadAutosave;
     public float heroX;
     public float heroY;
-    boolean[] heroHasWeapon = new boolean[Weapons.WEAPON_LAST];
-
-    int totalItems;
-    int totalMonsters;
-    int totalSecrets;
-    int pickedItems;
-    int killedMonsters;
-    int foundSecrets;
-    int foundSecretsMask;
-    int timeInTicks; // divide by 40 to get seconds
-    int levelExp;
+    public boolean[] heroHasWeapon = new boolean[Weapons.WEAPON_LAST];
+
+    public int totalMonsters;
+    public int totalSecrets;
+    public int killedMonsters;
+    public int foundSecrets;
+    public int foundSecretsMask;
+    public int timeInTicks; // divide by 40 to get seconds
+    public int levelExp;
 
     private boolean savedOrNew;
 
     public int levelWidth;
     public int levelHeight;
 
-    int[][] wallsMap;
+    public int[][] wallsMap;
     public int[][] texMap;
-    int[][] objectsMap;
+    public List<List<ObjectContainer>> objectsMap = new ArrayList<>();
     public int[][] passableMap;
-    int[][] floorMap1;
-    int[][] floorMap2;
-    int[][] floorMap3;
-    int[][] floorMap4;
-    int[][] ceilMap1;
-    int[][] ceilMap2;
-    int[][] ceilMap3;
-    int[][] ceilMap4;
+    public int[][] floorMap1;
+    public int[][] floorMap2;
+    public int[][] floorMap3;
+    public int[][] floorMap4;
+    public int[][] ceilMap1;
+    public int[][] ceilMap2;
+    public int[][] ceilMap3;
+    public int[][] ceilMap4;
     public int[][] arrowsMap;
-    int[][] explosivesMap;
+    public int[][] explosivesMap;
 
     public DataList<Door> doors = new DataList<>(Door.class, Level.MAX_DOORS);
     public DataList<Monster> monsters = new DataList<>(Monster.class, Level.MAX_MONSTERS);
 
-    DataList<Mark> marks = new DataList<>(Mark.class, Level.MAX_MARKS);
-    DataList<Timeout> timeouts = new DataList<>(Timeout.class, Level.MAX_TIMEOUTS);
-    DataList<LookPoint> lookPoints = new DataList<>(LookPoint.class, Level.MAX_LOOK_POINTS);
+    public DataList<Mark> marks = new DataList<>(Mark.class, Level.MAX_MARKS);
+    public DataList<Timeout> timeouts = new DataList<>(Timeout.class, Level.MAX_TIMEOUTS);
+    public DataList<LookPoint> lookPoints = new DataList<>(LookPoint.class, Level.MAX_LOOK_POINTS);
 
-    DataList<OnChangeWeaponAction> onChangeWeaponActions = new DataList<>(OnChangeWeaponAction.class,
+    public DataList<OnChangeWeaponAction> onChangeWeaponActions = new DataList<>(OnChangeWeaponAction.class,
             Level.MAX_ON_CHANGE_WEAPON_ACTIONS);
 
-    public ArrayList<ArrayList<Action>> actions = new ArrayList<>();
+    public List<List<Action>> actions = new ArrayList<>();
 
     public int[][] drawnAutoWalls;
     public DataList<AutoWall> autoWalls = new DataList<>(AutoWall.class, LevelRenderer.MAX_AUTO_WALLS);
     public DataList<TouchedCell> awTouchedCells = new DataList<>(TouchedCell.class, LevelRenderer.MAX_AW_CELLS);
 
-    long tempElapsedTime;
-    long tempLastTime;
-    boolean godMode;
-    int shownMessageId;
+    public long tempElapsedTime;
+    public long tempLastTime;
+    public boolean godMode;
+    public int shownMessageId;
     public int disabledControlsMask;
     public int controlsHelpMask;
     public boolean cheatsDisabled;
@@ -168,7 +189,6 @@ public class State extends BaseState implements EngineObject {
     private int wpPathIdx;
 
     public float heroVertA;
-    public boolean autoSelectWeapon;
 
     public DataList<Bullet> bullets = new DataList<>(Bullet.class, Level.MAX_BULLETS);
     public DataList<Explosion> explosions = new DataList<>(Explosion.class, Level.MAX_EXPLOSIONS);
@@ -179,29 +199,33 @@ public class State extends BaseState implements EngineObject {
     public int pathToY;
 
     @Override
-    public void setEngine(Engine engine) {
+    public void onCreate(Engine engine) {
         this.engine = engine;
 
         for (int i = 0; i < doors.buffer.length; i++) {
-            ((EngineObject)doors.buffer[i]).setEngine(engine);
+            doors.buffer[i].onCreate(engine);
         }
 
         for (int i = 0; i < monsters.buffer.length; i++) {
-            ((EngineObject)monsters.buffer[i]).setEngine(engine);
+            monsters.buffer[i].onCreate(engine);
         }
 
         for (int i = 0; i < bullets.buffer.length; i++) {
-            ((EngineObject)bullets.buffer[i]).setEngine(engine);
+            bullets.buffer[i].onCreate(engine);
         }
 
         for (int i = 0; i < explosions.buffer.length; i++) {
-            ((EngineObject)explosions.buffer[i]).setEngine(engine);
+            explosions.buffer[i].onCreate(engine);
         }
     }
 
     public void setHeroA(float angle) {
-        heroA = angle;
-        engine.heroAngleUpdated();
+        //noinspection MagicNumber
+        heroA = (360.0f + (angle % 360.0f)) % 360.0f;
+
+        engine.heroAr = heroA * GameMath.G2RAD_F;
+        engine.heroCs = (float)Math.cos(engine.heroAr);
+        engine.heroSn = (float)Math.sin(engine.heroAr);
     }
 
     @SuppressWarnings("MagicNumber")
@@ -215,7 +239,7 @@ public class State extends BaseState implements EngineObject {
         heroVertA = angle;
     }
 
-    public void init() {
+    public void reload() {
         levelName = LEVEL_INITIAL;
         showEpisodeSelector = true;
         mustReload = false;
@@ -224,13 +248,14 @@ public class State extends BaseState implements EngineObject {
         levelWidth = 1;
         levelHeight = 1;
         heroWeapon = Weapons.WEAPON_KNIFE;
-        heroHealth = GameParams.HEALTH_MAX;
+        heroHealth = GameConfig.HEALTH_MAX;
         heroArmor = 0;
         godMode = false;
-        overallItems = 0;
         overallMonsters = 0;
         overallSecrets = 0;
         overallSeconds = 0;
+        overallDeaths = 0;
+        overallResurrects = 0;
         lastWeaponIdx = 0;
 
         for (int i = 0; i < Weapons.WEAPON_LAST; i++) {
@@ -258,12 +283,10 @@ public class State extends BaseState implements EngineObject {
         setStartValues();
     }
 
-    void setStartValues() {
+    public void setStartValues() {
         heroKeysMask = 0;
-        totalItems = 0;
         totalMonsters = 0;
         totalSecrets = 0;
-        pickedItems = 0;
         killedMonsters = 0;
         foundSecrets = 0;
         foundSecretsMask = 0;
@@ -276,12 +299,12 @@ public class State extends BaseState implements EngineObject {
         heroVertA = 0.0f;
         timeInTicks = 0;
         wpPathIdx = 0;
-        autoSelectWeapon = true;
         pathToX = -1;
         pathToY = -1;
 
         engine.level.requestBuildPathToWave();
 
+        objectsMap.clear();
         doors.clear();
         monsters.clear();
         marks.clear();
@@ -294,6 +317,15 @@ public class State extends BaseState implements EngineObject {
         bullets.clear();
         explosions.clear();
 
+        for (int i = 0; i < levelHeight; i++) {
+            List<ObjectContainer> line = new ArrayList<>();
+            objectsMap.add(line);
+
+            for (int j = 0; j < levelWidth; j++) {
+                line.add(new ObjectContainer());
+            }
+        }
+
         for (int i = 0; i < Level.MAX_ACTIONS; i++) {
             actions.add(new ArrayList<Action>());
         }
@@ -313,7 +345,11 @@ public class State extends BaseState implements EngineObject {
             for (int j = 0; j < levelWidth; j++) {
                 wallsMap[i][j] = TextureLoader.packTexId(wallsMap[i][j]);
                 texMap[i][j] = TextureLoader.packTexId(texMap[i][j]);
-                objectsMap[i][j] = TextureLoader.packTexId(objectsMap[i][j]);
+
+                for (int k = 0; k < ObjectContainer.MAX_OBJECTS; k++) {
+                    objectsMap.get(i).get(j).set(k, TextureLoader.packTexId(objectsMap.get(i).get(j).get(k)));
+                }
+
                 arrowsMap[i][j] = TextureLoader.packTexId(arrowsMap[i][j]);
 
                 floorMap1[i][j] = TextureLoader.packTexId(floorMap1[i][j]);
@@ -339,10 +375,8 @@ public class State extends BaseState implements EngineObject {
         writer.write(FIELD_HERO_ARMOR, heroArmor);
         writer.write(FIELD_HERO_HAS_WEAPON, heroHasWeapon);
         writer.write(FIELD_HERO_AMMO, heroAmmo);
-        writer.write(FIELD_TOTAL_ITEMS, totalItems);
         writer.write(FIELD_TOTAL_MONSTERS, totalMonsters);
         writer.write(FIELD_TOTAL_SECRETS, totalSecrets);
-        writer.write(FIELD_PICKED_ITEMS, pickedItems);
         writer.write(FIELD_KILLED_MONSTERS, killedMonsters);
         writer.write(FIELD_FOUND_SECRETS, foundSecrets);
         writer.write(FIELD_FOUND_SECRETS_MASK, foundSecretsMask);
@@ -350,13 +384,13 @@ public class State extends BaseState implements EngineObject {
         writer.write(FIELD_LEVEL_HEIGHT, levelHeight);
         writer.write(FIELD_WALLS_MAP, wallsMap);
         writer.write(FIELD_TEX_MAP, texMap);
-        writer.write(FIELD_OBJECTS_MAP, objectsMap);
+        writer.writeList2d(FIELD_OBJECTS_MAP, objectsMap);
         writer.write(FIELD_PASSABLE_MAP, passableMap);
         writer.write(FIELD_DOORS, doors);
         writer.write(FIELD_MONSTERS, monsters);
         writer.write(FIELD_MARKS, marks);
         writer.writeList2d(FIELD_ACTIONS, actions);
-        writer.write(FIELD_DRAWED_AUTO_WALLS, drawnAutoWalls);
+        writer.write(FIELD_DRAWN_AUTO_WALLS, drawnAutoWalls);
         writer.write(FIELD_AUTO_WALLS, autoWalls);
         writer.write(FIELD_TEMP_ELAPSED_TIME, tempElapsedTime);
         writer.write(FIELD_TEMP_LAST_TIME, tempLastTime);
@@ -365,13 +399,13 @@ public class State extends BaseState implements EngineObject {
         writer.write(FIELD_HIGHLIGHTED_CONTROL_TYPE_MASK, highlightedControlTypeMask);
         writer.write(FIELD_SHOWN_MESSAGE_ID, shownMessageId);
         writer.write(FIELD_HERO_VERT_A, heroVertA);
-        writer.write(FIELD_AUTO_SELECT_WEAPON, autoSelectWeapon);
         writer.write(FIELD_AW_TOUCHED_CELLS, awTouchedCells);
         writer.write(FIELD_TIME_IN_TICKS, timeInTicks);
-        writer.write(FIELD_OVERALL_ITEMS, overallItems);
         writer.write(FIELD_OVERALL_MONSTERS, overallMonsters);
         writer.write(FIELD_OVERALL_SECRETS, overallSecrets);
         writer.write(FIELD_OVERALL_SECONDS, overallSeconds);
+        writer.write(FIELD_OVERALL_DEATHS, overallDeaths);
+        writer.write(FIELD_OVERALL_RESURRECTS, overallResurrects);
         writer.write(FIELD_WP_PATH_IDX, wpPathIdx);
         writer.write(FIELD_BULLETS, bullets);
         writer.write(FIELD_EXPLOSIONS, explosions);
@@ -405,7 +439,11 @@ public class State extends BaseState implements EngineObject {
             for (int j = 0; j < levelWidth; j++) {
                 wallsMap[i][j] = TextureLoader.unpackTexId(wallsMap[i][j]);
                 texMap[i][j] = TextureLoader.unpackTexId(texMap[i][j]);
-                objectsMap[i][j] = TextureLoader.unpackTexId(objectsMap[i][j]);
+
+                for (int k = 0; k < ObjectContainer.MAX_OBJECTS; k++) {
+                    objectsMap.get(i).get(j).set(k, TextureLoader.unpackTexId(objectsMap.get(i).get(j).get(k)));
+                }
+
                 arrowsMap[i][j] = TextureLoader.unpackTexId(arrowsMap[i][j]);
 
                 floorMap1[i][j] = TextureLoader.unpackTexId(floorMap1[i][j]);
@@ -424,6 +462,8 @@ public class State extends BaseState implements EngineObject {
     @Override
     public void readFrom(DataReader reader) {
         levelName = reader.readString(FIELD_LEVEL_NAME, LEVEL_INITIAL);
+        levelWidth = reader.readInt(FIELD_LEVEL_WIDTH);
+        levelHeight = reader.readInt(FIELD_LEVEL_HEIGHT);
         heroX = reader.readFloat(FIELD_HERO_X);
         heroY = reader.readFloat(FIELD_HERO_Y);
         setHeroA(reader.readFloat(FIELD_HERO_A));
@@ -433,24 +473,20 @@ public class State extends BaseState implements EngineObject {
         heroArmor = reader.readInt(FIELD_HERO_ARMOR);
         heroHasWeapon = reader.readBooleanArray(FIELD_HERO_HAS_WEAPON, Weapons.WEAPON_LAST);
         heroAmmo = reader.readIntArray(FIELD_HERO_AMMO, Weapons.AMMO_LAST);
-        totalItems = reader.readInt(FIELD_TOTAL_ITEMS);
         totalMonsters = reader.readInt(FIELD_TOTAL_MONSTERS);
         totalSecrets = reader.readInt(FIELD_TOTAL_SECRETS);
-        pickedItems = reader.readInt(FIELD_PICKED_ITEMS);
         killedMonsters = reader.readInt(FIELD_KILLED_MONSTERS);
         foundSecrets = reader.readInt(FIELD_FOUND_SECRETS);
         foundSecretsMask = reader.readInt(FIELD_FOUND_SECRETS_MASK);
-        levelWidth = reader.readInt(FIELD_LEVEL_WIDTH);
-        levelHeight = reader.readInt(FIELD_LEVEL_HEIGHT);
         wallsMap = reader.readInt2dArray(FIELD_WALLS_MAP, levelHeight, levelWidth);
         texMap = reader.readInt2dArray(FIELD_TEX_MAP, levelHeight, levelWidth);
-        objectsMap = reader.readInt2dArray(FIELD_OBJECTS_MAP, levelHeight, levelWidth);
+        reader.readList2d(FIELD_OBJECTS_MAP, objectsMap, ObjectContainer.class);
         passableMap = reader.readInt2dArray(FIELD_PASSABLE_MAP, levelHeight, levelWidth);
         reader.readDataList(FIELD_DOORS, doors);
         reader.readDataList(FIELD_MONSTERS, monsters);
         reader.readDataList(FIELD_MARKS, marks);
         reader.readList2d(FIELD_ACTIONS, actions, Action.class);
-        drawnAutoWalls = reader.readInt2dArray(FIELD_DRAWED_AUTO_WALLS, levelHeight, levelWidth);
+        drawnAutoWalls = reader.readInt2dArray(FIELD_DRAWN_AUTO_WALLS, levelHeight, levelWidth);
         reader.readDataList(FIELD_AUTO_WALLS, autoWalls);
         tempElapsedTime = reader.readLong(FIELD_TEMP_ELAPSED_TIME);
         tempLastTime = reader.readLong(FIELD_TEMP_LAST_TIME);
@@ -459,13 +495,13 @@ public class State extends BaseState implements EngineObject {
         highlightedControlTypeMask = reader.readInt(FIELD_HIGHLIGHTED_CONTROL_TYPE_MASK);
         shownMessageId = reader.readInt(FIELD_SHOWN_MESSAGE_ID);
         heroVertA = reader.readFloat(FIELD_HERO_VERT_A);
-        autoSelectWeapon = reader.readBoolean(FIELD_AUTO_SELECT_WEAPON);
         reader.readDataList(FIELD_AW_TOUCHED_CELLS, awTouchedCells);
         timeInTicks = reader.readInt(FIELD_TIME_IN_TICKS);
-        overallItems = reader.readInt(FIELD_OVERALL_ITEMS);
         overallMonsters = reader.readInt(FIELD_OVERALL_MONSTERS);
         overallSecrets = reader.readInt(FIELD_OVERALL_SECRETS);
         overallSeconds = reader.readInt(FIELD_OVERALL_SECONDS);
+        overallDeaths = reader.readInt(FIELD_OVERALL_DEATHS);
+        overallResurrects = reader.readInt(FIELD_OVERALL_RESURRECTS);
         wpPathIdx = reader.readInt(FIELD_WP_PATH_IDX);
         reader.readDataList(FIELD_BULLETS, bullets);
         reader.readDataList(FIELD_EXPLOSIONS, explosions);
@@ -489,7 +525,7 @@ public class State extends BaseState implements EngineObject {
         controlsHelpMask = reader.readInt(FIELD_CONTROLS_HELP_MASK);
         reader.readDataList(FIELD_LOOK_POINTS, lookPoints);
         reader.readDataList(FIELD_ON_CHANGE_WEAPON_ACTIONS, onChangeWeaponActions);
-        lastWeapons = reader.readIntArray(FIELD_LAST_WEAPONS);
+        lastWeapons = reader.readIntArray(FIELD_LAST_WEAPONS, 3);
         lastWeaponIdx = reader.readInt(FIELD_LAST_WEAPON_IDX);
         pathToX = reader.readInt(FIELD_PATH_TO_X);
         pathToY = reader.readInt(FIELD_PATH_TO_Y);
@@ -497,23 +533,15 @@ public class State extends BaseState implements EngineObject {
 
         engine.level.requestBuildPathToWave();
 
-        if (lastWeapons == null || lastWeapons.length < 3) {
-            int[] newLastWeapons = { -1, -1, -1 };
-
-            if (lastWeapons != null) {
-                for (int i = 0, len = lastWeapons.length; i < len; i++) {
-                    newLastWeapons[i] = lastWeapons[i];
-                }
-            }
-
-            lastWeapons = newLastWeapons;
-        }
-
         for (int i = 0; i < levelHeight; i++) {
             for (int j = 0; j < levelWidth; j++) {
                 wallsMap[i][j] = TextureLoader.unpackTexId(wallsMap[i][j]);
                 texMap[i][j] = TextureLoader.unpackTexId(texMap[i][j]);
-                objectsMap[i][j] = TextureLoader.unpackTexId(objectsMap[i][j]);
+
+                for (int k = 0; k < ObjectContainer.MAX_OBJECTS; k++) {
+                    objectsMap.get(i).get(j).set(k, TextureLoader.unpackTexId(objectsMap.get(i).get(j).get(k)));
+                }
+
                 arrowsMap[i][j] = TextureLoader.unpackTexId(arrowsMap[i][j]);
 
                 floorMap1[i][j] = TextureLoader.unpackTexId(floorMap1[i][j]);
@@ -527,7 +555,7 @@ public class State extends BaseState implements EngineObject {
                 ceilMap4[i][j] = TextureLoader.unpackTexId(ceilMap4[i][j]);
 
                 if (((passableMap[i][j] & Level.PASSABLE_IS_EXPLOSIVE) != 0) && (explosivesMap[i][j] == 0)) {
-                    explosivesMap[i][j] = GameParams.HEALTH_BARREL;
+                    explosivesMap[i][j] = GameConfig.HEALTH_BARREL;
                 }
             }
         }
@@ -535,9 +563,10 @@ public class State extends BaseState implements EngineObject {
         engine.level.conf = LevelConfig.read(App.self.getAssets(), levelName);
     }
 
+    @SuppressWarnings("RedundantMethodOverride")
     @Override
     protected int getVersion() {
-        return 8;
+        return 1;
     }
 
     @SuppressWarnings("RedundantMethodOverride")
@@ -549,12 +578,12 @@ public class State extends BaseState implements EngineObject {
     public boolean save(String name) {
         if (levelExp != 0) {
             engine.profile.exp += levelExp;
-            engine.profile.save();
+            engine.profile.save(engine.activity);
             levelExp = 0;
         }
 
         if (!super.save(engine.getSavePathBySaveName(name))) {
-            Common.showToast(R.string.msg_cant_save_state);
+            Common.showToast(engine.activity, R.string.engine_state_cant_save);
             return false;
         }
 
@@ -566,7 +595,7 @@ public class State extends BaseState implements EngineObject {
         int result = super.load(engine.getSavePathBySaveName(name));
 
         if (result == LOAD_RESULT_ERROR) {
-            Common.showToast(R.string.msg_cant_load_state);
+            Common.showToast(engine.activity, R.string.engine_state_cant_load);
         }
 
         return result;
diff --git a/src/main/java/zame/game/engine/util/GameMath.java b/src/main/java/zame/game/engine/util/GameMath.java
new file mode 100644
index 0000000..720bf3c
--- /dev/null
+++ b/src/main/java/zame/game/engine/util/GameMath.java
@@ -0,0 +1,109 @@
+package zame.game.engine.util;
+
+public final class GameMath {
+    public static final float PI_F = (float)Math.PI;
+    public static final float PI_M2F = (float)(Math.PI * 2.0);
+    public static final float PI_D2F = (float)(Math.PI / 2.0);
+    public static final float G2RAD_F = (float)(Math.PI / 180.0);
+    public static final float RAD2G_F = (float)(180.0 / Math.PI);
+    public static final float EPSILON = 0.000000001f;
+    public static final float ONE_MINUS_LITTLE = 1.0f - 0.0001f;
+    public static final float SIGHT_OFFSET = 0.01f;
+
+    private GameMath() {}
+
+    public static float getAngle(float dx, float dy) {
+        float l = (float)Math.sqrt((double)(dx * dx + dy * dy));
+        float a = (float)Math.acos(dx / (l < EPSILON ? EPSILON : l));
+
+        return (dy < 0 ? a : (PI_M2F - a));
+    }
+
+    public static float getAngle(float dx, float dy, float l) {
+        float a = (float)Math.acos(dx / (l < EPSILON ? EPSILON : l));
+        return (dy < 0 ? a : (PI_M2F - a));
+    }
+
+    // modified Level_CheckLine from wolf3d for iphone by Carmack
+    public static boolean traceLine(int levelWidth,
+            int levelHeight,
+            int[][] passableMap,
+            float x1,
+            float y1,
+            float x2,
+            float y2,
+            int mask) {
+
+        int cx1 = (int)x1;
+        int cy1 = (int)y1;
+        int cx2 = (int)x2;
+        int cy2 = (int)y2;
+        int maxX = levelWidth - 1;
+        int maxY = levelHeight - 1;
+
+        // level has one-cell border
+        if (cx1 <= 0 || cx1 >= maxX || cy1 <= 0 || cy1 >= maxY || cx2 <= 0 || cx2 >= maxX || cy2 <= 0 || cy2 >= maxY) {
+            return false;
+        }
+
+        if (cx1 != cx2) {
+            int stepX;
+            float partial;
+
+            if (cx2 > cx1) {
+                partial = 1.0f - (x1 - (float)((int)x1));
+                stepX = 1;
+            } else {
+                partial = x1 - (float)((int)x1);
+                stepX = -1;
+            }
+
+            float dx = ((x2 >= x1) ? (x2 - x1) : (x1 - x2));
+            float stepY = (y2 - y1) / dx;
+            float y = y1 + (stepY * partial);
+
+            cx1 += stepX;
+            cx2 += stepX;
+
+            do {
+                if ((passableMap[(int)y][cx1] & mask) != 0) {
+                    return false;
+                }
+
+                y += stepY;
+                cx1 += stepX;
+            } while (cx1 != cx2);
+        }
+
+        if (cy1 != cy2) {
+            int stepY;
+            float partial;
+
+            if (cy2 > cy1) {
+                partial = 1.0f - (y1 - (float)((int)y1));
+                stepY = 1;
+            } else {
+                partial = y1 - (float)((int)y1);
+                stepY = -1;
+            }
+
+            float dy = ((y2 >= y1) ? (y2 - y1) : (y1 - y2));
+            float stepX = (x2 - x1) / dy;
+            float x = x1 + (stepX * partial);
+
+            cy1 += stepY;
+            cy2 += stepY;
+
+            do {
+                if ((passableMap[cy1][(int)x] & mask) != 0) {
+                    return false;
+                }
+
+                x += stepX;
+                cy1 += stepY;
+            } while (cy1 != cy2);
+        }
+
+        return true;
+    }
+}
diff --git a/src/main/java/zame/game/engine/hud/AutoMap.java b/src/main/java/zame/game/engine/visual/AutoMap.java
similarity index 62%
rename from src/main/java/zame/game/engine/hud/AutoMap.java
rename to src/main/java/zame/game/engine/visual/AutoMap.java
index 539048b..867d856 100644
--- a/src/main/java/zame/game/engine/hud/AutoMap.java
+++ b/src/main/java/zame/game/engine/visual/AutoMap.java
@@ -1,143 +1,102 @@
-package zame.game.engine.hud;
+package zame.game.engine.visual;
 
-import javax.microedition.khronos.opengles.GL10;
-import zame.game.engine.AutoWall;
-import zame.game.engine.Bullet;
-import zame.game.engine.Door;
 import zame.game.engine.Engine;
 import zame.game.engine.EngineObject;
-import zame.game.engine.Explosion;
-import zame.game.engine.GameMath;
-import zame.game.engine.Labels;
-import zame.game.engine.Level;
-import zame.game.engine.LevelRenderer;
-import zame.game.engine.Monster;
-import zame.game.engine.PortalTracer;
-import zame.game.engine.Renderer;
-import zame.game.engine.State;
-import zame.game.engine.TextureLoader;
-import zame.game.engine.TouchedCell;
-import zame.game.engine.TraceInfo;
-import zame.game.engine.controls.Controls;
+import zame.game.engine.entity.AutoMapPathCell;
+import zame.game.engine.entity.AutoWall;
+import zame.game.engine.entity.Bullet;
+import zame.game.engine.entity.DebugTraceInfo;
+import zame.game.engine.entity.Door;
+import zame.game.engine.entity.Explosion;
+import zame.game.engine.entity.Monster;
+import zame.game.engine.entity.TouchedCell;
+import zame.game.engine.graphics.Labels;
+import zame.game.engine.graphics.Renderer;
+import zame.game.engine.graphics.TextureLoader;
+import zame.game.engine.level.Level;
+import zame.game.engine.level.LevelRenderer;
+import zame.game.engine.level.PortalTracer;
+import zame.game.engine.state.State;
+import zame.game.engine.util.GameMath;
 
 public class AutoMap implements EngineObject {
     private static final float AUTOMAP_AREA = 30.0f;
     private static final float AUTOMAP_VIEW_OFFSET = 0.4f;
     private static final float AUTOMAP_VIEW_SIZE = 0.35f;
+    private static final float AUTOMAP_EDGE_MULT = 9.95f;
 
     private Engine engine;
     private Renderer renderer;
-    private TextureLoader textureLoader;
     private Level level;
     private LevelRenderer levelRenderer;
     private State state;
 
     @Override
-    public void setEngine(Engine engine) {
+    public void onCreate(Engine engine) {
         this.engine = engine;
         this.renderer = engine.renderer;
-        this.textureLoader = engine.textureLoader;
         this.level = engine.level;
         this.levelRenderer = engine.levelRenderer;
         this.state = engine.state;
     }
 
     @SuppressWarnings("MagicNumber")
-    public void render(GL10 gl) {
+    public void render() {
         if ((state.disabledControlsMask & Controls.CONTROL_MINIMAP) != 0) {
             return;
         }
 
-        gl.glDisable(GL10.GL_DEPTH_TEST);
-
-        renderer.initOrtho(gl,
-                true,
-                false,
-                -AUTOMAP_AREA * engine.ratio,
-                AUTOMAP_AREA * engine.ratio,
-                -AUTOMAP_AREA,
-                AUTOMAP_AREA,
-                0.0f,
-                1.0f);
-
         float autoMapOffX = engine.config.leftHandAim
                 ? AUTOMAP_AREA * AUTOMAP_VIEW_OFFSET - AUTOMAP_AREA * engine.ratio
                 : AUTOMAP_AREA * engine.ratio - AUTOMAP_AREA * AUTOMAP_VIEW_OFFSET;
 
         float autoMapOffY = AUTOMAP_AREA - AUTOMAP_AREA * AUTOMAP_VIEW_OFFSET;
 
-        gl.glPushMatrix(); // push model matrix
-        gl.glTranslatef(autoMapOffX, autoMapOffY, 0.0f);
+        float currentHeroX = levelRenderer.currentHeroX;
+        float currentHeroY = levelRenderer.currentHeroY;
 
         // ----
 
-        gl.glEnable(GL10.GL_STENCIL_TEST);
-        gl.glStencilFunc(GL10.GL_ALWAYS, 1, 0xff);
-        gl.glStencilOp(GL10.GL_REPLACE, GL10.GL_REPLACE, GL10.GL_REPLACE);
-        gl.glStencilMask(0xff);
-        gl.glClear(GL10.GL_STENCIL_BUFFER_BIT);
-
-        renderer.init();
-
-        renderer.x1 = -AUTOMAP_AREA * AUTOMAP_VIEW_SIZE;
-        renderer.y1 = -AUTOMAP_AREA * AUTOMAP_VIEW_SIZE;
+        renderer.startBatch();
+        renderer.setColorQuadRGBA(1.0f, 1.0f, 1.0f, 0.75f);
 
-        renderer.x2 = -AUTOMAP_AREA * AUTOMAP_VIEW_SIZE;
-        renderer.y2 = AUTOMAP_AREA * AUTOMAP_VIEW_SIZE;
+        renderer.setCoordsQuadRectFlat(-AUTOMAP_AREA * AUTOMAP_VIEW_SIZE,
+                -AUTOMAP_AREA * AUTOMAP_VIEW_SIZE,
+                AUTOMAP_AREA * AUTOMAP_VIEW_SIZE,
+                AUTOMAP_AREA * AUTOMAP_VIEW_SIZE);
 
-        renderer.x3 = AUTOMAP_AREA * AUTOMAP_VIEW_SIZE;
-        renderer.y3 = AUTOMAP_AREA * AUTOMAP_VIEW_SIZE;
+        renderer.batchTexQuad(TextureLoader.ICON_MAP);
 
-        renderer.x4 = AUTOMAP_AREA * AUTOMAP_VIEW_SIZE;
-        renderer.y4 = -AUTOMAP_AREA * AUTOMAP_VIEW_SIZE;
-
-        renderer.setQuadRGBA(1.0f, 1.0f, 1.0f, 0.75f);
-        renderer.drawQuad(TextureLoader.ICON_MAP);
-
-        gl.glEnable(GL10.GL_ALPHA_TEST);
-
-        // not using Renderer.ALPHA_VALUE to be able to render icon with alpha < 0.5
-        gl.glAlphaFunc(GL10.GL_GREATER, 0.1f);
+        renderer.useOrtho(-AUTOMAP_AREA * engine.ratio,
+                AUTOMAP_AREA * engine.ratio,
+                -AUTOMAP_AREA,
+                AUTOMAP_AREA,
+                0.0f,
+                1.0f);
 
-        // gl.glColorMask(false, false, false, false);
-        renderer.bindTexture(gl, textureLoader.textures[TextureLoader.TEXTURE_MAIN]);
-        renderer.flush(gl);
-        gl.glDisable(GL10.GL_ALPHA_TEST);
-        // gl.glColorMask(true, true, true, true);
+        renderer.gl.glTranslatef(autoMapOffX, autoMapOffY, 0.0f);
 
-        gl.glStencilFunc(GL10.GL_EQUAL, 1, 0xff);
-        gl.glStencilOp(GL10.GL_KEEP, GL10.GL_KEEP, GL10.GL_KEEP);
-        gl.glStencilMask(0);
+        renderer.renderBatch(Renderer.FLAG_BLEND
+                        | Renderer.FLAG_ALPHA
+                        | Renderer.FLAG_ALPHA_LOWER
+                        | Renderer.FLAG_STENCIL_REPLACE,
+                Renderer.TEXTURE_MAIN);
 
         // ----
 
-        gl.glRotatef(90.0f - levelRenderer.currentHeroA, 0.0f, 0.0f, 1.0f);
-        gl.glTranslatef(-levelRenderer.currentHeroX, levelRenderer.currentHeroY, 0.0f);
-
-        gl.glEnable(GL10.GL_BLEND);
-        gl.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);
-
-        renderer.init();
+        renderer.startBatch();
 
         if (levelRenderer.debugOnAutomap) {
-            renderer.r1 = 0.0f;
-            renderer.r2 = 0.0f;
-            renderer.g1 = 1.0f;
-            renderer.g2 = 1.0f;
-            renderer.b1 = 0.0f;
-            renderer.b2 = 0.0f;
-            renderer.a1 = 1.0f;
-            renderer.a2 = 1.0f;
+            renderer.setColorLineRGBA(0.0f, 1.0f, 0.0f, 1.0f);
 
             for (int i = 0, len = levelRenderer.tracer.touchedCellsCountPriorToPostProcess; i < len; i++) {
                 TouchedCell tc = levelRenderer.tracer.touchedCells[i];
 
-                renderer.drawLine((float)tc.x, -(float)tc.y, (float)tc.x + 1.0f, -(float)tc.y - 1.0f);
-                renderer.drawLine((float)tc.x, -(float)tc.y - 1.0f, (float)tc.x + 1.0f, -(float)tc.y);
+                renderer.batchLine((float)tc.x, -(float)tc.y, (float)tc.x + 1.0f, -(float)tc.y - 1.0f);
+                renderer.batchLine((float)tc.x, -(float)tc.y - 1.0f, (float)tc.x + 1.0f, -(float)tc.y);
             }
 
-            renderer.g1 = 0.5f;
-            renderer.g2 = 0.5f;
+            renderer.setColorLineRGB(0.0f, 0.5f, 0.0f);
 
             for (int i = levelRenderer.tracer.touchedCellsCountPriorToPostProcess, len = levelRenderer.tracer.touchedCellsCount;
                     i < len;
@@ -145,21 +104,14 @@ public class AutoMap implements EngineObject {
 
                 TouchedCell tc = levelRenderer.tracer.touchedCells[i];
 
-                renderer.drawLine((float)tc.x, -(float)tc.y, (float)tc.x + 1.0f, -(float)tc.y - 1.0f);
-                renderer.drawLine((float)tc.x, -(float)tc.y - 1.0f, (float)tc.x + 1.0f, -(float)tc.y);
+                renderer.batchLine((float)tc.x, -(float)tc.y, (float)tc.x + 1.0f, -(float)tc.y - 1.0f);
+                renderer.batchLine((float)tc.x, -(float)tc.y - 1.0f, (float)tc.x + 1.0f, -(float)tc.y);
             }
         }
 
-        renderer.r1 = 1.0f;
-        renderer.r2 = 1.0f;
-        renderer.g1 = 1.0f;
-        renderer.g2 = 1.0f;
-        renderer.b1 = 1.0f;
-        renderer.b2 = 1.0f;
-        renderer.a1 = 0.75f;
-        renderer.a2 = 0.75f;
+        renderer.setColorLineRGBA(1.0f, 1.0f, 1.0f, 0.75f);
 
-        for (AutoWall aw = state.autoWalls.first(); aw != null; aw = (AutoWall)aw.next) {
+        for (AutoWall aw = state.autoWalls.first(); aw != null; aw = aw.next) {
             if (aw.door != null) {
                 float fromX = aw.fromX;
                 float fromY = aw.fromY;
@@ -172,9 +124,9 @@ public class AutoMap implements EngineObject {
                     fromX += aw.door.openPos;
                 }
 
-                renderer.drawLine(fromX, -fromY, toX, -toY);
+                renderer.batchLine(fromX, -fromY, toX, -toY);
             } else {
-                renderer.drawLine(aw.fromX, -aw.fromY, aw.toX, -aw.toY);
+                renderer.batchLine(aw.fromX, -aw.fromY, aw.toX, -aw.toY);
             }
         }
 
@@ -184,10 +136,9 @@ public class AutoMap implements EngineObject {
         float cycle = (float)(engine.elapsedTime % 1000) / 1000.0f;
 
         // if (profile.isPurchased(Store.SECRETS)) {
-        //     renderer.r1 = 0.0f; renderer.r2 = 0.0f;
-        //     renderer.g1 = 1.0f; renderer.g2 = 1.0f;
+        //     renderer.setColorLineRGB(0.0f, 1.0f, 1.0f);
         //
-        //     for (TouchedCell tc = state.awTouchedCells.first(); tc != null; tc = (TouchedCell)tc.next) {
+        //     for (TouchedCell tc = state.awTouchedCells.first(); tc != null; tc = tc.next) {
         //         if ((localPassableMap[tc.y][tc.x] & Level.PASSABLE_IS_SECRET) == 0) {
         //             continue;
         //         }
@@ -195,12 +146,12 @@ public class AutoMap implements EngineObject {
         //         float x = (float)tc.x;
         // 	       float y = (float)tc.y;
         //
-        // 	       renderer.drawLine(x + 0.35f, -(y + 0.5f), x + 0.65f, -(y + 0.5f));
-        // 	       renderer.drawLine(x + 0.5f, -(y + 0.35f), x + 0.5f, -(y + 0.65f));
+        // 	       renderer.batchLine(x + 0.35f, -(y + 0.5f), x + 0.65f, -(y + 0.5f));
+        // 	       renderer.batchLine(x + 0.5f, -(y + 0.35f), x + 0.5f, -(y + 0.65f));
         //     }
         // }
 
-        for (TouchedCell tc = state.awTouchedCells.first(); tc != null; tc = (TouchedCell)tc.next) {
+        for (TouchedCell tc = state.awTouchedCells.first(); tc != null; tc = tc.next) {
             int arrowTex = localArrowsMap[tc.y][tc.x];
 
             if (arrowTex == 0) {
@@ -212,33 +163,27 @@ public class AutoMap implements EngineObject {
             float arrOffset = cycle * 0.5f - 0.5f;
 
             for (int i = 0; i < 2; i++) {
-                if (i == 0) {
-                    renderer.a1 = cycle;
-                    renderer.a2 = cycle;
-                } else {
-                    renderer.a1 = 1.0f - cycle;
-                    renderer.a2 = 1.0f - cycle;
-                }
+                renderer.setColorLineA(i == 0 ? cycle : 1.0f - cycle);
 
                 switch (arrowTex) {
                     case TextureLoader.ARROW_UP:
-                        renderer.drawLine(x + 0.25f, -(y + 0.75f - arrOffset), x + 0.5f, -(y + 0.25f - arrOffset));
-                        renderer.drawLine(x + 0.5f, -(y + 0.25f - arrOffset), x + 0.75f, -(y + 0.75f - arrOffset));
+                        renderer.batchLine(x + 0.25f, -(y + 0.75f - arrOffset), x + 0.5f, -(y + 0.25f - arrOffset));
+                        renderer.batchLine(x + 0.5f, -(y + 0.25f - arrOffset), x + 0.75f, -(y + 0.75f - arrOffset));
                         break;
 
                     case TextureLoader.ARROW_RT:
-                        renderer.drawLine(x + 0.25f + arrOffset, -(y + 0.75f), x + 0.75f + arrOffset, -(y + 0.5f));
-                        renderer.drawLine(x + 0.75f + arrOffset, -(y + 0.5f), x + 0.25f + arrOffset, -(y + 0.25f));
+                        renderer.batchLine(x + 0.25f + arrOffset, -(y + 0.75f), x + 0.75f + arrOffset, -(y + 0.5f));
+                        renderer.batchLine(x + 0.75f + arrOffset, -(y + 0.5f), x + 0.25f + arrOffset, -(y + 0.25f));
                         break;
 
                     case TextureLoader.ARROW_DN:
-                        renderer.drawLine(x + 0.25f, -(y + 0.25f + arrOffset), x + 0.5f, -(y + 0.75f + arrOffset));
-                        renderer.drawLine(x + 0.5f, -(y + 0.75f + arrOffset), x + 0.75f, -(y + 0.25f + arrOffset));
+                        renderer.batchLine(x + 0.25f, -(y + 0.25f + arrOffset), x + 0.5f, -(y + 0.75f + arrOffset));
+                        renderer.batchLine(x + 0.5f, -(y + 0.75f + arrOffset), x + 0.75f, -(y + 0.25f + arrOffset));
                         break;
 
                     case TextureLoader.ARROW_LT:
-                        renderer.drawLine(x + 0.75f - arrOffset, -(y + 0.75f), x + 0.25f - arrOffset, -(y + 0.5f));
-                        renderer.drawLine(x + 0.25f - arrOffset, -(y + 0.5f), x + 0.75f - arrOffset, -(y + 0.25f));
+                        renderer.batchLine(x + 0.75f - arrOffset, -(y + 0.75f), x + 0.25f - arrOffset, -(y + 0.5f));
+                        renderer.batchLine(x + 0.25f - arrOffset, -(y + 0.5f), x + 0.75f - arrOffset, -(y + 0.25f));
                         break;
                 }
 
@@ -246,10 +191,9 @@ public class AutoMap implements EngineObject {
             }
         }
 
-        renderer.a1 = 1.0f;
-        renderer.a2 = 1.0f;
+        renderer.setColorQuadRGBA(1.0f, 1.0f, 1.0f, 1.0f);
 
-        for (AutoMapPathCell pc = level.autoMapPathCells.first(); pc != null; pc = (AutoMapPathCell)pc.next) {
+        for (AutoMapPathCell pc = level.autoMapPathCells.first(); pc != null; pc = pc.next) {
             if (!localAwTouchedCellsMap[pc.y][pc.x]) {
                 continue;
             }
@@ -263,24 +207,23 @@ public class AutoMap implements EngineObject {
             }
         }
 
-        renderer.a1 = 0.5f;
-        renderer.a2 = 0.5f;
+        renderer.setColorLineA(0.5f);
 
-        for (TouchedCell tc = state.awTouchedCells.first(); tc != null; tc = (TouchedCell)tc.next) {
-            if ((localPassableMap[tc.y][tc.x] & Level.PASSABLE_IS_DECOR_ITEM) == 0) {
+        for (TouchedCell tc = state.awTouchedCells.first(); tc != null; tc = tc.next) {
+            if ((localPassableMap[tc.y][tc.x] & Level.PASSABLE_MASK_AUTOMAP_ITEM) == 0) {
                 continue;
             }
 
             float x = (float)tc.x + 0.25f;
             float y = (float)tc.y + 0.25f;
 
-            renderer.drawLine(x, -y, x + 0.5f, -y);
-            renderer.drawLine(x + 0.5f, -y, x + 0.5f, -(y + 0.5f));
-            renderer.drawLine(x + 0.5f, -(y + 0.5f), x, -(y + 0.5f));
-            renderer.drawLine(x, -(y + 0.5f), x, -y);
+            renderer.batchLine(x, -y, x + 0.5f, -y);
+            renderer.batchLine(x + 0.5f, -y, x + 0.5f, -(y + 0.5f));
+            renderer.batchLine(x + 0.5f, -(y + 0.5f), x, -(y + 0.5f));
+            renderer.batchLine(x, -(y + 0.5f), x, -y);
         }
 
-        for (TouchedCell tc = state.awTouchedCells.first(); tc != null; tc = (TouchedCell)tc.next) {
+        for (TouchedCell tc = state.awTouchedCells.first(); tc != null; tc = tc.next) {
             if ((localPassableMap[tc.y][tc.x] & Level.PASSABLE_IS_OBJECT) == 0) {
                 continue;
             }
@@ -288,156 +231,136 @@ public class AutoMap implements EngineObject {
             float x = (float)tc.x;
             float y = (float)tc.y;
 
-            renderer.drawLine(x + 0.5f, -(y + 0.25f), x + 0.75f, -(y + 0.5f));
-            renderer.drawLine(x + 0.75f, -(y + 0.5f), x + 0.5f, -(y + 0.75f));
-            renderer.drawLine(x + 0.5f, -(y + 0.75f), x + 0.25f, -(y + 0.5f));
-            renderer.drawLine(x + 0.25f, -(y + 0.5f), x + 0.5f, -(y + 0.25f));
+            renderer.batchLine(x + 0.5f, -(y + 0.25f), x + 0.75f, -(y + 0.5f));
+            renderer.batchLine(x + 0.75f, -(y + 0.5f), x + 0.5f, -(y + 0.75f));
+            renderer.batchLine(x + 0.5f, -(y + 0.75f), x + 0.25f, -(y + 0.5f));
+            renderer.batchLine(x + 0.25f, -(y + 0.5f), x + 0.5f, -(y + 0.25f));
         }
 
-        if (levelRenderer.debugOnAutomap) {
-            renderer.g1 = 0.0f;
-            renderer.g2 = 0.0f;
+        renderer.setColorQuadRGBA(1.0f, 0.0f, 0.0f, 0.5f);
+
+        for (Monster mon = state.monsters.first(); mon != null; mon = mon.next) {
+            if (mon.health <= 0) {
+                continue;
+            }
+
+            float dx = mon.x - currentHeroX;
+            float dy = mon.y - currentHeroY;
+            float dist = Math.max(GameMath.EPSILON, (float)Math.sqrt(dx * dx + dy * dy));
+
+            drawPoint(currentHeroX + (dx / dist) * AUTOMAP_EDGE_MULT, currentHeroY + (dy / dist) * AUTOMAP_EDGE_MULT);
+        }
 
-            renderer.a1 = 1.0f;
-            renderer.a2 = 1.0f;
+        if (levelRenderer.debugOnAutomap) {
+            renderer.setColorLineA(1.0f);
 
-            for (Monster mon = state.monsters.first(); mon != null; mon = (Monster)mon.next) {
+            for (Monster mon = state.monsters.first(); mon != null; mon = mon.next) {
                 if (mon.health <= 0) {
-                    renderer.r1 = 0.5f;
-                    renderer.b1 = 0.5f;
-                    renderer.r2 = 0.5f;
-                    renderer.b2 = 0.5f;
+                    renderer.setColorLineRGB(0.5f, 0.0f, 0.5f);
                 } else if (mon.chaseMode) {
-                    renderer.r1 = 1.0f;
-                    renderer.b1 = 0.0f;
-                    renderer.r2 = 1.0f;
-                    renderer.b2 = 0.0f;
+                    renderer.setColorLineRGB(1.0f, 0.0f, 0.0f);
                 } else {
-                    renderer.r1 = 0.0f;
-                    renderer.b1 = 1.0f;
-                    renderer.r2 = 0.0f;
-                    renderer.b2 = 1.0f;
+                    renderer.setColorLineRGB(0.0f, 0.0f, 1.0f);
                 }
 
                 float mdx = (float)Math.cos((float)mon.shootAngle * GameMath.G2RAD_F) * 0.75f;
                 float mdy = (float)Math.sin((float)mon.shootAngle * GameMath.G2RAD_F) * 0.75f;
 
-                renderer.drawLine(mon.x, -mon.y, mon.x + mdx, -mon.y + mdy);
+                renderer.batchLine(mon.x, -mon.y, mon.x + mdx, -mon.y + mdy);
 
                 mdx *= 0.25;
                 mdy *= 0.25;
 
-                renderer.drawLine(mon.x + mdy, -mon.y - mdx, mon.x - mdy, -mon.y + mdx);
+                renderer.batchLine(mon.x + mdy, -mon.y - mdx, mon.x - mdy, -mon.y + mdx);
             }
 
-            renderer.r1 = 1.0f;
-            renderer.b1 = 0.5f;
-            renderer.r2 = 1.0f;
-            renderer.b2 = 0.5f;
+            renderer.setColorLineRGB(1.0f, 0.0f, 0.5f);
 
-            for (Bullet bullet = state.bullets.first(); bullet != null; bullet = (Bullet)bullet.next) {
+            for (Bullet bullet = state.bullets.first(); bullet != null; bullet = bullet.next) {
                 float x = bullet.x;
                 float y = bullet.y;
 
-                renderer.drawLine(x, -(y - 0.125f), x + 0.125f, -y);
-                renderer.drawLine(x + 0.125f, -y, x, -(y + 0.125f));
-                renderer.drawLine(x, -(y + 0.125f), x - 0.125f, -y);
-                renderer.drawLine(x - 0.125f, -y, x, -(y - 0.125f));
+                renderer.batchLine(x, -(y - 0.125f), x + 0.125f, -y);
+                renderer.batchLine(x + 0.125f, -y, x, -(y + 0.125f));
+                renderer.batchLine(x, -(y + 0.125f), x - 0.125f, -y);
+                renderer.batchLine(x - 0.125f, -y, x, -(y - 0.125f));
             }
 
-            renderer.g1 = 0.5f;
-            renderer.g2 = 0.5f;
+            renderer.setColorLineRGB(1.0f, 0.5f, 0.5f);
 
             for (Explosion explosion = state.explosions.first();
                     explosion != null;
-                    explosion = (Explosion)explosion.next) {
+                    explosion = explosion.next) {
 
                 float x = explosion.x;
                 float y = explosion.y;
 
-                renderer.drawLine(x, -(y - 0.125f), x + 0.125f, -y);
-                renderer.drawLine(x + 0.125f, -y, x, -(y + 0.125f));
-                renderer.drawLine(x, -(y + 0.125f), x - 0.125f, -y);
-                renderer.drawLine(x - 0.125f, -y, x, -(y - 0.125f));
+                renderer.batchLine(x, -(y - 0.125f), x + 0.125f, -y);
+                renderer.batchLine(x + 0.125f, -y, x, -(y + 0.125f));
+                renderer.batchLine(x, -(y + 0.125f), x - 0.125f, -y);
+                renderer.batchLine(x - 0.125f, -y, x, -(y - 0.125f));
             }
 
-            for (TraceInfo traceInfo = levelRenderer.tracesInfo.first(); traceInfo != null; ) {
-                TraceInfo nextTraceInfo = (TraceInfo)traceInfo.next;
+            for (DebugTraceInfo traceInfo = levelRenderer.debugTraceInfos.first(); traceInfo != null; ) {
+                DebugTraceInfo nextTraceInfo = traceInfo.next;
 
                 if (traceInfo.hit == Bullet.HitParams.HIT_OUT) {
-                    renderer.setLineRGB(0.0f, 1.0f, 0.0f);
+                    renderer.setColorLineRGB(0.0f, 1.0f, 0.0f);
                 } else if (traceInfo.hit == Bullet.HitParams.HIT_WALL) {
-                    renderer.setLineRGB(0.5f, 0.5f, 0.5f);
+                    renderer.setColorLineRGB(0.5f, 0.5f, 0.5f);
                 } else if (traceInfo.hit == Bullet.HitParams.HIT_MONSTER) {
-                    renderer.setLineRGB(0.0f, 1.0f, 0.0f);
+                    renderer.setColorLineRGB(0.0f, 1.0f, 0.0f);
                 } else if (traceInfo.hit == Bullet.HitParams.HIT_HERO) {
-                    renderer.setLineRGB(1.0f, 0.0f, 0.0f);
+                    renderer.setColorLineRGB(1.0f, 0.0f, 0.0f);
                 } else {
-                    renderer.setLineRGB(0.0f, 0.0f, 1.0f);
+                    renderer.setColorLineRGB(0.0f, 0.0f, 1.0f);
                 }
 
-                renderer.drawLine(traceInfo.sx, -traceInfo.sy, traceInfo.ex, -traceInfo.ey);
+                renderer.batchLine(traceInfo.sx, -traceInfo.sy, traceInfo.ex, -traceInfo.ey);
                 traceInfo.ticks++;
 
                 if (traceInfo.ticks > 10) {
-                    levelRenderer.tracesInfo.release(traceInfo);
+                    levelRenderer.debugTraceInfos.release(traceInfo);
                 }
 
                 //noinspection AssignmentToForLoopParameter
                 traceInfo = nextTraceInfo;
             }
 
-            renderer.r1 = 1.0f;
-            renderer.r2 = 1.0f;
-            renderer.g1 = 1.0f;
-            renderer.g2 = 1.0f;
-            renderer.b1 = 0.0f;
-            renderer.b2 = 0.0f;
-            renderer.a1 = 1.0f;
-            renderer.a2 = 1.0f;
+            renderer.setColorLineRGBA(1.0f, 1.0f, 0.0f, 1.0f);
 
             for (int i = 0, len = levelRenderer.tracer.wallsCount; i < len; i++) {
                 PortalTracer.Wall wall = levelRenderer.tracer.walls[i];
-                renderer.drawLine((float)wall.fromX, -(float)wall.fromY, (float)wall.toX, -(float)wall.toY);
+                renderer.batchLine((float)wall.fromX, -(float)wall.fromY, (float)wall.toX, -(float)wall.toY);
             }
         }
 
-        renderer.flush(gl, false);
+        renderer.pushModelviewMatrix();
+        renderer.gl.glRotatef(90.0f - levelRenderer.currentHeroA, 0.0f, 0.0f, 1.0f);
+        renderer.gl.glTranslatef(-currentHeroX, currentHeroY, 0.0f);
+        renderer.renderBatch(Renderer.FLAG_BLEND | Renderer.FLAG_STENCIL_KEEP);
+        renderer.popModelviewMatrix();
 
-        gl.glPopMatrix(); // pop model matrix
-        gl.glTranslatef(autoMapOffX, autoMapOffY, 0.0f);
-        renderer.init();
+        // ----
+
+        renderer.startBatch();
 
         final float hw = 0.4f;
         final float hh = 0.5f;
 
-        renderer.r1 = 1.0f;
-        renderer.r2 = 1.0f;
-        renderer.g1 = 1.0f;
-        renderer.g2 = 1.0f;
-        renderer.b1 = 1.0f;
-        renderer.b2 = 1.0f;
-        renderer.a1 = 1.0f;
-        renderer.a2 = 1.0f;
-
-        renderer.drawLine(-hw, -hh, 0.0f, hh);
-        renderer.drawLine(0.0f, hh, hw, -hh);
-        renderer.drawLine(-hw, -hh, hw, -hh);
-
-        renderer.flush(gl, false);
-
-        gl.glDisable(GL10.GL_STENCIL_TEST);
-        gl.glDisable(GL10.GL_BLEND);
-        gl.glMatrixMode(GL10.GL_PROJECTION);
-        gl.glPopMatrix();
+        renderer.setColorLineRGBA(1.0f, 1.0f, 1.0f, 1.0f);
+
+        renderer.batchLine(-hw, -hh, 0.0f, hh);
+        renderer.batchLine(0.0f, hh, hw, -hh);
+        renderer.batchLine(-hw, -hh, hw, -hh);
+
+        renderer.renderBatch(Renderer.FLAG_BLEND | Renderer.FLAG_STENCIL_KEEP);
     }
 
     @SuppressWarnings("MagicNumber")
     private void drawPoint(float x, float y) {
-        renderer.drawLine(x - 0.05f, -(y - 0.05f), x + 0.05f, -(y - 0.05f));
-        renderer.drawLine(x + 0.05f, -(y - 0.05f), x + 0.05f, -(y + 0.05f));
-        renderer.drawLine(x + 0.05f, -(y + 0.05f), x - 0.05f, -(y + 0.05f));
-        renderer.drawLine(x - 0.05f, -(y + 0.05f), x - 0.05f, -(y - 0.05f));
+        renderer.setCoordsQuadRectFlat(x - 0.15f, -(y - 0.15f), x + 0.15f, -(y + 0.15f));
+        renderer.batchQuad();
     }
 
     /*
@@ -620,7 +543,7 @@ public class AutoMap implements EngineObject {
     }
 
     @SuppressWarnings("MagicNumber")
-    public void renderHelp(GL10 gl, Controls controls) {
+    void renderHelp(Controls controls) {
         if ((state.disabledControlsMask & Controls.CONTROL_MINIMAP) != 0
                 || (state.controlsHelpMask & Controls.CONTROL_MINIMAP) == 0) {
 
@@ -629,8 +552,7 @@ public class AutoMap implements EngineObject {
 
         float xOff = (float)engine.width / engine.ratio * (AUTOMAP_VIEW_OFFSET + AUTOMAP_VIEW_SIZE) * 0.5f;
 
-        controls.drawHelpArrowWithText(gl,
-                (engine.config.leftHandAim ? xOff : (float)engine.width - xOff),
+        controls.renderHelpArrowWithText((engine.config.leftHandAim ? xOff : (float)engine.width - xOff),
                 (float)engine.height * (AUTOMAP_VIEW_OFFSET + AUTOMAP_VIEW_SIZE) * 0.5f,
                 Controls.DIAG_SIZE_LG,
                 engine.config.leftHandAim,
@@ -640,6 +562,10 @@ public class AutoMap implements EngineObject {
 
     @SuppressWarnings("ConstantConditions")
     public void updatePathTo() {
+        if (level.buildPathToWavePending) {
+            return;
+        }
+
         level.autoMapPathCells.clear();
 
         if (state.pathToX < 0 || state.pathToY < 0) {
diff --git a/src/main/java/zame/game/engine/controls/Controls.java b/src/main/java/zame/game/engine/visual/Controls.java
similarity index 64%
rename from src/main/java/zame/game/engine/controls/Controls.java
rename to src/main/java/zame/game/engine/visual/Controls.java
index b692dac..228652c 100644
--- a/src/main/java/zame/game/engine/controls/Controls.java
+++ b/src/main/java/zame/game/engine/visual/Controls.java
@@ -1,17 +1,20 @@
-package zame.game.engine.controls;
+package zame.game.engine.visual;
 
 import android.view.MotionEvent;
-import javax.microedition.khronos.opengles.GL10;
 import zame.game.App;
-import zame.game.Common;
+import zame.game.core.util.Common;
 import zame.game.engine.Config;
 import zame.game.engine.Engine;
 import zame.game.engine.EngineObject;
 import zame.game.engine.Game;
-import zame.game.engine.Labels;
-import zame.game.engine.Renderer;
-import zame.game.engine.State;
-import zame.game.engine.TextureLoader;
+import zame.game.engine.controls.OnScreenButton;
+import zame.game.engine.controls.OnScreenController;
+import zame.game.engine.controls.OnScreenFireAndRotate;
+import zame.game.engine.controls.OnScreenPad;
+import zame.game.engine.controls.OnScreenQuickWeapons;
+import zame.game.engine.graphics.Labels;
+import zame.game.engine.graphics.Renderer;
+import zame.game.engine.state.State;
 
 public class Controls implements EngineObject {
     public static final int CONTROL_MOVE = 1;
@@ -19,11 +22,11 @@ public class Controls implements EngineObject {
     public static final int CONTROL_FIRE = 4;
     public static final int CONTROL_WEAPONS = 8;
     public static final int CONTROL_QUICK_WEAPONS = 16;
-    public static final int CONTROL_MINIMAP = 32;
-    public static final int CONTROL_STATS_HEALTH = 64;
-    public static final int CONTROL_STATS_AMMO = 128;
-    public static final int CONTROL_STATS_ARMOR = 256;
-    public static final int CONTROL_STATS_KEYS = 512;
+    static final int CONTROL_MINIMAP = 32;
+    static final int CONTROL_STATS_HEALTH = 64;
+    static final int CONTROL_STATS_AMMO = 128;
+    static final int CONTROL_STATS_ARMOR = 256;
+    static final int CONTROL_STATS_KEYS = 512;
     public static final int CONTROL_MOVE_UP = 1024;
     public static final int CONTROL_MOVE_DOWN = 2048;
     public static final int CONTROL_MOVE_LEFT = 4096;
@@ -42,17 +45,16 @@ public class Controls implements EngineObject {
     public static final int NEXT_WEAPON = 32;
     public static final int ROTATE_LEFT = 64;
     public static final int ROTATE_RIGHT = 128;
-    // public static final int TOGGLE_MAP = 256;
-    public static final int STRAFE_MODE = 512;
-    @SuppressWarnings("WeakerAccess") public static final int MASK_MAX = 1024;
+    public static final int STRAFE_MODE = 256;
+    public static final int MASK_MAX = 512;
 
-    @SuppressWarnings("WeakerAccess") static final int POSITION_LEFT = 1;
-    @SuppressWarnings("WeakerAccess") static final int POSITION_HCENTER = 2;
-    static final int POSITION_RIGHT = 4;
-    static final int POSITION_TOP = 8;
+    private static final int POSITION_LEFT = 1;
+    public static final int POSITION_HCENTER = 2;
+    public static final int POSITION_RIGHT = 4;
+    public static final int POSITION_TOP = 8;
 
-    static final int ACTION_FIRE_ONSCREEN = 1;
-    static final int ACTION_FIRE_KEYS = 2;
+    public static final int ACTION_FIRE_ONSCREEN = 1;
+    public static final int ACTION_FIRE_KEYS = 2;
 
     private static final int POINTER_ACTION_DOWN = 1;
     private static final int POINTER_ACTION_MOVE = 2;
@@ -61,7 +63,7 @@ public class Controls implements EngineObject {
 
     public static final float DIAG_SIZE = 0.075f;
     public static final float DIAG_SIZE_LG = 0.1f;
-    public static final float DIAG_SIZE_XLG = 0.2f;
+    static final float DIAG_SIZE_XLG = 0.2f;
     public static final float DIAG_SIZE_XXLG = 0.4f;
     private static final float ARROW_F_SIZE = 0.075f;
     private static final float ARROW_N_SIZE = ARROW_F_SIZE * 0.75f;
@@ -71,7 +73,6 @@ public class Controls implements EngineObject {
     private Engine engine;
     private Renderer renderer;
     private Config config;
-    private TextureLoader textureLoader;
     private Game game;
     private Labels labels;
     private State state;
@@ -83,23 +84,26 @@ public class Controls implements EngineObject {
     private OnScreenQuickWeapons schemeQuickWeapons = new OnScreenQuickWeapons(POSITION_HCENTER | POSITION_TOP);
     private OnScreenPad schemePad = new OnScreenPad(POSITION_LEFT, false);
     private OnScreenFireAndRotate schemeFireAndRotate = new OnScreenFireAndRotate(POSITION_RIGHT);
-    private OnScreenUpgradeButton schemeUpgradeButton = new OnScreenUpgradeButton(POSITION_LEFT);
+    private OnScreenButton schemeRestartButton = new OnScreenButton(POSITION_LEFT, OnScreenButton.TYPE_RESTART);
+
+    private OnScreenButton schemeContinueButton = new OnScreenButton(POSITION_RIGHT,
+            OnScreenButton.TYPE_REWARDED_CONTINUE);
 
-    // "schemeFireAndRotate" must be last
     private OnScreenController[] scheme = { schemeMenuButton,
             schemeQuickWeapons,
             schemePad,
-            schemeUpgradeButton,
-            schemeFireAndRotate };
+            schemeFireAndRotate, // must be after all game controls
+            schemeRestartButton, // must be after fireAndRotate
+            schemeContinueButton, // must be after fireAndRotate
+    };
 
-    float iconSize;
+    public float iconSize;
 
     @Override
-    public void setEngine(Engine engine) {
+    public void onCreate(Engine engine) {
         this.engine = engine;
         this.renderer = engine.renderer;
         this.config = engine.config;
-        this.textureLoader = engine.textureLoader;
         this.game = engine.game;
         this.labels = engine.labels;
         this.state = engine.state;
@@ -111,11 +115,17 @@ public class Controls implements EngineObject {
         schemePad.position = (config.leftHandAim ? POSITION_RIGHT : POSITION_LEFT);
         schemePad.dynamic = (config.controlScheme == SCHEME_FREE_MOVE_PAD);
 
-        schemeFireAndRotate.position = (config.leftHandAim ? POSITION_LEFT : POSITION_RIGHT) | (config.fireButtonAtTop
-                ? POSITION_TOP
-                : 0);
+        schemeFireAndRotate.position = (config.leftHandAim ? POSITION_LEFT : POSITION_RIGHT)
+                | (config.fireButtonAtTop ? POSITION_TOP : 0);
 
-        schemeUpgradeButton.position = (config.leftHandAim ? POSITION_RIGHT : POSITION_LEFT);
+        if (engine.canShowRewardedVideo) {
+            schemeRestartButton.position = (config.leftHandAim ? POSITION_RIGHT : POSITION_LEFT);
+            schemeContinueButton.position = (config.leftHandAim ? POSITION_LEFT : POSITION_RIGHT);
+            schemeContinueButton.isVisible = true;
+        } else {
+            schemeRestartButton.position = POSITION_HCENTER;
+            schemeContinueButton.isVisible = false;
+        }
 
         for (OnScreenController controller : scheme) {
             controller.setOwner(this, engine);
@@ -239,133 +249,78 @@ public class Controls implements EngineObject {
         }
     }
 
-    void drawIcon(float pointerX, float pointerY, int texNum, boolean pressed) {
-        drawIcon(pointerX, pointerY, texNum, pressed, -1.0f, 1.0f);
+    public void batchIcon(float pointerX, float pointerY, int texNum, boolean pressed) {
+        batchIcon(pointerX, pointerY, texNum, pressed, -1.0f, 1.0f);
     }
 
-    void drawIcon(float pointerX,
+    public void batchIcon(float pointerX,
             float pointerY,
             int texNum,
             @SuppressWarnings("SameParameterValue") boolean pressed,
             float customAlpha) {
 
-        drawIcon(pointerX, pointerY, texNum, pressed, customAlpha, 1.0f);
+        batchIcon(pointerX, pointerY, texNum, pressed, customAlpha, 1.0f);
     }
 
     @SuppressWarnings("MagicNumber")
-    void drawIcon(float pointerX, float pointerY, int texNum, boolean pressed, float customAlpha, float customScale) {
+    public void batchIcon(float pointerX,
+            float pointerY,
+            int texNum,
+            boolean pressed,
+            float customAlpha,
+            float customScale) {
+
         float screenX = pointerX / (float)engine.width * engine.ratio;
         float screenY = 1.0f - pointerY / (float)engine.height;
 
         float sx = screenX - 0.125f * App.self.controlsScale * customScale;
         float sy = screenY - 0.125f * App.self.controlsScale * customScale;
-        float ex = sx + 0.25f * App.self.controlsScale * customScale;
-        float ey = sy + 0.25f * App.self.controlsScale * customScale;
 
-        renderer.x1 = sx;
-        renderer.y1 = sy;
-        renderer.x2 = sx;
-        renderer.y2 = ey;
-        renderer.x3 = ex;
-        renderer.y3 = ey;
-        renderer.x4 = ex;
-        renderer.y4 = sy;
+        renderer.setCoordsQuadRect(sx,
+                sy,
+                sx + 0.25f * App.self.controlsScale * customScale,
+                sy + 0.25f * App.self.controlsScale * customScale);
 
         if (customAlpha >= 0.0f) {
-            renderer.a1 = customAlpha;
+            renderer.setColorQuadA(customAlpha);
         } else if (pressed) {
-            renderer.a1 = 1.0f;
+            renderer.setColorQuadA(1.0f);
         } else {
-            renderer.a1 = config.controlsAlpha;
+            renderer.setColorQuadA(config.controlsAlpha);
         }
 
-        renderer.a2 = renderer.a1;
-        renderer.a3 = renderer.a1;
-        renderer.a4 = renderer.a1;
-
-        renderer.drawQuad(texNum);
+        renderer.batchTexQuad(texNum);
     }
 
-    void drawBack(float pointerX, float pointerY, int texNum, boolean pressed) {
-        drawBack(pointerX, pointerY, texNum, pressed, -1.0f);
+    public void batchBack(float pointerX, float pointerY, int texNum, boolean pressed) {
+        batchBack(pointerX, pointerY, texNum, pressed, -1.0f, 1.0f);
     }
 
     @SuppressWarnings("MagicNumber")
-    private void drawBack(float pointerX, float pointerY, int texNum, boolean pressed, float customAlpha) {
+    public void batchBack(float pointerX, float pointerY, int texNum, boolean pressed, float alpha, float scale) {
         float screenX = pointerX / (float)engine.width * engine.ratio;
         float screenY = 1.0f - pointerY / (float)engine.height;
 
-        float sx = screenX - 0.25f * App.self.controlsScale;
-        float sy = screenY - 0.25f * App.self.controlsScale;
-        float ex = sx + 0.5f * App.self.controlsScale;
-        float ey = sy + 0.5f * App.self.controlsScale;
+        float sx = screenX - 0.25f * App.self.controlsScale * scale;
+        float sy = screenY - 0.25f * App.self.controlsScale * scale;
 
-        renderer.x1 = sx;
-        renderer.y1 = sy;
-        renderer.x2 = sx;
-        renderer.y2 = ey;
-        renderer.x3 = ex;
-        renderer.y3 = ey;
-        renderer.x4 = ex;
-        renderer.y4 = sy;
+        renderer.setCoordsQuadRect(sx,
+                sy,
+                sx + 0.5f * App.self.controlsScale * scale,
+                sy + 0.5f * App.self.controlsScale * scale);
 
-        if (customAlpha >= 0.0f) {
-            renderer.a1 = customAlpha;
+        if (alpha >= 0.0f) {
+            renderer.setColorQuadA(alpha);
         } else if (pressed) {
-            renderer.a1 = 1.0f;
-        } else {
-            renderer.a1 = config.controlsAlpha;
-        }
-
-        renderer.a2 = renderer.a1;
-        renderer.a3 = renderer.a1;
-        renderer.a4 = renderer.a1;
-
-        renderer.drawQuad2x(texNum);
-    }
-
-    @SuppressWarnings("MagicNumber")
-    void drawBtn(float pointerX,
-            float pointerY,
-            int texNum,
-            boolean pressed,
-            @SuppressWarnings("SameParameterValue") boolean highlighted,
-            long elapsedTime) {
-
-        float screenX = pointerX / (float)engine.width * engine.ratio;
-        float screenY = 1.0f - pointerY / (float)engine.height;
-
-        float sx = screenX - 0.5f * App.self.controlsScale;
-        float sy = screenY - 0.125f * App.self.controlsScale;
-        float ex = sx + 1.0f * App.self.controlsScale;
-        float ey = sy + 0.25f * App.self.controlsScale;
-
-        renderer.x1 = sx;
-        renderer.y1 = sy;
-        renderer.x2 = sx;
-        renderer.y2 = ey;
-        renderer.x3 = ex;
-        renderer.y3 = ey;
-        renderer.x4 = ex;
-        renderer.y4 = sy;
-
-        if (pressed) {
-            renderer.a1 = 1.0f;
-        } else if (highlighted) {
-            renderer.a1 = (float)Math.sin((float)elapsedTime * 0.01f) * 0.25f + 0.75f;
+            renderer.setColorQuadA(1.0f);
         } else {
-            renderer.a1 = config.controlsAlpha;
+            renderer.setColorQuadA(config.controlsAlpha);
         }
 
-        renderer.a2 = renderer.a1;
-        renderer.a3 = renderer.a1;
-        renderer.a4 = renderer.a1;
-
-        renderer.drawQuad4x1x(texNum);
+        renderer.batchTexQuad2x(texNum);
     }
 
-    public void drawArrow(@SuppressWarnings("unused") GL10 gl,
-            float sx,
+    public void batchArrow(float sx,
             float sy,
             float ex,
             float ey,
@@ -390,7 +345,7 @@ public class Controls implements EngineObject {
         renderer.y3 = sy;
         renderer.x4 = sx + mx * ARROW_F_SIZE + nx * ARROW_F_WEIGHT;
         renderer.y4 = sy + my * ARROW_F_SIZE + ny * ARROW_F_WEIGHT;
-        renderer.drawQuad();
+        renderer.batchQuad();
 
         renderer.x1 = sx;
         renderer.y1 = sy;
@@ -400,7 +355,7 @@ public class Controls implements EngineObject {
         renderer.y3 = sy + my * ARROW_N_SIZE - ny * LINE_WEIGHT;
         renderer.x4 = sx + mx * ARROW_F_SIZE - nx * ARROW_F_WEIGHT;
         renderer.y4 = sy + my * ARROW_F_SIZE - ny * ARROW_F_WEIGHT;
-        renderer.drawQuad();
+        renderer.batchQuad();
 
         renderer.x1 = ex + nx * LINE_WEIGHT;
         renderer.y1 = ey + ny * LINE_WEIGHT;
@@ -410,7 +365,7 @@ public class Controls implements EngineObject {
         renderer.y3 = sy + my * ARROW_N_SIZE - ny * LINE_WEIGHT;
         renderer.x4 = sx + mx * ARROW_N_SIZE + nx * LINE_WEIGHT;
         renderer.y4 = sy + my * ARROW_N_SIZE + ny * LINE_WEIGHT;
-        renderer.drawQuad();
+        renderer.batchQuad();
 
         if (drawLastSegment) {
             renderer.x1 = ex + hor;
@@ -421,12 +376,12 @@ public class Controls implements EngineObject {
             renderer.y3 = ey - ny * LINE_WEIGHT;
             renderer.x4 = ex + nx * LINE_WEIGHT;
             renderer.y4 = ey + ny * LINE_WEIGHT;
-            renderer.drawQuad();
+            renderer.batchQuad();
         }
     }
 
-    private void subRenderControls(GL10 gl, long elapsedTime, boolean canRenderHelp) {
-        renderer.init();
+    private void subRenderControls(long elapsedTime, boolean canRenderHelp) {
+        renderer.startBatch();
 
         //noinspection ForLoopReplaceableByForEach
         for (int i = 0, len = scheme.length; i < len; i++) {
@@ -437,17 +392,15 @@ public class Controls implements EngineObject {
                     || (state.disabledControlsMask & controller.controlFlags) != controller.controlFlags)
                     && (controller.renderModeMask & game.renderMode) != 0) {
 
-                controller.render(gl, elapsedTime, canRenderHelp);
+                controller.render(elapsedTime, canRenderHelp);
             }
         }
 
-        renderer.bindTextureCtl(gl, textureLoader.textures[TextureLoader.TEXTURE_MAIN]);
-        renderer.flush(gl);
+        renderer.renderBatch(Renderer.FLAG_BLEND, Renderer.TEXTURE_MAIN);
     }
 
     @SuppressWarnings("MagicNumber")
-    public void drawHelpArrowWithText(GL10 gl,
-            float displayX,
+    public void renderHelpArrowWithText(float displayX,
             float displayY,
             float diagSize,
             boolean posLeft,
@@ -463,82 +416,69 @@ public class Controls implements EngineObject {
         float ey = sy + (posBottom ? diagSize : -diagSize);
         float hor = (posLeft ? horSize : -horSize);
 
-        renderer.init();
-        renderer.setQuadA(0.5f);
-
-        drawArrow(gl, sx, sy, ex, ey, hor, true);
-        renderer.flush(gl, false);
+        renderer.startBatch();
+        renderer.setColorQuadA(0.5f);
+        batchArrow(sx, sy, ex, ey, hor, true);
+        renderer.renderBatch(Renderer.FLAG_BLEND);
 
-        labels.beginDrawing(gl, true);
-        renderer.setQuadA(1.0f);
+        labels.startBatch(true);
+        renderer.setColorQuadA(1.0f);
 
         if (posLeft) {
             if (posBottom) {
-                labels.draw(gl, ex, ey + 0.01f, ex + engine.ratio * 0.4f, ey + 0.06f, helpText, 0.04f, Labels.ALIGN_CL);
+                labels.batch(ex, ey + 0.01f, ex + engine.ratio * 0.4f, ey + 0.06f, helpText, 0.04f, Labels.ALIGN_CL);
             } else {
-                labels.draw(gl, ex, ey - 0.05f, ex + engine.ratio * 0.4f, ey, helpText, 0.04f, Labels.ALIGN_CL);
+                labels.batch(ex, ey - 0.05f, ex + engine.ratio * 0.4f, ey, helpText, 0.04f, Labels.ALIGN_CL);
             }
         } else {
             if (posBottom) {
-                labels.draw(gl, ex - engine.ratio * 0.4f, ey + 0.01f, ex, ey + 0.06f, helpText, 0.04f, Labels.ALIGN_CR);
+                labels.batch(ex - engine.ratio * 0.4f, ey + 0.01f, ex, ey + 0.06f, helpText, 0.04f, Labels.ALIGN_CR);
             } else {
-                labels.draw(gl, ex - engine.ratio * 0.4f, ey - 0.05f, ex, ey, helpText, 0.04f, Labels.ALIGN_CR);
+                labels.batch(ex - engine.ratio * 0.4f, ey - 0.05f, ex, ey, helpText, 0.04f, Labels.ALIGN_CR);
             }
         }
 
-        labels.endDrawing(gl, true);
+        labels.renderBatch();
     }
 
-    private void subRenderBlackOverlay(GL10 gl, long elapsedTime, long firstTouchTime) {
+    private void subRenderBlackOverlay(long elapsedTime, long firstTouchTime) {
         //noinspection MagicNumber
         float op = 0.5f - (float)(elapsedTime - firstTouchTime) / 500.0f;
 
         if (op > 0.0f) {
-            renderer.init();
-            renderer.setQuadRGBA(0.0f, 0.0f, 0.0f, op);
-            renderer.setQuadOrthoCoords(0.0f, 0.0f, engine.ratio, 1.0f);
-            renderer.drawQuad();
-            renderer.flush(gl, false);
+            renderer.startBatch();
+            renderer.setColorQuadRGBA(0.0f, 0.0f, 0.0f, op);
+            renderer.setCoordsQuadRectFlat(0.0f, 0.0f, engine.ratio, 1.0f);
+            renderer.batchQuad();
+            renderer.renderBatch(Renderer.FLAG_BLEND);
         }
     }
 
     @SuppressWarnings("MagicNumber")
-    private void subRenderHelp(GL10 gl, long elapsedTime) {
+    private void subRenderHelp(long elapsedTime) {
         //noinspection ForLoopReplaceableByForEach
         for (int i = 0, len = scheme.length; i < len; i++) {
-            scheme[i].drawHelp(gl, elapsedTime);
+            scheme[i].renderHelp(elapsedTime);
         }
 
-        engine.stats.renderHelp(gl, this);
-        engine.autoMap.renderHelp(gl, this);
+        engine.stats.renderHelp(this);
+        engine.autoMap.renderHelp(this);
     }
 
-    public void render(GL10 gl, boolean canRenderHelp, long elapsedTime, long firstTouchTime) {
-        renderer.z1 = 0.0f;
-        renderer.z2 = 0.0f;
-        renderer.z3 = 0.0f;
-        renderer.z4 = 0.0f;
+    public void render(boolean canRenderHelp, long elapsedTime, long firstTouchTime) {
+        renderer.useOrtho(0.0f, engine.ratio, 0.0f, 1.0f, 0.0f, 1.0f);
+        renderer.setCoordsQuadZ(0.0f);
 
-        renderer.initOrtho(gl, true, false, 0.0f, engine.ratio, 0.0f, 1.0f, 0.0f, 1.0f);
-
-        gl.glDisable(GL10.GL_DEPTH_TEST);
-        gl.glShadeModel(GL10.GL_FLAT);
-        gl.glEnable(GL10.GL_BLEND);
-        gl.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);
-
-        if (canRenderHelp && state.controlsHelpMask != 0) {
-            subRenderBlackOverlay(gl, elapsedTime, firstTouchTime);
+        if (canRenderHelp && (state.controlsHelpMask != 0 || state.disabledControlsMask != 0)) {
+            subRenderBlackOverlay(elapsedTime, firstTouchTime);
         }
 
-        renderer.setQuadRGB(1.0f, 1.0f, 1.0f);
-        subRenderControls(gl, elapsedTime, canRenderHelp);
+        renderer.setColorQuadRGB(1.0f, 1.0f, 1.0f);
+        subRenderControls(elapsedTime, canRenderHelp);
 
         if (canRenderHelp && state.controlsHelpMask != 0) {
-            subRenderHelp(gl, elapsedTime);
+            subRenderHelp(elapsedTime);
         }
-
-        gl.glMatrixMode(GL10.GL_PROJECTION);
-        gl.glPopMatrix();
     }
 
     public void updateHero() {
diff --git a/src/main/java/zame/game/engine/EndLevel.java b/src/main/java/zame/game/engine/visual/EndLevel.java
similarity index 68%
rename from src/main/java/zame/game/engine/EndLevel.java
rename to src/main/java/zame/game/engine/visual/EndLevel.java
index ef8ff18..dce9bc5 100644
--- a/src/main/java/zame/game/engine/EndLevel.java
+++ b/src/main/java/zame/game/engine/visual/EndLevel.java
@@ -1,8 +1,12 @@
-package zame.game.engine;
+package zame.game.engine.visual;
 
-import javax.microedition.khronos.opengles.GL10;
-import zame.game.Common;
-import zame.game.managers.SoundManager;
+import zame.game.core.util.Common;
+import zame.game.engine.Engine;
+import zame.game.engine.EngineObject;
+import zame.game.engine.Game;
+import zame.game.engine.graphics.Labels;
+import zame.game.engine.graphics.Renderer;
+import zame.game.feature.sound.SoundManager;
 
 public class EndLevel implements EngineObject {
     private static final float LINE_HEIGHT = 0.25f;
@@ -15,19 +19,17 @@ public class EndLevel implements EngineObject {
     private Game game;
 
     private int totalKills;
-    private int totalItems;
     private int totalSecrets;
     private int totalSeconds;
     private float currentKills;
-    private float currentItems;
     private float currentSecrets;
     private float currentSeconds;
     private float currentAdd;
     private int timeout;
-    private float ystart;
+    private float startY;
 
     @Override
-    public void setEngine(Engine engine) {
+    public void onCreate(Engine engine) {
         this.engine = engine;
         this.renderer = engine.renderer;
         this.labels = engine.labels;
@@ -35,31 +37,25 @@ public class EndLevel implements EngineObject {
         this.game = engine.game;
     }
 
-    public void init(int totalKills, int totalItems, int totalSecrets, int totalSeconds) {
+    public void init(int totalKills, int totalSecrets, int totalSeconds) {
         this.totalKills = totalKills;
-        this.totalItems = totalItems;
         this.totalSecrets = totalSecrets;
         this.totalSeconds = totalSeconds;
 
         currentKills = 0.0f;
-        currentItems = 0.0f;
         currentSecrets = 0.0f;
         currentSeconds = 0.0f;
 
         currentAdd = 1.0f;
         timeout = 0;
-        ystart = 0.0f;
+        startY = 0.0f;
 
         if (totalKills >= 0) {
-            ystart -= LINE_OFFSET;
-        }
-
-        if (totalItems >= 0) {
-            ystart -= LINE_OFFSET;
+            startY -= LINE_OFFSET;
         }
 
         if (totalSecrets >= 0) {
-            ystart -= LINE_OFFSET;
+            startY -= LINE_OFFSET;
         }
     }
 
@@ -83,11 +79,6 @@ public class EndLevel implements EngineObject {
             playSound = true;
         }
 
-        if (currentItems < totalItems) {
-            currentItems = Math.min(totalItems, currentItems + currentAdd);
-            playSound = true;
-        }
-
         if (currentSecrets < totalSecrets) {
             currentSecrets = Math.min(totalSecrets, currentSecrets + currentAdd);
             playSound = true;
@@ -107,16 +98,15 @@ public class EndLevel implements EngineObject {
     }
 
     @SuppressWarnings("MagicNumber")
-    public void render(GL10 gl) {
-        labels.beginDrawing(gl);
-        renderer.setQuadRGBA(1.0f, 1.0f, 1.0f, 1.0f);
+    public void render() {
+        labels.startBatch();
+        renderer.setColorQuadRGBA(1.0f, 1.0f, 1.0f, 1.0f);
 
         float sx = -engine.ratio + 0.1f;
         float ex = engine.ratio - 0.1f;
-        float my = ystart;
+        float my = startY;
 
-        labels.draw(gl,
-                sx,
+        labels.batch(sx,
                 my - LINE_OFFSET,
                 ex,
                 my + LINE_OFFSET,
@@ -127,8 +117,7 @@ public class EndLevel implements EngineObject {
         my += LINE_HEIGHT;
 
         if (totalSecrets >= 0) {
-            labels.draw(gl,
-                    sx,
+            labels.batch(sx,
                     my - LINE_OFFSET,
                     ex,
                     my + LINE_OFFSET,
@@ -139,22 +128,8 @@ public class EndLevel implements EngineObject {
             my += LINE_HEIGHT;
         }
 
-        if (totalItems >= 0) {
-            labels.draw(gl,
-                    sx,
-                    my - LINE_OFFSET,
-                    ex,
-                    my + LINE_OFFSET,
-                    String.format(labels.map[Labels.LABEL_ENDL_ITEMS], (int)currentItems),
-                    0.225f,
-                    Labels.ALIGN_CC);
-
-            my += LINE_HEIGHT;
-        }
-
         if (totalKills >= 0) {
-            labels.draw(gl,
-                    sx,
+            labels.batch(sx,
                     my - LINE_OFFSET,
                     ex,
                     my + LINE_OFFSET,
@@ -163,6 +138,6 @@ public class EndLevel implements EngineObject {
                     Labels.ALIGN_CC);
         }
 
-        labels.endDrawing(gl);
+        labels.renderBatch();
     }
 }
diff --git a/src/main/java/zame/game/engine/visual/GameOver.java b/src/main/java/zame/game/engine/visual/GameOver.java
new file mode 100644
index 0000000..2696ddb
--- /dev/null
+++ b/src/main/java/zame/game/engine/visual/GameOver.java
@@ -0,0 +1,63 @@
+package zame.game.engine.visual;
+
+import zame.game.App;
+import zame.game.engine.Engine;
+import zame.game.engine.EngineObject;
+import zame.game.engine.Game;
+import zame.game.engine.graphics.Labels;
+import zame.game.engine.graphics.Renderer;
+import zame.game.feature.sound.SoundManager;
+
+public class GameOver implements EngineObject {
+    private Engine engine;
+    private Renderer renderer;
+    private Labels labels;
+    private SoundManager soundManager;
+    private Game game;
+
+    @Override
+    public void onCreate(Engine engine) {
+        this.engine = engine;
+        this.renderer = engine.renderer;
+        this.labels = engine.labels;
+        this.soundManager = engine.soundManager;
+        this.game = engine.game;
+    }
+
+    public void update() {
+        if (game.actionRestartButton) {
+            App.self.tracker.trackEvent("GameOver.Restart", engine.state.levelName);
+            soundManager.playSound(SoundManager.SOUND_BTN_PRESS);
+            soundManager.setPlaylist(SoundManager.LIST_MAIN);
+            game.loadLevel(Game.LOAD_LEVEL_NORMAL);
+        }
+
+        if (game.actionContinueButton) {
+            App.self.tracker.trackEvent("GameOver.Continue", engine.state.levelName);
+            soundManager.playSound(SoundManager.SOUND_BTN_PRESS);
+            soundManager.setPlaylist(SoundManager.LIST_MAIN);
+            engine.state.mustLoadAutosave = false;
+            engine.changeView(Engine.VIEW_TYPE_REWARDED_VIDEO);
+        }
+    }
+
+    @SuppressWarnings("MagicNumber")
+    public void render() {
+        labels.startBatch();
+        renderer.setColorQuadRGBA(1.0f, 1.0f, 1.0f, 1.0f);
+
+        float sx = -engine.ratio + 0.1f;
+        float ex = engine.ratio - 0.1f;
+
+        labels.batch(sx, 0.5f, ex, 0.8f, labels.map[Labels.LABEL_GAMEOVER], 0.25f, Labels.ALIGN_CC);
+
+        int labelIndex = engine.canShowRewardedVideo ? (
+                engine.config.leftHandAim
+                        ? Labels.LABEL_GAMEOVER_SUBTITLE_LEFT_HAND_AIM
+                        : Labels.LABEL_GAMEOVER_SUBTITLE)
+                : Labels.LABEL_GAMEOVER_SUBTITLE_JUST_RESTART;
+
+        labels.batch(sx, 0.2f, ex, 0.5f, labels.map[labelIndex], 0.25f, Labels.ALIGN_CC);
+        labels.renderBatch();
+    }
+}
diff --git a/src/main/java/zame/game/engine/Overlay.java b/src/main/java/zame/game/engine/visual/Overlay.java
similarity index 71%
rename from src/main/java/zame/game/engine/Overlay.java
rename to src/main/java/zame/game/engine/visual/Overlay.java
index cc49edd..c35987d 100644
--- a/src/main/java/zame/game/engine/Overlay.java
+++ b/src/main/java/zame/game/engine/visual/Overlay.java
@@ -1,9 +1,15 @@
-package zame.game.engine;
+package zame.game.engine.visual;
 
 import android.content.res.Resources;
-import javax.microedition.khronos.opengles.GL10;
-import zame.game.App;
-import zame.game.store.Achievements;
+import zame.game.engine.Config;
+import zame.game.engine.Engine;
+import zame.game.engine.EngineObject;
+import zame.game.engine.Game;
+import zame.game.engine.graphics.Labels;
+import zame.game.engine.graphics.Renderer;
+import zame.game.engine.state.State;
+import zame.game.engine.util.GameMath;
+import zame.game.feature.achievements.Achievements;
 
 public class Overlay implements EngineObject {
     /**
@@ -39,9 +45,9 @@ public class Overlay implements EngineObject {
     private static final float DURATION_BLOOD = 300.0f;
     private static final float DURATION_GENERAL = 500.0f;
 
-    static final int BLOOD = 1;
-    static final int ITEM = 2;
-    static final int MARK = 3;
+    public static final int BLOOD = 1;
+    public static final int ITEM = 2;
+    public static final int MARK = 3;
 
     // @:formatter:off
     private static final float[][] COLORS = { new float[] { 1.0f, 0.0f, 0.0f }, // BLOOD
@@ -63,16 +69,16 @@ public class Overlay implements EngineObject {
     private long[] hitSideTime = { 0, 0, 0, 0 }; // timers for all the four gradients
 
     @Override
-    public void setEngine(Engine engine) {
+    public void onCreate(Engine engine) {
         this.engine = engine;
         this.config = engine.config;
         this.renderer = engine.renderer;
         this.state = engine.state;
         this.labels = engine.labels;
-        this.resources = App.self.getResources();
+        this.resources = engine.activity.getResources();
     }
 
-    public void init() {
+    public void reload() {
         overlayType = 0;
         shownLabel = null;
 
@@ -81,7 +87,7 @@ public class Overlay implements EngineObject {
         }
     }
 
-    void showOverlay(int type) {
+    public void showOverlay(int type) {
         overlayType = type;
         overlayTime = engine.elapsedTime;
     }
@@ -98,7 +104,7 @@ public class Overlay implements EngineObject {
         labelTime = engine.elapsedTime;
     }
 
-    void showHitSide(float mx, float my) {
+    public void showHitSide(float mx, float my) {
         hitSideTime[getDirection(mx, my, state.heroX, state.heroY, state.heroA).ordinal()] = engine.elapsedTime;
     }
 
@@ -117,7 +123,7 @@ public class Overlay implements EngineObject {
     }
 
     @SuppressWarnings("MagicNumber")
-    void renderOverlay(GL10 gl) {
+    public void renderOverlay() {
         renderer.r1 = 0.0f;
         renderer.g1 = 0.0f;
         renderer.b1 = 0.0f;
@@ -147,68 +153,56 @@ public class Overlay implements EngineObject {
             return;
         }
 
-        renderer.initOrtho(gl, true, false, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f);
-        renderer.init();
+        renderer.startBatch();
 
         renderer.r2 = renderer.r1;
         renderer.g2 = renderer.g1;
         renderer.b2 = renderer.b1;
         renderer.a2 = renderer.a1;
+
         renderer.r3 = renderer.r1;
         renderer.g3 = renderer.g1;
         renderer.b3 = renderer.b1;
         renderer.a3 = renderer.a1;
+
         renderer.r4 = renderer.r1;
         renderer.g4 = renderer.g1;
         renderer.b4 = renderer.b1;
         renderer.a4 = renderer.a1;
 
-        renderer.setQuadOrthoCoords(0.0f, 0.0f, 1.0f, 1.0f);
-        renderer.drawQuad();
+        renderer.setCoordsQuadRectFlat(0.0f, 0.0f, 1.0f, 1.0f);
+        renderer.batchQuad();
 
-        gl.glShadeModel(GL10.GL_FLAT);
-        gl.glDisable(GL10.GL_DEPTH_TEST);
-        gl.glEnable(GL10.GL_BLEND);
-        gl.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);
-        renderer.flush(gl, false);
-
-        gl.glMatrixMode(GL10.GL_PROJECTION);
-        gl.glPopMatrix();
+        renderer.useOrtho(0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f);
+        renderer.renderBatch(Renderer.FLAG_BLEND);
     }
 
     @SuppressWarnings("MagicNumber")
-    private void renderLabelLine(GL10 gl, float sy, float ey, String str, float op) {
-        renderer.initOrtho(gl, true, false, -1.0f, 1.0f, -1.0f, 1.0f, 0.0f, 1.0f);
-        renderer.init();
+    private void renderLabelLine(float sy, float ey, String str, float op) {
+        renderer.startBatch();
 
         if (engine.game.renderMode == Game.RENDER_MODE_GAME) {
-            renderer.setQuadRGBA(0.0f, 0.0f, 0.0f, op * 0.25f);
+            renderer.setColorQuadRGBA(0.0f, 0.0f, 0.0f, op * 0.25f);
         } else {
-            renderer.setQuadRGBA(1.0f, 0.0f, 0.0f, op * 0.5f);
+            renderer.setColorQuadRGBA(1.0f, 0.0f, 0.0f, op * 0.5f);
         }
 
         float my = sy + (ey - sy) * 0.5f;
-        renderer.setQuadOrthoCoords(-1.0f, my - 0.25f, 1.0f, my + 0.25f);
-        renderer.drawQuad();
-
-        gl.glShadeModel(GL10.GL_FLAT);
-        gl.glDisable(GL10.GL_DEPTH_TEST);
-        gl.glEnable(GL10.GL_BLEND);
-        gl.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);
-        renderer.flush(gl, false);
-
-        gl.glMatrixMode(GL10.GL_PROJECTION);
-        gl.glPopMatrix();
-
-        labels.beginDrawing(gl);
-        renderer.setQuadRGBA(1.0f, 1.0f, 1.0f, op);
-        labels.draw(gl, -engine.ratio + 0.1f, sy, engine.ratio - 0.1f, ey, str, 0.25f, Labels.ALIGN_CC);
-        labels.endDrawing(gl);
+        renderer.setCoordsQuadRectFlat(-1.0f, my - 0.25f, 1.0f, my + 0.25f);
+        renderer.batchQuad();
+
+        renderer.useOrtho(-1.0f, 1.0f, -1.0f, 1.0f, 0.0f, 1.0f);
+        renderer.renderBatch(Renderer.FLAG_BLEND);
+
+        labels.startBatch();
+        renderer.setColorQuadRGBA(1.0f, 1.0f, 1.0f, op);
+        labels.batch(-engine.ratio + 0.1f, sy, engine.ratio - 0.1f, ey, str, 0.25f, Labels.ALIGN_CC);
+        labels.renderBatch();
     }
 
     @SuppressWarnings("MagicNumber")
-    void renderLabels(GL10 gl) {
-        if (engine.inWallpaperMode || shownLabel == null && state.shownMessageId < 0) {
+    public void renderLabels() {
+        if (shownLabel == null && state.shownMessageId < 0) {
             return;
         }
 
@@ -218,21 +212,21 @@ public class Overlay implements EngineObject {
             if (op <= 0.0f) {
                 shownLabel = null;
             } else {
-                renderLabelLine(gl, -0.75f, (state.shownMessageId >= 0 ? 0.0f : 1.0f), shownLabel, op);
+                renderLabelLine(-0.75f, (state.shownMessageId >= 0 ? 0.0f : 1.0f), shownLabel, op);
             }
         }
 
-        if (state.shownMessageId >= 0 && state.shownMessageId < Labels.LABEL_LAST) {
-            renderLabelLine(gl, 0.0f, 0.75f, labels.map[state.shownMessageId], 1.0f);
-        }
+        if (engine.game.renderMode == Game.RENDER_MODE_GAME
+                && state.shownMessageId >= 0
+                && state.shownMessageId < Labels.LABEL_LAST) {
 
-        labels.endDrawing(gl);
+            renderLabelLine(0.0f, 0.75f, labels.map[state.shownMessageId], 1.0f);
+        }
     }
 
     @SuppressWarnings("MagicNumber")
-    void renderEndLevelLayer(GL10 gl, float dt) {
-        renderer.initOrtho(gl, true, false, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f);
-        renderer.init();
+    public void renderEndLevelLayer(float dt) {
+        renderer.startBatch();
 
         renderer.a2 = Math.min(1.0f, dt) * 0.9f;
         renderer.a3 = renderer.a2;
@@ -240,29 +234,18 @@ public class Overlay implements EngineObject {
         renderer.a1 = Math.min(1.0f, dt * 0.5f) * 0.5f;
         renderer.a4 = renderer.a1;
 
-        renderer.setQuadRGB(0.0f, 0.0f, 0.0f);
-        renderer.setQuadOrthoCoords(0.0f, 0.0f, 1.0f, 1.0f);
-        renderer.drawQuad();
+        renderer.setColorQuadRGB(0.0f, 0.0f, 0.0f);
+        renderer.setCoordsQuadRectFlat(0.0f, 0.0f, 1.0f, 1.0f);
+        renderer.batchQuad();
 
-        gl.glShadeModel(GL10.GL_SMOOTH);
-        gl.glDisable(GL10.GL_DEPTH_TEST);
-        gl.glEnable(GL10.GL_BLEND);
-        gl.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);
-        renderer.flush(gl, false);
-
-        gl.glMatrixMode(GL10.GL_PROJECTION);
-        gl.glPopMatrix();
+        renderer.useOrtho(0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f);
+        renderer.renderBatch(Renderer.FLAG_BLEND | Renderer.FLAG_SMOOTH);
     }
 
     @SuppressWarnings("MagicNumber")
-    void renderHitSide(GL10 gl) {
-        if (engine.inWallpaperMode) {
-            return;
-        }
-
-        renderer.initOrtho(gl, true, false, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f);
-        renderer.init();
-        renderer.setQuadRGB(COLORS[BLOOD - 1][0], COLORS[BLOOD - 1][1], COLORS[BLOOD - 1][2]);
+    public void renderHitSide() {
+        renderer.startBatch();
+        renderer.setColorQuadRGB(COLORS[BLOOD - 1][0], COLORS[BLOOD - 1][1], COLORS[BLOOD - 1][2]);
 
         // repeat for each of the four sides
         for (int i = 0, len = hitSideTime.length; i < len; i++) {
@@ -340,40 +323,27 @@ public class Overlay implements EngineObject {
 
                 // set the coordinates of the gradient rectangle, taken from a enum element with a given ordinal
                 GradientDirection grad = GradientDirection.values()[i];
-                renderer.setQuadOrthoCoords(grad.x1, grad.y1, grad.x2, grad.y2); // from top
+                renderer.setCoordsQuadRectFlat(grad.x1, grad.y1, grad.x2, grad.y2); // from top
 
-                renderer.drawQuad();
+                renderer.batchQuad();
             } else {
                 hitSideTime[i] = 0L;
             }
         }
 
-        gl.glShadeModel(GL10.GL_SMOOTH);
-        gl.glDisable(GL10.GL_DEPTH_TEST);
-        gl.glEnable(GL10.GL_BLEND);
-        gl.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);
-        renderer.flush(gl, false);
-
-        gl.glMatrixMode(GL10.GL_PROJECTION);
-        gl.glPopMatrix();
+        renderer.useOrtho(0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f);
+        renderer.renderBatch(Renderer.FLAG_BLEND | Renderer.FLAG_SMOOTH);
     }
 
-    void renderGammaLayer(GL10 gl) {
-        renderer.initOrtho(gl, true, false, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f);
-        renderer.init();
-
-        renderer.setQuadRGBA(1.0f, 1.0f, 1.0f, config.gamma);
-        renderer.setQuadOrthoCoords(0.0f, 0.0f, 1.0f, 1.0f);
-        renderer.drawQuad();
+    public void renderGammaLayer() {
+        renderer.useOrtho(0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f);
+        renderer.startBatch();
 
-        gl.glShadeModel(GL10.GL_FLAT);
-        gl.glDisable(GL10.GL_DEPTH_TEST);
-        gl.glEnable(GL10.GL_BLEND);
-        gl.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE);
-        renderer.flush(gl, false);
+        renderer.setColorQuadRGBA(1.0f, 1.0f, 1.0f, config.gamma);
+        renderer.setCoordsQuadRectFlat(0.0f, 0.0f, 1.0f, 1.0f);
+        renderer.batchQuad();
 
-        gl.glMatrixMode(GL10.GL_PROJECTION);
-        gl.glPopMatrix();
+        renderer.renderBatch(Renderer.FLAG_BLEND | Renderer.FLAG_BLEND_GAMMA);
     }
 
     private Overlay.GradientDirection getDirection(float mx, float my, float px, float py, float pa) {
@@ -385,11 +355,11 @@ public class Overlay implements EngineObject {
             return GradientDirection.Bottom;
         }
 
-        if (phi > GRADIENT_BOUNDARY_1 && phi <= GRADIENT_BOUNDARY_2) {
+        if (phi <= GRADIENT_BOUNDARY_2) {
             return GradientDirection.Left;
         }
 
-        if (phi > GRADIENT_BOUNDARY_2 && phi <= GRADIENT_BOUNDARY_3) {
+        if (phi <= GRADIENT_BOUNDARY_3) {
             return GradientDirection.Top;
         }
 
diff --git a/src/main/java/zame/game/engine/hud/Stats.java b/src/main/java/zame/game/engine/visual/Stats.java
similarity index 60%
rename from src/main/java/zame/game/engine/hud/Stats.java
rename to src/main/java/zame/game/engine/visual/Stats.java
index 089e652..dd95ad4 100644
--- a/src/main/java/zame/game/engine/hud/Stats.java
+++ b/src/main/java/zame/game/engine/visual/Stats.java
@@ -1,16 +1,13 @@
-package zame.game.engine.hud;
+package zame.game.engine.visual;
 
-import javax.microedition.khronos.opengles.GL10;
 import zame.game.App;
 import zame.game.engine.Config;
 import zame.game.engine.Engine;
 import zame.game.engine.EngineObject;
-import zame.game.engine.Labels;
-import zame.game.engine.Renderer;
-import zame.game.engine.State;
-import zame.game.engine.TextureLoader;
-import zame.game.engine.Weapons;
-import zame.game.engine.controls.Controls;
+import zame.game.engine.graphics.Labels;
+import zame.game.engine.graphics.Renderer;
+import zame.game.engine.graphics.TextureLoader;
+import zame.game.engine.state.State;
 
 public class Stats implements EngineObject {
     private static final float DIST_Y_STATS = 0.5f;
@@ -23,20 +20,18 @@ public class Stats implements EngineObject {
     private Config config;
     private Labels labels;
     private Weapons weapons;
-    private TextureLoader textureLoader;
     private State state;
     private float iconSize;
     private float startX;
     private float startKeysX;
 
     @Override
-    public void setEngine(Engine engine) {
+    public void onCreate(Engine engine) {
         this.engine = engine;
         this.renderer = engine.renderer;
         this.config = engine.config;
         this.labels = engine.labels;
         this.weapons = engine.weapons;
-        this.textureLoader = engine.textureLoader;
         this.state = engine.state;
     }
 
@@ -49,30 +44,19 @@ public class Stats implements EngineObject {
     }
 
     @SuppressWarnings("MagicNumber")
-    private void drawStatIcon(@SuppressWarnings("unused") GL10 gl, int pos, int texNum) {
+    private void batchStatIcon(int pos, int texNum) {
         float pointerX = startX;
         float pointerY = ((float)pos * DIST_Y_STATS + OFFSET_Y_STATS) * iconSize;
 
         float sx = (pointerX / (float)engine.width * engine.ratio) - 0.125f * App.self.controlsScale;
         float sy = (1.0f - pointerY / (float)engine.height) - 0.125f * App.self.controlsScale;
 
-        float ex = sx + 0.25f * App.self.controlsScale;
-        float ey = sy + 0.25f * App.self.controlsScale;
-
-        renderer.x1 = sx;
-        renderer.y1 = sy;
-        renderer.x2 = sx;
-        renderer.y2 = ey;
-        renderer.x3 = ex;
-        renderer.y3 = ey;
-        renderer.x4 = ex;
-        renderer.y4 = sy;
-
-        renderer.drawQuad(texNum);
+        renderer.setCoordsQuadRect(sx, sy, sx + 0.25f * App.self.controlsScale, sy + 0.25f * App.self.controlsScale);
+        renderer.batchTexQuad(texNum);
     }
 
     @SuppressWarnings("MagicNumber")
-    private void drawStatLabel(GL10 gl, int pos, int value) {
+    private void batchStatLabel(int pos, int value) {
         float pointerX = startX;
         float pointerY = ((float)pos * DIST_Y_STATS + OFFSET_Y_STATS) * iconSize;
 
@@ -82,34 +66,27 @@ public class Stats implements EngineObject {
         float ex = sx + 0.125f * App.self.controlsScale; // 0.0625f
         float ey = sy + 0.25f * App.self.controlsScale;
 
-        labels.draw(gl, sx, sy, ex, ey, value, 0.05f * App.self.controlsScale, Labels.ALIGN_CL); // 0.0625f
+        labels.batch(sx, sy, ex, ey, value, 0.05f * App.self.controlsScale, Labels.ALIGN_CL); // 0.0625f
     }
 
     @SuppressWarnings("MagicNumber")
-    private void drawKeyIcon(@SuppressWarnings("unused") GL10 gl, int pos, int texNum) {
+    private void batchKeyIcon(int pos, int texNum) {
         float pointerX = startKeysX;
         float pointerY = ((float)pos * DIST_Y_KEYS + OFFSET_Y_KEYS) * iconSize;
 
         float sx = (pointerX / (float)engine.width * engine.ratio) - 0.125f * App.self.controlsScale;
         float sy = (1.0f - pointerY / (float)engine.height) - 0.125f * App.self.controlsScale;
 
-        float ex = sx + 0.25f * App.self.controlsScale;
-        float ey = sy + 0.25f * App.self.controlsScale;
+        renderer.setCoordsQuadRect(sx,
+                sy,
+                sx + 0.25f * App.self.controlsScale,
+                sy + 0.25f * App.self.controlsScale);
 
-        renderer.x1 = sx;
-        renderer.y1 = sy;
-        renderer.x2 = sx;
-        renderer.y2 = ey;
-        renderer.x3 = ex;
-        renderer.y3 = ey;
-        renderer.x4 = ex;
-        renderer.y4 = sy;
-
-        renderer.drawQuad(texNum);
+        renderer.batchTexQuad(texNum);
     }
 
     @SuppressWarnings("MagicNumber")
-    public void render(GL10 gl) {
+    public void render() {
         if (startX < 0.0f) {
             if (config.leftHandAim) {
                 startX = (float)engine.width - iconSize * 1.0f;
@@ -120,112 +97,76 @@ public class Stats implements EngineObject {
             }
         }
 
-        renderer.initOrtho(gl, true, false, 0.0f, engine.ratio, 0.0f, 1.0f, 0.0f, 1.0f);
-
-        renderer.z1 = 0.0f;
-        renderer.z2 = 0.0f;
-        renderer.z3 = 0.0f;
-        renderer.z4 = 0.0f;
-
-        gl.glDisable(GL10.GL_DEPTH_TEST);
-        gl.glShadeModel(GL10.GL_FLAT);
-        gl.glEnable(GL10.GL_BLEND);
-        gl.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);
-
-        renderer.r1 = 1.0f;
-        renderer.g1 = 1.0f;
-        renderer.b1 = 1.0f;
-        renderer.a1 = 0.8f;
-        renderer.r2 = 1.0f;
-        renderer.g2 = 1.0f;
-        renderer.b2 = 1.0f;
-        renderer.a2 = 0.8f;
-        renderer.r3 = 1.0f;
-        renderer.g3 = 1.0f;
-        renderer.b3 = 1.0f;
-        renderer.a3 = 0.8f;
-        renderer.r4 = 1.0f;
-        renderer.g4 = 1.0f;
-        renderer.b4 = 1.0f;
-        renderer.a4 = 0.8f;
-
-        renderer.init();
+        renderer.startBatch();
+        renderer.setCoordsQuadZ(0.0f);
+        renderer.setColorQuadRGBA(1.0f, 1.0f, 1.0f, 0.8f);
 
         if ((state.disabledControlsMask & Controls.CONTROL_STATS_HEALTH) == 0) {
-            drawStatIcon(gl, 0, TextureLoader.ICON_HEALTH);
+            batchStatIcon(0, TextureLoader.ICON_HEALTH);
         }
 
         if ((state.disabledControlsMask & Controls.CONTROL_STATS_ARMOR) == 0) {
-            drawStatIcon(gl, 1, TextureLoader.ICON_ARMOR);
+            batchStatIcon(1, TextureLoader.ICON_ARMOR);
         }
 
         if ((weapons.currentParams.ammoIdx >= 0)
                 && (state.heroAmmo[weapons.currentParams.ammoIdx] >= 0)
                 && (state.disabledControlsMask & Controls.CONTROL_STATS_AMMO) == 0) {
 
-            drawStatIcon(gl, 2, TextureLoader.ICON_AMMO);
+            batchStatIcon(2, TextureLoader.ICON_AMMO);
         }
 
         int keyPos = 0;
-
-        renderer.a1 = 1.0f;
-        renderer.a2 = 1.0f;
-        renderer.a3 = 1.0f;
-        renderer.a4 = 1.0f;
+        renderer.setColorQuadA(1.0f);
 
         if ((state.disabledControlsMask & Controls.CONTROL_STATS_KEYS) == 0) {
             if ((state.heroKeysMask & 1) != 0) {
-                drawKeyIcon(gl, keyPos, TextureLoader.ICON_BLUE_KEY);
+                batchKeyIcon(keyPos, TextureLoader.ICON_BLUE_KEY);
                 keyPos++;
             }
 
             if ((state.heroKeysMask & 2) != 0) {
-                drawKeyIcon(gl, keyPos, TextureLoader.ICON_RED_KEY);
+                batchKeyIcon(keyPos, TextureLoader.ICON_RED_KEY);
                 keyPos++;
             }
 
             if ((state.heroKeysMask & 4) != 0) {
-                drawKeyIcon(gl, keyPos, TextureLoader.ICON_GREEN_KEY);
+                batchKeyIcon(keyPos, TextureLoader.ICON_GREEN_KEY);
             }
         }
 
-        renderer.bindTextureCtl(gl, textureLoader.textures[TextureLoader.TEXTURE_MAIN]);
-        renderer.flush(gl);
+        renderer.useOrtho(0.0f, engine.ratio, 0.0f, 1.0f, 0.0f, 1.0f);
+        renderer.renderBatch(Renderer.FLAG_BLEND, Renderer.TEXTURE_MAIN);
 
-        renderer.init();
+        labels.startBatch(true);
 
         if ((state.disabledControlsMask & Controls.CONTROL_STATS_HEALTH) == 0) {
-            drawStatLabel(gl, 0, state.heroHealth);
+            batchStatLabel(0, state.heroHealth);
         }
 
         if ((state.disabledControlsMask & Controls.CONTROL_STATS_ARMOR) == 0) {
-            drawStatLabel(gl, 1, state.heroArmor);
+            batchStatLabel(1, state.heroArmor);
         }
 
         if ((weapons.currentParams.ammoIdx >= 0)
                 && (state.heroAmmo[weapons.currentParams.ammoIdx] >= 0)
                 && (state.disabledControlsMask & Controls.CONTROL_STATS_AMMO) == 0) {
 
-            drawStatLabel(gl, 2, state.heroAmmo[weapons.currentParams.ammoIdx]);
+            batchStatLabel(2, state.heroAmmo[weapons.currentParams.ammoIdx]);
         }
 
-        renderer.bindTextureBlur(gl, textureLoader.textures[TextureLoader.TEXTURE_LABELS]);
-        renderer.flush(gl);
-
-        gl.glMatrixMode(GL10.GL_PROJECTION);
-        gl.glPopMatrix();
+        labels.renderBatch();
     }
 
     @SuppressWarnings("MagicNumber")
-    public void renderHelp(GL10 gl, Controls controls) {
+    void renderHelp(Controls controls) {
         float xOff = 0.03125f * App.self.controlsScale * (float)engine.width / engine.ratio;
         float yOff = 0.03125f * App.self.controlsScale * (float)engine.height;
 
         if ((state.disabledControlsMask & Controls.CONTROL_STATS_HEALTH) == 0
                 && (state.controlsHelpMask & Controls.CONTROL_STATS_HEALTH) != 0) {
 
-            controls.drawHelpArrowWithText(gl,
-                    startX + xOff,
+            controls.renderHelpArrowWithText(startX + xOff,
                     OFFSET_Y_STATS * iconSize + yOff,
                     Controls.DIAG_SIZE_XLG,
                     !engine.config.leftHandAim,
@@ -236,8 +177,7 @@ public class Stats implements EngineObject {
         if ((state.disabledControlsMask & Controls.CONTROL_STATS_AMMO) == 0
                 && (state.controlsHelpMask & Controls.CONTROL_STATS_AMMO) != 0) {
 
-            controls.drawHelpArrowWithText(gl,
-                    startX + xOff,
+            controls.renderHelpArrowWithText(startX + xOff,
                     (DIST_Y_STATS * 2.0f + OFFSET_Y_STATS) * iconSize + yOff,
                     Controls.DIAG_SIZE,
                     !engine.config.leftHandAim,
@@ -248,8 +188,7 @@ public class Stats implements EngineObject {
         if ((state.disabledControlsMask & Controls.CONTROL_STATS_ARMOR) == 0
                 && (state.controlsHelpMask & Controls.CONTROL_STATS_ARMOR) != 0) {
 
-            controls.drawHelpArrowWithText(gl,
-                    startX + xOff,
+            controls.renderHelpArrowWithText(startX + xOff,
                     (DIST_Y_STATS + OFFSET_Y_STATS) * iconSize + yOff,
                     Controls.DIAG_SIZE_LG,
                     !engine.config.leftHandAim,
@@ -260,8 +199,7 @@ public class Stats implements EngineObject {
         if ((state.disabledControlsMask & Controls.CONTROL_STATS_KEYS) == 0
                 && (state.controlsHelpMask & Controls.CONTROL_STATS_KEYS) != 0) {
 
-            controls.drawHelpArrowWithText(gl,
-                    startKeysX + xOff,
+            controls.renderHelpArrowWithText(startKeysX + xOff,
                     OFFSET_Y_KEYS * iconSize + yOff,
                     Controls.DIAG_SIZE,
                     !engine.config.leftHandAim,
diff --git a/src/main/java/zame/game/engine/visual/Weapons.java b/src/main/java/zame/game/engine/visual/Weapons.java
new file mode 100644
index 0000000..573b45b
--- /dev/null
+++ b/src/main/java/zame/game/engine/visual/Weapons.java
@@ -0,0 +1,487 @@
+package zame.game.engine.visual;
+
+import zame.game.engine.Engine;
+import zame.game.engine.EngineObject;
+import zame.game.engine.entity.Bullet;
+import zame.game.engine.entity.OnChangeWeaponAction;
+import zame.game.engine.graphics.Renderer;
+import zame.game.engine.graphics.TextureLoader;
+import zame.game.engine.state.State;
+import zame.game.engine.util.GameMath;
+import zame.game.feature.sound.SoundManager;
+import zame.game.flavour.config.GameConfig;
+
+public class Weapons implements EngineObject {
+    public static class WeaponParams {
+        int[] cycle;
+        int needAmmo;
+        public int hits;
+        int stunTimeout; //    ""   
+        int textureBase;
+        float multX;
+        float offX;
+        float hgt;
+        int soundIdx;
+        boolean isMelee;
+        int noHitSoundIdx;
+        int hitsPerSecond;
+
+        public int ammoIdx;
+        public String name;
+        public String description;
+
+        WeaponParams(int[] cycle,
+                int ammoIdx,
+                int needAmmo,
+                int hits,
+                int stunTimeout,
+                int textureBase,
+                float multX,
+                float offX,
+                float hgt,
+                int soundIdx,
+                boolean isMelee,
+                int noHitSoundIdx,
+                int hitsPerSecond,
+                String name) {
+
+            this.cycle = cycle;
+            this.ammoIdx = ammoIdx;
+            this.needAmmo = needAmmo;
+            this.hits = hits;
+            this.stunTimeout = stunTimeout;
+            this.textureBase = textureBase;
+            this.multX = multX;
+            this.offX = offX;
+            this.hgt = hgt;
+            this.soundIdx = soundIdx;
+            this.isMelee = isMelee;
+            this.noHitSoundIdx = noHitSoundIdx;
+            this.hitsPerSecond = hitsPerSecond;
+            this.name = name;
+
+            makeDescription();
+        }
+
+        void makeDescription() {
+            StringBuilder sb = new StringBuilder(name);
+
+            if (isMelee) {
+                sb.append(" / MELEE");
+            }
+
+            int damage = 0;
+
+            //noinspection ForLoopReplaceableByForEach
+            for (int i = 0; i < cycle.length; i++) {
+                if (cycle[i] < 0) {
+                    damage += hits;
+                }
+            }
+
+            sb.append(" / DPS ");
+            sb.append(hitsPerSecond * damage);
+            sb.append(" / STUN ");
+            sb.append(stunTimeout);
+
+            if (needAmmo > 0) {
+                sb.append(" / AMMO ");
+                sb.append(needAmmo);
+            }
+
+            description = sb.toString();
+        }
+    }
+
+    public static final int AMMO_CLIP = 0;
+    public static final int AMMO_SHELL = 1;
+    public static final int AMMO_GRENADE = 2;
+    public static final int AMMO_LAST = 3;
+
+    public static final int[] AMMO_OBJ_TEX_MAP = { TextureLoader.OBJ_CLIP,
+            TextureLoader.OBJ_SHELL,
+            TextureLoader.OBJ_GRENADE, };
+
+    public static final int WEAPON_KNIFE = 0; // required to be 0
+    public static final int WEAPON_PISTOL = 1; // AMMO_CLIP
+    public static final int WEAPON_DBLPISTOL = 2; // AMMO_CLIP
+    public static final int WEAPON_AK47 = 3; // AMMO_SHELL
+    public static final int WEAPON_TMP = 4; // AMMO_SHELL
+    public static final int WEAPON_WINCHESTER = 5; // AMMO_SHELL
+    public static final int WEAPON_GRENADE = 6; // AMMO_GRENADE
+    public static final int WEAPON_LAST = 7;
+
+    private static final float WALK_OFFSET_X = 1.0f / 8.0f;
+    private static final float DEFAULT_HEIGHT = 1.5f;
+
+    // 1 frame = 1s / Engine.FRAMES_PER_SECOND = 1s / 40 = 0.025s
+    // 1s = 40 frames
+
+    // @formatter:off
+	public static final WeaponParams[] WEAPONS = {
+		// WEAPON_KNIFE (2 hits per second) -- must be first
+		new WeaponParams(
+			new int[] {
+				0,
+                3, 3, 3,
+                2, 2, 2,
+                -1, 1, 1,
+                3, 3, 3,
+                0, 0, 0, 0, 0, 0, 0
+			},
+			-1, 0,
+			GameConfig.HEALTH_HIT_KNIFE, GameConfig.STUN_KNIFE,
+			Renderer.TEXTURE_KNIFE, 1.0f, 0.0f, DEFAULT_HEIGHT,
+			SoundManager.SOUND_SHOOT_KNIFE, true, SoundManager.SOUND_NO_WAY,
+			2, "KNIFE"
+		),
+		// WEAPON_PISTOL (2 hits per second)
+		new WeaponParams(
+			new int[] {
+				0,
+				-1, 1, 1, 1, 1,
+				2, 2, 2, 2, 2,
+				3, 3, 3, 3, 3,
+				0, 0, 0, 0
+			},
+			AMMO_CLIP, 1,
+			GameConfig.HEALTH_HIT_PISTOL, GameConfig.STUN_PISTOL,
+			Renderer.TEXTURE_PISTOL, 1.0f, 0.0f, DEFAULT_HEIGHT,
+			SoundManager.SOUND_SHOOT_PISTOL, false, 0,
+			2, "PISTOL"
+		),
+		// WEAPON_DBLPISTOL (4 hits per second = 2 cycles per second)
+		new WeaponParams(
+			new int[] {
+				0,
+				-1, 1, 1, 1, 1,
+				-2, 2, 2, 2, 2,
+				3, 3, 3, 3, 3,
+				0, 0, 0, 0
+			},
+			AMMO_CLIP, 1,
+			GameConfig.HEALTH_HIT_DBLPISTOL, GameConfig.STUN_DBLPISTOL,
+			Renderer.TEXTURE_DBLPISTOL, 1.0f, 0.0f, DEFAULT_HEIGHT,
+			SoundManager.SOUND_SHOOT_DBLPISTOL, false, 0,
+			4, "DOUBLE PISTOL"
+		),
+		// WEAPON_AK47 (4 hits per second)
+		new WeaponParams(
+			new int[] {
+				0,
+				-1, 1,
+				2, 2,
+				3, 3,
+				0, 0, 0
+			},
+			AMMO_SHELL, 1,
+			GameConfig.HEALTH_HIT_AK47, GameConfig.STUN_AK47,
+			Renderer.TEXTURE_AK47, 1.0f, 0.0f, DEFAULT_HEIGHT,
+			SoundManager.SOUND_SHOOT_AK47, false, 0,
+			4, "AK-47"
+		),
+		// WEAPON_TMP (5 hits per second)
+		new WeaponParams(
+			new int[] {
+				0,
+				-1, 2, 3,
+                0,
+                1, 2, 3
+			},
+			AMMO_SHELL, 1,
+			GameConfig.HEALTH_HIT_TMP, GameConfig.STUN_TMP,
+			Renderer.TEXTURE_TMP, 1.0f, 0.0f, DEFAULT_HEIGHT,
+			SoundManager.SOUND_SHOOT_TMP, false, 0,
+			5, "TMP"
+		),
+		// WEAPON_WINCHESTER (1 hits per second)
+		new WeaponParams(
+			new int[] {
+				0, 0, 0, 0, 0,
+				1, 1, 1, 1, 1,
+				-2, 2, 2, 2, 2,
+				3, 3, 3, 3, 3,
+				4, 4, 4, 4, 4,
+				0, 0, 0, 0, 0,
+				0, 0, 0, 0, 0,
+				0, 0, 0, 0, 0,
+			},
+			AMMO_SHELL, 2,
+			GameConfig.HEALTH_HIT_WINCHESTER, GameConfig.STUN_WINCHESTER,
+			Renderer.TEXTURE_SHTG, 1.0f, 0.0f, DEFAULT_HEIGHT,
+			SoundManager.SOUND_SHOOT_WINCHESTER, false, 0,
+			1, "WINCHESTER"
+		),
+		// WEAPON_GRENADE (1 hit per second)
+		new WeaponParams(
+			new int[] {
+				0,
+				1, 1, 1, 1,
+				2, 2, 2, 2,
+				3, 3, 3, 3,
+				4, 4, 4, 4,
+				5, 5, 5, 5,
+				6, 6, 6, 6,
+				-7, 7, 7, 7,
+				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+			},
+			AMMO_GRENADE, 1,
+			GameConfig.HEALTH_HIT_GRENADE, GameConfig.STUN_GRENADE,
+			Renderer.TEXTURE_GRENADE,
+            1.0f + WALK_OFFSET_X, // multX
+            WALK_OFFSET_X, // offX
+            DEFAULT_HEIGHT * (1.0f + WALK_OFFSET_X), // hgt
+			SoundManager.SOUND_SHOOT_GRENADE, false, 0,
+			1, "GRENADE"
+		),
+	};
+    // @formatter:on
+
+    private Engine engine;
+    private State state;
+    private Renderer renderer;
+    WeaponParams currentParams;
+    private int[] currentCycle;
+    private int shootCycle;
+    private int changeWeaponNext;
+    private long changeWeaponTime;
+    private int changeWeaponDir;
+
+    @Override
+    public void onCreate(Engine engine) {
+        this.engine = engine;
+        this.state = engine.state;
+        this.renderer = engine.renderer;
+    }
+
+    public void reload() {
+        changeWeaponDir = 0;
+        setHeroWeaponImmediate(state.heroWeapon); // update params after reload
+    }
+
+    public void setHeroWeaponImmediate(int weaponIdx) {
+        int prevHeroWeapon = state.heroWeapon;
+        state.heroWeapon = weaponIdx;
+
+        currentParams = WEAPONS[weaponIdx];
+        currentCycle = currentParams.cycle;
+        shootCycle = 0;
+
+        int lastWeaponsLen = state.lastWeapons.length;
+
+        for (int i = 0; i < lastWeaponsLen; i++) {
+            if (state.lastWeapons[i] == weaponIdx) {
+                return;
+            }
+        }
+
+        for (int i = 0; i < lastWeaponsLen; i++) {
+            state.lastWeaponIdx = (state.lastWeaponIdx + 1) % lastWeaponsLen;
+
+            if (state.lastWeapons[state.lastWeaponIdx] < 0) {
+                state.lastWeapons[state.lastWeaponIdx] = weaponIdx;
+                return;
+            }
+        }
+
+        for (int i = 0; i < lastWeaponsLen; i++) {
+            state.lastWeaponIdx = (state.lastWeaponIdx + 1) % lastWeaponsLen;
+
+            if (state.lastWeapons[state.lastWeaponIdx] != prevHeroWeapon) {
+                state.lastWeapons[state.lastWeaponIdx] = weaponIdx;
+                return;
+            }
+        }
+    }
+
+    public void switchWeapon(int weaponIdx) {
+        if (state.heroWeapon == weaponIdx) {
+            return;
+        }
+
+        engine.interacted = true;
+
+        changeWeaponNext = weaponIdx;
+        changeWeaponTime = engine.elapsedTime;
+        changeWeaponDir = -1;
+
+        for (OnChangeWeaponAction onChangeWeaponAction = state.onChangeWeaponActions.first();
+                onChangeWeaponAction != null; ) {
+
+            OnChangeWeaponAction nextOnChangeWeaponAction = onChangeWeaponAction.next;
+            engine.level.executeActions(onChangeWeaponAction.markId);
+            state.onChangeWeaponActions.release(onChangeWeaponAction);
+
+            //noinspection AssignmentToForLoopParameter
+            onChangeWeaponAction = nextOnChangeWeaponAction;
+        }
+    }
+
+    public boolean hasNoAmmo(int weaponIdx) {
+        int ammoIdx = WEAPONS[weaponIdx].ammoIdx;
+        return (ammoIdx >= 0 && state.heroAmmo[ammoIdx] < WEAPONS[weaponIdx].needAmmo);
+    }
+
+    public boolean canSwitch(int weaponIdx) {
+        return (state.heroHasWeapon[weaponIdx] && !hasNoAmmo(weaponIdx));
+    }
+
+    public void update(boolean canShoot) {
+        int tex = currentCycle[shootCycle];
+
+        // "canSwitch" just for case
+        if (canShoot && tex < 0 && canSwitch(state.heroWeapon)) {
+            //noinspection BooleanVariableAlwaysNegated
+            boolean hitOrShoot = Bullet.shootOrPunch(state,
+                    state.heroX,
+                    state.heroY,
+                    engine.heroAr,
+                    null,
+                    currentParams.ammoIdx,
+                    currentParams.hits,
+                    currentParams.stunTimeout);
+
+            if (tex > -1000) {
+                engine.soundManager.playSound((currentParams.noHitSoundIdx != 0 && !hitOrShoot)
+                        ? currentParams.noHitSoundIdx
+                        : currentParams.soundIdx);
+            }
+
+            if (currentParams.ammoIdx >= 0) {
+                state.heroAmmo[currentParams.ammoIdx] -= currentParams.needAmmo;
+
+                if (state.heroAmmo[currentParams.ammoIdx] < currentParams.needAmmo) {
+                    if (state.heroAmmo[currentParams.ammoIdx] < 0) {
+                        state.heroAmmo[currentParams.ammoIdx] = 0;
+                    }
+
+                    selectBestWeapon(-1);
+                }
+            }
+        }
+
+        if (shootCycle > 0) {
+            shootCycle = (shootCycle + 1) % currentCycle.length;
+        }
+    }
+
+    public void fire() {
+        if (shootCycle == 0 && changeWeaponDir == 0) {
+            shootCycle++;
+        }
+    }
+
+    public boolean switchToNextWeapon() {
+        if (shootCycle != 0 || changeWeaponDir != 0) {
+            return false;
+        }
+
+        int resWeapon = (state.heroWeapon + 1) % WEAPON_LAST;
+
+        while (resWeapon != 0 && !canSwitch(resWeapon)) {
+            resWeapon = (resWeapon + 1) % WEAPON_LAST;
+        }
+
+        switchWeapon(resWeapon);
+        return true;
+    }
+
+    public int getBestWeapon(int desiredAmmo) {
+        // At first try to find beat weapon with desired ammo (but grenade is never desired)
+        if (desiredAmmo >= 0 && desiredAmmo != AMMO_GRENADE) {
+            for (int i = WEAPON_LAST - 1; i > 0; i--) {
+                if (canSwitch(i) && !WEAPONS[i].isMelee && WEAPONS[i].ammoIdx == desiredAmmo) {
+                    return i;
+                }
+            }
+        }
+
+        // At second try find anything except grenade or melee weapon
+        for (int i = WEAPON_LAST - 1; i > 0; i--) {
+            if (canSwitch(i) && !WEAPONS[i].isMelee && WEAPONS[i].ammoIdx != AMMO_GRENADE) {
+                return i;
+            }
+        }
+
+        // At last try to find anything appropriate
+        for (int i = WEAPON_LAST - 1; i > 0; i--) {
+            if (canSwitch(i)) {
+                return i;
+            }
+        }
+
+        // Use knife as last resort
+        return 0;
+    }
+
+    public void selectBestWeapon(int desiredAmmo) {
+        int bestWeapon = getBestWeapon(desiredAmmo);
+
+        if (bestWeapon == state.heroWeapon) {
+            return;
+        }
+
+        if (desiredAmmo < 0) {
+            switchWeapon(bestWeapon);
+            return;
+        }
+
+        if (WEAPONS[bestWeapon].ammoIdx == WEAPONS[state.heroWeapon].ammoIdx) {
+            return;
+        }
+
+        if (bestWeapon > state.heroWeapon) {
+            switchWeapon(bestWeapon);
+        }
+    }
+
+    @SuppressWarnings("MagicNumber")
+    public void render(long walkTime) {
+        float offY = 0;
+
+        if (changeWeaponDir < 0) {
+            offY = (float)(engine.elapsedTime - changeWeaponTime) / 150.0f;
+
+            if (offY >= currentParams.hgt + 0.1f) {
+                setHeroWeaponImmediate(changeWeaponNext);
+                changeWeaponDir = 1;
+                changeWeaponTime = engine.elapsedTime;
+            }
+        } else if (changeWeaponDir > 0) {
+            offY = currentParams.hgt + 0.1f - (float)(engine.elapsedTime - changeWeaponTime) / 150.0f;
+
+            if (offY <= 0.0f) {
+                offY = 0.0f;
+                changeWeaponDir = 0;
+            }
+        }
+
+        float offX = (float)Math.sin((float)walkTime / 150.0f) * WALK_OFFSET_X;
+        float lfX = -currentParams.multX + currentParams.offX + offX;
+        float rtX = currentParams.multX + currentParams.offX + offX;
+
+        offY += Math.abs((float)Math.sin((float)walkTime / 150.0f + GameMath.PI_F / 2.0f)) * 0.1f + 0.05f;
+
+        renderer.startBatch();
+        renderer.setColorQuadRGBA(1.0f, 1.0f, 1.0f, 1.0f);
+        renderer.setCoordsQuadRectFlat(lfX, -offY, rtX, currentParams.hgt - offY);
+        renderer.setTexRect(0, 1 << 16, 1 << 16, 0);
+        renderer.batchQuad();
+
+        // just for case
+        if (shootCycle > currentCycle.length) {
+            shootCycle = 0;
+        }
+
+        int weaponTexture = currentCycle[shootCycle];
+
+        if (weaponTexture < -1000) {
+            weaponTexture = -1000 - weaponTexture;
+        } else if (weaponTexture < 0) {
+            weaponTexture = -weaponTexture;
+        }
+
+        renderer.useOrtho(-1.0f, 1.0f, 0.0f, 2.0f, 0.0f, 1.0f);
+        renderer.renderBatch(Renderer.FLAG_BLEND, currentParams.textureBase + weaponTexture);
+    }
+}
diff --git a/src/main/java/zame/game/store/achievements/Achievement.java b/src/main/java/zame/game/feature/achievements/Achievement.java
similarity index 59%
rename from src/main/java/zame/game/store/achievements/Achievement.java
rename to src/main/java/zame/game/feature/achievements/Achievement.java
index 6e1f6aa..d81ef16 100644
--- a/src/main/java/zame/game/store/achievements/Achievement.java
+++ b/src/main/java/zame/game/feature/achievements/Achievement.java
@@ -1,25 +1,33 @@
-package zame.game.store.achievements;
+package zame.game.feature.achievements;
 
 import java.util.Locale;
 import zame.game.engine.Engine;
-import zame.game.engine.State;
-import zame.game.managers.SoundManager;
-import zame.game.store.Profile;
+import zame.game.engine.state.Profile;
+import zame.game.engine.state.State;
+import zame.game.feature.sound.SoundManager;
 
 public class Achievement {
     public int id;
-    public int statId;
+    int statId;
     public int titleResourceId;
-    public int descriptionResourceId;
+    int descriptionResourceId;
+    boolean isAltBackground;
 
     private int maxValue;
 
-    public Achievement(int id, int statId, int maxValue, int titleResourceId, int descriptionResourceId) {
+    Achievement(int id,
+            int statId,
+            int maxValue,
+            int titleResourceId,
+            int descriptionResourceId,
+            boolean isAltBackground) {
+
         this.id = id;
         this.statId = statId;
         this.maxValue = maxValue;
         this.titleResourceId = titleResourceId;
         this.descriptionResourceId = descriptionResourceId;
+        this.isAltBackground = isAltBackground;
     }
 
     public void update(Profile profile, Engine engine, State state) {
@@ -29,18 +37,18 @@ public class Achievement {
 
         if (!profile.achieved[id] && state.stats[statId] >= maxValue) {
             profile.achieved[id] = true;
-            profile.update();
+            profile.update(engine.activity);
 
             engine.overlay.showAchievement(titleResourceId);
             engine.soundManager.playSound(SoundManager.SOUND_ACHIEVEMENT_UNLOCKED);
         }
     }
 
-    public boolean isAchieved(Profile profile) {
+    boolean isAchieved(Profile profile) {
         return profile.achieved[id];
     }
 
-    public String getStatusText(@SuppressWarnings("unused") Profile profile, State state) {
+    String getStatusText(@SuppressWarnings("unused") Profile profile, State state) {
         return String.format(Locale.US, "%d/%d", (state.stats[statId] < 0 ? 0 : state.stats[statId]), maxValue);
     }
 }
diff --git a/src/main/java/zame/game/feature/achievements/Achievements.java b/src/main/java/zame/game/feature/achievements/Achievements.java
new file mode 100644
index 0000000..0c2cda2
--- /dev/null
+++ b/src/main/java/zame/game/feature/achievements/Achievements.java
@@ -0,0 +1,220 @@
+package zame.game.feature.achievements;
+
+import zame.game.R;
+import zame.game.engine.Engine;
+import zame.game.engine.state.Profile;
+import zame.game.engine.state.State;
+
+public final class Achievements {
+    public static final int STAT_MONSTERS_KILLED = 0;
+    public static final int STAT_DOORS_OPENED = 1;
+    public static final int STAT_SECRETS_FOUND = 2;
+    public static final int STAT_P100_KILLS_ROW = 3;
+    public static final int STAT_P100_SECRETS_ROW = 4;
+    public static final int STAT_BARRELS_EXPLODED = 5;
+    public static final int STAT_LAST = 6;
+
+    private static final int MONSTERS_KILLED_5 = 0; // hands in blood
+    private static final int MONSTERS_KILLED_50 = 1;
+    private static final int MONSTERS_KILLED_500 = 2;
+    private static final int MONSTERS_KILLED_2500 = 3;
+    private static final int MONSTERS_KILLED_5000 = 4;
+    private static final int DOORS_OPENED_5 = 5; // mastered doors
+    private static final int DOORS_OPENED_10 = 6;
+    private static final int DOORS_OPENED_25 = 7;
+    private static final int DOORS_OPENED_50 = 8;
+    private static final int DOORS_OPENED_75 = 9;
+    private static final int SECRETS_FOUND_5 = 10; // mastered secrets
+    private static final int SECRETS_FOUND_10 = 11;
+    private static final int SECRETS_FOUND_15 = 12;
+    private static final int SECRETS_FOUND_20 = 13;
+    private static final int SECRETS_FOUND_30 = 14;
+    private static final int P100_KILLS_ROW_5 = 15;
+    private static final int P100_SECRETS_ROW_5 = 16;
+    private static final int P100_KILLS_ROW_10 = 17;
+    private static final int P100_SECRETS_ROW_10 = 18;
+    private static final int BARRELS_EXPLODED_1 = 19;
+    private static final int BARRELS_EXPLODED_5 = 20;
+    private static final int BARRELS_EXPLODED_25 = 21;
+    private static final int BARRELS_EXPLODED_50 = 22;
+    private static final int BARRELS_EXPLODED_100 = 23;
+    public static final int LAST = 24;
+
+    public static final Achievement[] LIST = {
+            new Achievement(MONSTERS_KILLED_5,
+                    STAT_MONSTERS_KILLED,
+                    5,
+                    R.string.achievements_t_monsters_killed_5,
+                    R.string.achievements_d_monsters_killed_5,
+                    false),
+            new Achievement(MONSTERS_KILLED_50,
+                    STAT_MONSTERS_KILLED,
+                    50,
+                    R.string.achievements_t_monsters_killed_50,
+                    R.string.achievements_d_monsters_killed_50,
+                    false),
+            new Achievement(MONSTERS_KILLED_500,
+                    STAT_MONSTERS_KILLED,
+                    500,
+                    R.string.achievements_t_monsters_killed_500,
+                    R.string.achievements_d_monsters_killed_500,
+                    false),
+            new Achievement(MONSTERS_KILLED_2500,
+                    STAT_MONSTERS_KILLED,
+                    2500,
+                    R.string.achievements_t_monsters_killed_2500,
+                    R.string.achievements_d_monsters_killed_2500,
+                    false),
+            new Achievement(MONSTERS_KILLED_5000,
+                    STAT_MONSTERS_KILLED,
+                    5000,
+                    R.string.achievements_t_monsters_killed_5000,
+                    R.string.achievements_d_monsters_killed_5000,
+                    false),
+            new Achievement(P100_KILLS_ROW_5,
+                    STAT_P100_KILLS_ROW,
+                    5,
+                    R.string.achievements_t_p100_kills_row_5,
+                    R.string.achievements_d_p100_kills_row_5,
+                    false),
+            new Achievement(P100_KILLS_ROW_10,
+                    STAT_P100_KILLS_ROW,
+                    10,
+                    R.string.achievements_t_p100_kills_row_10,
+                    R.string.achievements_d_p100_kills_row_10,
+                    false),
+
+            new Achievement(SECRETS_FOUND_5,
+                    STAT_SECRETS_FOUND,
+                    5,
+                    R.string.achievements_t_secrets_found_5,
+                    R.string.achievements_d_secrets_found_5,
+                    true),
+            new Achievement(SECRETS_FOUND_10,
+                    STAT_SECRETS_FOUND,
+                    10,
+                    R.string.achievements_t_secrets_found_10,
+                    R.string.achievements_d_secrets_found_10,
+                    true),
+            new Achievement(SECRETS_FOUND_15,
+                    STAT_SECRETS_FOUND,
+                    15,
+                    R.string.achievements_t_secrets_found_15,
+                    R.string.achievements_d_secrets_found_15,
+                    true),
+            new Achievement(SECRETS_FOUND_20,
+                    STAT_SECRETS_FOUND,
+                    20,
+                    R.string.achievements_t_secrets_found_20,
+                    R.string.achievements_d_secrets_found_20,
+                    true),
+            new Achievement(SECRETS_FOUND_30,
+                    STAT_SECRETS_FOUND,
+                    30,
+                    R.string.achievements_t_secrets_found_30,
+                    R.string.achievements_d_secrets_found_30,
+                    true),
+            new Achievement(P100_SECRETS_ROW_5,
+                    STAT_P100_SECRETS_ROW,
+                    5,
+                    R.string.achievements_t_p100_secrets_row_5,
+                    R.string.achievements_d_p100_secrets_row_5,
+                    true),
+            new Achievement(P100_SECRETS_ROW_10,
+                    STAT_P100_SECRETS_ROW,
+                    10,
+                    R.string.achievements_t_p100_secrets_row_10,
+                    R.string.achievements_d_p100_secrets_row_10,
+                    true),
+
+            new Achievement(BARRELS_EXPLODED_1,
+                    STAT_BARRELS_EXPLODED,
+                    1,
+                    R.string.achievements_t_barrels_exploded_1,
+                    R.string.achievements_d_barrels_exploded_1,
+                    false),
+            new Achievement(BARRELS_EXPLODED_5,
+                    STAT_BARRELS_EXPLODED,
+                    5,
+                    R.string.achievements_t_barrels_exploded_5,
+                    R.string.achievements_d_barrels_exploded_5,
+                    false),
+            new Achievement(BARRELS_EXPLODED_25,
+                    STAT_BARRELS_EXPLODED,
+                    25,
+                    R.string.achievements_t_barrels_exploded_25,
+                    R.string.achievements_d_barrels_exploded_25,
+                    false),
+            new Achievement(BARRELS_EXPLODED_50,
+                    STAT_BARRELS_EXPLODED,
+                    50,
+                    R.string.achievements_t_barrels_exploded_50,
+                    R.string.achievements_d_barrels_exploded_50,
+                    false),
+            new Achievement(BARRELS_EXPLODED_100,
+                    STAT_BARRELS_EXPLODED,
+                    100,
+                    R.string.achievements_t_barrels_exploded_100,
+                    R.string.achievements_d_barrels_exploded_100,
+                    false),
+
+            new Achievement(DOORS_OPENED_5,
+                    STAT_DOORS_OPENED,
+                    5,
+                    R.string.achievements_t_doors_opened_5,
+                    R.string.achievements_d_doors_opened_5,
+                    true),
+            new Achievement(DOORS_OPENED_10,
+                    STAT_DOORS_OPENED,
+                    10,
+                    R.string.achievements_t_doors_opened_10,
+                    R.string.achievements_d_doors_opened_10,
+                    true),
+            new Achievement(DOORS_OPENED_25,
+                    STAT_DOORS_OPENED,
+                    25,
+                    R.string.achievements_t_doors_opened_25,
+                    R.string.achievements_d_doors_opened_25,
+                    true),
+            new Achievement(DOORS_OPENED_50,
+                    STAT_DOORS_OPENED,
+                    50,
+                    R.string.achievements_t_doors_opened_50,
+                    R.string.achievements_d_doors_opened_50,
+                    true),
+            new Achievement(DOORS_OPENED_75,
+                    STAT_DOORS_OPENED,
+                    75,
+                    R.string.achievements_t_doors_opened_75,
+                    R.string.achievements_d_doors_opened_75,
+                    true),
+    };
+
+    private Achievements() {}
+
+    public static void resetStat(int statId, @SuppressWarnings("unused") Profile profile, Engine engine, State state) {
+        if (!engine.inWallpaperMode) {
+            state.stats[statId] = 0;
+        }
+    }
+
+    public static void updateStat(int statId, Profile profile, Engine engine, State state) {
+        if (engine.inWallpaperMode) {
+            return;
+        }
+
+        state.stats[statId]++;
+
+        for (Achievement achievement : LIST) {
+            if (achievement.statId == statId) {
+                achievement.update(profile, engine, state);
+            }
+        }
+
+        profile.update(engine.activity);
+    }
+
+    public static String cleanupTitle(String achievementTitle) {
+        return achievementTitle.replaceAll("<font.+?font>", "").trim();
+    }
+}
diff --git a/src/main/java/zame/game/store/AchievementsAdapter.java b/src/main/java/zame/game/feature/achievements/AchievementsAdapter.java
similarity index 82%
rename from src/main/java/zame/game/store/AchievementsAdapter.java
rename to src/main/java/zame/game/feature/achievements/AchievementsAdapter.java
index 01f2338..30f88cb 100644
--- a/src/main/java/zame/game/store/AchievementsAdapter.java
+++ b/src/main/java/zame/game/feature/achievements/AchievementsAdapter.java
@@ -1,25 +1,30 @@
-package zame.game.store;
+package zame.game.feature.achievements;
 
 import android.content.Context;
 import android.content.res.Resources;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
 import android.text.Html;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.BaseAdapter;
 import android.widget.TextView;
-import zame.game.MainActivity;
 import zame.game.R;
-import zame.game.engine.State;
-import zame.game.store.achievements.Achievement;
+import zame.game.engine.state.Profile;
+import zame.game.engine.state.State;
+import zame.game.feature.main.MainActivity;
 
 public class AchievementsAdapter extends BaseAdapter {
     public static class ItemViewHolder {
+        ViewGroup viewGroup;
         TextView titleText;
         TextView descriptionText;
         TextView statusText;
 
         ItemViewHolder(ViewGroup viewGroup) {
+            this.viewGroup = viewGroup;
+
             titleText = viewGroup.findViewById(R.id.title);
             descriptionText = viewGroup.findViewById(R.id.description);
             statusText = viewGroup.findViewById(R.id.status);
@@ -31,11 +36,12 @@ public class AchievementsAdapter extends BaseAdapter {
     private State state;
     private LayoutInflater layoutInflater;
     private Achievement[] items;
+    private Drawable altBgDrawable;
     private int colorLocked;
     private int colorAchieved;
     private String textAchieved;
 
-    public AchievementsAdapter(MainActivity activity, Profile profile) {
+    AchievementsAdapter(MainActivity activity, Profile profile) {
         super();
 
         this.activity = activity;
@@ -46,6 +52,7 @@ public class AchievementsAdapter extends BaseAdapter {
         items = Achievements.LIST;
         Resources resources = activity.getResources();
 
+        altBgDrawable = new ColorDrawable(resources.getColor(R.color.gloomy_achievements_altbg));
         colorLocked = resources.getColor(R.color.gloomy_achievements_locked);
         colorAchieved = resources.getColor(R.color.gloomy_achievements_achieved);
         textAchieved = resources.getString(R.string.achievements_item_achieved);
@@ -87,13 +94,14 @@ public class AchievementsAdapter extends BaseAdapter {
             viewGroup = (ViewGroup)convertView;
             holder = (ItemViewHolder)viewGroup.getTag();
         } else {
-            viewGroup = (ViewGroup)layoutInflater.inflate(R.layout.list_achievement, parent, false);
+            viewGroup = (ViewGroup)layoutInflater.inflate(R.layout.achievements_item, parent, false);
             holder = new ItemViewHolder(viewGroup);
             viewGroup.setTag(holder);
         }
 
         Achievement item = items[position];
 
+        holder.viewGroup.setBackground(item.isAltBackground ? altBgDrawable : null);
         holder.titleText.setText(Html.fromHtml(activity.getString(item.titleResourceId).toUpperCase()));
         holder.descriptionText.setText(Html.fromHtml(activity.getString(item.descriptionResourceId)));
 
diff --git a/src/main/java/zame/game/fragments/AchievementsFragment.java b/src/main/java/zame/game/feature/achievements/AchievementsFragment.java
similarity index 78%
rename from src/main/java/zame/game/fragments/AchievementsFragment.java
rename to src/main/java/zame/game/feature/achievements/AchievementsFragment.java
index ec3b2b7..851f9ea 100644
--- a/src/main/java/zame/game/fragments/AchievementsFragment.java
+++ b/src/main/java/zame/game/feature/achievements/AchievementsFragment.java
@@ -1,4 +1,4 @@
-package zame.game.fragments;
+package zame.game.feature.achievements;
 
 import android.content.Context;
 import android.os.Bundle;
@@ -11,14 +11,22 @@ import android.widget.ListView;
 import android.widget.TextView;
 import zame.game.App;
 import zame.game.R;
-import zame.game.managers.SoundManager;
-import zame.game.store.AchievementsAdapter;
-import zame.game.store.Profile;
+import zame.game.feature.sound.SoundManager;
+import zame.game.core.app.BaseFragment;
+import zame.game.engine.state.Profile;
 
 public class AchievementsFragment extends BaseFragment {
+    public static AchievementsFragment newInstance() {
+        return new AchievementsFragment();
+    }
+
     private Profile profile;
     private ListView itemsList;
 
+    public AchievementsFragment() {
+        super();
+    }
+
     @Override
     public void onAttach(Context context) {
         super.onAttach(context);
@@ -27,7 +35,7 @@ public class AchievementsFragment extends BaseFragment {
 
     @Override
     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-        ViewGroup viewGroup = (ViewGroup)inflater.inflate(R.layout.fragment_achievements, container, false);
+        ViewGroup viewGroup = (ViewGroup)inflater.inflate(R.layout.achievements_fragment, container, false);
 
         itemsList = viewGroup.findViewById(R.id.items);
         refreshAdapter();
@@ -44,7 +52,7 @@ public class AchievementsFragment extends BaseFragment {
         return viewGroup;
     }
 
-    protected void refreshAdapter() {
+    private void refreshAdapter() {
         BaseAdapter adapter = new AchievementsAdapter(activity, profile);
         itemsList.setAdapter(adapter);
         itemsList.setVisibility(View.VISIBLE);
diff --git a/src/main/java/zame/game/feature/consent/ConsentChooserFragment.java b/src/main/java/zame/game/feature/consent/ConsentChooserFragment.java
new file mode 100644
index 0000000..fde66a5
--- /dev/null
+++ b/src/main/java/zame/game/feature/consent/ConsentChooserFragment.java
@@ -0,0 +1,76 @@
+package zame.game.feature.consent;
+
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+import zame.game.App;
+import zame.game.R;
+import zame.game.core.app.BaseFragment;
+import zame.game.feature.sound.SoundManager;
+
+public class ConsentChooserFragment extends BaseFragment {
+    public static ConsentChooserFragment newInstance() {
+        return new ConsentChooserFragment();
+    }
+
+    private Button backButtonView;
+    private Button nextButtonView;
+
+    public ConsentChooserFragment() {
+        super();
+    }
+
+    @Nullable
+    @Override
+    public View onCreateView(@NonNull LayoutInflater inflater,
+            @Nullable ViewGroup container,
+            @Nullable Bundle savedInstanceState) {
+
+        ViewGroup viewGroup = (ViewGroup)inflater.inflate(R.layout.consent_fragment, container, false);
+
+        backButtonView = viewGroup.findViewById(R.id.back);
+        nextButtonView = viewGroup.findViewById(R.id.next);
+
+        return viewGroup;
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+
+        backButtonView.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                activity.quitGame();
+            }
+        });
+
+        nextButtonView.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                App.self.preferences.putBoolean(R.string.key_is_consent_chosen, true);
+                App.self.applyConsent();
+
+                activity.processNext();
+            }
+        });
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        activity.soundManager.setPlaylist(SoundManager.LIST_MAIN);
+    }
+
+    @Override
+    public void onStop() {
+        backButtonView.setOnClickListener(null);
+        nextButtonView.setOnClickListener(null);
+
+        super.onStop();
+    }
+}
diff --git a/src/main/java/zame/game/feature/consent/ConsentPreferencesFragment.java b/src/main/java/zame/game/feature/consent/ConsentPreferencesFragment.java
new file mode 100644
index 0000000..9d756a9
--- /dev/null
+++ b/src/main/java/zame/game/feature/consent/ConsentPreferencesFragment.java
@@ -0,0 +1,16 @@
+package zame.game.feature.consent;
+
+import android.os.Bundle;
+import com.takisoft.fix.support.v7.preference.PreferenceFragmentCompat;
+import zame.game.R;
+
+public class ConsentPreferencesFragment extends PreferenceFragmentCompat {
+    public ConsentPreferencesFragment() {
+        super();
+    }
+
+    @Override
+    public void onCreatePreferencesFix(Bundle savedInstanceState, String rootKey) {
+        addPreferencesFromResource(R.xml.preferences_consent);
+    }
+}
diff --git a/src/main/java/zame/game/fragments/dialogs/GameCodeDialogFragment.java b/src/main/java/zame/game/feature/game/GameCodeDialogFragment.java
similarity index 74%
rename from src/main/java/zame/game/fragments/dialogs/GameCodeDialogFragment.java
rename to src/main/java/zame/game/feature/game/GameCodeDialogFragment.java
index 74fd5ec..75460f1 100644
--- a/src/main/java/zame/game/fragments/dialogs/GameCodeDialogFragment.java
+++ b/src/main/java/zame/game/feature/game/GameCodeDialogFragment.java
@@ -1,4 +1,4 @@
-package zame.game.fragments.dialogs;
+package zame.game.feature.game;
 
 import android.annotation.SuppressLint;
 import android.app.Dialog;
@@ -11,19 +11,20 @@ import android.view.LayoutInflater;
 import android.view.ViewGroup;
 import android.widget.EditText;
 import zame.game.App;
-import zame.game.MainActivity;
+import zame.game.feature.main.MainActivity;
 import zame.game.R;
+import zame.game.core.app.BaseDialogFragment;
 import zame.game.engine.Engine;
-import zame.game.managers.SoundManager;
+import zame.game.feature.sound.SoundManager;
 
 public class GameCodeDialogFragment extends BaseDialogFragment {
-    protected MainActivity activity;
-    protected Engine engine;
-
     public static GameCodeDialogFragment newInstance() {
         return new GameCodeDialogFragment();
     }
 
+    private MainActivity activity;
+    private Engine engine;
+
     public GameCodeDialogFragment() {
         super();
     }
@@ -40,20 +41,20 @@ public class GameCodeDialogFragment extends BaseDialogFragment {
     @Override
     public Dialog onCreateDialog(Bundle savedInstanceState) {
         @SuppressLint("InflateParams")
-        final ViewGroup viewGroup = (ViewGroup)LayoutInflater.from(activity).inflate(R.layout.dialog_game_code, null);
+        final ViewGroup viewGroup = (ViewGroup)LayoutInflater.from(activity).inflate(R.layout.game_dialog_code, null);
 
         return new AlertDialog.Builder(activity).setIcon(R.drawable.ic_dialog_alert)
-                .setTitle(R.string.dlg_enter_code)
+                .setTitle(R.string.game_enter_code)
                 .setView(viewGroup)
-                .setPositiveButton(R.string.dlg_ok, new DialogInterface.OnClickListener() {
+                .setPositiveButton(R.string.core_ok, new DialogInterface.OnClickListener() {
                     @Override
                     public void onClick(DialogInterface dialog, int whichButton) {
                         EditText editText = viewGroup.findViewById(R.id.code);
                         engine.game.unprocessedGameCode = editText.getText().toString();
-                        App.self.trackerInst.send("CodeEntered", engine.game.unprocessedGameCode);
+                        App.self.tracker.trackEvent("CodeEntered", engine.game.unprocessedGameCode);
                     }
                 })
-                .setNegativeButton(R.string.dlg_cancel, null)
+                .setNegativeButton(R.string.core_cancel, null)
                 .create();
     }
 
diff --git a/src/main/java/zame/game/feature/game/GameFragment.java b/src/main/java/zame/game/feature/game/GameFragment.java
new file mode 100644
index 0000000..99d3103
--- /dev/null
+++ b/src/main/java/zame/game/feature/game/GameFragment.java
@@ -0,0 +1,201 @@
+package zame.game.feature.game;
+
+import android.content.Context;
+import android.hardware.Sensor;
+import android.hardware.SensorEvent;
+import android.hardware.SensorEventListener;
+import android.hardware.SensorManager;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.view.LayoutInflater;
+import android.view.Surface;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.FrameLayout;
+import zame.game.R;
+import zame.game.core.app.BaseFragment;
+import zame.game.engine.Config;
+import zame.game.engine.Engine;
+import zame.game.engine.Game;
+import zame.game.engine.controller.HeroController;
+import zame.game.feature.sound.SoundManager;
+
+public class GameFragment extends BaseFragment implements SensorEventListener {
+    public static GameFragment newInstance() {
+        return new GameFragment();
+    }
+
+    private ViewGroup viewGroup;
+    private GameView gameView;
+    private Engine engine;
+    private Game game;
+    private SensorManager sensorManager;
+    private int deviceRotation;
+    private GameMenuDialogFragment gameMenuDialogFragment;
+    private GameCodeDialogFragment gameCodeDialogFragment;
+
+    public Config config;
+    public HeroController heroController;
+
+    public GameFragment() {
+        super();
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        this.engine = activity.engine;
+        this.config = engine.config;
+        this.heroController = engine.heroController;
+        this.game = engine.game;
+
+        gameMenuDialogFragment = GameMenuDialogFragment.newInstance();
+        gameCodeDialogFragment = GameCodeDialogFragment.newInstance();
+    }
+
+    @Override
+    public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        viewGroup = (ViewGroup)inflater.inflate(R.layout.game_fragment, container, false);
+        return viewGroup;
+    }
+
+    @Override
+    @SuppressWarnings("deprecation")
+    public void onResume() {
+        super.onResume();
+
+        if (gameView != null) {
+            viewGroup.removeView(gameView);
+        }
+
+        gameView = new GameView(activity);
+
+        viewGroup.addView(gameView,
+                new FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
+
+        gameView.setRenderer(gameView);
+        engine.onActivated();
+        gameView.onResume();
+
+        if (config.accelerometerEnabled) {
+            sensorManager = (SensorManager)activity.getSystemService(Context.SENSOR_SERVICE);
+
+            if (sensorManager != null) {
+                Sensor accelerometer = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
+
+                // documentation says that getOrientation() is deprecated, and we must use getRotation instead()
+                // but getRotation() available only for >= 2.2
+                // if we look for getRotation() into android sources, we found nice piece of code:
+                // public int getRotation() { return getOrientation(); }
+                // so it should be safe to use getOrientation() instead of getRotation()
+                deviceRotation = activity.getWindowManager().getDefaultDisplay().getOrientation();
+                sensorManager.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_NORMAL);
+            }
+        } else {
+            sensorManager = null;
+        }
+
+        if (game.renderMode == Game.RENDER_MODE_END_LEVEL) {
+            activity.soundManager.setPlaylist(SoundManager.LIST_ENDL);
+        } else if (game.renderMode == Game.RENDER_MODE_GAME_OVER) {
+            activity.soundManager.setPlaylist(SoundManager.LIST_GAMEOVER);
+        } else {
+            activity.soundManager.setPlaylist(SoundManager.LIST_MAIN);
+        }
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+
+        if (gameView != null) {
+            gameView.onPause();
+            viewGroup.removeView(gameView);
+            gameView = null;
+        }
+
+        engine.onPause();
+
+        if (config.accelerometerEnabled && (sensorManager != null)) {
+            sensorManager.unregisterListener(this);
+        }
+    }
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+    }
+
+    @Override
+    public void onWindowFocusChanged(boolean hasWindowFocus) {
+        super.onWindowFocusChanged(hasWindowFocus);
+
+        if (hasWindowFocus) {
+            engine.onResume();
+        } else {
+            engine.onPause();
+        }
+    }
+
+    @Override
+    public void onAccuracyChanged(Sensor sensor, int accuracy) {
+    }
+
+    @Override
+    public void onSensorChanged(SensorEvent e) {
+        float sensorX;
+        float sensorY;
+
+        if (config.accelerometerEnabled && (e.sensor.getType() == Sensor.TYPE_ACCELEROMETER)) {
+            switch (deviceRotation) {
+                case Surface.ROTATION_90:
+                    sensorX = -e.values[1];
+                    sensorY = e.values[0];
+                    break;
+
+                case Surface.ROTATION_180:
+                    sensorX = -e.values[0];
+                    sensorY = -e.values[1];
+                    break;
+
+                case Surface.ROTATION_270:
+                    sensorX = e.values[1];
+                    sensorY = -e.values[0];
+                    break;
+
+                default:
+                    sensorX = e.values[0];
+                    sensorY = e.values[1];
+                    break;
+            }
+
+            float accelerometerX = sensorX / SensorManager.GRAVITY_EARTH;
+            float accelerometerY = sensorY / SensorManager.GRAVITY_EARTH;
+
+            if (config.rotateScreen) {
+                heroController.setAccelerometerValues(-accelerometerX, -accelerometerY);
+            } else {
+                heroController.setAccelerometerValues(accelerometerX, accelerometerY);
+            }
+        }
+    }
+
+    public void showGameMenu() {
+        gameMenuDialogFragment.show(getFragmentManager());
+    }
+
+    public void showGameCodeDialog() {
+        gameCodeDialogFragment.show(getFragmentManager());
+    }
+
+    // public void hideDialogs() {
+    // 	if (gameCodeDialogFragment.isVisible()) {
+    // 		gameCodeDialogFragment.dismiss();
+    // 	}
+    //
+    // 	if (gameMenuDialogFragment.isVisible()) {
+    // 		gameMenuDialogFragment.dismiss();
+    // 	}
+    // }
+}
diff --git a/src/main/java/zame/game/fragments/dialogs/GameMenuDialogFragment.java b/src/main/java/zame/game/feature/game/GameMenuDialogFragment.java
similarity index 89%
rename from src/main/java/zame/game/fragments/dialogs/GameMenuDialogFragment.java
rename to src/main/java/zame/game/feature/game/GameMenuDialogFragment.java
index be1a949..4a3b41a 100644
--- a/src/main/java/zame/game/fragments/dialogs/GameMenuDialogFragment.java
+++ b/src/main/java/zame/game/feature/game/GameMenuDialogFragment.java
@@ -1,4 +1,4 @@
-package zame.game.fragments.dialogs;
+package zame.game.feature.game;
 
 import android.annotation.SuppressLint;
 import android.app.Dialog;
@@ -20,14 +20,15 @@ import android.widget.BaseAdapter;
 import android.widget.ImageView;
 import android.widget.TextView;
 import java.util.ArrayList;
-import zame.game.Common;
-import zame.game.MainActivity;
 import zame.game.R;
+import zame.game.core.app.BaseDialogFragment;
+import zame.game.core.util.Common;
 import zame.game.engine.Engine;
-import zame.game.engine.State;
-import zame.game.engine.Weapons;
-import zame.game.engine.controls.Controls;
-import zame.game.managers.SoundManager;
+import zame.game.engine.state.State;
+import zame.game.engine.visual.Controls;
+import zame.game.engine.visual.Weapons;
+import zame.game.feature.main.MainActivity;
+import zame.game.feature.sound.SoundManager;
 
 // http://stackoverflow.com/questions/12239886/how-to-migrate-from-gallery-to-horizontalscrollview-viewpager
 // https://gist.github.com/8cbe094bb7a783e37ad1
@@ -186,6 +187,10 @@ public class GameMenuDialogFragment extends BaseDialogFragment {
         return new GameMenuDialogFragment();
     }
 
+    public GameMenuDialogFragment() {
+        super();
+    }
+
     @SuppressWarnings("MagicNumber")
     @Override
     public void onAttach(Context context) {
@@ -212,7 +217,7 @@ public class GameMenuDialogFragment extends BaseDialogFragment {
     @Override
     @SuppressWarnings("deprecation")
     public Dialog onCreateDialog(Bundle savedInstanceState) {
-        ViewGroup viewGroup = (ViewGroup)LayoutInflater.from(activity).inflate(R.layout.dialog_game_menu, null);
+        ViewGroup viewGroup = (ViewGroup)LayoutInflater.from(activity).inflate(R.layout.game_dialog_menu, null);
 
         int maxGalleryWidth = engine.width - paddingInPx;
 
@@ -238,12 +243,7 @@ public class GameMenuDialogFragment extends BaseDialogFragment {
                 int weaponIdx = (Integer)gallery.getItemAtPosition(position);
 
                 if (weapons.canSwitch(weaponIdx)) {
-                    if (engine.state.heroWeapon != weaponIdx) {
-                        weapons.switchWeapon(weaponIdx);
-                        engine.state.autoSelectWeapon = false;
-                        engine.interacted = true;
-                    }
-
+                    weapons.switchWeapon(weaponIdx);
                     ignoreDismissHandlerOnce = true;
                     GameMenuDialogFragment.this.dismiss();
                 }
@@ -254,13 +254,13 @@ public class GameMenuDialogFragment extends BaseDialogFragment {
 
         if ((state.disabledControlsMask & Controls.CONTROL_WEAPONS) != 0) {
             gallery.setVisibility(View.GONE);
-            builder = builder.setTitle(R.string.dlg_menu);
+            builder = builder.setTitle(R.string.game_menu_title_noweapon);
         } else {
-            builder = builder.setTitle(R.string.dlg_change_weapon);
+            builder = builder.setTitle(R.string.game_menu_title_weapon);
         }
 
         return builder.setView(viewGroup)
-                .setNeutralButton(R.string.dlg_exit_to_menu, new DialogInterface.OnClickListener() {
+                .setNeutralButton(R.string.game_menu_exit, new DialogInterface.OnClickListener() {
                     @Override
                     public void onClick(DialogInterface dialog, int whichButton) {
                         GameMenuDialogFragment.this.dismiss();
@@ -269,14 +269,14 @@ public class GameMenuDialogFragment extends BaseDialogFragment {
                         activity.showFragment(activity.menuFragment);
                     }
                 })
-                .setNegativeButton(R.string.dlg_game_code, new DialogInterface.OnClickListener() {
+                .setNegativeButton(R.string.game_menu_code, new DialogInterface.OnClickListener() {
                     @Override
                     public void onClick(DialogInterface dialog, int whichButton) {
                         GameMenuDialogFragment.this.dismiss();
                         activity.gameFragment.showGameCodeDialog();
                     }
                 })
-                .setPositiveButton(R.string.dlg_close, null)
+                .setPositiveButton(R.string.game_menu_close, null)
                 .create();
     }
 
@@ -288,15 +288,14 @@ public class GameMenuDialogFragment extends BaseDialogFragment {
 
     @Override
     public void onDismiss(DialogInterface dialog) {
-        if (!ignoreDismissHandlerOnce) {
-            int weaponId = (Integer)gallery.getSelectedItem();
+        if (ignoreDismissHandlerOnce) {
+            ignoreDismissHandlerOnce = false;
+        } else {
+            int weaponIdx = (Integer)gallery.getSelectedItem();
 
-            if ((engine.state.heroWeapon != weaponId) && weapons.canSwitch(weaponId)) {
-                weapons.switchWeapon(weaponId);
-                engine.state.autoSelectWeapon = false;
+            if (weapons.canSwitch(weaponIdx)) {
+                weapons.switchWeapon(weaponIdx);
             }
-        } else {
-            ignoreDismissHandlerOnce = false;
         }
 
         super.onDismiss(dialog);
diff --git a/src/main/java/zame/game/misc/GameView.java b/src/main/java/zame/game/feature/game/GameView.java
similarity index 83%
rename from src/main/java/zame/game/misc/GameView.java
rename to src/main/java/zame/game/feature/game/GameView.java
index 71fe816..12a12a4 100644
--- a/src/main/java/zame/game/misc/GameView.java
+++ b/src/main/java/zame/game/feature/game/GameView.java
@@ -1,4 +1,4 @@
-package zame.game.misc;
+package zame.game.feature.game;
 
 import android.annotation.SuppressLint;
 import android.content.Context;
@@ -8,15 +8,14 @@ import android.view.KeyEvent;
 import android.view.MotionEvent;
 import javax.microedition.khronos.egl.EGLConfig;
 import javax.microedition.khronos.opengles.GL10;
-import zame.game.Common;
-import zame.game.MainActivity;
+import zame.game.core.util.Common;
+import zame.game.feature.main.MainActivity;
 import zame.game.engine.Engine;
-import zame.game.engine.HeroController;
+import zame.game.engine.controller.HeroController;
 
-public class GameView extends zame.game.libs.GLSurfaceView21 implements zame.game.libs.GLSurfaceView21.Renderer {
-    protected MainActivity activity;
-    protected Engine engine;
-    protected HeroController heroController;
+public class GameView extends zame.game.core.widget.GLSurfaceView21 implements zame.game.core.widget.GLSurfaceView21.Renderer {
+    private Engine engine;
+    private HeroController heroController;
 
     public GameView(Context context) {
         super(context);
@@ -29,8 +28,7 @@ public class GameView extends zame.game.libs.GLSurfaceView21 implements zame.gam
     }
 
     public void initialize(Context context) {
-        this.activity = (MainActivity)context;
-        this.engine = activity.engine;
+        this.engine = ((MainActivity)context).engine;
         this.heroController = engine.heroController;
 
         //noinspection MagicNumber
diff --git a/src/main/java/zame/game/misc/MapImageGenerator.java b/src/main/java/zame/game/feature/game/MapImageGenerator.java
similarity index 94%
rename from src/main/java/zame/game/misc/MapImageGenerator.java
rename to src/main/java/zame/game/feature/game/MapImageGenerator.java
index 4a17809..6e4a4d1 100644
--- a/src/main/java/zame/game/misc/MapImageGenerator.java
+++ b/src/main/java/zame/game/feature/game/MapImageGenerator.java
@@ -1,4 +1,4 @@
-package zame.game.misc;
+package zame.game.feature.game;
 
 import android.content.res.Resources;
 import android.graphics.Bitmap;
@@ -7,10 +7,10 @@ import android.graphics.Canvas;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Random;
-import zame.game.Common;
+import zame.game.core.util.Common;
 import zame.game.R;
 
-public final class MapImageGenerator {
+final class MapImageGenerator {
     private static final int MAP_WIDTH = 9;
     private static final int MAP_HEIGHT = 5;
     private static final int CELL_WIDTH = 40;
@@ -26,7 +26,7 @@ public final class MapImageGenerator {
         }
     }
 
-    public static class MapPath {
+    static class MapPath {
         List<MapPathItem> path;
         int width;
         int height;
@@ -38,13 +38,13 @@ public final class MapImageGenerator {
         }
     }
 
-    public static class MapImageBitmaps {
+    static class MapImageBitmaps {
         Bitmap cell;
         Bitmap cellHl;
         Bitmap connHor;
         Bitmap connVert;
 
-        public MapImageBitmaps(Resources resources) {
+        MapImageBitmaps(Resources resources) {
             BitmapFactory.Options opts = new BitmapFactory.Options();
             opts.inDither = false;
             opts.inPurgeable = true;
@@ -60,7 +60,7 @@ public final class MapImageGenerator {
     private MapImageGenerator() {
     }
 
-    public static Bitmap generateMapImage(MapPath mapPath, int highlighted, MapImageBitmaps bmps) {
+    static Bitmap generateMapImage(MapPath mapPath, int highlighted, MapImageBitmaps bmps) {
         //noinspection MagicNumber
         float xoff = (float)Math.floor((float)(MAP_WIDTH - mapPath.width) / 2.0f * (float)CELL_WIDTH);
 
@@ -119,7 +119,7 @@ public final class MapImageGenerator {
     }
 
     @SuppressWarnings("MagicNumber")
-    public static MapPath generateMapPath(int seed, int len) {
+    static MapPath generateMapPath(int seed, int len) {
         if (seed < 0) {
             seed = 100 - seed;
         }
diff --git a/src/main/java/zame/game/fragments/SelectEpisodeFragment.java b/src/main/java/zame/game/feature/game/SelectEpisodeFragment.java
similarity index 82%
rename from src/main/java/zame/game/fragments/SelectEpisodeFragment.java
rename to src/main/java/zame/game/feature/game/SelectEpisodeFragment.java
index c96d788..c08825f 100644
--- a/src/main/java/zame/game/fragments/SelectEpisodeFragment.java
+++ b/src/main/java/zame/game/feature/game/SelectEpisodeFragment.java
@@ -1,4 +1,4 @@
-package zame.game.fragments;
+package zame.game.feature.game;
 
 import android.content.Context;
 import android.os.Bundle;
@@ -9,22 +9,32 @@ import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ImageView;
-import android.widget.ScrollView;
 import android.widget.TextView;
 import java.util.Timer;
 import java.util.TimerTask;
 import zame.game.App;
-import zame.game.Common;
+import zame.game.core.util.Common;
 import zame.game.R;
-import zame.game.engine.State;
-import zame.game.managers.SoundManager;
-import zame.game.misc.MapImageGenerator;
-import zame.game.store.Profile;
-import zame.game.store.ProfileLevel;
+import zame.game.core.app.BaseFragment;
+import zame.game.engine.state.State;
+import zame.game.feature.sound.SoundManager;
+import zame.game.engine.state.Profile;
+import zame.game.engine.state.ProfileLevel;
 
 public class SelectEpisodeFragment extends BaseFragment {
     private static final SparseArrayCompat<Integer> EPISODE_NAME_MAP = new SparseArrayCompat<>();
 
+    static {
+        EPISODE_NAME_MAP.put(-1, R.string.game_pt_tutorial);
+        EPISODE_NAME_MAP.put(1, R.string.game_pt_episode_1);
+        EPISODE_NAME_MAP.put(2, R.string.game_pt_episode_2);
+        EPISODE_NAME_MAP.put(3, R.string.game_pt_episode_3);
+    }
+
+    public static SelectEpisodeFragment newInstance() {
+        return new SelectEpisodeFragment();
+    }
+
     private ViewGroup viewGroup;
     private ImageView[] images = new ImageView[2];
     private int currentImageIdx;
@@ -36,13 +46,6 @@ public class SelectEpisodeFragment extends BaseFragment {
     private MapImageGenerator.MapImageBitmaps mapImageBitmaps;
     private SparseArrayCompat<MapImageGenerator.MapPath> mapPathsHash = new SparseArrayCompat<>();
 
-    static {
-        EPISODE_NAME_MAP.put(-1, R.string.pt_tutorial);
-        EPISODE_NAME_MAP.put(1, R.string.pt_episode_1);
-        EPISODE_NAME_MAP.put(2, R.string.pt_episode_2);
-        EPISODE_NAME_MAP.put(3, R.string.pt_episode_3);
-    }
-
     private final Runnable switchImagesRunnable = new Runnable() {
         @Override
         public void run() {
@@ -60,6 +63,10 @@ public class SelectEpisodeFragment extends BaseFragment {
         }
     };
 
+    public SelectEpisodeFragment() {
+        super();
+    }
+
     @Override
     public void onAttach(Context context) {
         super.onAttach(context);
@@ -70,7 +77,7 @@ public class SelectEpisodeFragment extends BaseFragment {
 
     @Override
     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-        viewGroup = (ViewGroup)inflater.inflate(R.layout.fragment_select_episode, container, false);
+        viewGroup = (ViewGroup)inflater.inflate(R.layout.game_fragment_select_episode, container, false);
 
         images[0] = viewGroup.findViewById(R.id.image_1);
         images[1] = viewGroup.findViewById(R.id.image_2);
@@ -93,6 +100,11 @@ public class SelectEpisodeFragment extends BaseFragment {
         return viewGroup;
     }
 
+    @Override
+    protected void onShowBanner() {
+        App.self.mediadtor.showBanner(activity, (ViewGroup)viewGroup.findViewById(R.id.banner_wrapper));
+    }
+
     @Override
     public void onResume() {
         super.onResume();
@@ -115,18 +127,19 @@ public class SelectEpisodeFragment extends BaseFragment {
                 ? profile.getLevel(state.levelName)
                 : profile.getLevel(State.LEVEL_INITIAL);
 
-        ((TextView)viewGroup.findViewById(R.id.info)).setText(String.format(getString(R.string.se_info),
+        ((TextView)viewGroup.findViewById(R.id.info)).setText(String.format(getString(R.string.game_se_info),
                 state.overallMonsters,
-                state.overallItems,
                 state.overallSecrets,
-                Common.getTimeString(state.overallSeconds)));
+                Common.getTimeString(state.overallSeconds),
+                state.overallDeaths,
+                state.overallResurrects));
 
         if (level.characterResId != 0) {
             ((ImageView)viewGroup.findViewById(R.id.character)).setImageResource(level.characterResId);
         }
 
         Integer episodeNameResId = EPISODE_NAME_MAP.get(level.episode);
-        String episodeName = getString(episodeNameResId == null ? R.string.app_name : episodeNameResId);
+        String episodeName = getString(episodeNameResId == null ? R.string.core_app_name : episodeNameResId);
 
         ((TextView)viewGroup.findViewById(R.id.episode)).setText(episodeName);
         MapImageGenerator.MapPath mapPath = mapPathsHash.get(level.episode);
diff --git a/src/main/java/zame/game/LauncherActivity.java b/src/main/java/zame/game/feature/launcher/LauncherActivity.java
similarity index 50%
rename from src/main/java/zame/game/LauncherActivity.java
rename to src/main/java/zame/game/feature/launcher/LauncherActivity.java
index 7ed8082..aac5daa 100644
--- a/src/main/java/zame/game/LauncherActivity.java
+++ b/src/main/java/zame/game/feature/launcher/LauncherActivity.java
@@ -1,14 +1,14 @@
-package zame.game;
+package zame.game.feature.launcher;
 
+import android.content.Context;
 import android.content.Intent;
-import android.os.Handler;
-import android.support.v7.app.AppCompatActivity;
+import zame.game.App;
+import zame.game.core.app.BaseActivity;
+import zame.game.feature.main.MainActivity;
 
-public class LauncherActivity extends AppCompatActivity {
+public class LauncherActivity extends BaseActivity {
     private static final long START_GAME_DELAY = 1500L;
 
-    private final Handler handler = new Handler();
-
     private final Runnable startGameRunnable = new Runnable() {
         @Override
         public void run() {
@@ -17,15 +17,20 @@ public class LauncherActivity extends AppCompatActivity {
         }
     };
 
+    @Override
+    protected Context wrapBaseContext(Context newBase) {
+        return newBase;
+    }
+
     @Override
     protected void onStart() {
         super.onStart();
-        handler.postDelayed(startGameRunnable, START_GAME_DELAY);
+        App.self.handler.postDelayed(startGameRunnable, START_GAME_DELAY);
     }
 
     @Override
     protected void onStop() {
-        handler.removeCallbacks(startGameRunnable);
+        App.self.handler.removeCallbacks(startGameRunnable);
         super.onStop();
     }
 }
diff --git a/src/main/java/zame/game/MainActivity.java b/src/main/java/zame/game/feature/main/MainActivity.java
similarity index 66%
rename from src/main/java/zame/game/MainActivity.java
rename to src/main/java/zame/game/feature/main/MainActivity.java
index f517bbf..adb0bdc 100644
--- a/src/main/java/zame/game/MainActivity.java
+++ b/src/main/java/zame/game/feature/main/MainActivity.java
@@ -1,4 +1,4 @@
-package zame.game;
+package zame.game.feature.main;
 
 import android.content.Intent;
 import android.media.AudioManager;
@@ -7,39 +7,43 @@ import android.os.Handler;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentTransaction;
 import android.support.v7.app.ActionBar;
-import android.support.v7.app.AppCompatActivity;
+import android.view.View;
+import com.eightsines.esmediadtor.MediadtorListener;
+import zame.game.App;
+import zame.game.R;
+import zame.game.core.app.ActionBarFragment;
+import zame.game.core.app.BackPressedHandler;
+import zame.game.core.app.BaseActivity;
+import zame.game.core.app.BaseFragment;
+import zame.game.core.util.Common;
 import zame.game.engine.Engine;
-import zame.game.engine.State;
-import zame.game.fragments.AchievementsFragment;
-import zame.game.fragments.ActionBarFragment;
-import zame.game.fragments.BaseFragment;
-import zame.game.fragments.GameFragment;
-import zame.game.fragments.MenuFragment;
-import zame.game.fragments.OptionsFragment;
-import zame.game.fragments.PrepareFragment;
-import zame.game.fragments.SelectEpisodeFragment;
-import zame.game.fragments.dialogs.QuitWarnDialogFragment;
-import zame.game.managers.SoundManager;
-import zame.game.providers.CachedTexturesProvider;
-
-public class MainActivity extends AppCompatActivity {
-    public interface BackPressedHandler {
-        boolean onBackPressed();
-    }
-
+import zame.game.engine.state.State;
+import zame.game.feature.achievements.AchievementsFragment;
+import zame.game.feature.consent.ConsentChooserFragment;
+import zame.game.feature.game.GameFragment;
+import zame.game.feature.game.SelectEpisodeFragment;
+import zame.game.feature.menu.MenuFragment;
+import zame.game.feature.menu.QuitWarnDialogFragment;
+import zame.game.feature.options.OptionsFragment;
+import zame.game.feature.prepare.CachedTexturesProvider;
+import zame.game.feature.prepare.PrepareFragment;
+import zame.game.feature.sound.SoundManager;
+import zame.game.flavour.gplay.MainActivityGPlayHelper;
+
+public class MainActivity extends BaseActivity {
     private static final String TAG_FRAGMENT_CURRENT = "MainActivity.CurrentFragment";
 
-    public static MainActivity self;
-
     public SoundManager soundManager;
     public Engine engine;
+
+    private PrepareFragment prepareFragment;
+    private ConsentChooserFragment consentChooserFragment;
     public MenuFragment menuFragment;
-    public SelectEpisodeFragment selectEpisodeFragment;
-    public GameFragment gameFragment;
     public OptionsFragment optionsFragment;
     public AchievementsFragment achievementsFragment;
-    public PrepareFragment prepareFragment;
-    public QuitWarnDialogFragment quitWarnDialogFragment;
+    public SelectEpisodeFragment selectEpisodeFragment;
+    public GameFragment gameFragment;
+    private QuitWarnDialogFragment quitWarnDialogFragment;
 
     private Fragment currentFragment;
     @SuppressWarnings("FieldCanBeLocal") private Fragment prevFragment;
@@ -52,54 +56,59 @@ public class MainActivity extends AppCompatActivity {
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
 
-        // forceLocale(new Locale("ru"));
-        // ViewServer.get(this).addWindow(this);
+        setContentView(R.layout.main_activity);
+        setVolumeControlStream(AudioManager.STREAM_MUSIC);
+
+        ActionBar actionBar = getSupportActionBar();
+
+        if (actionBar != null) {
+            actionBar.hide();
+        }
 
         soundManager = SoundManager.getInstance(false);
         soundManager.initialize();
 
         engine = new Engine(this);
 
-        menuFragment = new MenuFragment();
-        selectEpisodeFragment = new SelectEpisodeFragment();
-        gameFragment = new GameFragment();
-        optionsFragment = new OptionsFragment();
-        achievementsFragment = new AchievementsFragment();
-        prepareFragment = new PrepareFragment();
-
+        prepareFragment = PrepareFragment.newInstance();
+        consentChooserFragment = ConsentChooserFragment.newInstance();
+        menuFragment = MenuFragment.newInstance();
+        optionsFragment = OptionsFragment.newInstance();
+        achievementsFragment = AchievementsFragment.newInstance();
+        selectEpisodeFragment = SelectEpisodeFragment.newInstance();
+        gameFragment = GameFragment.newInstance();
         quitWarnDialogFragment = QuitWarnDialogFragment.newInstance();
-        gPlayHelper.onCreate();
-
-        setContentView(R.layout.activity_main);
-        setVolumeControlStream(AudioManager.STREAM_MUSIC);
-        self = this;
-
-        ActionBar actionBar = getSupportActionBar();
-        assert actionBar != null;
 
-        actionBar.hide();
+        gPlayHelper.onCreate();
+        processNext();
+    }
 
+    public void processNext() {
         if (App.self.cachedTexturesTask != null || CachedTexturesProvider.needToUpdateCache()) {
             showFragment(prepareFragment);
-        } else {
-            showFragment(menuFragment);
+            return;
+        }
+
+        if (!App.self.preferences.getBoolean(R.string.key_is_consent_chosen)) {
+            showFragment(consentChooserFragment);
+            return;
         }
+
+        showFragment(menuFragment);
+
+        App.self.mediadtor.onActivityCreate(this, new MediadtorListener() {
+            @Override
+            public void onRewardedVideoClosed(boolean shouldGiveReward) {
+                engine.onRewardedVideoClosed(shouldGiveReward);
+            }
+        });
     }
 
-    // private void forceLocale(Locale locale) {
-    //     Locale.setDefault(locale);
-    //
-    //     Resources res = getResources();
-    //     Configuration conf = res.getConfiguration();
-    //
-    //     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
-    //         conf.setLocale(locale);
-    //     } else {
-    //         conf.locale = locale;
-    //     }
-    //
-    //     res.updateConfiguration(conf, res.getDisplayMetrics());
-    // }
+    @Override
+    protected void onResume() {
+        super.onResume();
+        App.self.mediadtor.onActivityResume(this);
+    }
 
     @Override
     public void onWindowFocusChanged(boolean hasFocus) {
@@ -113,20 +122,23 @@ public class MainActivity extends AppCompatActivity {
 
     @Override
     protected void onPause() {
-        soundManager.onWindowFocusChanged(false, SoundManager.FOCUS_MASK_MAIN_ACTIVITY);
+        if (soundManager != null) {
+            soundManager.onWindowFocusChanged(false, SoundManager.FOCUS_MASK_MAIN_ACTIVITY);
+        }
+
+        App.self.mediadtor.onActivityPause();
 
-        // if home screen button pressed, lock screen button pressed, call received or something similar - return to menu screen
-        /*
-        if (currentFragment == gameFragment) {
-			gameFragment.hideDialogs();
-			showFragment(menuFragment);
-		}
-		*/
+        // if home screen button_positive pressed, lock screen button_positive pressed, call received or something similar - return to menu screen
+        //
+        // if (currentFragment == gameFragment) {
+        // 	gameFragment.hideDialogs();
+        // 	showFragment(menuFragment);
+        // }
 
         super.onPause();
     }
 
-    public synchronized void showFragment(final Fragment fragment) {
+    public void showFragment(final Fragment fragment) {
         handler.post(new Runnable() {
             @Override
             public void run() {
@@ -151,6 +163,8 @@ public class MainActivity extends AppCompatActivity {
             getSupportFragmentManager().executePendingTransactions(); // fix for black-screen issue
         } catch (Exception ex) {
             Common.log(ex.toString());
+            recreate();
+            return;
         }
 
         FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
@@ -162,14 +176,10 @@ public class MainActivity extends AppCompatActivity {
 
         try {
             transaction.commit();
-
-            try {
-                getSupportFragmentManager().executePendingTransactions(); // fix FC due to "java.lang.IllegalStateException: Fragment already added"
-            } catch (Exception ex) {
-                Common.log(ex);
-            }
+            getSupportFragmentManager().executePendingTransactions();
         } catch (Exception ex) {
             Common.log(ex.toString());
+            recreate();
         }
     }
 
@@ -230,6 +240,11 @@ public class MainActivity extends AppCompatActivity {
             return;
         }
 
+        if (currentFragment == consentChooserFragment) {
+            quitGame();
+            return;
+        }
+
         if ((currentFragment instanceof BackPressedHandler)
                 && currentFragment.isVisible()
                 && ((BackPressedHandler)currentFragment).onBackPressed()) {
@@ -256,19 +271,20 @@ public class MainActivity extends AppCompatActivity {
 
     @Override
     protected void onDestroy() {
-        self = null;
-        soundManager.shutdown();
+        if (soundManager != null) {
+            soundManager.shutdown();
+        }
 
         super.onDestroy();
     }
 
     public boolean tryAndLoadInstantState() {
         if (!engine.hasInstantSave()) {
-            engine.state.init();
+            engine.state.reload();
             return false;
         }
 
-        engine.state.init();
+        engine.state.reload();
         return (engine.state.load(engine.instantName) == State.LOAD_RESULT_SUCCESS);
     }
 
diff --git a/src/main/java/zame/game/fragments/MenuFragment.java b/src/main/java/zame/game/feature/menu/MenuFragment.java
similarity index 58%
rename from src/main/java/zame/game/fragments/MenuFragment.java
rename to src/main/java/zame/game/feature/menu/MenuFragment.java
index ff4356b..fdec096 100644
--- a/src/main/java/zame/game/fragments/MenuFragment.java
+++ b/src/main/java/zame/game/feature/menu/MenuFragment.java
@@ -1,33 +1,48 @@
-package zame.game.fragments;
+package zame.game.feature.menu;
 
 import android.os.Bundle;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 import android.view.animation.AnimationUtils;
+import zame.game.App;
 import zame.game.R;
-import zame.game.fragments.dialogs.ShareDialogFragment;
-import zame.game.managers.SoundManager;
+import zame.game.core.app.BaseFragment;
+import zame.game.core.util.Common;
+import zame.game.feature.sound.SoundManager;
+import zame.game.flavour.config.AppConfig;
+import zame.game.flavour.gplay.MenuFragmentGPlayHelper;
 
 public class MenuFragment extends BaseFragment {
+    public static MenuFragment newInstance() {
+        return new MenuFragment();
+    }
+
     private View playWrapperView;
-    private ShareDialogFragment shareDialogFragment;
+    private ViewGroup bannerWrapperView;
     private MenuFragmentGPlayHelper gPlayHelper = new MenuFragmentGPlayHelper();
 
+    public MenuFragment() {
+        super();
+    }
+
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-
-        shareDialogFragment = ShareDialogFragment.newInstance();
         gPlayHelper.onCreate();
     }
 
     @Override
-    public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-        ViewGroup viewGroup = (ViewGroup)inflater.inflate(R.layout.fragment_menu, container, false);
+    public View onCreateView(@NonNull LayoutInflater inflater,
+            @Nullable ViewGroup container,
+            @Nullable Bundle savedInstanceState) {
+
+        ViewGroup viewGroup = (ViewGroup)inflater.inflate(R.layout.menu_fragment, container, false);
 
         playWrapperView = viewGroup.findViewById(R.id.play_wrapper);
+        bannerWrapperView = viewGroup.findViewById(R.id.banner_wrapper);
 
         viewGroup.findViewById(R.id.play).setOnClickListener(new View.OnClickListener() {
             @Override
@@ -58,11 +73,27 @@ public class MenuFragment extends BaseFragment {
             }
         });
 
-        viewGroup.findViewById(R.id.share).setOnClickListener(new View.OnClickListener() {
+        viewGroup.findViewById(R.id.like_vk).setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                activity.soundManager.playSound(SoundManager.SOUND_BTN_PRESS);
+                Common.openViewIntent(activity, AppConfig.LINK_VK);
+            }
+        });
+
+        viewGroup.findViewById(R.id.like_facebook).setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                activity.soundManager.playSound(SoundManager.SOUND_BTN_PRESS);
+                Common.openViewIntent(activity, AppConfig.LINK_FACEBOOK);
+            }
+        });
+
+        viewGroup.findViewById(R.id.like_telegram).setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
                 activity.soundManager.playSound(SoundManager.SOUND_BTN_PRESS);
-                shareDialogFragment.show(getFragmentManager());
+                Common.openViewIntent(activity, AppConfig.LINK_TELEGRAM);
             }
         });
 
@@ -70,11 +101,21 @@ public class MenuFragment extends BaseFragment {
         return viewGroup;
     }
 
+    @Override
+    protected void onShowBanner() {
+        App.self.mediadtor.showBanner(activity, bannerWrapperView);
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+        playWrapperView.setAnimation(AnimationUtils.loadAnimation(getContext(), R.anim.bounce));
+    }
+
     @Override
     public void onResume() {
         super.onResume();
         activity.soundManager.setPlaylist(SoundManager.LIST_MAIN);
-        playWrapperView.setAnimation(AnimationUtils.loadAnimation(getContext(), R.anim.bounce));
     }
 
     @Override
diff --git a/src/main/java/zame/game/fragments/dialogs/QuitWarnDialogFragment.java b/src/main/java/zame/game/feature/menu/QuitWarnDialogFragment.java
similarity index 69%
rename from src/main/java/zame/game/fragments/dialogs/QuitWarnDialogFragment.java
rename to src/main/java/zame/game/feature/menu/QuitWarnDialogFragment.java
index a1080e1..6a42073 100644
--- a/src/main/java/zame/game/fragments/dialogs/QuitWarnDialogFragment.java
+++ b/src/main/java/zame/game/feature/menu/QuitWarnDialogFragment.java
@@ -1,39 +1,46 @@
-package zame.game.fragments.dialogs;
+package zame.game.feature.menu;
 
 import android.app.Dialog;
 import android.content.Context;
 import android.content.DialogInterface;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
 import android.support.v7.app.AlertDialog;
-import zame.game.MainActivity;
+import zame.game.feature.main.MainActivity;
 import zame.game.R;
-import zame.game.managers.SoundManager;
+import zame.game.core.app.BaseDialogFragment;
+import zame.game.feature.sound.SoundManager;
 
 public class QuitWarnDialogFragment extends BaseDialogFragment {
-    protected MainActivity activity;
-
     public static QuitWarnDialogFragment newInstance() {
         return new QuitWarnDialogFragment();
     }
 
+    private MainActivity activity;
+
+    public QuitWarnDialogFragment() {
+        super();
+    }
+
     @Override
     public void onAttach(Context context) {
         super.onAttach(context);
         this.activity = (MainActivity)context;
     }
 
+    @NonNull
     @Override
     public Dialog onCreateDialog(Bundle savedInstanceState) {
         return new AlertDialog.Builder(activity).setIcon(R.drawable.ic_dialog_alert)
-                .setTitle(R.string.dlg_quit_game)
-                .setPositiveButton(R.string.dlg_yes, new DialogInterface.OnClickListener() {
+                .setTitle(R.string.game_quit_warn)
+                .setPositiveButton(R.string.menu_quit_warn_yes, new DialogInterface.OnClickListener() {
                     @Override
                     public void onClick(DialogInterface dialog, int whichButton) {
                         shouldSoundPauseInstantlyOnDismiss = true;
                         activity.quitGame();
                     }
                 })
-                .setNegativeButton(R.string.dlg_no, null)
+                .setNegativeButton(R.string.menu_quit_warn_no, null)
                 .create();
     }
 
diff --git a/src/main/java/zame/game/feature/options/ConsentForAdsChangedDialogFragment.java b/src/main/java/zame/game/feature/options/ConsentForAdsChangedDialogFragment.java
new file mode 100644
index 0000000..b2cd409
--- /dev/null
+++ b/src/main/java/zame/game/feature/options/ConsentForAdsChangedDialogFragment.java
@@ -0,0 +1,58 @@
+package zame.game.feature.options;
+
+import android.app.Dialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.v7.app.AlertDialog;
+import com.jakewharton.processphoenix.ProcessPhoenix;
+import zame.game.R;
+import zame.game.core.app.BaseDialogFragment;
+import zame.game.feature.main.MainActivity;
+import zame.game.feature.sound.SoundManager;
+
+public class ConsentForAdsChangedDialogFragment extends BaseDialogFragment {
+    public static ConsentForAdsChangedDialogFragment newInstance() {
+        ConsentForAdsChangedDialogFragment dialogFragment = new ConsentForAdsChangedDialogFragment();
+        dialogFragment.setCancelable(false);
+        return dialogFragment;
+    }
+
+    private MainActivity activity;
+
+    public ConsentForAdsChangedDialogFragment() {
+        super();
+    }
+
+    @Override
+    public void onAttach(Context context) {
+        super.onAttach(context);
+        this.activity = (MainActivity)context;
+    }
+
+    @NonNull
+    @Override
+    public Dialog onCreateDialog(Bundle savedInstanceState) {
+        return new AlertDialog.Builder(activity).setIcon(R.drawable.ic_dialog_alert)
+                .setMessage(R.string.options_consent_for_ads_changed)
+                .setPositiveButton(R.string.core_ok, new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialog, int whichButton) {
+                        ProcessPhoenix.triggerRebirth(activity);
+                    }
+                })
+                .create();
+    }
+
+    // @Override
+    // public void onStart() {
+    //     super.onStart();
+    //     soundManager.setPlaylist(SoundManager.LIST_MAIN);
+    // }
+
+    @Override
+    public int getFocusMask() {
+        return SoundManager.FOCUS_MASK_CONSENT_FOR_ADS_CHANGED_DIALOG;
+    }
+}
diff --git a/src/main/java/zame/game/feature/options/OptionsFragment.java b/src/main/java/zame/game/feature/options/OptionsFragment.java
new file mode 100644
index 0000000..0397da7
--- /dev/null
+++ b/src/main/java/zame/game/feature/options/OptionsFragment.java
@@ -0,0 +1,187 @@
+package zame.game.feature.options;
+
+import android.content.Context;
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v7.preference.Preference;
+import android.support.v7.preference.PreferenceScreen;
+import com.takisoft.fix.support.v7.preference.PreferenceFragmentCompat;
+import java.util.Locale;
+import zame.game.App;
+import zame.game.R;
+import zame.game.core.app.BackPressedHandler;
+import zame.game.core.util.Common;
+import zame.game.feature.main.MainActivity;
+import zame.game.feature.web.GeneralWebActivity;
+import zame.game.flavour.config.AppConfig;
+
+public class OptionsFragment extends PreferenceFragmentCompat
+        implements PreferenceFragmentCompat.OnPreferenceStartScreenCallback, BackPressedHandler {
+
+    public static OptionsFragment newInstance() {
+        return new OptionsFragment();
+    }
+
+    private MainActivity activity;
+    private PreferenceScreen rootPreferenceScreen;
+    private RestartWarnDialogFragment restartWarnDialogFragment;
+    private ConsentForAdsChangedDialogFragment consentForAdsChangedDialogFragment;
+
+    public OptionsFragment() {
+        super();
+    }
+
+    @Override
+    public void onAttach(Context context) {
+        super.onAttach(context);
+        this.activity = (MainActivity)context;
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        activity.soundManager.setPlaylist(null, false);
+    }
+
+    @Override
+    public void onCreatePreferencesFix(Bundle savedInstanceState, String rootKey) {
+        addPreferencesFromResource(R.xml.preferences);
+
+        rootPreferenceScreen = getPreferenceScreen();
+        restartWarnDialogFragment = RestartWarnDialogFragment.newInstance();
+        consentForAdsChangedDialogFragment = ConsentForAdsChangedDialogFragment.newInstance();
+
+        final String currentLanguage = Locale.getDefault().getLanguage().toLowerCase(Locale.US);
+
+        findPreference(getString(R.string.key_language)).setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
+            @Override
+            public boolean onPreferenceChange(Preference preference, Object newValue) {
+                App.self.cachedTypeface = null;
+                activity.recreate();
+                return true;
+            }
+        });
+
+        findPreference(getString(R.string.key_help)).setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {
+            @Override
+            public boolean onPreferenceClick(Preference preference) {
+                App.self.tracker.trackEvent("Help", String.valueOf(currentLanguage));
+
+                Intent intent = new Intent(activity, GeneralWebActivity.class);
+                intent.putExtra(GeneralWebActivity.EXTRA_URL, AppConfig.LINK_HELP + currentLanguage);
+                activity.startActivity(intent);
+
+                return true;
+            }
+        });
+
+        findPreference(getString(R.string.key_about)).setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {
+            @Override
+            public boolean onPreferenceClick(Preference preference) {
+                Intent intent = new Intent(activity, GeneralWebActivity.class);
+
+                intent.putExtra(GeneralWebActivity.EXTRA_URL,
+                        "file:///android_asset/web/about.html?language="
+                                + Common.urlEncode(currentLanguage)
+                                + "&appName="
+                                + Common.urlEncode(getString(R.string.core_app_name))
+                                + "&appVersion="
+                                + Common.urlEncode(App.self.getVersionName()));
+
+                activity.startActivity(intent);
+                return true;
+            }
+        });
+
+        findPreference(getString(R.string.key_restart)).setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {
+            @Override
+            public boolean onPreferenceClick(Preference preference) {
+                restartWarnDialogFragment.show(getFragmentManager());
+                return true;
+            }
+        });
+
+        // findPreference(getString(R.string.key_enable_sound)).setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
+        //     @Override
+        //     public boolean onPreferenceChange(Preference preference, Object newValue) {
+        //         activity.soundManager.setSoundEnabledSetting((Boolean)newValue);
+        //         activity.soundManager.onSettingsUpdated();
+        //         return true;
+        //     }
+        // });
+
+        // findPreference(getString(R.string.key_music_volume)).setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
+        //     @Override
+        //     public boolean onPreferenceChange(Preference preference, Object newValue) {
+        //         activity.soundManager.setMusicVolumeSetting((Integer)newValue);
+        //         activity.soundManager.onSettingsUpdated();
+        //         return true;
+        //     }
+        // });
+
+        // findPreference(getString(R.string.key_effects_volume)).setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
+        //     @Override
+        //     public boolean onPreferenceChange(Preference preference, Object newValue) {
+        //         activity.soundManager.setEffectsVolumeSetting((Integer)newValue);
+        //         activity.soundManager.onSettingsUpdated();
+        //         return true;
+        //     }
+        // });
+
+        findPreference(getString(R.string.key_rotate_screen)).setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
+            @Override
+            public boolean onPreferenceChange(Preference preference, Object newValue) {
+                ((zame.game.core.widget.FrameLayout)activity.findViewById(R.id.root_container)).updateRotateScreen((Boolean)newValue);
+                return true;
+            }
+        });
+
+        findPreference(getString(R.string.key_consent_crashes)).setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
+            @Override
+            public boolean onPreferenceChange(Preference preference, Object newValue) {
+                App.self.tracker.setCrashesConsent((Boolean)newValue);
+                return true;
+            }
+        });
+
+        findPreference(getString(R.string.key_consent_analytics)).setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
+            @Override
+            public boolean onPreferenceChange(Preference preference, Object newValue) {
+                App.self.tracker.setAnalyticsConsent((Boolean)newValue);
+                return true;
+            }
+        });
+
+        findPreference(getString(R.string.key_consent_ad_personalization)).setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
+            @Override
+            public boolean onPreferenceChange(Preference preference, Object newValue) {
+                consentForAdsChangedDialogFragment.show(getFragmentManager());
+                return true;
+            }
+        });
+    }
+
+    @Override
+    public Fragment getCallbackFragment() {
+        return this;
+    }
+
+    @Override
+    public boolean onPreferenceStartScreen(android.support.v7.preference.PreferenceFragmentCompat caller,
+            PreferenceScreen pref) {
+
+        caller.setPreferenceScreen(pref);
+        return true;
+    }
+
+    @Override
+    public boolean onBackPressed() {
+        if (getPreferenceScreen() == rootPreferenceScreen) {
+            return false;
+        }
+
+        setPreferenceScreen(rootPreferenceScreen);
+        return true;
+    }
+}
diff --git a/src/main/java/zame/game/fragments/dialogs/RestartWarnDialogFragment.java b/src/main/java/zame/game/feature/options/RestartWarnDialogFragment.java
similarity index 59%
rename from src/main/java/zame/game/fragments/dialogs/RestartWarnDialogFragment.java
rename to src/main/java/zame/game/feature/options/RestartWarnDialogFragment.java
index 83d516f..582a143 100644
--- a/src/main/java/zame/game/fragments/dialogs/RestartWarnDialogFragment.java
+++ b/src/main/java/zame/game/feature/options/RestartWarnDialogFragment.java
@@ -1,4 +1,4 @@
-package zame.game.fragments.dialogs;
+package zame.game.feature.options;
 
 import android.app.Dialog;
 import android.content.Context;
@@ -7,17 +7,22 @@ import android.os.Bundle;
 import android.support.annotation.NonNull;
 import android.support.v7.app.AlertDialog;
 import zame.game.App;
-import zame.game.MainActivity;
+import zame.game.feature.main.MainActivity;
 import zame.game.R;
-import zame.game.managers.SoundManager;
+import zame.game.core.app.BaseDialogFragment;
+import zame.game.feature.sound.SoundManager;
 
 public class RestartWarnDialogFragment extends BaseDialogFragment {
-    protected MainActivity activity;
-
     public static RestartWarnDialogFragment newInstance() {
         return new RestartWarnDialogFragment();
     }
 
+    private MainActivity activity;
+
+    public RestartWarnDialogFragment() {
+        super();
+    }
+
     @Override
     public void onAttach(Context context) {
         super.onAttach(context);
@@ -28,24 +33,28 @@ public class RestartWarnDialogFragment extends BaseDialogFragment {
     @Override
     public Dialog onCreateDialog(Bundle savedInstanceState) {
         return new AlertDialog.Builder(activity).setIcon(R.drawable.ic_dialog_alert)
-                .setTitle(R.string.dlg_new_game)
-                .setPositiveButton(R.string.dlg_ok, new DialogInterface.OnClickListener() {
+                .setMessage(R.string.options_restart_warn)
+                .setPositiveButton(R.string.core_ok, new DialogInterface.OnClickListener() {
                     @Override
                     public void onClick(DialogInterface dialog, int whichButton) {
-                        App.self.trackerInst.send("RestartPressed", "");
+                        App.self.tracker.trackEvent("RestartPressed", "");
+
                         activity.engine.deleteInstantSave();
+                        App.self.profile.clear(activity);
+                        App.self.profile.save(activity);
+
                         activity.showFragment(activity.selectEpisodeFragment);
                     }
                 })
-                .setNegativeButton(R.string.dlg_cancel, null)
+                .setNegativeButton(R.string.core_cancel, null)
                 .create();
     }
 
-    @Override
-    public void onStart() {
-        super.onStart();
-        soundManager.setPlaylist(SoundManager.LIST_MAIN);
-    }
+    // @Override
+    // public void onStart() {
+    //     super.onStart();
+    //     soundManager.setPlaylist(SoundManager.LIST_MAIN);
+    // }
 
     @Override
     public int getFocusMask() {
diff --git a/src/main/java/zame/game/providers/CachedTexturesProvider.java b/src/main/java/zame/game/feature/prepare/CachedTexturesProvider.java
similarity index 91%
rename from src/main/java/zame/game/providers/CachedTexturesProvider.java
rename to src/main/java/zame/game/feature/prepare/CachedTexturesProvider.java
index f9dd4c4..192e8d9 100644
--- a/src/main/java/zame/game/providers/CachedTexturesProvider.java
+++ b/src/main/java/zame/game/feature/prepare/CachedTexturesProvider.java
@@ -1,8 +1,7 @@
-package zame.game.providers;
+package zame.game.feature.prepare;
 
 import android.annotation.SuppressLint;
 import android.content.Intent;
-import android.content.SharedPreferences;
 import android.content.res.AssetManager;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
@@ -20,13 +19,14 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.util.Properties;
 import zame.game.App;
-import zame.game.Common;
-import zame.game.engine.Renderer;
-import zame.game.engine.TextureLoader;
+import zame.game.R;
+import zame.game.core.util.Common;
+import zame.game.engine.graphics.Renderer;
+import zame.game.engine.graphics.TextureLoader;
 
 public final class CachedTexturesProvider {
-    public static final String BROADCAST_ACTION = "local:CachedTexturesProvider";
-    public static final String EXTRA_PROGRESS = "EXTRA_PROGRESS";
+    static final String BROADCAST_ACTION = "local:CachedTexturesProvider";
+    static final String EXTRA_PROGRESS = "EXTRA_PROGRESS";
 
     // @formatter:off
     private static final ColorMatrixColorFilter GRAY_COLOR_FILTER = new ColorMatrixColorFilter(new ColorMatrix(new float[] {
@@ -115,14 +115,14 @@ public final class CachedTexturesProvider {
             canvas.setDensity(Bitmap.DENSITY_NONE);
 
             Bitmap tiles = loadAlphaImage(texList[0], texList[1]);
-            canvas.drawBitmap(tiles, 0.0f, (float)(TextureLoader.ROW_TILES * (Renderer.TILE_SIZE + 2)), null);
+            canvas.drawBitmap(tiles, 0.0f, (float)(TextureLoader.ROW_TILES * (Renderer.SIZE_TILE + 2)), null);
             tiles.recycle();
 
             //noinspection UnusedAssignment
             tiles = null;
 
             Bitmap common = loadAlphaImage("texmap_common_p", "texmap_common_a");
-            canvas.drawBitmap(common, 0.0f, (float)(TextureLoader.ROW_COMMON * (Renderer.TILE_SIZE + 2)), null);
+            canvas.drawBitmap(common, 0.0f, (float)(TextureLoader.ROW_COMMON * (Renderer.SIZE_TILE + 2)), null);
             common.recycle();
 
             //noinspection UnusedAssignment
@@ -241,7 +241,7 @@ public final class CachedTexturesProvider {
 
         @Override
         protected void onProgressUpdate(Integer... progress) {
-            App.self.getLocalBroadcastManager()
+            App.self.getBroadcastManager()
                     .sendBroadcast((new Intent(BROADCAST_ACTION)).putExtra(EXTRA_PROGRESS, progress[0]));
         }
 
@@ -261,7 +261,7 @@ public final class CachedTexturesProvider {
         try {
             bytes = Common.readBytes(assetManager.open("textures/" + name + ".tex"));
         } catch (IOException ex) {
-            final String ioErrorMessage = "Can't open " + name + " texture";
+            final String ioErrorMessage = "Can't open \"" + name + "\" texture";
             Common.showToast(ioErrorMessage);
             throw new RuntimeException(ioErrorMessage);
         }
@@ -280,7 +280,7 @@ public final class CachedTexturesProvider {
         } catch (OutOfMemoryError oom) {
             // ignored
         } catch (Exception ex) {
-            final String decodeErrorMessage = "Can't decode " + name + " texture";
+            final String decodeErrorMessage = "Can't decode \"" + name + "\" texture";
             Common.showToast(decodeErrorMessage);
             throw new RuntimeException(decodeErrorMessage);
         }
@@ -293,7 +293,7 @@ public final class CachedTexturesProvider {
             } catch (OutOfMemoryError oom) {
                 // ignored
             } catch (Exception ex) {
-                final String decodeErrorMessage = "Can't decode " + name + " texture";
+                final String decodeErrorMessage = "Can't decode \"" + name + "\" texture";
                 Common.showToast(decodeErrorMessage);
                 throw new RuntimeException(decodeErrorMessage);
             }
@@ -303,7 +303,7 @@ public final class CachedTexturesProvider {
         bytes = null;
 
         if (result == null) {
-            final String oomErrorMessage = "Out of memory (or can't decode) " + name + " texture";
+            final String oomErrorMessage = "Out of memory (or can't decode) \"" + name + "\" texture";
             Common.showToast(oomErrorMessage);
             throw new OutOfMemoryError(oomErrorMessage);
         }
@@ -347,10 +347,9 @@ public final class CachedTexturesProvider {
     }
 
     public static boolean needToUpdateCache() {
-        SharedPreferences sp = App.self.getSharedPreferences();
         App.self.cachedTexturesReady = false;
 
-        if (sp.getInt("CachedTexturesVersion", 0) != getCacheVersion()) {
+        if (App.self.preferences.getInt(R.string.key_cached_textures_version) != getCacheVersion()) {
             return true;
         }
 
@@ -372,7 +371,7 @@ public final class CachedTexturesProvider {
         return false;
     }
 
-    public static void updateCache() {
+    static void updateCache() {
         App.self.handler.post(new Runnable() {
             @Override
             public void run() {
@@ -383,16 +382,12 @@ public final class CachedTexturesProvider {
                 App.self.cachedTexturesTask = new Task(new IOnComplete() {
                     @Override
                     public void onComplete() {
-                        App.self.getSharedPreferences()
-                                .edit()
-                                .putInt("CachedTexturesVersion", getCacheVersion())
-                                .apply();
-
+                        App.self.preferences.putInt(R.string.key_cached_textures_version, getCacheVersion());
                         App.self.cachedTexturesReady = true;
                         App.self.cachedTexturesTask = null;
 
                         //noinspection MagicNumber
-                        App.self.getLocalBroadcastManager()
+                        App.self.getBroadcastManager()
                                 .sendBroadcast((new Intent(BROADCAST_ACTION)).putExtra(EXTRA_PROGRESS, 101));
                     }
                 });
diff --git a/src/main/java/zame/game/fragments/PrepareFragment.java b/src/main/java/zame/game/feature/prepare/PrepareFragment.java
similarity index 72%
rename from src/main/java/zame/game/fragments/PrepareFragment.java
rename to src/main/java/zame/game/feature/prepare/PrepareFragment.java
index 1d38600..130abb8 100644
--- a/src/main/java/zame/game/fragments/PrepareFragment.java
+++ b/src/main/java/zame/game/feature/prepare/PrepareFragment.java
@@ -1,4 +1,4 @@
-package zame.game.fragments;
+package zame.game.feature.prepare;
 
 import android.content.BroadcastReceiver;
 import android.content.Context;
@@ -10,35 +10,38 @@ import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ProgressBar;
-import android.widget.TextView;
 import zame.game.App;
 import zame.game.R;
-import zame.game.providers.CachedTexturesProvider;
+import zame.game.core.app.BaseFragment;
 
 public class PrepareFragment extends BaseFragment {
-    protected ViewGroup viewGroup;
-    protected ProgressBar progressView;
-    protected TextView infoView;
+    public static PrepareFragment newInstance() {
+        return new PrepareFragment();
+    }
+
+    private ProgressBar progressView;
 
-    protected final BroadcastReceiver cacheUpdateProgressReceiver = new BroadcastReceiver() {
+    private final BroadcastReceiver cacheUpdateProgressReceiver = new BroadcastReceiver() {
         @Override
         public void onReceive(Context context, Intent intent) {
             int progress = intent.getIntExtra(CachedTexturesProvider.EXTRA_PROGRESS, 0);
 
             if (progress > 100) {
-                activity.showFragment(activity.menuFragment);
+                activity.processNext();
             } else {
                 progressView.setProgress(progress);
             }
         }
     };
 
+    public PrepareFragment() {
+        super();
+    }
+
     @Override
     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-        viewGroup = (ViewGroup)inflater.inflate(R.layout.fragment_prepare, container, false);
-
+        ViewGroup viewGroup = (ViewGroup)inflater.inflate(R.layout.prepare_fragment, container, false);
         progressView = viewGroup.findViewById(R.id.progress);
-        infoView = viewGroup.findViewById(R.id.info);
 
         //noinspection BooleanVariableAlwaysNegated
         boolean needToUpdateCache = (App.self.cachedTexturesTask != null
@@ -47,7 +50,7 @@ public class PrepareFragment extends BaseFragment {
         if (!needToUpdateCache) {
             activity.showFragment(activity.menuFragment);
         } else {
-            App.self.getLocalBroadcastManager()
+            App.self.getBroadcastManager()
                     .registerReceiver(cacheUpdateProgressReceiver,
                             new IntentFilter(CachedTexturesProvider.BROADCAST_ACTION));
 
@@ -67,7 +70,7 @@ public class PrepareFragment extends BaseFragment {
 
     @Override
     public void onDestroyView() {
-        App.self.getLocalBroadcastManager().unregisterReceiver(cacheUpdateProgressReceiver);
+        App.self.getBroadcastManager().unregisterReceiver(cacheUpdateProgressReceiver);
         super.onDestroyView();
     }
 }
diff --git a/src/main/java/zame/game/managers/SoundManager.java b/src/main/java/zame/game/feature/sound/SoundManager.java
similarity index 80%
rename from src/main/java/zame/game/managers/SoundManager.java
rename to src/main/java/zame/game/feature/sound/SoundManager.java
index a64f73e..dd5d631 100644
--- a/src/main/java/zame/game/managers/SoundManager.java
+++ b/src/main/java/zame/game/feature/sound/SoundManager.java
@@ -1,5 +1,7 @@
-package zame.game.managers;
+package zame.game.feature.sound;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import zame.game.App;
 
 public abstract class SoundManager {
@@ -7,20 +9,18 @@ public abstract class SoundManager {
         public String[] list;
         int idx;
 
-        PlayList(String[] list) {
+        PlayList(@NonNull String[] list) {
             this.list = list;
         }
     }
 
     public static final int FOCUS_MASK_MAIN_ACTIVITY = 1;
-    // public static final int FOCUS_MASK_PROGRESS_DIALOG = 2;
-    public static final int FOCUS_MASK_GAME_CODE_DIALOG = 4;
-    public static final int FOCUS_MASK_GAME_MENU_DIALOG = 8;
-    public static final int FOCUS_MASK_RESTART_WARN_DIALOG = 16;
-    public static final int FOCUS_MASK_SHARE_DIALOG = 32;
-    public static final int FOCUS_MASK_QUIT_WARN_DIALOG = 64;
-    public static final int FOCUS_MASK_RATE_GAME_DIALOG = 128;
-    public static final int FOCUS_MASK_DELETE_PROFILE_DIALOG = 256;
+    public static final int FOCUS_MASK_GAME_CODE_DIALOG = 2;
+    public static final int FOCUS_MASK_GAME_MENU_DIALOG = 4;
+    public static final int FOCUS_MASK_RESTART_WARN_DIALOG = 8;
+    public static final int FOCUS_MASK_CONSENT_FOR_ADS_CHANGED_DIALOG = 16;
+    public static final int FOCUS_MASK_QUIT_WARN_DIALOG = 32;
+    public static final int FOCUS_MASK_RATE_GAME_DIALOG = 64;
 
     public static final PlayList LIST_MAIN = new PlayList(new String[] { "bensound-high-octane.mp3",
             "incompetech-motherlode.mp3",
@@ -100,11 +100,11 @@ public abstract class SoundManager {
             return new SoundManagerDummy();
         }
 
-        if (App.self.soundManagerInst == null) {
-            App.self.soundManagerInst = new SoundManagerInst();
+        if (App.self.soundManagerInstance == null) {
+            App.self.soundManagerInstance = new SoundManagerInst();
         }
 
-        return App.self.soundManagerInst;
+        return App.self.soundManagerInstance;
     }
 
     public boolean instantPause = true;
@@ -119,11 +119,15 @@ public abstract class SoundManager {
 
     public abstract void setEffectsVolumeSetting(int volume);
 
-    public abstract void onSettingsUpdated();
+    // public abstract void onSettingsUpdated();
 
     public abstract void playSound(int idx, float volume);
 
-    public abstract void setPlaylist(PlayList playlist);
+    public void setPlaylist(@Nullable PlayList playlist) {
+        setPlaylist(playlist, true);
+    }
+
+    public abstract void setPlaylist(@Nullable PlayList playlist, boolean shouldMoveToNextInPrevPlaylist);
 
     public abstract void onWindowFocusChanged(boolean hasFocus, int focusMask);
 
diff --git a/src/main/java/zame/game/managers/SoundManagerDummy.java b/src/main/java/zame/game/feature/sound/SoundManagerDummy.java
similarity index 75%
rename from src/main/java/zame/game/managers/SoundManagerDummy.java
rename to src/main/java/zame/game/feature/sound/SoundManagerDummy.java
index 5738f76..d0ad104 100644
--- a/src/main/java/zame/game/managers/SoundManagerDummy.java
+++ b/src/main/java/zame/game/feature/sound/SoundManagerDummy.java
@@ -1,4 +1,4 @@
-package zame.game.managers;
+package zame.game.feature.sound;
 
 public class SoundManagerDummy extends SoundManager {
     @Override
@@ -13,16 +13,16 @@ public class SoundManagerDummy extends SoundManager {
     public void setEffectsVolumeSetting(int volume) {
     }
 
-    @Override
-    public void onSettingsUpdated() {
-    }
+    // @Override
+    // public void onSettingsUpdated() {
+    // }
 
     @Override
     public void playSound(int idx, float volume) {
     }
 
     @Override
-    public void setPlaylist(PlayList playlist) {
+    public void setPlaylist(PlayList playlist, boolean shouldMoveToNextInPrevPlaylist) {
     }
 
     @Override
diff --git a/src/main/java/zame/game/managers/SoundManagerInst.java b/src/main/java/zame/game/feature/sound/SoundManagerInst.java
similarity index 86%
rename from src/main/java/zame/game/managers/SoundManagerInst.java
rename to src/main/java/zame/game/feature/sound/SoundManagerInst.java
index ff3cd97..3868df2 100644
--- a/src/main/java/zame/game/managers/SoundManagerInst.java
+++ b/src/main/java/zame/game/feature/sound/SoundManagerInst.java
@@ -1,6 +1,5 @@
-package zame.game.managers;
+package zame.game.feature.sound;
 
-import android.content.SharedPreferences;
 import android.content.res.AssetFileDescriptor;
 import android.content.res.AssetManager;
 import android.media.AudioManager;
@@ -15,7 +14,9 @@ import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
 import zame.game.App;
-import zame.game.Common;
+import zame.game.R;
+import zame.game.core.manager.PreferencesManager;
+import zame.game.core.util.Common;
 
 // http://stackoverflow.com/questions/7437505/how-to-properly-use-soundpool-on-a-game
 // http://stackoverflow.com/questions/10181822/android-soundpool-play-sometimes-lags
@@ -123,7 +124,9 @@ public class SoundManagerInst extends SoundManager {
         }
     }
 
-    @SuppressWarnings("FieldAccessedSynchronizedAndUnsynchronized") private AssetManager assetManager;
+    private static final float VOLUME_THRESHOLD = 0.01f;
+
+    private AssetManager assetManager;
     private MediaPlayer mediaPlayer = new MediaPlayer();
     private volatile SoundThread soundThread;
 
@@ -162,23 +165,27 @@ public class SoundManagerInst extends SoundManager {
         });
     }
 
-    private synchronized SoundThread getSoundThread() {
-        if (soundThread == null) {
-            soundThread = new SoundThread(assetManager);
-            soundThread.start();
+    private SoundThread getSoundThread() {
+        AssetManager assetManagerCached = assetManager;
+
+        synchronized (this) {
+            if (soundThread == null) {
+                soundThread = new SoundThread(assetManagerCached);
+                soundThread.start();
+            }
         }
 
         return soundThread;
     }
 
     private void updateVolume() {
-        SharedPreferences sp = App.self.getSharedPreferences();
+        PreferencesManager preferences = App.self.preferences;
 
         //noinspection CallToSimpleSetterFromWithinClass
-        setSoundEnabledSetting(sp.getBoolean("EnableSound", false));
+        setSoundEnabledSetting(preferences.getBoolean(R.string.key_enable_sound));
 
-        setMusicVolumeSetting(sp.getInt("MusicVolume", 10));
-        setEffectsVolumeSetting(sp.getInt("EffectsVolume", 5));
+        setMusicVolumeSetting(preferences.getInt(R.string.key_music_volume, 10));
+        setEffectsVolumeSetting(preferences.getInt(R.string.key_effects_volume, 5));
     }
 
     private void play(boolean wasPlaying) {
@@ -241,7 +248,7 @@ public class SoundManagerInst extends SoundManager {
             pauseTask.cancel();
             pauseTimer.purge();
             pauseTask = null;
-        } else if (musicLoaded && wasPlaying) {
+        } else if (musicLoaded && wasPlaying && (musicVolume > VOLUME_THRESHOLD)) {
             mediaPlayer.setVolume(musicVolume, musicVolume);
             mediaPlayer.start();
         }
@@ -264,27 +271,22 @@ public class SoundManagerInst extends SoundManager {
         effectsVolume = (float)volume / 10.0f; // 0 .. 1.0
     }
 
-    @Override
-    public void onSettingsUpdated() {
-        if (soundEnabled) {
-            //noinspection MagicNumber
-            if (musicLoaded && (musicVolume > 0.01f)) {
-                mediaPlayer.setVolume(musicVolume, musicVolume);
-                mediaPlayer.start();
-            }
-        } else {
-            if (mediaPlayer.isPlaying()) {
-                mediaPlayer.pause();
-            }
-        }
-    }
+    // @Override
+    // public void onSettingsUpdated() {
+    //     if (soundEnabled && musicLoaded && (musicVolume > VOLUME_THRESHOLD)) {
+    //         mediaPlayer.setVolume(musicVolume, musicVolume);
+    //         mediaPlayer.startBatch();
+    //     } else if (mediaPlayer.isPlaying()) {
+    //         mediaPlayer.pause();
+    //     }
+    // }
 
-    private static final long SOUND_DEBOUNCE_THRESHOLD = 250L;
+    private static final long SOUND_DEBOUNCE_THRESHOLD = 50L; //  EndLevel    90
 
     @Override
     public void playSound(int idx, float volume) {
         //noinspection MagicNumber
-        if (!soundEnabled || (effectsVolume <= 0.01f) || (volume <= 0.01f)) {
+        if (!soundEnabled || (effectsVolume <= VOLUME_THRESHOLD) || (volume <= VOLUME_THRESHOLD)) {
             return;
         }
 
@@ -299,7 +301,9 @@ public class SoundManagerInst extends SoundManager {
     }
 
     @Override
-    public void setPlaylist(PlayList playlist) {
+    public void setPlaylist(PlayList playlist, boolean shouldMoveToNextInPrevPlaylist) {
+        updateVolume();
+
         if (current != playlist) {
             PlayList prev = current;
             boolean isPlaying = mediaPlayer.isPlaying();
@@ -307,7 +311,7 @@ public class SoundManagerInst extends SoundManager {
             current = playlist;
             play(isPlaying || (soundEnabled && prev == null));
 
-            if (prev != null && isPlaying) {
+            if (shouldMoveToNextInPrevPlaylist && prev != null && isPlaying) {
                 prev.idx = (prev.idx + 1) % prev.list.length;
             }
         }
@@ -328,16 +332,11 @@ public class SoundManagerInst extends SoundManager {
                 pauseTask = null;
             }
 
-            if (soundEnabled) {
-                //noinspection MagicNumber
-                if (musicLoaded && (musicVolume > 0.01f)) {
-                    mediaPlayer.setVolume(musicVolume, musicVolume);
-                    mediaPlayer.start();
-                }
-            } else {
-                if (mediaPlayer.isPlaying()) {
-                    mediaPlayer.pause();
-                }
+            if (soundEnabled && musicLoaded && (musicVolume > VOLUME_THRESHOLD)) {
+                mediaPlayer.setVolume(musicVolume, musicVolume);
+                mediaPlayer.start();
+            } else if (mediaPlayer.isPlaying()) {
+                mediaPlayer.pause();
             }
         } else {
             inFocusMask &= ~focusMask;
diff --git a/src/main/java/zame/game/misc/GeneralWebActivity.java b/src/main/java/zame/game/feature/web/GeneralWebActivity.java
similarity index 94%
rename from src/main/java/zame/game/misc/GeneralWebActivity.java
rename to src/main/java/zame/game/feature/web/GeneralWebActivity.java
index f4806ff..f50f879 100644
--- a/src/main/java/zame/game/misc/GeneralWebActivity.java
+++ b/src/main/java/zame/game/feature/web/GeneralWebActivity.java
@@ -1,9 +1,8 @@
-package zame.game.misc;
+package zame.game.feature.web;
 
 import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.os.Bundle;
-import android.support.v7.app.AppCompatActivity;
 import android.view.View;
 import android.webkit.WebBackForwardList;
 import android.webkit.WebHistoryItem;
@@ -11,10 +10,11 @@ import android.webkit.WebSettings;
 import android.webkit.WebView;
 import android.widget.ProgressBar;
 import zame.game.R;
+import zame.game.core.app.BaseActivity;
 
 // http://stackoverflow.com/questions/2566485/webview-and-cookies-on-android
 
-public class GeneralWebActivity extends AppCompatActivity {
+public class GeneralWebActivity extends BaseActivity {
     public static final String EXTRA_URL = "url";
 
     protected static final String KEY_WEBVIEW = "web";
@@ -29,13 +29,12 @@ public class GeneralWebActivity extends AppCompatActivity {
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity_web);
+        setContentView(R.layout.web_activity);
 
         webView = findViewById(R.id.web_view);
         progressBar = findViewById(R.id.progress);
 
         initWebView();
-
         Bundle extras = getIntent().getExtras();
 
         //noinspection ConstantConditions
diff --git a/src/main/java/zame/game/misc/GeneralWebChromeClient.java b/src/main/java/zame/game/feature/web/GeneralWebChromeClient.java
similarity index 96%
rename from src/main/java/zame/game/misc/GeneralWebChromeClient.java
rename to src/main/java/zame/game/feature/web/GeneralWebChromeClient.java
index c611199..d46bfde 100644
--- a/src/main/java/zame/game/misc/GeneralWebChromeClient.java
+++ b/src/main/java/zame/game/feature/web/GeneralWebChromeClient.java
@@ -1,4 +1,4 @@
-package zame.game.misc;
+package zame.game.feature.web;
 
 import android.content.Intent;
 import android.net.Uri;
@@ -7,7 +7,7 @@ import android.view.View;
 import android.webkit.WebChromeClient;
 import android.webkit.WebView;
 import android.widget.ProgressBar;
-import zame.game.Common;
+import zame.game.core.util.Common;
 
 public class GeneralWebChromeClient extends WebChromeClient {
     private ProgressBar progressBar;
diff --git a/src/main/java/zame/game/misc/GeneralWebViewClient.java b/src/main/java/zame/game/feature/web/GeneralWebViewClient.java
similarity index 79%
rename from src/main/java/zame/game/misc/GeneralWebViewClient.java
rename to src/main/java/zame/game/feature/web/GeneralWebViewClient.java
index 63c8785..246e799 100644
--- a/src/main/java/zame/game/misc/GeneralWebViewClient.java
+++ b/src/main/java/zame/game/feature/web/GeneralWebViewClient.java
@@ -1,4 +1,4 @@
-package zame.game.misc;
+package zame.game.feature.web;
 
 import android.content.Intent;
 import android.net.Uri;
@@ -7,7 +7,8 @@ import android.webkit.WebView;
 import android.webkit.WebViewClient;
 import java.io.InputStream;
 import java.util.Locale;
-import zame.game.Common;
+import zame.game.core.util.Common;
+import zame.game.core.util.IntentProvider;
 
 public class GeneralWebViewClient extends WebViewClient {
     static final String ERROR_PAGE_URL = "file:///android_asset/web/error.html";
@@ -34,8 +35,14 @@ public class GeneralWebViewClient extends WebViewClient {
         if (url.startsWith(ANDROID_ASSET)) {
             try {
                 Uri uri = Uri.parse(url.replaceFirst(ANDROID_ASSET, ""));
-                InputStream stream = view.getContext().getAssets().open(uri.getPath());
-                return new WebResourceResponse("text/html", "UTF-8", stream);
+                String path = uri.getPath();
+
+                if (path != null) {
+                    InputStream stream = view.getContext().getAssets().open(path);
+                    return new WebResourceResponse("text/html", "UTF-8", stream);
+                } else {
+                    throw new RuntimeException("uri.getPath() returns null");
+                }
             } catch (Exception ex) {
                 Common.log(ex);
             }
diff --git a/src/main/java/zame/game/flavour/config/AppConfig.java b/src/main/java/zame/game/flavour/config/AppConfig.java
new file mode 100644
index 0000000..3107a74
--- /dev/null
+++ b/src/main/java/zame/game/flavour/config/AppConfig.java
@@ -0,0 +1,23 @@
+package zame.game.flavour.config;
+
+import zame.game.BuildConfig;
+
+public final class AppConfig {
+    public static final String TAG = "FSR";
+
+    public static final boolean DEBUG = BuildConfig.DEBUG;
+    public static final boolean DEBUG_TRACKER = false;
+    public static final boolean DEBUG_MEDIADTOR = false;
+
+    public static final String APPCENTER_KEY = "e50ebca7-3d1b-41af-bd4d-de199974b77e";
+    public static final String APPODEAL_KEY = "f73b332eca8fbfd3bfca04109c5b7a99e047d11c387b8160";
+
+    public static final String LINK_HELP = "https://eightsines.com/fire-strike/index.php?action=help&utm_medium=referral&utm_source=ingame&utm_campaign=ingame&hl=";
+    public static final String LINK_DISLIKE = "http://eightsines.com/fire-strike/index.php?action=dislike&utm_medium=referral&utm_source=ingame&utm_campaign=ingame&hl=";
+
+    public static final String LINK_VK = "https://vk.com/gloomy.dungeons";
+    public static final String LINK_FACEBOOK = "https://www.facebook.com/gloomy.dungeons/";
+    public static final String LINK_TELEGRAM = "https://t.me/gloomy_dungeons";
+
+    private AppConfig() {}
+}
diff --git a/src/main/java/zame/game/flavour/config/GameConfig.java b/src/main/java/zame/game/flavour/config/GameConfig.java
new file mode 100644
index 0000000..2197693
--- /dev/null
+++ b/src/main/java/zame/game/flavour/config/GameConfig.java
@@ -0,0 +1,69 @@
+package zame.game.flavour.config;
+
+@SuppressWarnings("PointlessArithmeticExpression")
+public final class GameConfig {
+    public static final int COLOR_SKY = 0x45a7f2;
+
+    public static final int MAX_MONSTER_TYPES = 5;
+
+    public static final int HEALTH_MAX = 100;
+    public static final int HEALTH_ADD_STIM = 10;
+    public static final int HEALTH_ADD_MEDI = 50;
+
+    public static final int HEALTH_BARREL = 25;
+
+    public static final int HEALTH_HIT_KNIFE = 3; // 2 hits per second -> 6 dmg per second
+    public static final int HEALTH_HIT_PISTOL = 2; // 2 hits per second -> 4 dmg per second
+    public static final int HEALTH_HIT_DBLPISTOL = 2; // 4 hits per second -> 8 dmg per second
+    public static final int HEALTH_HIT_AK47 = 3; // 4 hits per second -> 12 dmg per second
+    public static final int HEALTH_HIT_TMP = 4; // 5 hits per second -> 20 dmg per second
+    public static final int HEALTH_HIT_WINCHESTER = 32; // 1 hit per second -> 32 dmg per second (but need 2 bullets)
+    public static final int HEALTH_HIT_GRENADE = 52; // 1 hit per second -> 52 dmg per second
+    public static final int HEALTH_HIT_BARREL = 40; //      ,       
+
+    public static final double ARMOR_HEALTH_SAVER = 0.25; // if hero has armor, than it take only (hits * saver) damage
+    public static final double ARMOR_HIT_TAKER = 0.75; // if hero has armor, than it loose (hits * taker) armor
+
+    // 1 frame = 1s / Engine.FRAMES_PER_SECOND = 1s / 40 = 0.025s
+    // 1s = 40 frames
+
+    public static final int STUN_KNIFE = 15; // 2 hits per second -> 15 * 2 / 40 -> 0.75 stn per second
+    public static final int STUN_PISTOL = 5; // 2 hits per second -> 5 * 2 / 40 -> 0.25 stn per second
+    public static final int STUN_DBLPISTOL = 4; // 4 hits per second -> 4 * 4 / 40 -> 0.4 stn per second
+    public static final int STUN_AK47 = 3; // 4 hits per second -> 3 * 4 / 40 -> 0.3 stn per second
+    public static final int STUN_TMP = 4; // 5 hits per second -> 4 * 5 / 40 -> 0.5 stn per second
+    public static final int STUN_WINCHESTER = 20; // 1 hit per second -> 20 * 1 / 40 -> 0.5 stn per second
+    public static final int STUN_GRENADE = 25; // 1 hit per second -> 25 * 1 / 40 -> 0.625 stn per second
+
+    public static final int ARMOR_MAX = 200;
+    public static final int ARMOR_ADD_GREEN = 100;
+    public static final int ARMOR_ADD_RED = 200;
+
+    public static final int AMMO_MAX_CLIP = 150;
+    public static final int AMMO_MAX_SHELL = 75;
+    public static final int AMMO_MAX_GRENADE = 50;
+
+    public static final int AMMO_ENSURED_CLIP = 50;
+    public static final int AMMO_ENSURED_SHELL = 25;
+    public static final int AMMO_ENSURED_GRENADE = 5;
+
+    public static final int AMMO_ADD_CLIP = 5;
+    public static final int AMMO_ADD_CBOX = 20;
+    public static final int AMMO_ADD_SHELL = 5;
+    public static final int AMMO_ADD_SBOX = 15;
+    public static final int AMMO_ADD_GRENADE = 1;
+    public static final int AMMO_ADD_GBOX = 5;
+
+    public static final int AMMO_ADD_DBLPIST = 20;
+    public static final int AMMO_ADD_AK47 = 30;
+    public static final int AMMO_ADD_TMP = 3;
+    public static final int AMMO_ADD_WINCHESTER = 6;
+
+    public static final int EXP_OPEN_DOOR = 1 * 5;
+    public static final int EXP_PICK_OBJECT = 5 * 5;
+    public static final int EXP_KILL_MONSTER = 25 * 5;
+    public static final int EXP_SECRET_FOUND = 50 * 5;
+    public static final int EXP_END_LEVEL = 100 * 5;
+
+    private GameConfig() {}
+}
diff --git a/src/main/java/zame/game/flavour/config/ProfileConfig.java b/src/main/java/zame/game/flavour/config/ProfileConfig.java
new file mode 100644
index 0000000..69e7761
--- /dev/null
+++ b/src/main/java/zame/game/flavour/config/ProfileConfig.java
@@ -0,0 +1,54 @@
+package zame.game.flavour.config;
+
+import zame.game.R;
+import zame.game.engine.state.ProfileLevel;
+
+public final class ProfileConfig {
+    public static ProfileLevel[] createLevelsList() {
+        return new ProfileLevel[] { new ProfileLevel("e00m00", -1, R.drawable.char_commander, ProfileLevel.AD_NONE),
+                new ProfileLevel("e00m01", -1, R.drawable.char_commander, ProfileLevel.AD_NONE),
+
+                new ProfileLevel("e01m01", 1, R.drawable.char_soldier, ProfileLevel.AD_NONE),
+                new ProfileLevel("e01m02", 1, R.drawable.char_soldier, ProfileLevel.AD_REWARDED),
+                new ProfileLevel("e01m03", 1, R.drawable.char_soldier, ProfileLevel.AD_REWARDED),
+                new ProfileLevel("e01m04", 1, R.drawable.char_soldier, ProfileLevel.AD_INTERSTITIAL),
+                new ProfileLevel("e01m05", 1, R.drawable.char_soldier, ProfileLevel.AD_REWARDED),
+                new ProfileLevel("e01m06", 1, R.drawable.char_soldier, ProfileLevel.AD_INTERSTITIAL),
+                new ProfileLevel("e01m07", 1, R.drawable.char_soldier, ProfileLevel.AD_REWARDED),
+                new ProfileLevel("e01m08", 1, R.drawable.char_soldier, ProfileLevel.AD_INTERSTITIAL),
+                new ProfileLevel("e01m09", 1, R.drawable.char_soldier, ProfileLevel.AD_REWARDED),
+                new ProfileLevel("e01m10", 1, R.drawable.char_soldier, ProfileLevel.AD_INTERSTITIAL),
+
+                new ProfileLevel("e02m01", 2, R.drawable.char_commander, ProfileLevel.AD_REWARDED),
+                new ProfileLevel("e02m02", 2, R.drawable.char_commander, ProfileLevel.AD_INTERSTITIAL),
+                new ProfileLevel("e02m03", 2, R.drawable.char_commander, ProfileLevel.AD_REWARDED),
+                new ProfileLevel("e02m04", 2, R.drawable.char_commander, ProfileLevel.AD_INTERSTITIAL),
+                new ProfileLevel("e02m05", 2, R.drawable.char_commander, ProfileLevel.AD_REWARDED),
+                new ProfileLevel("e02m06", 2, R.drawable.char_commander, ProfileLevel.AD_INTERSTITIAL),
+                new ProfileLevel("e02m07", 2, R.drawable.char_commander, ProfileLevel.AD_INTERSTITIAL),
+                new ProfileLevel("e02m08", 2, R.drawable.char_commander, ProfileLevel.AD_INTERSTITIAL),
+                new ProfileLevel("e02m09", 2, R.drawable.char_commander, ProfileLevel.AD_INTERSTITIAL),
+                new ProfileLevel("e02m10", 2, R.drawable.char_commander, ProfileLevel.AD_INTERSTITIAL),
+
+                new ProfileLevel("e03m01", 3, R.drawable.char_doctor, ProfileLevel.AD_INTERSTITIAL),
+                new ProfileLevel("e03m02", 3, R.drawable.char_doctor, ProfileLevel.AD_INTERSTITIAL),
+                new ProfileLevel("e03m03", 3, R.drawable.char_doctor, ProfileLevel.AD_INTERSTITIAL),
+                new ProfileLevel("e03m04", 3, R.drawable.char_doctor, ProfileLevel.AD_INTERSTITIAL),
+                new ProfileLevel("e03m05", 3, R.drawable.char_doctor, ProfileLevel.AD_INTERSTITIAL),
+
+                new ProfileLevel("e99m99", -2, R.drawable.char_doctor, ProfileLevel.AD_NONE),
+
+                new ProfileLevel("e77m01", -3, R.drawable.char_soldier, ProfileLevel.AD_NONE),
+                new ProfileLevel("e77m02", -3, R.drawable.char_soldier, ProfileLevel.AD_NONE),
+                new ProfileLevel("e77m03", -3, R.drawable.char_soldier, ProfileLevel.AD_NONE),
+                new ProfileLevel("e77m04", -3, R.drawable.char_soldier, ProfileLevel.AD_NONE),
+                new ProfileLevel("e77m05", -3, R.drawable.char_soldier, ProfileLevel.AD_NONE),
+                new ProfileLevel("e77m06", -3, R.drawable.char_soldier, ProfileLevel.AD_NONE),
+                new ProfileLevel("e77m07", -3, R.drawable.char_soldier, ProfileLevel.AD_NONE),
+                new ProfileLevel("e77m08", -3, R.drawable.char_soldier, ProfileLevel.AD_NONE),
+                new ProfileLevel("e77m09", -3, R.drawable.char_soldier, ProfileLevel.AD_NONE),
+                new ProfileLevel("e77m10", -3, R.drawable.char_soldier, ProfileLevel.AD_NONE), };
+    }
+
+    private ProfileConfig() {}
+}
diff --git a/src/main/java/zame/game/flavour/gplay/MainActivityGPlayHelper.java b/src/main/java/zame/game/flavour/gplay/MainActivityGPlayHelper.java
new file mode 100644
index 0000000..3bd8fee
--- /dev/null
+++ b/src/main/java/zame/game/flavour/gplay/MainActivityGPlayHelper.java
@@ -0,0 +1,37 @@
+package zame.game.flavour.gplay;
+
+import android.content.Intent;
+import zame.game.App;
+import zame.game.R;
+import zame.game.feature.main.MainActivity;
+
+public class MainActivityGPlayHelper {
+    private RateGameDialogFragment rateGameDialogFragment;
+    @SuppressWarnings("BooleanVariableAlwaysNegated") private boolean rateGameDialogShown;
+
+    public void onCreate() {
+        rateGameDialogFragment = RateGameDialogFragment.newInstance(true);
+        rateGameDialogShown = false;
+    }
+
+    public boolean onBackPressed(MainActivity activity) {
+        if (!rateGameDialogShown && App.self.preferences.getInt(R.string.key_quit_count) == 3 - 1) {
+            rateGameDialogShown = true;
+            rateGameDialogFragment.show(activity.getSupportFragmentManager());
+            return false;
+        }
+
+        return true;
+    }
+
+    public void quitGame() {
+        if (App.self.preferences.getBoolean(R.string.key_is_consent_chosen)) {
+            App.self.preferences.putInt(R.string.key_quit_count,
+                    App.self.preferences.getInt(R.string.key_quit_count) + 1);
+        }
+    }
+
+    @SuppressWarnings("unused")
+    public void onActivityResult(MainActivity activity, int requestCode, int resultCode, Intent data) {
+    }
+}
diff --git a/src/main/java/zame/game/fragments/MenuFragmentGPlayHelper.java b/src/main/java/zame/game/flavour/gplay/MenuFragmentGPlayHelper.java
similarity index 56%
rename from src/main/java/zame/game/fragments/MenuFragmentGPlayHelper.java
rename to src/main/java/zame/game/flavour/gplay/MenuFragmentGPlayHelper.java
index 1e764df..3bd4cae 100644
--- a/src/main/java/zame/game/fragments/MenuFragmentGPlayHelper.java
+++ b/src/main/java/zame/game/flavour/gplay/MenuFragmentGPlayHelper.java
@@ -1,30 +1,29 @@
-package zame.game.fragments;
+package zame.game.flavour.gplay;
 
-import android.content.SharedPreferences;
 import android.view.View;
 import android.view.ViewGroup;
-import zame.game.MainActivity;
 import zame.game.App;
 import zame.game.R;
-import zame.game.fragments.dialogs.RateGameDialogFragment;
-import zame.game.managers.SoundManager;
+import zame.game.core.manager.PreferencesManager;
+import zame.game.feature.main.MainActivity;
+import zame.game.feature.sound.SoundManager;
 
-class MenuFragmentGPlayHelper {
+public class MenuFragmentGPlayHelper {
     private RateGameDialogFragment rateGameDialogFragment;
     private ViewGroup rateGameWrap;
 
-    void onCreate() {
+    public void onCreate() {
         rateGameDialogFragment = RateGameDialogFragment.newInstance(false);
     }
 
-    void createFragmentView(ViewGroup viewGroup, final MainActivity activity) {
+    public void createFragmentView(ViewGroup viewGroup, final MainActivity activity) {
         rateGameWrap = viewGroup.findViewById(R.id.rate_game_wrap);
 
         rateGameWrap.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
                 activity.soundManager.playSound(SoundManager.SOUND_BTN_PRESS);
-                App.self.trackerInst.send("BarLine.Rate");
+                App.self.tracker.trackEvent("BarLine.Rate");
                 rateGameDialogFragment.show(activity.getSupportFragmentManager());
             }
         });
@@ -32,10 +31,12 @@ class MenuFragmentGPlayHelper {
         updateRateWrapVisibility();
     }
 
-    void updateRateWrapVisibility() {
-        SharedPreferences sp = App.self.getSharedPreferences();
+    public void updateRateWrapVisibility() {
+        PreferencesManager preferences = App.self.preferences;
+
+        if (preferences.getBoolean(R.string.flavour_key_quit_without_rate)
+                && !preferences.getBoolean(R.string.flavour_key_rate_at_least_once)) {
 
-        if (sp.getBoolean("QuitWithoutRate", false) && !sp.getBoolean("RateAtLeastOnce", false)) {
             rateGameWrap.setVisibility(View.VISIBLE);
         } else {
             rateGameWrap.setVisibility(View.GONE);
diff --git a/src/main/java/zame/game/fragments/dialogs/RateGameDialogFragment.java b/src/main/java/zame/game/flavour/gplay/RateGameDialogFragment.java
similarity index 64%
rename from src/main/java/zame/game/fragments/dialogs/RateGameDialogFragment.java
rename to src/main/java/zame/game/flavour/gplay/RateGameDialogFragment.java
index d56bb87..e9b0152 100644
--- a/src/main/java/zame/game/fragments/dialogs/RateGameDialogFragment.java
+++ b/src/main/java/zame/game/flavour/gplay/RateGameDialogFragment.java
@@ -1,9 +1,11 @@
-package zame.game.fragments.dialogs;
+package zame.game.flavour.gplay;
 
 import android.annotation.SuppressLint;
 import android.app.Dialog;
 import android.content.Context;
 import android.content.DialogInterface;
+import android.content.Intent;
+import android.net.Uri;
 import android.os.Bundle;
 import android.support.annotation.NonNull;
 import android.support.v7.app.AlertDialog;
@@ -11,12 +13,13 @@ import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 import java.util.Locale;
-import zame.game.Common;
-import zame.game.CommonGPlayHelper;
-import zame.game.MainActivity;
 import zame.game.App;
 import zame.game.R;
-import zame.game.managers.SoundManager;
+import zame.game.core.app.BaseDialogFragment;
+import zame.game.core.util.Common;
+import zame.game.feature.main.MainActivity;
+import zame.game.feature.sound.SoundManager;
+import zame.game.flavour.config.AppConfig;
 
 public class RateGameDialogFragment extends BaseDialogFragment {
     private static final String KEY_SHOWN_ON_QUIT = "shownOnQuit";
@@ -33,6 +36,10 @@ public class RateGameDialogFragment extends BaseDialogFragment {
         return fragment;
     }
 
+    public RateGameDialogFragment() {
+        super();
+    }
+
     @Override
     public void onAttach(Context context) {
         super.onAttach(context);
@@ -46,15 +53,16 @@ public class RateGameDialogFragment extends BaseDialogFragment {
         final boolean shownOnQuit = getArguments().getBoolean(KEY_SHOWN_ON_QUIT);
 
         @SuppressLint("InflateParams")
-        final ViewGroup viewGroup = (ViewGroup)LayoutInflater.from(activity).inflate(R.layout.dialog_rate_game, null);
+        final ViewGroup viewGroup = (ViewGroup)LayoutInflater.from(activity)
+                .inflate(R.layout.flavour_dialog_rate_game, null);
 
         viewGroup.findViewById(R.id.like).setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
                 shouldSoundPauseInstantlyOnDismiss = true;
-                App.self.getSharedPreferences().edit().putBoolean("RateAtLeastOnce", true).apply();
-                App.self.trackerInst.send("Rate", "Like");
-                CommonGPlayHelper.openMarket(activity, App.self.getPackageName());
+                App.self.preferences.putBoolean(R.string.flavour_key_rate_at_least_once, true);
+                App.self.tracker.trackEvent("Rate", "Like");
+                openMarket(activity, App.self.getPackageName());
 
                 if (shownOnQuit) {
                     activity.quitGame();
@@ -68,12 +76,11 @@ public class RateGameDialogFragment extends BaseDialogFragment {
             @Override
             public void onClick(View v) {
                 shouldSoundPauseInstantlyOnDismiss = true;
-                App.self.getSharedPreferences().edit().putBoolean("RateAtLeastOnce", true).apply();
-
-                App.self.trackerInst.send("Rate", "Dislike");
+                App.self.preferences.putBoolean(R.string.flavour_key_rate_at_least_once, true);
+                App.self.tracker.trackEvent("Rate", "Dislike");
 
                 Common.openBrowser(activity,
-                        CommonGPlayHelper.RATE_DISLIKE_LINK + Locale.getDefault().getLanguage().toLowerCase());
+                        AppConfig.LINK_DISLIKE + Locale.getDefault().getLanguage().toLowerCase(Locale.US));
 
                 if (shownOnQuit) {
                     activity.quitGame();
@@ -83,12 +90,12 @@ public class RateGameDialogFragment extends BaseDialogFragment {
             }
         });
 
-        App.self.trackerInst.send("Rate", "Show");
+        App.self.tracker.trackEvent("Rate", "Show");
 
         return new AlertDialog.Builder(activity).setIcon(R.drawable.ic_dialog_alert)
-                .setTitle(R.string.dlg_rate_title)
+                .setTitle(R.string.flavour_rate_game_title)
                 .setView(viewGroup)
-                .setPositiveButton(shownOnQuit ? R.string.dlg_rate_quit : R.string.dlg_cancel,
+                .setPositiveButton(shownOnQuit ? R.string.flavour_rate_game_quit : R.string.core_cancel,
                         new DialogInterface.OnClickListener() {
                             @Override
                             public void onClick(DialogInterface dialog, int whichButton) {
@@ -106,12 +113,23 @@ public class RateGameDialogFragment extends BaseDialogFragment {
         super.onStart();
         soundManager.setPlaylist(SoundManager.LIST_MAIN);
 
-        // set QuitWithoutRate on show, because user can hide dialog using "Back" button
-        App.self.getSharedPreferences().edit().putBoolean("QuitWithoutRate", true).apply();
+        // set QuitWithoutRate on show, because user can hide dialog using "Back" button_positive
+        App.self.preferences.putBoolean(R.string.flavour_key_quit_without_rate, true);
     }
 
     @Override
     public int getFocusMask() {
         return SoundManager.FOCUS_MASK_RATE_GAME_DIALOG;
     }
+
+    private static void openMarket(Context context, String packageName) {
+        try {
+            context.startActivity((new Intent(Intent.ACTION_VIEW,
+                    Uri.parse("market://details?id="
+                            + packageName))).addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET));
+        } catch (Exception ex) {
+            Common.log(ex);
+            Common.showToast("Could not launch the market application.");
+        }
+    }
 }
diff --git a/src/main/java/zame/game/fragments/BaseFragment.java b/src/main/java/zame/game/fragments/BaseFragment.java
deleted file mode 100644
index ce6467f..0000000
--- a/src/main/java/zame/game/fragments/BaseFragment.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package zame.game.fragments;
-
-import android.content.Context;
-import android.support.v4.app.Fragment;
-import zame.game.MainActivity;
-
-public abstract class BaseFragment extends Fragment {
-    public MainActivity activity;
-
-    @Override
-    public void onAttach(Context context) {
-        super.onAttach(context);
-        this.activity = (MainActivity)context;
-        this.activity.setupTabs();
-    }
-
-    public void onWindowFocusChanged(boolean hasWindowFocus) {
-    }
-}
diff --git a/src/main/java/zame/game/fragments/GameFragment.java b/src/main/java/zame/game/fragments/GameFragment.java
deleted file mode 100644
index b12022e..0000000
--- a/src/main/java/zame/game/fragments/GameFragment.java
+++ /dev/null
@@ -1,211 +0,0 @@
-package zame.game.fragments;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.hardware.Sensor;
-import android.hardware.SensorEvent;
-import android.hardware.SensorEventListener;
-import android.hardware.SensorManager;
-import android.os.Bundle;
-import android.support.annotation.NonNull;
-import android.view.LayoutInflater;
-import android.view.Surface;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.FrameLayout;
-import zame.game.R;
-import zame.game.engine.Config;
-import zame.game.engine.Engine;
-import zame.game.engine.Game;
-import zame.game.engine.HeroController;
-import zame.game.fragments.dialogs.GameCodeDialogFragment;
-import zame.game.fragments.dialogs.GameMenuDialogFragment;
-import zame.game.managers.SoundManager;
-import zame.game.misc.GameView;
-
-public class GameFragment extends BaseFragment implements SensorEventListener {
-    public static final int REQ_DUMMY_REWARDED_VIDEO_ACTIVITY = 1;
-
-	protected ViewGroup viewGroup;
-	protected GameView gameView;
-	protected Engine engine;
-	protected Game game;
-	protected SensorManager sensorManager;
-	protected Sensor accelerometer;
-	protected int deviceRotation;
-	protected GameMenuDialogFragment gameMenuDialogFragment;
-	protected GameCodeDialogFragment gameCodeDialogFragment;
-
-	public Config config;
-	public HeroController heroController;
-
-	@Override
-	public void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-
-		this.engine = activity.engine;
-		this.config = engine.config;
-		this.heroController = engine.heroController;
-		this.game = engine.game;
-
-		gameMenuDialogFragment = GameMenuDialogFragment.newInstance();
-		gameCodeDialogFragment = GameCodeDialogFragment.newInstance();
-	}
-
-	@Override
-	public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-		viewGroup = (ViewGroup)inflater.inflate(R.layout.fragment_game, container, false);
-		return viewGroup;
-	}
-
-    @Override
-    public void onActivityResult(int requestCode, int resultCode, Intent data) {
-        if (requestCode == REQ_DUMMY_REWARDED_VIDEO_ACTIVITY && resultCode == Activity.RESULT_OK) {
-            engine.game.isRewardedVideoWatched = true;
-            return;
-        }
-
-        super.onActivityResult(requestCode, resultCode, data);
-    }
-
-	@Override
-	@SuppressWarnings("deprecation")
-	public void onResume() {
-		super.onResume();
-
-		if (gameView != null) {
-			viewGroup.removeView(gameView);
-		}
-
-		gameView = new GameView(activity);
-		viewGroup.addView(gameView, new FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
-
-		gameView.setRenderer(gameView);
-		engine.init();
-		gameView.onResume();
-
-		if (config.accelerometerEnabled) {
-			sensorManager = (SensorManager)activity.getSystemService(Context.SENSOR_SERVICE);
-
-			if (sensorManager != null) {
-				accelerometer = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
-
-				// documentation says that getOrientation() is deprecated, and we must use getRotation instead()
-				// but getRotation() available only for >= 2.2
-				// if we look for getRotation() into android sources, we found nice piece of code:
-				// public int getRotation() { return getOrientation(); }
-				// so it should be safe to use getOrientation() instead of getRotation()
-				deviceRotation = activity.getWindowManager().getDefaultDisplay().getOrientation();
-				sensorManager.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_NORMAL);
-			}
-		} else {
-			sensorManager = null;
-			accelerometer = null;
-		}
-
-		if (game.renderMode == Game.RENDER_MODE_END_LEVEL) {
-			activity.soundManager.setPlaylist(SoundManager.LIST_ENDL);
-		} else if (game.renderMode == Game.RENDER_MODE_GAME_OVER) {
-			activity.soundManager.setPlaylist(SoundManager.LIST_GAMEOVER);
-		} else {
-			activity.soundManager.setPlaylist(SoundManager.LIST_MAIN);
-		}
-	}
-
-	@Override
-	public void onPause() {
-		super.onPause();
-
-		if (gameView != null) {
-			gameView.onPause();
-			viewGroup.removeView(gameView);
-			gameView = null;
-		}
-
-		engine.onPause();
-
-		if (config.accelerometerEnabled && (sensorManager != null)) {
-			sensorManager.unregisterListener(this);
-		}
-
-		// engine.tracker.flushEvents();
-	}
-
-	@Override
-	public void onDestroyView() {
-		super.onDestroyView();
-	}
-
-	@Override
-	public void onWindowFocusChanged(boolean hasWindowFocus) {
-		super.onWindowFocusChanged(hasWindowFocus);
-
-		if (hasWindowFocus) {
-			engine.onResume();
-		} else {
-			engine.onPause();
-		}
-	}
-
-	@Override
-	public void onAccuracyChanged(Sensor sensor, int accuracy) {
-	}
-
-	@Override
-	public void onSensorChanged(SensorEvent e) {
-		float sensorX;
-		float sensorY;
-
-		if (config.accelerometerEnabled && (e.sensor.getType() == Sensor.TYPE_ACCELEROMETER)) {
-			switch (deviceRotation) {
-				case Surface.ROTATION_90:
-					sensorX = -e.values[1];
-					sensorY = e.values[0];
-					break;
-
-				case Surface.ROTATION_180:
-					sensorX = -e.values[0];
-					sensorY = -e.values[1];
-					break;
-
-				case Surface.ROTATION_270:
-					sensorX = e.values[1];
-					sensorY = -e.values[0];
-					break;
-
-				default:
-					sensorX = e.values[0];
-					sensorY = e.values[1];
-					break;
-			}
-
-			float accelerometerX = sensorX / SensorManager.GRAVITY_EARTH;
-			float accelerometerY = sensorY / SensorManager.GRAVITY_EARTH;
-
-			if (config.rotateScreen) {
-				heroController.setAccelerometerValues(-accelerometerX, -accelerometerY);
-			} else {
-				heroController.setAccelerometerValues(accelerometerX, accelerometerY);
-			}
-		}
-	}
-
-	public void showGameMenu() {
-		gameMenuDialogFragment.show(getFragmentManager());
-	}
-
-	public void showGameCodeDialog() {
-		gameCodeDialogFragment.show(getFragmentManager());
-	}
-
-	// public void hideDialogs() {
-	// 	if (gameCodeDialogFragment.isVisible()) {
-	// 		gameCodeDialogFragment.dismiss();
-	// 	}
-    //
-	// 	if (gameMenuDialogFragment.isVisible()) {
-	// 		gameMenuDialogFragment.dismiss();
-	// 	}
-	// }
-}
diff --git a/src/main/java/zame/game/fragments/OptionsFragment.java b/src/main/java/zame/game/fragments/OptionsFragment.java
deleted file mode 100644
index d03eb3f..0000000
--- a/src/main/java/zame/game/fragments/OptionsFragment.java
+++ /dev/null
@@ -1,143 +0,0 @@
-package zame.game.fragments;
-
-import android.content.Context;
-import android.content.Intent;
-import android.os.Bundle;
-import android.support.v4.app.Fragment;
-import android.support.v7.preference.Preference;
-import android.support.v7.preference.PreferenceScreen;
-import com.takisoft.fix.support.v7.preference.PreferenceFragmentCompat;
-import java.util.Locale;
-import zame.game.Common;
-import zame.game.MainActivity;
-import zame.game.App;
-import zame.game.R;
-import zame.game.fragments.dialogs.DeleteProfileDialogFragment;
-import zame.game.fragments.dialogs.RestartWarnDialogFragment;
-import zame.game.misc.GeneralWebActivity;
-
-public class OptionsFragment extends PreferenceFragmentCompat
-        implements PreferenceFragmentCompat.OnPreferenceStartScreenCallback, MainActivity.BackPressedHandler {
-
-    private MainActivity activity;
-    private RestartWarnDialogFragment restartWarnDialogFragment;
-    private DeleteProfileDialogFragment deleteProfileDialogFragment;
-    private PreferenceScreen rootPreferenceScreen;
-
-    @Override
-    public void onAttach(Context context) {
-        super.onAttach(context);
-        this.activity = (MainActivity)context;
-    }
-
-    @Override
-    public void onCreatePreferencesFix(Bundle savedInstanceState, String rootKey) {
-        addPreferencesFromResource(R.xml.preferences);
-        rootPreferenceScreen = getPreferenceScreen();
-
-        restartWarnDialogFragment = RestartWarnDialogFragment.newInstance();
-        deleteProfileDialogFragment = DeleteProfileDialogFragment.newInstance();
-
-        findPreference("About").setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {
-            @Override
-            public boolean onPreferenceClick(Preference preference) {
-                Intent intent = new Intent(activity, GeneralWebActivity.class);
-                intent.putExtra(GeneralWebActivity.EXTRA_URL,
-                        Common.getLocalizedAssetPath(activity.getAssets(), "web/about%s.html")
-                                + "?appName="
-                                + Common.urlEncode(getString(R.string.app_name))
-                                + "&ver="
-                                + Common.urlEncode(App.self.getVersionName()));
-
-                activity.startActivity(intent);
-                return true;
-            }
-        });
-
-        findPreference("Help").setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {
-            @Override
-            public boolean onPreferenceClick(Preference preference) {
-                String lang = Locale.getDefault().getLanguage().toLowerCase();
-                App.self.trackerInst.send("Help", String.valueOf(lang));
-
-                Intent intent = new Intent(activity, GeneralWebActivity.class);
-                intent.putExtra(GeneralWebActivity.EXTRA_URL, Common.HELP_LINK + lang);
-                activity.startActivity(intent);
-
-                return true;
-            }
-        });
-
-        findPreference("Restart").setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {
-            @Override
-            public boolean onPreferenceClick(Preference preference) {
-                restartWarnDialogFragment.show(getFragmentManager());
-                return true;
-            }
-        });
-
-        findPreference("DeleteProfile").setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {
-            @Override
-            public boolean onPreferenceClick(Preference preference) {
-                deleteProfileDialogFragment.show(getFragmentManager());
-                return true;
-            }
-        });
-
-        findPreference("EnableSound").setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
-            @Override
-            public boolean onPreferenceChange(Preference preference, Object newValue) {
-                activity.soundManager.setSoundEnabledSetting((Boolean)newValue);
-                activity.soundManager.onSettingsUpdated();
-                return true;
-            }
-        });
-
-        findPreference("MusicVolume").setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
-            @Override
-            public boolean onPreferenceChange(Preference preference, Object newValue) {
-                activity.soundManager.setMusicVolumeSetting((Integer)newValue);
-                return true;
-            }
-        });
-
-        findPreference("EffectsVolume").setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
-            @Override
-            public boolean onPreferenceChange(Preference preference, Object newValue) {
-                activity.soundManager.setEffectsVolumeSetting((Integer)newValue);
-                return true;
-            }
-        });
-
-        findPreference("RotateScreen").setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
-            @Override
-            public boolean onPreferenceChange(Preference preference, Object newValue) {
-                ((zame.game.libs.FrameLayout)activity.findViewById(R.id.root_container)).updateRotateScreen((Boolean)newValue);
-                return true;
-            }
-        });
-    }
-
-    @Override
-    public Fragment getCallbackFragment() {
-        return this;
-    }
-
-    @Override
-    public boolean onPreferenceStartScreen(android.support.v7.preference.PreferenceFragmentCompat caller,
-            PreferenceScreen pref) {
-
-        caller.setPreferenceScreen(pref);
-        return true;
-    }
-
-    @Override
-    public boolean onBackPressed() {
-        if (getPreferenceScreen() == rootPreferenceScreen) {
-            return false;
-        }
-
-        setPreferenceScreen(rootPreferenceScreen);
-        return true;
-    }
-}
diff --git a/src/main/java/zame/game/fragments/dialogs/DeleteProfileDialogFragment.java b/src/main/java/zame/game/fragments/dialogs/DeleteProfileDialogFragment.java
deleted file mode 100644
index 1e9cdd5..0000000
--- a/src/main/java/zame/game/fragments/dialogs/DeleteProfileDialogFragment.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package zame.game.fragments.dialogs;
-
-import android.app.Dialog;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.os.Bundle;
-import android.support.annotation.NonNull;
-import android.support.v7.app.AlertDialog;
-import zame.game.MainActivity;
-import zame.game.App;
-import zame.game.R;
-import zame.game.managers.SoundManager;
-
-public class DeleteProfileDialogFragment extends BaseDialogFragment {
-    protected MainActivity activity;
-
-    public static DeleteProfileDialogFragment newInstance() {
-        return new DeleteProfileDialogFragment();
-    }
-
-    @Override
-    public void onAttach(Context context) {
-        super.onAttach(context);
-        this.activity = (MainActivity)context;
-    }
-
-    @NonNull
-    @Override
-    public Dialog onCreateDialog(Bundle savedInstanceState) {
-        return new AlertDialog.Builder(activity).setIcon(R.drawable.ic_dialog_alert)
-                .setTitle(R.string.dlg_delete_profile)
-                .setPositiveButton(R.string.dlg_ok, new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialog, int whichButton) {
-                        App.self.profile.clear();
-                        App.self.profile.save();
-                    }
-                })
-                .setNegativeButton(R.string.dlg_cancel, null)
-                .create();
-    }
-
-    @Override
-    public void onStart() {
-        super.onStart();
-        soundManager.setPlaylist(SoundManager.LIST_MAIN);
-    }
-
-    @Override
-    public int getFocusMask() {
-        return SoundManager.FOCUS_MASK_DELETE_PROFILE_DIALOG;
-    }
-}
diff --git a/src/main/java/zame/game/fragments/dialogs/ShareDialogFragment.java b/src/main/java/zame/game/fragments/dialogs/ShareDialogFragment.java
deleted file mode 100644
index 6010b8a..0000000
--- a/src/main/java/zame/game/fragments/dialogs/ShareDialogFragment.java
+++ /dev/null
@@ -1,88 +0,0 @@
-package zame.game.fragments.dialogs;
-
-import android.app.Dialog;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.os.Bundle;
-import android.support.annotation.NonNull;
-import android.support.v7.app.AlertDialog;
-import android.widget.ArrayAdapter;
-import java.util.ArrayList;
-import java.util.Locale;
-import zame.game.App;
-import zame.game.Common;
-import zame.game.MainActivity;
-import zame.game.R;
-import zame.game.managers.SoundManager;
-import zame.game.misc.IntentProvider;
-
-public class ShareDialogFragment extends BaseDialogFragment {
-    public static class ListItem {
-        public String title;
-        public Intent intent;
-
-        ListItem(String title, Intent intent) {
-            this.title = title;
-            this.intent = intent;
-        }
-
-        @Override
-        public String toString() {
-            return title;
-        }
-    }
-
-    protected MainActivity activity;
-    protected ArrayAdapter<ListItem> adapter;
-    protected ArrayList<ListItem> items = new ArrayList<>();
-
-    public static ShareDialogFragment newInstance() {
-        return new ShareDialogFragment();
-    }
-
-    @Override
-    public void onAttach(Context context) {
-        super.onAttach(context);
-        this.activity = (MainActivity)context;
-
-        String title = getString(R.string.share_title);
-        String url = Common.WEB_LINK + Locale.getDefault().getLanguage().toLowerCase();
-
-        items.clear();
-        items.add(new ListItem("Facebook", IntentProvider.getFacebookIntent(activity, title, url)));
-        items.add(new ListItem("Twitter", IntentProvider.getTwitterIntent(activity, title, url)));
-        items.add(new ListItem("Google+", IntentProvider.getGooglePlusIntent(activity, title, url)));
-        items.add(new ListItem("VK", IntentProvider.getVkIntent(activity, title, url)));
-
-        adapter = new ArrayAdapter<>(activity, android.R.layout.select_dialog_item, items);
-    }
-
-    @NonNull
-    @Override
-    public Dialog onCreateDialog(Bundle savedInstanceState) {
-        return new AlertDialog.Builder(activity).setTitle(R.string.dlg_share)
-                .setAdapter(adapter, new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialog, int which) {
-                        if (which >= 0 && which < items.size()) {
-                            App.self.trackerInst.send("Share", items.get(which).title);
-                            Common.openExternalIntent(getActivity(), items.get(which).intent);
-                        }
-                    }
-                })
-                .setNegativeButton(R.string.dlg_cancel, null)
-                .create();
-    }
-
-    @Override
-    public void onStart() {
-        super.onStart();
-        soundManager.setPlaylist(SoundManager.LIST_MAIN);
-    }
-
-    @Override
-    public int getFocusMask() {
-        return SoundManager.FOCUS_MASK_SHARE_DIALOG;
-    }
-}
diff --git a/src/main/java/zame/game/misc/DummyRewardedVideoActivity.java b/src/main/java/zame/game/misc/DummyRewardedVideoActivity.java
deleted file mode 100644
index 002a7ff..0000000
--- a/src/main/java/zame/game/misc/DummyRewardedVideoActivity.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package zame.game.misc;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.os.Handler;
-import android.support.v7.app.AppCompatActivity;
-import zame.game.R;
-
-public class DummyRewardedVideoActivity extends AppCompatActivity {
-    private final Handler handler = new Handler();
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity_dummy_rewarded_video);
-
-        //noinspection MagicNumber
-        handler.postDelayed(new Runnable() {
-            @Override
-            public void run() {
-                DummyRewardedVideoActivity.this.setResult(Activity.RESULT_OK);
-                DummyRewardedVideoActivity.this.finish();
-            }
-        }, 2500L);
-    }
-}
diff --git a/src/main/java/zame/game/misc/Tracker.java b/src/main/java/zame/game/misc/Tracker.java
deleted file mode 100644
index 46c8986..0000000
--- a/src/main/java/zame/game/misc/Tracker.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package zame.game.misc;
-
-public interface Tracker {
-    void send(String event);
-    void send(String event, String param);
-}
diff --git a/src/main/java/zame/game/misc/TrackerDummy.java b/src/main/java/zame/game/misc/TrackerDummy.java
deleted file mode 100644
index eefb799..0000000
--- a/src/main/java/zame/game/misc/TrackerDummy.java
+++ /dev/null
@@ -1,11 +0,0 @@
-package zame.game.misc;
-
-public class TrackerDummy implements Tracker {
-    @Override
-    public void send(String event) {
-    }
-
-    @Override
-    public void send(String event, String param) {
-    }
-}
diff --git a/src/main/java/zame/game/misc/TrackerInst.java b/src/main/java/zame/game/misc/TrackerInst.java
deleted file mode 100644
index 6769e50..0000000
--- a/src/main/java/zame/game/misc/TrackerInst.java
+++ /dev/null
@@ -1,16 +0,0 @@
-package zame.game.misc;
-
-// import com.crashlytics.android.answers.Answers;
-// import com.crashlytics.android.answers.CustomEvent;
-//
-// public class TrackerInst implements Tracker {
-//     @Override
-//     public void send(String event) {
-//         Answers.getInstance().logCustom(new CustomEvent(event));
-//     }
-//
-//     @Override
-//     public void send(String event, String param) {
-//         Answers.getInstance().logCustom(new CustomEvent(event).putCustomAttribute("param", param));
-//     }
-// }
diff --git a/src/main/java/zame/game/store/Achievements.java b/src/main/java/zame/game/store/Achievements.java
deleted file mode 100644
index fb10162..0000000
--- a/src/main/java/zame/game/store/Achievements.java
+++ /dev/null
@@ -1,173 +0,0 @@
-package zame.game.store;
-
-import zame.game.R;
-import zame.game.engine.Engine;
-import zame.game.engine.State;
-import zame.game.store.achievements.Achievement;
-
-public final class Achievements {
-    public static final int STAT_MONSTERS_KILLED = 0;
-    public static final int STAT_DOORS_OPENED = 1;
-    public static final int STAT_SECRETS_FOUND = 2;
-    public static final int STAT_P100_KILLS_ROW = 3;
-    public static final int STAT_P100_ITEMS_ROW = 4;
-    public static final int STAT_P100_SECRETS_ROW = 5;
-    public static final int STAT_LAST = 6;
-
-    private static final int MONSTERS_KILLED_5 = 0; // hands in blood
-    private static final int MONSTERS_KILLED_25 = 1;
-    private static final int MONSTERS_KILLED_100 = 2;
-    private static final int MONSTERS_KILLED_500 = 3;
-    private static final int MONSTERS_KILLED_1000 = 4;
-    private static final int DOORS_OPENED_5 = 5; // mastered doors
-    private static final int DOORS_OPENED_25 = 6;
-    private static final int DOORS_OPENED_100 = 7;
-    private static final int DOORS_OPENED_500 = 8;
-    private static final int DOORS_OPENED_1000 = 9;
-    private static final int SECRETS_FOUND_5 = 10; // mastered secrets
-    private static final int SECRETS_FOUND_10 = 11;
-    private static final int SECRETS_FOUND_25 = 12;
-    private static final int SECRETS_FOUND_50 = 13;
-    private static final int SECRETS_FOUND_100 = 14;
-    private static final int P100_KILLS_ROW_5 = 15;
-    private static final int P100_ITEMS_ROW_5 = 16;
-    private static final int P100_SECRETS_ROW_5 = 17;
-    private static final int P100_KILLS_ROW_10 = 18;
-    private static final int P100_ITEMS_ROW_10 = 19;
-    private static final int P100_SECRETS_ROW_10 = 20;
-    static final int LAST = 21;
-
-    public static final Achievement[] LIST = { new Achievement(MONSTERS_KILLED_5,
-            STAT_MONSTERS_KILLED,
-            5,
-            R.string.at_monsters_killed_5,
-            R.string.ad_monsters_killed_5),
-            new Achievement(DOORS_OPENED_5,
-                    STAT_DOORS_OPENED,
-                    5,
-                    R.string.at_doors_opened_5,
-                    R.string.ad_doors_opened_5),
-            new Achievement(SECRETS_FOUND_5,
-                    STAT_SECRETS_FOUND,
-                    5,
-                    R.string.at_secrets_found_5,
-                    R.string.ad_secrets_found_5),
-            new Achievement(P100_KILLS_ROW_5,
-                    STAT_P100_KILLS_ROW,
-                    5,
-                    R.string.at_p100_kills_row_5,
-                    R.string.ad_p100_kills_row_5),
-            new Achievement(P100_ITEMS_ROW_5,
-                    STAT_P100_ITEMS_ROW,
-                    5,
-                    R.string.at_p100_items_row_5,
-                    R.string.ad_p100_items_row_5),
-            new Achievement(P100_SECRETS_ROW_5,
-                    STAT_P100_SECRETS_ROW,
-                    5,
-                    R.string.at_p100_secrets_row_5,
-                    R.string.ad_p100_secrets_row_5),
-            new Achievement(MONSTERS_KILLED_25,
-                    STAT_MONSTERS_KILLED,
-                    25,
-                    R.string.at_monsters_killed_25,
-                    R.string.ad_monsters_killed_25),
-            new Achievement(DOORS_OPENED_25,
-                    STAT_DOORS_OPENED,
-                    25,
-                    R.string.at_doors_opened_25,
-                    R.string.ad_doors_opened_25),
-            new Achievement(SECRETS_FOUND_10,
-                    STAT_SECRETS_FOUND,
-                    10,
-                    R.string.at_secrets_found_10,
-                    R.string.ad_secrets_found_10),
-            new Achievement(P100_KILLS_ROW_10,
-                    STAT_P100_KILLS_ROW,
-                    10,
-                    R.string.at_p100_kills_row_10,
-                    R.string.ad_p100_kills_row_10),
-            new Achievement(P100_ITEMS_ROW_10,
-                    STAT_P100_ITEMS_ROW,
-                    10,
-                    R.string.at_p100_items_row_10,
-                    R.string.ad_p100_items_row_10),
-            new Achievement(P100_SECRETS_ROW_10,
-                    STAT_P100_SECRETS_ROW,
-                    10,
-                    R.string.at_p100_secrets_row_10,
-                    R.string.ad_p100_secrets_row_10),
-            new Achievement(MONSTERS_KILLED_100,
-                    STAT_MONSTERS_KILLED,
-                    100,
-                    R.string.at_monsters_killed_100,
-                    R.string.ad_monsters_killed_100),
-            new Achievement(DOORS_OPENED_100,
-                    STAT_DOORS_OPENED,
-                    100,
-                    R.string.at_doors_opened_100,
-                    R.string.ad_doors_opened_100),
-            new Achievement(SECRETS_FOUND_25,
-                    STAT_SECRETS_FOUND,
-                    25,
-                    R.string.at_secrets_found_25,
-                    R.string.ad_secrets_found_25),
-            new Achievement(MONSTERS_KILLED_500,
-                    STAT_MONSTERS_KILLED,
-                    500,
-                    R.string.at_monsters_killed_500,
-                    R.string.ad_monsters_killed_500),
-            new Achievement(DOORS_OPENED_500,
-                    STAT_DOORS_OPENED,
-                    500,
-                    R.string.at_doors_opened_500,
-                    R.string.ad_doors_opened_500),
-            new Achievement(SECRETS_FOUND_50,
-                    STAT_SECRETS_FOUND,
-                    50,
-                    R.string.at_secrets_found_50,
-                    R.string.ad_secrets_found_50),
-            new Achievement(MONSTERS_KILLED_1000,
-                    STAT_MONSTERS_KILLED,
-                    1000,
-                    R.string.at_monsters_killed_1000,
-                    R.string.ad_monsters_killed_1000),
-            new Achievement(DOORS_OPENED_1000,
-                    STAT_DOORS_OPENED,
-                    1000,
-                    R.string.at_doors_opened_1000,
-                    R.string.ad_doors_opened_1000),
-            new Achievement(SECRETS_FOUND_100,
-                    STAT_SECRETS_FOUND,
-                    100,
-                    R.string.at_secrets_found_100,
-                    R.string.ad_secrets_found_100), };
-
-    private Achievements() {}
-
-    public static void resetStat(int statId, @SuppressWarnings("unused") Profile profile, Engine engine, State state) {
-        if (!engine.inWallpaperMode) {
-            state.stats[statId] = 0;
-        }
-    }
-
-    public static void updateStat(int statId, Profile profile, Engine engine, State state) {
-        if (engine.inWallpaperMode) {
-            return;
-        }
-
-        state.stats[statId]++;
-
-        for (Achievement achievement : LIST) {
-            if (achievement.statId == statId) {
-                achievement.update(profile, engine, state);
-            }
-        }
-
-        profile.update();
-    }
-
-    public static String cleanupTitle(String achievementTitle) {
-        return achievementTitle.replaceAll("<font.+?font>", "").trim();
-    }
-}
diff --git a/src/main/java/zame/game/store/Profile.java b/src/main/java/zame/game/store/Profile.java
deleted file mode 100644
index ab3d9da..0000000
--- a/src/main/java/zame/game/store/Profile.java
+++ /dev/null
@@ -1,190 +0,0 @@
-package zame.game.store;
-
-import android.support.v4.util.SparseArrayCompat;
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.HashSet;
-import zame.game.App;
-import zame.game.Common;
-import zame.game.R;
-import zame.game.engine.BaseState;
-import zame.game.engine.data.DataReader;
-import zame.game.engine.data.DataWriter;
-
-public class Profile extends BaseState {
-    // public static final String BROADCAST_ACTION_UPDATED = "local:Profile.updated";
-
-    private static final int FIELD_BUILD = 1;
-    private static final int FIELD_EXP = 5;
-    private static final int FIELD_ACHIEVED = 7;
-    private static final int FIELD_ALREADY_COMPLETED_LEVELS = 10;
-
-    @SuppressWarnings("FieldAccessedSynchronizedAndUnsynchronized") public boolean autoSaveOnUpdate = true;
-    @SuppressWarnings("FieldAccessedSynchronizedAndUnsynchronized") public boolean isUnsavedUpdates;
-
-    public int exp;
-    public boolean[] achieved = new boolean[Achievements.LAST];
-    public HashSet<String> alreadyCompletedLevels = new HashSet<>();
-
-    public ProfileLevel[] levels = { new ProfileLevel("e00m00", -1, R.drawable.char_commander),
-
-            new ProfileLevel("e01m01", 1, R.drawable.char_soldier),
-            new ProfileLevel("e01m02", 1, R.drawable.char_soldier),
-            new ProfileLevel("e01m03", 1, R.drawable.char_soldier),
-            new ProfileLevel("e01m04", 1, R.drawable.char_soldier),
-            new ProfileLevel("e01m05", 1, R.drawable.char_soldier),
-            new ProfileLevel("e01m06", 1, R.drawable.char_soldier),
-            new ProfileLevel("e01m07", 1, R.drawable.char_soldier),
-            new ProfileLevel("e01m08", 1, R.drawable.char_soldier),
-            new ProfileLevel("e01m09", 1, R.drawable.char_soldier),
-            new ProfileLevel("e01m10", 1, R.drawable.char_soldier),
-
-            new ProfileLevel("e02m01", 2, R.drawable.char_commander),
-            new ProfileLevel("e02m02", 2, R.drawable.char_commander),
-            new ProfileLevel("e02m03", 2, R.drawable.char_commander),
-            new ProfileLevel("e02m04", 2, R.drawable.char_commander),
-            new ProfileLevel("e02m05", 2, R.drawable.char_commander),
-            new ProfileLevel("e02m06", 2, R.drawable.char_commander),
-            new ProfileLevel("e02m07", 2, R.drawable.char_commander),
-            new ProfileLevel("e02m08", 2, R.drawable.char_commander),
-            new ProfileLevel("e02m09", 2, R.drawable.char_commander),
-            new ProfileLevel("e02m10", 2, R.drawable.char_commander),
-
-            new ProfileLevel("e03m01", 3, R.drawable.char_doctor),
-            new ProfileLevel("e03m02", 3, R.drawable.char_doctor),
-            new ProfileLevel("e03m03", 3, R.drawable.char_doctor),
-            new ProfileLevel("e03m04", 3, R.drawable.char_doctor),
-            new ProfileLevel("e03m05", 3, R.drawable.char_doctor),
-
-            new ProfileLevel("e99m99", -2, R.drawable.char_doctor),
-
-            new ProfileLevel("e77m01", -3, R.drawable.char_soldier),
-            new ProfileLevel("e77m02", -3, R.drawable.char_soldier),
-            new ProfileLevel("e77m03", -3, R.drawable.char_soldier),
-            new ProfileLevel("e77m04", -3, R.drawable.char_soldier),
-            new ProfileLevel("e77m05", -3, R.drawable.char_soldier),
-            new ProfileLevel("e77m06", -3, R.drawable.char_soldier),
-            new ProfileLevel("e77m07", -3, R.drawable.char_soldier),
-            new ProfileLevel("e77m08", -3, R.drawable.char_soldier),
-            new ProfileLevel("e77m09", -3, R.drawable.char_soldier),
-            new ProfileLevel("e77m10", -3, R.drawable.char_soldier), };
-
-    private HashMap<String, ProfileLevel> levelsMap = new HashMap<>();
-    private ProfileLevel dummyLevel = new ProfileLevel("", -1, 0);
-    @SuppressWarnings("FieldCanBeLocal") private boolean wasChangedOnVersionUpgrade;
-
-    public Profile() {
-        super();
-        SparseArrayCompat<Integer> episodeIndices = new SparseArrayCompat<>();
-
-        for (int i = 0, len = levels.length; i < len; i++) {
-            int episodeIndex = (episodeIndices.indexOfKey(levels[i].episode) >= 0)
-                    ? episodeIndices.get(levels[i].episode)
-                    : 0;
-
-            episodeIndices.put(levels[i].episode, episodeIndex + 1);
-            levels[i].update(episodeIndex, (i < (len - 1) ? levels[i + 1] : null));
-            levelsMap.put(levels[i].name, levels[i]);
-        }
-
-        for (ProfileLevel level : levels) {
-            level.episodeLevelsCount = episodeIndices.get(level.episode);
-        }
-
-        dummyLevel.update(0, null);
-    }
-
-    public ProfileLevel getLevel(String name) {
-        ProfileLevel level = levelsMap.get(name);
-        return (level == null ? dummyLevel : level);
-    }
-
-    public void clear() {
-        autoSaveOnUpdate = false;
-        isUnsavedUpdates = false;
-
-        exp = 0;
-
-        for (int i = 0, len = achieved.length; i < len; i++) {
-            achieved[i] = false;
-        }
-
-        alreadyCompletedLevels.clear();
-        update();
-    }
-
-    @Override
-    public void writeTo(DataWriter writer) throws IOException {
-        writer.write(FIELD_BUILD, App.self.getVersionName());
-        writer.write(FIELD_EXP, exp);
-        writer.write(FIELD_ACHIEVED, achieved);
-        writer.write(FIELD_ALREADY_COMPLETED_LEVELS, alreadyCompletedLevels.toArray(new String[0]));
-    }
-
-    @Override
-    public void readFrom(DataReader reader) {
-        exp = reader.readInt(FIELD_EXP);
-        achieved = reader.readBooleanArray(FIELD_ACHIEVED, Achievements.LAST);
-
-        alreadyCompletedLevels.clear();
-
-        alreadyCompletedLevels.addAll(Arrays.asList((String[])Common.defaultize(reader.readStringArray(
-                FIELD_ALREADY_COMPLETED_LEVELS), new String[0])));
-    }
-
-    public synchronized void update() {
-        update(true);
-    }
-
-    public synchronized void update(boolean changed) {
-        // Additional profile updates may be here
-
-        if (changed) {
-            if (autoSaveOnUpdate) {
-                save();
-            } else {
-                isUnsavedUpdates = true;
-            }
-        }
-
-        // MyApplication.self.getLocalBroadcastManager().sendBroadcast(new Intent(BROADCAST_ACTION_UPDATED));
-    }
-
-    @Override
-    protected int getVersion() {
-        return 5;
-    }
-
-    @SuppressWarnings("RedundantMethodOverride")
-    @Override
-    protected void versionUpgrade(int version) {
-    }
-
-    public void load() {
-        load(true);
-    }
-
-    public void load(boolean showErrorMessage) {
-        if (isUnsavedUpdates) {
-            save();
-        }
-
-        wasChangedOnVersionUpgrade = false;
-
-        if (load(App.self.internalRoot + "profile.data") != LOAD_RESULT_SUCCESS && showErrorMessage) {
-            Common.showToast(R.string.msg_cant_load_profile);
-        }
-
-        update(wasChangedOnVersionUpgrade);
-    }
-
-    public void save() {
-        autoSaveOnUpdate = true;
-        isUnsavedUpdates = false;
-
-        if (!save(App.self.internalRoot + "profile.data")) {
-            Common.showToast(R.string.msg_cant_save_profile);
-        }
-    }
-}
diff --git a/src/main/java/zame/game/store/ProfileLevel.java b/src/main/java/zame/game/store/ProfileLevel.java
deleted file mode 100644
index 741c224..0000000
--- a/src/main/java/zame/game/store/ProfileLevel.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package zame.game.store;
-
-public class ProfileLevel {
-    private ProfileLevel next;
-
-    public String name;
-    public int episode;
-    public int characterResId;
-    public int episodeIndex;
-    public int episodeLevelsCount = 1;
-
-    ProfileLevel(String name, int episode, int characterResId) {
-        this.name = name;
-        this.episode = episode;
-        this.characterResId = characterResId;
-    }
-
-    public void update(int episodeIndex, ProfileLevel next) {
-        this.episodeIndex = episodeIndex;
-        this.next = next;
-    }
-
-    public String getNextLevelName() {
-        return (next == null ? "" : next.name);
-    }
-}
