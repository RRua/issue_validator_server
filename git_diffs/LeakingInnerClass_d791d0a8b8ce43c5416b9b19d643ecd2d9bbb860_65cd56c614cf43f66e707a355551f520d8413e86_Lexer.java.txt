diff --git a/app/src/main/java/cn/rbc/termuc/EditFragment.java b/app/src/main/java/cn/rbc/termuc/EditFragment.java
index 8100049..5abaa6c 100644
--- a/app/src/main/java/cn/rbc/termuc/EditFragment.java
+++ b/app/src/main/java/cn/rbc/termuc/EditFragment.java
@@ -7,14 +7,10 @@ import java.io.*;
 import org.json.*;
 import android.net.*;
 import java.util.*;
-/*import tiiehenry.code.view.*;
-import tiiehenry.code.language.c.*;
-import tiiehenry.code.language.cpp.*;
-import tiiehenry.code.language.java.*;*/
 import cn.rbc.codeeditor.lang.*;
 import cn.rbc.codeeditor.common.*;
 import cn.rbc.codeeditor.util.*;
-import android.util.*;
+import cn.rbc.codeeditor.lang.c.*;
 
 public class EditFragment extends Fragment implements OnTextChangeListener
 {
@@ -26,8 +22,6 @@ public class EditFragment extends Fragment implements OnTextChangeListener
 	private File fl;
 	private TextEditor ed;
 	int type;
-	//private int id;
-	//private int _ed;
 	private String C = "gcc";
 
 	public EditFragment() {
@@ -65,21 +59,19 @@ public class EditFragment extends Fragment implements OnTextChangeListener
 			while ((i=fr.read(cs)) != -1)
 				sb.append(cs, 0, i);
 			fr.close();
-			//sb.trimToSize();
 			String s = sb.toString();
 			editor.setText(s);
 			editor.getText().setOnTextChangeListener(this);
 			if ((type&1) == 0) {
 				C = "gcc";
-				editor.setLanguage(LanguageC.getInstance());
+				editor.setLanguage(CLanguage.getInstance());
 			} else {
 				C = "g++";
-				editor.setLanguage(LanguageCpp.getInstance());
+				editor.setLanguage(CppLanguage.getInstance());
 			}
-			//editor.setLanguage(.getInstance());
 			ma.setEditor(editor);
 			ma.lsp.didOpen(fl, (type&1)==1?"cpp":"c", s);
-		} catch(Exception fnf) {
+		} catch(IOException fnf) {
 			fnf.printStackTrace();
 			Toast.makeText(ma, "打开失败！", Toast.LENGTH_SHORT).show();
 		}
@@ -90,46 +82,47 @@ public class EditFragment extends Fragment implements OnTextChangeListener
 		return C;
 	}
 
-	private int lastVer = -1;
-	private ArrayList<Quart> cgs;
+	//private int lastVer = -1;
+	private ArrayList<Range> cgs;
 
-	public void onChanged(CharSequence c, int s, int ver, boolean ins, boolean typ) {
+	public void onChanged(CharSequence c, int start, int ver, boolean ins, boolean typ) {
 		Document dp = ed.getText();
-		boolean b = ed.isWordWrap();
-		Quart q = new Quart();
-		if (b) {
-			q.sr = dp.findLineNumber(s);
-			q.sc = dp.getLineOffset(q.sr);
+		boolean wordwrap = ed.isWordWrap();
+		Range range = new Range();
+		if (wordwrap) {
+			range.stl = dp.findLineNumber(start);
+			range.stc = dp.getLineOffset(range.stl);
 		} else {
-			q.sr = dp.findRowNumber(s);
-			q.sc = dp.getRowOffset(q.sr);
+			range.stl = dp.findRowNumber(start);
+			range.stc = dp.getRowOffset(range.stl);
 		}
-		q.sc = s - q.sc;
-		if (ins) { // i
-			q.er = q.sr;
-			q.ec = q.sc;
-		} else { // d
-			int e = s + c.length();
+		range.stc = start - range.stc;
+		if (ins) { // insert
+			range.enl = range.stl;
+			range.enc = range.stc;
+		} else { // delete
+			int e = start + c.length();
 			c = "";
-			if (b) {
-				q.er = dp.findLineNumber(e);
-				q.ec = dp.getLineOffset(q.er);
+			if (wordwrap) {
+				range.enl = dp.findLineNumber(e);
+				range.enc = dp.getLineOffset(range.enl);
 			} else {
-				q.er = dp.findRowNumber(e);
-				q.ec = dp.getRowOffset(q.er);
+				range.enl = dp.findRowNumber(e);
+				range.enc = dp.getRowOffset(range.enl);
 			}
-			q.ec = e - q.ec;
+			range.enc = e - range.enc;
 		}
-		q.tx = (String)c;
-		cgs.add(q);
+		range.msg = (String)c;
+		cgs.add(range);
 		//lastStr = (String)c;
 		//if (lastVer != ver) {
 		Lsp l = ((MainActivity)getActivity()).lsp;
 		l.didChange(fl, ver, cgs);
 		//lastStart = s;
 		//lastVer = ver;
-		if (ins && typ && (s=c.length())==1 && l.completionTry(fl, q.er, q.ec+1, c.charAt(0)))
-			ed.getAutoCompletePanel().dismiss();
+		// when inserting text and typing, call for completion
+		if (ins && typ && c.length()==1) l.completionTry(fl, range.enl, range.enl+1, c.charAt(0));
+			//ed.getAutoCompletePanel().dismiss();
 		cgs.clear();
 		//}
 	}
@@ -141,12 +134,10 @@ public class EditFragment extends Fragment implements OnTextChangeListener
 		super.onHiddenChanged(hidden);
 		if (!hidden) {
 			((MainActivity)getActivity()).setEditor(ed);
-			if ((type&1) == 0) { // C
-				ed.setLanguage(LanguageC.getInstance());
-			} else {
-				ed.setLanguage(LanguageCpp.getInstance());
-			}
-			//_tmp = 0;
+			if ((type&1) == 0) // C
+				ed.setLanguage(CLanguage.getInstance());
+			else
+				ed.setLanguage(CppLanguage.getInstance());
 		}
 	}
 
diff --git a/app/src/main/java/cn/rbc/termuc/Lsp.java b/app/src/main/java/cn/rbc/termuc/Lsp.java
index d3bd106..e4ce197 100644
--- a/app/src/main/java/cn/rbc/termuc/Lsp.java
+++ b/app/src/main/java/cn/rbc/termuc/Lsp.java
@@ -9,6 +9,8 @@ import android.util.Log;
 import android.app.*;
 import java.nio.charset.StandardCharsets;
 import android.os.*;
+import cn.rbc.codeeditor.util.*;
+import android.widget.*;
 
 public class Lsp {
 	//final static String METHOD = "method";
@@ -22,16 +24,24 @@ public class Lsp {
 	int id = 0;
 	private Socket sk;
 	private char[] compTrigs = {};
-	private Thread t;
+	//private Thread t;
 	//private Context mA;
 
-	public void start(Context c, final Handler read) {
-		Utils.run(c, "/system/bin/nc", new String[]{"-l", "-s", "127.0.0.1", "-p", "48455", "clangd", "--header-insertion-decorators=0"}, Environment.getExternalStorageDirectory().getAbsolutePath(), false);
+	public void start(final Context c, final Handler read) {
+		Utils.run(c, "/system/bin/nc", new String[]{"-l", "-s", "127.0.0.1", "-p", "48455", "clangd", "--header-insertion-decorators=0"}, Environment.getExternalStorageDirectory().getAbsolutePath(), true);
+		sk = new Socket();
 		new Thread(){
 			public void run() {
-				try {
-					Thread.sleep(200L);
-					sk = new Socket("127.0.0.1", 48455);
+				try{
+					int i=0;
+					for (; !sk.isConnected() && i<20; i++) {
+						Thread.sleep(100L);
+						try {
+							sk.connect(new InetSocketAddress("127.0.0.1", 48455));
+						}catch(SocketException s){}
+					}
+					if (i==20)
+						throw new Exception("Connection failed");
 					InputStream is = sk.getInputStream();
 					final int L = 2048;
 					byte[] b = new byte[L];
@@ -62,6 +72,7 @@ public class Lsp {
 					is.close();
 				} catch (Exception ioe) {
 					Log.e(TAG, ioe.getMessage());
+					// HelperUtils.show(Toast.makeText(c, ioe.getMessage(), 1));
 				}
 			}
 		}.start();
@@ -130,31 +141,35 @@ public class Lsp {
 		new SendThread("textDocument/didSave", s, false).start();
 	}
 
-	public synchronized void didChange(File f, int version, List<Quart> chs) {
+	public synchronized void didChange(File f, int version, List<Range> chs) {
 		StringBuilder sb = new StringBuilder("{\"textDocument\":{\"uri\":")
 		.append(JSONObject.quote(Uri.fromFile(f).toString()))
 		.append(",\"version\":")
 		.append(version)
 		.append("},\"contentChanges\":[");
 		for (int i=0,j=chs.size(); i<j; i++) {
-			Quart c = chs.get(i);
+			Range c = chs.get(i);
 			sb.append("{\"range\":{\"start\":{\"line\":")
-			.append(c.sr)
+			.append(c.stl)
 			.append(",\"character\":")
-			.append(c.sc)
+			.append(c.stc)
 			.append("},\"end\":{\"line\":")
-			.append(c.er)
+			.append(c.enl)
 			.append(",\"character\":")
-			.append(c.ec)
+			.append(c.enc)
 			.append("}},\"text\":")
-			.append(JSONObject.quote(c.tx))
+			.append(JSONObject.quote(c.msg))
 			.append("},");
 		}
 		sb.setCharAt(sb.length()-1, ']');
 		sb.append('}');
 		Log.d(TAG, sb.toString());
 		//tp = CHANGE;
-		new SendThread("textDocument/didChange", sb.toString(), false).start();
+		Thread td = new SendThread("textDocument/didChange", sb.toString(), false);
+		td.start();
+		try{
+			td.join();
+		}catch(InterruptedException ie){}
 	}
 
 	public synchronized boolean completionTry(File f, int l, int c, char tgc) {
@@ -199,11 +214,11 @@ public class Lsp {
 				else if (!sk.isConnected())
 					sk.connect(new InetSocketAddress("127.0.0.1", 48455));
 				OutputStream ow = sk.getOutputStream();
-				synchronized(Lsp.class) {
-					ow.write(new StringBuilder("Content-Length: ").append(s.length).append("\r\n\r\n").toString().getBytes());
-					ow.write(s);
-					ow.flush();
-				}
+				//synchronized(Lsp.class) {
+				ow.write(new StringBuilder("Content-Length: ").append(s.length).append("\r\n\r\n").toString().getBytes());
+				ow.write(s);
+				ow.flush();
+				//}
 			} catch(IOException e) {
 				Log.e(TAG, e.getMessage());
 			}
diff --git a/app/src/main/java/cn/rbc/termuc/MainActivity.java b/app/src/main/java/cn/rbc/termuc/MainActivity.java
index e897c8c..427a3a1 100644
--- a/app/src/main/java/cn/rbc/termuc/MainActivity.java
+++ b/app/src/main/java/cn/rbc/termuc/MainActivity.java
@@ -20,7 +20,8 @@ import cn.rbc.codeeditor.util.*;
 
 public class MainActivity extends Activity implements
 	ActionBar.OnNavigationListener, OnGlobalLayoutListener,
-	AdapterView.OnItemClickListener, AdapterView.OnItemLongClickListener {
+	AdapterView.OnItemClickListener, AdapterView.OnItemLongClickListener,
+	DialogInterface.OnClickListener {
 	private StrComp cmp = new StrComp();
     private File root = Environment.getExternalStorageDirectory();
     
@@ -250,9 +251,6 @@ public class MainActivity extends Activity implements
 			case R.id.test:
 				lsp.initialize();
 				break;
-			/*case R.id.swth:
-				FreeScrollingTextField.jj = !FreeScrollingTextField.jj;
-				break;*/
         }
         return true;
     }
@@ -306,34 +304,31 @@ public class MainActivity extends Activity implements
         super.onSaveInstanceState(bundle);
     }
 
+	private EditText fname;
+
+	@Override
+	public void onClick(DialogInterface p1, int p2) {
+		try {
+			File f = new File(pwd, fname.getText().toString());
+			if (p2 == DialogInterface.BUTTON_POSITIVE)
+				f.createNewFile();
+			else
+				f.mkdir();
+			refresh();
+		} catch (IOException e) {
+			e.printStackTrace();
+			toast(e.getMessage());
+		}
+	}
+
     public void createFile(View view) {
         View inflate = View.inflate(this, R.layout.edit, null);
-        final EditText e = inflate.findViewById(R.id.file_name);
+        fname = inflate.findViewById(R.id.file_name);
 		new AlertDialog.Builder(this)
 		.setTitle("新建")
 		.setView(inflate)
-		.setPositiveButton("文件", new DialogInterface.OnClickListener(){
-			public void onClick(DialogInterface di, int p) {
-				try {
-					new File(pwd, e.getText().toString()).createNewFile();
-					refresh();
-				} catch (Exception e) {
-					e.printStackTrace();
-					toast(e.getMessage());
-				}
-			}
-		})
-		.setNeutralButton("文件夹", new DialogInterface.OnClickListener(){
-				public void onClick(DialogInterface di, int p) {
-					try {
-						new File(pwd, e.getText().toString()).mkdir();
-						refresh();
-					} catch (Exception e) {
-						e.printStackTrace();
-						toast(e.getMessage());
-					}
-				}
-			})
+		.setPositiveButton("文件", this)
+		.setNeutralButton("文件夹", this)
 		.setNegativeButton(android.R.string.cancel, null)
 		.create().show();
     }
@@ -364,7 +359,7 @@ public class MainActivity extends Activity implements
     }
 
     public void toast(CharSequence charSequence) {
-        Toast.makeText(this, charSequence, 0).show();
+        HelperUtils.show(Toast.makeText(this, charSequence, 0));
     }
 
     public void showList(View view) {
diff --git a/app/src/main/java/cn/rbc/termuc/MainHandler.java b/app/src/main/java/cn/rbc/termuc/MainHandler.java
index 113d7b4..21e4a8e 100644
--- a/app/src/main/java/cn/rbc/termuc/MainHandler.java
+++ b/app/src/main/java/cn/rbc/termuc/MainHandler.java
@@ -44,15 +44,13 @@ public class MainHandler extends Handler implements Comparator<ErrSpan> {
 				return;
 		}
 		try {
-			JsonReader jr = new JsonReader(new StringReader((String)msg.obj));
+			JsonReader jr = new JsonReader(new CharSeqReader((CharSequence)msg.obj));
 			jr.beginObject();
-			Deque<String> st = new ArrayDeque<>();
-			st = new LinkedList<>();
+			Deque<String> stack = new ArrayDeque<>();
 			int sl = 0, sc = 0, el = 0, ec = 0;
 			Object tmp1 = null, tmp2 = null, tmp3 = null;
-			boolean _ct = true;
-			while (_ct) {
-				//Log.i("LSP", st.toString());
+			boolean _loop = true;
+			while (_loop) {
 				switch (jr.peek()) {
 					case NAME:
 						String n = jr.nextName();
@@ -82,7 +80,7 @@ public class MainHandler extends Handler implements Comparator<ErrSpan> {
 								tmp1 = new ArrayList();
 							case ADDEDIT:
 								jr.beginArray();
-								st.push(n);
+								stack.push(n);
 								break;
 							case TG:
 								jr.beginArray();
@@ -91,7 +89,7 @@ public class MainHandler extends Handler implements Comparator<ErrSpan> {
 									sb.append(jr.nextString());
 								jr.close();
 								ma.lsp.setCompTrigs(sb.toString().toCharArray());
-								_ct = false;
+								_loop = false;
 								break;
 							case RNG:
 								jr.beginObject();
@@ -121,7 +119,7 @@ public class MainHandler extends Handler implements Comparator<ErrSpan> {
 							case PARA:
 							case RESU:
 								jr.beginObject();
-								st.push(n);
+								stack.push(n);
 								break;
 							default:
 								jr.skipValue();
@@ -130,8 +128,8 @@ public class MainHandler extends Handler implements Comparator<ErrSpan> {
 						break;
 					case BEGIN_OBJECT:
 						jr.beginObject();
-						if (!st.isEmpty()) {
-						switch (st.peek()) {
+						if (!stack.isEmpty()) {
+						switch (stack.peek()) {
 							case ADDEDIT:
 								tmp3 = new Edit();
 								break;
@@ -146,8 +144,8 @@ public class MainHandler extends Handler implements Comparator<ErrSpan> {
 						break;
 					case END_OBJECT:
 						jr.endObject();
-						if (!st.isEmpty())
-						switch (st.peek()) {
+						if (!stack.isEmpty())
+						switch (stack.peek()) {
 							case ADDEDIT:
 								Edit _p = (Edit)tmp3;
 								Document te = ma.getEditor().getText();
@@ -161,7 +159,7 @@ public class MainHandler extends Handler implements Comparator<ErrSpan> {
 								_p.start = te.getLineOffset(sl) + sc;
 								_p.len = te.getLineOffset(el) + ec - _p.start;
 								((ListItem)tmp2).edits.addFirst(_p);
-								st.pop();
+								stack.pop();
 								break;
 							case IT:
 								((ArrayList)tmp1).add(tmp2);
@@ -177,19 +175,19 @@ public class MainHandler extends Handler implements Comparator<ErrSpan> {
 								}
 								break;
 							default:
-								st.pop();
+								stack.pop();
 						}
 						break;
 					case END_ARRAY:
 						jr.endArray();
-						if (!st.isEmpty())
-						switch (st.peek()) {
+						if (!stack.isEmpty())
+						switch (stack.peek()) {
 							case ADDEDIT:
-								st.pop();
+								stack.pop();
 								break;
 							case IT:
 								ma.getEditor().getAutoCompletePanel().update((ArrayList<ListItem>)tmp1);
-								_ct = false;
+								_loop = false;
 								break;
 							case DG:
 								jr.close();
@@ -197,14 +195,15 @@ public class MainHandler extends Handler implements Comparator<ErrSpan> {
 								a.sort(this);
 								TextEditor te = ma.getEditor();
 								te.getText().setDiag(a);
+								Log.i("LSP", a.toString());
 								te.invalidate();
-								_ct = false;
+								_loop = false;
 								break;
 						}
 						break;
 					case END_DOCUMENT:
 						jr.close();
-						_ct = false;
+						_loop = false;
 						break;
 					default:
 						jr.skipValue();
diff --git a/app/src/main/java/cn/rbc/termuc/Quart.java b/app/src/main/java/cn/rbc/termuc/Quart.java
deleted file mode 100644
index d657b7c..0000000
--- a/app/src/main/java/cn/rbc/termuc/Quart.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package cn.rbc.termuc;
-
-public class Quart
-{
-	public int sr, sc, er, ec;
-	public String tx;
-}
diff --git a/app/src/main/java/cn/rbc/termuc/TextEditor.java b/app/src/main/java/cn/rbc/termuc/TextEditor.java
index 81da65e..cd9c884 100644
--- a/app/src/main/java/cn/rbc/termuc/TextEditor.java
+++ b/app/src/main/java/cn/rbc/termuc/TextEditor.java
@@ -85,7 +85,7 @@ public class TextEditor extends FreeScrollingTextField{
 
     public static void setLanguage(Language language){
         AutoCompletePanel.setLanguage(language);
-        Lexer.setLanguage(language);
+        Tokenizer.setLanguage(language);
     }
 
     public String getSelectedText() {
diff --git a/codeeditor/src/main/java/cn/rbc/codeeditor/lang/DefFormatter.java b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/DefFormatter.java
new file mode 100644
index 0000000..41f01ae
--- /dev/null
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/DefFormatter.java
@@ -0,0 +1,21 @@
+package cn.rbc.codeeditor.lang;
+
+public class DefFormatter implements Formatter
+{
+	public static char indentChar='\t';
+	private static DefFormatter _theOne = null;
+
+	public static DefFormatter getInstance() {
+		if (_theOne == null) {
+			_theOne = new DefFormatter();
+		}
+		return _theOne;
+	}
+	public int createAutoIndent(CharSequence text){
+		return 1;
+	}
+	public CharSequence format(CharSequence text, int width){
+		return text;
+	}
+}
+
diff --git a/codeeditor/src/main/java/cn/rbc/codeeditor/lang/Formatter.java b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/Formatter.java
new file mode 100644
index 0000000..a30d5ca
--- /dev/null
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/Formatter.java
@@ -0,0 +1,7 @@
+package cn.rbc.codeeditor.lang;
+
+public interface Formatter
+{
+	public int createAutoIndent(CharSequence text);
+	public CharSequence format(CharSequence text, int width);
+}
diff --git a/codeeditor/src/main/java/cn/rbc/codeeditor/lang/Language.java b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/Language.java
index 98f557f..1fb7b02 100644
--- a/codeeditor/src/main/java/cn/rbc/codeeditor/lang/Language.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/Language.java
@@ -8,10 +8,11 @@
  */
 package cn.rbc.codeeditor.lang;
 
-import cn.rbc.codeeditor.util.Lexer;
+import cn.rbc.codeeditor.util.Tokenizer;
 
 import java.util.HashMap;
 import java.util.*;
+import cn.rbc.codeeditor.util.*;
 
 /**
  * Base class for programming language syntax.
@@ -75,6 +76,20 @@ public abstract class Language
 		return _keyword;
 	}
 
+	public Lexer newLexer(CharSeqReader reader) {
+		return null;
+	}
+
+	/*//子类需要实现该方法
+	public LexerTokenizer getTokenizer() {
+		return LexerTokenizer.getInstance();
+	}*/
+
+	//子类需要实现该方法
+	public DefFormatter getFormatter() {
+		return DefFormatter.getInstance();
+	}
+
 	public void setKeywords(String[] keywords)
 	{
 		_keyword = new String[keywords.length];
@@ -96,7 +111,7 @@ public abstract class Language
 	public void addKeynames(String[] keynames) {
 		//_namesMap.clear();
 		for (String keynam:keynames) {
-			_namesMap.put(keynam, Lexer.KEYNAME);
+			_namesMap.put(keynam, Tokenizer.KEYNAME);
 		}
 		_name = new String[_namesMap.size()];
 		_namesMap.keySet().toArray(_name);
@@ -105,7 +120,7 @@ public abstract class Language
 	public void addNames(String[] names)
 	{
 		for (String keynam:names) {
-			_namesMap.put(keynam, Lexer.NAME);
+			_namesMap.put(keynam, Tokenizer.NAME);
 		}
 		_name = new String[_namesMap.size()];
 		_namesMap.keySet().toArray(_name);
@@ -113,7 +128,7 @@ public abstract class Language
 
 	public void addTypes(String[] types) {
 		for (String tp:types)
-			_namesMap.put(tp, Lexer.TYPE);
+			_namesMap.put(tp, Tokenizer.TYPE);
 		_name = new String[_namesMap.size()];
 		_namesMap.keySet().toArray(_name);
 	}
@@ -133,7 +148,7 @@ public abstract class Language
 	{
 		if(!_userCache.contains(name) && !_namesMap.containsKey(name))
 			_userCache.add(name);
-		_usersMap.put(name, Lexer.NAME);
+		_usersMap.put(name, Tokenizer.NAME);
 	}
 
 	protected void setOperators(char[] operators)
@@ -172,9 +187,14 @@ public abstract class Language
 
 	public final boolean isKeyname(String s) {
 		Integer b = _namesMap.get(s);
-		return b!=null && b.intValue() == Lexer.KEYNAME;
+		return b!=null && b.intValue() == Tokenizer.KEYNAME;
 	}
-	
+
+	public final boolean isType(String s) {
+		Integer b = _namesMap.get(s);
+		return b!=null && b.intValue() == Tokenizer.TYPE;
+	}
+
 	public final boolean isBasePackage(String s)
 	{
 		return _basesMap.containsKey(s);
@@ -233,7 +253,7 @@ public abstract class Language
 	 */
 	public boolean isProgLang()
 	{
-		return true;
+		return false;
 	}
 
 	/**
diff --git a/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageCFamily.java b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageCFamily.java
index 511f5e6..db3ebe1 100644
--- a/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageCFamily.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageCFamily.java
@@ -8,7 +8,7 @@
  */
 package cn.rbc.codeeditor.lang;
 
-import cn.rbc.codeeditor.util.Lexer;
+import cn.rbc.codeeditor.util.Tokenizer;
 
 import java.util.HashMap;
 
@@ -40,7 +40,7 @@ public abstract class LanguageCFamily
 		_keywords = new HashMap<String, Integer>(keywords.length);
 		for (int i = 0; i < keywords.length; ++i)
 		{
-			_keywords.put(keywords[i], Lexer.KEYWORD);
+			_keywords.put(keywords[i], Tokenizer.KEYWORD);
 		}
 	}
 
@@ -49,7 +49,7 @@ public abstract class LanguageCFamily
 		_operators = new HashMap<>(operators.length);
 		for (int i = 0; i < operators.length; ++i)
 		{
-			_operators.put(operators[i], Lexer.OPERATOR);
+			_operators.put(operators[i], Tokenizer.OPERATOR);
 		}
 	}
 
diff --git a/codeeditor/src/main/java/cn/rbc/codeeditor/lang/c/CLanguage.java b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/c/CLanguage.java
new file mode 100644
index 0000000..5d1b9b9
--- /dev/null
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/c/CLanguage.java
@@ -0,0 +1,37 @@
+package cn.rbc.codeeditor.lang.c;
+
+import cn.rbc.codeeditor.lang.*;
+import cn.rbc.codeeditor.util.*;
+
+public class CLanguage extends Language{
+	private static Language _theOne = null;
+
+	/*private final static String[] types = {
+		"char", "double", "float", "int", "long", "short", "void", "signed", "unsigned"
+		/*"auto", "const", "extern", "register", "static", "volatile",
+		"signed", "unsigned", "sizeof", "typedef",
+		"enum", "struct", "union",
+		"break", "case", "continue", "default", "do", "else", "for",
+		"goto", "if", "return", "switch", "while"*
+	};*/
+
+	public static Language getInstance(){
+		if(_theOne == null){
+			_theOne = new CLanguage();
+		}
+		return _theOne;
+	}
+
+	@Override
+	public boolean isProgLang() {
+		// TODO: Implement this method
+		return true;
+	}
+
+	@Override
+	public Lexer newLexer(CharSeqReader reader) {
+		// TODO: Implement this method
+		return new CLexer(reader);
+	}
+}
+
diff --git a/codeeditor/src/main/java/cn/rbc/codeeditor/lang/c/CLexer.java b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/c/CLexer.java
new file mode 100644
index 0000000..6b7a948
--- /dev/null
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/c/CLexer.java
@@ -0,0 +1,1493 @@
+// DO NOT EDIT
+// Generated by JFlex 1.9.1 http://jflex.de/
+// source: c.flex
+
+package cn.rbc.codeeditor.lang.c;
+import cn.rbc.codeeditor.util.*;
+
+
+@SuppressWarnings("fallthrough")
+public class CLexer implements Lexer {
+
+  /** This character denotes the end of file. */
+  public static final int YYEOF = -1;
+
+  /** Initial size of the lookahead buffer. */
+  private static final int ZZ_BUFFERSIZE = 16384;
+
+  // Lexical states.
+  public static final int YYINITIAL = 0;
+  public static final int STRING = 2;
+  public static final int CHARLITERAL = 4;
+  public static final int PRETREATMENT = 6;
+  public static final int DEFINE = 8;
+  public static final int DEFINE_NEW_LINE = 10;
+
+  /**
+   * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
+   * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
+   *                  at the beginning of a line
+   * l is of the form l = 2*k, k a non negative integer
+   */
+  private static final int ZZ_LEXSTATE[] = {
+     0,  0,  1,  1,  2,  2,  3,  3,  4,  4,  5, 5
+  };
+
+  /**
+   * Top-level table for translating characters to character classes
+   */
+  private static final int [] ZZ_CMAP_TOP = zzUnpackcmap_top();
+
+  private static final String ZZ_CMAP_TOP_PACKED_0 =
+    "\1\0\1\u0100\1\u0200\1\u0300\1\u0400\1\u0500\1\u0600\1\u0700"+
+    "\1\u0800\1\u0900\1\u0a00\1\u0b00\1\u0c00\1\u0d00\1\u0e00\1\u0f00"+
+    "\1\u1000\1\u0100\1\u1100\1\u1200\1\u1300\1\u0100\1\u1400\1\u1500"+
+    "\1\u1600\1\u1700\1\u1800\1\u1900\1\u1a00\1\u1b00\1\u0100\1\u1c00"+
+    "\1\u1d00\1\u1e00\12\u1f00\1\u2000\1\u2100\1\u2200\1\u1f00\1\u2300"+
+    "\1\u2400\2\u1f00\31\u0100\1\u2500\121\u0100\1\u2600\4\u0100\1\u2700"+
+    "\1\u0100\1\u2800\1\u2900\1\u2a00\1\u2b00\1\u2c00\1\u2d00\53\u0100"+
+    "\1\u2e00\10\u2f00\31\u1f00\1\u0100\1\u3000\1\u3100\1\u0100\1\u3200"+
+    "\1\u3300\1\u3400\1\u3500\1\u3600\1\u3700\1\u3800\1\u3900\1\u3a00"+
+    "\1\u0100\1\u3b00\1\u3c00\1\u3d00\1\u3e00\1\u3f00\1\u4000\1\u4100"+
+    "\1\u4200\1\u4300\1\u4400\1\u4500\1\u4600\1\u4700\1\u4800\1\u4900"+
+    "\1\u4a00\1\u4b00\1\u4c00\1\u4d00\1\u4e00\1\u1f00\1\u4f00\1\u5000"+
+    "\1\u5100\1\u5200\3\u0100\1\u5300\1\u5400\1\u5500\12\u1f00\4\u0100"+
+    "\1\u5600\17\u1f00\2\u0100\1\u5700\41\u1f00\2\u0100\1\u5800\1\u5900"+
+    "\2\u1f00\1\u5a00\1\u5b00\27\u0100\1\u5c00\4\u0100\1\u5d00\1\u5e00"+
+    "\42\u1f00\1\u0100\1\u5f00\1\u6000\11\u1f00\1\u6100\24\u1f00\1\u6200"+
+    "\1\u6300\1\u1f00\1\u6400\1\u6500\1\u6600\1\u6700\2\u1f00\1\u6800"+
+    "\5\u1f00\1\u6900\1\u6a00\1\u6b00\5\u1f00\1\u6c00\1\u6d00\2\u1f00"+
+    "\1\u6e00\1\u1f00\1\u6f00\14\u1f00\1\u7000\4\u1f00\246\u0100\1\u7100"+
+    "\20\u0100\1\u7200\1\u7300\25\u0100\1\u7400\34\u0100\1\u7500\14\u1f00"+
+    "\2\u0100\1\u7600\5\u1f00\23\u0100\1\u7700\u0aec\u1f00\1\u7800\1\u7900"+
+    "\u02fe\u1f00";
+
+  private static int [] zzUnpackcmap_top() {
+    int [] result = new int[4352];
+    int offset = 0;
+    offset = zzUnpackcmap_top(ZZ_CMAP_TOP_PACKED_0, offset, result);
+    return result;
+  }
+
+  private static int zzUnpackcmap_top(String packed, int offset, int [] result) {
+    int i = 0;       /* index in packed string  */
+    int j = offset;  /* index in unpacked array */
+    int l = packed.length();
+    while (i < l) {
+      int count = packed.charAt(i++);
+      int value = packed.charAt(i++);
+      do result[j++] = value; while (--count > 0);
+    }
+    return j;
+  }
+
+
+  /**
+   * Second-level tables for translating characters to character classes
+   */
+  private static final int [] ZZ_CMAP_BLOCKS = zzUnpackcmap_blocks();
+
+  private static final String ZZ_CMAP_BLOCKS_PACKED_0 =
+    "\11\0\1\1\1\2\1\3\1\4\1\5\16\0\4\6"+
+    "\1\7\1\10\1\11\1\12\1\13\2\10\1\14\1\15"+
+    "\1\16\1\17\1\20\1\21\1\22\1\23\1\24\1\25"+
+    "\1\26\2\27\4\30\2\31\1\10\1\32\1\33\1\10"+
+    "\1\33\1\10\1\6\1\34\1\35\1\36\1\37\1\40"+
+    "\1\37\2\41\1\42\2\41\1\43\3\41\1\44\7\41"+
+    "\1\45\2\41\1\46\1\47\1\50\1\10\1\51\1\6"+
+    "\1\52\1\53\1\54\1\55\1\56\1\57\1\60\1\61"+
+    "\1\62\1\41\1\63\1\64\1\65\1\66\1\67\1\70"+
+    "\1\41\1\71\1\72\1\73\1\74\1\75\1\76\1\77"+
+    "\1\100\1\101\1\102\1\10\1\103\1\10\6\0\1\104"+
+    "\32\0\2\6\4\13\4\6\1\13\2\6\1\0\7\6"+
+    "\1\13\4\6\1\13\5\6\27\13\1\6\37\13\1\6"+
+    "\u01ca\13\4\6\14\13\16\6\5\13\7\6\1\13\1\6"+
+    "\1\13\21\6\160\0\5\13\1\6\2\13\2\6\4\13"+
+    "\1\6\1\13\6\6\1\13\1\6\3\13\1\6\1\13"+
+    "\1\6\24\13\1\6\123\13\1\6\213\13\1\6\5\0"+
+    "\2\6\246\13\1\6\46\13\2\6\1\13\6\6\51\13"+
+    "\6\6\1\13\1\6\55\0\1\6\1\0\1\6\2\0"+
+    "\1\6\2\0\1\6\1\0\10\6\33\13\4\6\4\13"+
+    "\15\6\6\0\5\6\1\13\4\6\13\0\1\6\1\0"+
+    "\3\6\53\13\37\0\4\6\2\13\1\0\143\13\1\6"+
+    "\1\13\10\0\1\6\6\0\2\13\2\0\1\6\4\0"+
+    "\2\13\12\0\3\13\2\6\1\13\17\6\1\0\1\13"+
+    "\1\0\36\13\33\0\2\6\131\13\13\0\1\13\16\6"+
+    "\12\0\41\13\11\0\2\13\4\6\1\13\2\6\1\0"+
+    "\30\13\4\0\1\13\11\0\1\13\3\0\1\13\5\0"+
+    "\22\6\31\13\3\0\4\6\13\13\65\6\25\13\1\6"+
+    "\22\13\13\6\61\0\66\13\3\0\1\13\22\0\1\13"+
+    "\7\0\12\13\2\0\2\6\12\0\1\6\20\13\3\0"+
+    "\1\6\10\13\2\6\2\13\2\6\26\13\1\6\7\13"+
+    "\1\6\1\13\3\6\4\13\2\6\1\0\1\13\7\0"+
+    "\2\6\2\0\2\6\3\0\1\13\10\6\1\0\4\6"+
+    "\2\13\1\6\3\13\2\0\2\6\12\0\4\13\7\6"+
+    "\2\13\1\6\1\0\2\6\3\0\1\6\6\13\4\6"+
+    "\2\13\2\6\26\13\1\6\7\13\1\6\2\13\1\6"+
+    "\2\13\1\6\2\13\2\6\1\0\1\6\5\0\4\6"+
+    "\2\0\2\6\3\0\3\6\1\0\7\6\4\13\1\6"+
+    "\1\13\7\6\14\0\3\13\1\0\13\6\3\0\1\6"+
+    "\11\13\1\6\3\13\1\6\26\13\1\6\7\13\1\6"+
+    "\2\13\1\6\5\13\2\6\1\0\1\13\10\0\1\6"+
+    "\3\0\1\6\3\0\2\6\1\13\17\6\2\13\2\0"+
+    "\2\6\12\0\1\6\1\13\7\6\1\13\6\0\1\6"+
+    "\3\0\1\6\10\13\2\6\2\13\2\6\26\13\1\6"+
+    "\7\13\1\6\2\13\1\6\5\13\2\6\1\0\1\13"+
+    "\7\0\2\6\2\0\2\6\3\0\7\6\3\0\4\6"+
+    "\2\13\1\6\3\13\2\0\2\6\12\0\1\6\1\13"+
+    "\20\6\1\0\1\13\1\6\6\13\3\6\3\13\1\6"+
+    "\4\13\3\6\2\13\1\6\1\13\1\6\2\13\3\6"+
+    "\2\13\3\6\3\13\3\6\14\13\4\6\5\0\3\6"+
+    "\3\0\1\6\4\0\2\6\1\13\6\6\1\0\16\6"+
+    "\12\0\11\6\1\13\6\6\5\0\10\13\1\6\3\13"+
+    "\1\6\27\13\1\6\20\13\3\6\1\13\7\0\1\6"+
+    "\3\0\1\6\4\0\7\6\2\0\1\6\3\13\5\6"+
+    "\2\13\2\0\2\6\12\0\20\6\1\13\3\0\1\6"+
+    "\10\13\1\6\3\13\1\6\27\13\1\6\12\13\1\6"+
+    "\5\13\2\6\1\0\1\13\7\0\1\6\3\0\1\6"+
+    "\4\0\7\6\2\0\7\6\1\13\1\6\2\13\2\0"+
+    "\2\6\12\0\1\6\2\13\15\6\4\0\11\13\1\6"+
+    "\3\13\1\6\51\13\2\0\1\13\7\0\1\6\3\0"+
+    "\1\6\4\0\1\13\5\6\3\13\1\0\7\6\3\13"+
+    "\2\0\2\6\12\0\12\6\6\13\1\6\3\0\1\6"+
+    "\22\13\3\6\30\13\1\6\11\13\1\6\1\13\2\6"+
+    "\7\13\3\6\1\0\4\6\6\0\1\6\1\0\1\6"+
+    "\10\0\6\6\12\0\2\6\2\0\15\6\60\13\1\0"+
+    "\2\13\7\0\4\6\10\13\10\0\1\6\12\0\47\6"+
+    "\2\13\1\6\1\13\1\6\5\13\1\6\30\13\1\6"+
+    "\1\13\1\6\12\13\1\0\2\13\11\0\1\13\2\6"+
+    "\5\13\1\6\1\13\1\6\6\0\2\6\12\0\2\6"+
+    "\4\13\40\6\1\13\27\6\2\0\6\6\12\0\13\6"+
+    "\1\0\1\6\1\0\1\6\1\0\4\6\2\0\10\13"+
+    "\1\6\44\13\4\6\24\0\1\6\2\0\5\13\13\0"+
+    "\1\6\44\0\11\6\1\0\71\6\53\13\24\0\1\13"+
+    "\12\0\6\6\6\13\4\0\4\13\3\0\1\13\3\0"+
+    "\2\13\7\0\3\13\4\0\15\13\14\0\1\13\17\0"+
+    "\2\6\46\13\1\6\1\13\5\6\1\13\2\6\53\13"+
+    "\1\6\115\13\1\6\4\13\2\6\7\13\1\6\1\13"+
+    "\1\6\4\13\2\6\51\13\1\6\4\13\2\6\41\13"+
+    "\1\6\4\13\2\6\7\13\1\6\1\13\1\6\4\13"+
+    "\2\6\17\13\1\6\71\13\1\6\4\13\2\6\103\13"+
+    "\2\6\3\0\40\6\20\13\20\6\126\13\2\6\6\13"+
+    "\3\6\u016c\13\2\6\21\13\1\6\32\13\5\6\113\13"+
+    "\3\6\13\13\7\6\15\13\1\6\4\13\3\0\13\6"+
+    "\22\13\3\0\13\6\22\13\2\0\14\6\15\13\1\6"+
+    "\3\13\1\6\2\0\14\6\64\13\40\0\3\6\1\13"+
+    "\3\6\2\13\1\0\2\6\12\0\41\6\4\0\1\6"+
+    "\12\0\6\6\131\13\7\6\5\13\2\0\42\13\1\0"+
+    "\1\13\5\6\106\13\12\6\37\13\1\6\14\0\4\6"+
+    "\14\0\12\6\12\0\36\13\2\6\5\13\13\6\54\13"+
+    "\4\6\32\13\6\6\12\0\46\6\27\13\5\0\4\6"+
+    "\65\13\12\0\1\6\35\0\2\6\13\0\6\6\12\0"+
+    "\15\6\1\13\10\6\16\0\1\6\2\0\77\6\5\0"+
+    "\57\13\21\0\7\13\4\6\12\0\21\6\11\0\14\6"+
+    "\3\0\36\13\15\0\2\13\12\0\54\13\16\0\14\6"+
+    "\44\13\24\0\10\6\12\0\3\6\3\13\12\0\44\13"+
+    "\2\6\11\13\7\6\53\13\2\6\3\13\20\6\3\0"+
+    "\1\6\25\0\4\13\1\0\6\13\1\0\2\13\3\0"+
+    "\1\13\5\6\300\13\72\0\1\6\5\0\26\13\2\6"+
+    "\6\13\2\6\46\13\2\6\6\13\2\6\10\13\1\6"+
+    "\1\13\1\6\1\13\1\6\1\13\1\6\37\13\2\6"+
+    "\65\13\1\6\7\13\1\6\1\13\3\6\3\13\1\6"+
+    "\7\13\3\6\4\13\2\6\6\13\4\6\15\13\5\6"+
+    "\3\13\1\6\7\13\16\6\5\0\30\6\2\3\5\0"+
+    "\20\6\2\13\23\6\1\13\13\6\5\0\1\6\12\0"+
+    "\1\6\1\13\15\6\1\13\20\6\15\13\3\6\40\13"+
+    "\20\6\15\0\4\6\1\0\3\6\14\0\21\6\1\13"+
+    "\4\6\1\13\2\6\12\13\1\6\1\13\3\6\5\13"+
+    "\6\6\1\13\1\6\1\13\1\6\1\13\1\6\4\13"+
+    "\1\6\13\13\2\6\4\13\5\6\5\13\4\6\1\13"+
+    "\21\6\51\13\u0177\6\57\13\1\6\57\13\1\6\205\13"+
+    "\6\6\4\13\3\0\2\13\14\6\46\13\1\6\1\13"+
+    "\5\6\1\13\2\6\70\13\7\6\1\13\17\6\1\0"+
+    "\27\13\11\6\7\13\1\6\7\13\1\6\7\13\1\6"+
+    "\7\13\1\6\7\13\1\6\7\13\1\6\7\13\1\6"+
+    "\7\13\1\6\40\0\57\6\1\13\325\6\3\13\31\6"+
+    "\11\13\6\0\1\6\5\13\2\6\5\13\4\6\126\13"+
+    "\2\6\2\0\2\6\3\13\1\6\132\13\1\6\4\13"+
+    "\5\6\53\13\1\6\136\13\21\6\40\13\60\6\320\13"+
+    "\100\6\375\13\3\6\215\13\103\6\56\13\2\6\15\13"+
+    "\3\6\20\13\12\0\2\13\24\6\57\13\1\0\4\6"+
+    "\12\0\1\6\37\13\2\0\120\13\2\0\45\6\11\13"+
+    "\2\6\147\13\2\6\65\13\2\6\11\13\52\6\15\13"+
+    "\1\0\3\13\1\0\4\13\1\0\27\13\5\0\4\6"+
+    "\1\0\13\6\1\13\7\6\64\13\14\6\2\0\62\13"+
+    "\22\0\12\6\12\0\6\6\22\0\6\13\3\6\1\13"+
+    "\1\6\2\13\13\0\34\13\10\0\2\6\27\13\15\0"+
+    "\14\6\35\13\3\6\4\0\57\13\16\0\16\6\1\13"+
+    "\12\0\6\6\5\13\1\0\12\13\12\0\5\13\1\6"+
+    "\51\13\16\0\11\6\3\13\1\0\10\13\2\0\2\6"+
+    "\12\0\6\6\27\13\3\6\1\13\3\0\62\13\1\0"+
+    "\1\13\3\0\2\13\2\0\5\13\2\0\1\13\1\0"+
+    "\1\13\30\6\3\13\2\6\13\13\5\0\2\6\3\13"+
+    "\2\0\12\6\6\13\2\6\6\13\2\6\6\13\11\6"+
+    "\7\13\1\6\7\13\1\6\53\13\1\6\16\13\6\6"+
+    "\163\13\10\0\1\6\2\0\2\6\12\0\6\6\244\13"+
+    "\14\6\27\13\4\6\61\13\4\6\u0100\3\156\13\2\6"+
+    "\152\13\46\6\7\13\14\6\5\13\5\6\1\13\1\0"+
+    "\12\13\1\6\15\13\1\6\5\13\1\6\1\13\1\6"+
+    "\2\13\1\6\2\13\1\6\154\13\41\6\153\13\22\6"+
+    "\100\13\2\6\66\13\50\6\15\13\3\6\20\0\20\6"+
+    "\20\0\3\6\2\13\30\6\3\13\31\6\1\13\6\6"+
+    "\5\13\1\6\207\13\2\6\1\0\4\6\1\13\13\6"+
+    "\12\0\7\6\32\13\4\6\1\13\1\6\32\13\13\6"+
+    "\131\13\3\6\6\13\2\6\6\13\2\6\6\13\2\6"+
+    "\3\13\3\6\2\13\3\6\2\13\22\6\3\0\4\6"+
+    "\14\13\1\6\32\13\1\6\23\13\1\6\2\13\1\6"+
+    "\17\13\2\6\16\13\42\6\173\13\105\6\65\13\210\6"+
+    "\1\0\202\6\35\13\3\6\61\13\17\6\1\0\37\6"+
+    "\40\13\15\6\36\13\5\6\46\13\5\0\5\6\36\13"+
+    "\2\6\44\13\4\6\10\13\1\6\5\13\52\6\236\13"+
+    "\2\6\12\0\6\6\44\13\4\6\44\13\4\6\50\13"+
+    "\10\6\64\13\234\6\67\13\11\6\26\13\12\6\10\13"+
+    "\230\6\6\13\2\6\1\13\1\6\54\13\1\6\2\13"+
+    "\3\6\1\13\2\6\27\13\12\6\27\13\11\6\37\13"+
+    "\101\6\23\13\1\6\2\13\12\6\26\13\12\6\32\13"+
+    "\106\6\70\13\6\6\2\13\100\6\1\13\3\0\1\6"+
+    "\2\0\5\6\4\0\4\13\1\6\3\13\1\6\35\13"+
+    "\2\6\3\0\4\6\1\0\40\6\35\13\3\6\35\13"+
+    "\43\6\10\13\1\6\34\13\2\0\31\6\66\13\12\6"+
+    "\26\13\12\6\23\13\15\6\22\13\156\6\111\13\67\6"+
+    "\63\13\15\6\63\13\15\6\44\13\4\0\10\6\12\0"+
+    "\u0146\6\52\13\1\6\2\0\3\6\2\13\116\6\35\13"+
+    "\12\6\1\13\10\6\26\13\13\0\137\6\25\13\33\6"+
+    "\27\13\11\6\3\0\65\13\17\0\37\6\12\0\17\6"+
+    "\4\0\55\13\13\0\2\6\1\0\17\6\1\0\2\6"+
+    "\31\13\7\6\12\0\6\6\3\0\44\13\16\0\1\6"+
+    "\12\0\4\6\1\13\2\0\1\13\10\6\43\13\1\0"+
+    "\2\6\1\13\11\6\3\0\60\13\16\0\4\13\4\6"+
+    "\4\0\1\6\14\0\1\13\1\6\1\13\43\6\22\13"+
+    "\1\6\31\13\14\0\6\6\1\0\101\6\7\13\1\6"+
+    "\1\13\1\6\4\13\1\6\17\13\1\6\12\13\7\6"+
+    "\57\13\14\0\5\6\12\0\6\6\4\0\1\6\10\13"+
+    "\2\6\2\13\2\6\26\13\1\6\7\13\1\6\2\13"+
+    "\1\6\5\13\1\6\2\0\1\13\7\0\2\6\2\0"+
+    "\2\6\3\0\2\6\1\13\6\6\1\0\5\6\5\13"+
+    "\2\0\2\6\7\0\3\6\5\0\213\6\65\13\22\0"+
+    "\4\13\5\6\12\0\4\6\1\0\3\13\36\6\60\13"+
+    "\24\0\2\13\1\6\1\13\10\6\12\0\246\6\57\13"+
+    "\7\0\2\6\11\0\27\6\4\13\2\0\42\6\60\13"+
+    "\21\0\3\6\1\13\13\6\12\0\46\6\53\13\15\0"+
+    "\1\13\7\6\12\0\66\6\33\13\2\6\17\0\4\6"+
+    "\12\0\306\6\54\13\17\0\145\6\100\13\12\0\25\6"+
+    "\10\13\2\6\1\13\2\6\10\13\1\6\2\13\1\6"+
+    "\30\13\6\0\1\6\2\0\2\6\4\0\1\13\1\0"+
+    "\1\13\2\0\14\6\12\0\106\6\10\13\2\6\47\13"+
+    "\7\0\2\6\7\0\1\13\1\6\1\13\1\0\33\6"+
+    "\1\13\12\0\50\13\7\0\1\13\4\0\10\6\1\0"+
+    "\10\6\1\13\13\0\56\13\20\0\3\6\1\13\42\6"+
+    "\71\13\7\6\11\13\1\6\45\13\10\0\1\6\10\0"+
+    "\1\13\17\6\12\0\30\6\36\13\2\6\26\0\1\6"+
+    "\16\0\111\6\7\13\1\6\2\13\1\6\46\13\6\0"+
+    "\3\6\1\0\1\6\2\0\1\6\7\0\1\13\1\0"+
+    "\10\6\12\0\6\6\6\13\1\6\2\13\1\6\40\13"+
+    "\5\0\1\6\2\0\1\6\5\0\1\13\7\6\12\0"+
+    "\u0136\6\23\13\4\0\271\6\1\13\54\6\4\13\37\6"+
+    "\232\13\146\6\157\13\21\6\304\13\274\6\57\13\1\6"+
+    "\11\0\307\6\107\13\271\6\71\13\7\6\37\13\1\6"+
+    "\12\0\146\6\36\13\2\6\5\0\13\6\60\13\7\0"+
+    "\11\6\4\13\14\6\12\0\11\6\25\13\5\6\23\13"+
+    "\260\6\100\13\200\6\113\13\4\6\1\0\1\13\67\0"+
+    "\7\6\4\0\15\13\100\6\2\13\1\6\1\13\1\0"+
+    "\13\6\2\0\16\6\370\13\10\6\326\13\52\6\11\13"+
+    "\367\6\37\13\61\6\3\13\21\6\4\13\10\6\u018c\13"+
+    "\4\6\153\13\5\6\15\13\3\6\11\13\7\6\12\13"+
+    "\3\6\2\0\1\6\4\0\301\6\5\0\3\6\26\0"+
+    "\2\6\7\0\36\6\4\0\224\6\3\0\273\6\125\13"+
+    "\1\6\107\13\1\6\2\13\2\6\1\13\2\6\2\13"+
+    "\2\6\4\13\1\6\14\13\1\6\1\13\1\6\7\13"+
+    "\1\6\101\13\1\6\4\13\2\6\10\13\1\6\7\13"+
+    "\1\6\34\13\1\6\4\13\1\6\5\13\1\6\1\13"+
+    "\3\6\7\13\1\6\u0154\13\2\6\31\13\1\6\31\13"+
+    "\1\6\37\13\1\6\31\13\1\6\37\13\1\6\31\13"+
+    "\1\6\37\13\1\6\31\13\1\6\37\13\1\6\31\13"+
+    "\1\6\10\13\2\6\151\0\4\6\62\0\10\6\1\0"+
+    "\16\6\1\0\26\6\5\0\1\6\17\0\120\6\7\0"+
+    "\1\6\21\0\2\6\7\0\1\6\2\0\1\6\5\0"+
+    "\325\6\55\13\3\6\7\0\7\13\2\6\12\0\4\6"+
+    "\1\13\u0171\6\54\13\16\0\5\6\306\13\13\6\7\0"+
+    "\51\6\104\13\7\0\1\13\4\6\12\0\u0156\6\1\13"+
+    "\117\6\4\13\1\6\33\13\1\6\2\13\1\6\1\13"+
+    "\2\6\1\13\1\6\12\13\1\6\4\13\1\6\1\13"+
+    "\1\6\1\13\6\6\1\13\4\6\1\13\1\6\1\13"+
+    "\1\6\1\13\1\6\3\13\1\6\2\13\1\6\1\13"+
+    "\2\6\1\13\1\6\1\13\1\6\1\13\1\6\1\13"+
+    "\1\6\1\13\1\6\2\13\1\6\1\13\2\6\4\13"+
+    "\1\6\7\13\1\6\4\13\1\6\4\13\1\6\1\13"+
+    "\1\6\12\13\1\6\21\13\5\6\3\13\1\6\5\13"+
+    "\1\6\21\13\u0134\6\12\0\6\6\336\13\42\6\65\13"+
+    "\13\6\336\13\2\6\u0182\13\16\6\u0131\13\37\6\36\13"+
+    "\342\6\113\13\266\6\1\0\36\6\140\0\200\6\360\0"+
+    "\20\6";
+
+  private static int [] zzUnpackcmap_blocks() {
+    int [] result = new int[31232];
+    int offset = 0;
+    offset = zzUnpackcmap_blocks(ZZ_CMAP_BLOCKS_PACKED_0, offset, result);
+    return result;
+  }
+
+  private static int zzUnpackcmap_blocks(String packed, int offset, int [] result) {
+    int i = 0;       /* index in packed string  */
+    int j = offset;  /* index in unpacked array */
+    int l = packed.length();
+    while (i < l) {
+      int count = packed.charAt(i++);
+      int value = packed.charAt(i++);
+      do result[j++] = value; while (--count > 0);
+    }
+    return j;
+  }
+
+  /**
+   * Translates DFA states to action switch labels.
+   */
+  private static final int [] ZZ_ACTION = zzUnpackAction();
+
+  private static final String ZZ_ACTION_PACKED_0 =
+    "\6\0\1\1\1\2\2\3\1\4\1\5\1\1\1\6"+
+    "\1\7\1\10\1\11\1\12\1\13\1\4\2\14\1\15"+
+    "\1\16\1\17\20\6\1\20\1\21\1\22\2\23\1\24"+
+    "\1\1\1\25\1\26\1\1\2\27\2\30\1\31\2\32"+
+    "\7\0\1\33\1\0\1\34\4\14\2\33\1\0\1\14"+
+    "\1\0\11\6\1\35\5\6\1\35\13\6\1\22\1\0"+
+    "\1\36\4\0\1\37\6\0\2\34\2\14\1\0\1\33"+
+    "\2\14\16\6\1\40\17\6\2\0\2\36\11\0\3\14"+
+    "\23\6\2\0\1\41\4\0\3\14\11\6\1\0\1\37"+
+    "\2\0\3\14\4\6\3\14\2\6\3\14\1\6\3\14"+
+    "\1\6\5\14\1\0\2\14\1\0\2\14\1\0\2\14"+
+    "\1\0\2\14\1\0\2\14\1\0\1\14\1\33\1\0"+
+    "\1\33\1\0\4\33";
+
+  private static int [] zzUnpackAction() {
+    int [] result = new int[264];
+    int offset = 0;
+    offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
+    return result;
+  }
+
+  private static int zzUnpackAction(String packed, int offset, int [] result) {
+    int i = 0;       /* index in packed string  */
+    int j = offset;  /* index in unpacked array */
+    int l = packed.length();
+    while (i < l) {
+      int count = packed.charAt(i++);
+      int value = packed.charAt(i++);
+      do result[j++] = value; while (--count > 0);
+    }
+    return j;
+  }
+
+
+  /**
+   * Translates a state to a row index in the transition table
+   */
+  private static final int [] ZZ_ROWMAP = zzUnpackRowMap();
+
+  private static final String ZZ_ROWMAP_PACKED_0 =
+    "\0\0\0\105\0\212\0\317\0\u0114\0\u0159\0\u019e\0\u019e"+
+    "\0\u019e\0\u01e3\0\u019e\0\u019e\0\u0228\0\u026d\0\u019e\0\u019e"+
+    "\0\u019e\0\u019e\0\u02b2\0\u02f7\0\u033c\0\u0381\0\u019e\0\u019e"+
+    "\0\u019e\0\u03c6\0\u040b\0\u0450\0\u0495\0\u04da\0\u051f\0\u0564"+
+    "\0\u05a9\0\u05ee\0\u0633\0\u0678\0\u06bd\0\u0702\0\u0747\0\u078c"+
+    "\0\u07d1\0\u019e\0\u019e\0\u0816\0\u019e\0\u085b\0\u019e\0\u08a0"+
+    "\0\u019e\0\u019e\0\u08e5\0\u019e\0\u092a\0\u019e\0\u092a\0\u019e"+
+    "\0\u019e\0\u096f\0\u0228\0\u09b4\0\u09f9\0\u0a3e\0\u0a83\0\u0ac8"+
+    "\0\u0b0d\0\u0b52\0\u0b97\0\u0bdc\0\u0c21\0\u0c66\0\u0cab\0\u0cf0"+
+    "\0\u0d35\0\u019e\0\u0d7a\0\u019e\0\u0dbf\0\u0e04\0\u0e49\0\u0e8e"+
+    "\0\u0ed3\0\u0f18\0\u0f5d\0\u0fa2\0\u0fe7\0\u102c\0\u1071\0\u10b6"+
+    "\0\u10fb\0\u1140\0\u1185\0\u11ca\0\u026d\0\u120f\0\u1254\0\u1299"+
+    "\0\u12de\0\u1323\0\u1368\0\u13ad\0\u13f2\0\u1437\0\u147c\0\u14c1"+
+    "\0\u019e\0\u1506\0\u154b\0\u1590\0\u15d5\0\u161a\0\u165f\0\u16a4"+
+    "\0\u16e9\0\u172e\0\u1773\0\u17b8\0\u17fd\0\u1842\0\u019e\0\u1887"+
+    "\0\u18cc\0\u1911\0\u1956\0\u199b\0\u19e0\0\u1a25\0\u1a6a\0\u1aaf"+
+    "\0\u1af4\0\u1b39\0\u1b7e\0\u1bc3\0\u1c08\0\u1c4d\0\u1c92\0\u1cd7"+
+    "\0\u1d1c\0\u1d61\0\u1da6\0\u1deb\0\u026d\0\u1e30\0\u1e75\0\u1eba"+
+    "\0\u1eff\0\u1f44\0\u1f89\0\u1fce\0\u2013\0\u2058\0\u209d\0\u20e2"+
+    "\0\u2127\0\u216c\0\u21b1\0\u21f6\0\u223b\0\u2280\0\u019e\0\u22c5"+
+    "\0\u230a\0\u234f\0\u2394\0\u23d9\0\u241e\0\u2463\0\u24a8\0\u24ed"+
+    "\0\u2532\0\u2577\0\u25bc\0\u2601\0\u2646\0\u268b\0\u26d0\0\u2715"+
+    "\0\u275a\0\u279f\0\u27e4\0\u2829\0\u286e\0\u28b3\0\u28f8\0\u293d"+
+    "\0\u2982\0\u29c7\0\u2a0c\0\u2a51\0\u2a96\0\u2adb\0\u2b20\0\u2b65"+
+    "\0\u2baa\0\u019e\0\u2bef\0\u2c34\0\u2c79\0\u2cbe\0\u2d03\0\u2d48"+
+    "\0\u2d8d\0\u2dd2\0\u2e17\0\u2e5c\0\u2ea1\0\u2ee6\0\u2f2b\0\u2f70"+
+    "\0\u2fb5\0\u2ffa\0\u303f\0\u019e\0\u3084\0\u30c9\0\u310e\0\u3153"+
+    "\0\u3198\0\u31dd\0\u3222\0\u3267\0\u32ac\0\u32f1\0\u3336\0\u337b"+
+    "\0\u33c0\0\u3405\0\u344a\0\u348f\0\u34d4\0\u3519\0\u355e\0\u35a3"+
+    "\0\u35e8\0\u362d\0\u3672\0\u36b7\0\u36fc\0\u3741\0\u3786\0\u37cb"+
+    "\0\u3810\0\u3855\0\u389a\0\u38df\0\u3924\0\u3969\0\u39ae\0\u39f3"+
+    "\0\u3a38\0\u3a7d\0\u3ac2\0\u3b07\0\u3b4c\0\u3b91\0\u3bd6\0\u3c1b"+
+    "\0\u3c1b\0\u3c60\0\u3ca5\0\u3cea\0\u3d2f\0\u3d74\0\u3db9\0\u3dfe";
+
+  private static int [] zzUnpackRowMap() {
+    int [] result = new int[264];
+    int offset = 0;
+    offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
+    return result;
+  }
+
+  private static int zzUnpackRowMap(String packed, int offset, int [] result) {
+    int i = 0;  /* index in packed string  */
+    int j = offset;  /* index in unpacked array */
+    int l = packed.length() - 1;
+    while (i < l) {
+      int high = packed.charAt(i++) << 16;
+      result[j++] = high | packed.charAt(i++);
+    }
+    return j;
+  }
+
+  /**
+   * The transition table of the DFA
+   */
+  private static final int [] ZZ_TRANS = zzUnpacktrans();
+
+  private static final String ZZ_TRANS_PACKED_0 =
+    "\1\7\1\10\1\11\1\7\1\10\1\12\1\7\1\10"+
+    "\1\13\1\14\1\15\1\16\1\17\1\20\1\21\2\13"+
+    "\1\22\1\13\1\23\1\24\1\25\4\26\1\27\1\13"+
+    "\12\16\1\30\1\7\1\31\1\32\1\33\1\34\1\35"+
+    "\1\36\1\37\1\40\1\41\1\16\1\42\1\16\1\43"+
+    "\4\16\1\44\1\45\1\46\1\47\1\50\1\51\3\16"+
+    "\1\52\1\53\1\7\2\54\1\55\2\54\1\56\3\54"+
+    "\1\57\35\54\1\60\35\54\2\61\1\55\2\61\1\56"+
+    "\6\61\1\62\32\61\1\63\35\61\1\7\1\64\1\55"+
+    "\1\7\1\64\1\56\1\7\1\64\1\7\1\64\10\7"+
+    "\2\64\1\65\5\64\1\7\13\64\3\7\31\64\4\7"+
+    "\1\66\1\55\1\7\1\66\1\56\1\7\2\66\4\7"+
+    "\7\66\1\67\22\66\1\70\34\66\2\7\1\66\1\71"+
+    "\1\7\1\66\1\72\1\7\1\66\75\7\107\0\1\11"+
+    "\111\0\1\73\45\0\1\74\1\75\3\0\1\76\1\0"+
+    "\1\77\3\0\1\100\3\0\1\101\10\0\1\16\12\0"+
+    "\1\16\11\0\5\16\2\0\12\16\3\0\31\16\2\0"+
+    "\1\16\25\0\5\102\72\0\1\103\4\0\1\104\103\0"+
+    "\1\102\1\0\1\105\1\106\1\107\1\110\1\111\5\0"+
+    "\1\112\1\113\2\0\1\114\1\113\1\115\7\0\1\112"+
+    "\1\113\1\112\4\0\1\114\3\0\1\113\6\0\1\115"+
+    "\30\0\1\102\1\0\5\26\5\0\1\112\1\113\2\0"+
+    "\1\114\1\113\10\0\1\112\1\113\1\112\4\0\1\114"+
+    "\3\0\1\113\14\0\1\16\12\0\1\16\11\0\5\16"+
+    "\2\0\1\16\1\116\1\117\3\16\1\120\3\16\3\0"+
+    "\31\16\2\0\2\16\12\0\1\16\11\0\5\16\2\0"+
+    "\12\16\3\0\23\16\1\121\5\16\2\0\2\16\12\0"+
+    "\1\16\11\0\5\16\2\0\12\16\3\0\20\16\1\122"+
+    "\10\16\2\0\2\16\12\0\1\16\11\0\5\16\2\0"+
+    "\12\16\3\0\1\16\1\123\6\16\1\124\5\16\1\125"+
+    "\12\16\2\0\2\16\12\0\1\16\11\0\5\16\2\0"+
+    "\12\16\3\0\5\16\1\126\10\16\1\127\12\16\2\0"+
+    "\2\16\12\0\1\16\11\0\5\16\2\0\12\16\3\0"+
+    "\13\16\1\130\1\16\1\131\10\16\1\132\2\16\2\0"+
+    "\2\16\12\0\1\16\11\0\5\16\2\0\12\16\3\0"+
+    "\13\16\1\133\2\16\1\134\12\16\2\0\2\16\12\0"+
+    "\1\16\11\0\5\16\2\0\12\16\3\0\16\16\1\121"+
+    "\12\16\2\0\2\16\12\0\1\16\11\0\5\16\2\0"+
+    "\12\16\3\0\6\16\1\135\6\16\1\136\13\16\2\0"+
+    "\2\16\12\0\1\16\11\0\5\16\2\0\12\16\3\0"+
+    "\16\16\1\137\12\16\2\0\2\16\12\0\1\16\11\0"+
+    "\5\16\2\0\12\16\3\0\5\16\1\140\23\16\2\0"+
+    "\2\16\12\0\1\16\11\0\5\16\2\0\12\16\3\0"+
+    "\10\16\1\141\1\142\10\16\1\143\2\16\1\144\3\16"+
+    "\2\0\2\16\12\0\1\16\11\0\5\16\2\0\12\16"+
+    "\3\0\27\16\1\145\1\16\2\0\2\16\12\0\1\16"+
+    "\11\0\5\16\2\0\12\16\3\0\15\16\1\146\13\16"+
+    "\2\0\2\16\12\0\1\16\11\0\5\16\2\0\12\16"+
+    "\3\0\16\16\1\147\12\16\2\0\2\16\12\0\1\16"+
+    "\11\0\5\16\2\0\12\16\3\0\10\16\1\150\20\16"+
+    "\2\0\1\16\2\54\1\0\2\54\1\0\3\54\1\0"+
+    "\35\54\1\0\35\54\2\0\1\55\102\0\2\151\4\0"+
+    "\76\151\1\0\2\61\4\0\76\61\20\0\1\152\4\0"+
+    "\1\153\62\0\1\71\160\0\1\154\112\0\1\155\1\0"+
+    "\1\156\2\0\1\157\72\0\1\160\6\0\1\161\100\0"+
+    "\1\162\113\0\1\163\101\0\1\164\43\0\5\102\5\0"+
+    "\1\112\1\113\3\0\1\113\10\0\1\112\1\113\1\112"+
+    "\10\0\1\113\14\0\17\165\1\166\65\165\2\104\1\167"+
+    "\2\104\1\170\77\104\23\0\1\102\1\0\1\105\1\106"+
+    "\1\107\1\110\1\111\5\0\1\112\1\113\2\0\1\114"+
+    "\1\113\10\0\1\112\1\113\1\112\4\0\1\114\3\0"+
+    "\1\113\37\0\1\102\1\0\4\110\1\111\5\0\1\112"+
+    "\1\113\2\0\1\114\1\113\10\0\1\112\1\113\1\112"+
+    "\4\0\1\114\3\0\1\113\37\0\1\102\1\0\4\171"+
+    "\1\111\5\0\1\112\1\113\2\0\1\114\1\113\10\0"+
+    "\1\112\1\113\1\112\4\0\1\114\3\0\1\113\37\0"+
+    "\1\102\1\0\4\172\1\111\5\0\1\112\1\113\2\0"+
+    "\1\114\1\113\10\0\1\112\1\113\1\112\4\0\1\114"+
+    "\3\0\1\113\37\0\1\102\1\0\5\111\5\0\1\112"+
+    "\1\113\3\0\1\113\10\0\1\112\1\113\1\112\10\0"+
+    "\1\113\34\0\1\173\1\0\1\173\2\0\5\174\100\0"+
+    "\1\175\4\176\2\0\5\176\11\0\6\176\25\0\1\16"+
+    "\12\0\1\16\11\0\5\16\2\0\12\16\3\0\16\16"+
+    "\1\177\12\16\2\0\2\16\12\0\1\16\11\0\5\16"+
+    "\2\0\12\16\3\0\16\16\1\200\12\16\2\0\2\16"+
+    "\12\0\1\16\11\0\5\16\2\0\12\16\3\0\14\16"+
+    "\1\201\14\16\2\0\2\16\12\0\1\16\11\0\5\16"+
+    "\2\0\12\16\3\0\22\16\1\202\6\16\2\0\2\16"+
+    "\12\0\1\16\11\0\5\16\2\0\12\16\3\0\5\16"+
+    "\1\203\23\16\2\0\2\16\12\0\1\16\11\0\5\16"+
+    "\2\0\12\16\3\0\21\16\1\204\1\205\6\16\2\0"+
+    "\2\16\12\0\1\16\11\0\5\16\2\0\12\16\3\0"+
+    "\1\16\1\206\27\16\2\0\2\16\12\0\1\16\11\0"+
+    "\5\16\2\0\12\16\3\0\15\16\1\207\13\16\2\0"+
+    "\2\16\12\0\1\16\11\0\5\16\2\0\12\16\3\0"+
+    "\6\16\1\210\22\16\2\0\2\16\12\0\1\16\11\0"+
+    "\5\16\2\0\12\16\3\0\23\16\1\211\5\16\2\0"+
+    "\2\16\12\0\1\16\11\0\5\16\2\0\12\16\3\0"+
+    "\21\16\1\204\7\16\2\0\2\16\12\0\1\16\11\0"+
+    "\5\16\2\0\12\16\3\0\23\16\1\212\5\16\2\0"+
+    "\2\16\12\0\1\16\11\0\5\16\2\0\12\16\3\0"+
+    "\22\16\1\213\6\16\2\0\2\16\12\0\1\16\11\0"+
+    "\5\16\2\0\12\16\3\0\16\16\1\214\12\16\2\0"+
+    "\2\16\12\0\1\16\11\0\5\16\2\0\12\16\3\0"+
+    "\20\16\1\135\10\16\2\0\2\16\12\0\1\16\11\0"+
+    "\5\16\2\0\12\16\3\0\22\16\1\215\6\16\2\0"+
+    "\2\16\12\0\1\16\11\0\5\16\2\0\12\16\3\0"+
+    "\15\16\1\216\13\16\2\0\2\16\12\0\1\16\11\0"+
+    "\5\16\2\0\12\16\3\0\7\16\1\217\12\16\1\220"+
+    "\6\16\2\0\2\16\12\0\1\16\11\0\5\16\2\0"+
+    "\12\16\3\0\16\16\1\221\12\16\2\0\2\16\12\0"+
+    "\1\16\11\0\5\16\2\0\12\16\3\0\7\16\1\222"+
+    "\20\16\1\223\2\0\2\16\12\0\1\16\11\0\5\16"+
+    "\2\0\12\16\3\0\1\16\1\224\16\16\1\225\10\16"+
+    "\2\0\2\16\12\0\1\16\11\0\5\16\2\0\12\16"+
+    "\3\0\11\16\1\226\17\16\2\0\2\16\12\0\1\16"+
+    "\11\0\5\16\2\0\12\16\3\0\17\16\1\227\11\16"+
+    "\2\0\2\16\12\0\1\16\11\0\5\16\2\0\12\16"+
+    "\3\0\11\16\1\230\7\16\1\231\7\16\2\0\2\16"+
+    "\12\0\1\16\11\0\5\16\2\0\12\16\3\0\11\16"+
+    "\1\232\1\16\1\233\15\16\2\0\2\16\12\0\1\16"+
+    "\11\0\5\16\2\0\12\16\3\0\11\16\1\234\17\16"+
+    "\2\0\1\16\17\235\1\236\65\235\2\153\1\237\2\153"+
+    "\1\240\77\153\57\0\1\241\107\0\1\242\7\0\1\243"+
+    "\67\0\1\244\120\0\1\245\70\0\1\246\10\0\1\164"+
+    "\72\0\1\247\116\0\1\243\70\0\1\250\107\0\1\246"+
+    "\27\0\17\165\1\251\65\165\17\0\1\166\4\0\1\167"+
+    "\62\0\1\167\125\0\1\102\1\0\4\252\1\111\5\0"+
+    "\1\112\1\113\2\0\1\114\1\113\10\0\1\112\1\113"+
+    "\1\112\4\0\1\114\3\0\1\113\37\0\1\102\1\0"+
+    "\4\253\1\111\5\0\1\112\1\113\2\0\1\114\1\113"+
+    "\10\0\1\112\1\113\1\112\4\0\1\114\3\0\1\113"+
+    "\41\0\5\174\100\0\5\174\5\0\1\112\15\0\1\112"+
+    "\1\0\1\112\52\0\1\175\4\176\2\0\5\176\2\0"+
+    "\1\114\6\0\6\176\4\0\1\114\45\0\5\254\2\0"+
+    "\5\254\2\0\1\114\6\0\6\254\4\0\1\114\20\0"+
+    "\1\16\12\0\1\16\11\0\5\16\2\0\12\16\3\0"+
+    "\16\16\1\255\12\16\2\0\2\16\12\0\1\16\11\0"+
+    "\5\16\2\0\12\16\3\0\14\16\1\256\14\16\2\0"+
+    "\2\16\12\0\1\16\11\0\5\16\2\0\12\16\3\0"+
+    "\1\16\1\257\27\16\2\0\2\16\12\0\1\16\11\0"+
+    "\5\16\2\0\12\16\3\0\16\16\1\135\12\16\2\0"+
+    "\2\16\12\0\1\16\11\0\5\16\2\0\12\16\3\0"+
+    "\1\16\1\260\27\16\2\0\2\16\12\0\1\16\11\0"+
+    "\5\16\2\0\12\16\3\0\5\16\1\135\23\16\2\0"+
+    "\2\16\12\0\1\16\11\0\5\16\2\0\12\16\3\0"+
+    "\3\16\1\261\25\16\2\0\2\16\12\0\1\16\11\0"+
+    "\5\16\2\0\12\16\3\0\20\16\1\215\10\16\2\0"+
+    "\2\16\12\0\1\16\11\0\5\16\2\0\12\16\3\0"+
+    "\21\16\1\262\1\263\6\16\2\0\2\16\12\0\1\16"+
+    "\11\0\5\16\2\0\12\16\3\0\1\16\1\264\27\16"+
+    "\2\0\2\16\12\0\1\16\11\0\5\16\2\0\12\16"+
+    "\3\0\2\16\1\265\26\16\2\0\2\16\12\0\1\16"+
+    "\11\0\5\16\2\0\12\16\3\0\14\16\1\135\14\16"+
+    "\2\0\2\16\12\0\1\16\11\0\5\16\2\0\12\16"+
+    "\3\0\5\16\1\266\23\16\2\0\2\16\12\0\1\16"+
+    "\11\0\5\16\2\0\12\16\3\0\1\16\1\136\27\16"+
+    "\2\0\2\16\12\0\1\16\11\0\5\16\2\0\12\16"+
+    "\3\0\7\16\1\215\21\16\2\0\2\16\12\0\1\16"+
+    "\11\0\5\16\2\0\12\16\3\0\11\16\1\267\17\16"+
+    "\2\0\2\16\12\0\1\16\11\0\5\16\2\0\12\16"+
+    "\3\0\23\16\1\266\5\16\2\0\2\16\12\0\1\16"+
+    "\11\0\5\16\2\0\12\16\3\0\20\16\1\136\10\16"+
+    "\2\0\2\16\12\0\1\16\11\0\5\16\2\0\12\16"+
+    "\3\0\15\16\1\270\13\16\2\0\2\16\12\0\1\16"+
+    "\11\0\5\16\2\0\12\16\3\0\5\16\1\271\23\16"+
+    "\2\0\2\16\12\0\1\16\11\0\5\16\2\0\12\16"+
+    "\3\0\22\16\1\272\6\16\2\0\2\16\12\0\1\16"+
+    "\11\0\5\16\2\0\12\16\3\0\23\16\1\273\5\16"+
+    "\2\0\2\16\12\0\1\16\11\0\5\16\2\0\12\16"+
+    "\3\0\22\16\1\205\6\16\2\0\2\16\12\0\1\16"+
+    "\11\0\5\16\2\0\12\16\3\0\5\16\1\274\23\16"+
+    "\2\0\2\16\12\0\1\16\11\0\5\16\2\0\12\16"+
+    "\3\0\16\16\1\275\12\16\2\0\2\16\12\0\1\16"+
+    "\11\0\5\16\2\0\12\16\3\0\11\16\1\276\17\16"+
+    "\2\0\2\16\12\0\1\16\11\0\5\16\2\0\12\16"+
+    "\3\0\4\16\1\215\24\16\2\0\2\16\12\0\1\16"+
+    "\11\0\5\16\2\0\12\16\3\0\1\16\1\277\27\16"+
+    "\2\0\2\16\12\0\1\16\11\0\5\16\2\0\12\16"+
+    "\3\0\13\16\1\204\15\16\2\0\1\16\17\235\1\300"+
+    "\65\235\17\0\1\236\4\0\1\237\62\0\1\237\164\0"+
+    "\1\301\101\0\1\302\103\0\1\302\110\0\1\242\111\0"+
+    "\1\303\73\0\1\304\112\0\1\305\100\0\1\306\24\0"+
+    "\17\165\1\251\4\165\1\167\60\165\23\0\1\102\1\0"+
+    "\4\307\1\111\5\0\1\112\1\113\2\0\1\114\1\113"+
+    "\10\0\1\112\1\113\1\112\4\0\1\114\3\0\1\113"+
+    "\37\0\1\102\1\0\4\310\1\111\5\0\1\112\1\113"+
+    "\2\0\1\114\1\113\10\0\1\112\1\113\1\112\4\0"+
+    "\1\114\3\0\1\113\41\0\5\311\2\0\5\311\2\0"+
+    "\1\114\6\0\6\311\4\0\1\114\20\0\1\16\12\0"+
+    "\1\16\11\0\5\16\2\0\12\16\3\0\13\16\1\215"+
+    "\15\16\2\0\2\16\12\0\1\16\11\0\5\16\2\0"+
+    "\12\16\3\0\17\16\1\312\11\16\2\0\2\16\12\0"+
+    "\1\16\11\0\5\16\2\0\12\16\3\0\7\16\1\313"+
+    "\21\16\2\0\2\16\12\0\1\16\11\0\5\16\2\0"+
+    "\12\16\3\0\12\16\1\135\16\16\2\0\2\16\12\0"+
+    "\1\16\11\0\5\16\2\0\12\16\3\0\10\16\1\135"+
+    "\20\16\2\0\2\16\12\0\1\16\11\0\5\16\2\0"+
+    "\12\16\3\0\22\16\1\135\6\16\2\0\2\16\12\0"+
+    "\1\16\11\0\5\16\2\0\12\16\3\0\11\16\1\314"+
+    "\17\16\2\0\2\16\12\0\1\16\11\0\5\16\2\0"+
+    "\12\16\3\0\23\16\1\315\5\16\2\0\2\16\12\0"+
+    "\1\16\11\0\5\16\2\0\12\16\3\0\13\16\1\316"+
+    "\15\16\2\0\2\16\12\0\1\16\11\0\5\16\2\0"+
+    "\12\16\3\0\20\16\1\275\10\16\2\0\2\16\12\0"+
+    "\1\16\11\0\5\16\2\0\12\16\3\0\21\16\1\317"+
+    "\7\16\2\0\2\16\12\0\1\16\11\0\5\16\2\0"+
+    "\12\16\3\0\5\16\1\232\23\16\2\0\2\16\12\0"+
+    "\1\16\11\0\5\16\2\0\12\16\3\0\16\16\1\320"+
+    "\12\16\2\0\2\16\12\0\1\16\11\0\5\16\2\0"+
+    "\12\16\3\0\11\16\1\321\17\16\2\0\2\16\12\0"+
+    "\1\16\11\0\5\16\2\0\12\16\3\0\3\16\1\262"+
+    "\25\16\2\0\2\16\12\0\1\16\11\0\5\16\2\0"+
+    "\12\16\3\0\4\16\1\322\24\16\2\0\2\16\12\0"+
+    "\1\16\11\0\5\16\2\0\12\16\3\0\15\16\1\135"+
+    "\13\16\2\0\2\16\12\0\1\16\11\0\5\16\2\0"+
+    "\12\16\3\0\7\16\1\222\21\16\2\0\2\16\12\0"+
+    "\1\16\11\0\5\16\2\0\12\16\3\0\22\16\1\150"+
+    "\6\16\2\0\1\16\17\235\1\300\4\235\1\237\60\235"+
+    "\66\0\1\323\107\0\1\302\72\0\1\324\121\0\1\325"+
+    "\75\0\1\326\42\0\1\102\1\0\4\327\1\111\5\0"+
+    "\1\112\1\113\2\0\1\114\1\113\10\0\1\112\1\113"+
+    "\1\112\4\0\1\114\3\0\1\113\37\0\1\102\1\0"+
+    "\4\330\1\111\5\0\1\112\1\113\2\0\1\114\1\113"+
+    "\10\0\1\112\1\113\1\112\4\0\1\114\3\0\1\113"+
+    "\41\0\5\331\2\0\5\331\2\0\1\114\6\0\6\331"+
+    "\4\0\1\114\20\0\1\16\12\0\1\16\11\0\5\16"+
+    "\2\0\12\16\3\0\13\16\1\332\15\16\2\0\2\16"+
+    "\12\0\1\16\11\0\5\16\2\0\12\16\3\0\11\16"+
+    "\1\333\17\16\2\0\2\16\12\0\1\16\11\0\5\16"+
+    "\2\0\12\16\3\0\15\16\1\334\13\16\2\0\2\16"+
+    "\12\0\1\16\11\0\5\16\2\0\12\16\3\0\13\16"+
+    "\1\262\15\16\2\0\2\16\12\0\1\16\11\0\5\16"+
+    "\2\0\12\16\3\0\5\16\1\215\23\16\2\0\2\16"+
+    "\12\0\1\16\11\0\5\16\2\0\12\16\3\0\22\16"+
+    "\1\335\6\16\2\0\2\16\12\0\1\16\11\0\5\16"+
+    "\2\0\12\16\3\0\6\16\1\135\22\16\2\0\2\16"+
+    "\12\0\1\16\11\0\5\16\2\0\12\16\3\0\3\16"+
+    "\1\135\25\16\2\0\2\16\12\0\1\16\11\0\5\16"+
+    "\2\0\12\16\3\0\5\16\1\320\23\16\2\0\1\16"+
+    "\56\0\1\324\103\0\1\243\101\0\1\302\55\0\1\102"+
+    "\1\0\4\336\1\111\5\0\1\112\1\113\2\0\1\114"+
+    "\1\113\10\0\1\112\1\113\1\112\4\0\1\114\3\0"+
+    "\1\113\37\0\1\102\1\0\4\337\1\111\5\0\1\112"+
+    "\1\113\2\0\1\114\1\113\10\0\1\112\1\113\1\112"+
+    "\4\0\1\114\3\0\1\113\41\0\5\340\2\0\5\340"+
+    "\2\0\1\114\6\0\6\340\4\0\1\114\20\0\1\16"+
+    "\12\0\1\16\11\0\5\16\2\0\12\16\3\0\5\16"+
+    "\1\341\23\16\2\0\2\16\12\0\1\16\11\0\5\16"+
+    "\2\0\12\16\3\0\15\16\1\342\13\16\2\0\2\16"+
+    "\12\0\1\16\11\0\5\16\2\0\12\16\3\0\23\16"+
+    "\1\204\5\16\2\0\2\16\12\0\1\16\11\0\5\16"+
+    "\2\0\12\16\3\0\5\16\1\134\23\16\2\0\1\16"+
+    "\23\0\1\102\1\0\4\343\1\111\5\0\1\112\1\113"+
+    "\2\0\1\114\1\113\10\0\1\112\1\113\1\112\4\0"+
+    "\1\114\3\0\1\113\37\0\1\102\1\0\4\344\1\111"+
+    "\5\0\1\112\1\113\2\0\1\114\1\113\10\0\1\112"+
+    "\1\113\1\112\4\0\1\114\3\0\1\113\41\0\5\345"+
+    "\2\0\5\345\2\0\1\114\6\0\6\345\4\0\1\114"+
+    "\20\0\1\16\12\0\1\16\11\0\5\16\2\0\12\16"+
+    "\3\0\26\16\1\215\2\16\2\0\2\16\12\0\1\16"+
+    "\11\0\5\16\2\0\12\16\3\0\1\16\1\346\27\16"+
+    "\2\0\1\16\23\0\1\102\1\0\4\347\1\111\5\0"+
+    "\1\112\1\113\2\0\1\114\1\113\10\0\1\112\1\113"+
+    "\1\112\4\0\1\114\3\0\1\113\37\0\1\102\1\0"+
+    "\4\350\1\111\5\0\1\112\1\113\2\0\1\114\1\113"+
+    "\10\0\1\112\1\113\1\112\4\0\1\114\3\0\1\113"+
+    "\41\0\5\351\2\0\5\351\2\0\1\114\6\0\6\351"+
+    "\4\0\1\114\20\0\1\16\12\0\1\16\11\0\5\16"+
+    "\2\0\12\16\3\0\20\16\1\352\10\16\2\0\1\16"+
+    "\23\0\1\102\1\0\4\353\1\111\5\0\1\112\1\113"+
+    "\2\0\1\114\1\113\10\0\1\112\1\113\1\112\4\0"+
+    "\1\114\3\0\1\113\37\0\1\102\1\0\4\354\1\111"+
+    "\5\0\1\112\1\113\2\0\1\114\1\113\10\0\1\112"+
+    "\1\113\1\112\4\0\1\114\3\0\1\113\41\0\5\355"+
+    "\2\0\5\355\2\0\1\114\6\0\6\355\4\0\1\114"+
+    "\20\0\1\16\12\0\1\16\11\0\5\16\2\0\12\16"+
+    "\3\0\27\16\1\215\1\16\2\0\1\16\23\0\1\102"+
+    "\1\0\4\356\1\111\5\0\1\112\1\113\2\0\1\114"+
+    "\1\113\10\0\1\112\1\113\1\112\4\0\1\114\3\0"+
+    "\1\113\37\0\1\102\1\0\4\357\1\111\5\0\1\112"+
+    "\1\113\2\0\1\114\1\113\10\0\1\112\1\113\1\112"+
+    "\4\0\1\114\3\0\1\113\41\0\5\360\2\0\5\360"+
+    "\2\0\1\114\6\0\6\360\4\0\1\114\43\0\1\102"+
+    "\1\0\4\361\1\111\5\0\1\112\1\113\2\0\1\114"+
+    "\1\113\10\0\1\112\1\113\1\112\4\0\1\114\3\0"+
+    "\1\113\37\0\1\102\1\0\4\362\1\111\5\0\1\112"+
+    "\1\113\2\0\1\114\1\113\10\0\1\112\1\113\1\112"+
+    "\4\0\1\114\3\0\1\113\41\0\5\363\2\0\5\363"+
+    "\2\0\1\114\6\0\6\363\4\0\1\114\43\0\1\102"+
+    "\1\0\4\364\1\111\5\0\1\112\1\113\2\0\1\114"+
+    "\1\113\10\0\1\112\1\113\1\112\4\0\1\114\3\0"+
+    "\1\113\37\0\1\102\1\0\4\365\1\111\5\0\1\112"+
+    "\1\113\2\0\1\114\1\113\10\0\1\112\1\113\1\112"+
+    "\4\0\1\114\3\0\1\113\41\0\5\366\2\0\5\366"+
+    "\2\0\1\114\6\0\6\366\4\0\1\114\43\0\1\102"+
+    "\1\0\4\367\1\111\5\0\1\112\1\113\2\0\1\114"+
+    "\1\113\10\0\1\112\1\113\1\112\4\0\1\114\3\0"+
+    "\1\113\37\0\1\102\1\0\4\370\1\111\5\0\1\112"+
+    "\1\113\2\0\1\114\1\113\10\0\1\112\1\113\1\112"+
+    "\4\0\1\114\3\0\1\113\41\0\5\371\2\0\5\371"+
+    "\2\0\1\114\6\0\6\371\4\0\1\114\43\0\1\102"+
+    "\1\0\4\372\1\111\5\0\1\112\1\113\2\0\1\114"+
+    "\1\113\10\0\1\112\1\113\1\112\4\0\1\114\3\0"+
+    "\1\113\37\0\1\102\1\0\4\373\1\111\5\0\1\112"+
+    "\1\113\2\0\1\114\1\113\10\0\1\112\1\113\1\112"+
+    "\4\0\1\114\3\0\1\113\41\0\5\374\2\0\5\374"+
+    "\2\0\1\114\6\0\6\374\4\0\1\114\43\0\1\102"+
+    "\1\0\4\375\1\111\5\0\1\112\1\113\2\0\1\114"+
+    "\1\113\10\0\1\112\1\113\1\112\4\0\1\114\3\0"+
+    "\1\113\37\0\1\102\1\0\4\376\1\111\5\0\1\112"+
+    "\1\113\2\0\1\114\1\113\10\0\1\112\1\113\1\112"+
+    "\4\0\1\114\3\0\1\113\41\0\5\377\2\0\5\377"+
+    "\2\0\1\114\6\0\6\377\4\0\1\114\43\0\1\102"+
+    "\1\0\4\u0100\1\111\5\0\1\112\1\113\2\0\1\114"+
+    "\1\113\10\0\1\112\1\113\1\112\4\0\1\114\3\0"+
+    "\1\113\37\0\1\102\1\0\4\u0101\1\111\5\0\1\112"+
+    "\1\113\2\0\1\114\1\113\10\0\1\112\1\113\1\112"+
+    "\4\0\1\114\3\0\1\113\41\0\5\u0102\2\0\5\u0102"+
+    "\2\0\1\114\6\0\6\u0102\4\0\1\114\43\0\1\102"+
+    "\1\0\4\u0103\1\111\5\0\1\112\1\113\2\0\1\114"+
+    "\1\113\10\0\1\112\1\113\1\112\4\0\1\114\3\0"+
+    "\1\113\41\0\5\u0104\2\0\5\u0104\2\0\1\114\6\0"+
+    "\6\u0104\4\0\1\114\43\0\1\102\1\0\4\u0105\1\111"+
+    "\5\0\1\112\1\113\2\0\1\114\1\113\10\0\1\112"+
+    "\1\113\1\112\4\0\1\114\3\0\1\113\57\0\1\114"+
+    "\20\0\1\114\43\0\1\102\1\0\4\u0106\1\111\5\0"+
+    "\1\112\1\113\2\0\1\114\1\113\10\0\1\112\1\113"+
+    "\1\112\4\0\1\114\3\0\1\113\37\0\1\102\1\0"+
+    "\4\u0107\1\111\5\0\1\112\1\113\2\0\1\114\1\113"+
+    "\10\0\1\112\1\113\1\112\4\0\1\114\3\0\1\113"+
+    "\37\0\1\102\1\0\4\u0108\1\111\5\0\1\112\1\113"+
+    "\2\0\1\114\1\113\10\0\1\112\1\113\1\112\4\0"+
+    "\1\114\3\0\1\113\37\0\1\102\1\0\5\111\5\0"+
+    "\1\112\1\113\2\0\1\114\1\113\10\0\1\112\1\113"+
+    "\1\112\4\0\1\114\3\0\1\113\14\0";
+
+  private static int [] zzUnpacktrans() {
+    int [] result = new int[15939];
+    int offset = 0;
+    offset = zzUnpacktrans(ZZ_TRANS_PACKED_0, offset, result);
+    return result;
+  }
+
+  private static int zzUnpacktrans(String packed, int offset, int [] result) {
+    int i = 0;       /* index in packed string  */
+    int j = offset;  /* index in unpacked array */
+    int l = packed.length();
+    while (i < l) {
+      int count = packed.charAt(i++);
+      int value = packed.charAt(i++);
+      value--;
+      do result[j++] = value; while (--count > 0);
+    }
+    return j;
+  }
+
+
+  /** Error code for "Unknown internal scanner error". */
+  private static final int ZZ_UNKNOWN_ERROR = 0;
+  /** Error code for "could not match input". */
+  private static final int ZZ_NO_MATCH = 1;
+  /** Error code for "pushback value was too large". */
+  private static final int ZZ_PUSHBACK_2BIG = 2;
+
+  /**
+   * Error messages for {@link #ZZ_UNKNOWN_ERROR}, {@link #ZZ_NO_MATCH}, and
+   * {@link #ZZ_PUSHBACK_2BIG} respectively.
+   */
+  private static final String ZZ_ERROR_MSG[] = {
+    "Unknown internal scanner error",
+    "Error: could not match input",
+    "Error: pushback value was too large"
+  };
+
+  /**
+   * ZZ_ATTRIBUTE[aState] contains the attributes of state {@code aState}
+   */
+  private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();
+
+  private static final String ZZ_ATTRIBUTE_PACKED_0 =
+    "\6\0\3\11\1\1\2\11\2\1\4\11\4\1\3\11"+
+    "\20\1\2\11\1\1\1\11\1\1\1\11\1\1\2\11"+
+    "\1\1\1\11\1\1\1\11\1\1\2\11\1\1\7\0"+
+    "\1\1\1\0\6\1\1\11\1\0\1\11\1\0\33\1"+
+    "\1\11\1\0\1\1\4\0\1\1\6\0\1\11\3\1"+
+    "\1\0\41\1\2\0\1\11\1\1\11\0\26\1\2\0"+
+    "\1\11\4\0\14\1\1\0\1\11\2\0\31\1\1\0"+
+    "\2\1\1\0\2\1\1\0\2\1\1\0\2\1\1\0"+
+    "\2\1\1\0\2\1\1\0\1\1\1\0\4\1";
+
+  private static int [] zzUnpackAttribute() {
+    int [] result = new int[264];
+    int offset = 0;
+    offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
+    return result;
+  }
+
+  private static int zzUnpackAttribute(String packed, int offset, int [] result) {
+    int i = 0;       /* index in packed string  */
+    int j = offset;  /* index in unpacked array */
+    int l = packed.length();
+    while (i < l) {
+      int count = packed.charAt(i++);
+      int value = packed.charAt(i++);
+      do result[j++] = value; while (--count > 0);
+    }
+    return j;
+  }
+
+  /** Input device. */
+  private java.io.Reader zzReader;
+
+  /** Current state of the DFA. */
+  private int zzState;
+
+  /** Current lexical state. */
+  private int zzLexicalState = YYINITIAL;
+
+  /**
+   * This buffer contains the current text to be matched and is the source of the {@link #yytext()}
+   * string.
+   */
+  private char zzBuffer[] = new char[Math.min(ZZ_BUFFERSIZE, zzMaxBufferLen())];
+
+  /** Text position at the last accepting state. */
+  private int zzMarkedPos;
+
+  /** Current text position in the buffer. */
+  private int zzCurrentPos;
+
+  /** Marks the beginning of the {@link #yytext()} string in the buffer. */
+  private int zzStartRead;
+
+  /** Marks the last character in the buffer, that has been read from input. */
+  private int zzEndRead;
+
+  /**
+   * Whether the scanner is at the end of file.
+   * @see #yyatEOF
+   */
+  private boolean zzAtEOF;
+
+  /**
+   * The number of occupied positions in {@link #zzBuffer} beyond {@link #zzEndRead}.
+   *
+   * <p>When a lead/high surrogate has been read from the input stream into the final
+   * {@link #zzBuffer} position, this will have a value of 1; otherwise, it will have a value of 0.
+   */
+  private int zzFinalHighSurrogate = 0;
+
+  /** Number of newlines encountered up to the start of the matched text. */
+  private int yyline;
+
+  /** Number of characters from the last newline up to the start of the matched text. */
+  private int yycolumn;
+
+  /** Number of characters up to the start of the matched text. */
+  private long yychar;
+
+  /** Whether the scanner is currently at the beginning of a line. */
+  @SuppressWarnings("unused")
+  private boolean zzAtBOL = true;
+
+  /** Whether the user-EOF-code has already been executed. */
+  @SuppressWarnings("unused")
+  private boolean zzEOFDone;
+
+  /* user code: */
+
+
+
+  /**
+   * Creates a new scanner
+   *
+   * @param   in  the java.io.Reader to read input from.
+   */
+  public CLexer(java.io.Reader in) {
+    this.zzReader = in;
+  }
+
+
+  /** Returns the maximum size of the scanner buffer, which limits the size of tokens. */
+  private int zzMaxBufferLen() {
+    return Integer.MAX_VALUE;
+  }
+
+  /**  Whether the scanner buffer can grow to accommodate a larger token. */
+  private boolean zzCanGrow() {
+    return true;
+  }
+
+  /**
+   * Translates raw input code points to DFA table row
+   */
+  private static int zzCMap(int input) {
+    int offset = input & 255;
+    return offset == input ? ZZ_CMAP_BLOCKS[offset] : ZZ_CMAP_BLOCKS[ZZ_CMAP_TOP[input >> 8] | offset];
+  }
+
+  /**
+   * Refills the input buffer.
+   *
+   * @return {@code false} iff there was new input.
+   * @exception java.io.IOException  if any I/O-Error occurs
+   */
+  private boolean zzRefill() throws java.io.IOException {
+
+    /* first: make room (if you can) */
+    if (zzStartRead > 0) {
+      zzEndRead += zzFinalHighSurrogate;
+      zzFinalHighSurrogate = 0;
+      System.arraycopy(zzBuffer, zzStartRead,
+                       zzBuffer, 0,
+                       zzEndRead - zzStartRead);
+
+      /* translate stored positions */
+      zzEndRead -= zzStartRead;
+      zzCurrentPos -= zzStartRead;
+      zzMarkedPos -= zzStartRead;
+      zzStartRead = 0;
+    }
+
+    /* is the buffer big enough? */
+    if (zzCurrentPos >= zzBuffer.length - zzFinalHighSurrogate && zzCanGrow()) {
+      /* if not, and it can grow: blow it up */
+      char newBuffer[] = new char[Math.min(zzBuffer.length * 2, zzMaxBufferLen())];
+      System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
+      zzBuffer = newBuffer;
+      zzEndRead += zzFinalHighSurrogate;
+      zzFinalHighSurrogate = 0;
+    }
+
+    /* fill the buffer with new input */
+    int requested = zzBuffer.length - zzEndRead;
+    int numRead = zzReader.read(zzBuffer, zzEndRead, requested);
+
+    /* not supposed to occur according to specification of java.io.Reader */
+    if (numRead == 0) {
+      if (requested == 0) {
+        throw new java.io.EOFException("Scan buffer limit reached ["+zzBuffer.length+"]");
+      }
+      else {
+        throw new java.io.IOException(
+            "Reader returned 0 characters. See JFlex examples/zero-reader for a workaround.");
+      }
+    }
+    if (numRead > 0) {
+      zzEndRead += numRead;
+      if (Character.isHighSurrogate(zzBuffer[zzEndRead - 1])) {
+        if (numRead == requested) { // We requested too few chars to encode a full Unicode character
+          --zzEndRead;
+          zzFinalHighSurrogate = 1;
+        } else {                    // There is room in the buffer for at least one more char
+          int c = zzReader.read();  // Expecting to read a paired low surrogate char
+          if (c == -1) {
+            return true;
+          } else {
+            zzBuffer[zzEndRead++] = (char)c;
+          }
+        }
+      }
+      /* potentially more input available */
+      return false;
+    }
+
+    /* numRead < 0 ==> end of stream */
+    return true;
+  }
+
+
+  /**
+   * Closes the input reader.
+   *
+   * @throws java.io.IOException if the reader could not be closed.
+   */
+  public final void yyclose() throws java.io.IOException {
+    zzAtEOF = true; // indicate end of file
+    zzEndRead = zzStartRead; // invalidate buffer
+
+    if (zzReader != null) {
+      zzReader.close();
+    }
+  }
+
+
+  /**
+   * Resets the scanner to read from a new input stream.
+   *
+   * <p>Does not close the old reader.
+   *
+   * <p>All internal variables are reset, the old input stream <b>cannot</b> be reused (internal
+   * buffer is discarded and lost). Lexical state is set to {@code ZZ_INITIAL}.
+   *
+   * <p>Internal scan buffer is resized down to its initial length, if it has grown.
+   *
+   * @param reader The new input stream.
+   */
+  public final void yyreset(java.io.Reader reader) {
+    zzReader = reader;
+    zzEOFDone = false;
+    yyResetPosition();
+    zzLexicalState = YYINITIAL;
+    int initBufferSize = Math.min(ZZ_BUFFERSIZE, zzMaxBufferLen());
+    if (zzBuffer.length > initBufferSize) {
+      zzBuffer = new char[initBufferSize];
+    }
+  }
+
+  /**
+   * Resets the input position.
+   */
+  private final void yyResetPosition() {
+      zzAtBOL  = true;
+      zzAtEOF  = false;
+      zzCurrentPos = 0;
+      zzMarkedPos = 0;
+      zzStartRead = 0;
+      zzEndRead = 0;
+      zzFinalHighSurrogate = 0;
+      yyline = 0;
+      yycolumn = 0;
+      yychar = 0L;
+  }
+
+
+  /**
+   * Returns whether the scanner has reached the end of the reader it reads from.
+   *
+   * @return whether the scanner has reached EOF.
+   */
+  public final boolean yyatEOF() {
+    return zzAtEOF;
+  }
+
+
+  /**
+   * Returns the current lexical state.
+   *
+   * @return the current lexical state.
+   */
+  public final int yystate() {
+    return zzLexicalState;
+  }
+
+
+  /**
+   * Enters a new lexical state.
+   *
+   * @param newState the new lexical state
+   */
+  public final void yybegin(int newState) {
+    zzLexicalState = newState;
+  }
+
+
+  /**
+   * Returns the text matched by the current regular expression.
+   *
+   * @return the matched text.
+   */
+  public final String yytext() {
+    return new String(zzBuffer, zzStartRead, zzMarkedPos-zzStartRead);
+  }
+
+
+  /**
+   * Returns the character at the given position from the matched text.
+   *
+   * <p>It is equivalent to {@code yytext().charAt(pos)}, but faster.
+   *
+   * @param position the position of the character to fetch. A value from 0 to {@code yylength()-1}.
+   *
+   * @return the character at {@code position}.
+   */
+  public final char yycharat(int position) {
+    return zzBuffer[zzStartRead + position];
+  }
+
+
+  /**
+   * How many characters were matched.
+   *
+   * @return the length of the matched text region.
+   */
+  public final int yylength() {
+    return zzMarkedPos-zzStartRead;
+  }
+
+
+  /**
+   * Reports an error that occurred while scanning.
+   *
+   * <p>In a well-formed scanner (no or only correct usage of {@code yypushback(int)} and a
+   * match-all fallback rule) this method will only be called with things that
+   * "Can't Possibly Happen".
+   *
+   * <p>If this method is called, something is seriously wrong (e.g. a JFlex bug producing a faulty
+   * scanner etc.).
+   *
+   * <p>Usual syntax/scanner level error handling should be done in error fallback rules.
+   *
+   * @param errorCode the code of the error message to display.
+   */
+  private static void zzScanError(int errorCode) {
+    String message;
+    try {
+      message = ZZ_ERROR_MSG[errorCode];
+    } catch (ArrayIndexOutOfBoundsException e) {
+      message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
+    }
+
+    throw new Error(message);
+  }
+
+
+  /**
+   * Pushes the specified amount of characters back into the input stream.
+   *
+   * <p>They will be read again by then next call of the scanning method.
+   *
+   * @param number the number of characters to be read again. This number must not be greater than
+   *     {@link #yylength()}.
+   */
+  public void yypushback(int number)  {
+    if ( number > yylength() )
+      zzScanError(ZZ_PUSHBACK_2BIG);
+
+    zzMarkedPos -= number;
+  }
+
+
+  /**
+   * Resumes scanning until the next regular expression is matched, the end of input is encountered
+   * or an I/O-Error occurs.
+   *
+   * @return the next token.
+   * @exception java.io.IOException if any I/O-Error occurs.
+   */
+  public int yylex() throws java.io.IOException
+  {
+    int zzInput;
+    int zzAction;
+
+    // cached fields:
+    int zzCurrentPosL;
+    int zzMarkedPosL;
+    int zzEndReadL = zzEndRead;
+    char[] zzBufferL = zzBuffer;
+
+    int [] zzTransL = ZZ_TRANS;
+    int [] zzRowMapL = ZZ_ROWMAP;
+    int [] zzAttrL = ZZ_ATTRIBUTE;
+
+    while (true) {
+      zzMarkedPosL = zzMarkedPos;
+
+      yychar+= zzMarkedPosL-zzStartRead;
+
+      boolean zzR = false;
+      int zzCh;
+      int zzCharCount;
+      for (zzCurrentPosL = zzStartRead  ;
+           zzCurrentPosL < zzMarkedPosL ;
+           zzCurrentPosL += zzCharCount ) {
+        zzCh = Character.codePointAt(zzBufferL, zzCurrentPosL, zzMarkedPosL);
+        zzCharCount = Character.charCount(zzCh);
+        switch (zzCh) {
+        case '\u000B':  // fall through
+        case '\u000C':  // fall through
+        case '\u0085':  // fall through
+        case '\u2028':  // fall through
+        case '\u2029':
+          yyline++;
+          yycolumn = 0;
+          zzR = false;
+          break;
+        case '\r':
+          yyline++;
+          yycolumn = 0;
+          zzR = true;
+          break;
+        case '\n':
+          if (zzR)
+            zzR = false;
+          else {
+            yyline++;
+            yycolumn = 0;
+          }
+          break;
+        default:
+          zzR = false;
+          yycolumn += zzCharCount;
+        }
+      }
+
+      if (zzR) {
+        // peek one character ahead if it is
+        // (if we have counted one line too much)
+        boolean zzPeek;
+        if (zzMarkedPosL < zzEndReadL)
+          zzPeek = zzBufferL[zzMarkedPosL] == '\n';
+        else if (zzAtEOF)
+          zzPeek = false;
+        else {
+          boolean eof = zzRefill();
+          zzEndReadL = zzEndRead;
+          zzMarkedPosL = zzMarkedPos;
+          zzBufferL = zzBuffer;
+          if (eof)
+            zzPeek = false;
+          else
+            zzPeek = zzBufferL[zzMarkedPosL] == '\n';
+        }
+        if (zzPeek) yyline--;
+      }
+      zzAction = -1;
+
+      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
+
+      zzState = ZZ_LEXSTATE[zzLexicalState];
+
+      // set up zzAction for empty match case:
+      int zzAttributes = zzAttrL[zzState];
+      if ( (zzAttributes & 1) == 1 ) {
+        zzAction = zzState;
+      }
+
+
+      zzForAction: {
+        while (true) {
+
+          if (zzCurrentPosL < zzEndReadL) {
+            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
+            zzCurrentPosL += Character.charCount(zzInput);
+          }
+          else if (zzAtEOF) {
+            zzInput = YYEOF;
+            break zzForAction;
+          }
+          else {
+            // store back cached positions
+            zzCurrentPos  = zzCurrentPosL;
+            zzMarkedPos   = zzMarkedPosL;
+            boolean eof = zzRefill();
+            // get translated positions and possibly new buffer
+            zzCurrentPosL  = zzCurrentPos;
+            zzMarkedPosL   = zzMarkedPos;
+            zzBufferL      = zzBuffer;
+            zzEndReadL     = zzEndRead;
+            if (eof) {
+              zzInput = YYEOF;
+              break zzForAction;
+            }
+            else {
+              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
+              zzCurrentPosL += Character.charCount(zzInput);
+            }
+          }
+          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMap(zzInput) ];
+          if (zzNext == -1) break zzForAction;
+          zzState = zzNext;
+
+          zzAttributes = zzAttrL[zzState];
+          if ( (zzAttributes & 1) == 1 ) {
+            zzAction = zzState;
+            zzMarkedPosL = zzCurrentPosL;
+            if ( (zzAttributes & 8) == 8 ) break zzForAction;
+          }
+
+        }
+      }
+
+      // store back cached position
+      zzMarkedPos = zzMarkedPosL;
+
+      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
+        zzAtEOF = true;
+              {
+                return EOF;
+              }
+      }
+      else {
+        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
+          case 1:
+            { return ERROR;
+            }
+          // fall through
+          case 34: break;
+          case 2:
+            { return WHITE_CHAR;
+            }
+          // fall through
+          case 35: break;
+          case 3:
+            { return NEW_LINE;
+            }
+          // fall through
+          case 36: break;
+          case 4:
+            { return OPERATOR;
+            }
+          // fall through
+          case 37: break;
+          case 5:
+            { yybegin(STRING); return STRING_LITERAL;
+            }
+          // fall through
+          case 38: break;
+          case 6:
+            { return IDENTIFIER;
+            }
+          // fall through
+          case 39: break;
+          case 7:
+            { yybegin(CHARLITERAL);return CHARACTER_LITERAL;
+            }
+          // fall through
+          case 40: break;
+          case 8:
+            { return LPAREN;
+            }
+          // fall through
+          case 41: break;
+          case 9:
+            { return RPAREN;
+            }
+          // fall through
+          case 42: break;
+          case 10:
+            { return COMMA;
+            }
+          // fall through
+          case 43: break;
+          case 11:
+            { return DOT;
+            }
+          // fall through
+          case 44: break;
+          case 12:
+            { return INTEGER_LITERAL;
+            }
+          // fall through
+          case 45: break;
+          case 13:
+            { return SEMICOLON;
+            }
+          // fall through
+          case 46: break;
+          case 14:
+            { return LBRACK;
+            }
+          // fall through
+          case 47: break;
+          case 15:
+            { return RBRACK;
+            }
+          // fall through
+          case 48: break;
+          case 16:
+            { return LBRACE;
+            }
+          // fall through
+          case 49: break;
+          case 17:
+            { return RBRACE;
+            }
+          // fall through
+          case 50: break;
+          case 18:
+            { return STRING_LITERAL;
+            }
+          // fall through
+          case 51: break;
+          case 19:
+            { yybegin(YYINITIAL);return NEW_LINE;
+            }
+          // fall through
+          case 52: break;
+          case 20:
+            { yybegin(YYINITIAL);return STRING_LITERAL;
+            }
+          // fall through
+          case 53: break;
+          case 21:
+            { return CHARACTER_LITERAL;
+            }
+          // fall through
+          case 54: break;
+          case 22:
+            { yybegin(YYINITIAL);return CHARACTER_LITERAL;
+            }
+          // fall through
+          case 55: break;
+          case 23:
+            { return PRETREATMENT_LINE;
+            }
+          // fall through
+          case 56: break;
+          case 24:
+            { return DEFINE_LINE;
+            }
+          // fall through
+          case 57: break;
+          case 25:
+            { yybegin(DEFINE_NEW_LINE);return DEFINE_LINE;
+            }
+          // fall through
+          case 58: break;
+          case 26:
+            { yybegin(DEFINE);return DEFINE_LINE;
+            }
+          // fall through
+          case 59: break;
+          case 27:
+            { return FLOATING_POINT_LITERAL;
+            }
+          // fall through
+          case 60: break;
+          case 28:
+            { return COMMENT;
+            }
+          // fall through
+          case 61: break;
+          case 29:
+            { return KEYWORD;
+            }
+          // fall through
+          case 62: break;
+          case 30:
+            { yybegin(YYINITIAL);return COMMENT;
+            }
+          // fall through
+          case 63: break;
+          case 31:
+            { { yybegin(DEFINE);return DEFINE_LINE; }
+            }
+          // fall through
+          case 64: break;
+          case 32:
+            { return TYPE;
+            }
+          // fall through
+          case 65: break;
+          case 33:
+            { yybegin(PRETREATMENT);return PRETREATMENT_LINE;
+            }
+          // fall through
+          case 66: break;
+          default:
+            zzScanError(ZZ_NO_MATCH);
+        }
+      }
+    }
+  }
+
+
+}
diff --git a/codeeditor/src/main/java/cn/rbc/codeeditor/lang/c/CppLanguage.java b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/c/CppLanguage.java
new file mode 100644
index 0000000..7930025
--- /dev/null
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/c/CppLanguage.java
@@ -0,0 +1,26 @@
+package cn.rbc.codeeditor.lang.c;
+
+import cn.rbc.codeeditor.lang.*;
+import cn.rbc.codeeditor.util.*;
+
+public class CppLanguage extends Language{
+	private static Language _theOne = null;
+
+	public static Language getInstance(){
+		if(_theOne == null){
+			_theOne = new CppLanguage();
+		}
+		return _theOne;
+	}
+
+	@Override
+	public boolean isProgLang() {
+		return true;
+	}
+
+	@Override
+	public Lexer newLexer(CharSeqReader reader) {
+		return new CppLexer(reader);
+	}
+}
+
diff --git a/codeeditor/src/main/java/cn/rbc/codeeditor/lang/c/CppLexer.java b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/c/CppLexer.java
new file mode 100644
index 0000000..8dd3cf4
--- /dev/null
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/c/CppLexer.java
@@ -0,0 +1,1623 @@
+// DO NOT EDIT
+// Generated by JFlex 1.9.1 http://jflex.de/
+// source: cpp.flex
+
+package cn.rbc.codeeditor.lang.c;
+
+import cn.rbc.codeeditor.util.Lexer;
+
+@SuppressWarnings("fallthrough")
+public class CppLexer implements Lexer {
+
+  /** This character denotes the end of file. */
+  public static final int YYEOF = -1;
+
+  /** Initial size of the lookahead buffer. */
+  private static final int ZZ_BUFFERSIZE = 16384;
+
+  // Lexical states.
+  public static final int YYINITIAL = 0;
+  public static final int STRING = 2;
+  public static final int CHARLITERAL = 4;
+  public static final int PRETREATMENT = 6;
+  public static final int DEFINE = 8;
+  public static final int DEFINE_NEW_LINE = 10;
+
+  /**
+   * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
+   * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
+   *                  at the beginning of a line
+   * l is of the form l = 2*k, k a non negative integer
+   */
+  private static final int ZZ_LEXSTATE[] = {
+     0,  0,  1,  1,  2,  2,  3,  3,  4,  4,  5, 5
+  };
+
+  /**
+   * Top-level table for translating characters to character classes
+   */
+  private static final int [] ZZ_CMAP_TOP = zzUnpackcmap_top();
+
+  private static final String ZZ_CMAP_TOP_PACKED_0 =
+    "\1\0\1\u0100\1\u0200\1\u0300\1\u0400\1\u0500\1\u0600\1\u0700"+
+    "\1\u0800\1\u0900\1\u0a00\1\u0b00\1\u0c00\1\u0d00\1\u0e00\1\u0f00"+
+    "\1\u1000\1\u0100\1\u1100\1\u1200\1\u1300\1\u0100\1\u1400\1\u1500"+
+    "\1\u1600\1\u1700\1\u1800\1\u1900\1\u1a00\1\u1b00\1\u0100\1\u1c00"+
+    "\1\u1d00\1\u1e00\12\u1f00\1\u2000\1\u2100\1\u2200\1\u1f00\1\u2300"+
+    "\1\u2400\2\u1f00\31\u0100\1\u2500\121\u0100\1\u2600\4\u0100\1\u2700"+
+    "\1\u0100\1\u2800\1\u2900\1\u2a00\1\u2b00\1\u2c00\1\u2d00\53\u0100"+
+    "\1\u2e00\10\u2f00\31\u1f00\1\u0100\1\u3000\1\u3100\1\u0100\1\u3200"+
+    "\1\u3300\1\u3400\1\u3500\1\u3600\1\u3700\1\u3800\1\u3900\1\u3a00"+
+    "\1\u0100\1\u3b00\1\u3c00\1\u3d00\1\u3e00\1\u3f00\1\u4000\1\u4100"+
+    "\1\u4200\1\u4300\1\u4400\1\u4500\1\u4600\1\u4700\1\u4800\1\u4900"+
+    "\1\u4a00\1\u4b00\1\u4c00\1\u4d00\1\u4e00\1\u1f00\1\u4f00\1\u5000"+
+    "\1\u5100\1\u5200\3\u0100\1\u5300\1\u5400\1\u5500\12\u1f00\4\u0100"+
+    "\1\u5600\17\u1f00\2\u0100\1\u5700\41\u1f00\2\u0100\1\u5800\1\u5900"+
+    "\2\u1f00\1\u5a00\1\u5b00\27\u0100\1\u5c00\4\u0100\1\u5d00\1\u5e00"+
+    "\42\u1f00\1\u0100\1\u5f00\1\u6000\11\u1f00\1\u6100\24\u1f00\1\u6200"+
+    "\1\u6300\1\u1f00\1\u6400\1\u6500\1\u6600\1\u6700\2\u1f00\1\u6800"+
+    "\5\u1f00\1\u6900\1\u6a00\1\u6b00\5\u1f00\1\u6c00\1\u6d00\2\u1f00"+
+    "\1\u6e00\1\u1f00\1\u6f00\14\u1f00\1\u7000\4\u1f00\246\u0100\1\u7100"+
+    "\20\u0100\1\u7200\1\u7300\25\u0100\1\u7400\34\u0100\1\u7500\14\u1f00"+
+    "\2\u0100\1\u7600\5\u1f00\23\u0100\1\u7700\u0aec\u1f00\1\u7800\1\u7900"+
+    "\u02fe\u1f00";
+
+  private static int [] zzUnpackcmap_top() {
+    int [] result = new int[4352];
+    int offset = 0;
+    offset = zzUnpackcmap_top(ZZ_CMAP_TOP_PACKED_0, offset, result);
+    return result;
+  }
+
+  private static int zzUnpackcmap_top(String packed, int offset, int [] result) {
+    int i = 0;       /* index in packed string  */
+    int j = offset;  /* index in unpacked array */
+    int l = packed.length();
+    while (i < l) {
+      int count = packed.charAt(i++);
+      int value = packed.charAt(i++);
+      do result[j++] = value; while (--count > 0);
+    }
+    return j;
+  }
+
+
+  /**
+   * Second-level tables for translating characters to character classes
+   */
+  private static final int [] ZZ_CMAP_BLOCKS = zzUnpackcmap_blocks();
+
+  private static final String ZZ_CMAP_BLOCKS_PACKED_0 =
+    "\11\0\1\1\1\2\1\3\1\4\1\5\16\0\4\6"+
+    "\1\7\1\10\1\11\1\12\1\13\2\10\1\14\1\15"+
+    "\1\16\1\17\1\20\1\21\1\22\1\23\1\24\1\25"+
+    "\1\26\1\27\1\30\2\31\1\32\1\31\2\33\1\10"+
+    "\1\34\1\35\1\10\1\35\1\10\1\6\3\36\1\37"+
+    "\1\40\1\37\5\41\1\42\3\41\1\43\7\41\1\44"+
+    "\2\41\1\45\1\46\1\47\1\10\1\50\1\6\1\51"+
+    "\1\52\1\53\1\54\1\55\1\56\1\57\1\60\1\61"+
+    "\1\41\1\62\1\63\1\64\1\65\1\66\1\67\1\41"+
+    "\1\70\1\71\1\72\1\73\1\74\1\75\1\76\1\77"+
+    "\1\100\1\101\1\10\1\102\1\10\6\0\1\103\32\0"+
+    "\2\6\4\13\4\6\1\13\2\6\1\0\7\6\1\13"+
+    "\4\6\1\13\5\6\27\13\1\6\37\13\1\6\u01ca\13"+
+    "\4\6\14\13\16\6\5\13\7\6\1\13\1\6\1\13"+
+    "\21\6\160\0\5\13\1\6\2\13\2\6\4\13\1\6"+
+    "\1\13\6\6\1\13\1\6\3\13\1\6\1\13\1\6"+
+    "\24\13\1\6\123\13\1\6\213\13\1\6\5\0\2\6"+
+    "\246\13\1\6\46\13\2\6\1\13\6\6\51\13\6\6"+
+    "\1\13\1\6\55\0\1\6\1\0\1\6\2\0\1\6"+
+    "\2\0\1\6\1\0\10\6\33\13\4\6\4\13\15\6"+
+    "\6\0\5\6\1\13\4\6\13\0\1\6\1\0\3\6"+
+    "\53\13\37\0\4\6\2\13\1\0\143\13\1\6\1\13"+
+    "\10\0\1\6\6\0\2\13\2\0\1\6\4\0\2\13"+
+    "\12\0\3\13\2\6\1\13\17\6\1\0\1\13\1\0"+
+    "\36\13\33\0\2\6\131\13\13\0\1\13\16\6\12\0"+
+    "\41\13\11\0\2\13\4\6\1\13\2\6\1\0\30\13"+
+    "\4\0\1\13\11\0\1\13\3\0\1\13\5\0\22\6"+
+    "\31\13\3\0\4\6\13\13\65\6\25\13\1\6\22\13"+
+    "\13\6\61\0\66\13\3\0\1\13\22\0\1\13\7\0"+
+    "\12\13\2\0\2\6\12\0\1\6\20\13\3\0\1\6"+
+    "\10\13\2\6\2\13\2\6\26\13\1\6\7\13\1\6"+
+    "\1\13\3\6\4\13\2\6\1\0\1\13\7\0\2\6"+
+    "\2\0\2\6\3\0\1\13\10\6\1\0\4\6\2\13"+
+    "\1\6\3\13\2\0\2\6\12\0\4\13\7\6\2\13"+
+    "\1\6\1\0\2\6\3\0\1\6\6\13\4\6\2\13"+
+    "\2\6\26\13\1\6\7\13\1\6\2\13\1\6\2\13"+
+    "\1\6\2\13\2\6\1\0\1\6\5\0\4\6\2\0"+
+    "\2\6\3\0\3\6\1\0\7\6\4\13\1\6\1\13"+
+    "\7\6\14\0\3\13\1\0\13\6\3\0\1\6\11\13"+
+    "\1\6\3\13\1\6\26\13\1\6\7\13\1\6\2\13"+
+    "\1\6\5\13\2\6\1\0\1\13\10\0\1\6\3\0"+
+    "\1\6\3\0\2\6\1\13\17\6\2\13\2\0\2\6"+
+    "\12\0\1\6\1\13\7\6\1\13\6\0\1\6\3\0"+
+    "\1\6\10\13\2\6\2\13\2\6\26\13\1\6\7\13"+
+    "\1\6\2\13\1\6\5\13\2\6\1\0\1\13\7\0"+
+    "\2\6\2\0\2\6\3\0\7\6\3\0\4\6\2\13"+
+    "\1\6\3\13\2\0\2\6\12\0\1\6\1\13\20\6"+
+    "\1\0\1\13\1\6\6\13\3\6\3\13\1\6\4\13"+
+    "\3\6\2\13\1\6\1\13\1\6\2\13\3\6\2\13"+
+    "\3\6\3\13\3\6\14\13\4\6\5\0\3\6\3\0"+
+    "\1\6\4\0\2\6\1\13\6\6\1\0\16\6\12\0"+
+    "\11\6\1\13\6\6\5\0\10\13\1\6\3\13\1\6"+
+    "\27\13\1\6\20\13\3\6\1\13\7\0\1\6\3\0"+
+    "\1\6\4\0\7\6\2\0\1\6\3\13\5\6\2\13"+
+    "\2\0\2\6\12\0\20\6\1\13\3\0\1\6\10\13"+
+    "\1\6\3\13\1\6\27\13\1\6\12\13\1\6\5\13"+
+    "\2\6\1\0\1\13\7\0\1\6\3\0\1\6\4\0"+
+    "\7\6\2\0\7\6\1\13\1\6\2\13\2\0\2\6"+
+    "\12\0\1\6\2\13\15\6\4\0\11\13\1\6\3\13"+
+    "\1\6\51\13\2\0\1\13\7\0\1\6\3\0\1\6"+
+    "\4\0\1\13\5\6\3\13\1\0\7\6\3\13\2\0"+
+    "\2\6\12\0\12\6\6\13\1\6\3\0\1\6\22\13"+
+    "\3\6\30\13\1\6\11\13\1\6\1\13\2\6\7\13"+
+    "\3\6\1\0\4\6\6\0\1\6\1\0\1\6\10\0"+
+    "\6\6\12\0\2\6\2\0\15\6\60\13\1\0\2\13"+
+    "\7\0\4\6\10\13\10\0\1\6\12\0\47\6\2\13"+
+    "\1\6\1\13\1\6\5\13\1\6\30\13\1\6\1\13"+
+    "\1\6\12\13\1\0\2\13\11\0\1\13\2\6\5\13"+
+    "\1\6\1\13\1\6\6\0\2\6\12\0\2\6\4\13"+
+    "\40\6\1\13\27\6\2\0\6\6\12\0\13\6\1\0"+
+    "\1\6\1\0\1\6\1\0\4\6\2\0\10\13\1\6"+
+    "\44\13\4\6\24\0\1\6\2\0\5\13\13\0\1\6"+
+    "\44\0\11\6\1\0\71\6\53\13\24\0\1\13\12\0"+
+    "\6\6\6\13\4\0\4\13\3\0\1\13\3\0\2\13"+
+    "\7\0\3\13\4\0\15\13\14\0\1\13\17\0\2\6"+
+    "\46\13\1\6\1\13\5\6\1\13\2\6\53\13\1\6"+
+    "\115\13\1\6\4\13\2\6\7\13\1\6\1\13\1\6"+
+    "\4\13\2\6\51\13\1\6\4\13\2\6\41\13\1\6"+
+    "\4\13\2\6\7\13\1\6\1\13\1\6\4\13\2\6"+
+    "\17\13\1\6\71\13\1\6\4\13\2\6\103\13\2\6"+
+    "\3\0\40\6\20\13\20\6\126\13\2\6\6\13\3\6"+
+    "\u016c\13\2\6\21\13\1\6\32\13\5\6\113\13\3\6"+
+    "\13\13\7\6\15\13\1\6\4\13\3\0\13\6\22\13"+
+    "\3\0\13\6\22\13\2\0\14\6\15\13\1\6\3\13"+
+    "\1\6\2\0\14\6\64\13\40\0\3\6\1\13\3\6"+
+    "\2\13\1\0\2\6\12\0\41\6\4\0\1\6\12\0"+
+    "\6\6\131\13\7\6\5\13\2\0\42\13\1\0\1\13"+
+    "\5\6\106\13\12\6\37\13\1\6\14\0\4\6\14\0"+
+    "\12\6\12\0\36\13\2\6\5\13\13\6\54\13\4\6"+
+    "\32\13\6\6\12\0\46\6\27\13\5\0\4\6\65\13"+
+    "\12\0\1\6\35\0\2\6\13\0\6\6\12\0\15\6"+
+    "\1\13\10\6\16\0\1\6\2\0\77\6\5\0\57\13"+
+    "\21\0\7\13\4\6\12\0\21\6\11\0\14\6\3\0"+
+    "\36\13\15\0\2\13\12\0\54\13\16\0\14\6\44\13"+
+    "\24\0\10\6\12\0\3\6\3\13\12\0\44\13\2\6"+
+    "\11\13\7\6\53\13\2\6\3\13\20\6\3\0\1\6"+
+    "\25\0\4\13\1\0\6\13\1\0\2\13\3\0\1\13"+
+    "\5\6\300\13\72\0\1\6\5\0\26\13\2\6\6\13"+
+    "\2\6\46\13\2\6\6\13\2\6\10\13\1\6\1\13"+
+    "\1\6\1\13\1\6\1\13\1\6\37\13\2\6\65\13"+
+    "\1\6\7\13\1\6\1\13\3\6\3\13\1\6\7\13"+
+    "\3\6\4\13\2\6\6\13\4\6\15\13\5\6\3\13"+
+    "\1\6\7\13\16\6\5\0\30\6\2\3\5\0\20\6"+
+    "\2\13\23\6\1\13\13\6\5\0\1\6\12\0\1\6"+
+    "\1\13\15\6\1\13\20\6\15\13\3\6\40\13\20\6"+
+    "\15\0\4\6\1\0\3\6\14\0\21\6\1\13\4\6"+
+    "\1\13\2\6\12\13\1\6\1\13\3\6\5\13\6\6"+
+    "\1\13\1\6\1\13\1\6\1\13\1\6\4\13\1\6"+
+    "\13\13\2\6\4\13\5\6\5\13\4\6\1\13\21\6"+
+    "\51\13\u0177\6\57\13\1\6\57\13\1\6\205\13\6\6"+
+    "\4\13\3\0\2\13\14\6\46\13\1\6\1\13\5\6"+
+    "\1\13\2\6\70\13\7\6\1\13\17\6\1\0\27\13"+
+    "\11\6\7\13\1\6\7\13\1\6\7\13\1\6\7\13"+
+    "\1\6\7\13\1\6\7\13\1\6\7\13\1\6\7\13"+
+    "\1\6\40\0\57\6\1\13\325\6\3\13\31\6\11\13"+
+    "\6\0\1\6\5\13\2\6\5\13\4\6\126\13\2\6"+
+    "\2\0\2\6\3\13\1\6\132\13\1\6\4\13\5\6"+
+    "\53\13\1\6\136\13\21\6\40\13\60\6\320\13\100\6"+
+    "\375\13\3\6\215\13\103\6\56\13\2\6\15\13\3\6"+
+    "\20\13\12\0\2\13\24\6\57\13\1\0\4\6\12\0"+
+    "\1\6\37\13\2\0\120\13\2\0\45\6\11\13\2\6"+
+    "\147\13\2\6\65\13\2\6\11\13\52\6\15\13\1\0"+
+    "\3\13\1\0\4\13\1\0\27\13\5\0\4\6\1\0"+
+    "\13\6\1\13\7\6\64\13\14\6\2\0\62\13\22\0"+
+    "\12\6\12\0\6\6\22\0\6\13\3\6\1\13\1\6"+
+    "\2\13\13\0\34\13\10\0\2\6\27\13\15\0\14\6"+
+    "\35\13\3\6\4\0\57\13\16\0\16\6\1\13\12\0"+
+    "\6\6\5\13\1\0\12\13\12\0\5\13\1\6\51\13"+
+    "\16\0\11\6\3\13\1\0\10\13\2\0\2\6\12\0"+
+    "\6\6\27\13\3\6\1\13\3\0\62\13\1\0\1\13"+
+    "\3\0\2\13\2\0\5\13\2\0\1\13\1\0\1\13"+
+    "\30\6\3\13\2\6\13\13\5\0\2\6\3\13\2\0"+
+    "\12\6\6\13\2\6\6\13\2\6\6\13\11\6\7\13"+
+    "\1\6\7\13\1\6\53\13\1\6\16\13\6\6\163\13"+
+    "\10\0\1\6\2\0\2\6\12\0\6\6\244\13\14\6"+
+    "\27\13\4\6\61\13\4\6\u0100\3\156\13\2\6\152\13"+
+    "\46\6\7\13\14\6\5\13\5\6\1\13\1\0\12\13"+
+    "\1\6\15\13\1\6\5\13\1\6\1\13\1\6\2\13"+
+    "\1\6\2\13\1\6\154\13\41\6\153\13\22\6\100\13"+
+    "\2\6\66\13\50\6\15\13\3\6\20\0\20\6\20\0"+
+    "\3\6\2\13\30\6\3\13\31\6\1\13\6\6\5\13"+
+    "\1\6\207\13\2\6\1\0\4\6\1\13\13\6\12\0"+
+    "\7\6\32\13\4\6\1\13\1\6\32\13\13\6\131\13"+
+    "\3\6\6\13\2\6\6\13\2\6\6\13\2\6\3\13"+
+    "\3\6\2\13\3\6\2\13\22\6\3\0\4\6\14\13"+
+    "\1\6\32\13\1\6\23\13\1\6\2\13\1\6\17\13"+
+    "\2\6\16\13\42\6\173\13\105\6\65\13\210\6\1\0"+
+    "\202\6\35\13\3\6\61\13\17\6\1\0\37\6\40\13"+
+    "\15\6\36\13\5\6\46\13\5\0\5\6\36\13\2\6"+
+    "\44\13\4\6\10\13\1\6\5\13\52\6\236\13\2\6"+
+    "\12\0\6\6\44\13\4\6\44\13\4\6\50\13\10\6"+
+    "\64\13\234\6\67\13\11\6\26\13\12\6\10\13\230\6"+
+    "\6\13\2\6\1\13\1\6\54\13\1\6\2\13\3\6"+
+    "\1\13\2\6\27\13\12\6\27\13\11\6\37\13\101\6"+
+    "\23\13\1\6\2\13\12\6\26\13\12\6\32\13\106\6"+
+    "\70\13\6\6\2\13\100\6\1\13\3\0\1\6\2\0"+
+    "\5\6\4\0\4\13\1\6\3\13\1\6\35\13\2\6"+
+    "\3\0\4\6\1\0\40\6\35\13\3\6\35\13\43\6"+
+    "\10\13\1\6\34\13\2\0\31\6\66\13\12\6\26\13"+
+    "\12\6\23\13\15\6\22\13\156\6\111\13\67\6\63\13"+
+    "\15\6\63\13\15\6\44\13\4\0\10\6\12\0\u0146\6"+
+    "\52\13\1\6\2\0\3\6\2\13\116\6\35\13\12\6"+
+    "\1\13\10\6\26\13\13\0\137\6\25\13\33\6\27\13"+
+    "\11\6\3\0\65\13\17\0\37\6\12\0\17\6\4\0"+
+    "\55\13\13\0\2\6\1\0\17\6\1\0\2\6\31\13"+
+    "\7\6\12\0\6\6\3\0\44\13\16\0\1\6\12\0"+
+    "\4\6\1\13\2\0\1\13\10\6\43\13\1\0\2\6"+
+    "\1\13\11\6\3\0\60\13\16\0\4\13\4\6\4\0"+
+    "\1\6\14\0\1\13\1\6\1\13\43\6\22\13\1\6"+
+    "\31\13\14\0\6\6\1\0\101\6\7\13\1\6\1\13"+
+    "\1\6\4\13\1\6\17\13\1\6\12\13\7\6\57\13"+
+    "\14\0\5\6\12\0\6\6\4\0\1\6\10\13\2\6"+
+    "\2\13\2\6\26\13\1\6\7\13\1\6\2\13\1\6"+
+    "\5\13\1\6\2\0\1\13\7\0\2\6\2\0\2\6"+
+    "\3\0\2\6\1\13\6\6\1\0\5\6\5\13\2\0"+
+    "\2\6\7\0\3\6\5\0\213\6\65\13\22\0\4\13"+
+    "\5\6\12\0\4\6\1\0\3\13\36\6\60\13\24\0"+
+    "\2\13\1\6\1\13\10\6\12\0\246\6\57\13\7\0"+
+    "\2\6\11\0\27\6\4\13\2\0\42\6\60\13\21\0"+
+    "\3\6\1\13\13\6\12\0\46\6\53\13\15\0\1\13"+
+    "\7\6\12\0\66\6\33\13\2\6\17\0\4\6\12\0"+
+    "\306\6\54\13\17\0\145\6\100\13\12\0\25\6\10\13"+
+    "\2\6\1\13\2\6\10\13\1\6\2\13\1\6\30\13"+
+    "\6\0\1\6\2\0\2\6\4\0\1\13\1\0\1\13"+
+    "\2\0\14\6\12\0\106\6\10\13\2\6\47\13\7\0"+
+    "\2\6\7\0\1\13\1\6\1\13\1\0\33\6\1\13"+
+    "\12\0\50\13\7\0\1\13\4\0\10\6\1\0\10\6"+
+    "\1\13\13\0\56\13\20\0\3\6\1\13\42\6\71\13"+
+    "\7\6\11\13\1\6\45\13\10\0\1\6\10\0\1\13"+
+    "\17\6\12\0\30\6\36\13\2\6\26\0\1\6\16\0"+
+    "\111\6\7\13\1\6\2\13\1\6\46\13\6\0\3\6"+
+    "\1\0\1\6\2\0\1\6\7\0\1\13\1\0\10\6"+
+    "\12\0\6\6\6\13\1\6\2\13\1\6\40\13\5\0"+
+    "\1\6\2\0\1\6\5\0\1\13\7\6\12\0\u0136\6"+
+    "\23\13\4\0\271\6\1\13\54\6\4\13\37\6\232\13"+
+    "\146\6\157\13\21\6\304\13\274\6\57\13\1\6\11\0"+
+    "\307\6\107\13\271\6\71\13\7\6\37\13\1\6\12\0"+
+    "\146\6\36\13\2\6\5\0\13\6\60\13\7\0\11\6"+
+    "\4\13\14\6\12\0\11\6\25\13\5\6\23\13\260\6"+
+    "\100\13\200\6\113\13\4\6\1\0\1\13\67\0\7\6"+
+    "\4\0\15\13\100\6\2\13\1\6\1\13\1\0\13\6"+
+    "\2\0\16\6\370\13\10\6\326\13\52\6\11\13\367\6"+
+    "\37\13\61\6\3\13\21\6\4\13\10\6\u018c\13\4\6"+
+    "\153\13\5\6\15\13\3\6\11\13\7\6\12\13\3\6"+
+    "\2\0\1\6\4\0\301\6\5\0\3\6\26\0\2\6"+
+    "\7\0\36\6\4\0\224\6\3\0\273\6\125\13\1\6"+
+    "\107\13\1\6\2\13\2\6\1\13\2\6\2\13\2\6"+
+    "\4\13\1\6\14\13\1\6\1\13\1\6\7\13\1\6"+
+    "\101\13\1\6\4\13\2\6\10\13\1\6\7\13\1\6"+
+    "\34\13\1\6\4\13\1\6\5\13\1\6\1\13\3\6"+
+    "\7\13\1\6\u0154\13\2\6\31\13\1\6\31\13\1\6"+
+    "\37\13\1\6\31\13\1\6\37\13\1\6\31\13\1\6"+
+    "\37\13\1\6\31\13\1\6\37\13\1\6\31\13\1\6"+
+    "\10\13\2\6\151\0\4\6\62\0\10\6\1\0\16\6"+
+    "\1\0\26\6\5\0\1\6\17\0\120\6\7\0\1\6"+
+    "\21\0\2\6\7\0\1\6\2\0\1\6\5\0\325\6"+
+    "\55\13\3\6\7\0\7\13\2\6\12\0\4\6\1\13"+
+    "\u0171\6\54\13\16\0\5\6\306\13\13\6\7\0\51\6"+
+    "\104\13\7\0\1\13\4\6\12\0\u0156\6\1\13\117\6"+
+    "\4\13\1\6\33\13\1\6\2\13\1\6\1\13\2\6"+
+    "\1\13\1\6\12\13\1\6\4\13\1\6\1\13\1\6"+
+    "\1\13\6\6\1\13\4\6\1\13\1\6\1\13\1\6"+
+    "\1\13\1\6\3\13\1\6\2\13\1\6\1\13\2\6"+
+    "\1\13\1\6\1\13\1\6\1\13\1\6\1\13\1\6"+
+    "\1\13\1\6\2\13\1\6\1\13\2\6\4\13\1\6"+
+    "\7\13\1\6\4\13\1\6\4\13\1\6\1\13\1\6"+
+    "\12\13\1\6\21\13\5\6\3\13\1\6\5\13\1\6"+
+    "\21\13\u0134\6\12\0\6\6\336\13\42\6\65\13\13\6"+
+    "\336\13\2\6\u0182\13\16\6\u0131\13\37\6\36\13\342\6"+
+    "\113\13\266\6\1\0\36\6\140\0\200\6\360\0\20\6";
+
+  private static int [] zzUnpackcmap_blocks() {
+    int [] result = new int[31232];
+    int offset = 0;
+    offset = zzUnpackcmap_blocks(ZZ_CMAP_BLOCKS_PACKED_0, offset, result);
+    return result;
+  }
+
+  private static int zzUnpackcmap_blocks(String packed, int offset, int [] result) {
+    int i = 0;       /* index in packed string  */
+    int j = offset;  /* index in unpacked array */
+    int l = packed.length();
+    while (i < l) {
+      int count = packed.charAt(i++);
+      int value = packed.charAt(i++);
+      do result[j++] = value; while (--count > 0);
+    }
+    return j;
+  }
+
+  /**
+   * Translates DFA states to action switch labels.
+   */
+  private static final int [] ZZ_ACTION = zzUnpackAction();
+
+  private static final String ZZ_ACTION_PACKED_0 =
+    "\6\0\1\1\1\2\2\3\1\4\1\5\1\1\1\6"+
+    "\1\7\1\10\1\11\1\12\1\13\1\4\2\14\1\15"+
+    "\1\16\1\17\23\6\1\20\1\21\1\22\2\23\1\24"+
+    "\1\1\1\25\1\26\1\1\2\27\2\30\1\31\2\32"+
+    "\7\0\1\33\1\0\1\34\4\14\2\33\1\0\1\14"+
+    "\1\0\11\6\1\35\10\6\1\35\27\6\1\22\1\0"+
+    "\1\36\4\0\1\37\5\0\2\34\2\14\1\0\1\33"+
+    "\2\14\21\6\1\40\35\6\1\0\2\36\10\0\3\14"+
+    "\2\6\1\40\40\6\1\0\1\41\4\0\3\14\2\6"+
+    "\1\35\24\6\1\0\1\37\2\0\3\14\13\6\3\14"+
+    "\5\6\3\14\2\6\3\14\1\6\3\14\1\6\2\14"+
+    "\1\0\2\14\1\0\2\14\1\0\2\14\1\0\2\14"+
+    "\1\0\2\14\1\0\1\14\1\33\1\0\1\33\1\0"+
+    "\4\33";
+
+  private static int [] zzUnpackAction() {
+    int [] result = new int[337];
+    int offset = 0;
+    offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
+    return result;
+  }
+
+  private static int zzUnpackAction(String packed, int offset, int [] result) {
+    int i = 0;       /* index in packed string  */
+    int j = offset;  /* index in unpacked array */
+    int l = packed.length();
+    while (i < l) {
+      int count = packed.charAt(i++);
+      int value = packed.charAt(i++);
+      do result[j++] = value; while (--count > 0);
+    }
+    return j;
+  }
+
+
+  /**
+   * Translates a state to a row index in the transition table
+   */
+  private static final int [] ZZ_ROWMAP = zzUnpackRowMap();
+
+  private static final String ZZ_ROWMAP_PACKED_0 =
+    "\0\0\0\104\0\210\0\314\0\u0110\0\u0154\0\u0198\0\u0198"+
+    "\0\u0198\0\u01dc\0\u0198\0\u0198\0\u0220\0\u0264\0\u0198\0\u0198"+
+    "\0\u0198\0\u0198\0\u02a8\0\u02ec\0\u0330\0\u0374\0\u0198\0\u0198"+
+    "\0\u0198\0\u03b8\0\u03fc\0\u0440\0\u0484\0\u04c8\0\u050c\0\u0550"+
+    "\0\u0594\0\u05d8\0\u061c\0\u0660\0\u06a4\0\u06e8\0\u072c\0\u0770"+
+    "\0\u07b4\0\u07f8\0\u083c\0\u0880\0\u0198\0\u0198\0\u08c4\0\u0198"+
+    "\0\u0908\0\u0198\0\u094c\0\u0198\0\u0198\0\u0990\0\u0198\0\u09d4"+
+    "\0\u0198\0\u09d4\0\u0198\0\u0198\0\u0a18\0\u0220\0\u0a5c\0\u0aa0"+
+    "\0\u0ae4\0\u0b28\0\u0b6c\0\u0bb0\0\u0bf4\0\u0c38\0\u0c7c\0\u0cc0"+
+    "\0\u0d04\0\u0d48\0\u0d8c\0\u0dd0\0\u0198\0\u0e14\0\u0198\0\u0e58"+
+    "\0\u0e9c\0\u0ee0\0\u0f24\0\u0f68\0\u0fac\0\u0ff0\0\u1034\0\u1078"+
+    "\0\u10bc\0\u1100\0\u1144\0\u1188\0\u11cc\0\u1210\0\u1254\0\u1298"+
+    "\0\u12dc\0\u1320\0\u0264\0\u1364\0\u13a8\0\u13ec\0\u1430\0\u1474"+
+    "\0\u14b8\0\u14fc\0\u1540\0\u1584\0\u15c8\0\u160c\0\u1650\0\u1694"+
+    "\0\u16d8\0\u171c\0\u1760\0\u17a4\0\u17e8\0\u182c\0\u1870\0\u18b4"+
+    "\0\u18f8\0\u193c\0\u0198\0\u1980\0\u19c4\0\u1a08\0\u1a4c\0\u1a90"+
+    "\0\u1ad4\0\u1b18\0\u1b5c\0\u1ba0\0\u1be4\0\u1c28\0\u1c6c\0\u0198"+
+    "\0\u1cb0\0\u1cf4\0\u1d38\0\u1d7c\0\u1dc0\0\u1e04\0\u1e48\0\u1e8c"+
+    "\0\u1ed0\0\u1f14\0\u1f58\0\u1f9c\0\u1fe0\0\u2024\0\u2068\0\u20ac"+
+    "\0\u20f0\0\u2134\0\u2178\0\u21bc\0\u2200\0\u2244\0\u2288\0\u22cc"+
+    "\0\u0264\0\u2310\0\u2354\0\u2398\0\u23dc\0\u2420\0\u2464\0\u24a8"+
+    "\0\u24ec\0\u2530\0\u2574\0\u25b8\0\u25fc\0\u2640\0\u2684\0\u26c8"+
+    "\0\u270c\0\u2750\0\u2794\0\u27d8\0\u281c\0\u2860\0\u28a4\0\u28e8"+
+    "\0\u292c\0\u2970\0\u29b4\0\u29f8\0\u2a3c\0\u2a80\0\u2ac4\0\u0198"+
+    "\0\u2b08\0\u2b4c\0\u2b90\0\u2bd4\0\u2c18\0\u2c5c\0\u2ca0\0\u2ce4"+
+    "\0\u2d28\0\u2d6c\0\u2db0\0\u2df4\0\u2e38\0\u2e7c\0\u2ec0\0\u2f04"+
+    "\0\u2f48\0\u2f8c\0\u2fd0\0\u3014\0\u3058\0\u309c\0\u30e0\0\u3124"+
+    "\0\u3168\0\u31ac\0\u31f0\0\u3234\0\u3278\0\u32bc\0\u3300\0\u3344"+
+    "\0\u3388\0\u33cc\0\u3410\0\u3454\0\u3498\0\u34dc\0\u3520\0\u3564"+
+    "\0\u35a8\0\u35ec\0\u3630\0\u3674\0\u36b8\0\u36fc\0\u3740\0\u3784"+
+    "\0\u0198\0\u37c8\0\u380c\0\u3850\0\u3894\0\u38d8\0\u391c\0\u3960"+
+    "\0\u39a4\0\u39e8\0\u3a2c\0\u3a70\0\u3ab4\0\u3af8\0\u3b3c\0\u3b80"+
+    "\0\u3bc4\0\u3c08\0\u3c4c\0\u3c90\0\u3cd4\0\u3d18\0\u3d5c\0\u3da0"+
+    "\0\u3de4\0\u3e28\0\u3e6c\0\u3eb0\0\u3ef4\0\u3f38\0\u3f7c\0\u3fc0"+
+    "\0\u0198\0\u4004\0\u4048\0\u408c\0\u40d0\0\u4114\0\u4158\0\u419c"+
+    "\0\u41e0\0\u4224\0\u4268\0\u42ac\0\u42f0\0\u4334\0\u4378\0\u43bc"+
+    "\0\u4400\0\u4444\0\u4488\0\u44cc\0\u4510\0\u3a2c\0\u4554\0\u4598"+
+    "\0\u45dc\0\u4620\0\u4664\0\u46a8\0\u46ec\0\u4730\0\u4774\0\u47b8"+
+    "\0\u47fc\0\u4840\0\u4884\0\u48c8\0\u490c\0\u4950\0\u4994\0\u49d8"+
+    "\0\u4a1c\0\u4a60\0\u4aa4\0\u4ae8\0\u4b2c\0\u4b70\0\u4bb4\0\u4bf8"+
+    "\0\u4c3c\0\u4c80\0\u4cc4\0\u4d08\0\u4d4c\0\u4d90\0\u4dd4\0\u4e18"+
+    "\0\u4e5c\0\u4e5c\0\u4ea0\0\u4ee4\0\u4f28\0\u4f6c\0\u4fb0\0\u4ff4"+
+    "\0\u5038";
+
+  private static int [] zzUnpackRowMap() {
+    int [] result = new int[337];
+    int offset = 0;
+    offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
+    return result;
+  }
+
+  private static int zzUnpackRowMap(String packed, int offset, int [] result) {
+    int i = 0;  /* index in packed string  */
+    int j = offset;  /* index in unpacked array */
+    int l = packed.length() - 1;
+    while (i < l) {
+      int high = packed.charAt(i++) << 16;
+      result[j++] = high | packed.charAt(i++);
+    }
+    return j;
+  }
+
+  /**
+   * The transition table of the DFA
+   */
+  private static final int [] ZZ_TRANS = zzUnpacktrans();
+
+  private static final String ZZ_TRANS_PACKED_0 =
+    "\1\7\1\10\1\11\1\7\1\10\1\12\1\7\1\10"+
+    "\1\13\1\14\1\15\1\16\1\17\1\20\1\21\2\13"+
+    "\1\22\1\13\1\23\1\24\1\25\6\26\1\27\1\13"+
+    "\7\16\1\30\1\7\1\31\1\16\1\32\1\33\1\34"+
+    "\1\35\1\36\1\37\1\40\1\16\1\41\1\16\1\42"+
+    "\1\43\1\44\1\45\1\46\1\47\1\50\1\51\1\52"+
+    "\1\53\1\54\3\16\1\55\1\56\1\7\2\57\1\60"+
+    "\2\57\1\61\3\57\1\62\34\57\1\63\35\57\2\64"+
+    "\1\60\2\64\1\61\6\64\1\65\31\64\1\66\35\64"+
+    "\1\7\1\67\1\60\1\7\1\67\1\61\1\7\1\67"+
+    "\1\7\1\67\10\7\2\67\1\70\7\67\1\7\10\67"+
+    "\3\7\31\67\4\7\1\71\1\60\1\7\1\71\1\61"+
+    "\1\7\2\71\4\7\7\71\1\72\21\71\1\73\34\71"+
+    "\2\7\1\71\1\74\1\7\1\71\1\75\1\7\1\71"+
+    "\74\7\106\0\1\11\110\0\1\76\44\0\1\77\1\100"+
+    "\3\0\1\101\1\0\1\102\3\0\1\103\3\0\1\104"+
+    "\10\0\1\16\12\0\1\16\11\0\7\16\2\0\7\16"+
+    "\3\0\31\16\2\0\1\16\25\0\7\105\67\0\1\106"+
+    "\4\0\1\107\102\0\1\105\1\0\1\110\1\111\2\112"+
+    "\2\113\1\114\3\0\1\115\1\116\1\0\1\117\1\116"+
+    "\1\120\7\0\1\115\1\116\1\115\4\0\1\117\3\0"+
+    "\1\116\6\0\1\120\30\0\1\105\1\0\7\26\3\0"+
+    "\1\115\1\116\1\0\1\117\1\116\10\0\1\115\1\116"+
+    "\1\115\4\0\1\117\3\0\1\116\14\0\1\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\21\16\1\121"+
+    "\1\16\1\122\5\16\2\0\2\16\12\0\1\16\11\0"+
+    "\7\16\2\0\7\16\3\0\16\16\1\123\1\16\1\124"+
+    "\10\16\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\1\16\1\125\6\16\1\126\2\16\1\127"+
+    "\2\16\1\130\12\16\2\0\2\16\12\0\1\16\11\0"+
+    "\7\16\2\0\7\16\3\0\5\16\1\131\10\16\1\132"+
+    "\10\16\1\133\1\16\2\0\2\16\12\0\1\16\11\0"+
+    "\7\16\2\0\7\16\3\0\13\16\1\134\1\16\1\135"+
+    "\10\16\1\136\2\16\2\0\2\16\12\0\1\16\11\0"+
+    "\7\16\2\0\7\16\3\0\1\16\1\137\11\16\1\140"+
+    "\2\16\1\141\1\16\1\142\10\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\16\16\1\122"+
+    "\12\16\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\6\16\1\143\6\16\1\144\13\16\2\0"+
+    "\2\16\12\0\1\16\11\0\7\16\2\0\7\16\3\0"+
+    "\16\16\1\145\12\16\2\0\2\16\12\0\1\16\11\0"+
+    "\7\16\2\0\7\16\3\0\23\16\1\146\5\16\2\0"+
+    "\2\16\12\0\1\16\11\0\7\16\2\0\7\16\3\0"+
+    "\1\16\1\147\3\16\1\150\23\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\17\16\1\151"+
+    "\11\16\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\20\16\1\152\2\16\1\153\5\16\2\0"+
+    "\2\16\12\0\1\16\11\0\7\16\2\0\7\16\3\0"+
+    "\5\16\1\154\23\16\2\0\2\16\12\0\1\16\11\0"+
+    "\7\16\2\0\7\16\3\0\10\16\1\155\1\156\10\16"+
+    "\1\157\2\16\1\160\3\16\2\0\2\16\12\0\1\16"+
+    "\11\0\7\16\2\0\7\16\3\0\5\16\1\161\2\16"+
+    "\1\162\7\16\1\163\6\16\1\164\1\16\2\0\2\16"+
+    "\12\0\1\16\11\0\7\16\2\0\7\16\3\0\15\16"+
+    "\1\165\3\16\1\166\7\16\2\0\2\16\12\0\1\16"+
+    "\11\0\7\16\2\0\7\16\3\0\11\16\1\167\4\16"+
+    "\1\170\12\16\2\0\2\16\12\0\1\16\11\0\7\16"+
+    "\2\0\7\16\3\0\3\16\1\171\4\16\1\172\20\16"+
+    "\2\0\1\16\2\57\1\0\2\57\1\0\3\57\1\0"+
+    "\34\57\1\0\35\57\2\0\1\60\101\0\2\173\4\0"+
+    "\75\173\1\0\2\64\4\0\75\64\20\0\1\174\4\0"+
+    "\1\175\61\0\1\74\156\0\1\176\111\0\1\177\1\0"+
+    "\1\200\2\0\1\201\71\0\1\202\6\0\1\203\77\0"+
+    "\1\204\112\0\1\205\100\0\1\206\43\0\7\105\3\0"+
+    "\1\115\1\116\2\0\1\116\10\0\1\115\1\116\1\115"+
+    "\10\0\1\116\14\0\17\106\1\207\64\106\2\107\1\210"+
+    "\2\107\1\211\76\107\23\0\1\105\1\0\1\110\1\111"+
+    "\2\112\2\113\1\114\3\0\1\115\1\116\1\0\1\117"+
+    "\1\116\10\0\1\115\1\116\1\115\4\0\1\117\3\0"+
+    "\1\116\37\0\1\105\1\0\6\113\1\114\3\0\1\115"+
+    "\1\116\1\0\1\117\1\116\10\0\1\115\1\116\1\115"+
+    "\4\0\1\117\3\0\1\116\37\0\1\105\1\0\6\212"+
+    "\1\114\3\0\1\115\1\116\1\0\1\117\1\116\10\0"+
+    "\1\115\1\116\1\115\4\0\1\117\3\0\1\116\37\0"+
+    "\1\105\1\0\6\213\1\114\3\0\1\115\1\116\1\0"+
+    "\1\117\1\116\10\0\1\115\1\116\1\115\4\0\1\117"+
+    "\3\0\1\116\37\0\1\105\1\0\7\114\3\0\1\115"+
+    "\1\116\2\0\1\116\10\0\1\115\1\116\1\115\10\0"+
+    "\1\116\34\0\1\214\1\0\1\214\2\0\7\215\75\0"+
+    "\1\216\6\217\2\0\3\217\10\0\6\217\25\0\1\16"+
+    "\12\0\1\16\11\0\7\16\2\0\7\16\3\0\14\16"+
+    "\1\143\14\16\2\0\2\16\12\0\1\16\11\0\7\16"+
+    "\2\0\7\16\3\0\22\16\1\220\6\16\2\0\2\16"+
+    "\12\0\1\16\11\0\7\16\2\0\7\16\3\0\16\16"+
+    "\1\221\12\16\2\0\2\16\12\0\1\16\11\0\7\16"+
+    "\2\0\7\16\3\0\5\16\1\222\23\16\2\0\2\16"+
+    "\12\0\1\16\11\0\7\16\2\0\7\16\3\0\21\16"+
+    "\1\223\1\224\6\16\2\0\2\16\12\0\1\16\11\0"+
+    "\7\16\2\0\7\16\3\0\1\16\1\225\27\16\2\0"+
+    "\2\16\12\0\1\16\11\0\7\16\2\0\7\16\3\0"+
+    "\1\16\1\226\27\16\2\0\2\16\12\0\1\16\11\0"+
+    "\7\16\2\0\7\16\3\0\15\16\1\227\13\16\2\0"+
+    "\2\16\12\0\1\16\11\0\7\16\2\0\7\16\3\0"+
+    "\6\16\1\230\4\16\1\231\15\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\23\16\1\232"+
+    "\5\16\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\15\16\1\233\13\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\21\16\1\223"+
+    "\7\16\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\23\16\1\121\5\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\17\16\1\234"+
+    "\2\16\1\235\6\16\2\0\2\16\12\0\1\16\11\0"+
+    "\7\16\2\0\7\16\3\0\13\16\1\134\15\16\2\0"+
+    "\2\16\12\0\1\16\11\0\7\16\2\0\7\16\3\0"+
+    "\16\16\1\236\12\16\2\0\2\16\12\0\1\16\11\0"+
+    "\7\16\2\0\7\16\3\0\20\16\1\143\10\16\2\0"+
+    "\2\16\12\0\1\16\11\0\7\16\2\0\7\16\3\0"+
+    "\11\16\1\237\17\16\2\0\2\16\12\0\1\16\11\0"+
+    "\7\16\2\0\7\16\3\0\13\16\1\240\6\16\1\241"+
+    "\6\16\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\15\16\1\242\13\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\22\16\1\243"+
+    "\6\16\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\14\16\1\244\14\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\25\16\1\143"+
+    "\3\16\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\5\16\1\245\23\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\11\16\1\246"+
+    "\4\16\1\247\12\16\2\0\2\16\12\0\1\16\11\0"+
+    "\7\16\2\0\7\16\3\0\2\16\1\250\26\16\2\0"+
+    "\2\16\12\0\1\16\11\0\7\16\2\0\7\16\3\0"+
+    "\7\16\1\251\1\16\1\252\7\16\1\253\1\254\6\16"+
+    "\2\0\2\16\12\0\1\16\11\0\7\16\2\0\7\16"+
+    "\3\0\16\16\1\255\12\16\2\0\2\16\12\0\1\16"+
+    "\11\0\7\16\2\0\7\16\3\0\7\16\1\256\20\16"+
+    "\1\257\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\1\16\1\260\16\16\1\261\10\16\2\0"+
+    "\2\16\12\0\1\16\11\0\7\16\2\0\7\16\3\0"+
+    "\11\16\1\262\17\16\2\0\2\16\12\0\1\16\11\0"+
+    "\7\16\2\0\7\16\3\0\14\16\1\263\14\16\2\0"+
+    "\2\16\12\0\1\16\11\0\7\16\2\0\7\16\3\0"+
+    "\11\16\1\264\6\16\1\265\10\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\23\16\1\223"+
+    "\3\16\1\143\1\16\2\0\2\16\12\0\1\16\11\0"+
+    "\7\16\2\0\7\16\3\0\17\16\1\266\11\16\2\0"+
+    "\2\16\12\0\1\16\11\0\7\16\2\0\7\16\3\0"+
+    "\11\16\1\267\7\16\1\270\7\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\11\16\1\271"+
+    "\17\16\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\20\16\1\272\10\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\11\16\1\273"+
+    "\1\16\1\274\15\16\2\0\2\16\12\0\1\16\11\0"+
+    "\7\16\2\0\7\16\3\0\10\16\1\275\20\16\2\0"+
+    "\2\16\12\0\1\16\11\0\7\16\2\0\7\16\3\0"+
+    "\11\16\1\276\17\16\2\0\1\16\17\174\1\277\64\174"+
+    "\2\175\1\300\2\175\1\301\76\175\56\0\1\302\106\0"+
+    "\1\303\7\0\1\304\66\0\1\305\117\0\1\306\67\0"+
+    "\1\307\10\0\1\206\71\0\1\310\115\0\1\304\67\0"+
+    "\1\311\106\0\1\307\27\0\17\106\1\207\4\106\1\210"+
+    "\57\106\2\0\1\210\124\0\1\105\1\0\6\312\1\114"+
+    "\3\0\1\115\1\116\1\0\1\117\1\116\10\0\1\115"+
+    "\1\116\1\115\4\0\1\117\3\0\1\116\37\0\1\105"+
+    "\1\0\6\313\1\114\3\0\1\115\1\116\1\0\1\117"+
+    "\1\116\10\0\1\115\1\116\1\115\4\0\1\117\3\0"+
+    "\1\116\41\0\7\215\75\0\7\215\3\0\1\115\14\0"+
+    "\1\115\1\0\1\115\52\0\1\216\6\217\2\0\3\217"+
+    "\1\0\1\117\6\0\6\217\4\0\1\117\45\0\7\314"+
+    "\2\0\3\314\1\0\1\117\6\0\6\314\4\0\1\117"+
+    "\20\0\1\16\12\0\1\16\11\0\7\16\2\0\7\16"+
+    "\3\0\16\16\1\143\12\16\2\0\2\16\12\0\1\16"+
+    "\11\0\7\16\2\0\7\16\3\0\13\16\1\241\15\16"+
+    "\2\0\2\16\12\0\1\16\11\0\7\16\2\0\7\16"+
+    "\3\0\1\16\1\315\27\16\2\0\2\16\12\0\1\16"+
+    "\11\0\7\16\2\0\7\16\3\0\5\16\1\143\23\16"+
+    "\2\0\2\16\12\0\1\16\11\0\7\16\2\0\7\16"+
+    "\3\0\3\16\1\316\25\16\2\0\2\16\12\0\1\16"+
+    "\11\0\7\16\2\0\7\16\3\0\20\16\1\317\10\16"+
+    "\2\0\2\16\12\0\1\16\11\0\7\16\2\0\7\16"+
+    "\3\0\21\16\1\264\7\16\2\0\2\16\12\0\1\16"+
+    "\11\0\7\16\2\0\7\16\3\0\21\16\1\320\1\321"+
+    "\6\16\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\1\16\1\322\27\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\5\16\1\323"+
+    "\23\16\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\2\16\1\324\26\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\1\16\1\325"+
+    "\27\16\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\13\16\1\326\15\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\5\16\1\327"+
+    "\23\16\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\1\16\1\330\27\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\5\16\1\331"+
+    "\23\16\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\11\16\1\332\17\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\7\16\1\241"+
+    "\21\16\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\1\16\1\333\27\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\5\16\1\334"+
+    "\23\16\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\20\16\1\335\10\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\24\16\1\336"+
+    "\4\16\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\22\16\1\337\6\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\13\16\1\340"+
+    "\15\16\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\11\16\1\341\17\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\15\16\1\342"+
+    "\13\16\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\22\16\1\343\6\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\23\16\1\327"+
+    "\5\16\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\20\16\1\330\10\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\15\16\1\344"+
+    "\13\16\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\5\16\1\345\23\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\22\16\1\346"+
+    "\6\16\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\23\16\1\347\5\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\22\16\1\224"+
+    "\6\16\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\17\16\1\350\11\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\21\16\1\143"+
+    "\7\16\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\16\16\1\150\12\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\5\16\1\351"+
+    "\23\16\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\16\16\1\352\12\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\11\16\1\353"+
+    "\17\16\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\15\16\1\354\13\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\22\16\1\355"+
+    "\6\16\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\4\16\1\241\24\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\1\16\1\356"+
+    "\27\16\2\0\2\16\12\0\1\16\11\0\7\16\2\0"+
+    "\7\16\3\0\1\16\1\357\27\16\2\0\2\16\12\0"+
+    "\1\16\11\0\7\16\2\0\7\16\3\0\13\16\1\223"+
+    "\15\16\2\0\1\16\17\174\1\277\4\174\1\300\57\174"+
+    "\2\0\1\300\162\0\1\360\100\0\1\361\102\0\1\361"+
+    "\107\0\1\303\110\0\1\362\72\0\1\363\111\0\1\364"+
+    "\77\0\1\365\47\0\1\105\1\0\6\366\1\114\3\0"+
+    "\1\115\1\116\1\0\1\117\1\116\10\0\1\115\1\116"+
+    "\1\115\4\0\1\117\3\0\1\116\37\0\1\105\1\0"+
+    "\6\367\1\114\3\0\1\115\1\116\1\0\1\117\1\116"+
+    "\10\0\1\115\1\116\1\115\4\0\1\117\3\0\1\116"+
+    "\41\0\7\370\2\0\3\370\1\0\1\117\6\0\6\370"+
+    "\4\0\1\117\20\0\1\16\12\0\1\16\11\0\7\16"+
+    "\2\0\7\16\3\0\12\16\1\143\16\16\2\0\2\16"+
+    "\12\0\1\16\11\0\7\16\2\0\7\16\3\0\10\16"+
+    "\1\143\20\16\2\0\2\16\12\0\1\16\11\0\1\16"+
+    "\1\371\1\16\1\372\3\16\2\0\7\16\3\0\31\16"+
+    "\2\0\2\16\12\0\1\16\11\0\7\16\2\0\7\16"+
+    "\3\0\22\16\1\373\6\16\2\0\2\16\12\0\1\16"+
+    "\11\0\7\16\2\0\7\16\3\0\11\16\1\374\17\16"+
+    "\2\0\2\16\12\0\1\16\11\0\7\16\2\0\7\16"+
+    "\3\0\23\16\1\375\5\16\2\0\2\16\12\0\1\16"+
+    "\11\0\7\16\2\0\7\16\3\0\22\16\1\223\6\16"+
+    "\2\0\2\16\12\0\1\16\11\0\7\16\2\0\7\16"+
+    "\3\0\13\16\1\376\15\16\2\0\2\16\12\0\1\16"+
+    "\11\0\7\16\2\0\7\16\3\0\14\16\1\377\14\16"+
+    "\2\0\2\16\12\0\1\16\11\0\7\16\2\0\7\16"+
+    "\3\0\11\16\1\u0100\17\16\2\0\2\16\12\0\1\16"+
+    "\11\0\7\16\2\0\7\16\3\0\20\16\1\352\10\16"+
+    "\2\0\2\16\12\0\1\16\11\0\7\16\2\0\7\16"+
+    "\3\0\22\16\1\241\6\16\2\0\2\16\12\0\1\16"+
+    "\11\0\7\16\2\0\7\16\3\0\15\16\1\u0101\13\16"+
+    "\2\0\2\16\12\0\1\16\11\0\7\16\2\0\7\16"+
+    "\3\0\15\16\1\223\13\16\2\0\2\16\12\0\1\16"+
+    "\11\0\7\16\2\0\7\16\3\0\2\16\1\276\26\16"+
+    "\2\0\2\16\12\0\1\16\11\0\7\16\2\0\7\16"+
+    "\3\0\21\16\1\u0102\7\16\2\0\2\16\12\0\1\16"+
+    "\11\0\7\16\2\0\7\16\3\0\1\16\1\u0103\27\16"+
+    "\2\0\2\16\12\0\1\16\11\0\7\16\2\0\7\16"+
+    "\3\0\1\16\1\323\27\16\2\0\2\16\12\0\1\16"+
+    "\11\0\7\16\2\0\7\16\3\0\5\16\1\u0104\23\16"+
+    "\2\0\2\16\12\0\1\16\11\0\7\16\2\0\7\16"+
+    "\3\0\11\16\1\u0105\17\16\2\0\2\16\12\0\1\16"+
+    "\11\0\7\16\2\0\7\16\3\0\21\16\1\u0106\7\16"+
+    "\2\0\2\16\12\0\1\16\11\0\7\16\2\0\7\16"+
+    "\3\0\22\16\1\u0107\6\16\2\0\2\16\12\0\1\16"+
+    "\11\0\7\16\2\0\7\16\3\0\20\16\1\u0108\10\16"+
+    "\2\0\2\16\12\0\1\16\11\0\7\16\2\0\7\16"+
+    "\3\0\5\16\1\273\23\16\2\0\2\16\12\0\1\16"+
+    "\11\0\7\16\2\0\7\16\3\0\16\16\1\u0109\12\16"+
+    "\2\0\2\16\12\0\1\16\11\0\7\16\2\0\7\16"+
+    "\3\0\11\16\1\u010a\17\16\2\0\2\16\12\0\1\16"+
+    "\11\0\7\16\2\0\7\16\3\0\3\16\1\u010b\25\16"+
+    "\2\0\2\16\12\0\1\16\11\0\7\16\2\0\7\16"+
+    "\3\0\13\16\1\336\15\16\2\0\2\16\12\0\1\16"+
+    "\11\0\7\16\2\0\7\16\3\0\4\16\1\u010c\4\16"+
+    "\1\u0101\3\16\1\u010d\13\16\2\0\2\16\12\0\1\16"+
+    "\11\0\7\16\2\0\7\16\3\0\15\16\1\143\13\16"+
+    "\2\0\2\16\12\0\1\16\11\0\7\16\2\0\7\16"+
+    "\3\0\7\16\1\256\21\16\2\0\2\16\12\0\1\16"+
+    "\11\0\7\16\2\0\7\16\3\0\7\16\1\143\21\16"+
+    "\2\0\2\16\12\0\1\16\11\0\7\16\2\0\7\16"+
+    "\3\0\23\16\1\u010e\5\16\2\0\2\16\12\0\1\16"+
+    "\11\0\7\16\2\0\7\16\3\0\22\16\1\172\6\16"+
+    "\2\0\2\16\12\0\1\16\11\0\7\16\2\0\7\16"+
+    "\3\0\20\16\1\u010f\10\16\2\0\1\16\65\0\1\u0110"+
+    "\106\0\1\361\71\0\1\u0111\120\0\1\u0112\74\0\1\u0113"+
+    "\42\0\1\105\1\0\6\u0114\1\114\3\0\1\115\1\116"+
+    "\1\0\1\117\1\116\10\0\1\115\1\116\1\115\4\0"+
+    "\1\117\3\0\1\116\37\0\1\105\1\0\6\u0115\1\114"+
+    "\3\0\1\115\1\116\1\0\1\117\1\116\10\0\1\115"+
+    "\1\116\1\115\4\0\1\117\3\0\1\116\41\0\7\u0116"+
+    "\2\0\3\u0116\1\0\1\117\6\0\6\u0116\4\0\1\117"+
+    "\20\0\1\16\12\0\1\16\11\0\5\16\1\u010f\1\16"+
+    "\2\0\7\16\3\0\31\16\2\0\2\16\12\0\1\16"+
+    "\11\0\2\16\1\u010f\4\16\2\0\7\16\3\0\31\16"+
+    "\2\0\2\16\12\0\1\16\11\0\7\16\2\0\7\16"+
+    "\3\0\1\u0117\30\16\2\0\2\16\12\0\1\16\11\0"+
+    "\7\16\2\0\7\16\3\0\15\16\1\u0118\13\16\2\0"+
+    "\2\16\12\0\1\16\11\0\7\16\2\0\7\16\3\0"+
+    "\13\16\1\u010b\15\16\2\0\2\16\12\0\1\16\11\0"+
+    "\7\16\2\0\7\16\3\0\5\16\1\241\23\16\2\0"+
+    "\2\16\12\0\1\16\11\0\7\16\2\0\7\16\3\0"+
+    "\11\16\1\u0119\17\16\2\0\2\16\12\0\1\16\11\0"+
+    "\7\16\2\0\7\16\3\0\3\16\1\u011a\25\16\2\0"+
+    "\2\16\12\0\1\16\11\0\7\16\2\0\7\16\3\0"+
+    "\4\16\1\143\24\16\2\0\2\16\12\0\1\16\11\0"+
+    "\7\16\2\0\7\16\3\0\17\16\1\u011b\11\16\2\0"+
+    "\2\16\12\0\1\16\11\0\7\16\2\0\7\16\3\0"+
+    "\22\16\1\u011c\6\16\2\0\2\16\12\0\1\16\11\0"+
+    "\7\16\2\0\7\16\3\0\3\16\1\u011d\25\16\2\0"+
+    "\2\16\12\0\1\16\11\0\7\16\2\0\7\16\3\0"+
+    "\3\16\1\143\25\16\2\0\2\16\12\0\1\16\11\0"+
+    "\7\16\2\0\7\16\3\0\22\16\1\u011e\6\16\2\0"+
+    "\2\16\12\0\1\16\11\0\7\16\2\0\7\16\3\0"+
+    "\5\16\1\u011f\23\16\2\0\2\16\12\0\1\16\11\0"+
+    "\7\16\2\0\7\16\3\0\11\16\1\347\17\16\2\0"+
+    "\2\16\12\0\1\16\11\0\7\16\2\0\7\16\3\0"+
+    "\6\16\1\143\22\16\2\0\2\16\12\0\1\16\11\0"+
+    "\7\16\2\0\7\16\3\0\3\16\1\373\25\16\2\0"+
+    "\2\16\12\0\1\16\11\0\7\16\2\0\7\16\3\0"+
+    "\22\16\1\143\6\16\2\0\2\16\12\0\1\16\11\0"+
+    "\7\16\2\0\7\16\3\0\5\16\1\u0109\23\16\2\0"+
+    "\2\16\12\0\1\16\11\0\7\16\2\0\7\16\3\0"+
+    "\1\16\1\u0120\27\16\2\0\2\16\12\0\1\16\11\0"+
+    "\7\16\2\0\7\16\3\0\1\16\1\u0121\27\16\2\0"+
+    "\2\16\12\0\1\16\11\0\7\16\2\0\7\16\3\0"+
+    "\1\330\30\16\2\0\1\16\55\0\1\u0111\102\0\1\304"+
+    "\100\0\1\361\55\0\1\105\1\0\6\u0122\1\114\3\0"+
+    "\1\115\1\116\1\0\1\117\1\116\10\0\1\115\1\116"+
+    "\1\115\4\0\1\117\3\0\1\116\37\0\1\105\1\0"+
+    "\6\u0123\1\114\3\0\1\115\1\116\1\0\1\117\1\116"+
+    "\10\0\1\115\1\116\1\115\4\0\1\117\3\0\1\116"+
+    "\41\0\7\u0124\2\0\3\u0124\1\0\1\117\6\0\6\u0124"+
+    "\4\0\1\117\20\0\1\16\12\0\1\16\11\0\7\16"+
+    "\2\0\7\16\3\0\3\16\1\u0125\25\16\2\0\2\16"+
+    "\12\0\1\16\11\0\7\16\2\0\7\16\3\0\23\16"+
+    "\1\223\5\16\2\0\2\16\12\0\1\16\11\0\7\16"+
+    "\2\0\7\16\3\0\3\16\1\u0126\25\16\2\0\2\16"+
+    "\12\0\1\16\11\0\7\16\2\0\7\16\3\0\11\16"+
+    "\1\u010b\17\16\2\0\2\16\12\0\1\16\11\0\7\16"+
+    "\2\0\7\16\3\0\1\16\1\u0127\27\16\2\0\2\16"+
+    "\12\0\1\16\11\0\7\16\2\0\7\16\3\0\16\16"+
+    "\1\141\12\16\2\0\2\16\12\0\1\16\11\0\7\16"+
+    "\2\0\7\16\3\0\22\16\1\u0128\6\16\2\0\2\16"+
+    "\12\0\1\16\11\0\7\16\2\0\7\16\3\0\5\16"+
+    "\1\141\23\16\2\0\2\16\12\0\1\16\11\0\7\16"+
+    "\2\0\7\16\3\0\20\16\1\u0129\10\16\2\0\2\16"+
+    "\12\0\1\16\11\0\7\16\2\0\7\16\3\0\14\16"+
+    "\1\223\14\16\2\0\2\16\12\0\1\16\11\0\7\16"+
+    "\2\0\7\16\3\0\13\16\1\143\15\16\2\0\1\16"+
+    "\23\0\1\105\1\0\6\u012a\1\114\3\0\1\115\1\116"+
+    "\1\0\1\117\1\116\10\0\1\115\1\116\1\115\4\0"+
+    "\1\117\3\0\1\116\37\0\1\105\1\0\6\u012b\1\114"+
+    "\3\0\1\115\1\116\1\0\1\117\1\116\10\0\1\115"+
+    "\1\116\1\115\4\0\1\117\3\0\1\116\41\0\7\u012c"+
+    "\2\0\3\u012c\1\0\1\117\6\0\6\u012c\4\0\1\117"+
+    "\20\0\1\16\12\0\1\16\11\0\7\16\2\0\7\16"+
+    "\3\0\1\16\1\u012d\27\16\2\0\2\16\12\0\1\16"+
+    "\11\0\7\16\2\0\7\16\3\0\3\16\1\223\25\16"+
+    "\2\0\2\16\12\0\1\16\11\0\7\16\2\0\7\16"+
+    "\3\0\5\16\1\u0101\23\16\2\0\2\16\12\0\1\16"+
+    "\11\0\7\16\2\0\7\16\3\0\17\16\1\u012e\11\16"+
+    "\2\0\1\16\23\0\1\105\1\0\6\u012f\1\114\3\0"+
+    "\1\115\1\116\1\0\1\117\1\116\10\0\1\115\1\116"+
+    "\1\115\4\0\1\117\3\0\1\116\37\0\1\105\1\0"+
+    "\6\u0130\1\114\3\0\1\115\1\116\1\0\1\117\1\116"+
+    "\10\0\1\115\1\116\1\115\4\0\1\117\3\0\1\116"+
+    "\41\0\7\u0131\2\0\3\u0131\1\0\1\117\6\0\6\u0131"+
+    "\4\0\1\117\20\0\1\16\12\0\1\16\11\0\7\16"+
+    "\2\0\7\16\3\0\21\16\1\u010b\7\16\2\0\2\16"+
+    "\12\0\1\16\11\0\7\16\2\0\7\16\3\0\20\16"+
+    "\1\u0132\10\16\2\0\1\16\23\0\1\105\1\0\6\u0133"+
+    "\1\114\3\0\1\115\1\116\1\0\1\117\1\116\10\0"+
+    "\1\115\1\116\1\115\4\0\1\117\3\0\1\116\37\0"+
+    "\1\105\1\0\6\u0134\1\114\3\0\1\115\1\116\1\0"+
+    "\1\117\1\116\10\0\1\115\1\116\1\115\4\0\1\117"+
+    "\3\0\1\116\41\0\7\u0135\2\0\3\u0135\1\0\1\117"+
+    "\6\0\6\u0135\4\0\1\117\20\0\1\16\12\0\1\16"+
+    "\11\0\7\16\2\0\7\16\3\0\5\16\1\u0136\23\16"+
+    "\2\0\1\16\23\0\1\105\1\0\6\u0137\1\114\3\0"+
+    "\1\115\1\116\1\0\1\117\1\116\10\0\1\115\1\116"+
+    "\1\115\4\0\1\117\3\0\1\116\37\0\1\105\1\0"+
+    "\6\u0138\1\114\3\0\1\115\1\116\1\0\1\117\1\116"+
+    "\10\0\1\115\1\116\1\115\4\0\1\117\3\0\1\116"+
+    "\41\0\7\u0139\2\0\3\u0139\1\0\1\117\6\0\6\u0139"+
+    "\4\0\1\117\20\0\1\16\12\0\1\16\11\0\7\16"+
+    "\2\0\7\16\3\0\22\16\1\u0126\6\16\2\0\1\16"+
+    "\23\0\1\105\1\0\6\u013a\1\114\3\0\1\115\1\116"+
+    "\1\0\1\117\1\116\10\0\1\115\1\116\1\115\4\0"+
+    "\1\117\3\0\1\116\37\0\1\105\1\0\6\u013b\1\114"+
+    "\3\0\1\115\1\116\1\0\1\117\1\116\10\0\1\115"+
+    "\1\116\1\115\4\0\1\117\3\0\1\116\41\0\7\u013c"+
+    "\2\0\3\u013c\1\0\1\117\6\0\6\u013c\4\0\1\117"+
+    "\43\0\1\105\1\0\6\u013d\1\114\3\0\1\115\1\116"+
+    "\1\0\1\117\1\116\10\0\1\115\1\116\1\115\4\0"+
+    "\1\117\3\0\1\116\37\0\1\105\1\0\6\u013e\1\114"+
+    "\3\0\1\115\1\116\1\0\1\117\1\116\10\0\1\115"+
+    "\1\116\1\115\4\0\1\117\3\0\1\116\41\0\7\u013f"+
+    "\2\0\3\u013f\1\0\1\117\6\0\6\u013f\4\0\1\117"+
+    "\43\0\1\105\1\0\6\u0140\1\114\3\0\1\115\1\116"+
+    "\1\0\1\117\1\116\10\0\1\115\1\116\1\115\4\0"+
+    "\1\117\3\0\1\116\37\0\1\105\1\0\6\u0141\1\114"+
+    "\3\0\1\115\1\116\1\0\1\117\1\116\10\0\1\115"+
+    "\1\116\1\115\4\0\1\117\3\0\1\116\41\0\7\u0142"+
+    "\2\0\3\u0142\1\0\1\117\6\0\6\u0142\4\0\1\117"+
+    "\43\0\1\105\1\0\6\u0143\1\114\3\0\1\115\1\116"+
+    "\1\0\1\117\1\116\10\0\1\115\1\116\1\115\4\0"+
+    "\1\117\3\0\1\116\37\0\1\105\1\0\6\u0144\1\114"+
+    "\3\0\1\115\1\116\1\0\1\117\1\116\10\0\1\115"+
+    "\1\116\1\115\4\0\1\117\3\0\1\116\41\0\7\u0145"+
+    "\2\0\3\u0145\1\0\1\117\6\0\6\u0145\4\0\1\117"+
+    "\43\0\1\105\1\0\6\u0146\1\114\3\0\1\115\1\116"+
+    "\1\0\1\117\1\116\10\0\1\115\1\116\1\115\4\0"+
+    "\1\117\3\0\1\116\37\0\1\105\1\0\6\u0147\1\114"+
+    "\3\0\1\115\1\116\1\0\1\117\1\116\10\0\1\115"+
+    "\1\116\1\115\4\0\1\117\3\0\1\116\41\0\7\u0148"+
+    "\2\0\3\u0148\1\0\1\117\6\0\6\u0148\4\0\1\117"+
+    "\43\0\1\105\1\0\6\u0149\1\114\3\0\1\115\1\116"+
+    "\1\0\1\117\1\116\10\0\1\115\1\116\1\115\4\0"+
+    "\1\117\3\0\1\116\37\0\1\105\1\0\6\u014a\1\114"+
+    "\3\0\1\115\1\116\1\0\1\117\1\116\10\0\1\115"+
+    "\1\116\1\115\4\0\1\117\3\0\1\116\41\0\7\u014b"+
+    "\2\0\3\u014b\1\0\1\117\6\0\6\u014b\4\0\1\117"+
+    "\43\0\1\105\1\0\6\u014c\1\114\3\0\1\115\1\116"+
+    "\1\0\1\117\1\116\10\0\1\115\1\116\1\115\4\0"+
+    "\1\117\3\0\1\116\41\0\7\u014d\2\0\3\u014d\1\0"+
+    "\1\117\6\0\6\u014d\4\0\1\117\43\0\1\105\1\0"+
+    "\6\u014e\1\114\3\0\1\115\1\116\1\0\1\117\1\116"+
+    "\10\0\1\115\1\116\1\115\4\0\1\117\3\0\1\116"+
+    "\56\0\1\117\20\0\1\117\43\0\1\105\1\0\6\u014f"+
+    "\1\114\3\0\1\115\1\116\1\0\1\117\1\116\10\0"+
+    "\1\115\1\116\1\115\4\0\1\117\3\0\1\116\37\0"+
+    "\1\105\1\0\6\u0150\1\114\3\0\1\115\1\116\1\0"+
+    "\1\117\1\116\10\0\1\115\1\116\1\115\4\0\1\117"+
+    "\3\0\1\116\37\0\1\105\1\0\6\u0151\1\114\3\0"+
+    "\1\115\1\116\1\0\1\117\1\116\10\0\1\115\1\116"+
+    "\1\115\4\0\1\117\3\0\1\116\37\0\1\105\1\0"+
+    "\7\114\3\0\1\115\1\116\1\0\1\117\1\116\10\0"+
+    "\1\115\1\116\1\115\4\0\1\117\3\0\1\116\14\0";
+
+  private static int [] zzUnpacktrans() {
+    int [] result = new int[20604];
+    int offset = 0;
+    offset = zzUnpacktrans(ZZ_TRANS_PACKED_0, offset, result);
+    return result;
+  }
+
+  private static int zzUnpacktrans(String packed, int offset, int [] result) {
+    int i = 0;       /* index in packed string  */
+    int j = offset;  /* index in unpacked array */
+    int l = packed.length();
+    while (i < l) {
+      int count = packed.charAt(i++);
+      int value = packed.charAt(i++);
+      value--;
+      do result[j++] = value; while (--count > 0);
+    }
+    return j;
+  }
+
+
+  /** Error code for "Unknown internal scanner error". */
+  private static final int ZZ_UNKNOWN_ERROR = 0;
+  /** Error code for "could not match input". */
+  private static final int ZZ_NO_MATCH = 1;
+  /** Error code for "pushback value was too large". */
+  private static final int ZZ_PUSHBACK_2BIG = 2;
+
+  /**
+   * Error messages for {@link #ZZ_UNKNOWN_ERROR}, {@link #ZZ_NO_MATCH}, and
+   * {@link #ZZ_PUSHBACK_2BIG} respectively.
+   */
+  private static final String ZZ_ERROR_MSG[] = {
+    "Unknown internal scanner error",
+    "Error: could not match input",
+    "Error: pushback value was too large"
+  };
+
+  /**
+   * ZZ_ATTRIBUTE[aState] contains the attributes of state {@code aState}
+   */
+  private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();
+
+  private static final String ZZ_ATTRIBUTE_PACKED_0 =
+    "\6\0\3\11\1\1\2\11\2\1\4\11\4\1\3\11"+
+    "\23\1\2\11\1\1\1\11\1\1\1\11\1\1\2\11"+
+    "\1\1\1\11\1\1\1\11\1\1\2\11\1\1\7\0"+
+    "\1\1\1\0\6\1\1\11\1\0\1\11\1\0\52\1"+
+    "\1\11\1\0\1\1\4\0\1\1\5\0\1\11\3\1"+
+    "\1\0\62\1\1\0\1\11\1\1\10\0\46\1\1\0"+
+    "\1\11\4\0\32\1\1\0\1\11\2\0\45\1\1\0"+
+    "\2\1\1\0\2\1\1\0\2\1\1\0\2\1\1\0"+
+    "\2\1\1\0\2\1\1\0\1\1\1\0\4\1";
+
+  private static int [] zzUnpackAttribute() {
+    int [] result = new int[337];
+    int offset = 0;
+    offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
+    return result;
+  }
+
+  private static int zzUnpackAttribute(String packed, int offset, int [] result) {
+    int i = 0;       /* index in packed string  */
+    int j = offset;  /* index in unpacked array */
+    int l = packed.length();
+    while (i < l) {
+      int count = packed.charAt(i++);
+      int value = packed.charAt(i++);
+      do result[j++] = value; while (--count > 0);
+    }
+    return j;
+  }
+
+  /** Input device. */
+  private java.io.Reader zzReader;
+
+  /** Current state of the DFA. */
+  private int zzState;
+
+  /** Current lexical state. */
+  private int zzLexicalState = YYINITIAL;
+
+  /**
+   * This buffer contains the current text to be matched and is the source of the {@link #yytext()}
+   * string.
+   */
+  private char zzBuffer[] = new char[Math.min(ZZ_BUFFERSIZE, zzMaxBufferLen())];
+
+  /** Text position at the last accepting state. */
+  private int zzMarkedPos;
+
+  /** Current text position in the buffer. */
+  private int zzCurrentPos;
+
+  /** Marks the beginning of the {@link #yytext()} string in the buffer. */
+  private int zzStartRead;
+
+  /** Marks the last character in the buffer, that has been read from input. */
+  private int zzEndRead;
+
+  /**
+   * Whether the scanner is at the end of file.
+   * @see #yyatEOF
+   */
+  private boolean zzAtEOF;
+
+  /**
+   * The number of occupied positions in {@link #zzBuffer} beyond {@link #zzEndRead}.
+   *
+   * <p>When a lead/high surrogate has been read from the input stream into the final
+   * {@link #zzBuffer} position, this will have a value of 1; otherwise, it will have a value of 0.
+   */
+  private int zzFinalHighSurrogate = 0;
+
+  /** Number of newlines encountered up to the start of the matched text. */
+  private int yyline;
+
+  /** Number of characters from the last newline up to the start of the matched text. */
+  private int yycolumn;
+
+  /** Number of characters up to the start of the matched text. */
+  private long yychar;
+
+  /** Whether the scanner is currently at the beginning of a line. */
+  @SuppressWarnings("unused")
+  private boolean zzAtBOL = true;
+
+  /** Whether the user-EOF-code has already been executed. */
+  @SuppressWarnings("unused")
+  private boolean zzEOFDone;
+
+  /* user code: */
+
+
+
+  /**
+   * Creates a new scanner
+   *
+   * @param   in  the java.io.Reader to read input from.
+   */
+  public CppLexer(java.io.Reader in) {
+    this.zzReader = in;
+  }
+
+
+  /** Returns the maximum size of the scanner buffer, which limits the size of tokens. */
+  private int zzMaxBufferLen() {
+    return Integer.MAX_VALUE;
+  }
+
+  /**  Whether the scanner buffer can grow to accommodate a larger token. */
+  private boolean zzCanGrow() {
+    return true;
+  }
+
+  /**
+   * Translates raw input code points to DFA table row
+   */
+  private static int zzCMap(int input) {
+    int offset = input & 255;
+    return offset == input ? ZZ_CMAP_BLOCKS[offset] : ZZ_CMAP_BLOCKS[ZZ_CMAP_TOP[input >> 8] | offset];
+  }
+
+  /**
+   * Refills the input buffer.
+   *
+   * @return {@code false} iff there was new input.
+   * @exception java.io.IOException  if any I/O-Error occurs
+   */
+  private boolean zzRefill() throws java.io.IOException {
+
+    /* first: make room (if you can) */
+    if (zzStartRead > 0) {
+      zzEndRead += zzFinalHighSurrogate;
+      zzFinalHighSurrogate = 0;
+      System.arraycopy(zzBuffer, zzStartRead,
+                       zzBuffer, 0,
+                       zzEndRead - zzStartRead);
+
+      /* translate stored positions */
+      zzEndRead -= zzStartRead;
+      zzCurrentPos -= zzStartRead;
+      zzMarkedPos -= zzStartRead;
+      zzStartRead = 0;
+    }
+
+    /* is the buffer big enough? */
+    if (zzCurrentPos >= zzBuffer.length - zzFinalHighSurrogate && zzCanGrow()) {
+      /* if not, and it can grow: blow it up */
+      char newBuffer[] = new char[Math.min(zzBuffer.length * 2, zzMaxBufferLen())];
+      System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
+      zzBuffer = newBuffer;
+      zzEndRead += zzFinalHighSurrogate;
+      zzFinalHighSurrogate = 0;
+    }
+
+    /* fill the buffer with new input */
+    int requested = zzBuffer.length - zzEndRead;
+    int numRead = zzReader.read(zzBuffer, zzEndRead, requested);
+
+    /* not supposed to occur according to specification of java.io.Reader */
+    if (numRead == 0) {
+      if (requested == 0) {
+        throw new java.io.EOFException("Scan buffer limit reached ["+zzBuffer.length+"]");
+      }
+      else {
+        throw new java.io.IOException(
+            "Reader returned 0 characters. See JFlex examples/zero-reader for a workaround.");
+      }
+    }
+    if (numRead > 0) {
+      zzEndRead += numRead;
+      if (Character.isHighSurrogate(zzBuffer[zzEndRead - 1])) {
+        if (numRead == requested) { // We requested too few chars to encode a full Unicode character
+          --zzEndRead;
+          zzFinalHighSurrogate = 1;
+        } else {                    // There is room in the buffer for at least one more char
+          int c = zzReader.read();  // Expecting to read a paired low surrogate char
+          if (c == -1) {
+            return true;
+          } else {
+            zzBuffer[zzEndRead++] = (char)c;
+          }
+        }
+      }
+      /* potentially more input available */
+      return false;
+    }
+
+    /* numRead < 0 ==> end of stream */
+    return true;
+  }
+
+
+  /**
+   * Closes the input reader.
+   *
+   * @throws java.io.IOException if the reader could not be closed.
+   */
+  public final void yyclose() throws java.io.IOException {
+    zzAtEOF = true; // indicate end of file
+    zzEndRead = zzStartRead; // invalidate buffer
+
+    if (zzReader != null) {
+      zzReader.close();
+    }
+  }
+
+
+  /**
+   * Resets the scanner to read from a new input stream.
+   *
+   * <p>Does not close the old reader.
+   *
+   * <p>All internal variables are reset, the old input stream <b>cannot</b> be reused (internal
+   * buffer is discarded and lost). Lexical state is set to {@code ZZ_INITIAL}.
+   *
+   * <p>Internal scan buffer is resized down to its initial length, if it has grown.
+   *
+   * @param reader The new input stream.
+   */
+  public final void yyreset(java.io.Reader reader) {
+    zzReader = reader;
+    zzEOFDone = false;
+    yyResetPosition();
+    zzLexicalState = YYINITIAL;
+    int initBufferSize = Math.min(ZZ_BUFFERSIZE, zzMaxBufferLen());
+    if (zzBuffer.length > initBufferSize) {
+      zzBuffer = new char[initBufferSize];
+    }
+  }
+
+  /**
+   * Resets the input position.
+   */
+  private final void yyResetPosition() {
+      zzAtBOL  = true;
+      zzAtEOF  = false;
+      zzCurrentPos = 0;
+      zzMarkedPos = 0;
+      zzStartRead = 0;
+      zzEndRead = 0;
+      zzFinalHighSurrogate = 0;
+      yyline = 0;
+      yycolumn = 0;
+      yychar = 0L;
+  }
+
+
+  /**
+   * Returns whether the scanner has reached the end of the reader it reads from.
+   *
+   * @return whether the scanner has reached EOF.
+   */
+  public final boolean yyatEOF() {
+    return zzAtEOF;
+  }
+
+
+  /**
+   * Returns the current lexical state.
+   *
+   * @return the current lexical state.
+   */
+  public final int yystate() {
+    return zzLexicalState;
+  }
+
+
+  /**
+   * Enters a new lexical state.
+   *
+   * @param newState the new lexical state
+   */
+  public final void yybegin(int newState) {
+    zzLexicalState = newState;
+  }
+
+
+  /**
+   * Returns the text matched by the current regular expression.
+   *
+   * @return the matched text.
+   */
+  public final String yytext() {
+    return new String(zzBuffer, zzStartRead, zzMarkedPos-zzStartRead);
+  }
+
+
+  /**
+   * Returns the character at the given position from the matched text.
+   *
+   * <p>It is equivalent to {@code yytext().charAt(pos)}, but faster.
+   *
+   * @param position the position of the character to fetch. A value from 0 to {@code yylength()-1}.
+   *
+   * @return the character at {@code position}.
+   */
+  public final char yycharat(int position) {
+    return zzBuffer[zzStartRead + position];
+  }
+
+
+  /**
+   * How many characters were matched.
+   *
+   * @return the length of the matched text region.
+   */
+  public final int yylength() {
+    return zzMarkedPos-zzStartRead;
+  }
+
+
+  /**
+   * Reports an error that occurred while scanning.
+   *
+   * <p>In a well-formed scanner (no or only correct usage of {@code yypushback(int)} and a
+   * match-all fallback rule) this method will only be called with things that
+   * "Can't Possibly Happen".
+   *
+   * <p>If this method is called, something is seriously wrong (e.g. a JFlex bug producing a faulty
+   * scanner etc.).
+   *
+   * <p>Usual syntax/scanner level error handling should be done in error fallback rules.
+   *
+   * @param errorCode the code of the error message to display.
+   */
+  private static void zzScanError(int errorCode) {
+    String message;
+    try {
+      message = ZZ_ERROR_MSG[errorCode];
+    } catch (ArrayIndexOutOfBoundsException e) {
+      message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
+    }
+
+    throw new Error(message);
+  }
+
+
+  /**
+   * Pushes the specified amount of characters back into the input stream.
+   *
+   * <p>They will be read again by then next call of the scanning method.
+   *
+   * @param number the number of characters to be read again. This number must not be greater than
+   *     {@link #yylength()}.
+   */
+  public void yypushback(int number)  {
+    if ( number > yylength() )
+      zzScanError(ZZ_PUSHBACK_2BIG);
+
+    zzMarkedPos -= number;
+  }
+
+
+
+
+  /**
+   * Resumes scanning until the next regular expression is matched, the end of input is encountered
+   * or an I/O-Error occurs.
+   *
+   * @return the next token.
+   * @exception java.io.IOException if any I/O-Error occurs.
+   */
+  public int yylex() throws java.io.IOException
+  {
+    int zzInput;
+    int zzAction;
+
+    // cached fields:
+    int zzCurrentPosL;
+    int zzMarkedPosL;
+    int zzEndReadL = zzEndRead;
+    char[] zzBufferL = zzBuffer;
+
+    int [] zzTransL = ZZ_TRANS;
+    int [] zzRowMapL = ZZ_ROWMAP;
+    int [] zzAttrL = ZZ_ATTRIBUTE;
+
+    while (true) {
+      zzMarkedPosL = zzMarkedPos;
+
+      yychar+= zzMarkedPosL-zzStartRead;
+
+      boolean zzR = false;
+      int zzCh;
+      int zzCharCount;
+      for (zzCurrentPosL = zzStartRead  ;
+           zzCurrentPosL < zzMarkedPosL ;
+           zzCurrentPosL += zzCharCount ) {
+        zzCh = Character.codePointAt(zzBufferL, zzCurrentPosL, zzMarkedPosL);
+        zzCharCount = Character.charCount(zzCh);
+        switch (zzCh) {
+        case '\u000B':  // fall through
+        case '\u000C':  // fall through
+        case '\u0085':  // fall through
+        case '\u2028':  // fall through
+        case '\u2029':
+          yyline++;
+          yycolumn = 0;
+          zzR = false;
+          break;
+        case '\r':
+          yyline++;
+          yycolumn = 0;
+          zzR = true;
+          break;
+        case '\n':
+          if (zzR)
+            zzR = false;
+          else {
+            yyline++;
+            yycolumn = 0;
+          }
+          break;
+        default:
+          zzR = false;
+          yycolumn += zzCharCount;
+        }
+      }
+
+      if (zzR) {
+        // peek one character ahead if it is
+        // (if we have counted one line too much)
+        boolean zzPeek;
+        if (zzMarkedPosL < zzEndReadL)
+          zzPeek = zzBufferL[zzMarkedPosL] == '\n';
+        else if (zzAtEOF)
+          zzPeek = false;
+        else {
+          boolean eof = zzRefill();
+          zzEndReadL = zzEndRead;
+          zzMarkedPosL = zzMarkedPos;
+          zzBufferL = zzBuffer;
+          if (eof)
+            zzPeek = false;
+          else
+            zzPeek = zzBufferL[zzMarkedPosL] == '\n';
+        }
+        if (zzPeek) yyline--;
+      }
+      zzAction = -1;
+
+      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
+
+      zzState = ZZ_LEXSTATE[zzLexicalState];
+
+      // set up zzAction for empty match case:
+      int zzAttributes = zzAttrL[zzState];
+      if ( (zzAttributes & 1) == 1 ) {
+        zzAction = zzState;
+      }
+
+
+      zzForAction: {
+        while (true) {
+
+          if (zzCurrentPosL < zzEndReadL) {
+            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
+            zzCurrentPosL += Character.charCount(zzInput);
+          }
+          else if (zzAtEOF) {
+            zzInput = YYEOF;
+            break zzForAction;
+          }
+          else {
+            // store back cached positions
+            zzCurrentPos  = zzCurrentPosL;
+            zzMarkedPos   = zzMarkedPosL;
+            boolean eof = zzRefill();
+            // get translated positions and possibly new buffer
+            zzCurrentPosL  = zzCurrentPos;
+            zzMarkedPosL   = zzMarkedPos;
+            zzBufferL      = zzBuffer;
+            zzEndReadL     = zzEndRead;
+            if (eof) {
+              zzInput = YYEOF;
+              break zzForAction;
+            }
+            else {
+              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
+              zzCurrentPosL += Character.charCount(zzInput);
+            }
+          }
+          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMap(zzInput) ];
+          if (zzNext == -1) break zzForAction;
+          zzState = zzNext;
+
+          zzAttributes = zzAttrL[zzState];
+          if ( (zzAttributes & 1) == 1 ) {
+            zzAction = zzState;
+            zzMarkedPosL = zzCurrentPosL;
+            if ( (zzAttributes & 8) == 8 ) break zzForAction;
+          }
+
+        }
+      }
+
+      // store back cached position
+      zzMarkedPos = zzMarkedPosL;
+
+      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
+        zzAtEOF = true;
+              {
+                return EOF;
+              }
+      }
+      else {
+        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
+          case 1:
+            { return ERROR;
+            }
+          // fall through
+          case 34: break;
+          case 2:
+            { return WHITE_CHAR;
+            }
+          // fall through
+          case 35: break;
+          case 3:
+            { return NEW_LINE;
+            }
+          // fall through
+          case 36: break;
+          case 4:
+            { return OPERATOR;
+            }
+          // fall through
+          case 37: break;
+          case 5:
+            { yybegin(STRING); return STRING_LITERAL;
+            }
+          // fall through
+          case 38: break;
+          case 6:
+            { return IDENTIFIER;
+            }
+          // fall through
+          case 39: break;
+          case 7:
+            { yybegin(CHARLITERAL);return CHARACTER_LITERAL;
+            }
+          // fall through
+          case 40: break;
+          case 8:
+            { return LPAREN;
+            }
+          // fall through
+          case 41: break;
+          case 9:
+            { return RPAREN;
+            }
+          // fall through
+          case 42: break;
+          case 10:
+            { return COMMA;
+            }
+          // fall through
+          case 43: break;
+          case 11:
+            { return DOT;
+            }
+          // fall through
+          case 44: break;
+          case 12:
+            { return INTEGER_LITERAL;
+            }
+          // fall through
+          case 45: break;
+          case 13:
+            { return SEMICOLON;
+            }
+          // fall through
+          case 46: break;
+          case 14:
+            { return LBRACK;
+            }
+          // fall through
+          case 47: break;
+          case 15:
+            { return RBRACK;
+            }
+          // fall through
+          case 48: break;
+          case 16:
+            { return LBRACE;
+            }
+          // fall through
+          case 49: break;
+          case 17:
+            { return RBRACE;
+            }
+          // fall through
+          case 50: break;
+          case 18:
+            { return STRING_LITERAL;
+            }
+          // fall through
+          case 51: break;
+          case 19:
+            { yybegin(YYINITIAL);return NEW_LINE;
+            }
+          // fall through
+          case 52: break;
+          case 20:
+            { yybegin(YYINITIAL);return STRING_LITERAL;
+            }
+          // fall through
+          case 53: break;
+          case 21:
+            { return CHARACTER_LITERAL;
+            }
+          // fall through
+          case 54: break;
+          case 22:
+            { yybegin(YYINITIAL);return CHARACTER_LITERAL;
+            }
+          // fall through
+          case 55: break;
+          case 23:
+            { return PRETREATMENT_LINE;
+            }
+          // fall through
+          case 56: break;
+          case 24:
+            { return DEFINE_LINE;
+            }
+          // fall through
+          case 57: break;
+          case 25:
+            { yybegin(DEFINE_NEW_LINE);return DEFINE_LINE;
+            }
+          // fall through
+          case 58: break;
+          case 26:
+            { yybegin(DEFINE);return DEFINE_LINE;
+            }
+          // fall through
+          case 59: break;
+          case 27:
+            { return FLOATING_POINT_LITERAL;
+            }
+          // fall through
+          case 60: break;
+          case 28:
+            { return COMMENT;
+            }
+          // fall through
+          case 61: break;
+          case 29:
+            { return KEYWORD;
+            }
+          // fall through
+          case 62: break;
+          case 30:
+            { yybegin(YYINITIAL);return COMMENT;
+            }
+          // fall through
+          case 63: break;
+          case 31:
+            { { yybegin(DEFINE);return DEFINE_LINE; }
+            }
+          // fall through
+          case 64: break;
+          case 32:
+            { return TYPE;
+            }
+          // fall through
+          case 65: break;
+          case 33:
+            { yybegin(PRETREATMENT);return PRETREATMENT_LINE;
+            }
+          // fall through
+          case 66: break;
+          default:
+            zzScanError(ZZ_NO_MATCH);
+        }
+      }
+    }
+  }
+
+
+}
diff --git a/codeeditor/src/main/java/cn/rbc/codeeditor/util/CharSeqReader.java b/codeeditor/src/main/java/cn/rbc/codeeditor/util/CharSeqReader.java
new file mode 100644
index 0000000..98b9d32
--- /dev/null
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/util/CharSeqReader.java
@@ -0,0 +1,35 @@
+package cn.rbc.codeeditor.util;
+
+import java.io.*;
+
+public class CharSeqReader extends Reader {
+	int offset = 0;
+	CharSequence src;
+
+	public CharSeqReader(CharSequence src) {
+		this.src = src;
+	}
+
+	@Override
+	public void close() {
+		src = null;
+		offset = 0;
+	}
+
+	@Override
+	public int read(char[] chars, int i, int i1) throws IOException {
+		int len = Math.min(src.length() - offset, i1);
+		for (int n = 0; n < len; n++) {
+			try {
+				char c = src.charAt(offset++);
+				chars[i++] = c;
+			} catch (Exception e) {
+
+			}
+		}
+		if (len <= 0)
+			return  -1;
+		return len;
+	}
+}
+
diff --git a/codeeditor/src/main/java/cn/rbc/codeeditor/util/ErrSpan.java b/codeeditor/src/main/java/cn/rbc/codeeditor/util/ErrSpan.java
index 7715763..4d4ecd3 100644
--- a/codeeditor/src/main/java/cn/rbc/codeeditor/util/ErrSpan.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/util/ErrSpan.java
@@ -1,14 +1,13 @@
 package cn.rbc.codeeditor.util;
 
-public class ErrSpan
+public class ErrSpan extends Range
 {
 	public final static int
 		ERROR = 0,
 		WARNING = 1,
 		INFOR = 2,
 		HINT = 3;
-	public String msg;
-	public int stl, stc, enl, enc, severity = 0;
+	public int severity = 0;
 
 	@Override
 	public String toString() {
diff --git a/codeeditor/src/main/java/cn/rbc/codeeditor/util/Lexer.java b/codeeditor/src/main/java/cn/rbc/codeeditor/util/Lexer.java
index d51d2d1..39c89c1 100644
--- a/codeeditor/src/main/java/cn/rbc/codeeditor/util/Lexer.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/util/Lexer.java
@@ -1,384 +1,35 @@
-/*
- * Copyright (c) 2013 Tah Wei Hoon.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Apache License Version 2.0,
- * with full text available at http://www.apache.org/licenses/LICENSE-2.0.html
- *
- * This software is provided "as is". Use at your own risk.
- */
 package cn.rbc.codeeditor.util;
-
-import cn.rbc.codeeditor.lang.Language;
-import cn.rbc.codeeditor.lang.LanguageNonProg;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import android.util.*;
-
-/**
- * Does lexical analysis of a text for C-like languages.
- * The programming language syntax used is set as a static class variable.
- */
-public class Lexer {
-    public final static int UNKNOWN = -1;
-    public final static int NORMAL = 0;
-    public final static int KEYWORD = 1;
-    public final static int OPERATOR = 2;
-    public final static int NAME = 3;
-    public final static int NUMBER = 4;
-	public final static int KEYNAME = 5;
-	public final static int TYPE = 6;
-	final static int NUM_HEX = 1;
-	final static int NUM_FLOAT = 2;
-	final static int NUM_EXP = 4;
-    /**
-     * A word that starts with a special symbol, inclusive.
-     * Examples:
-     * :ruby_symbol
-     */
-    public final static int SINGLE_SYMBOL_WORD = 10;
-    /**
-     * Tokens that extend from a single start symbol, inclusive, until the end of line.
-     * Up to 2 types of symbols are supported per language, denoted by A and B
-     * Examples:
-     * #include "myCppFile"
-     * #this is a comment in Python
-     * %this is a comment in Prolog
-     */
-    public final static int SINGLE_SYMBOL_LINE_A = 20;
-    public final static int SINGLE_SYMBOL_LINE_B = 21;
-    /**
-     * Tokens that extend from a two start symbols, inclusive, until the end of line.
-     * Examples:
-     * //this is a comment in C
-     */
-    public final static int DOUBLE_SYMBOL_LINE = 30;
-    /**
-     * Tokens that are enclosed between a start and end sequence, inclusive,
-     * that can span multiple lines. The start and end sequences contain exactly
-     * 2 symbols.
-     * Examples:
-     * {- this is a...
-     * ...multi-line comment in Haskell -}
-     */
-    public final static int DOUBLE_SYMBOL_DELIMITED_MULTILINE = 40;
-    /**
-     * Tokens that are enclosed by the same single symbol, inclusive, and
-     * do not span over more than one line.
-     * Examples: 'c', "hello world"
-     */
-    public final static int SINGLE_SYMBOL_DELIMITED_A = 50;
-    public final static int SINGLE_SYMBOL_DELIMITED_B = 51;
-    private final static int MAX_KEYWORD_LENGTH = 31;
-    private static Language _globalLanguage = LanguageNonProg.getInstance();
-    LexCallback _callback = null;
-    private Document _hDoc;
-    private LexThread _workerThread = null;
-    public Lexer(LexCallback callback) {
-        _callback = callback;
-    }
-
-    synchronized public static Language getLanguage() {
-        return _globalLanguage;
-    }
-
-    synchronized public static void setLanguage(Language lang) {
-        _globalLanguage = lang;
-    }
-
-    public void tokenize(Document hDoc) {
-        if (!Lexer.getLanguage().isProgLang())
-            return;
-
-        //tokenize will modify the state of hDoc; make a copy
-        setDocument(hDoc);
-        if (_workerThread == null) {
-            _workerThread = new LexThread(this);
-            _workerThread.start();
-        } else
-            _workerThread.restart();
-    }
-
-    void tokenizeDone(List<Pair> result) {
-        if (_callback != null)
-            _callback.lexDone(result);
-        _workerThread = null;
-    }
-
-    public void cancelTokenize() {
-        if (_workerThread != null) {
-            _workerThread.abort();
-            _workerThread = null;
-        }
-    }
-
-    public synchronized Document getDocument() {
-        return _hDoc;
-    }
-
-    public synchronized void setDocument(Document hDoc) {
-        _hDoc = hDoc;
-    }
-
-
-    public interface LexCallback {
-        public void lexDone(List<Pair> results);
-    }
-
-    private class LexThread extends Thread {
-        private final Lexer _lexManager;
-        /**
-         * can be set by another thread to stop the scan immediately
-         */
-        private final Flag _abort;
-        private boolean rescan = false;
-        /**
-         * A collection of Pairs, where Pair.first is the start
-         * position of the token, and Pair.second is the type of the token.
-         */
-        private ArrayList<Pair> _tokens;
-
-        public LexThread(Lexer p) {
-            _lexManager = p;
-            _abort = new Flag();
-        }
-
-        @Override
-        public void run() {
-            do {
-                rescan = false;
-                _abort.clear();
-                tokenize();
-            } while (rescan);
-
-            if (!_abort.isSet())
-                // lex complete
-                _lexManager.tokenizeDone(_tokens);
-        }
-
-        public void restart() {
-            rescan = true;
-            _abort.set();
-        }
-
-        public void abort() {
-            _abort.set();
-        }
-
-        /**
-         * Scans the document referenced by _lexManager for tokens.
-         * The result is stored internally.
-         */
-        public void tokenize() {
-            Document hDoc = getDocument();
-            Language language = Lexer.getLanguage();
-            ArrayList<Pair> tokens = new ArrayList<Pair>();
-
-            if (!language.isProgLang()) {
-                tokens.add(new Pair(0, NORMAL));
-                _tokens = tokens;
-                return;
-            }
-
-            char[] candidateWord = new char[MAX_KEYWORD_LENGTH];
-            int currCharInWord = 0;
-
-            int spanStartPosition = 0;
-            int workingPosition = 0;
-            int state = UNKNOWN;
-			int substate = 0;
-            char prevChar = 0;
-			boolean stateChanged;
-
-            //hDoc.seekChar(0);
-            for (int idx=0, mL=hDoc.getTextLength(); idx<mL && !_abort.isSet();) {
-                char currChar = hDoc.charAt(idx++);
-
-                switch (state) {
-					case NUMBER:
-						stateChanged = false;
-						boolean t = (substate&NUM_HEX)==0;
-						boolean f = (substate&NUM_FLOAT)==0;
-						char upc = Character.toLowerCase(currChar);
-						char plc;
-						// 十六进制
-						if (currCharInWord==1&&prevChar=='0'&&upc=='x') {
-							substate |= NUM_HEX;
-							stateChanged = true;
-							// 浮点数
-						} else if (f&&upc=='.') {
-							substate |= NUM_FLOAT;
-							stateChanged = true;
-							// 科学计数法
-						} else if ((substate&NUM_EXP)==0
-								   && (t&&upc=='e'
-								   || (!t)&&upc=='p')) {
-							substate |= NUM_EXP;
-							substate |= NUM_FLOAT;
-							substate &= (~NUM_HEX);
-							stateChanged = true;
-							// 科学计数后
-						} else if (((plc=Character.toLowerCase(prevChar))=='p'||plc=='e')
-								   &&(upc=='-'||upc=='+')) {
-							stateChanged = true;
-							// 结尾
-						} else if (f&&upc=='l' || (!f)&&upc=='f') {
-							currChar = ' ';
-						}
-						if (stateChanged||Character.isDigit(currChar)||((!t)&&'a'<=upc&&'f'>=upc)) {
-							currCharInWord++;
-							break;
-						}
-						if (!Character.isJavaIdentifierStart(currChar)) {
-							spanStartPosition = workingPosition - currCharInWord;
-							tokens.add(new Pair(spanStartPosition, state));
-						}
-						currCharInWord = 0;
-						state = UNKNOWN;
-					case OPERATOR:
-                    case UNKNOWN: //fall-through
-                    case NORMAL: //fall-through
-                    case KEYWORD: //fall-through
-					case KEYNAME:
-					case TYPE:
-                    case SINGLE_SYMBOL_WORD:
-                        int pendingState = state;
-                        stateChanged = false;
-                        if (language.isLineStart(prevChar, currChar)) {
-                            pendingState = DOUBLE_SYMBOL_LINE;
-                            stateChanged = true;
-                        } else if (language.isMultilineStartDelimiter(prevChar, currChar)) {
-                            pendingState = DOUBLE_SYMBOL_DELIMITED_MULTILINE;
-                            stateChanged = true;
-                        } else if (language.isDelimiterA(currChar)) {
-                            pendingState = SINGLE_SYMBOL_DELIMITED_A;
-                            stateChanged = true;
-                        } else if (language.isDelimiterB(currChar)) {
-                            pendingState = SINGLE_SYMBOL_DELIMITED_B;
-                            stateChanged = true;
-						} else if ((!Character.isJavaIdentifierPart(prevChar)) && Character.isDigit(currChar)) {
-							state = NUMBER;
-                        } else if (language.isLineAStart(currChar)) {
-                            pendingState = SINGLE_SYMBOL_LINE_A;
-                            stateChanged = true;
-                        } else if (language.isLineBStart(currChar)) {
-                            pendingState = SINGLE_SYMBOL_LINE_B;
-                            stateChanged = true;
-                        }
-
-                        if (stateChanged) {
-                            if (pendingState == DOUBLE_SYMBOL_LINE ||
-                                    pendingState == DOUBLE_SYMBOL_DELIMITED_MULTILINE) {
-                                // account for previous char
-                                spanStartPosition = workingPosition - 1;
-								//TODO consider less greedy approach and avoid adding token for previous char
-                                if (tokens.get(tokens.size() - 1).first == spanStartPosition)
-                                    tokens.remove(tokens.size() - 1);
-                            } else
-                                spanStartPosition = workingPosition;
-
-                            // If a span appears mid-word, mark the chars preceding
-                            // it as NORMAL, if the previous span isn't already NORMAL
-                            if (currCharInWord > 0 && state != NORMAL)
-                                tokens.add(new Pair(workingPosition - currCharInWord, NORMAL));
-
-                            state = pendingState;
-                            tokens.add(new Pair(spanStartPosition, state));
-                            currCharInWord = 0;
-                        } else if (language.isWhitespace(currChar) || language.isOperator(currChar)) {
-                            if (currCharInWord > 0) {
-                                // full word obtained; mark the beginning of the word accordingly
-								stateChanged = false;
-                                if (language.isWordStart(candidateWord[0])) {
-                                    state = SINGLE_SYMBOL_WORD;
-									stateChanged = true;
-                                } else if (language.isKeyword(new String(candidateWord, 0, currCharInWord))) {
-                                    state = KEYWORD;
-									stateChanged = true;
-                                } else {
-									Integer i = language.type(new String(candidateWord, 0, currCharInWord));
-									int _t;
-									if (i != null && (_t=i.intValue()) != Lexer.NAME) {
-										state = _t;
-										stateChanged = true;
-									} else if (state != NORMAL) {
-                                    	state = NORMAL;
-										stateChanged = true;
-                                	}
-								}
-								if (stateChanged) {
-									spanStartPosition = workingPosition - currCharInWord;
-									tokens.add(new Pair(spanStartPosition, state));
-								}
-                                currCharInWord = 0;
-                            }
-
-                            // mark operators as normal
-                            if (state != OPERATOR && language.isOperator(currChar)) {
-                                state = OPERATOR;
-                                tokens.add(new Pair(workingPosition, state));
-                            }
-                        } else if (currCharInWord < MAX_KEYWORD_LENGTH) {
-                            // collect non-whitespace chars up to MAX_KEYWORD_LENGTH
-                            candidateWord[currCharInWord] = currChar;
-                            currCharInWord++;
-                        }
-                        break;
-
-
-					case DOUBLE_SYMBOL_LINE:
-                    case SINGLE_SYMBOL_LINE_A: // fall-through
-						if (language.isEscapeChar(prevChar))
-							break;
-                    case SINGLE_SYMBOL_LINE_B:
-                        if (currChar == '\n')
-                            state = UNKNOWN;
-                        break;
-
-
-                    case SINGLE_SYMBOL_DELIMITED_A:
-                        if ((language.isDelimiterA(currChar) || currChar == '\n')
-                                && !language.isEscapeChar(prevChar))
-                            state = UNKNOWN;
-                        // consume escape of the escape character by assigning
-                        // currChar as something else so that it would not be
-                        // treated as an escape char in the next iteration
-                        else if (language.isEscapeChar(currChar) && language.isEscapeChar(prevChar))
-                            currChar = ' ';
-                        break;
-                    case SINGLE_SYMBOL_DELIMITED_B:
-                        if ((language.isDelimiterB(currChar) || currChar == '\n')
-                                && !language.isEscapeChar(prevChar))
-                            state = UNKNOWN;
-                        // consume escape of the escape character by assigning
-                        // currChar as something else so that it would not be
-                        // treated as an escape char in the next iteration
-                        else if (language.isEscapeChar(currChar)
-                                && language.isEscapeChar(prevChar))
-                            currChar = ' ';
-                        break;
-
-                    case DOUBLE_SYMBOL_DELIMITED_MULTILINE:
-                        if (language.isMultilineEndDelimiter(prevChar, currChar))
-                            state = UNKNOWN;
-                        break;
-
-                    default:
-                        TextWarriorException.fail("Invalid state in TokenScanner");
-                        break;
-                }
-                ++workingPosition;
-                prevChar = currChar;
-            }
-            // end state machine
-
-            if (tokens.isEmpty())
-                // return value cannot be empty
-                tokens.add(new Pair(0, NORMAL));
-
-            _tokens = tokens;
-        }
-
-    }//end inner class
+import java.io.*;
+
+public interface Lexer
+{
+	public final static int EOF = 0,
+	OPERATOR=1, //运算符
+	IDENTIFIER=2,//标识符
+	INTEGER_LITERAL=3, //整数
+	KEYWORD=4, //关键字
+	TYPE=18, //类型
+	FLOATING_POINT_LITERAL=5, //浮点
+	COMMENT=6, //注释
+	STRING_LITERAL=7,//字符串
+	COMMA=8, //逗号
+	SEMICOLON=9,//分号
+	RBRACK=10, 
+	LBRACK=11,
+	LPAREN=12,//左括号
+	RPAREN=13,//右括号
+	RBRACE=14, //右大括号
+	LBRACE=15, //左大括号
+	DOT=16, //点
+	CHARACTER_LITERAL=17,//字符
+	PRETREATMENT_LINE=19, //预处理
+	WHITE_SPACE=20,//空白符
+	DEFINE_LINE=21,//define
+	NEW_LINE=22,
+	WHITE_CHAR=23,
+	ERROR=24;
+
+	public int yylex() throws IOException
+	public int yylength()
+	public String yytext()
 }
diff --git a/codeeditor/src/main/java/cn/rbc/codeeditor/util/LinearSearchStrategy.java b/codeeditor/src/main/java/cn/rbc/codeeditor/util/LinearSearchStrategy.java
index 80f71e4..b9fce57 100644
--- a/codeeditor/src/main/java/cn/rbc/codeeditor/util/LinearSearchStrategy.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/util/LinearSearchStrategy.java
@@ -186,7 +186,7 @@ public class LinearSearchStrategy implements SearchStrategy {
      */
     protected boolean isSandwichedByWhitespace(Document src,
                                                int start, int length) {
-        Language charSet = Lexer.getLanguage();
+        Language charSet = Tokenizer.getLanguage();
         boolean startWithWhitespace = (start == 0) || charSet.isWhitespace(src.charAt(start - 1));
 
         int end = start + length;
diff --git a/codeeditor/src/main/java/cn/rbc/codeeditor/util/Range.java b/codeeditor/src/main/java/cn/rbc/codeeditor/util/Range.java
new file mode 100644
index 0000000..490037a
--- /dev/null
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/util/Range.java
@@ -0,0 +1,7 @@
+package cn.rbc.codeeditor.util;
+
+public class Range
+{
+	public int stl, stc, enl, enc;
+	public String msg;
+}
diff --git a/codeeditor/src/main/java/cn/rbc/codeeditor/util/TextBuffer.java b/codeeditor/src/main/java/cn/rbc/codeeditor/util/TextBuffer.java
index 4e4693d..6dfa8b3 100644
--- a/codeeditor/src/main/java/cn/rbc/codeeditor/util/TextBuffer.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/util/TextBuffer.java
@@ -546,7 +546,7 @@ public class TextBuffer implements CharSequence
 
 	public void clearSpans(){
 		_spans = new Vector<Pair>();
-	    _spans.add(new Pair(0, Lexer.NORMAL));
+	    _spans.add(new Pair(0, Tokenizer.NORMAL));
 	}
 
 	public List<Pair> getSpans(){
diff --git a/codeeditor/src/main/java/cn/rbc/codeeditor/util/Tokenizer.java b/codeeditor/src/main/java/cn/rbc/codeeditor/util/Tokenizer.java
new file mode 100644
index 0000000..eeef4b2
--- /dev/null
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/util/Tokenizer.java
@@ -0,0 +1,464 @@
+/*
+ * Copyright (c) 2013 Tah Wei Hoon.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Apache License Version 2.0,
+ * with full text available at http://www.apache.org/licenses/LICENSE-2.0.html
+ *
+ * This software is provided "as is". Use at your own risk.
+ */
+package cn.rbc.codeeditor.util;
+
+import cn.rbc.codeeditor.lang.Language;
+import cn.rbc.codeeditor.lang.LanguageNonProg;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import android.util.*;
+
+/**
+ * Does lexical analysis of a text for C-like languages.
+ * The programming language syntax used is set as a static class variable.
+ */
+public class Tokenizer {
+    public final static int UNKNOWN = -1;
+    public final static int NORMAL = 0;
+    public final static int KEYWORD = 1;
+    public final static int OPERATOR = 2;
+    public final static int NAME = 3;
+    public final static int NUMBER = 4;
+	public final static int KEYNAME = 5;
+	public final static int TYPE = 6;
+	final static int NUM_HEX = 1;
+	final static int NUM_FLOAT = 2;
+	final static int NUM_EXP = 4;
+    /**
+     * A word that starts with a special symbol, inclusive.
+     * Examples:
+     * :ruby_symbol
+     */
+    public final static int SINGLE_SYMBOL_WORD = 10;
+    /**
+     * Tokens that extend from a single start symbol, inclusive, until the end of line.
+     * Up to 2 types of symbols are supported per language, denoted by A and B
+     * Examples:
+     * #include "myCppFile"
+     * #this is a comment in Python
+     * %this is a comment in Prolog
+     */
+    public final static int SINGLE_SYMBOL_LINE_A = 20;
+    public final static int SINGLE_SYMBOL_LINE_B = 21;
+    /**
+     * Tokens that extend from a two start symbols, inclusive, until the end of line.
+     * Examples:
+     * //this is a comment in C
+     */
+    public final static int DOUBLE_SYMBOL_LINE = 30;
+    /**
+     * Tokens that are enclosed between a start and end sequence, inclusive,
+     * that can span multiple lines. The start and end sequences contain exactly
+     * 2 symbols.
+     * Examples:
+     * {- this is a...
+     * ...multi-line comment in Haskell -}
+     */
+    public final static int DOUBLE_SYMBOL_DELIMITED_MULTILINE = 40;
+    /**
+     * Tokens that are enclosed by the same single symbol, inclusive, and
+     * do not span over more than one line.
+     * Examples: 'c', "hello world"
+     */
+    public final static int SINGLE_SYMBOL_DELIMITED_A = 50;
+    public final static int SINGLE_SYMBOL_DELIMITED_B = 51;
+   // public final static int MAX_KEYWORD_LENGTH = 63;
+    private static Language _globalLanguage = LanguageNonProg.getInstance();
+    LexCallback _callback = null;
+    private Document _hDoc;
+    private LexThread _workerThread = null;
+    public Tokenizer(LexCallback callback) {
+        _callback = callback;
+    }
+
+    synchronized public static Language getLanguage() {
+        return _globalLanguage;
+    }
+
+    synchronized public static void setLanguage(Language lang) {
+        _globalLanguage = lang;
+    }
+
+    public void tokenize(Document hDoc) {
+        if (!Tokenizer.getLanguage().isProgLang())
+            return;
+
+        //tokenize will modify the state of hDoc; make a copy
+        setDocument(hDoc);
+        if (_workerThread == null) {
+            _workerThread = new LexThread(this);
+            _workerThread.start();
+        } else
+            _workerThread.restart();
+    }
+
+    void tokenizeDone(List<Pair> result) {
+        if (_callback != null)
+            _callback.lexDone(result);
+        _workerThread = null;
+    }
+
+    public void cancelTokenize() {
+        if (_workerThread != null) {
+            _workerThread.abort();
+            _workerThread = null;
+        }
+    }
+
+    public synchronized Document getDocument() {
+        return _hDoc;
+    }
+
+    public synchronized void setDocument(Document hDoc) {
+        _hDoc = hDoc;
+    }
+
+
+    public interface LexCallback {
+        public void lexDone(List<Pair> results);
+    }
+
+    private class LexThread extends Thread {
+        private final Tokenizer _lexManager;
+        /**
+         * can be set by another thread to stop the scan immediately
+         */
+        private final Flag _abort;
+        private boolean rescan = false;
+        /**
+         * A collection of Pairs, where Pair.first is the start
+         * position of the token, and Pair.second is the type of the token.
+         */
+        private ArrayList<Pair> _tokens;
+
+        public LexThread(Tokenizer p) {
+            _lexManager = p;
+            _abort = new Flag();
+        }
+
+        @Override
+        public void run() {
+            do {
+                rescan = false;
+                _abort.clear();
+                tokenize();
+				//_tokens = Lexer.getLanguage().getTokenizer().tokenize(getDocument(), _abort);
+            } while (rescan);
+
+            if (!_abort.isSet())
+                // lex complete
+                _lexManager.tokenizeDone(_tokens);
+        }
+
+        public void restart() {
+            rescan = true;
+            _abort.set();
+        }
+
+        public void abort() {
+            _abort.set();
+        }
+
+        /**
+         * Scans the document referenced by _lexManager for tokens.
+         * The result is stored internally.
+         */
+        public void tokenize() {
+			Language language = Tokenizer.getLanguage();
+			if (!language.isProgLang()) {
+				_tokens = new ArrayList<>();
+				return;
+			}
+			ArrayList<Pair> tokens = new ArrayList<>();
+			Lexer lexer=language.newLexer(new CharSeqReader(_hDoc));
+			int type=-1, lastCtype=-1;
+			int idx=0;
+			String identifier=null;//存储标识符
+			language.clearUserWord();
+			while (type!=Lexer.EOF && !_abort.isSet()){
+				try {
+					type=lexer.yylex();
+					if (type!=lastCtype)
+						switch (type)
+						{
+							case Lexer.KEYWORD:
+								tokens.add(new Pair(idx, Tokenizer.KEYWORD));
+								break;
+							case Lexer.TYPE:
+								tokens.add(new Pair(idx, Tokenizer.TYPE));
+								break;
+							case Lexer.COMMENT:
+								tokens.add(new Pair(idx, Tokenizer.DOUBLE_SYMBOL_DELIMITED_MULTILINE));
+								break;
+								// macro
+							case Lexer.PRETREATMENT_LINE:
+							case Lexer.DEFINE_LINE:
+								tokens.add(new Pair(idx, Tokenizer.SINGLE_SYMBOL_LINE_A));
+								break;
+								// string, char
+							case Lexer.STRING_LITERAL:
+							case Lexer.CHARACTER_LITERAL:
+								tokens.add(new Pair(idx, Tokenizer.SINGLE_SYMBOL_DELIMITED_A));
+								break;
+								// number
+							case Lexer.INTEGER_LITERAL:
+							case Lexer.FLOATING_POINT_LITERAL:
+								tokens.add(new Pair(idx, Tokenizer.NUMBER));
+								break;
+							case Lexer.IDENTIFIER:
+								identifier=lexer.yytext();
+								tokens.add(new Pair(idx, Tokenizer.NORMAL));
+								break;
+								// symbols
+							case Lexer.LPAREN:// (
+							case Lexer.RPAREN:// )
+							case Lexer.LBRACK:// [
+							case Lexer.RBRACK:// ]
+							case Lexer.LBRACE:// {
+							case Lexer.RBRACE:// }
+							case Lexer.COMMA:// ,
+							case Lexer.WHITE_CHAR:// ' '
+							case Lexer.SEMICOLON:// ;
+							case Lexer.OPERATOR:
+								if (identifier!=null) {
+									language.addUserWord(identifier);
+									language.updateUserWord();
+									identifier=null;
+								}
+								tokens.add(new Pair(idx, Tokenizer.OPERATOR));
+								break;
+							default:
+								tokens.add(new Pair(idx, Tokenizer.NORMAL));
+						}
+					lastCtype = type;
+					idx += lexer.yylength();
+				} catch (Exception e) {
+					e.printStackTrace();
+					idx++;//错误了，索引也要往后挪
+				}
+			}
+
+			if (tokens.isEmpty()){
+				// return value cannot be empty
+				tokens.add(new Pair(0, Tokenizer.NORMAL));
+			}
+			//printList(tokens);
+			_tokens = tokens;
+            /*Document hDoc = getDocument();
+            Language language = Lexer.getLanguage();
+            ArrayList<Pair> tokens = new ArrayList<Pair>();
+
+            if (!language.isProgLang()) {
+                tokens.add(new Pair(0, NORMAL));
+                _tokens = tokens;
+                return;
+            }
+
+            char[] candidateWord = new char[MAX_KEYWORD_LENGTH];
+            int currCharInWord = 0;
+
+            int spanStartPosition = 0;
+            int workingPosition = 0;
+            int state = UNKNOWN;
+			int substate = 0;
+            char prevChar = 0;
+			boolean stateChanged;
+
+            for (int idx=0, mL=hDoc.getTextLength(); idx<mL && !_abort.isSet();) {
+                char currChar = hDoc.charAt(idx++);
+
+                switch (state) {
+					case NUMBER:
+						stateChanged = false;
+						boolean t = (substate&NUM_HEX)==0;
+						boolean f = (substate&NUM_FLOAT)==0;
+						char upc = Character.toLowerCase(currChar);
+						char plc;
+						// hex
+						if (currCharInWord==1&&prevChar=='0'&&upc=='x') {
+							substate |= NUM_HEX;
+							stateChanged = true;
+							// float
+						} else if (f&&upc=='.') {
+							substate |= NUM_FLOAT;
+							stateChanged = true;
+							// 科学计数法
+						} else if ((substate&NUM_EXP)==0
+								   && (t&&upc=='e'
+								   || (!t)&&upc=='p')) {
+							substate |= NUM_EXP;
+							substate |= NUM_FLOAT;
+							substate &= (~NUM_HEX);
+							stateChanged = true;
+							// 科学计数后
+						} else if (((plc=Character.toLowerCase(prevChar))=='p'||plc=='e')
+								   &&(upc=='-'||upc=='+')) {
+							stateChanged = true;
+							// suffix
+						} else if (f&&upc=='l' || (!f)&&upc=='f') {
+							currChar = ' ';
+						}
+						if (stateChanged||Character.isDigit(currChar)||((!t)&&'a'<=upc&&'f'>=upc)) {
+							currCharInWord++;
+							break;
+						}
+						if (!Character.isJavaIdentifierStart(currChar)) {
+							spanStartPosition = workingPosition - currCharInWord;
+							tokens.add(new Pair(spanStartPosition, state));
+						}
+						currCharInWord = 0;
+						state = UNKNOWN;
+					case OPERATOR:
+                    case UNKNOWN: //fall-through
+                    case NORMAL: //fall-through
+                    case KEYWORD: //fall-through
+					case KEYNAME:
+					case TYPE:
+                    case SINGLE_SYMBOL_WORD:
+                        int pendingState = state;
+                        stateChanged = false;
+                        if (language.isLineStart(prevChar, currChar)) {
+                            pendingState = DOUBLE_SYMBOL_LINE;
+                            stateChanged = true;
+                        } else if (language.isMultilineStartDelimiter(prevChar, currChar)) {
+                            pendingState = DOUBLE_SYMBOL_DELIMITED_MULTILINE;
+                            stateChanged = true;
+                        } else if (language.isDelimiterA(currChar)) {
+                            pendingState = SINGLE_SYMBOL_DELIMITED_A;
+                            stateChanged = true;
+                        } else if (language.isDelimiterB(currChar)) {
+                            pendingState = SINGLE_SYMBOL_DELIMITED_B;
+                            stateChanged = true;
+						} else if ((!Character.isJavaIdentifierPart(prevChar)) && Character.isDigit(currChar)) {
+							state = NUMBER;
+                        } else if (language.isLineAStart(currChar)) {
+                            pendingState = SINGLE_SYMBOL_LINE_A;
+                            stateChanged = true;
+                        } else if (language.isLineBStart(currChar)) {
+                            pendingState = SINGLE_SYMBOL_LINE_B;
+                            stateChanged = true;
+                        }
+
+                        if (stateChanged) {
+                            if (pendingState == DOUBLE_SYMBOL_LINE ||
+                                    pendingState == DOUBLE_SYMBOL_DELIMITED_MULTILINE) {
+                                // account for previous char
+                                spanStartPosition = workingPosition - 1;
+								//TODO consider less greedy approach and avoid adding token for previous char
+                                if (tokens.get(tokens.size() - 1).first == spanStartPosition)
+                                    tokens.remove(tokens.size() - 1);
+                            } else
+                                spanStartPosition = workingPosition;
+
+                            // If a span appears mid-word, mark the chars preceding
+                            // it as NORMAL, if the previous span isn't already NORMAL
+                            if (currCharInWord > 0 && state != NORMAL)
+                                tokens.add(new Pair(workingPosition - currCharInWord, NORMAL));
+
+                            state = pendingState;
+                            tokens.add(new Pair(spanStartPosition, state));
+                            currCharInWord = 0;
+                        } else if (language.isWhitespace(currChar) || language.isOperator(currChar)) {
+                            if (currCharInWord > 0) {
+                                // full word obtained; mark the beginning of the word accordingly
+								stateChanged = false;
+                                if (language.isWordStart(candidateWord[0])) {
+                                    state = SINGLE_SYMBOL_WORD;
+									stateChanged = true;
+                                } else if (language.isKeyword(new String(candidateWord, 0, currCharInWord))) {
+                                    state = KEYWORD;
+									stateChanged = true;
+                                } else {
+									Integer i = language.type(new String(candidateWord, 0, currCharInWord));
+									int _t;
+									if (i != null && (_t=i.intValue()) != Lexer.NAME) {
+										state = _t;
+										stateChanged = true;
+									} else if (state != NORMAL) {
+                                    	state = NORMAL;
+										stateChanged = true;
+                                	}
+								}
+								if (stateChanged) {
+									spanStartPosition = workingPosition - currCharInWord;
+									tokens.add(new Pair(spanStartPosition, state));
+								}
+                                currCharInWord = 0;
+                            }
+
+                            // mark operators as normal
+                            if (state != OPERATOR && language.isOperator(currChar)) {
+                                state = OPERATOR;
+                                tokens.add(new Pair(workingPosition, state));
+                            }
+                        } else if (currCharInWord < MAX_KEYWORD_LENGTH) {
+                            // collect non-whitespace chars up to MAX_KEYWORD_LENGTH
+                            candidateWord[currCharInWord] = currChar;
+                            currCharInWord++;
+                        }
+                        break;
+
+
+					case DOUBLE_SYMBOL_LINE:
+                    case SINGLE_SYMBOL_LINE_A: // fall-through
+						if (language.isEscapeChar(prevChar))
+							break;
+                    case SINGLE_SYMBOL_LINE_B:
+                        if (currChar == '\n')
+                            state = UNKNOWN;
+                        break;
+
+
+                    case SINGLE_SYMBOL_DELIMITED_A:
+                        if ((language.isDelimiterA(currChar) || currChar == '\n')
+                                && !language.isEscapeChar(prevChar))
+                            state = UNKNOWN;
+                        // consume escape of the escape character by assigning
+                        // currChar as something else so that it would not be
+                        // treated as an escape char in the next iteration
+                        else if (language.isEscapeChar(currChar) && language.isEscapeChar(prevChar))
+                            currChar = ' ';
+                        break;
+                    case SINGLE_SYMBOL_DELIMITED_B:
+                        if ((language.isDelimiterB(currChar) || currChar == '\n')
+                                && !language.isEscapeChar(prevChar))
+                            state = UNKNOWN;
+                        // consume escape of the escape character by assigning
+                        // currChar as something else so that it would not be
+                        // treated as an escape char in the next iteration
+                        else if (language.isEscapeChar(currChar)
+                                && language.isEscapeChar(prevChar))
+                            currChar = ' ';
+                        break;
+
+                    case DOUBLE_SYMBOL_DELIMITED_MULTILINE:
+                        if (language.isMultilineEndDelimiter(prevChar, currChar))
+                            state = UNKNOWN;
+                        break;
+
+                    default:
+                        TextWarriorException.fail("Invalid state in TokenScanner");
+                        break;
+                }
+                ++workingPosition;
+                prevChar = currChar;
+            }
+            // end state machine
+
+            if (tokens.isEmpty())
+                // return value cannot be empty
+                tokens.add(new Pair(0, NORMAL));
+
+            _tokens = tokens;*/
+        }
+
+    }//end inner class
+}
diff --git a/codeeditor/src/main/java/cn/rbc/codeeditor/view/ColorScheme.java b/codeeditor/src/main/java/cn/rbc/codeeditor/view/ColorScheme.java
index 901bb7d..c694443 100644
--- a/codeeditor/src/main/java/cn/rbc/codeeditor/view/ColorScheme.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/view/ColorScheme.java
@@ -9,7 +9,7 @@
 
 package cn.rbc.codeeditor.view;
 
-import cn.rbc.codeeditor.util.Lexer;
+import cn.rbc.codeeditor.util.Tokenizer;
 import cn.rbc.codeeditor.util.TextWarriorException;
 
 import java.util.HashMap;
@@ -42,36 +42,36 @@ public abstract class ColorScheme {
     public int getTokenColor(int tokenType) {
         Colorable element;
         switch (tokenType) {
-            case Lexer.NORMAL:
+            case Tokenizer.NORMAL:
                 element = Colorable.FOREGROUND;
                 break;
-            case Lexer.KEYWORD:
+            case Tokenizer.KEYWORD:
                 element = Colorable.KEYWORD;
                 break;
-			case Lexer.TYPE:
+			case Tokenizer.TYPE:
 				element = Colorable.TYPE;
 				break;
-            case Lexer.NAME:
+            case Tokenizer.NAME:
                 element = Colorable.NAME;
                 break;
-            case Lexer.DOUBLE_SYMBOL_LINE: //fall-through
-            case Lexer.DOUBLE_SYMBOL_DELIMITED_MULTILINE:
+            case Tokenizer.DOUBLE_SYMBOL_LINE: //fall-through
+            case Tokenizer.DOUBLE_SYMBOL_DELIMITED_MULTILINE:
                 element = Colorable.COMMENT;
                 break;
-            case Lexer.SINGLE_SYMBOL_DELIMITED_A: //fall-through
-            case Lexer.SINGLE_SYMBOL_DELIMITED_B:
-			case Lexer.KEYNAME:
+            case Tokenizer.SINGLE_SYMBOL_DELIMITED_A: //fall-through
+            case Tokenizer.SINGLE_SYMBOL_DELIMITED_B:
+			case Tokenizer.KEYNAME:
                 element = Colorable.STRING;
                 break;
-            case Lexer.NUMBER:
+            case Tokenizer.NUMBER:
                 element = Colorable.NUMBER;
                 break;
-            case Lexer.SINGLE_SYMBOL_LINE_A: //fall-through
-            case Lexer.SINGLE_SYMBOL_WORD:
-            case Lexer.OPERATOR:
+            case Tokenizer.SINGLE_SYMBOL_LINE_A: //fall-through
+            case Tokenizer.SINGLE_SYMBOL_WORD:
+            case Tokenizer.OPERATOR:
                 element = Colorable.SECONDARY;
                 break;
-            case Lexer.SINGLE_SYMBOL_LINE_B: //类型
+            case Tokenizer.SINGLE_SYMBOL_LINE_B: //类型
                 element = Colorable.NAME;
                 break;
             default:
@@ -119,5 +119,5 @@ public abstract class ColorScheme {
     private static final int WHITE = 0xFFFFFFE0;
     private static final int LIGHT_BLUE2 = 0xFF40B0FF;
 
-	static final int[] DIAG = {Color.RED, 0xFFFFD000, Color.GREEN, Color.GRAY};
+	static final int[] DIAG = {Color.RED, Color.MAGENTA, 0xFF00BB00, Color.GRAY};
 }
diff --git a/codeeditor/src/main/java/cn/rbc/codeeditor/view/FreeScrollingTextField.java b/codeeditor/src/main/java/cn/rbc/codeeditor/view/FreeScrollingTextField.java
index 11979fd..9f0f8ec 100644
--- a/codeeditor/src/main/java/cn/rbc/codeeditor/view/FreeScrollingTextField.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/view/FreeScrollingTextField.java
@@ -297,7 +297,6 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
     private Pair mCaretSpan = new Pair(0, 0);
     private Typeface defTypeface = Typeface.DEFAULT;
     private Typeface boldTypeface = Typeface.DEFAULT_BOLD;
-    //private Typeface italicTypeface = Typeface.create(Typeface.DEFAULT, Typeface.ITALIC);
     private int mTypeInput = InputType.TYPE_CLASS_TEXT;
     private Context mContext;
 	private SparseIntArray chrAdvs = new SparseIntArray();
@@ -411,7 +410,7 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
         mSpaceWidth = (int) mTextPaint.measureText(" ");
         //int idx=coordToCharIndex(getScrollX(), getScrollY());
         //if (!makeCharVisible(idx))
-            invalidate();
+        invalidate();
     }
 
     public void replaceText(int from, int charCount, String text) {
@@ -625,7 +624,8 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
             if (!isLayout)
                 mCtrlr.determineSpans();
             isLayout = right > 0;
-			invalidate();
+			if (!mCtrlr.lexing)
+				invalidate();
            // mAutoCompletePanel.setWidth(getWidth() / 2);
             //mAutoCompletePanel.setHeight(getHeight() / 2);
         }
@@ -726,8 +726,6 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
         mNavMethod.onTextDrawComplete(canvas);
     }
 
-	//public static boolean jj = false;
-
     private void realDraw(Canvas canvas) {
         int currRowNum = getBeginPaintRow(canvas);
         int currIndex = hDoc.getRowOffset(currRowNum);
@@ -763,7 +761,7 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
 		int currType = currSpan.second;
         int lastType = currType;
 
-        mTextPaint.setTypeface(currSpan.second==Lexer.KEYWORD ? boldTypeface : defTypeface);
+        mTextPaint.setTypeface(currSpan.second==Tokenizer.KEYWORD ? boldTypeface : defTypeface);
 
         int spanColor = mColorScheme.getTokenColor(currSpan.second);
         mTextPaint.setColor(spanColor);
@@ -825,7 +823,7 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
                     spanColor = mColorScheme.getTokenColor(currSpan.second);
                     mTextPaint.setColor(spanColor);
 					if (lastType != currType) {
-                        Typeface currTypeface = currType==Lexer.KEYWORD ? boldTypeface : defTypeface;
+                        Typeface currTypeface = currType==Tokenizer.KEYWORD ? boldTypeface : defTypeface;
 
                         if (mTextPaint.getTypeface() != currTypeface)
                             mTextPaint.setTypeface(currTypeface);
@@ -852,15 +850,20 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
 					else if (currIndex + 1 == mCaretPosition)
 						mCaretSpan = currSpan;
 					// draw err line
-					if (idx <= dgl && p.stl == currLineNum) {
-						if (m < 0 && p.stc == i)
-								m = x;
-						// 假设 p.stl==p.enl
-						if (m >= 0 && (p.enc == i+1 || i+1 == rowLen || paintX >= mWidth)) {
+					if (idx <= dgl) {
+						if (m < 0
+							// start position
+							&& (p.stl == currLineNum && p.stc == i
+							// following position
+							|| p.stl < currLineNum && p.enl >= currLineNum && x==mLeftOffset))
+							m = x;
+						boolean b;
+						if (m >= 0 && ((b=(p.enl == currLineNum && p.enc == i+1))|| i+1 == rowLen || paintX >= mWidth)) {
 							mLineBrush.setColor(ColorScheme.DIAG[p.severity]);
 							canvas.drawLine(m, paintY, paintX, paintY, mLineBrush);
+							Log.i("LSP", currLineNum+" "+i);
 							m = -1;
-							if (idx<dgl)
+							if (idx<dgl && b)
 								p = dg.get(idx++);
 						}
 					}
@@ -869,9 +872,9 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
             }
 
             if (hDoc.charAt(currIndex - 1) == Language.NEWLINE) {
-                ++currLineNum;
-				while (idx < dgl && p.stl < currLineNum)
+				while (idx < dgl && p.enl == currLineNum)
 					p = dg.get(idx++);
+				++currLineNum;
 			}
 
             paintY += rowheight;
@@ -1204,6 +1207,8 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
      * Invalidate rows from startRow (inclusive) to the end of the field
      */
     void invalidateFromRow(int startRow) {
+		if (mCtrlr.lexing)
+			return;
         TextWarriorException.assertVerbose(startRow >= 0,
 										   "Invalid startRow");
 
@@ -1457,7 +1462,6 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
                         isEmoji = false;
                     else
                         extent += getCharAdvance(c);
-
             }
 
             if (extent >= x)
diff --git a/codeeditor/src/main/java/cn/rbc/codeeditor/view/TextFieldController.java b/codeeditor/src/main/java/cn/rbc/codeeditor/view/TextFieldController.java
index 6184748..fb298e6 100644
--- a/codeeditor/src/main/java/cn/rbc/codeeditor/view/TextFieldController.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/view/TextFieldController.java
@@ -5,7 +5,7 @@ import android.text.ClipboardManager;
 import android.view.inputmethod.InputMethodManager;
 
 import cn.rbc.codeeditor.lang.Language;
-import cn.rbc.codeeditor.util.Lexer;
+import cn.rbc.codeeditor.util.Tokenizer;
 import cn.rbc.codeeditor.util.Pair;
 import cn.rbc.codeeditor.util.TextWarriorException;
 
@@ -18,8 +18,8 @@ import cn.rbc.codeeditor.util.*;
 //*********************************************************************
 //************************ Controller logic ***************************
 //*********************************************************************
-public class TextFieldController implements Lexer.LexCallback {
-    private final Lexer _lexer = new Lexer(this);
+public class TextFieldController implements Tokenizer.LexCallback {
+    private final Tokenizer _lexer = new Tokenizer(this);
     public boolean _isInSelectionMode = false;
     private boolean _isInSelectionMode2;
 	public boolean lexing;
diff --git a/codeeditor/src/main/java/cn/rbc/codeeditor/view/TextFieldInputConnection.java b/codeeditor/src/main/java/cn/rbc/codeeditor/view/TextFieldInputConnection.java
index f7065a3..14633ae 100644
--- a/codeeditor/src/main/java/cn/rbc/codeeditor/view/TextFieldInputConnection.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/view/TextFieldInputConnection.java
@@ -6,9 +6,11 @@ import android.view.inputmethod.BaseInputConnection;
 
 import cn.rbc.codeeditor.lang.Language;
 import cn.rbc.codeeditor.util.DLog;
-import cn.rbc.codeeditor.util.Lexer;
+import cn.rbc.codeeditor.util.Tokenizer;
 
 import static cn.rbc.codeeditor.util.DLog.log;
+import cn.rbc.codeeditor.util.*;
+import android.widget.*;
 
 //*********************************************************************
 //************************** InputConnection **************************
@@ -59,10 +61,7 @@ public class TextFieldInputConnection extends BaseInputConnection {
     public boolean sendKeyEvent(KeyEvent event) {
         switch (event.getKeyCode()) {
             case KeyEvent.KEYCODE_SHIFT_LEFT:
-                if (textField.isSelectText())
-                    textField.selectText(false);
-                else
-                    textField.selectText(true);
+				textField.selectText(!textField.isSelected());
                 break;
             case KeyEvent.KEYCODE_DPAD_LEFT:
                 textField.moveCaretLeft();
@@ -84,11 +83,10 @@ public class TextFieldInputConnection extends BaseInputConnection {
                 break;
             case KeyEvent.KEYCODE_ENTER:
             case KeyEvent.KEYCODE_NUMPAD_ENTER:
-                if (textField.mAutoCompletePanel.isShow())
+                if (textField.mAutoCompletePanel.isShow()) {
                     textField.mAutoCompletePanel.select(0);
-                else
-                    return super.sendKeyEvent(event);
-                break;
+					break;
+				}
             default:
                 return super.sendKeyEvent(event);
         }
@@ -135,7 +133,6 @@ public class TextFieldInputConnection extends BaseInputConnection {
             tf.moveCaret(mCaretPosition - text.length() - newCursorPosition);
 		if (sel)
 			tf.determineSpans();
-			//tc
         // log("setComposingText:"+text+","+newCursorPosition);
         return true;
     }
@@ -163,7 +160,7 @@ public class TextFieldInputConnection extends BaseInputConnection {
             isComposing = false;
             return true;
 
-              */
+         */
         return setComposingText(text, newCursorPosition) && finishComposingText();
     }
 
@@ -193,7 +190,7 @@ public class TextFieldInputConnection extends BaseInputConnection {
         if ((reqModes & InputType.TYPE_TEXT_FLAG_CAP_WORDS)
                 == InputType.TYPE_TEXT_FLAG_CAP_WORDS) {
             int prevChar = mCaretPosition - 1;
-            if (prevChar < 0 || Lexer.getLanguage().isWhitespace(textField.hDoc.charAt(prevChar))) {
+            if (prevChar < 0 || Tokenizer.getLanguage().isWhitespace(textField.hDoc.charAt(prevChar))) {
                 capsMode |= InputType.TYPE_TEXT_FLAG_CAP_WORDS;
 
                 //set CAP_SENTENCES if client is interested in it
@@ -208,7 +205,7 @@ public class TextFieldInputConnection extends BaseInputConnection {
         // Android bug? Therefore, we assume TYPE_TEXT_FLAG_CAP_SENTENCES
         // is always set to be on the safe side.
         else {
-            Language lang = Lexer.getLanguage();
+            Language lang = Tokenizer.getLanguage();
 
             int prevChar = mCaretPosition - 1;
             int whitespaceCount = 0;
diff --git a/codeeditor/src/main/java/cn/rbc/codeeditor/view/TouchNavigationMethod.java b/codeeditor/src/main/java/cn/rbc/codeeditor/view/TouchNavigationMethod.java
index dc86a42..0931ffa 100644
--- a/codeeditor/src/main/java/cn/rbc/codeeditor/view/TouchNavigationMethod.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/view/TouchNavigationMethod.java
@@ -11,6 +11,7 @@ import cn.rbc.codeeditor.util.*;
 import java.util.*;
 import android.widget.*;
 import android.util.*;
+import android.content.*;
 
 //TODO minimise unnecessary invalidate calls
 
@@ -303,7 +304,7 @@ public class TouchNavigationMethod extends GestureDetector.SimpleOnGestureListen
                 for (end = charOffset; Character.isJavaIdentifierPart(doc.charAt(end)); end++);
                 mTextField.selectText(true);
                 mTextField.setSelectionRange(start, end - start);
-				// err msg
+				// toast err msg
 				List<ErrSpan> dg = mTextField.hDoc.getDiag();
 				if (!(dg == null || dg.isEmpty())) {
 					y = dg.size() - 1;
@@ -312,18 +313,32 @@ public class TouchNavigationMethod extends GestureDetector.SimpleOnGestureListen
 					start -= x;
 					end -= x;
 					x = 0;
-					ErrSpan es;
+					ErrSpan errspan;
 					while (x < y) {
 						m = (x + y) >> 1;
-						es = dg.get(m);
-						if (es.stl > line || (es.stl == line && es.enc >= start))
+						errspan = dg.get(m);
+						if (errspan.enl > line || errspan.enl == line && errspan.enc >= start)
 							y = m;
 						else
 							x = m + 1;
 					}
-					es = dg.get(y);
-					if (es.stl == line && start <= es.enc && es.stc <= end && es.msg != null) {
-						HelperUtils.show(Toast.makeText(mTextField.getContext(), es.msg, Toast.LENGTH_SHORT));
+					errspan = dg.get(y);
+					if ((errspan.stl < line || errspan.stl==line && errspan.stc<=end)
+						&& (line < errspan.enl || line==errspan.enl && start<=errspan.enc)
+						&& errspan.msg != null) {
+						Context ctx = mTextField.getContext();
+						Toast t = new Toast(ctx);
+						//.makeText(mTextField.getContext(), errspan.msg, Toast.LENGTH_SHORT);
+						LinearLayout ll = new LinearLayout(ctx);
+						ll.setOrientation(LinearLayout.VERTICAL);
+						TextView tv = new TextView(ctx);
+						tv.setTextColor(0xffffffff);
+						tv.setText(errspan.msg);
+						ll.setPadding(40,40,40,40);
+						ll.setBackgroundColor(ColorScheme.DIAG[errspan.severity]&0xf0ffffff);
+						ll.addView(tv);
+						t.setView(ll);
+						HelperUtils.show(t);
 					}
 				}
             }
diff --git a/codeeditor/src/main/java/cn/rbc/codeeditor/view/autocomplete/AutoCompletePanel.java b/codeeditor/src/main/java/cn/rbc/codeeditor/view/autocomplete/AutoCompletePanel.java
index db64dc2..849f4a5 100644
--- a/codeeditor/src/main/java/cn/rbc/codeeditor/view/autocomplete/AutoCompletePanel.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/view/autocomplete/AutoCompletePanel.java
@@ -24,7 +24,7 @@ import android.util.*;
 import cn.rbc.codeeditor.util.*;
 
 
-public class AutoCompletePanel {
+public class AutoCompletePanel implements OnItemClickListener {
 
     public static Language _globalLanguage = LanguageNonProg.getInstance();
    // public CharSequence _constraint;
@@ -76,7 +76,6 @@ public class AutoCompletePanel {
     @SuppressWarnings("ResourceType")
     private void initAutoCompletePanel() {
         _autoCompletePanel = new ListPopupWindow(_context);
-		_autoCompletePanel.setInputMethodMode(PopupWindow.INPUT_METHOD_NEEDED);
         _autoCompletePanel.setAnchorView(_textField);
         _adapter = new AutoPanelAdapter(_context, this, _textField);
         _autoCompletePanel.setAdapter(_adapter);
@@ -98,13 +97,13 @@ public class AutoCompletePanel {
         gd.setStroke(1, textColor);
         setTextColor(textColor);
         _autoCompletePanel.setBackgroundDrawable(gd);
-        _autoCompletePanel.setOnItemClickListener(new OnItemClickListener() {
-            public void onItemClick(AdapterView<?> p1, View p2, int p3, long p4) {
-                select(p3);
-            }
-        });
+        _autoCompletePanel.setOnItemClickListener(this);
     }
 
+	public void onItemClick(AdapterView<?> p1, View p2, int p3, long p4) {
+		select(p3);
+	}
+
     public void select(int pos) {
 		Deque<Edit> edits = _adapter.getItem(pos).edits;
 		Document doc = _textField.getText();
@@ -169,16 +168,19 @@ public class AutoCompletePanel {
         _filter.filter(constraint);
     }
 
-	public void update(@NonNull ArrayList<ListItem> l) {
-		_adapter.setData(l);
-		//_autoCompletePanel.set
-		int y = _textField.getCaretY() + _textField.rowHeight() / 2 - _textField.getScrollY();
-		setHeight(_adapter.getItemHeight() * Math.min(3, l.size()));
-		setHorizontalOffset(AutoPanelAdapter.PADDING);
-		setWidth(_textField.getWidth() - AutoPanelAdapter.PADDING * 2);
-		setVerticalOffset(y - _textField.getHeight());//_textField.getCaretY()-_textField.getScrollY()-_textField.getHeight());
-		_adapter.notifyDataSetChanged();
-		show();
+	public void update(ArrayList<ListItem> l) {
+		if (l==null || l.isEmpty()) {
+			_adapter.notifyDataSetInvalidated();
+		} else {
+			_adapter.setData(l);
+			int y = _textField.getCaretY() + _textField.rowHeight() / 2 - _textField.getScrollY();
+			setHeight(_adapter.getItemHeight() * Math.min(3, l.size()));
+			setHorizontalOffset(AutoPanelAdapter.PADDING);
+			setWidth(_textField.getWidth() - AutoPanelAdapter.PADDING * 2);
+			setVerticalOffset(y - _textField.getHeight());//_textField.getCaretY()-_textField.getScrollY()-_textField.getHeight());
+			_adapter.notifyDataSetChanged();
+			show();
+		}
 	}
 
 	public Bitmap getBitmap() {
@@ -189,15 +191,16 @@ public class AutoCompletePanel {
         if (!isShow()) {
 			_autoCompletePanel.show();
         }
-		//_autoCompletePanel.getListView();.setFadingEdgeLength(0);
-        isShow = true;
+		//_autoCompletePanel.getListView().setFadingEdgeLength(0);
+		isShow = true;
     }
 
     public void dismiss() {
         if (isShow()) {
-            isShow = false;
 			_autoCompletePanel.dismiss();
         }
+		isShow = false;
+		//HelperUtils.show(Toast.makeText(_textField.getContext(), String.valueOf(isShow), 1));
     }
 
     public boolean isShow() {
diff --git a/codeeditor/src/main/java/cn/rbc/codeeditor/view/autocomplete/AutoPanelAdapter.java b/codeeditor/src/main/java/cn/rbc/codeeditor/view/autocomplete/AutoPanelAdapter.java
index fd7e954..e8114e9 100644
--- a/codeeditor/src/main/java/cn/rbc/codeeditor/view/autocomplete/AutoPanelAdapter.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/view/autocomplete/AutoPanelAdapter.java
@@ -141,7 +141,8 @@ public class AutoPanelAdapter extends BaseAdapter  {
     }
 
 	public void setData(@NonNull ArrayList<ListItem> l) {
-		listItems = l;
+		listItems.clear();
+		listItems.addAll(l);
 	}
     /**
      * 计算列表高
