diff --git a/app/src/main/java/com/github/yeriomin/dumbphoneassistant/Contact.java b/app/src/main/java/com/github/yeriomin/dumbphoneassistant/Contact.java
index eb64eda..bd3dde2 100644
--- a/app/src/main/java/com/github/yeriomin/dumbphoneassistant/Contact.java
+++ b/app/src/main/java/com/github/yeriomin/dumbphoneassistant/Contact.java
@@ -1,181 +1,181 @@
-package com.github.yeriomin.dumbphoneassistant;
-
-import java.io.UnsupportedEncodingException;
-
-public class Contact {
-
-    private String id = null;
-    private String name;
-    private String number;
-
-    public String getId() {
-        return id;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public String getNumber() {
-        return number;
-    }
-
-    public void setId(String id) {
-        this.id = id;
-    }
-
-    protected Contact(String id, String name, String number) {
-        this.id = id;
-        this.name = name;
-        this.number = number;
-    }
-
-    /**
-     * Null-safe string compare
-     */
-    private boolean compareStrings(final String one, final String two) {
-        if (one == null ^ two == null) {
-            return false;
-        }
-        if (one == null && two == null) {
-            return true;
-        }
-        return one.compareTo(two) == 0;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        // if not Contact, can't be true
-        if(!(o instanceof Contact)) 
-            return false;
-        Contact c = (Contact)o;
-        
-        // only if id's present, compare them
-        if((id != null) && (id.length()) > 0 && (c.id.length() > 0))
-            return c.id.compareTo(id) == 0;
-        
-        // if SimNames not equal...
-        if(!compareStrings(name, c.name)) {
-            return false;
-        }
-
-        // finally if numbers not equal...
-        return compareStrings(number, c.number);
-    }
-
-    public static byte[] getSimCompatibleByteArray(String src) {
-        byte[] dest = null;
-        try {
-            byte[] srcByte = src.getBytes("UTF-16BE");
-            dest = ucs2ToAlphaField(srcByte, 0, srcByte.length, 0, dest);
-            System.out.println("Before conversion: ");
-            System.out.println("String: " + src);
-            System.out.print("Bytes : ");
-            for (int i = 0; i < srcByte.length; i++) {
-                System.out.print(Integer.toHexString(srcByte[i] & 0xFF) + " ");
-            }
-            System.out.println();
-            System.out.println("After conversion:");
-            System.out.println("String: " + String.valueOf(dest));
-            System.out.print("Bytes : ");
-            for (int i = 0; i < dest.length; i++) {
-                System.out.print(Integer.toHexString(dest[i] & 0xFF) + " ");
-            }
-            System.out.println();
-        } catch (UnsupportedEncodingException e) {
-            e.printStackTrace();
-        }
-        return dest;
-    }
-
-    /**
-     * The function will give priority to 81 and 82 using the format code, if you do not meet the encoding condition, choose 80 format code
-     *
-     * @param src source UCS2 byte array
-     * @param srcOff source array of bytes starting position
-     * @param srcLen source byte array length
-     * @param destOff The starting position of the target array destOff
-     * @return The target array
-     */
-    private static byte[] ucs2ToAlphaField(byte[] src, int srcOff, int srcLen, int destOff, byte dest[]) {
-        int i;
-        int min = 0x7FFF;
-        int max = 0;
-        int temp;
-        int outOff;
-        // When the source array length is greater than 2 to 81 or 82 formats
-        if (srcLen > 2) {
-            // The minimum and maximum values of the source array
-            for (i = 0; i < srcLen; i += 2) {
-                //Each character is first bytes is not 0
-                if (src[srcOff + i] != 0) {
-                    temp = ((src[srcOff + i] << 8) & 0xFF00) | (src[srcOff
-                            + i + 1] & 0xFF);
-                    // Because in the 81 format base left 7 after highs to fill 0, so FFFF cannot use 8000 to 81
-                    if (temp < 0) {
-                        max = min + 130;
-                        break;
-                    }
-                    if (min > temp) {
-                        min = temp;
-                    }
-                    if (max < temp) {
-                        max = temp;
-                    }
-                }
-            }
-        }
-        // If all the characters in the UCS code in a continuous range of 128, then the first bytes are the same
-        if ((max - min) < 129) {
-            // If the fifteenth bit to eighth bit the same, you can use 81 format code
-            if ((byte) (min & 0x80) == (byte) (max & 0x80)) {
-                // Figure 81 the length of the target array format, initialization
-                dest = new byte[srcLen / 2 + 3];
-                // Setting the target array of second byte length
-                dest[destOff + 1] = (byte) (srcLen / 2);
-                // Set the first byte is 81
-                dest[destOff] = (byte) 0x81;
-                // The base is fifteenth to eighth,
-                min = min & 0x7F80;
-                dest[destOff + 2] = (byte) ((min >> 7) & 0xFF);
-                outOff = destOff + 3;
-            }
-            // Eighth bytes are not the same (a 0, a 1), then use the 82 format
-            else {
-                // Figure 82 the length of the target array format, initialization
-                dest = new byte[srcLen / 2 + 4];
-                // Setting the target array of second byte length
-                dest[destOff + 1] = (byte) (srcLen / 2);
-                // Set the first byte is 82
-                dest[destOff] = (byte) 0x82;
-                // The base for the source array minimum value (first bytes to 0 except)
-                dest[destOff + 2] = (byte) ((min >> 8) & 0xFF);
-                dest[destOff + 3] = (byte) (min & 0xFF);
-                outOff = destOff + 4;
-            }
-
-            for (i = 0; i < srcLen; i += 2) {
-                // If the first byte is 0, then 7 to 1, the highest for 0
-                if (src[srcOff + i] == 0) {
-                    dest[outOff] = (byte) (src[srcOff + i + 1] & 0x7F);
-                }
-                // If the first byte is not 0, using the UCS code is subtracted from the base, the high fill 1
-                else {
-                    temp = (((src[srcOff + i] << 8) & 0xFF00) | (src[srcOff
-                            + i + 1] & 0xFF)) - min;
-                    dest[outOff] = (byte) (temp | 0x80);
-                }
-                outOff++;
-            }
-            // Returns the target array
-            return dest;
-        }
-
-        // Do not meet the 81 and the 82 format, using 80 format code
-        dest = new byte[srcLen + 1];
-        dest[destOff] = (byte) 0x80;
-        System.arraycopy(src, 0, dest, 1, srcLen);
-        // Returns a 80 format object array
-        return dest;
-    }
+package com.github.yeriomin.dumbphoneassistant;
+
+import java.io.UnsupportedEncodingException;
+
+public class Contact {
+
+    private String id = null;
+    private String name;
+    private String number;
+
+    public String getId() {
+        return id;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public String getNumber() {
+        return number;
+    }
+
+    public void setId(String id) {
+        this.id = id;
+    }
+
+    protected Contact(String id, String name, String number) {
+        this.id = id;
+        this.name = name;
+        this.number = number;
+    }
+
+    /**
+     * Null-safe string compare
+     */
+    private boolean compareStrings(final String one, final String two) {
+        if (one == null ^ two == null) {
+            return false;
+        }
+        if (one == null && two == null) {
+            return true;
+        }
+        return one.compareTo(two) == 0;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        // if not Contact, can't be true
+        if(!(o instanceof Contact)) 
+            return false;
+        Contact c = (Contact)o;
+        
+        // only if id's present, compare them
+        if((id != null) && (id.length()) > 0 && (c.id.length() > 0))
+            return c.id.compareTo(id) == 0;
+        
+        // if SimNames not equal...
+        if(!compareStrings(name, c.name)) {
+            return false;
+        }
+
+        // finally if numbers not equal...
+        return compareStrings(number, c.number);
+    }
+
+    public static byte[] getSimCompatibleByteArray(String src) {
+        byte[] dest = null;
+        try {
+            byte[] srcByte = src.getBytes("UTF-16BE");
+            dest = ucs2ToAlphaField(srcByte, 0, srcByte.length, 0, dest);
+            System.out.println("Before conversion: ");
+            System.out.println("String: " + src);
+            System.out.print("Bytes : ");
+            for (int i = 0; i < srcByte.length; i++) {
+                System.out.print(Integer.toHexString(srcByte[i] & 0xFF) + " ");
+            }
+            System.out.println();
+            System.out.println("After conversion:");
+            System.out.println("String: " + String.valueOf(dest));
+            System.out.print("Bytes : ");
+            for (int i = 0; i < dest.length; i++) {
+                System.out.print(Integer.toHexString(dest[i] & 0xFF) + " ");
+            }
+            System.out.println();
+        } catch (UnsupportedEncodingException e) {
+            e.printStackTrace();
+        }
+        return dest;
+    }
+
+    /**
+     * The function will give priority to 81 and 82 using the format code, if you do not meet the encoding condition, choose 80 format code
+     *
+     * @param src source UCS2 byte array
+     * @param srcOff source array of bytes starting position
+     * @param srcLen source byte array length
+     * @param destOff The starting position of the target array destOff
+     * @return The target array
+     */
+    private static byte[] ucs2ToAlphaField(byte[] src, int srcOff, int srcLen, int destOff, byte dest[]) {
+        int i;
+        int min = 0x7FFF;
+        int max = 0;
+        int temp;
+        int outOff;
+        // When the source array length is greater than 2 to 81 or 82 formats
+        if (srcLen > 2) {
+            // The minimum and maximum values of the source array
+            for (i = 0; i < srcLen; i += 2) {
+                //Each character is first bytes is not 0
+                if (src[srcOff + i] != 0) {
+                    temp = ((src[srcOff + i] << 8) & 0xFF00) | (src[srcOff
+                            + i + 1] & 0xFF);
+                    // Because in the 81 format base left 7 after highs to fill 0, so FFFF cannot use 8000 to 81
+                    if (temp < 0) {
+                        max = min + 130;
+                        break;
+                    }
+                    if (min > temp) {
+                        min = temp;
+                    }
+                    if (max < temp) {
+                        max = temp;
+                    }
+                }
+            }
+        }
+        // If all the characters in the UCS code in a continuous range of 128, then the first bytes are the same
+        if ((max - min) < 129) {
+            // If the fifteenth bit to eighth bit the same, you can use 81 format code
+            if ((byte) (min & 0x80) == (byte) (max & 0x80)) {
+                // Figure 81 the length of the target array format, initialization
+                dest = new byte[srcLen / 2 + 3];
+                // Setting the target array of second byte length
+                dest[destOff + 1] = (byte) (srcLen / 2);
+                // Set the first byte is 81
+                dest[destOff] = (byte) 0x81;
+                // The base is fifteenth to eighth,
+                min = min & 0x7F80;
+                dest[destOff + 2] = (byte) ((min >> 7) & 0xFF);
+                outOff = destOff + 3;
+            }
+            // Eighth bytes are not the same (a 0, a 1), then use the 82 format
+            else {
+                // Figure 82 the length of the target array format, initialization
+                dest = new byte[srcLen / 2 + 4];
+                // Setting the target array of second byte length
+                dest[destOff + 1] = (byte) (srcLen / 2);
+                // Set the first byte is 82
+                dest[destOff] = (byte) 0x82;
+                // The base for the source array minimum value (first bytes to 0 except)
+                dest[destOff + 2] = (byte) ((min >> 8) & 0xFF);
+                dest[destOff + 3] = (byte) (min & 0xFF);
+                outOff = destOff + 4;
+            }
+
+            for (i = 0; i < srcLen; i += 2) {
+                // If the first byte is 0, then 7 to 1, the highest for 0
+                if (src[srcOff + i] == 0) {
+                    dest[outOff] = (byte) (src[srcOff + i + 1] & 0x7F);
+                }
+                // If the first byte is not 0, using the UCS code is subtracted from the base, the high fill 1
+                else {
+                    temp = (((src[srcOff + i] << 8) & 0xFF00) | (src[srcOff
+                            + i + 1] & 0xFF)) - min;
+                    dest[outOff] = (byte) (temp | 0x80);
+                }
+                outOff++;
+            }
+            // Returns the target array
+            return dest;
+        }
+
+        // Do not meet the 81 and the 82 format, using 80 format code
+        dest = new byte[srcLen + 1];
+        dest[destOff] = (byte) 0x80;
+        System.arraycopy(src, 0, dest, 1, srcLen);
+        // Returns a 80 format object array
+        return dest;
+    }
 }
\ No newline at end of file
diff --git a/app/src/main/java/com/github/yeriomin/dumbphoneassistant/ManageContactsActivity.java b/app/src/main/java/com/github/yeriomin/dumbphoneassistant/ManageContactsActivity.java
index d919284..e50998f 100644
--- a/app/src/main/java/com/github/yeriomin/dumbphoneassistant/ManageContactsActivity.java
+++ b/app/src/main/java/com/github/yeriomin/dumbphoneassistant/ManageContactsActivity.java
@@ -1,6 +1,7 @@
 package com.github.yeriomin.dumbphoneassistant;
 
 import android.Manifest;
+import android.annotation.TargetApi;
 import android.app.AlertDialog;
 import android.app.ProgressDialog;
 import android.app.TabActivity;
@@ -36,22 +37,20 @@ public class ManageContactsActivity extends TabActivity {
     private SimUtil simUtil;
     private PhoneUtil phoneUtil;
     private ProgressDialog progressDialog;
+    private PermissionManager permissionManager;
 
     private final int EDIT_REQUEST_CODE = 42; // Any number
 
-    final private int REQUEST_CODE_ASK_MULTIPLE_PERMISSIONS = 125;
-    final private String[] permissionsRequired = new String[] {
-            Manifest.permission.READ_PHONE_STATE,
-            Manifest.permission.WRITE_CONTACTS,
-            Manifest.permission.READ_CONTACTS
-    };
-    private ArrayList<String> permissionsGranted = new ArrayList<String>();
-
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
 
-        if (permissionsGranted()) {
+        boolean permissionsGranted = true;
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+            permissionManager = new PermissionManager(this);
+            permissionsGranted = permissionManager.permissionsGranted();
+        }
+        if (permissionsGranted) {
             initListViews();
         }
     }
@@ -481,47 +480,10 @@ public class ManageContactsActivity extends TabActivity {
         }
     }
 
-    private boolean permissionsGranted() {
-        boolean granted = true;
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-            ArrayList<String> permissionsNotGranted = new ArrayList<String>();
-            for (int i = 0; i < this.permissionsRequired.length; i++) {
-                if (checkSelfPermission(this.permissionsRequired[i]) != PackageManager.PERMISSION_GRANTED) {
-                    permissionsNotGranted.add(this.permissionsRequired[i]);
-                } else {
-                    this.permissionsGranted.add(this.permissionsRequired[i]);
-                }
-            }
-            if (permissionsNotGranted.size() > 0) {
-                granted = false;
-                String[] notGrantedArray = permissionsNotGranted.toArray(new String[permissionsNotGranted.size()]);
-                requestPermissions(notGrantedArray, REQUEST_CODE_ASK_MULTIPLE_PERMISSIONS);
-            }
-        }
-        return granted;
-    }
-
     @Override
     public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
-        switch (requestCode) {
-            case REQUEST_CODE_ASK_MULTIPLE_PERMISSIONS:
-            {
-                List<String> requiredPermissions = Arrays.asList(this.permissionsRequired);
-                String permission;
-                for (int i = 0; i < permissions.length; i++) {
-                    permission = permissions[i];
-                    if (requiredPermissions.contains(permission)
-                            && grantResults[i] == PackageManager.PERMISSION_GRANTED) {
-                        this.permissionsGranted.add(permission);
-                    }
-                }
-                if (this.permissionsGranted.size() == this.permissionsRequired.length) {
-                    initListViews();
-                }
-            }
-            break;
-            default:
-                super.onRequestPermissionsResult(requestCode, permissions, grantResults);
+        if (permissionManager.onRequestPermissionsResult(requestCode, permissions, grantResults)) {
+            initListViews();
         }
     }
 }
\ No newline at end of file
diff --git a/app/src/main/java/com/github/yeriomin/dumbphoneassistant/PermissionManager.java b/app/src/main/java/com/github/yeriomin/dumbphoneassistant/PermissionManager.java
new file mode 100644
index 0000000..29307a8
--- /dev/null
+++ b/app/src/main/java/com/github/yeriomin/dumbphoneassistant/PermissionManager.java
@@ -0,0 +1,60 @@
+package com.github.yeriomin.dumbphoneassistant;
+
+import android.Manifest;
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.content.pm.PackageManager;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+@TargetApi(23)
+public class PermissionManager {
+
+    public final static int REQUEST_CODE_ASK_MULTIPLE_PERMISSIONS = 125; // Any number
+    private final String[] permissionsRequired = new String[] {
+            Manifest.permission.READ_PHONE_STATE,
+            Manifest.permission.WRITE_CONTACTS,
+            Manifest.permission.READ_CONTACTS
+    };
+    private ArrayList<String> permissionsGranted = new ArrayList<String>();
+    private Activity activity;
+
+    PermissionManager(Activity activity) {
+        this.activity = activity;
+    }
+
+    public boolean permissionsGranted() {
+        boolean granted = true;
+        ArrayList<String> permissionsNotGranted = new ArrayList<String>();
+        for (int i = 0; i < this.permissionsRequired.length; i++) {
+            if (activity.checkSelfPermission(this.permissionsRequired[i]) != PackageManager.PERMISSION_GRANTED) {
+                permissionsNotGranted.add(this.permissionsRequired[i]);
+            } else {
+                this.permissionsGranted.add(this.permissionsRequired[i]);
+            }
+        }
+        if (permissionsNotGranted.size() > 0) {
+            granted = false;
+            String[] notGrantedArray = permissionsNotGranted.toArray(new String[permissionsNotGranted.size()]);
+            activity.requestPermissions(notGrantedArray, REQUEST_CODE_ASK_MULTIPLE_PERMISSIONS);
+        }
+        return granted;
+    }
+
+    public boolean onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
+        boolean granted = false;
+        List<String> requiredPermissions = Arrays.asList(this.permissionsRequired);
+        for (int i = 0; i < permissions.length; i++) {
+            if (requiredPermissions.contains(permissions[i])
+                    && grantResults[i] == PackageManager.PERMISSION_GRANTED) {
+                this.permissionsGranted.add(permissions[i]);
+            }
+        }
+        if (this.permissionsGranted.size() == this.permissionsRequired.length) {
+            granted = true;
+        }
+        return granted;
+    }
+}
diff --git a/app/src/main/java/com/github/yeriomin/dumbphoneassistant/PhoneUtil.java b/app/src/main/java/com/github/yeriomin/dumbphoneassistant/PhoneUtil.java
index 14b8c56..e8b3130 100644
--- a/app/src/main/java/com/github/yeriomin/dumbphoneassistant/PhoneUtil.java
+++ b/app/src/main/java/com/github/yeriomin/dumbphoneassistant/PhoneUtil.java
@@ -1,22 +1,22 @@
-package com.github.yeriomin.dumbphoneassistant;
-
-import android.app.Activity;
-import android.net.Uri;
-
-public abstract class PhoneUtil extends Util {
-
-    public PhoneUtil(Activity activity) {
-        super(activity);
-    }
-    
-    /**
-     * Retrieves the Uri to the contact using the Contacts.Phones path. If the given Contact contains an ID it will be
-     * assumed that it's an ID from the Contacts.Phones path and used. If no ID is present, the name and number is used
-     * to resolve the first matching contact. 
-     * 
-     * @param contact The contact containing the required information to be able to resolve the Uri
-     * @return the Uri of the found contact or null if none found 
-     */
-    public abstract Uri retrieveContactUri(Contact contact);
-
+package com.github.yeriomin.dumbphoneassistant;
+
+import android.app.Activity;
+import android.net.Uri;
+
+public abstract class PhoneUtil extends Util {
+
+    public PhoneUtil(Activity activity) {
+        super(activity);
+    }
+    
+    /**
+     * Retrieves the Uri to the contact using the Contacts.Phones path. If the given Contact contains an ID it will be
+     * assumed that it's an ID from the Contacts.Phones path and used. If no ID is present, the name and number is used
+     * to resolve the first matching contact. 
+     * 
+     * @param contact The contact containing the required information to be able to resolve the Uri
+     * @return the Uri of the found contact or null if none found 
+     */
+    public abstract Uri retrieveContactUri(Contact contact);
+
 }
\ No newline at end of file
diff --git a/app/src/main/java/com/github/yeriomin/dumbphoneassistant/PhoneUtilDonut.java b/app/src/main/java/com/github/yeriomin/dumbphoneassistant/PhoneUtilDonut.java
index 3a08d8c..82b936b 100644
--- a/app/src/main/java/com/github/yeriomin/dumbphoneassistant/PhoneUtilDonut.java
+++ b/app/src/main/java/com/github/yeriomin/dumbphoneassistant/PhoneUtilDonut.java
@@ -1,109 +1,101 @@
-package com.github.yeriomin.dumbphoneassistant;
-
-import android.annotation.SuppressLint;
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.content.ContentUris;
-import android.content.ContentValues;
-import android.database.Cursor;
-import android.net.Uri;
-import android.provider.Contacts;
-import android.provider.Contacts.People;
-
-import java.util.ArrayList;
-
-public class PhoneUtilDonut extends PhoneUtil {
-
-    public PhoneUtilDonut(Activity activity) {
-        super(activity);
-    }
-
-    @TargetApi(4)
-    @SuppressLint("NewApi")
-    public ArrayList<Contact> get() {
-        final String[] phoneProjection = new String[]{
-                People.NAME,
-                People.NUMBER,
-                People._ID
-        };
-
-        Cursor results = resolver.query(
-                People.CONTENT_URI,
-                phoneProjection,
-                null,
-                null,
-                People.NAME
-        );
-
-        // create array of Phone contacts and fill it
-        final ArrayList<Contact> phoneContacts = new ArrayList<Contact>();
-        if (null != results) {
-            while (results.moveToNext()) {
-                final Contact phoneContact = new Contact(
-                        results.getString(results.getColumnIndex(People._ID)),
-                        results.getString(results.getColumnIndex(People.NAME)),
-                        results.getString(results.getColumnIndex(People.NUMBER))
-                );
-                phoneContacts.add(phoneContact);
-            }
-            results.close();
-        }
-        return phoneContacts;
-    }
-
-    @TargetApi(4)
-    @SuppressLint("NewApi")
-    public boolean create(Contact newPhoneContact) throws Exception {
-        // first, we have to create the contact
-        ContentValues newPhoneValues = new ContentValues();
-        newPhoneValues.put(Contacts.People.NAME, newPhoneContact.getName());
-        Uri newPhoneRow = resolver.insert(Contacts.People.CONTENT_URI, newPhoneValues);
-
-        // then we have to add a number
-        newPhoneValues.clear();
-        newPhoneValues.put(Contacts.People.Phones.TYPE, Contacts.People.Phones.TYPE_MOBILE);
-        newPhoneValues.put(Contacts.Phones.NUMBER, newPhoneContact.getNumber());
-        // insert the new phone number in the database using the returned uri from creating the contact
-        newPhoneRow = resolver.insert(Uri.withAppendedPath(newPhoneRow, Contacts.People.Phones.CONTENT_DIRECTORY), newPhoneValues);
-
-        // if contacts uri returned, there was an error with adding the number
-        if (newPhoneRow.getPath().contains("people")) {
-            throw new Exception(String.valueOf(R.string.error_phone_number_not_stored));
-        }
-
-        // if phone uri returned, everything went OK
-        if (!newPhoneRow.getPath().contains("phones")) {
-            // some unknown error has happened
-            throw new Exception(String.valueOf(R.string.error_phone_number_error));
-        }
-
-        return true;
-    }
-
-
-    @TargetApi(4)
-    @SuppressLint("NewApi")
-    public Uri retrieveContactUri(Contact contact) {
-        String id = contact.getId();
-        String[] projection = new String[] { Contacts.Phones.PERSON_ID };
-        String path = null;
-        Cursor result;
-        if (null != id) {
-            Uri uri = ContentUris.withAppendedId(Contacts.Phones.CONTENT_URI, Long.valueOf(id));
-            result = resolver.query(uri, projection, null, null, null);
-        } else {
-            String selection = "name='?' AND number='?'";
-            String[] selectionArgs = new String[] { contact.getName(), contact.getNumber() };
-            result = resolver.query(Contacts.Phones.CONTENT_URI, projection, selection, selectionArgs, null);
-        }
-        if (null != result) {
-            result.moveToNext();
-            path = result.getString(0);
-            result.close();
-        }
-        if (null == path) {
-            return null;
-        }
-        return Uri.withAppendedPath(Contacts.People.CONTENT_URI, path);
-    }
-}
+package com.github.yeriomin.dumbphoneassistant;
+
+import android.app.Activity;
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.net.Uri;
+import android.provider.Contacts;
+import android.provider.Contacts.People;
+
+import java.util.ArrayList;
+
+public class PhoneUtilDonut extends PhoneUtil {
+
+    public PhoneUtilDonut(Activity activity) {
+        super(activity);
+    }
+
+    public ArrayList<Contact> get() {
+        final String[] phoneProjection = new String[]{
+                People.NAME,
+                People.NUMBER,
+                People._ID
+        };
+
+        Cursor results = resolver.query(
+                People.CONTENT_URI,
+                phoneProjection,
+                null,
+                null,
+                People.NAME
+        );
+
+        // create array of Phone contacts and fill it
+        final ArrayList<Contact> phoneContacts = new ArrayList<Contact>();
+        if (null != results) {
+            while (results.moveToNext()) {
+                final Contact phoneContact = new Contact(
+                        results.getString(results.getColumnIndex(People._ID)),
+                        results.getString(results.getColumnIndex(People.NAME)),
+                        results.getString(results.getColumnIndex(People.NUMBER))
+                );
+                phoneContacts.add(phoneContact);
+            }
+            results.close();
+        }
+        return phoneContacts;
+    }
+
+    public boolean create(Contact newPhoneContact) throws Exception {
+        // first, we have to create the contact
+        ContentValues newPhoneValues = new ContentValues();
+        newPhoneValues.put(Contacts.People.NAME, newPhoneContact.getName());
+        Uri newPhoneRow = resolver.insert(Contacts.People.CONTENT_URI, newPhoneValues);
+
+        // then we have to add a number
+        newPhoneValues.clear();
+        newPhoneValues.put(Contacts.People.Phones.TYPE, Contacts.People.Phones.TYPE_MOBILE);
+        newPhoneValues.put(Contacts.Phones.NUMBER, newPhoneContact.getNumber());
+        // insert the new phone number in the database using the returned uri from creating the contact
+        newPhoneRow = resolver.insert(Uri.withAppendedPath(newPhoneRow, Contacts.People.Phones.CONTENT_DIRECTORY), newPhoneValues);
+
+        // if contacts uri returned, there was an error with adding the number
+        if (newPhoneRow.getPath().contains("people")) {
+            throw new Exception(String.valueOf(R.string.error_phone_number_not_stored));
+        }
+
+        // if phone uri returned, everything went OK
+        if (!newPhoneRow.getPath().contains("phones")) {
+            // some unknown error has happened
+            throw new Exception(String.valueOf(R.string.error_phone_number_error));
+        }
+
+        return true;
+    }
+
+
+    public Uri retrieveContactUri(Contact contact) {
+        String id = contact.getId();
+        String[] projection = new String[] { Contacts.Phones.PERSON_ID };
+        String path = null;
+        Cursor result;
+        if (null != id) {
+            Uri uri = ContentUris.withAppendedId(Contacts.Phones.CONTENT_URI, Long.valueOf(id));
+            result = resolver.query(uri, projection, null, null, null);
+        } else {
+            String selection = "name='?' AND number='?'";
+            String[] selectionArgs = new String[] { contact.getName(), contact.getNumber() };
+            result = resolver.query(Contacts.Phones.CONTENT_URI, projection, selection, selectionArgs, null);
+        }
+        if (null != result) {
+            result.moveToNext();
+            path = result.getString(0);
+            result.close();
+        }
+        if (null == path) {
+            return null;
+        }
+        return Uri.withAppendedPath(Contacts.People.CONTENT_URI, path);
+    }
+}
diff --git a/app/src/main/java/com/github/yeriomin/dumbphoneassistant/PhoneUtilEclair.java b/app/src/main/java/com/github/yeriomin/dumbphoneassistant/PhoneUtilEclair.java
index 557b855..d1f5b32 100644
--- a/app/src/main/java/com/github/yeriomin/dumbphoneassistant/PhoneUtilEclair.java
+++ b/app/src/main/java/com/github/yeriomin/dumbphoneassistant/PhoneUtilEclair.java
@@ -1,135 +1,137 @@
-package com.github.yeriomin.dumbphoneassistant;
-
-import android.app.Activity;
-import android.content.ContentProviderOperation;
-import android.content.ContentProviderResult;
-import android.database.Cursor;
-import android.net.Uri;
-import android.provider.ContactsContract;
-import android.provider.ContactsContract.PhoneLookup;
-
-import java.util.ArrayList;
-
-/**
- * @TargetApi(5)
- */
-public class PhoneUtilEclair extends PhoneUtil {
-
-    public PhoneUtilEclair(Activity activity) {
-        super(activity);
-    }
-
-    public ArrayList<Contact> get() {
-        Uri uri = ContactsContract.CommonDataKinds.Phone.CONTENT_URI;
-        String[] projection = new String[] {
-                PhoneLookup._ID,
-                PhoneLookup.DISPLAY_NAME,
-                ContactsContract.CommonDataKinds.Phone.NUMBER
-        };
-        String selection = null;
-        String[] selectionArgs = null;
-        String sortOrder = ContactsContract.Contacts.DISPLAY_NAME + " COLLATE LOCALIZED ASC";
-
-        Cursor results = resolver.query(
-                uri,
-                projection,
-                selection,
-                selectionArgs,
-                sortOrder
-        );
-
-        // create array of Phone contacts and fill it
-        final ArrayList<Contact> phoneContacts = new ArrayList<Contact>(results.getCount());
-        while (results.moveToNext()) {
-            final Contact phoneContact = new Contact(
-                    results.getString(results.getColumnIndex(PhoneLookup._ID)),
-                    results.getString(results.getColumnIndex(PhoneLookup.DISPLAY_NAME)),
-                    results.getString(results.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER))
-            );
-            phoneContacts.add(phoneContact);
-        }
-        results.close();
-        return phoneContacts;
-    }
-
-    public boolean create(Contact newPhoneContact) throws Exception {
-        ArrayList<ContentProviderOperation> ops = new ArrayList<ContentProviderOperation>();
-        ops.add(ContentProviderOperation
-                .newInsert(ContactsContract.Data.CONTENT_URI)
-                .withValueBackReference(ContactsContract.Data.RAW_CONTACT_ID, 0)
-                .withValue(ContactsContract.Data.MIMETYPE, ContactsContract.CommonDataKinds.StructuredName.CONTENT_ITEM_TYPE)
-                .withValue(ContactsContract.CommonDataKinds.StructuredName.DISPLAY_NAME, newPhoneContact.getName())
-                .build()
-        );
-        ops.add(ContentProviderOperation
-                .newInsert(ContactsContract.Data.CONTENT_URI)
-                .withValueBackReference(ContactsContract.Data.RAW_CONTACT_ID, 0)
-                .withValue(ContactsContract.Data.MIMETYPE, ContactsContract.CommonDataKinds.Phone.CONTENT_ITEM_TYPE)
-                .withValue(ContactsContract.CommonDataKinds.Phone.NUMBER, newPhoneContact.getNumber())
-                .withValue(ContactsContract.CommonDataKinds.Phone.TYPE, ContactsContract.CommonDataKinds.Phone.TYPE_MAIN)
-                .build()
-        );
-
-        ContentProviderResult[] results = resolver.applyBatch(ContactsContract.AUTHORITY, ops);
-
-        Uri uri = results[0].uri;
-        // if contacts uri returned, there was an error with adding the number
-        if (uri.getPath().contains("people")) {
-            throw new Exception(String.valueOf(R.string.error_phone_number_not_stored));
-        }
-        // if phone uri returned, everything went OK
-        if (!uri.getPath().contains("phones")) {
-            // some unknown error has happened
-            throw new Exception(String.valueOf(R.string.error_phone_number_error));
-        }
-        newPhoneContact.setId(uri.getLastPathSegment());
-        return true;
-    }
-
-    public Uri retrieveContactUri(Contact contact) {
-        String lookupKey;
-        Long contactId;
-        Cursor result = null;
-        Uri uri = ContactsContract.CommonDataKinds.Phone.CONTENT_URI;
-        String[] projection = new String[] { ContactsContract.Contacts.LOOKUP_KEY, ContactsContract.RawContacts.CONTACT_ID };
-        String selection;
-
-        // at first try to resolve with contacts id
-        if (contact.getId() != null) {
-            selection = PhoneLookup._ID + "=?";
-            result = resolver.query(uri, projection, selection, new String[] { contact.getId() }, null);
-            // check if unique result
-            if (result.getCount() != 1) {
-                result.close();
-                result = null;
-            }
-        }
-        
-        // if no contact id or no result, try alternate method
-        if (result == null) {
-            selection = ContactsContract.Contacts.DISPLAY_NAME + " = '" + contact.getName()
-                    + "' AND " + ContactsContract.CommonDataKinds.Phone.NUMBER + " = '" + contact.getNumber() + "'"
-            ;
-            result = resolver.query(uri, projection, selection, null, null);
-            // check if unique result
-            if (result.getCount() != 1) {
-                result.close();
-                result = null;
-            }
-        }
-                
-        // check for result
-        if (result == null) {
-            return null;
-        }
-        
-        // get results
-        result.moveToNext();
-        lookupKey = result.getString(0);
-        contactId = result.getLong(1);
-        result.close();
-
-        // create contact URI
-        return ContactsContract.Contacts.getLookupUri(contactId, lookupKey);
-    }
-}
+package com.github.yeriomin.dumbphoneassistant;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.content.ContentProviderOperation;
+import android.content.ContentProviderResult;
+import android.database.Cursor;
+import android.net.Uri;
+import android.provider.ContactsContract;
+import android.provider.ContactsContract.PhoneLookup;
+
+import java.util.ArrayList;
+
+@TargetApi(5)
+public class PhoneUtilEclair extends PhoneUtil {
+
+    public PhoneUtilEclair(Activity activity) {
+        super(activity);
+    }
+
+    public ArrayList<Contact> get() {
+        Uri uri = ContactsContract.CommonDataKinds.Phone.CONTENT_URI;
+        String[] projection = new String[] {
+                PhoneLookup._ID,
+                PhoneLookup.DISPLAY_NAME,
+                ContactsContract.CommonDataKinds.Phone.NUMBER
+        };
+        String selection = null;
+        String[] selectionArgs = null;
+        String sortOrder = ContactsContract.Contacts.DISPLAY_NAME + " COLLATE LOCALIZED ASC";
+
+        Cursor results = resolver.query(
+                uri,
+                projection,
+                selection,
+                selectionArgs,
+                sortOrder
+        );
+
+        // create array of Phone contacts and fill it
+        final ArrayList<Contact> phoneContacts = new ArrayList<Contact>(results.getCount());
+        while (results.moveToNext()) {
+            final Contact phoneContact = new Contact(
+                    results.getString(results.getColumnIndex(PhoneLookup._ID)),
+                    results.getString(results.getColumnIndex(PhoneLookup.DISPLAY_NAME)),
+                    results.getString(results.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER))
+            );
+            phoneContacts.add(phoneContact);
+        }
+        results.close();
+        return phoneContacts;
+    }
+
+    public boolean create(Contact newPhoneContact) throws Exception {
+        ArrayList<ContentProviderOperation> ops = new ArrayList<ContentProviderOperation>();
+        ops.add(ContentProviderOperation
+                .newInsert(ContactsContract.Data.CONTENT_URI)
+                .withValueBackReference(ContactsContract.Data.RAW_CONTACT_ID, 0)
+                .withValue(ContactsContract.Data.MIMETYPE, ContactsContract.CommonDataKinds.StructuredName.CONTENT_ITEM_TYPE)
+                .withValue(ContactsContract.CommonDataKinds.StructuredName.DISPLAY_NAME, newPhoneContact.getName())
+                .build()
+        );
+        ops.add(ContentProviderOperation
+                .newInsert(ContactsContract.Data.CONTENT_URI)
+                .withValueBackReference(ContactsContract.Data.RAW_CONTACT_ID, 0)
+                .withValue(ContactsContract.Data.MIMETYPE, ContactsContract.CommonDataKinds.Phone.CONTENT_ITEM_TYPE)
+                .withValue(ContactsContract.CommonDataKinds.Phone.NUMBER, newPhoneContact.getNumber())
+                .withValue(ContactsContract.CommonDataKinds.Phone.TYPE, ContactsContract.CommonDataKinds.Phone.TYPE_MAIN)
+                .build()
+        );
+
+        ContentProviderResult[] results = resolver.applyBatch(ContactsContract.AUTHORITY, ops);
+
+        Uri uri = results[0].uri;
+        // if contacts uri returned, there was an error with adding the number
+        if (uri.getPath().contains("people")) {
+            throw new Exception(String.valueOf(R.string.error_phone_number_not_stored));
+        }
+        // if phone uri returned, everything went OK
+        if (!uri.getPath().contains("phones")) {
+            // some unknown error has happened
+            throw new Exception(String.valueOf(R.string.error_phone_number_error));
+        }
+        newPhoneContact.setId(uri.getLastPathSegment());
+        return true;
+    }
+
+    public Uri retrieveContactUri(Contact contact) {
+        String lookupKey;
+        Long contactId;
+        Cursor result = null;
+        Uri uri = ContactsContract.CommonDataKinds.Phone.CONTENT_URI;
+        String[] projection = new String[] { ContactsContract.Contacts.LOOKUP_KEY, ContactsContract.RawContacts.CONTACT_ID };
+        String selection;
+        String[] selectionArgs;
+
+        // at first try to resolve with contacts id
+        if (contact.getId() != null) {
+            selection = PhoneLookup._ID + "=?";
+            selectionArgs = new String[] { contact.getId() };
+            result = resolver.query(uri, projection, selection, selectionArgs, null);
+            // check if unique result
+            if (result.getCount() != 1) {
+                result.close();
+                result = null;
+            }
+        }
+        
+        // if no contact id or no result, try alternate method
+        if (result == null) {
+            selection = ContactsContract.Contacts.DISPLAY_NAME + " = '?' AND "
+                    + ContactsContract.CommonDataKinds.Phone.NUMBER + " = '?'"
+            ;
+            selectionArgs = new String[] { contact.getName(), contact.getNumber() };
+            result = resolver.query(uri, projection, selection, selectionArgs, null);
+            // check if unique result
+            if (result.getCount() != 1) {
+                result.close();
+                result = null;
+            }
+        }
+                
+        // check for result
+        if (result == null) {
+            return null;
+        }
+        
+        // get results
+        result.moveToNext();
+        lookupKey = result.getString(0);
+        contactId = result.getLong(1);
+        result.close();
+
+        // create contact URI
+        return ContactsContract.Contacts.getLookupUri(contactId, lookupKey);
+    }
+}
diff --git a/app/src/main/java/com/github/yeriomin/dumbphoneassistant/SimUtil.java b/app/src/main/java/com/github/yeriomin/dumbphoneassistant/SimUtil.java
index fcfb141..098586c 100644
--- a/app/src/main/java/com/github/yeriomin/dumbphoneassistant/SimUtil.java
+++ b/app/src/main/java/com/github/yeriomin/dumbphoneassistant/SimUtil.java
@@ -1,175 +1,176 @@
-package com.github.yeriomin.dumbphoneassistant;
-
-import android.app.Activity;
-import android.content.ContentValues;
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.database.Cursor;
-import android.net.Uri;
-import android.os.Build;
-import android.telephony.TelephonyManager;
-
-import java.util.ArrayList;
-
-public class SimUtil extends Util {
-
-    private final SharedPreferences settings;
-    private final TelephonyManager telephony;
-    private Uri simUri;
-
-    private int maxContactNameLength = 0; // Maximum length of contact names may
-                                          // differ from SIM to SIM, will be
-                                          // detected upon load of class
-
-    public SimUtil(Activity activity) {
-        super(activity);
-
-        this.settings = activity.getSharedPreferences(activity.getApplicationInfo().name, 0);
-        this.telephony = (TelephonyManager) activity.getSystemService(Context.TELEPHONY_SERVICE);
-        this.simUri = Uri.parse(detectSimUri());
-
-        maxContactNameLength = getMaxContactNameLength();
-    }
-
-    /**
-     * Detects the URI identifier for accessing the SIM card. Is different,
-     * depending on Android version.
-     * 
-     * @return Uri of the SIM card on this system
-     */
-    private String detectSimUri() {
-        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.DONUT
-                ? "content://icc/adn"
-                : "content://sim/adn"
-                ;
-    }
-
-    /**
-     * Query SharedPreferences storage for the maximum contact length
-     * If no value is stored, detect it by attempting to write a contact, then store it
-     * The value is stored with current SIM card's id
-     *
-     * @return Length of the longest contact name the SIM card accepts
-     */
-    private int getMaxContactNameLength() {
-        String simId = this.telephony.getSimSerialNumber();
-        int maxContactLength = this.settings.getInt(simId, 0);
-        if (maxContactLength == 0) {
-            maxContactLength = detectMaxContactNameLength();
-        }
-        if (maxContactLength > 0) {
-            this.settings.edit().putInt(simId, maxContactLength);
-        }
-        return maxContactLength;
-    }
-
-    /**
-     * Detects the maximum length of a contacts name which is accepted by the
-     * SIM card by attempting to insert contacts until the SIM card accepts
-     * 
-     * @return Length of the longest contact name the SIM card accepts
-     */
-    private int detectMaxContactNameLength() {
-        String nameString = "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"; // 52 chars
-        int currentMax;
-        boolean success = false;
-        Contact testContact = null;
-
-        // loop from longest to shortest contact name length until a contact is stored successfully
-        for (currentMax = nameString.length(); (!success && currentMax > 0); currentMax--) {
-            testContact = new Contact(null, nameString.substring(0, currentMax), "24448888888");
-            success = create(testContact);
-        }
-
-        // if stored successfully, remove contact
-        delete(testContact);
-
-        return currentMax;
-    }
-
-    /**
-     * Retrieves all contacts from the SIM card.
-     * 
-     * @return ArrayList containing Contact objects from the stored SIM information
-     */
-    public ArrayList<Contact> get() {
-        final String[] simProjection = new String[] {
-                android.provider.Contacts.PeopleColumns.NAME,
-                android.provider.Contacts.PhonesColumns.NUMBER,
-                android.provider.BaseColumns._ID
-        };
-        Cursor results = resolver.query(
-                simUri,
-                simProjection,
-                null,
-                null,
-                android.provider.Contacts.PeopleColumns.NAME
-        );
-
-        final ArrayList<Contact> simContacts;
-        if (results != null && results.getCount() > 0) {
-            simContacts  = new ArrayList<Contact>(results.getCount());
-            while (results.moveToNext()) {
-                final Contact simContact = new Contact(
-                        results.getString(results.getColumnIndex("_id")),
-                        results.getString(results.getColumnIndex("name")),
-                        results.getString(results.getColumnIndex("number"))
-                );
-                simContacts.add(simContact);
-            }
-        } else {
-            simContacts = new ArrayList<Contact>(0);
-        }
-        return simContacts;
-    }
-
-    /**
-     * Creates a contact on the SIM card.
-     * 
-     * @param newSimContact
-     *            The Contact object containing the name and number of the
-     *            contact
-     * @return Success or failure. ContentResolver doesn't dive any other info
-     */
-    public boolean create(Contact newSimContact) {
-        ContentValues newSimValues = new ContentValues();
-        newSimValues.put("tag", newSimContact.getName());
-        newSimValues.put("number", newSimContact.getNumber());
-        Uri newSimRow = resolver.insert(simUri, newSimValues);
-
-        // It is always "content://icc/adn/0" on success and null on failure
-        // TODO: Isn't there a better API for working with SIM?
-        return newSimRow != null;
-    }
-
-    /**
-     * Delete a contact on the SIM card. Will only be removed if identified
-     * uniquely. Identification happens on the contact.name and contact.number
-     * attributes.
-     * 
-     * @param contact The contact to delete.
-     * @return Success or not
-     */
-    public boolean delete(Contact contact) {
-        String where = "tag='" + contact.getName() + "' AND number='" + contact.getNumber() + "'";
-        return resolver.delete(simUri, where, null) > 0;
-    }
-
-    /**
-     * Converts a contact to a SIM card conforming contact by stripping the name
-     * to the maximum allowed length and setting ID to null.
-     * 
-     * @param contact
-     *            The contact to convert to SIM conforming values
-     * @return a contact which does not contain values which exceed the SIM
-     *         cards limits or null if there was a problem detecting the limits
-     */
-    public Contact convertToSimContact(Contact contact) {
-        String name = maxContactNameLength > 0
-                ? contact.getName().substring(0, Math.min(contact.getName().length(), maxContactNameLength))
-                : contact.getName()
-                ;
-        String number = contact.getNumber().replace("-", "");
-        return new Contact(null, name, number);
-    }
-}
+package com.github.yeriomin.dumbphoneassistant;
+
+import android.app.Activity;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Build;
+import android.telephony.TelephonyManager;
+
+import java.util.ArrayList;
+
+public class SimUtil extends Util {
+
+    private final SharedPreferences settings;
+    private final TelephonyManager telephony;
+    private Uri simUri;
+
+    private int maxContactNameLength = 0; // Maximum length of contact names may
+                                          // differ from SIM to SIM, will be
+                                          // detected upon load of class
+
+    public SimUtil(Activity activity) {
+        super(activity);
+
+        this.settings = activity.getSharedPreferences(activity.getApplicationInfo().name, 0);
+        this.telephony = (TelephonyManager) activity.getSystemService(Context.TELEPHONY_SERVICE);
+        this.simUri = Uri.parse(detectSimUri());
+
+        maxContactNameLength = getMaxContactNameLength();
+    }
+
+    /**
+     * Detects the URI identifier for accessing the SIM card. Is different,
+     * depending on Android version.
+     * 
+     * @return Uri of the SIM card on this system
+     */
+    private String detectSimUri() {
+        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.DONUT
+                ? "content://icc/adn"
+                : "content://sim/adn"
+                ;
+    }
+
+    /**
+     * Query SharedPreferences storage for the maximum contact length
+     * If no value is stored, detect it by attempting to write a contact, then store it
+     * The value is stored with current SIM card's id
+     *
+     * @return Length of the longest contact name the SIM card accepts
+     */
+    private int getMaxContactNameLength() {
+        String simId = this.telephony.getSimSerialNumber();
+        int maxContactLength = this.settings.getInt(simId, 0);
+        if (maxContactLength == 0) {
+            maxContactLength = detectMaxContactNameLength();
+        }
+        if (maxContactLength > 0) {
+            this.settings.edit().putInt(simId, maxContactLength);
+        }
+        return maxContactLength;
+    }
+
+    /**
+     * Detects the maximum length of a contacts name which is accepted by the
+     * SIM card by attempting to insert contacts until the SIM card accepts
+     * 
+     * @return Length of the longest contact name the SIM card accepts
+     */
+    private int detectMaxContactNameLength() {
+        String nameString = "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"; // 52 chars
+        int currentMax;
+        boolean success = false;
+        Contact testContact = null;
+
+        // loop from longest to shortest contact name length until a contact is stored successfully
+        for (currentMax = nameString.length(); (!success && currentMax > 0); currentMax--) {
+            testContact = new Contact(null, nameString.substring(0, currentMax), "24448888888");
+            success = create(testContact);
+        }
+
+        // if stored successfully, remove contact
+        delete(testContact);
+
+        return currentMax;
+    }
+
+    /**
+     * Retrieves all contacts from the SIM card.
+     * 
+     * @return ArrayList containing Contact objects from the stored SIM information
+     */
+    public ArrayList<Contact> get() {
+        final String[] simProjection = new String[] {
+                android.provider.Contacts.PeopleColumns.NAME,
+                android.provider.Contacts.PhonesColumns.NUMBER,
+                android.provider.BaseColumns._ID
+        };
+        Cursor results = resolver.query(
+                simUri,
+                simProjection,
+                null,
+                null,
+                android.provider.Contacts.PeopleColumns.NAME
+        );
+
+        final ArrayList<Contact> simContacts = new ArrayList<Contact>();
+        if (results != null) {
+            if (results.getCount() > 0) {
+                while (results.moveToNext()) {
+                    final Contact simContact = new Contact(
+                            results.getString(results.getColumnIndex(android.provider.BaseColumns._ID)),
+                            results.getString(results.getColumnIndex(android.provider.Contacts.PeopleColumns.NAME)),
+                            results.getString(results.getColumnIndex(android.provider.Contacts.PhonesColumns.NUMBER))
+                    );
+                    simContacts.add(simContact);
+                }
+            }
+            results.close();
+        }
+        return simContacts;
+    }
+
+    /**
+     * Creates a contact on the SIM card.
+     * 
+     * @param newSimContact
+     *            The Contact object containing the name and number of the
+     *            contact
+     * @return Success or failure. ContentResolver doesn't dive any other info
+     */
+    public boolean create(Contact newSimContact) {
+        ContentValues newSimValues = new ContentValues();
+        newSimValues.put("tag", newSimContact.getName());
+        newSimValues.put("number", newSimContact.getNumber());
+        Uri newSimRow = resolver.insert(simUri, newSimValues);
+
+        // It is always "content://icc/adn/0" on success and null on failure
+        // TODO: Isn't there a better API for working with SIM?
+        return newSimRow != null;
+    }
+
+    /**
+     * Delete a contact on the SIM card. Will only be removed if identified
+     * uniquely. Identification happens on the contact.name and contact.number
+     * attributes.
+     * 
+     * @param contact The contact to delete.
+     * @return Success or not
+     */
+    public boolean delete(Contact contact) {
+        String where = "tag='?' AND number='?'";
+        String[] selectionArgs = new String[] {contact.getName(), contact.getNumber()};
+        return resolver.delete(simUri, where, selectionArgs) > 0;
+    }
+
+    /**
+     * Converts a contact to a SIM card conforming contact by stripping the name
+     * to the maximum allowed length and setting ID to null.
+     * 
+     * @param contact
+     *            The contact to convert to SIM conforming values
+     * @return a contact which does not contain values which exceed the SIM
+     *         cards limits or null if there was a problem detecting the limits
+     */
+    public Contact convertToSimContact(Contact contact) {
+        String name = maxContactNameLength > 0
+                ? contact.getName().substring(0, Math.min(contact.getName().length(), maxContactNameLength))
+                : contact.getName()
+                ;
+        String number = contact.getNumber().replace("-", "");
+        return new Contact(null, name, number);
+    }
+}
diff --git a/app/src/main/java/com/github/yeriomin/dumbphoneassistant/Util.java b/app/src/main/java/com/github/yeriomin/dumbphoneassistant/Util.java
index 61137f5..795bd25 100644
--- a/app/src/main/java/com/github/yeriomin/dumbphoneassistant/Util.java
+++ b/app/src/main/java/com/github/yeriomin/dumbphoneassistant/Util.java
@@ -1,33 +1,33 @@
-package com.github.yeriomin.dumbphoneassistant;
-
-import android.app.Activity;
-import android.content.ContentResolver;
-
-import java.util.ArrayList;
-
-public abstract class Util {
-
-    protected static Activity activity;
-    protected ContentResolver resolver;
-
-    public Util(Activity activity) {
-        this.activity = activity;
-        this.resolver = activity.getContentResolver();
-    }
-    
-    /**
-     * Retrieves all contacts
-     * 
-     * @return List containing all Contact objects
-     */
-    public abstract ArrayList<Contact> get();
-
-    /**
-     * Creates a contact
-     * 
-     * @param newContact The Contact object containing the name and number of the contact
-     * @return Success or not
-     */
-    public abstract boolean create(Contact newContact) throws Exception;
-
+package com.github.yeriomin.dumbphoneassistant;
+
+import android.app.Activity;
+import android.content.ContentResolver;
+
+import java.util.ArrayList;
+
+public abstract class Util {
+
+    protected static Activity activity;
+    protected ContentResolver resolver;
+
+    public Util(Activity activity) {
+        this.activity = activity;
+        this.resolver = activity.getContentResolver();
+    }
+    
+    /**
+     * Retrieves all contacts
+     * 
+     * @return List containing all Contact objects
+     */
+    public abstract ArrayList<Contact> get();
+
+    /**
+     * Creates a contact
+     * 
+     * @param newContact The Contact object containing the name and number of the contact
+     * @return Success or not
+     */
+    public abstract boolean create(Contact newContact) throws Exception;
+
 }
\ No newline at end of file
