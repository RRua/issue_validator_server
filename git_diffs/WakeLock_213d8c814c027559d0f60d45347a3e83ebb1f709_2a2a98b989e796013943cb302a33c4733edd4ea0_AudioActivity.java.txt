diff --git a/src/ac/robinson/mediaphone/BrowserActivity.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/BrowserActivity.java
similarity index 100%
rename from src/ac/robinson/mediaphone/BrowserActivity.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/BrowserActivity.java
diff --git a/src/ac/robinson/mediaphone/MediaPhone.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/MediaPhone.java
similarity index 97%
rename from src/ac/robinson/mediaphone/MediaPhone.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/MediaPhone.java
index 672a16c..858f9ff 100644
--- a/src/ac/robinson/mediaphone/MediaPhone.java
+++ b/MediaPhone/src/main/java/ac/robinson/mediaphone/MediaPhone.java
@@ -36,6 +36,9 @@ public class MediaPhone {
 	public static final String EXTENSION_PHOTO_FILE = "jpg"; // TODO: check Camera.Parameters for proper file format?
 	public static final String EXTENSION_AUDIO_FILE = (DebugUtilities.supportsAMRAudioRecordingOnly() ? "3gp" : "m4a");
 	public static final String EXTENSION_TEXT_FILE = "txt";
+	
+	//the number of audio items to allow per frame - note that if this is changed, layouts need updating too
+	public static final int MAX_AUDIO_ITEMS = 3;
 
 	// we can pause/resume recording in either AAC (M4A) or AMR (3GP) formats - get extensions from MediaUtilities
 	public static String[] EDITABLE_AUDIO_EXTENSIONS = {};
diff --git a/src/ac/robinson/mediaphone/MediaPhoneActivity.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/MediaPhoneActivity.java
similarity index 67%
rename from src/ac/robinson/mediaphone/MediaPhoneActivity.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/MediaPhoneActivity.java
index d5b539f..4406b2a 100644
--- a/src/ac/robinson/mediaphone/MediaPhoneActivity.java
+++ b/MediaPhone/src/main/java/ac/robinson/mediaphone/MediaPhoneActivity.java
@@ -25,11 +25,14 @@ import java.io.IOException;
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.Hashtable;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 
+import ac.robinson.mediaphone.activity.FrameEditorActivity;
 import ac.robinson.mediaphone.activity.NarrativeBrowserActivity;
 import ac.robinson.mediaphone.activity.PreferencesActivity;
 import ac.robinson.mediaphone.activity.SaveNarrativeActivity;
@@ -70,6 +73,7 @@ import android.content.SharedPreferences;
 import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.Point;
+import android.graphics.drawable.AnimationDrawable;
 import android.media.MediaScannerConnection;
 import android.net.Uri;
 import android.os.AsyncTask;
@@ -83,7 +87,7 @@ import android.os.SystemClock;
 import android.preference.PreferenceManager;
 import android.provider.MediaStore;
 import android.provider.MediaStore.Video;
-import android.support.v4.app.FragmentActivity;
+import android.support.v7.app.AppCompatActivity;
 import android.util.Log;
 import android.util.TypedValue;
 import android.view.GestureDetector;
@@ -94,9 +98,11 @@ import android.view.MenuItem;
 import android.view.MotionEvent;
 import android.view.View;
 import android.view.ViewConfiguration;
+import android.view.Window;
+import android.view.WindowManager;
 import android.widget.ImageView;
 
-public abstract class MediaPhoneActivity extends FragmentActivity {
+public abstract class MediaPhoneActivity extends AppCompatActivity {
 
 	private ImportFramesTask mImportFramesTask;
 	private ProgressDialog mImportFramesProgressDialog;
@@ -132,7 +138,14 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 		if (MediaPhone.DEBUG) {
 			ViewServer.get(this).addWindow(this);
 		}
-		UIUtilities.setPixelDithering(getWindow());
+		Window window = getWindow();
+		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+			window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
+			window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
+			window.setStatusBarColor(getResources().getColor(R.color.primary_dark));
+		}
+		
+		UIUtilities.setPixelDithering(window);
 		checkDirectoriesExist();
 
 		Object retained = getLastCustomNonConfigurationInstance();
@@ -419,25 +432,38 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 		}
 	}
 
-	protected void setupMenuNavigationButtonsFromMedia(MenuInflater inflater, Menu menu,
-			ContentResolver contentResolver, String mediaId, boolean edited) {
-		String parentId = null;
+	protected void createMediaMenuNavigationButtons(MenuInflater inflater, Menu menu, boolean edited) {
+		inflater.inflate(R.menu.add_frame, menu);
+		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
+			if (edited) {
+				inflater.inflate(R.menu.finished_editing, menu);
+			} else {
+				inflater.inflate(R.menu.back_without_editing, menu);
+			}
+		}
+	}
+
+	protected void prepareMediaMenuNavigationButtons(Menu menu, String mediaId) {
+		boolean allowSpannedMediaNavigation = false;
 		if (mediaId != null) {
 			MediaItem mediaItem = MediaManager.findMediaByInternalId(getContentResolver(), mediaId);
 			if (mediaItem != null) {
-				parentId = mediaItem.getParentId();
+				// don't allow spanned frames to add frame after as this doesn't make any sense
+				allowSpannedMediaNavigation = !mediaItem.getSpanFrames();
 			}
 		}
-		setupMenuNavigationButtons(inflater, menu, parentId, edited);
+		menu.findItem(R.id.menu_add_frame).setEnabled(allowSpannedMediaNavigation);
 	}
 
-	protected void setupMenuNavigationButtons(MenuInflater inflater, Menu menu, String frameId, boolean edited) {
+	protected void setupFrameMenuNavigationButtons(MenuInflater inflater, Menu menu, String frameId, boolean edited,
+			boolean preventSpannedMediaNavigation) {
 		inflater.inflate(R.menu.previous_frame, menu);
 		inflater.inflate(R.menu.next_frame, menu);
 		// we should have already got focus by the time this is called, so can try to disable invalid buttons
 		if (frameId != null) {
 			NavigationMode navigationAllowed = FrameItem.getNavigationAllowed(getContentResolver(), frameId);
-			if (navigationAllowed == NavigationMode.PREVIOUS || navigationAllowed == NavigationMode.NONE) {
+			if (navigationAllowed == NavigationMode.PREVIOUS || navigationAllowed == NavigationMode.NONE
+					|| preventSpannedMediaNavigation) {
 				menu.findItem(R.id.menu_next_frame).setEnabled(false);
 			}
 			if (navigationAllowed == NavigationMode.NEXT || navigationAllowed == NavigationMode.NONE) {
@@ -445,6 +471,9 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 			}
 		}
 		inflater.inflate(R.menu.add_frame, menu);
+		if (preventSpannedMediaNavigation) {
+			menu.findItem(R.id.menu_add_frame).setEnabled(false);
+		}
 		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
 			if (edited) {
 				inflater.inflate(R.menu.finished_editing, menu);
@@ -457,11 +486,11 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 	protected void setBackButtonIcons(Activity activity, int button1, int button2, boolean isEdited) {
 		if (button1 != 0) {
 			((CenteredImageTextButton) findViewById(button1)).setCompoundDrawablesWithIntrinsicBounds(0,
-					(isEdited ? R.drawable.ic_finished_editing : android.R.drawable.ic_menu_revert), 0, 0);
+					(isEdited ? R.drawable.ic_menu_accept : R.drawable.ic_menu_back), 0, 0);
 		}
 		if (button2 != 0) {
 			((CenteredImageTextButton) findViewById(button2)).setCompoundDrawablesWithIntrinsicBounds(0,
-					(isEdited ? R.drawable.ic_finished_editing : android.R.drawable.ic_menu_revert), 0, 0);
+					(isEdited ? R.drawable.ic_menu_accept : R.drawable.ic_menu_back), 0, 0);
 		}
 		UIUtilities.refreshActionBar(activity);
 	}
@@ -520,6 +549,8 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 		MediaPhone.PLAYBACK_EXPORT_MINIMUM_FRAME_DURATION = Math.round(minimumFrameDuration * 1000);
 
 		// word duration
+		// TODO: currently a one-time setting - should we queue a background task to select text items with negative or
+		// zero/ duration values (i.e., not user-set) and update them to the new duration?
 		res.getValue(R.attr.default_word_duration, resourceValue, true);
 		float wordDuration;
 		try {
@@ -715,7 +746,7 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 			} else {
 				mImportFramesTask = new ImportFramesTask(MediaPhoneActivity.this);
 				mImportFramesTask.addFramesToImport(narrativeFrames);
-				mImportFramesTask.execute();
+				mImportFramesTask.execute(); // TODO: deal with post-4.0 single thread AsyncTask - use executeOnExecutor
 			}
 		}
 	}
@@ -772,6 +803,98 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 		return frameIdSettings.getString(getString(R.string.key_last_edited_frame), null);
 	}
 
+	/**
+	 * Inserts a frame after the one containing this media item, and returns the new frame's internal id
+	 * 
+	 * @param existingMedia
+	 * @return
+	 */
+	protected String insertFrameAfterMedia(MediaItem existingMedia) {
+		String insertAfterId = existingMedia.getParentId();
+		ContentResolver contentResolver = getContentResolver();
+		FrameItem existingParent = FramesManager.findFrameByInternalId(contentResolver, insertAfterId);
+		if (existingParent == null) {
+			return null;
+		}
+
+		// create a new frame (but don't load the its icon yet - it will be loaded (or deleted) when we return)
+		final String narrativeId = existingParent.getParentId();
+		final FrameItem newFrame = new FrameItem(narrativeId, -1);
+		final String newFrameId = newFrame.getInternalId();
+		FramesManager.addFrame(getResources(), contentResolver, newFrame, false); // must add before calculating seq id
+
+		// get and update any inherited media
+		ArrayList<MediaItem> inheritedMedia = MediaManager.findMediaByParentId(contentResolver, insertAfterId);
+		for (final MediaItem media : inheritedMedia) {
+			if (media.getSpanFrames()) {
+				MediaManager.addMediaLink(contentResolver, newFrameId, media.getInternalId());
+			}
+		}
+
+		// get and update the required narrative sequence id
+		final int narrativeSequenceId = adjustNarrativeSequenceIds(narrativeId, insertAfterId);
+		newFrame.setNarrativeSequenceId(narrativeSequenceId);
+		FramesManager.updateFrame(contentResolver, newFrame);
+
+		return newFrameId;
+	}
+
+	/**
+	 * Used for inserting a new frame - given the narrative id and the desired before or after frame id (not both) this
+	 * function will adjust existing frames and return the new frame sequence id, which must be updated into the frame
+	 * by the caller. Note: the new frame must have already been added to the database.
+	 * 
+	 * @param narrativeId
+	 * @param insertAfterId
+	 * @return The sequence id that should be used for the new frame
+	 */
+	protected int adjustNarrativeSequenceIds(String narrativeId, String insertAfterId) {
+		// note: not a background task any more, because it causes concurrency problems with deleting after back press
+		Resources res = getResources();
+		ContentResolver contentResolver = getContentResolver();
+		int narrativeSequenceIdIncrement = res.getInteger(R.integer.frame_narrative_sequence_increment);
+		int narrativeSequenceId = 0;
+
+		// insert new frame - increment necessary frames after the new frame's position
+		boolean insertAtStart = FrameItem.KEY_FRAME_ID_START.equals(insertAfterId);
+		ArrayList<FrameItem> narrativeFrames = FramesManager.findFramesByParentId(contentResolver, narrativeId);
+		narrativeFrames.remove(0); // don't edit the newly inserted frame yet
+
+		int previousNarrativeSequenceId = -1;
+		boolean frameFound = false;
+		for (FrameItem frame : narrativeFrames) {
+			if (!frameFound && insertAtStart) {
+				frameFound = true;
+				narrativeSequenceId = frame.getNarrativeSequenceId();
+			}
+			if (frameFound) {
+				int currentNarrativeSequenceId = frame.getNarrativeSequenceId();
+				if (currentNarrativeSequenceId <= narrativeSequenceId
+						|| currentNarrativeSequenceId <= previousNarrativeSequenceId) {
+
+					frame.setNarrativeSequenceId(currentNarrativeSequenceId
+							+ Math.max(narrativeSequenceId - currentNarrativeSequenceId, previousNarrativeSequenceId
+									- currentNarrativeSequenceId) + 1);
+					if (insertAtStart) {
+						FramesManager.updateFrame(res, contentResolver, frame, true); // TODO: background task?
+						insertAtStart = false;
+					} else {
+						FramesManager.updateFrame(contentResolver, frame);
+					}
+					previousNarrativeSequenceId = frame.getNarrativeSequenceId();
+				} else {
+					break;
+				}
+			}
+			if (!frameFound && frame.getInternalId().equals(insertAfterId)) {
+				frameFound = true;
+				narrativeSequenceId = frame.getNarrativeSequenceId() + narrativeSequenceIdIncrement;
+			}
+		}
+
+		return narrativeSequenceId;
+	}
+
 	/**
 	 * Switch from one frame to another. Will call onBackPressed() on the calling activity
 	 * 
@@ -782,8 +905,7 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 	 * @param targetActivityClass
 	 * @return
 	 */
-	protected boolean switchFrames(String currentFrameId, int buttonId, int idExtra, boolean showOptionsMenu,
-			Class<?> targetActivityClass) {
+	protected boolean switchFrames(String currentFrameId, int buttonId, String newFrameId, boolean showOptionsMenu) {
 		if (currentFrameId == null) {
 			return false;
 		}
@@ -796,6 +918,13 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 		int inAnimation = R.anim.slide_in_from_right;
 		int outAnimation = R.anim.slide_out_to_left;
 		switch (buttonId) {
+			case 0:
+				newFramePosition = narrativeFrameIds.indexOf(newFrameId);
+				if (currentPosition < newFramePosition) {
+					inAnimation = R.anim.slide_in_from_left;
+					outAnimation = R.anim.slide_out_to_right;
+				}
+				break;
 			case R.id.menu_previous_frame:
 				if (currentPosition > 0) {
 					newFramePosition = currentPosition - 1;
@@ -810,8 +939,9 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 				break;
 		}
 		if (newFramePosition >= 0) {
-			final Intent nextPreviousFrameIntent = new Intent(MediaPhoneActivity.this, targetActivityClass);
-			nextPreviousFrameIntent.putExtra(getString(idExtra), narrativeFrameIds.get(newFramePosition));
+			final Intent nextPreviousFrameIntent = new Intent(MediaPhoneActivity.this, FrameEditorActivity.class);
+			nextPreviousFrameIntent.putExtra(getString(R.string.extra_internal_id),
+					narrativeFrameIds.get(newFramePosition));
 
 			// this allows us to prevent showing first activity launch hints repeatedly
 			nextPreviousFrameIntent.putExtra(getString(R.string.extra_switched_frames), true);
@@ -825,6 +955,13 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 			closeOptionsMenu(); // so onBackPressed doesn't just do this
 			onBackPressed();
 			overridePendingTransition(inAnimation, outAnimation);
+
+			// may have switched without actually adding media - delete frame if so (only applicable from media, as the
+			// frame editor handles this on back pressed, but setting a frame to deleted twice has no ill effects)
+			if (MediaManager.countMediaByParentId(contentResolver, currentFrameId) <= 0) {
+				currentFrame.setDeleted(true);
+				FramesManager.updateFrame(contentResolver, currentFrame);
+			}
 			return true;
 		} else {
 			UIUtilities.showToast(MediaPhoneActivity.this, R.string.next_previous_no_more_frames);
@@ -832,6 +969,483 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 		}
 	}
 
+	/**
+	 * Update the span frames button with the given id to show the correct icon for media spanning multiple frames
+	 * 
+	 * @param buttonId
+	 * @param spanFrames
+	 * @param animate Whether to animate the transition between button icons
+	 */
+	protected void updateSpanFramesButtonIcon(int buttonId, boolean spanFrames, boolean animate) {
+		CenteredImageTextButton spanFramesButton = ((CenteredImageTextButton) findViewById(buttonId));
+		if (animate) {
+			AnimationDrawable spanAnimation = (AnimationDrawable) getResources().getDrawable(
+					spanFrames ? R.drawable.span_frames_animation_on : R.drawable.span_frames_animation_off);
+			spanFramesButton.setCompoundDrawablesWithIntrinsicBounds(null, spanAnimation, null, null);
+			spanAnimation.start();
+		} else {
+			spanFramesButton.setCompoundDrawablesWithIntrinsicBounds(0, spanFrames ? R.drawable.ic_menu_span_frames_on
+					: R.drawable.ic_menu_span_frames_off, 0, 0);
+		}
+	}
+
+	/**
+	 * Update the icon of the parent frame of the given media item; and, if this media item is spanning, update any
+	 * applicable frame icons after the one containing this media item (used when the media has changed)
+	 * 
+	 * @param mediaItem
+	 * @param preUpdateTask a Runnable that will be run before updating anything - used, for example, to make sure text
+	 *            is saved before updating icons
+	 */
+	protected void updateMediaFrameIcons(MediaItem mediaItem, Runnable preUpdateTask) {
+		// Because database/file edits are buffered, we need to use a runnable to update icons in the same thread as
+		// those edits (currently only used for text). A side-effect of updating text in a thread is that the file is
+		// locked when we try to get the summary for the frame editor - for now, running the save and icon tasks on the
+		// UI thread deal with this. TODO: in future, save the text snippet to the database, or to a shared preference?
+		final boolean updateCurrentIcon;
+		if (preUpdateTask != null) {
+			preUpdateTask.run();
+			FramesManager.reloadFrameIcon(getResources(), getContentResolver(), mediaItem.getParentId());
+			updateCurrentIcon = false;
+		} else {
+			// ensure the previous icon is not shown - remove from cache
+			ImageCacheUtilities.setLoadingIcon(FrameItem.getCacheId(mediaItem.getParentId()));
+			updateCurrentIcon = true;
+		}
+
+		final String parentId = mediaItem.getParentId();
+		final String internalId = mediaItem.getInternalId();
+		final boolean updateMultipleIcons = mediaItem.getSpanFrames();
+		runQueuedBackgroundTask(new BackgroundRunnable() {
+			@Override
+			public int getTaskId() {
+				return 0;
+			}
+
+			@Override
+			public boolean getShowDialog() {
+				return false;
+			}
+
+			@Override
+			public void run() {
+				ContentResolver contentResolver = getContentResolver();
+				Resources resources = getResources();
+				if (updateCurrentIcon) {
+					FramesManager.reloadFrameIcon(getResources(), contentResolver, parentId);
+				}
+
+				// if applicable, update all frame items that link to this media item
+				if (updateMultipleIcons) {
+					FramesManager.reloadFrameIcons(resources, contentResolver,
+							MediaManager.findLinkedParentIdsByMediaId(contentResolver, internalId));
+				}
+			}
+		});
+	}
+
+	/**
+	 * Removes the link to the media item with mediaId from startFrameId and all frames following - used when replacing
+	 * a linked media item with a new item
+	 * 
+	 * @param mediaId
+	 * @param startFrameId
+	 */
+	protected void endLinkedMediaItem(final String mediaId, final String startFrameId) {
+		// because database access can take time, we need to do db and icon updates in the same thread
+		runQueuedBackgroundTask(new BackgroundRunnable() {
+			@Override
+			public int getTaskId() {
+				return 0;
+			}
+
+			@Override
+			public boolean getShowDialog() {
+				return false;
+			}
+
+			@Override
+			public void run() {
+				// we only need the parent ids of frames after (not including) the current one
+				ContentResolver contentResolver = getContentResolver();
+				ArrayList<String> narrativeFrameIds = FramesManager.getFollowingFrameIds(contentResolver, startFrameId,
+						false);
+				if (narrativeFrameIds == null) {
+					return;
+				}
+
+				// hold a list of icons to update, so we only can do database manipulation first
+				ArrayList<String> iconsToUpdate = new ArrayList<String>();
+
+				// now remove the media link from all of these frames - we do this way rather than just selecting links
+				// because links are not ordered TODO: could join select with frames table, ordering by sequence id?
+				for (final String frameId : narrativeFrameIds) {
+					boolean mediaFound = false;
+
+					// need to check all following frames until we find one that doesn't link to this item
+					ArrayList<String> frameMedia = MediaManager.findLinkedMediaIdsByParentId(contentResolver, frameId);
+					for (String media : frameMedia) {
+						if (mediaId.equals(media)) {
+							mediaFound = true;
+							break;
+						}
+					}
+
+					// remove the media link and queue updating icons for changed frames; remove frames now blank
+					if (mediaFound) {
+						MediaManager.deleteMediaLink(contentResolver, frameId, mediaId);
+
+						if (MediaManager.countMediaByParentId(contentResolver, frameId, false) > 0) {
+							iconsToUpdate.add(frameId);
+						} else {
+							// don't allow frames that don't have any normal (i.e., non-linked media) - set deleted
+							FrameItem frameToDelete = FramesManager.findFrameByInternalId(contentResolver, frameId);
+							frameToDelete.setDeleted(true);
+							FramesManager.updateFrame(contentResolver, frameToDelete);
+						}
+					} else {
+						break;
+					}
+				}
+
+				// finally, update icons for changed frames
+				FramesManager.reloadFrameIcons(getResources(), contentResolver, iconsToUpdate);
+			}
+		});
+
+		// the current media item is a special case - we do it separately because we don't want to accidentally delete
+		// the frame if its only current content is the inherited item; there's also no need to update the icon because
+		// if they do edit we'll update automatically; if they don't then we'll have to undo all these changes...
+		MediaManager.deleteMediaLink(getContentResolver(), startFrameId, mediaId);
+	}
+
+	/**
+	 * Make sure any linked media prior to the given frame is propagated to that frame and any after it that apply. Will
+	 * always update startFrameId's icon. Used when deleting a media item or frame.
+	 * 
+	 * @param startFrameId
+	 * @param deletedMediaItem a media item from startFrameId has already been deleted, and so should also be checked in
+	 *            the following frames for spanning - used only from media activities (may be null)
+	 * @param frameMediaItemsToDelete a list of media item ids that should be removed from startFrameId and all
+	 *            following frames - used only from frame editor (may be null)
+	 */
+	protected void inheritMediaAndDeleteItemLinks(final String startFrameId, final MediaItem deletedMediaItem,
+			final ArrayList<String> frameMediaItemsToDelete) {
+
+		// first get a list of the frames that could need updating
+		ContentResolver contentResolver = getContentResolver();
+		FrameItem parentFrame = FramesManager.findFrameByInternalId(contentResolver, startFrameId);
+		final ArrayList<String> narrativeFrameIds = FramesManager.getFollowingFrameIds(contentResolver, parentFrame,
+				true);
+		if (narrativeFrameIds == null) {
+			return; // no frames found - error; won't be able to update anything
+		}
+
+		// and a list of icons that we will need to update
+		// this also fixes an issue where database conflicts were occurring (random quits) in the task thread
+		final ArrayList<String> iconsToUpdate = new ArrayList<String>();
+		if (deletedMediaItem != null) {
+			iconsToUpdate.addAll(MediaManager.findLinkedParentIdsByMediaId(contentResolver,
+					deletedMediaItem.getInternalId()));
+		}
+		if (frameMediaItemsToDelete != null) {
+			for (String mediaId : frameMediaItemsToDelete) {
+				iconsToUpdate.addAll(MediaManager.findLinkedParentIdsByMediaId(contentResolver, mediaId));
+			}
+		}
+		// remove duplicates by adding to a hash set then retrieving (LinkedHashSet also preserves order)
+		LinkedHashSet<String> setItems = new LinkedHashSet<>(iconsToUpdate);
+		iconsToUpdate.clear();
+		iconsToUpdate.addAll(setItems);
+
+		// when using from the frame editor the previous icons are briefly displayed - remove from cache to prevent this
+		// - we won't definitely be updating all of these, but removing from the cache gives a better experience
+		ImageCacheUtilities.setLoadingIcon(FrameItem.getCacheId(startFrameId));
+		for (String frameId : iconsToUpdate) {
+			ImageCacheUtilities.setLoadingIcon(FrameItem.getCacheId(frameId));
+		}
+
+		// save loading things twice if we can - get the previous frame and its media
+		final String previousFrameId;
+		if (narrativeFrameIds.size() >= 1) {
+			previousFrameId = narrativeFrameIds.remove(0);
+		} else {
+			previousFrameId = null;
+		}
+
+		// get inherited media (items from the previous frame that span multiple frames)
+		final ArrayList<MediaItem> inheritedMedia = new ArrayList<>();
+		if (previousFrameId != null) {
+			ArrayList<MediaItem> prevMedia = MediaManager.findMediaByParentId(contentResolver, previousFrameId);
+			// filter - we only need items that span frames
+			for (final MediaItem media : prevMedia) {
+				if (media.getSpanFrames()) {
+					inheritedMedia.add(media);
+				}
+			}
+		}
+
+		// because we delete and propagate all icons at once, the current frame's propagated media may not have been
+		// updated by the time we return, and may not show in the frame editor - to deal with this we propagate the
+		// current frame's media first, on the UI thread, but only for the type of deletedMediaItem (no others apply)
+		if (deletedMediaItem != null) {
+			// link the previous frame's media of this item's type (if not currently linked)
+			int mediaType = deletedMediaItem.getType();
+			if (previousFrameId != null) {
+				ArrayList<String> currentMedia = MediaManager.findLinkedMediaIdsByParentId(contentResolver,
+						startFrameId); // need to compare with existing links so we don't re-add audio when deleting one
+				for (MediaItem media : inheritedMedia) {
+					final String mediaId = media.getInternalId();
+					if (media.getType() == mediaType && !currentMedia.contains(mediaId)) {
+						MediaManager.addMediaLink(contentResolver, startFrameId, mediaId);
+					}
+				}
+			}
+		}
+
+		// because database access can take time, we need to do db and icon updates in the same thread
+		runQueuedBackgroundTask(new BackgroundRunnable() {
+			@Override
+			public int getTaskId() {
+				return 0;
+			}
+
+			@Override
+			public boolean getShowDialog() {
+				return false;
+			}
+
+			@Override
+			public void run() {
+
+				// first, delete the media items as requested
+				ContentResolver contentResolver = getContentResolver();
+				if (frameMediaItemsToDelete != null) {
+					for (String mediaId : frameMediaItemsToDelete) {
+						final MediaItem deletedMedia = MediaManager.findMediaByInternalId(contentResolver, mediaId);
+						if (deletedMedia != null) {
+							deletedMedia.setDeleted(true);
+							MediaManager.updateMedia(contentResolver, deletedMedia);
+						}
+					}
+				}
+
+				// if we're removing a frame's media, we need to add the current frame to propagate media to (in this
+				// case, startFrameId is the frame after the deleted frame, rather than the frame media is removed from)
+				if (frameMediaItemsToDelete != null) {
+					narrativeFrameIds.add(0, startFrameId);
+				}
+
+				// check we have enough frames to operate on
+				if (narrativeFrameIds.size() == 0 || (inheritedMedia.size() == 0 && iconsToUpdate.size() == 0)) {
+					// no spanning items or media to delete; nothing to do except update the current frame's icon
+					FramesManager.reloadFrameIcon(getResources(), contentResolver, startFrameId);
+					return;
+				}
+
+				// now remove previously propagated media and propagate media from earlier frames
+				boolean deletedMediaComplete = false;
+				iconsToUpdate.add(0, startFrameId); // always update the current icon (first for better appearance)
+				for (final String frameId : narrativeFrameIds) {
+
+					// update icons to remove this media item from its propagated frames
+					if (!deletedMediaComplete) {
+
+						// delete frames that are now blank
+						if (iconsToUpdate.contains(frameId)) {
+							if (MediaManager.countMediaByParentId(contentResolver, frameId, false) <= 0) {
+								// don't allow frames that don't have any normal (i.e., non-linked media) - set deleted
+								iconsToUpdate.remove(frameId); // no need to update this icon any more - will not exist
+								FrameItem frameToDelete = FramesManager.findFrameByInternalId(contentResolver, frameId);
+								frameToDelete.setDeleted(true);
+								FramesManager.updateFrame(contentResolver, frameToDelete);
+							}
+						} else {
+							// we've reached the end of spanning media if there's no link to a frame
+							deletedMediaComplete = true;
+						}
+					}
+
+					// need to check all following frames until we find those with media of this type
+					if (inheritedMedia.size() > 0) {
+						// check this frame's media for collisions with spanning items
+						ArrayList<MediaItem> frameMedia = MediaManager.findMediaByParentId(contentResolver, frameId,
+								false); // no inherited items needed (now allow only one spanning audio item per frame)
+						ArrayList<MediaItem> mediaToRemove = new ArrayList<>();
+						int audioCount = 0;
+						boolean hasSpanningAudio = false;
+						for (MediaItem existingMedia : frameMedia) {
+							if (existingMedia.getType() == MediaPhoneProvider.TYPE_AUDIO) {
+								audioCount += 1;
+								if (existingMedia.getSpanFrames()) {
+									hasSpanningAudio = true;
+									break;
+								}
+							}
+						}
+						for (final MediaItem newMedia : inheritedMedia) {
+							int currentType = newMedia.getType();
+							if (currentType == MediaPhoneProvider.TYPE_AUDIO
+									&& (audioCount >= MediaPhone.MAX_AUDIO_ITEMS || hasSpanningAudio)) {
+								mediaToRemove.add(newMedia); // spanning audio or >= max stops spanning - finished item
+							} else {
+								for (MediaItem existingMedia : frameMedia) {
+									if (existingMedia.getType() == currentType) {
+										mediaToRemove.add(newMedia); // any other media overrides spanning - item done
+									}
+								}
+							}
+						}
+						frameMedia.removeAll(mediaToRemove);
+
+						// any media still in the propagated list should be added to this frame
+						if (inheritedMedia.size() > 0) {
+							for (MediaItem propagatedMedia : inheritedMedia) {
+								MediaManager.addMediaLink(contentResolver, frameId, propagatedMedia.getInternalId());
+							}
+							if (!iconsToUpdate.contains(frameId)) { // only add items we haven't already queued
+								iconsToUpdate.add(frameId);
+							}
+						}
+
+					} else if (deletedMediaComplete) {
+						break; // both deleting and propagating items are complete
+					}
+				}
+
+				// remove all links to the deleted media items
+				if (deletedMediaItem != null) {
+					MediaManager.deleteMediaLinks(contentResolver, deletedMediaItem.getInternalId());
+				}
+				if (frameMediaItemsToDelete != null) {
+					for (String mediaLink : frameMediaItemsToDelete) {
+						MediaManager.deleteMediaLinks(contentResolver, mediaLink);
+					}
+				}
+
+				// finally, update icons for changed frames (must be done last so the links no longer exist)
+				FramesManager.reloadFrameIcons(getResources(), contentResolver, iconsToUpdate);
+			}
+		});
+	}
+
+	/**
+	 * Toggle whether the media item with this id spans multiple frames or not
+	 * 
+	 * @param mediaItem
+	 * @return The new state of the media item (true for frame spanning; false otherwise)
+	 */
+	protected boolean toggleFrameSpanningMedia(MediaItem mediaItem) {
+
+		final boolean isFrameSpanning = mediaItem.getSpanFrames();
+		final String mediaId = mediaItem.getInternalId();
+		final String parentId = mediaItem.getParentId();
+		final int mediaType = mediaItem.getType();
+
+		// because database access can take time, we need to do db and icon updates in the same thread
+		runQueuedBackgroundTask(new BackgroundRunnable() {
+			@Override
+			public int getTaskId() {
+				return 0;
+			}
+
+			@Override
+			public boolean getShowDialog() {
+				return false;
+			}
+
+			@Override
+			public void run() {
+
+				// hold a list of icons to update, so we update icons after all database edits are complete
+				ArrayList<String> iconsToUpdate;
+				ContentResolver contentResolver = getContentResolver();
+
+				if (isFrameSpanning) {
+
+					// TODO: here we need to inherit previous audio when turning spanning off - combine this function
+					// with inheritMediaAndDeleteItemLinks?
+
+					// get the known links to this media item and check the frames contain other media; remove if not
+					iconsToUpdate = MediaManager.findLinkedParentIdsByMediaId(contentResolver, mediaId);
+					ArrayList<String> removedIcons = new ArrayList<>();
+					for (final String frameId : iconsToUpdate) {
+						if (MediaManager.countMediaByParentId(contentResolver, frameId, false) <= 0) {
+							// don't allow frames that don't have any normal (i.e., non-linked media) - set deleted
+							FrameItem frameToDelete = FramesManager.findFrameByInternalId(contentResolver, frameId);
+							frameToDelete.setDeleted(true);
+							FramesManager.updateFrame(contentResolver, frameToDelete);
+							removedIcons.add(frameId); // no need to update this icon any more - will not exist
+						}
+					}
+					iconsToUpdate.removeAll(removedIcons);
+
+					// delete all links to this media item
+					MediaManager.deleteMediaLinks(contentResolver, mediaId);
+
+				} else {
+
+					iconsToUpdate = new ArrayList<>();
+					ArrayList<String> narrativeFrameIds = FramesManager.getFollowingFrameIds(contentResolver, parentId,
+							false);
+					if (narrativeFrameIds == null) {
+						return; // nothing we can do - we have no frame ids to propagate to, so can't enable spanning
+					}
+
+					// turn this item into a frame-spanning media item by extending it to other frames
+					for (String frameId : narrativeFrameIds) {
+						// need to add this media to all following frames until one that already has media of this type
+						ArrayList<MediaItem> frameMedia = MediaManager.findMediaByParentId(contentResolver, frameId,
+								false); // no inherited items needed (now allow only one spanning audio item per frame)
+						boolean mediaFound = false;
+						if (mediaType == MediaPhoneProvider.TYPE_AUDIO) {
+							int audioCount = 0;
+							boolean hasSpanningAudio = false;
+							for (MediaItem existingMedia : frameMedia) {
+								if (existingMedia.getType() == MediaPhoneProvider.TYPE_AUDIO) {
+									audioCount += 1;
+									if (existingMedia.getSpanFrames()) {
+										hasSpanningAudio = true;
+										break;
+									}
+								}
+							}
+							if (audioCount >= MediaPhone.MAX_AUDIO_ITEMS || hasSpanningAudio) {
+								mediaFound = true; // over max audio items stops spanning - finished item
+							}
+						} else {
+							for (MediaItem media : frameMedia) {
+								if (media.getType() == mediaType) {
+									mediaFound = true; // any other media overrides spanning - item done
+									break;
+								}
+							}
+						}
+						if (!mediaFound) {
+							// add a linked media element and update the icon of the frame in question
+							MediaManager.addMediaLink(contentResolver, frameId, mediaId);
+							ImageCacheUtilities.setLoadingIcon(FrameItem.getCacheId(frameId)); // for better ui flow
+							iconsToUpdate.add(frameId);
+						} else {
+							break;
+						}
+					}
+				}
+
+				// finally, update icons for changed frames (must be done last so the link no longer exists)
+				FramesManager.reloadFrameIcons(getResources(), contentResolver, iconsToUpdate);
+			}
+		});
+
+		// state has changed, so disabled menu items may be enabled, and vice-versa
+		UIUtilities.refreshActionBar(MediaPhoneActivity.this);
+
+		// finally, return the new media spanning state
+		mediaItem.setSpanFrames(!isFrameSpanning);
+		MediaManager.updateMedia(getContentResolver(), mediaItem);
+		return !isFrameSpanning;
+	}
+
 	private void sendFiles(final ArrayList<Uri> filesToSend) {
 		// send files in a separate task without a dialog so we don't leave the previous progress dialog behind on
 		// screen rotation - this is a bit of a hack, but it works
@@ -880,31 +1494,28 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 		});
 	}
 
-	protected void deleteNarrativeDialog(final String frameInternalId) {
+	protected void deleteNarrativeDialog(final String narrativeInternalId) {
 		AlertDialog.Builder builder = new AlertDialog.Builder(MediaPhoneActivity.this);
 		builder.setTitle(R.string.delete_narrative_confirmation);
 		builder.setMessage(R.string.delete_narrative_hint);
 		builder.setIcon(android.R.drawable.ic_dialog_alert);
-		builder.setNegativeButton(android.R.string.cancel, null);
+		builder.setNegativeButton(R.string.button_cancel, null);
 		builder.setPositiveButton(R.string.button_delete, new DialogInterface.OnClickListener() {
 			@Override
 			public void onClick(DialogInterface dialog, int whichButton) {
-				ContentResolver contentResolver = getContentResolver();
-				FrameItem currentFrame = FramesManager.findFrameByInternalId(contentResolver, frameInternalId);
-				final String narrativeId = currentFrame.getParentId();
-				int numFramesDeleted = FramesManager.countFramesByParentId(contentResolver, narrativeId);
+				int numFramesDeleted = FramesManager.countFramesByParentId(getContentResolver(), narrativeInternalId);
 				AlertDialog.Builder builder = new AlertDialog.Builder(MediaPhoneActivity.this);
 				builder.setTitle(R.string.delete_narrative_second_confirmation);
 				builder.setMessage(getResources().getQuantityString(R.plurals.delete_narrative_second_hint,
 						numFramesDeleted, numFramesDeleted));
 				builder.setIcon(android.R.drawable.ic_dialog_alert);
-				builder.setNegativeButton(android.R.string.cancel, null);
+				builder.setNegativeButton(R.string.button_cancel, null);
 				builder.setPositiveButton(R.string.button_delete, new DialogInterface.OnClickListener() {
 					@Override
 					public void onClick(DialogInterface dialog, int whichButton) {
 						ContentResolver contentResolver = getContentResolver();
 						NarrativeItem narrativeToDelete = NarrativesManager.findNarrativeByInternalId(contentResolver,
-								narrativeId);
+								narrativeInternalId);
 						narrativeToDelete.setDeleted(true);
 						NarrativesManager.updateNarrative(contentResolver, narrativeToDelete);
 						UIUtilities.showToast(MediaPhoneActivity.this, R.string.delete_narrative_succeeded);
@@ -940,7 +1551,7 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 		builder.setTitle(R.string.export_narrative_title);
 		// builder.setMessage(R.string.send_narrative_hint); //breaks dialog
 		builder.setIcon(android.R.drawable.ic_dialog_info);
-		builder.setNegativeButton(android.R.string.cancel, null);
+		builder.setNegativeButton(R.string.button_cancel, null);
 		builder.setItems(items, new DialogInterface.OnClickListener() {
 			@Override
 			public void onClick(DialogInterface dialog, int item) {
@@ -960,7 +1571,7 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 						.replaceAll("[^a-zA-Z0-9]+", "-").toLowerCase(Locale.ENGLISH), exportId);
 
 				Resources res = getResources();
-				final Map<Integer, Object> settings = new Hashtable<Integer, Object>();
+				final Map<Integer, Object> settings = new Hashtable<>();
 				settings.put(MediaUtilities.KEY_AUDIO_RESOURCE_ID, R.raw.ic_audio_playback);
 
 				// some output settings (TODO: make sure HTML version respects these)
@@ -1008,10 +1619,10 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 
 							if (incompatibleAudio) {
 								AlertDialog.Builder builder = new AlertDialog.Builder(MediaPhoneActivity.this);
-								builder.setTitle(android.R.string.dialog_alert_title);
-								builder.setMessage(R.string.mov_export_mov_incompatible);
+								builder.setTitle(R.string.mov_export_mov_incompatible_title);
+								builder.setMessage(R.string.mov_export_mov_incompatible_summary);
 								builder.setIcon(android.R.drawable.ic_dialog_alert);
-								builder.setNegativeButton(android.R.string.cancel, null);
+								builder.setNegativeButton(R.string.button_cancel, null);
 								builder.setPositiveButton(R.string.button_continue,
 										new DialogInterface.OnClickListener() {
 											@Override
@@ -1154,7 +1765,7 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 		} else {
 			mExportNarrativesTask = new ExportNarrativesTask(this);
 			mExportNarrativesTask.addTask(r);
-			mExportNarrativesTask.execute();
+			mExportNarrativesTask.execute(); // TODO: deal with post-4.0 single thread AsyncTask - use executeOnExecutor
 		}
 	}
 
@@ -1219,7 +1830,7 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 	 */
 	protected void runImmediateBackgroundTask(Runnable r) {
 		ImmediateBackgroundRunnerTask backgroundTask = new ImmediateBackgroundRunnerTask(r);
-		backgroundTask.execute();
+		backgroundTask.execute(); // TODO: deal with post-4.0 single thread AsyncTask - use executeOnExecutor
 	}
 
 	protected void runQueuedBackgroundTask(BackgroundRunnable r) {
@@ -1230,7 +1841,7 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 		} else {
 			mBackgroundRunnerTask = new QueuedBackgroundRunnerTask(this);
 			mBackgroundRunnerTask.addTask(r);
-			mBackgroundRunnerTask.execute();
+			mBackgroundRunnerTask.execute(); // TODO: deal with post-4.0 single thread AsyncTask - use executeOnExecutor
 		}
 	}
 
@@ -1258,7 +1869,7 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 			builder.setTitle(R.string.make_template_confirmation);
 			builder.setMessage(R.string.make_template_hint);
 			builder.setIcon(android.R.drawable.ic_dialog_info);
-			builder.setPositiveButton(android.R.string.ok, null);
+			builder.setPositiveButton(R.string.button_ok, null);
 			AlertDialog alert = builder.create();
 			alert.show();
 		}
@@ -1416,7 +2027,7 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 					try {
 						r.run();
 					} catch (Throwable t) {
-						Log.d(DebugUtilities.getLogTag(this),
+						Log.e(DebugUtilities.getLogTag(this),
 								"Error running background task: " + t.getLocalizedMessage());
 					}
 					publishProgress(new int[] { r.getTaskId(), r.getShowDialog() ? 1 : 0, 1 });
@@ -1463,7 +2074,7 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 	}
 
 	private class ImmediateBackgroundRunnerTask extends AsyncTask<Runnable, Void, Void> {
-		private Runnable backgroundTask = null;
+		private Runnable backgroundTask;
 
 		private ImmediateBackgroundRunnerTask(Runnable task) {
 			backgroundTask = task;
@@ -1475,7 +2086,7 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 				try {
 					backgroundTask.run();
 				} catch (Throwable t) {
-					Log.d(DebugUtilities.getLogTag(this), "Error running background task: " + t.getLocalizedMessage());
+					Log.e(DebugUtilities.getLogTag(this), "Error running background task: " + t.getLocalizedMessage());
 				}
 			}
 			return null;
@@ -1519,7 +2130,7 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 					try {
 						r.run();
 					} catch (Throwable t) {
-						Log.d(DebugUtilities.getLogTag(this),
+						Log.e(DebugUtilities.getLogTag(this),
 								"Error running background task: " + t.getLocalizedMessage());
 					}
 					publishProgress(new int[] { r.getTaskId(), r.getShowDialog() ? 1 : 0, 1 });
@@ -1577,8 +2188,18 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 		public abstract boolean getShowDialog();
 	}
 
-	protected Runnable getMediaCleanupRunnable() {
-		return new Runnable() {
+	protected BackgroundRunnable getMediaCleanupRunnable() {
+		return new BackgroundRunnable() {
+			@Override
+			public int getTaskId() {
+				return 0;
+			}
+
+			@Override
+			public boolean getShowDialog() {
+				return false;
+			}
+
 			@Override
 			public void run() {
 				ContentResolver contentResolver = getContentResolver();
@@ -1595,13 +2216,15 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 				}
 
 				// find media marked as deleted, and also media whose parent frame is marked as deleted
+				// (but not inherited links)
 				ArrayList<String> deletedMedia = MediaManager.findDeletedMedia(contentResolver);
 				for (String frameId : deletedFrames) {
-					deletedMedia.addAll(MediaManager.findMediaIdsByParentId(contentResolver, frameId));
+					deletedMedia.addAll(MediaManager.findMediaIdsByParentId(contentResolver, frameId, false));
 				}
 
-				// delete the actual media items on disk and from the database
+				// delete the actual media items on disk and the items and any links to them from the database
 				int deletedMediaCount = 0;
+				int deletedLinkCount = 0;
 				for (String mediaId : deletedMedia) {
 					final MediaItem mediaToDelete = MediaManager.findMediaByInternalId(contentResolver, mediaId);
 					if (mediaToDelete != null) {
@@ -1613,6 +2236,15 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 						}
 						MediaManager.deleteMediaFromBackgroundTask(contentResolver, mediaId);
 					}
+
+					// links should have already been removed, but we might as well check for stragglers
+					deletedLinkCount += MediaManager.deleteMediaLinks(contentResolver, mediaId);
+				}
+
+				// remove links marked as deleted
+				ArrayList<String> deletedLinks = MediaManager.findDeletedMediaLinks(contentResolver);
+				for (String linkId : deletedLinks) {
+					MediaManager.deleteMediaLinkFromBackgroundTask(contentResolver, linkId);
 				}
 
 				// delete the actual frame items on disk and from the database
@@ -1643,106 +2275,12 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 				Log.i(DebugUtilities.getLogTag(this), "Media cleanup: removed " + deletedNarratives.size() + "/"
 						+ deletedTemplates.size() + " narratives/templates, " + deletedFrames.size() + " ("
 						+ deletedFrameCount + ") frames, and " + deletedMedia.size() + " (" + deletedMediaCount
-						+ ") media items");
-			}
-		};
-	}
-
-	protected BackgroundRunnable getFrameSplitterRunnable(final String currentMediaItemInternalId) {
-		return new BackgroundRunnable() {
-			@Override
-			public int getTaskId() {
-				return R.id.split_frame_task_complete;
-			}
-
-			@Override
-			public boolean getShowDialog() {
-				return true;
-			}
-
-			@Override
-			public void run() {
-				// get the current media item and its parent
-				ContentResolver contentResolver = getContentResolver();
-				Resources resources = getResources();
-				MediaItem currentMediaItem = MediaManager.findMediaByInternalId(contentResolver,
-						currentMediaItemInternalId);
-				FrameItem parentFrame = FramesManager.findFrameByInternalId(contentResolver,
-						currentMediaItem.getParentId());
-				String parentFrameInternalId = parentFrame.getInternalId();
-				ArrayList<MediaItem> frameComponents = MediaManager.findMediaByParentId(contentResolver,
-						parentFrameInternalId);
-
-				// get all the frames in this narrative
-				ArrayList<FrameItem> narrativeFrames = FramesManager.findFramesByParentId(contentResolver,
-						parentFrame.getParentId());
-
-				// if the new frame is the first frame, we need to update the second frame's icon, as it's possible
-				// that this task was launched by adding a frame at the start of the narrative
-				if (narrativeFrames.size() >= 2) {
-					if (narrativeFrames.get(0).getInternalId().equals(currentMediaItemInternalId)) {
-						FramesManager.reloadFrameIcon(resources, contentResolver, narrativeFrames.get(1), true);
-					}
-				}
-
-				// insert new frame - increment necessary frames after the new frame's position
-				boolean frameFound = false;
-				int newFrameSequenceId = 0;
-				int previousNarrativeSequenceId = 0;
-				for (FrameItem frame : narrativeFrames) {
-					if (!frameFound && (parentFrameInternalId.equals(frame.getInternalId()))) {
-						frameFound = true;
-						newFrameSequenceId = frame.getNarrativeSequenceId();
-					}
-					if (frameFound) {
-						if (newFrameSequenceId <= frame.getNarrativeSequenceId()
-								|| frame.getNarrativeSequenceId() <= previousNarrativeSequenceId) {
-
-							frame.setNarrativeSequenceId(frame.getNarrativeSequenceId() + 1);
-							FramesManager.updateFrame(contentResolver, frame);
-							previousNarrativeSequenceId = frame.getNarrativeSequenceId();
-						} else {
-							break;
-						}
-					}
-				}
-
-				// create a new frame and move all the old media to it
-				FrameItem newFrame = new FrameItem(parentFrame.getParentId(), newFrameSequenceId);
-				String newFrameInternalId = newFrame.getInternalId();
-				for (MediaItem currentItem : frameComponents) {
-					// need to know where the existing file is stored before editing the database record
-					if (!currentMediaItemInternalId.equals(currentItem.getInternalId())) {
-						File tempMediaFile = currentItem.getFile();
-						currentItem.setParentId(newFrameInternalId);
-						tempMediaFile.renameTo(currentItem.getFile());
-						MediaManager.updateMedia(contentResolver, currentItem);
-					}
-				}
-
-				// the current media item is a special case - need to silently create a new copy
-				String newMediaItemId = MediaPhoneProvider.getNewInternalId();
-				File tempMediaFile = currentMediaItem.getFile();
-
-				currentMediaItem.setParentId(newFrameInternalId);
-				MediaManager.updateMedia(contentResolver, currentMediaItem);
-
-				MediaManager.changeMediaId(contentResolver, currentMediaItemInternalId, newMediaItemId);
-				File newMediaFile = MediaItem.getFile(newFrameInternalId, newMediaItemId,
-						currentMediaItem.getFileExtension());
-				tempMediaFile.renameTo(newMediaFile);
-
-				MediaManager.addMedia(contentResolver, new MediaItem(currentMediaItemInternalId, parentFrameInternalId,
-						currentMediaItem.getFileExtension(), currentMediaItem.getType()));
-
-				// add the frame and regenerate the icon
-				FramesManager.addFrame(resources, contentResolver, newFrame, true);
+						+ ") media items (" + deletedLinks.size() + "/" + deletedLinkCount + " links)");
 			}
 		};
 	}
 
-	protected BackgroundRunnable getNarrativeTemplateRunnable(final String fromId, final String toId,
-			final boolean toTemplate) {
+	protected BackgroundRunnable getNarrativeTemplateRunnable(final String fromId, final boolean toTemplate) {
 		return new BackgroundRunnable() {
 			@Override
 			public int getTaskId() {
@@ -1760,6 +2298,7 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 				Resources resources = getResources();
 				ArrayList<FrameItem> narrativeFrames = FramesManager.findFramesByParentId(contentResolver, fromId);
 
+				final String toId = MediaPhoneProvider.getNewInternalId();
 				final NarrativeItem newItem;
 				if (toTemplate) {
 					newItem = new NarrativeItem(toId, NarrativesManager.getNextTemplateExternalId(contentResolver));
@@ -1771,8 +2310,9 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 				final long newCreationDate = newItem.getCreationDate();
 
 				boolean updateFirstFrame = true;
-				ArrayList<String> fromFiles = new ArrayList<String>();
-				ArrayList<String> toFiles = new ArrayList<String>();
+				ArrayList<String> fromFiles = new ArrayList<>();
+				ArrayList<String> toFiles = new ArrayList<>();
+				HashMap<String, String> linkedMedia = new HashMap<>();
 				for (FrameItem frame : narrativeFrames) {
 					final FrameItem newFrame = FrameItem.fromExisting(frame, MediaPhoneProvider.getNewInternalId(),
 							toId, newCreationDate);
@@ -1787,26 +2327,39 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 					}
 
 					for (MediaItem media : MediaManager.findMediaByParentId(contentResolver, frame.getInternalId())) {
-						final MediaItem newMedia = MediaItem.fromExisting(media, MediaPhoneProvider.getNewInternalId(),
-								newFrameId, newCreationDate);
-						MediaManager.addMedia(contentResolver, newMedia);
-						if (updateFirstFrame) {
-							// must always copy the first frame's media
-							try {
-								IOUtilities.copyFile(media.getFile(), newMedia.getFile());
-							} catch (IOException e) {
-								// TODO: error
+						// this is a linked item - create a new link rather than copying media
+						boolean spanningMedia = media.getSpanFrames();
+						if (spanningMedia && !media.getParentId().equals(frame.getInternalId())) {
+							final String linkedId = linkedMedia.get(media.getInternalId()); // get the new linked id;
+							if (linkedId != null) {
+								MediaManager.addMediaLink(contentResolver, newFrameId, linkedId);
 							}
 						} else {
-							// queue copying other media
-							fromFiles.add(media.getFile().getAbsolutePath());
-							try {
-								newMedia.getFile().createNewFile(); // add an empty file so that if they open the item
-																	// before copying completes it won't get deleted
-							} catch (IOException e) {
-								// TODO: error
+							final MediaItem newMedia = MediaItem.fromExisting(media,
+									MediaPhoneProvider.getNewInternalId(), newFrameId, newCreationDate);
+							MediaManager.addMedia(contentResolver, newMedia);
+							if (spanningMedia) {
+								linkedMedia.put(media.getInternalId(), newMedia.getInternalId()); // for copying links
+							}
+							if (updateFirstFrame) {
+								// must always copy the first frame's media
+								try {
+									IOUtilities.copyFile(media.getFile(), newMedia.getFile());
+								} catch (IOException e) {
+									// TODO: error
+								}
+							} else {
+								// queue copying other media
+								fromFiles.add(media.getFile().getAbsolutePath());
+								try {
+									newMedia.getFile().createNewFile(); // add an empty file so that if they open the
+																		// item before copying it won't get deleted
+																		// TODO: checking length() > 0 negates this...
+								} catch (IOException e) {
+									// TODO: error
+								}
+								toFiles.add(newMedia.getFile().getAbsolutePath());
 							}
-							toFiles.add(newMedia.getFile().getAbsolutePath());
 						}
 					}
 					FramesManager.addFrame(resources, contentResolver, newFrame, updateFirstFrame);
@@ -1850,30 +2403,6 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 		};
 	}
 
-	protected BackgroundRunnable getFrameIconUpdaterRunnable(final String frameInternalId) {
-		return new BackgroundRunnable() {
-			@Override
-			public int getTaskId() {
-				return 0;
-			}
-
-			@Override
-			public boolean getShowDialog() {
-				return false;
-			}
-
-			@Override
-			public void run() {
-				// update the icon
-				ContentResolver contentResolver = getContentResolver();
-				FrameItem thisFrame = FramesManager.findFrameByInternalId(contentResolver, frameInternalId);
-				if (thisFrame != null) { // if run from switchFrames then the existing frame could have been deleted
-					FramesManager.reloadFrameIcon(getResources(), contentResolver, thisFrame, true);
-				}
-			}
-		};
-	}
-
 	protected BackgroundRunnable getMediaLibraryAdderRunnable(final String mediaPath, final String outputDirectoryType) {
 		return new BackgroundRunnable() {
 			@Override
@@ -1915,14 +2444,26 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 		};
 	}
 
+	public static enum FadeType {
+		NONE, FADEIN // CROSSFADE - disabled because of memory issues (holding previous and next bitmaps in memory)
+	}
+
 	protected void loadScreenSizedImageInBackground(ImageView imageView, String imagePath,
-			boolean forceReloadSameImage, boolean fadeIn) {
+			boolean forceReloadSameImage, FadeType fadeType) {
 		// forceReloadSameImage is for, e.g., reloading image after rotation (normally this extra load would be ignored)
 		if (cancelExistingTask(imagePath, imageView, forceReloadSameImage)) {
-			final BitmapLoaderTask task = new BitmapLoaderTask(imageView, fadeIn);
+			final BitmapLoaderTask task = new BitmapLoaderTask(imageView, fadeType);
 			final BitmapLoaderHolder loaderTaskHolder = new BitmapLoaderHolder(task);
 			imageView.setTag(loaderTaskHolder);
-			task.execute(imagePath);
+			task.execute(imagePath); // TODO: deal with post-4.0 single thread AsyncTask - use executeOnExecutor
+		}
+	}
+
+	protected void cancelLoadingScreenSizedImageInBackground(ImageView imageView) {
+		final BitmapLoaderTask bitmapLoaderTask = getBitmapLoaderTask(imageView);
+		if (bitmapLoaderTask != null) {
+			bitmapLoaderTask.cancel(true);
+			imageView.setTag(null); // clear the tag to signal that we've finished/cancelled loading
 		}
 	}
 
@@ -1932,6 +2473,7 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 			final String loadingImagePath = bitmapLoaderTask.mImagePath;
 			if (imagePath != null && (forceReload || !imagePath.equals(loadingImagePath))) {
 				bitmapLoaderTask.cancel(true); // cancel previous task for this ImageView
+				imageView.setTag(null); // clear the tag to signal that we've finished/cancelled loading
 			} else {
 				return false; // already loading the same image (or new path is null)
 			}
@@ -1952,44 +2494,68 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 
 	private class BitmapLoaderTask extends AsyncTask<String, Void, Bitmap> {
 		private final WeakReference<ImageView> mImageView; // WeakReference to allow garbage collection
-		private boolean mFadeIn;
+		private FadeType mFadeType;
 
 		public String mImagePath;
 
-		public BitmapLoaderTask(ImageView imageView, boolean fadeIn) {
-			mImageView = new WeakReference<ImageView>(imageView);
-			mFadeIn = fadeIn;
+		public BitmapLoaderTask(ImageView imageView, FadeType fadeType) {
+			mImageView = new WeakReference<>(imageView);
+			mFadeType = fadeType;
 		}
 
 		@Override
 		protected Bitmap doInBackground(String... params) {
 			mImagePath = params[0];
 			Point screenSize = UIUtilities.getScreenSize(getWindowManager());
-			return BitmapUtilities.loadAndCreateScaledBitmap(mImagePath, screenSize.x, screenSize.y,
-					BitmapUtilities.ScalingLogic.FIT, true);
+			try {
+				return BitmapUtilities.loadAndCreateScaledBitmap(mImagePath, screenSize.x, screenSize.y,
+						BitmapUtilities.ScalingLogic.FIT, true);
+			} catch (Throwable t) {
+				return null; // out of memory...
+			}
 		}
 
 		@Override
 		protected void onPostExecute(Bitmap bitmap) {
 			if (isCancelled()) {
+				if (bitmap != null) {
+					bitmap.recycle();
+				}
 				bitmap = null;
+				return;
 			}
 
 			if (mImageView != null && bitmap != null) {
 				final ImageView imageView = mImageView.get();
 				final BitmapLoaderTask bitmapLoaderTask = getBitmapLoaderTask(imageView);
 				if (this == bitmapLoaderTask && imageView != null) {
-					if (mFadeIn) {
+					if (mFadeType == FadeType.NONE) {
+						imageView.setImageBitmap(bitmap);
+					} else {
+						// Drawable currentDrawable = imageView.getDrawable();
+						// final Bitmap initialState;
+						// if (currentDrawable instanceof BitmapDrawable) {
+						// initialState = ((BitmapDrawable) currentDrawable).getBitmap();
+						// } else if (currentDrawable instanceof CrossFadeDrawable) {
+						// initialState = ((CrossFadeDrawable) currentDrawable).getEnd();
+						// } else {
+						// initialState = Bitmap.createBitmap(1, 1,
+						// ImageCacheUtilities.mBitmapFactoryOptions.inPreferredConfig);
+						// }
 						final CrossFadeDrawable transition = new CrossFadeDrawable(Bitmap.createBitmap(1, 1,
-								ImageCacheUtilities.mBitmapFactoryOptions.inPreferredConfig), bitmap);
+								Bitmap.Config.ALPHA_8), bitmap);
 						transition.setCallback(imageView);
-						transition.setCrossFadeEnabled(true);
+						// if (mFadeType == FadeType.CROSSFADE) {
+						// transition.setCrossFadeEnabled(true);
+						// } else {
+						// transition.setCrossFadeEnabled(false);
+						// }
 						transition.startTransition(MediaPhone.ANIMATION_FADE_TRANSITION_DURATION);
 						imageView.setImageDrawable(transition);
-					} else {
-						imageView.setImageBitmap(bitmap);
 					}
 				}
+
+				imageView.setTag(null); // clear the tag to signal that we've finished loading
 			}
 		}
 	}
@@ -1998,7 +2564,7 @@ public abstract class MediaPhoneActivity extends FragmentActivity {
 		private final WeakReference<BitmapLoaderTask> bitmapWorkerTaskReference;
 
 		public BitmapLoaderHolder(BitmapLoaderTask bitmapWorkerTask) {
-			bitmapWorkerTaskReference = new WeakReference<BitmapLoaderTask>(bitmapWorkerTask);
+			bitmapWorkerTaskReference = new WeakReference<>(bitmapWorkerTask);
 		}
 
 		public BitmapLoaderTask getBitmapWorkerTask() {
diff --git a/src/ac/robinson/mediaphone/MediaPhoneApplication.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/MediaPhoneApplication.java
similarity index 98%
rename from src/ac/robinson/mediaphone/MediaPhoneApplication.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/MediaPhoneApplication.java
index 645c698..7462b57 100644
--- a/src/ac/robinson/mediaphone/MediaPhoneApplication.java
+++ b/MediaPhone/src/main/java/ac/robinson/mediaphone/MediaPhoneApplication.java
@@ -39,6 +39,7 @@ import android.content.IntentFilter;
 import android.content.ServiceConnection;
 import android.content.SharedPreferences;
 import android.content.res.Resources;
+import android.os.Build;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.IBinder;
@@ -74,7 +75,7 @@ public class MediaPhoneApplication extends Application {
 
 	@Override
 	public void onCreate() {
-		if (MediaPhone.DEBUG) {
+		if (MediaPhone.DEBUG && Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {
 			StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder().detectAll().penaltyLog().build());
 			StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder().detectAll().penaltyLog().penaltyDeath().build());
 		}
@@ -186,7 +187,7 @@ public class MediaPhoneApplication extends Application {
 			mCurrentActivity.clear();
 			mCurrentActivity = null;
 		}
-		mCurrentActivity = new WeakReference<MediaPhoneActivity>(activity);
+		mCurrentActivity = new WeakReference<>(activity);
 		for (MessageContainer msg : mSavedMessages) {
 			// must duplicate the data here, or we crash
 			Message clientMessage = Message.obtain(null, msg.what, 0, 0);
diff --git a/src/ac/robinson/mediaphone/activity/AudioActivity.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/activity/AudioActivity.java
similarity index 84%
rename from src/ac/robinson/mediaphone/activity/AudioActivity.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/activity/AudioActivity.java
index a88d91d..aaa6786 100644
--- a/src/ac/robinson/mediaphone/activity/AudioActivity.java
+++ b/MediaPhone/src/main/java/ac/robinson/mediaphone/activity/AudioActivity.java
@@ -50,7 +50,6 @@ import android.app.AlertDialog;
 import android.content.ActivityNotFoundException;
 import android.content.ContentProviderClient;
 import android.content.ContentResolver;
-import android.content.Context;
 import android.content.DialogInterface;
 import android.content.Intent;
 import android.content.SharedPreferences;
@@ -76,9 +75,7 @@ import android.util.Log;
 import android.view.Menu;
 import android.view.MenuInflater;
 import android.view.MenuItem;
-import android.view.MotionEvent;
 import android.view.View;
-import android.view.ViewConfiguration;
 import android.widget.RelativeLayout;
 import android.widget.TextView;
 
@@ -88,15 +85,14 @@ public class AudioActivity extends MediaPhoneActivity {
 
 	private String mMediaItemInternalId;
 	private boolean mHasEditedMedia = false;
-	private boolean mShowOptionsMenu = false;
-	private boolean mSwitchedFrames = false;
 	private boolean mAudioPickerShown = false;
 
 	private boolean mRecordingIsAllowed; // TODO: currently extension-based, but we can't actually process all AAC files
+	private boolean mFrameSpanningPrevented;
 	private boolean mDoesNotHaveMicrophone;
 	private PathAndStateSavingMediaRecorder mMediaRecorder;
 	private MediaPlayer mMediaPlayer;
-	private NoSwipeCustomMediaController mMediaController;
+	private CustomMediaController mMediaController;
 	private TextView mRecordingDurationText;
 	private Handler mTextUpdateHandler = new TextUpdateHandler();
 	private ScheduledThreadPoolExecutor mAudioTextScheduler;
@@ -107,11 +103,7 @@ public class AudioActivity extends MediaPhoneActivity {
 	private ScheduledThreadPoolExecutor mButtonIconBlinkScheduler;
 	private int mNextBlinkMode = R.id.msg_blink_icon_off;
 
-	private Handler mSwipeEnablerHandler = new SwipeEnablerHandler();
-	private boolean mSwitchingFrames;
-	private int mSwitchFrameDirection;
-	private boolean mSwitchFrameShowOptionsMenu;
-	private boolean mContinueRecordingAfterSplit;
+	private boolean mContinueRecordingAfterSplit; // for tracking recording state when adding a frame after
 
 	// loaded properly from preferences on initialisation
 	private boolean mAddToMediaLibrary = false;
@@ -122,7 +114,7 @@ public class AudioActivity extends MediaPhoneActivity {
 	};
 
 	private enum AfterRecordingMode {
-		DO_NOTHING, SWITCH_TO_PLAYBACK, SPLIT_FRAME, SWITCH_FRAME
+		DO_NOTHING, SWITCH_TO_PLAYBACK, ADD_FRAME_AFTER
 	};
 
 	private DisplayMode mDisplayMode;
@@ -130,9 +122,6 @@ public class AudioActivity extends MediaPhoneActivity {
 	@Override
 	protected void onCreate(Bundle savedInstanceState) {
 		super.onCreate(savedInstanceState);
-		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
-			setTheme(R.style.default_light_theme); // light looks *much* better beyond honeycomb
-		}
 		UIUtilities.configureActionBar(this, true, true, R.string.title_frame_editor, R.string.title_audio);
 		setContentView(R.layout.audio_view);
 
@@ -144,20 +133,28 @@ public class AudioActivity extends MediaPhoneActivity {
 		mRecordingDurationText = ((TextView) findViewById(R.id.audio_recording_progress));
 		mDisplayMode = DisplayMode.PLAY_AUDIO;
 		mMediaItemInternalId = null;
-		mShowOptionsMenu = false;
-		mSwitchedFrames = false;
 
 		// load previous id on screen rotation
 		if (savedInstanceState != null) {
 			mMediaItemInternalId = savedInstanceState.getString(getString(R.string.extra_internal_id));
 			mHasEditedMedia = savedInstanceState.getBoolean(getString(R.string.extra_media_edited), true);
-			mSwitchedFrames = savedInstanceState.getBoolean(getString(R.string.extra_switched_frames));
 			mAudioPickerShown = savedInstanceState.getBoolean(getString(R.string.extra_external_chooser_shown), false);
 			if (mHasEditedMedia) {
 				setBackButtonIcons(AudioActivity.this, R.id.button_finished_audio, R.id.button_cancel_recording, true);
 			}
 		}
 
+		// prevent spanning if appropriate
+		Intent launchIntent = getIntent();
+		if (launchIntent != null) {
+			// hide the spanning button if we're not allowed to span from this item
+			mFrameSpanningPrevented = launchIntent.getBooleanExtra(getString(R.string.extra_prevent_frame_spanning),
+					false);
+			if (mFrameSpanningPrevented) {
+				findViewById(R.id.button_toggle_mode_audio).setVisibility(View.GONE);
+			}
+		}
+
 		// load the media itself
 		loadMediaContainer();
 	}
@@ -167,23 +164,10 @@ public class AudioActivity extends MediaPhoneActivity {
 		// no need to save display mode as we don't allow rotation when actually recording
 		savedInstanceState.putString(getString(R.string.extra_internal_id), mMediaItemInternalId);
 		savedInstanceState.putBoolean(getString(R.string.extra_media_edited), mHasEditedMedia);
-		savedInstanceState.putBoolean(getString(R.string.extra_switched_frames), mSwitchedFrames);
 		savedInstanceState.putBoolean(getString(R.string.extra_external_chooser_shown), mAudioPickerShown);
 		super.onSaveInstanceState(savedInstanceState);
 	}
 
-	@Override
-	public void onWindowFocusChanged(boolean hasFocus) {
-		super.onWindowFocusChanged(hasFocus);
-		if (hasFocus) {
-			if (mShowOptionsMenu) {
-				mShowOptionsMenu = false;
-				openOptionsMenu();
-			}
-			registerForSwipeEvents(); // here to avoid crashing due to double-swiping
-		}
-	}
-
 	// @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1) is for callOnClick()
 	@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
 	@Override
@@ -222,9 +206,13 @@ public class AudioActivity extends MediaPhoneActivity {
 		if (audioMediaItem != null) {
 			switch (mDisplayMode) {
 				case PLAY_AUDIO:
-					// deleted the picture (media item already set deleted) - update the icon
-					if (mHasEditedMedia) {
-						runImmediateBackgroundTask(getFrameIconUpdaterRunnable(audioMediaItem.getParentId()));
+					if (audioMediaItem.getDeleted()) {
+						// we've been deleted - propagate changes to our parent frame and any following frames
+						inheritMediaAndDeleteItemLinks(audioMediaItem.getParentId(), audioMediaItem, null);
+					} else if (mHasEditedMedia) {
+						// imported or otherwise edited the audio - update icons
+						// TODO: we could just update when the audio is added or removed; audio edits don't change icons
+						updateMediaFrameIcons(audioMediaItem, null);
 					}
 					break;
 
@@ -237,7 +225,9 @@ public class AudioActivity extends MediaPhoneActivity {
 						if (audioMediaItem.getFile().length() > 0) {
 							// recorded new audio (rather than just cancelling the recording) - update the icon
 							if (mHasEditedMedia) {
-								runImmediateBackgroundTask(getFrameIconUpdaterRunnable(audioMediaItem.getParentId()));
+								// update this frame's icon to show audio; propagate to following frames if applicable
+								// TODO: we could just update when the audio is added or removed; edits not needed
+								updateMediaFrameIcons(audioMediaItem, null);
 								setBackButtonIcons(AudioActivity.this, R.id.button_finished_audio,
 										R.id.button_cancel_recording, true);
 
@@ -245,60 +235,54 @@ public class AudioActivity extends MediaPhoneActivity {
 								// mHasEditedMedia = false; // we've saved the icon, so are no longer in edit mode
 							}
 
-							// show hint after recording, but not if switching frames (will get shown over frame editor)
-							switchToPlayback(!mSwitchingFrames);
-							return;
+							// show hint after recording
+							switchToPlayback(true);
+							return; // we're not exiting yet, but playing the just-recorded audio
 
 						} else {
 							// so we don't leave an empty stub
 							audioMediaItem.setDeleted(true);
 							MediaManager.updateMedia(contentResolver, audioMediaItem);
+
+							// we've been deleted - propagate changes to our parent frame and any following frames
+							inheritMediaAndDeleteItemLinks(audioMediaItem.getParentId(), audioMediaItem, null);
 						}
 					}
 					break;
 			}
 
-			saveLastEditedFrame(audioMediaItem != null ? audioMediaItem.getParentId() : null);
+			// save the id of the frame we're part of so that the frame editor gets notified
+			saveLastEditedFrame(audioMediaItem.getParentId());
 		}
 
-		if (mSwitchingFrames) { // so the parent exits too (or we end up with multiple copies of the frame editor)
-			setResult(mHasEditedMedia ? R.id.result_audio_ok_exit : R.id.result_audio_cancelled_exit);
-		} else {
-			setResult(mHasEditedMedia ? Activity.RESULT_OK : Activity.RESULT_CANCELED);
-		}
+		setResult(mHasEditedMedia ? Activity.RESULT_OK : Activity.RESULT_CANCELED);
 		super.onBackPressed();
 	}
 
 	@Override
 	public boolean onCreateOptionsMenu(Menu menu) {
 		MenuInflater inflater = getMenuInflater();
-		setupMenuNavigationButtonsFromMedia(inflater, menu, getContentResolver(), mMediaItemInternalId, mHasEditedMedia);
+		createMediaMenuNavigationButtons(inflater, menu, mHasEditedMedia);
 		return super.onCreateOptionsMenu(menu);
 	}
 
 	@Override
-	public boolean onOptionsItemSelected(MenuItem item) {
-		final int itemId = item.getItemId();
-		switch (itemId) {
-			case R.id.menu_previous_frame:
-			case R.id.menu_next_frame:
-				performSwitchFrames(itemId, true);
-				return true;
+	public boolean onPrepareOptionsMenu(Menu menu) {
+		prepareMediaMenuNavigationButtons(menu, mMediaItemInternalId);
+		return super.onPrepareOptionsMenu(menu);
+	}
 
+	@Override
+	public boolean onOptionsItemSelected(MenuItem item) {
+		switch (item.getItemId()) {
 			case R.id.menu_add_frame:
 				if (mAudioRecordingInProgress) {
 					findViewById(R.id.button_record_audio).setEnabled(false);
 					mContinueRecordingAfterSplit = true;
-					stopRecording(AfterRecordingMode.SPLIT_FRAME);
+					stopRecording(AfterRecordingMode.ADD_FRAME_AFTER);
 				} else {
-					MediaItem audioMediaItem = MediaManager.findMediaByInternalId(getContentResolver(),
-							mMediaItemInternalId);
-					if (audioMediaItem != null && audioMediaItem.getFile().length() > 0) {
-						mContinueRecordingAfterSplit = false;
-						runQueuedBackgroundTask(getFrameSplitterRunnable(mMediaItemInternalId));
-					} else {
-						UIUtilities.showToast(AudioActivity.this, R.string.split_audio_add_content);
-					}
+					mContinueRecordingAfterSplit = false;
+					addFrameAfter();
 				}
 				return true;
 
@@ -363,6 +347,7 @@ public class AudioActivity extends MediaPhoneActivity {
 		// first launch
 		ContentResolver contentResolver = getContentResolver();
 		boolean firstLaunch = mMediaItemInternalId == null;
+		boolean startRecording = false;
 		if (firstLaunch) {
 
 			// editing an existing frame
@@ -372,11 +357,7 @@ public class AudioActivity extends MediaPhoneActivity {
 			if (intent != null) {
 				parentInternalId = intent.getStringExtra(getString(R.string.extra_parent_id));
 				mediaInternalId = intent.getStringExtra(getString(R.string.extra_internal_id));
-				mShowOptionsMenu = intent.getBooleanExtra(getString(R.string.extra_show_options_menu), false);
-				mSwitchedFrames = intent.getBooleanExtra(getString(R.string.extra_switched_frames), false);
-				if (mSwitchedFrames) {
-					firstLaunch = false; // so we don't show hints
-				}
+				startRecording = intent.getBooleanExtra(getString(R.string.extra_start_recording_audio), false);
 			}
 			if (parentInternalId == null) {
 				UIUtilities.showToast(AudioActivity.this, R.string.error_loading_audio_editor);
@@ -399,6 +380,8 @@ public class AudioActivity extends MediaPhoneActivity {
 		// load the existing audio
 		final MediaItem audioMediaItem = MediaManager.findMediaByInternalId(contentResolver, mMediaItemInternalId);
 		if (audioMediaItem != null) {
+			updateSpanFramesButtonIcon(R.id.button_toggle_mode_audio, audioMediaItem.getSpanFrames(), false);
+
 			mRecordingIsAllowed = true;
 			final File currentFile = audioMediaItem.getFile();
 			if (currentFile.length() > 0) {
@@ -409,7 +392,10 @@ public class AudioActivity extends MediaPhoneActivity {
 				if (mDoesNotHaveMicrophone && firstLaunch) {
 					UIUtilities.showToast(AudioActivity.this, R.string.error_recording_audio_no_microphone, true);
 				}
-				switchToRecording(currentFile);
+				boolean initialised = switchToRecording(currentFile);
+				if (initialised && startRecording) {
+					startRecording();
+				}
 			}
 		} else {
 			UIUtilities.showToast(AudioActivity.this, R.string.error_loading_audio_editor);
@@ -452,11 +438,11 @@ public class AudioActivity extends MediaPhoneActivity {
 		return true;
 	}
 
-	private void switchToRecording(File currentFile) {
+	private boolean switchToRecording(File currentFile) {
 		if (!mRecordingIsAllowed) { // can only edit m4a
 			// could switch to import automatically here, but it's probably confusing UI-wise to do that
 			UIUtilities.showToast(AudioActivity.this, R.string.retake_audio_forbidden, true);
-			return;
+			return false;
 		}
 
 		releasePlayer();
@@ -473,7 +459,7 @@ public class AudioActivity extends MediaPhoneActivity {
 				// - this is probably a rare issue, but very frustrating when it does happen
 				importAudio();
 			}
-			return;
+			return false;
 		}
 
 		// disable screen rotation and screen sleeping while in the recorder
@@ -485,12 +471,14 @@ public class AudioActivity extends MediaPhoneActivity {
 		mMediaRecorder = new PathAndStateSavingMediaRecorder();
 
 		// always record into a temporary file, then combine later
-		if (initialiseAudioRecording(currentFile)) {
+		boolean initialised = initialiseAudioRecording(currentFile);
+		if (initialised) {
 			findViewById(R.id.audio_preview_container).setVisibility(View.GONE);
 			findViewById(R.id.audio_preview_controls).setVisibility(View.GONE);
 			findViewById(R.id.audio_recording).setVisibility(View.VISIBLE);
 			findViewById(R.id.audio_recording_controls).setVisibility(View.VISIBLE);
 		}
+		return initialised;
 	}
 
 	// @TargetApi(Build.VERSION_CODES.GINGERBREAD_MR1) is for AAC/HE_AAC audio recording
@@ -615,7 +603,7 @@ public class AudioActivity extends MediaPhoneActivity {
 				scheduleNextAudioTextUpdate(getResources().getInteger(R.integer.audio_timer_update_interval));
 				CenteredImageTextButton recordButton = (CenteredImageTextButton) findViewById(R.id.button_record_audio);
 				recordButton.setEnabled(true);
-				recordButton.setCompoundDrawablesWithIntrinsicBounds(0, R.drawable.ic_pause, 0, 0);
+				recordButton.setCompoundDrawablesWithIntrinsicBounds(0, R.drawable.ic_audio_pause, 0, 0);
 			}
 		});
 	}
@@ -629,7 +617,7 @@ public class AudioActivity extends MediaPhoneActivity {
 		mAudioRecordingInProgress = false;
 		CenteredImageTextButton recordButton = (CenteredImageTextButton) findViewById(R.id.button_record_audio);
 		recordButton.setEnabled(true);
-		recordButton.setCompoundDrawablesWithIntrinsicBounds(0, R.drawable.ic_record, 0, 0);
+		recordButton.setCompoundDrawablesWithIntrinsicBounds(0, R.drawable.ic_audio_record, 0, 0);
 		UIUtilities.releaseKeepScreenOn(getWindow());
 	}
 
@@ -700,11 +688,9 @@ public class AudioActivity extends MediaPhoneActivity {
 			if (afterRecordingMode == AfterRecordingMode.SWITCH_TO_PLAYBACK) {
 				onBackPressed();
 				return;
-			} else if (afterRecordingMode == AfterRecordingMode.SPLIT_FRAME) {
-				runQueuedBackgroundTask(getFrameSplitterRunnable(mMediaItemInternalId));
-				return;
-			} else if (afterRecordingMode == AfterRecordingMode.SWITCH_FRAME) {
-				completeSwitchFrames();
+			} else if (afterRecordingMode == AfterRecordingMode.ADD_FRAME_AFTER) {
+				switchToPlayback(false); // first switch to playback, so we exit from addFrameAfter()
+				addFrameAfter();
 				return;
 			} else if (afterRecordingMode == AfterRecordingMode.DO_NOTHING && !mRecordingIsAllowed) {
 				onBackPressed();
@@ -735,10 +721,8 @@ public class AudioActivity extends MediaPhoneActivity {
 					switch (afterRecordingMode) {
 						case SWITCH_TO_PLAYBACK:
 							return R.id.audio_switch_to_playback_task_complete;
-						case SPLIT_FRAME:
-							return R.id.split_frame_task_complete;
-						case SWITCH_FRAME:
-							return R.id.audio_switch_frame_task_complete;
+						case ADD_FRAME_AFTER:
+							return R.id.audio_add_frame_after_task_complete;
 						case DO_NOTHING:
 							if (!mRecordingIsAllowed) {
 								return R.id.audio_switch_to_playback_task_complete;
@@ -751,8 +735,7 @@ public class AudioActivity extends MediaPhoneActivity {
 				public boolean getShowDialog() {
 					switch (afterRecordingMode) {
 						case SWITCH_TO_PLAYBACK:
-						case SPLIT_FRAME:
-						case SWITCH_FRAME:
+						case ADD_FRAME_AFTER:
 							return true;
 						case DO_NOTHING:
 							if (!mRecordingIsAllowed) {
@@ -807,11 +790,6 @@ public class AudioActivity extends MediaPhoneActivity {
 						if (MediaPhone.DEBUG)
 							Log.d(DebugUtilities.getLogTag(this), "Append audio: Throwable");
 					}
-
-					// split the frame if necessary
-					if (afterRecordingMode == AfterRecordingMode.SPLIT_FRAME) {
-						getFrameSplitterRunnable(mMediaItemInternalId).run();
-					}
 				}
 			});
 		}
@@ -843,30 +821,9 @@ public class AudioActivity extends MediaPhoneActivity {
 			case R.id.audio_switch_to_playback_task_complete:
 				onBackPressed();
 				break;
-			case R.id.split_frame_task_complete:
-				// reset when split frame task has finished
-				mHasEditedMedia = true; // because now the original media item has a new id, so must reload in editor
-				setBackButtonIcons(AudioActivity.this, R.id.button_finished_audio, R.id.button_cancel_recording, false);
-				mAudioDuration = 0;
-				updateAudioRecordingText(0);
-
-				// new frames have no content, so make sure to start in recording mode
-				if (mDisplayMode != DisplayMode.RECORD_AUDIO) {
-					MediaItem audioMediaItem = MediaManager.findMediaByInternalId(getContentResolver(),
-							mMediaItemInternalId);
-					if (audioMediaItem != null) {
-						switchToRecording(audioMediaItem.getFile());
-					}
-				}
-
-				// resume recording state if necessary
-				if (mContinueRecordingAfterSplit) {
-					mContinueRecordingAfterSplit = false;
-					startRecording();
-				}
-				break;
-			case R.id.audio_switch_frame_task_complete:
-				completeSwitchFrames();
+			case R.id.audio_add_frame_after_task_complete:
+				switchToPlayback(false); // first switch to playback, so we exit from addFrameAfter()
+				addFrameAfter();
 				break;
 			case R.id.import_external_media_succeeded:
 				mHasEditedMedia = true; // to force an icon update
@@ -896,46 +853,24 @@ public class AudioActivity extends MediaPhoneActivity {
 		}
 	}
 
-	private boolean performSwitchFrames(int itemId, boolean showOptionsMenu) {
-		if (mMediaItemInternalId != null) {
-			mSwitchingFrames = true;
-			if (mAudioRecordingInProgress) {
-				// TODO: do we need to disable the menu buttons here to prevent double pressing?
-				findViewById(R.id.button_record_audio).setEnabled(false);
-				mContinueRecordingAfterSplit = true;
-
-				mSwitchFrameDirection = itemId;
-				mSwitchFrameShowOptionsMenu = showOptionsMenu;
-
-				stopRecording(AfterRecordingMode.SWITCH_FRAME);
-				return true;
-			} else {
-				MediaItem audioMediaItem = MediaManager.findMediaByInternalId(getContentResolver(),
-						mMediaItemInternalId);
-				if (audioMediaItem != null) {
-					if (mDisplayMode == DisplayMode.RECORD_AUDIO && audioMediaItem.getFile().length() > 0) {
-						onBackPressed(); // need to exit from recording mode when not recording but no player present
-					}
-					return switchFrames(audioMediaItem.getParentId(), itemId, R.string.extra_internal_id,
-							showOptionsMenu, FrameEditorActivity.class);
-				}
+	private void addFrameAfter() {
+		final MediaItem audioMediaItem = MediaManager.findMediaByInternalId(getContentResolver(), mMediaItemInternalId);
+		if (audioMediaItem != null && audioMediaItem.getFile().length() > 0) {
+			final String newFrameId = insertFrameAfterMedia(audioMediaItem);
+			final Intent addAudioIntent = new Intent(AudioActivity.this, AudioActivity.class);
+			addAudioIntent.putExtra(getString(R.string.extra_parent_id), newFrameId);
+			if (mContinueRecordingAfterSplit) {
+				addAudioIntent.putExtra(getString(R.string.extra_start_recording_audio), mContinueRecordingAfterSplit);
 			}
-		}
-		return false;
-	}
-
-	private void completeSwitchFrames() {
-		performSwitchFrames(mSwitchFrameDirection, mSwitchFrameShowOptionsMenu);
-	}
-
-	@Override
-	protected boolean swipeNext() {
-		return performSwitchFrames(R.id.menu_next_frame, false);
-	}
+			if (mFrameSpanningPrevented) {
+				addAudioIntent.putExtra(getString(R.string.extra_prevent_frame_spanning), true);
+			}
+			startActivity(addAudioIntent);
 
-	@Override
-	protected boolean swipePrevious() {
-		return performSwitchFrames(R.id.menu_previous_frame, false);
+			onBackPressed();
+		} else {
+			UIUtilities.showToast(AudioActivity.this, R.string.split_audio_add_content);
+		}
 	}
 
 	private void releasePlayer() {
@@ -966,7 +901,7 @@ public class AudioActivity extends MediaPhoneActivity {
 			try {
 				releasePlayer();
 				mMediaPlayer = new MediaPlayer();
-				mMediaController = new NoSwipeCustomMediaController(AudioActivity.this);
+				mMediaController = new CustomMediaController(AudioActivity.this);
 
 				// can't play from data directory (they're private; permissions don't work), must use an input stream
 				playerInputStream = new FileInputStream(audioMediaItem.getFile());
@@ -1053,10 +988,6 @@ public class AudioActivity extends MediaPhoneActivity {
 					}
 				}
 			}
-
-			// disable swipe events so we don't swipe by mistake while moving
-			disableSwipe();
-			enableSwipeDelayed();
 		}
 
 		@Override
@@ -1094,48 +1025,6 @@ public class AudioActivity extends MediaPhoneActivity {
 		}
 	};
 
-	private class NoSwipeCustomMediaController extends CustomMediaController {
-		private NoSwipeCustomMediaController(Context context) {
-			super(context);
-		}
-
-		@Override
-		public boolean onInterceptTouchEvent(MotionEvent event) {
-			switch (event.getAction()) {
-				case MotionEvent.ACTION_DOWN:
-					disableSwipe();
-					break;
-				case MotionEvent.ACTION_UP:
-					enableSwipeDelayed();
-					break;
-			}
-			return false;
-		}
-	}
-
-	private void disableSwipe() {
-		mSwipeEnablerHandler.removeMessages(R.id.msg_enable_swipe_events);
-		setSwipeEventsEnabled(false);
-	}
-
-	private void enableSwipeDelayed() {
-		final Handler handler = mSwipeEnablerHandler;
-		final Message message = handler.obtainMessage(R.id.msg_enable_swipe_events, AudioActivity.this);
-		handler.removeMessages(R.id.msg_enable_swipe_events);
-		handler.sendMessageDelayed(message, ViewConfiguration.getTapTimeout());
-	}
-
-	private static class SwipeEnablerHandler extends Handler {
-		@Override
-		public void handleMessage(Message msg) {
-			switch (msg.what) {
-				case R.id.msg_enable_swipe_events:
-					((AudioActivity) msg.obj).setSwipeEventsEnabled(true);
-					break;
-			}
-		}
-	}
-
 	public void handleButtonClicks(View currentButton) {
 		if (!verifyButtonClick(currentButton)) {
 			return;
@@ -1168,12 +1057,28 @@ public class AudioActivity extends MediaPhoneActivity {
 				}
 				break;
 
+			case R.id.button_toggle_mode_audio:
+				final MediaItem spanningAudioMediaItem = MediaManager.findMediaByInternalId(getContentResolver(),
+						mMediaItemInternalId);
+				if (spanningAudioMediaItem != null && spanningAudioMediaItem.getFile().length() > 0) {
+					mHasEditedMedia = true; // so we update/inherit on exit and show the media edited icon
+					setBackButtonIcons(AudioActivity.this, R.id.button_finished_audio, R.id.button_cancel_recording,
+							true);
+					boolean frameSpanning = toggleFrameSpanningMedia(spanningAudioMediaItem);
+					updateSpanFramesButtonIcon(R.id.button_toggle_mode_audio, frameSpanning, true);
+					UIUtilities.showToast(AudioActivity.this, frameSpanning ? R.string.span_audio_multiple_frames
+							: R.string.span_audio_single_frame);
+				} else {
+					UIUtilities.showToast(AudioActivity.this, R.string.span_audio_add_content);
+				}
+				break;
+
 			case R.id.button_delete_audio:
 				AlertDialog.Builder builder = new AlertDialog.Builder(AudioActivity.this);
 				builder.setTitle(R.string.delete_audio_confirmation);
 				builder.setMessage(R.string.delete_audio_hint);
 				builder.setIcon(android.R.drawable.ic_dialog_alert);
-				builder.setNegativeButton(android.R.string.cancel, null);
+				builder.setNegativeButton(R.string.button_cancel, null);
 				builder.setPositiveButton(R.string.button_delete, new DialogInterface.OnClickListener() {
 					@Override
 					public void onClick(DialogInterface dialog, int whichButton) {
@@ -1181,7 +1086,7 @@ public class AudioActivity extends MediaPhoneActivity {
 						MediaItem audioToDelete = MediaManager.findMediaByInternalId(contentResolver,
 								mMediaItemInternalId);
 						if (audioToDelete != null) {
-							mHasEditedMedia = true;
+							mHasEditedMedia = true; // so the frame editor updates its display
 							audioToDelete.setDeleted(true);
 							MediaManager.updateMedia(contentResolver, audioToDelete);
 							UIUtilities.showToast(AudioActivity.this, R.string.delete_audio_succeeded);
@@ -1189,8 +1094,7 @@ public class AudioActivity extends MediaPhoneActivity {
 						}
 					}
 				});
-				AlertDialog alert = builder.create();
-				alert.show();
+				builder.show();
 				break;
 
 			case R.id.button_import_audio:
@@ -1258,7 +1162,7 @@ public class AudioActivity extends MediaPhoneActivity {
 		}
 		mNextBlinkMode = R.id.msg_blink_icon_off;
 		((CenteredImageTextButton) findViewById(R.id.button_record_audio)).setCompoundDrawablesWithIntrinsicBounds(0,
-				R.drawable.ic_record, 0, 0); // reset the button icon
+				R.drawable.ic_audio_record, 0, 0); // reset the button icon
 	}
 
 	private final Runnable mButtonIconBlinkTask = new Runnable() {
@@ -1285,9 +1189,9 @@ public class AudioActivity extends MediaPhoneActivity {
 		if (mButtonIconBlinkScheduler != null && !mButtonIconBlinkScheduler.isShutdown()) {
 			CenteredImageTextButton recordButton = (CenteredImageTextButton) findViewById(R.id.button_record_audio);
 			if (currentBlinkMode == R.id.msg_blink_icon_on) {
-				recordButton.setCompoundDrawablesWithIntrinsicBounds(0, R.drawable.ic_record_paused, 0, 0);
+				recordButton.setCompoundDrawablesWithIntrinsicBounds(0, R.drawable.ic_audio_resume, 0, 0);
 			} else {
-				recordButton.setCompoundDrawablesWithIntrinsicBounds(0, R.drawable.ic_record, 0, 0);
+				recordButton.setCompoundDrawablesWithIntrinsicBounds(0, R.drawable.ic_audio_record, 0, 0);
 			}
 			mNextBlinkMode = (currentBlinkMode == R.id.msg_blink_icon_on ? R.id.msg_blink_icon_off
 					: R.id.msg_blink_icon_on);
diff --git a/src/ac/robinson/mediaphone/activity/CameraActivity.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/activity/CameraActivity.java
similarity index 87%
rename from src/ac/robinson/mediaphone/activity/CameraActivity.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/activity/CameraActivity.java
index 828b4ff..9290b8b 100644
--- a/src/ac/robinson/mediaphone/activity/CameraActivity.java
+++ b/MediaPhone/src/main/java/ac/robinson/mediaphone/activity/CameraActivity.java
@@ -90,10 +90,8 @@ public class CameraActivity extends MediaPhoneActivity implements OrientationMan
 
 	private String mMediaItemInternalId = null;
 	private boolean mHasEditedMedia = false;
-	private boolean mShowOptionsMenu = false;
-	private boolean mSwitchedFrames = false;
-	private int mSwitchToLandscape = -1;
 	private boolean mImagePickerShown = false;
+	private int mSwitchToLandscape = -1;
 
 	private boolean mDoesNotHaveCamera;
 	private CameraView mCameraView;
@@ -115,7 +113,7 @@ public class CameraActivity extends MediaPhoneActivity implements OrientationMan
 	private boolean mAddToMediaLibrary = false;
 
 	private enum DisplayMode {
-		DISPLAY_PICTURE, TAKE_PICTURE, SWITCHING_FRAME
+		DISPLAY_PICTURE, TAKE_PICTURE
 	};
 
 	private DisplayMode mDisplayMode;
@@ -123,9 +121,6 @@ public class CameraActivity extends MediaPhoneActivity implements OrientationMan
 	@Override
 	protected void onCreate(Bundle savedInstanceState) {
 		super.onCreate(savedInstanceState);
-		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
-			setTheme(R.style.default_light_theme); // light looks *much* better beyond honeycomb
-		}
 		UIUtilities.configureActionBar(this, true, true, R.string.title_frame_editor, R.string.title_camera);
 		setContentView(R.layout.camera_view);
 
@@ -133,14 +128,11 @@ public class CameraActivity extends MediaPhoneActivity implements OrientationMan
 
 		mDisplayMode = DisplayMode.TAKE_PICTURE;
 		mMediaItemInternalId = null;
-		mShowOptionsMenu = false;
-		mSwitchedFrames = false;
 
 		// load previous id on screen rotation
 		if (savedInstanceState != null) {
 			mMediaItemInternalId = savedInstanceState.getString(getString(R.string.extra_internal_id));
 			mHasEditedMedia = savedInstanceState.getBoolean(getString(R.string.extra_media_edited), true);
-			mSwitchedFrames = savedInstanceState.getBoolean(getString(R.string.extra_switched_frames));
 			mSwitchToLandscape = savedInstanceState.getInt(getString(R.string.extra_switch_to_landscape_camera), -1);
 			mImagePickerShown = savedInstanceState.getBoolean(getString(R.string.extra_external_chooser_shown), false);
 			if (mHasEditedMedia) {
@@ -157,24 +149,11 @@ public class CameraActivity extends MediaPhoneActivity implements OrientationMan
 		// no need to save display mode as we don't allow rotation when actually taking a picture
 		savedInstanceState.putString(getString(R.string.extra_internal_id), mMediaItemInternalId);
 		savedInstanceState.putBoolean(getString(R.string.extra_media_edited), mHasEditedMedia);
-		savedInstanceState.putBoolean(getString(R.string.extra_switched_frames), mSwitchedFrames);
 		savedInstanceState.putInt(getString(R.string.extra_switch_to_landscape_camera), mSwitchToLandscape);
 		savedInstanceState.putBoolean(getString(R.string.extra_external_chooser_shown), mImagePickerShown);
 		super.onSaveInstanceState(savedInstanceState);
 	}
 
-	@Override
-	public void onWindowFocusChanged(boolean hasFocus) {
-		super.onWindowFocusChanged(hasFocus);
-		if (hasFocus) {
-			if (mShowOptionsMenu) {
-				mShowOptionsMenu = false;
-				openOptionsMenu();
-			}
-			registerForSwipeEvents(); // here to avoid crashing due to double-swiping
-		}
-	}
-
 	@Override
 	protected void onResume() {
 		super.onResume();
@@ -214,17 +193,22 @@ public class CameraActivity extends MediaPhoneActivity implements OrientationMan
 		if (imageMediaItem != null) {
 			switch (mDisplayMode) {
 				case DISPLAY_PICTURE:
-					// deleted the picture (media item already set deleted) - update the icon
-					if (mHasEditedMedia) {
-						runImmediateBackgroundTask(getFrameIconUpdaterRunnable(imageMediaItem.getParentId()));
+					if (imageMediaItem.getDeleted()) {
+						// we've been deleted - propagate changes to our parent frame and any following frames
+						inheritMediaAndDeleteItemLinks(imageMediaItem.getParentId(), imageMediaItem, null);
+					} else if (mHasEditedMedia) {
+						// imported, rotated or otherwise edited the image - update icons
+						updateMediaFrameIcons(imageMediaItem, null);
 					}
 					break;
 
 				case TAKE_PICTURE:
+					// display if they took a picture, exit otherwise
 					if (imageMediaItem.getFile().length() > 0) {
 						// took a new picture (rather than just cancelling the camera) - update the icon
 						if (mHasEditedMedia) {
-							runImmediateBackgroundTask(getFrameIconUpdaterRunnable(imageMediaItem.getParentId()));
+							// update this frame's icon with the new image; propagate to following frames if applicable
+							updateMediaFrameIcons(imageMediaItem, null);
 							setBackButtonIcons(CameraActivity.this, R.id.button_finished_picture, 0, true);
 
 							// if we do this then we can't tell whether to change icons on screen rotation; disabled
@@ -238,20 +222,14 @@ public class CameraActivity extends MediaPhoneActivity implements OrientationMan
 						// so we don't leave an empty stub
 						imageMediaItem.setDeleted(true);
 						MediaManager.updateMedia(contentResolver, imageMediaItem);
-					}
-					break;
 
-				case SWITCHING_FRAME:
-					// this mode means we were in TAKE_PICTURE, but are now switching frames
-					// - there's no icon to update because no picture was taken
-					if (imageMediaItem.getFile().length() <= 0) {
-						// so we don't leave an empty stub
-						imageMediaItem.setDeleted(true);
-						MediaManager.updateMedia(contentResolver, imageMediaItem);
+						// we've been deleted - propagate changes to our parent frame and any following frames
+						inheritMediaAndDeleteItemLinks(imageMediaItem.getParentId(), imageMediaItem, null);
 					}
 					break;
 			}
 
+			// save the id of the frame we're part of so that the frame editor gets notified
 			saveLastEditedFrame(imageMediaItem.getParentId());
 		}
 
@@ -281,24 +259,29 @@ public class CameraActivity extends MediaPhoneActivity implements OrientationMan
 	@Override
 	public boolean onCreateOptionsMenu(Menu menu) {
 		MenuInflater inflater = getMenuInflater();
-		setupMenuNavigationButtonsFromMedia(inflater, menu, getContentResolver(), mMediaItemInternalId, mHasEditedMedia);
+		createMediaMenuNavigationButtons(inflater, menu, mHasEditedMedia);
 		return super.onCreateOptionsMenu(menu);
 	}
 
 	@Override
-	public boolean onOptionsItemSelected(MenuItem item) {
-		final int itemId = item.getItemId();
-		switch (itemId) {
-			case R.id.menu_previous_frame:
-			case R.id.menu_next_frame:
-				performSwitchFrames(itemId, true);
-				return true;
+	public boolean onPrepareOptionsMenu(Menu menu) {
+		prepareMediaMenuNavigationButtons(menu, mMediaItemInternalId);
+		return super.onPrepareOptionsMenu(menu);
+	}
 
+	@Override
+	public boolean onOptionsItemSelected(MenuItem item) {
+		switch (item.getItemId()) {
 			case R.id.menu_add_frame:
-				MediaItem imageMediaItem = MediaManager.findMediaByInternalId(getContentResolver(),
+				final MediaItem imageMediaItem = MediaManager.findMediaByInternalId(getContentResolver(),
 						mMediaItemInternalId);
 				if (imageMediaItem != null && imageMediaItem.getFile().length() > 0) {
-					runQueuedBackgroundTask(getFrameSplitterRunnable(mMediaItemInternalId));
+					final String newFrameId = insertFrameAfterMedia(imageMediaItem);
+					final Intent addImageIntent = new Intent(CameraActivity.this, CameraActivity.class);
+					addImageIntent.putExtra(getString(R.string.extra_parent_id), newFrameId);
+					startActivity(addImageIntent);
+
+					onBackPressed();
 				} else {
 					UIUtilities.showToast(CameraActivity.this, R.string.split_image_add_content);
 				}
@@ -349,11 +332,6 @@ public class CameraActivity extends MediaPhoneActivity implements OrientationMan
 			final Intent intent = getIntent();
 			if (intent != null) {
 				parentInternalId = intent.getStringExtra(getString(R.string.extra_parent_id));
-				mShowOptionsMenu = intent.getBooleanExtra(getString(R.string.extra_show_options_menu), false);
-				mSwitchedFrames = intent.getBooleanExtra(getString(R.string.extra_switched_frames), false);
-				if (mSwitchedFrames) {
-					firstLaunch = false; // so we don't show hints
-				}
 			}
 			if (parentInternalId == null) {
 				UIUtilities.showToast(CameraActivity.this, R.string.error_loading_image_editor);
@@ -362,7 +340,7 @@ public class CameraActivity extends MediaPhoneActivity implements OrientationMan
 				return;
 			}
 
-			// get existing content if it exists
+			// get existing content if it exists (ignores links)
 			mMediaItemInternalId = FrameItem.getImageContentId(contentResolver, parentInternalId);
 
 			// add a new media item if it doesn't already exist
@@ -377,6 +355,8 @@ public class CameraActivity extends MediaPhoneActivity implements OrientationMan
 		// load the existing image
 		final MediaItem imageMediaItem = MediaManager.findMediaByInternalId(contentResolver, mMediaItemInternalId);
 		if (imageMediaItem != null) {
+			updateSpanFramesButtonIcon(R.id.button_toggle_mode_picture, imageMediaItem.getSpanFrames(), false);
+
 			if (mSwitchToLandscape < 0 && imageMediaItem.getFile().length() > 0) {
 				if (imageMediaItem.getType() == MediaPhoneProvider.TYPE_IMAGE_FRONT) {
 					mCameraConfiguration.usingFrontCamera = true;
@@ -719,13 +699,13 @@ public class CameraActivity extends MediaPhoneActivity implements OrientationMan
 		}
 	};
 
+	// TODO: move to normal queued/immediate background task?
 	private class SavePreviewFrameTask extends AsyncTask<byte[], Void, Boolean> {
 
 		@Override
 		protected Boolean doInBackground(byte[]... params) {
 			byte[] data = params[0];
 			if (data == null) {
-				UIUtilities.showToast(CameraActivity.this, R.string.save_picture_failed);
 				if (MediaPhone.DEBUG)
 					Log.d(DebugUtilities.getLogTag(this), "SavePreviewFrameTask: data is null");
 				return false;
@@ -766,7 +746,7 @@ public class CameraActivity extends MediaPhoneActivity implements OrientationMan
 					if (!BitmapUtilities.saveYUYToJPEG(data, imageMediaItem.getFile(), pictureConfig.imageFormat,
 							mJpegSaveQuality, pictureConfig.width, pictureConfig.height, rotation,
 							mCameraConfiguration.usingFrontCamera)) {
-						UIUtilities.showToast(CameraActivity.this, R.string.save_picture_failed);
+						return false;
 					}
 
 				} else if (pictureConfig.imageFormat == ImageFormat.JPEG) {
@@ -775,7 +755,7 @@ public class CameraActivity extends MediaPhoneActivity implements OrientationMan
 
 					if (!BitmapUtilities.saveJPEGToJPEG(data, imageMediaItem.getFile(),
 							mCameraConfiguration.usingFrontCamera)) {
-						UIUtilities.showToast(CameraActivity.this, R.string.save_picture_failed);
+						return false;
 					}
 
 				} else {
@@ -788,7 +768,7 @@ public class CameraActivity extends MediaPhoneActivity implements OrientationMan
 						rawBitmap.recycle();
 					}
 					if (rawBitmap == null || !success) {
-						UIUtilities.showToast(CameraActivity.this, R.string.save_picture_failed);
+						return false;
 					}
 				}
 
@@ -798,13 +778,13 @@ public class CameraActivity extends MediaPhoneActivity implements OrientationMan
 					runImmediateBackgroundTask(getMediaLibraryAdderRunnable(imageMediaItem.getFile().getAbsolutePath(),
 							Environment.DIRECTORY_DCIM));
 				}
+				return true;
+
 			} else {
-				UIUtilities.showToast(CameraActivity.this, R.string.save_picture_failed);
 				if (MediaPhone.DEBUG)
 					Log.d(DebugUtilities.getLogTag(this), "Save image failed: no MediaItem to save to");
 				return false;
 			}
-			return true;
 		}
 
 		protected void onPostExecute(Boolean saveSucceeded) {
@@ -830,14 +810,17 @@ public class CameraActivity extends MediaPhoneActivity implements OrientationMan
 					}
 				}
 
-				onBackPressed();
+			} else {
+				UIUtilities.showToast(CameraActivity.this, R.string.save_picture_failed);
+			}
 
-				synchronized (mSavingInProgress) {
-					mSavingInProgress = false;
-					if (mBackPressedDuringPhoto) {
-						mBackPressedDuringPhoto = false;
-						onBackPressed(); // second press doesn't really work, but don't want pressing back while saving
-					}
+			onBackPressed();
+
+			synchronized (mSavingInProgress) {
+				mSavingInProgress = false;
+				if (mBackPressedDuringPhoto) {
+					mBackPressedDuringPhoto = false;
+					onBackPressed(); // second press doesn't really work, but don't want pressing back while saving
 				}
 			}
 		}
@@ -915,14 +898,6 @@ public class CameraActivity extends MediaPhoneActivity implements OrientationMan
 	@Override
 	protected void onBackgroundTaskCompleted(int taskId) {
 		switch (taskId) {
-			case R.id.split_frame_task_complete:
-				((ImageView) findViewById(R.id.camera_result)).setImageBitmap(null); // otherwise we copy to new frame
-				mHasEditedMedia = true; // because now the original media item has a new id, so must reload in editor
-				setBackButtonIcons(CameraActivity.this, R.id.button_finished_picture, 0, false);
-				if (mDisplayMode != DisplayMode.TAKE_PICTURE) {
-					switchToCamera(mCameraConfiguration.usingFrontCamera, false);
-				}
-				break;
 			case R.id.import_external_media_succeeded:
 				mHasEditedMedia = true; // to force an icon update
 				onBackPressed();
@@ -938,12 +913,13 @@ public class CameraActivity extends MediaPhoneActivity implements OrientationMan
 				break;
 			case R.id.image_rotate_completed:
 				mStopImageRotationAnimation = true;
+				mHasEditedMedia = true; // to force an icon update
 				setBackButtonIcons(CameraActivity.this, R.id.button_finished_picture, 0, true); // changed the image
 				MediaItem imageMediaItem = MediaManager.findMediaByInternalId(getContentResolver(),
 						mMediaItemInternalId);
 				if (imageMediaItem != null) {
 					loadScreenSizedImageInBackground((ImageView) findViewById(R.id.camera_result), imageMediaItem
-							.getFile().getAbsolutePath(), true, true); // reload the image
+							.getFile().getAbsolutePath(), true, MediaPhoneActivity.FadeType.FADEIN); // reload image
 				}
 				findViewById(R.id.button_rotate_clockwise).setEnabled(true);
 				findViewById(R.id.button_rotate_anticlockwise).setEnabled(true);
@@ -951,38 +927,14 @@ public class CameraActivity extends MediaPhoneActivity implements OrientationMan
 		}
 	}
 
-	private boolean performSwitchFrames(int itemId, boolean showOptionsMenu) {
-		if (mMediaItemInternalId != null) {
-			MediaItem imageMediaItem = MediaManager.findMediaByInternalId(getContentResolver(), mMediaItemInternalId);
-			if (imageMediaItem != null) {
-				if (mDisplayMode == DisplayMode.TAKE_PICTURE) {
-					mDisplayMode = DisplayMode.SWITCHING_FRAME; // so we exit properly
-				}
-				return switchFrames(imageMediaItem.getParentId(), itemId, R.string.extra_parent_id, showOptionsMenu,
-						CameraActivity.class);
-			}
-		}
-		return false;
-	}
-
-	@Override
-	protected boolean swipeNext() {
-		return performSwitchFrames(R.id.menu_next_frame, false);
-	}
-
-	@Override
-	protected boolean swipePrevious() {
-		return performSwitchFrames(R.id.menu_previous_frame, false);
-	}
-
 	private void setFlashButtonIcon(String flashMode) {
-		int currentDrawable = R.drawable.ic_flash_auto; // auto mode is the default
+		int currentDrawable = R.drawable.ic_image_flash_auto; // auto mode is the default
 		if (Camera.Parameters.FLASH_MODE_OFF.equals(flashMode)) {
-			currentDrawable = R.drawable.ic_flash_off;
+			currentDrawable = R.drawable.ic_image_flash_off;
 		} else if (Camera.Parameters.FLASH_MODE_ON.equals(flashMode)) {
-			currentDrawable = R.drawable.ic_flash_on;
+			currentDrawable = R.drawable.ic_image_flash_on;
 		} else if (Camera.Parameters.FLASH_MODE_RED_EYE.equals(flashMode)) {
-			currentDrawable = R.drawable.ic_flash_red_eye;
+			currentDrawable = R.drawable.ic_image_flash_redeye;
 		}
 
 		Resources res = getResources();
@@ -1051,12 +1003,27 @@ public class CameraActivity extends MediaPhoneActivity implements OrientationMan
 				retakePicture();
 				break;
 
+			case R.id.button_toggle_mode_picture:
+				final MediaItem imageMediaItem = MediaManager.findMediaByInternalId(getContentResolver(),
+						mMediaItemInternalId);
+				if (imageMediaItem != null && imageMediaItem.getFile().length() > 0) {
+					mHasEditedMedia = true; // so we update/inherit on exit and show the media edited icon
+					setBackButtonIcons(CameraActivity.this, R.id.button_finished_picture, 0, true);
+					boolean frameSpanning = toggleFrameSpanningMedia(imageMediaItem);
+					updateSpanFramesButtonIcon(R.id.button_toggle_mode_picture, frameSpanning, true);
+					UIUtilities.showToast(CameraActivity.this, frameSpanning ? R.string.span_image_multiple_frames
+							: R.string.span_image_single_frame);
+				} else {
+					UIUtilities.showToast(CameraActivity.this, R.string.span_image_add_content);
+				}
+				break;
+
 			case R.id.button_delete_picture:
 				AlertDialog.Builder builder = new AlertDialog.Builder(CameraActivity.this);
 				builder.setTitle(R.string.delete_image_confirmation);
 				builder.setMessage(R.string.delete_image_hint);
 				builder.setIcon(android.R.drawable.ic_dialog_alert);
-				builder.setNegativeButton(android.R.string.cancel, null);
+				builder.setNegativeButton(R.string.button_cancel, null);
 				builder.setPositiveButton(R.string.button_delete, new DialogInterface.OnClickListener() {
 					@Override
 					public void onClick(DialogInterface dialog, int whichButton) {
@@ -1064,7 +1031,7 @@ public class CameraActivity extends MediaPhoneActivity implements OrientationMan
 						MediaItem imageToDelete = MediaManager.findMediaByInternalId(contentResolver,
 								mMediaItemInternalId);
 						if (imageToDelete != null) {
-							mHasEditedMedia = true;
+							mHasEditedMedia = true; // so the frame editor updates its display
 							imageToDelete.setDeleted(true);
 							MediaManager.updateMedia(contentResolver, imageToDelete);
 							UIUtilities.showToast(CameraActivity.this, R.string.delete_image_succeeded);
@@ -1072,8 +1039,7 @@ public class CameraActivity extends MediaPhoneActivity implements OrientationMan
 						}
 					}
 				});
-				AlertDialog alert = builder.create();
-				alert.show();
+				builder.show();
 				break;
 
 			case R.id.button_import_image:
@@ -1143,15 +1109,23 @@ public class CameraActivity extends MediaPhoneActivity implements OrientationMan
 	private void animateButtonRotation(Resources res, int animation, int button, int icon, int previousRotation) {
 		CenteredImageTextButton imageButton = (CenteredImageTextButton) findViewById(button);
 		Bitmap currentBitmap = BitmapFactory.decodeResource(res, icon);
-		Drawable buttonIcon = new BitmapDrawable(res, BitmapUtilities.rotate(currentBitmap, previousRotation,
-				currentBitmap.getWidth() / 2, currentBitmap.getHeight() / 2)); // need previous rotation to correct diff
-		buttonIcon.setBounds(0, 0, buttonIcon.getIntrinsicWidth(), buttonIcon.getIntrinsicHeight());
-		Animation rotationAnimation = AnimationUtils.loadAnimation(this, animation);
-		rotationAnimation.initialize(buttonIcon.getIntrinsicWidth(), buttonIcon.getIntrinsicHeight(),
-				imageButton.getWidth(), imageButton.getHeight());
-		rotationAnimation.start();
-		imageButton.setCompoundDrawablesWithIntrinsicBounds(null, new AnimateDrawable(buttonIcon, rotationAnimation),
-				null, null);
+		if (currentBitmap == null) { // the take picture icon is an xml drawable - it must be loaded as such
+			Drawable bitmapDrawable = res.getDrawable(icon);
+			if (bitmapDrawable instanceof BitmapDrawable) {
+				currentBitmap = ((BitmapDrawable) bitmapDrawable).getBitmap();
+			}
+		}
+		if (currentBitmap != null) {
+			Drawable buttonIcon = new BitmapDrawable(res, BitmapUtilities.rotate(currentBitmap, previousRotation,
+					currentBitmap.getWidth() / 2, currentBitmap.getHeight() / 2));
+			buttonIcon.setBounds(0, 0, buttonIcon.getIntrinsicWidth(), buttonIcon.getIntrinsicHeight());
+			Animation rotationAnimation = AnimationUtils.loadAnimation(this, animation);
+			rotationAnimation.initialize(buttonIcon.getIntrinsicWidth(), buttonIcon.getIntrinsicHeight(),
+					imageButton.getWidth(), imageButton.getHeight());
+			rotationAnimation.start();
+			imageButton.setCompoundDrawablesWithIntrinsicBounds(null,
+					new AnimateDrawable(buttonIcon, rotationAnimation), null, null);
+		}
 	}
 
 	@Override
@@ -1180,47 +1154,51 @@ public class CameraActivity extends MediaPhoneActivity implements OrientationMan
 			mCameraView.setRotation(mDisplayOrientation, mDisplayOrientation);
 		}
 
-		// get the difference between the current and previous orientations
-		int animation = 0;
-		int rotationDifference = ((mIconRotation - correctedRotation + 360) % 360);
-		switch (rotationDifference) {
-			case 270:
-				animation = R.anim.rotate_clockwise_90;
-				break;
-			case 90:
-				animation = R.anim.rotate_anticlockwise_90;
-				break;
-			case 180:
-				animation = R.anim.rotate_clockwise_180;
-				break;
-		}
+		// we only need to animate rotations if we're in camera mode
+		if (mDisplayMode == DisplayMode.TAKE_PICTURE) {
 
-		if (animation == 0) {
-			return; // no need to change icons - no difference in orientation
-		}
+			// get the difference between the current and previous orientations
+			int animation = 0;
+			int rotationDifference = ((mIconRotation - correctedRotation + 360) % 360);
+			switch (rotationDifference) {
+				case 270:
+					animation = R.anim.rotate_clockwise_90;
+					break;
+				case 90:
+					animation = R.anim.rotate_anticlockwise_90;
+					break;
+				case 180:
+					animation = R.anim.rotate_clockwise_180;
+					break;
+			}
 
-		// animate rotating the button icons
-		Resources res = getResources();
-		animateButtonRotation(res, animation, R.id.button_take_picture, android.R.drawable.ic_menu_camera,
-				mIconRotation);
-		animateButtonRotation(res, animation, R.id.button_import_image, android.R.drawable.ic_menu_gallery,
-				mIconRotation);
+			if (animation == 0) {
+				return; // no need to change icons - no difference in orientation
+			}
 
-		if (findViewById(R.id.button_cancel_camera).getVisibility() == View.VISIBLE) {
-			animateButtonRotation(res, animation, R.id.button_cancel_camera, android.R.drawable.ic_menu_revert,
+			// animate rotating the button icons
+			Resources res = getResources();
+			animateButtonRotation(res, animation, R.id.button_take_picture, R.drawable.ic_menu_take_picture,
+					mIconRotation);
+			animateButtonRotation(res, animation, R.id.button_import_image, R.drawable.ic_menu_import_picture,
 					mIconRotation);
-		}
 
-		if (findViewById(R.id.button_switch_camera).getVisibility() == View.VISIBLE) {
-			animateButtonRotation(res, animation, R.id.button_switch_camera, R.drawable.ic_switch_camera, mIconRotation);
-		}
+			if (findViewById(R.id.button_cancel_camera).getVisibility() == View.VISIBLE) {
+				animateButtonRotation(res, animation, R.id.button_cancel_camera, R.drawable.ic_menu_back, mIconRotation);
+			}
 
-		// the flash button is done differently as its icon changes each time it is pressed
-		View flashButton = findViewById(R.id.button_toggle_flash);
-		if (flashButton.getVisibility() == View.VISIBLE) {
-			Integer imageTag = (Integer) flashButton.getTag();
-			if (imageTag != null) {
-				animateButtonRotation(res, animation, R.id.button_toggle_flash, imageTag, mIconRotation);
+			if (findViewById(R.id.button_switch_camera).getVisibility() == View.VISIBLE) {
+				animateButtonRotation(res, animation, R.id.button_switch_camera, R.drawable.ic_image_switch_camera,
+						mIconRotation);
+			}
+
+			// the flash button is done differently as its icon changes each time it is pressed
+			View flashButton = findViewById(R.id.button_toggle_flash);
+			if (flashButton.getVisibility() == View.VISIBLE) {
+				Integer imageTag = (Integer) flashButton.getTag();
+				if (imageTag != null) {
+					animateButtonRotation(res, animation, R.id.button_toggle_flash, imageTag, mIconRotation);
+				}
 			}
 		}
 
diff --git a/src/ac/robinson/mediaphone/activity/FrameEditorActivity.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/activity/FrameEditorActivity.java
similarity index 51%
rename from src/ac/robinson/mediaphone/activity/FrameEditorActivity.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/activity/FrameEditorActivity.java
index 0c6401f..3db82a9 100644
--- a/src/ac/robinson/mediaphone/activity/FrameEditorActivity.java
+++ b/MediaPhone/src/main/java/ac/robinson/mediaphone/activity/FrameEditorActivity.java
@@ -48,6 +48,8 @@ import android.content.SharedPreferences;
 import android.content.res.Configuration;
 import android.content.res.Resources;
 import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.LayerDrawable;
 import android.os.Build;
 import android.os.Bundle;
 import android.util.TypedValue;
@@ -58,9 +60,6 @@ import android.view.View;
 
 public class FrameEditorActivity extends MediaPhoneActivity {
 
-	// not in MediaPhone.java because it needs more than just this to add more audio items (layouts need updating too)
-	private final int MAX_AUDIO_ITEMS = 3;
-
 	private String mFrameInternalId;
 	private boolean mHasEditedMedia = false;
 	private boolean mShowOptionsMenu = false;
@@ -68,14 +67,19 @@ public class FrameEditorActivity extends MediaPhoneActivity {
 	private String mReloadImagePath = null;
 	private boolean mDeleteFrameOnExit = false;
 
-	private LinkedHashMap<String, Integer> mFrameAudioItems = new LinkedHashMap<String, Integer>();
+	private LinkedHashMap<String, Integer> mFrameAudioItems = new LinkedHashMap<>();
+
+	// the ids of inherited (spanned) media items from previous frames
+	private String mImageInherited;
+	private int mImageLinkingDrawable;
+	private String mAudioInherited;
+	private int mAudioLinkingIndex; // we only allow one inherited audio item, but need to know which one it is
+	private int mAudioLinkingDrawable;
+	private String mTextInherited;
 
 	@Override
 	protected void onCreate(Bundle savedInstanceState) {
 		super.onCreate(savedInstanceState);
-		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
-			setTheme(R.style.default_light_theme); // light looks *much* better beyond honeycomb
-		}
 		UIUtilities.configureActionBar(this, true, true, R.string.title_frame_editor, 0);
 		setContentView(R.layout.frame_editor);
 
@@ -107,22 +111,24 @@ public class FrameEditorActivity extends MediaPhoneActivity {
 			if (mAddNewFrame) {
 				mAddNewFrame = false;
 				addNewFrame();
-				saveLastEditedFrame(mFrameInternalId); // this is now the last edited frame
+				loadFrameElements();
 			} else {
 				// change the frame that is displayed, if applicable
 				changeFrames(loadLastEditedFrame());
 
-				// do image loading here so that we know the layout's size for sizing the image
-				if (mReloadImagePath != null) {
-					reloadFrameImage(mReloadImagePath);
-					mReloadImagePath = null;
-				}
-
+				// never have to show the options menu after creating a new frame
 				if (mShowOptionsMenu) {
 					mShowOptionsMenu = false;
 					openOptionsMenu();
 				}
 			}
+
+			// do image loading here so that we know the layout's size for sizing the image
+			if (mReloadImagePath != null) {
+				reloadFrameImage(mReloadImagePath);
+				mReloadImagePath = null;
+			}
+
 			registerForSwipeEvents(); // here to avoid crashing due to double-swiping
 		}
 	}
@@ -134,69 +140,69 @@ public class FrameEditorActivity extends MediaPhoneActivity {
 			return;
 		}
 
-		// delete frame/narrative if required
-		Resources resources = getResources();
+		// make sure to always scroll to the correct frame even if we've done next/prev
+		saveLastEditedFrame(mFrameInternalId);
+
+		// delete frame/narrative if required; don't allow frames with just links and no actual media
 		ContentResolver contentResolver = getContentResolver();
 		final FrameItem editedFrame = FramesManager.findFrameByInternalId(contentResolver, mFrameInternalId);
-		if (MediaManager.countMediaByParentId(contentResolver, mFrameInternalId) <= 0 || mDeleteFrameOnExit) {
+		String newStartFrameId = null;
+		String nextFrameId = null;
+		if (editedFrame != null
+				&& (MediaManager.countMediaByParentId(contentResolver, mFrameInternalId, false) <= 0 || mDeleteFrameOnExit)) {
 			// need the next frame id for scrolling (but before we update it to be deleted)
 			ArrayList<String> frameIds = FramesManager.findFrameIdsByParentId(contentResolver,
 					editedFrame.getParentId());
 
+			// save the next frame's id for updating icons/media; also deal with scrolling - if we're the first/last
+			// frame scroll to ensure frames don't show off screen TODO: do this in the horizontal list view instead
+			// (otherwise, there's no need to scroll - better to leave items in place than scroll to previous or next)
 			int numFrames = frameIds.size();
-			if (numFrames > 1) { // don't save if we're the last frame
-				int i = 0;
-				int foundId = -1;
-				for (String id : frameIds) {
-					if (mFrameInternalId.equals(id)) {
-						foundId = i;
-						break;
-					}
-					i += 1;
-				}
-				if (foundId >= 0) {
-					int idCount = numFrames - 2; // so we scroll to the last frame after this is deleted
-					foundId = foundId > idCount ? idCount : foundId;
-					saveLastEditedFrame(frameIds.get(foundId)); // scroll to this frame after exiting
+			if (numFrames > 1) {
+				int currentFrameIndex = frameIds.indexOf(mFrameInternalId);
+				if (currentFrameIndex == 0) {
+					nextFrameId = frameIds.get(1);
+					saveLastEditedFrame(newStartFrameId); // scroll to new first frame after exiting
+				} else if (currentFrameIndex > numFrames - 2) {
+					saveLastEditedFrame(frameIds.get(numFrames - 2)); // scroll to new last frame after exiting
+				} else {
+					nextFrameId = frameIds.get(currentFrameIndex + 1); // just store the frame to start updates from
 				}
 			}
 
+			// delete this frame
 			editedFrame.setDeleted(true);
 			FramesManager.updateFrame(contentResolver, editedFrame);
-		} else {
-			saveLastEditedFrame(mFrameInternalId); // so we always get the id even if we've done next/prev
-		}
 
-		// delete, or added no frame content
-		if (editedFrame.getDeleted()) {
-			// no narrative content - delete the narrative first for a better interface experience
-			// (don't have to wait for the frame to disappear)
-			int numFrames = FramesManager.countFramesByParentId(contentResolver, editedFrame.getParentId());
-			if (numFrames == 0) {
+			// if there's no narrative content after we've been deleted - delete the narrative first for a better
+			// interface experience (doing this means we don't have to wait for the frame icon to disappear)
+			if (numFrames == 1) {
 				NarrativeItem narrativeToDelete = NarrativesManager.findNarrativeByInternalId(contentResolver,
 						editedFrame.getParentId());
 				narrativeToDelete.setDeleted(true);
 				NarrativesManager.updateNarrative(contentResolver, narrativeToDelete);
 
-			} else if (numFrames > 0) {
-				// if we're the first frame, update the second frame's icon to be the main icon (i.e. with overlay)
-				FrameItem nextFrame = FramesManager
-						.findFirstFrameByParentId(contentResolver, editedFrame.getParentId());
-				if (editedFrame.getNarrativeSequenceId() < nextFrame.getNarrativeSequenceId()) {
-					FramesManager.reloadFrameIcon(resources, contentResolver, nextFrame, true);
-				}
+			} else if (numFrames > 1 && nextFrameId != null) {
+				// otherwise we need to delete our media from subsequent frames; always update the next frame's icon
+				ArrayList<String> frameComponents = MediaManager.findMediaIdsByParentId(contentResolver,
+						mFrameInternalId, false);
+				inheritMediaAndDeleteItemLinks(nextFrameId, null, frameComponents);
 			}
 		}
 
 		setResult(Activity.RESULT_OK);
-		super.onBackPressed();
+		try {
+			// if they've managed to swipe and open another activity between, this will crash as result can't be sent
+			super.onBackPressed();
+		} catch (RuntimeException e) {
+		}
 	}
 
 	@Override
 	public boolean onCreateOptionsMenu(Menu menu) {
 		// TODO: if we couldn't open a temporary directory then exporting won't work
 		MenuInflater inflater = getMenuInflater();
-		setupMenuNavigationButtons(inflater, menu, mFrameInternalId, mHasEditedMedia);
+		setupFrameMenuNavigationButtons(inflater, menu, mFrameInternalId, mHasEditedMedia, false);
 		inflater.inflate(R.menu.play_narrative, menu);
 		inflater.inflate(R.menu.make_template, menu);
 		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
@@ -211,7 +217,7 @@ public class FrameEditorActivity extends MediaPhoneActivity {
 		switch (itemId) {
 			case R.id.menu_previous_frame:
 			case R.id.menu_next_frame:
-				switchFrames(mFrameInternalId, itemId, R.string.extra_internal_id, true, FrameEditorActivity.class);
+				switchFrames(mFrameInternalId, itemId, null, true);
 				return true;
 
 			case R.id.menu_export_narrative:
@@ -224,7 +230,7 @@ public class FrameEditorActivity extends MediaPhoneActivity {
 
 			case R.id.menu_play_narrative:
 				if (MediaManager.countMediaByParentId(getContentResolver(), mFrameInternalId) > 0) {
-					final Intent framePlayerIntent = new Intent(FrameEditorActivity.this, NarrativePlayerActivity.class);
+					final Intent framePlayerIntent = new Intent(FrameEditorActivity.this, PlaybackActivity.class);
 					framePlayerIntent.putExtra(getString(R.string.extra_internal_id), mFrameInternalId);
 					startActivityForResult(framePlayerIntent, MediaPhone.R_id_intent_narrative_player);
 				} else {
@@ -252,15 +258,17 @@ public class FrameEditorActivity extends MediaPhoneActivity {
 				ContentResolver resolver = getContentResolver();
 				if (MediaManager.countMediaByParentId(resolver, mFrameInternalId) > 0) {
 					FrameItem currentFrame = FramesManager.findFrameByInternalId(resolver, mFrameInternalId);
-					runQueuedBackgroundTask(getNarrativeTemplateRunnable(currentFrame.getParentId(),
-							MediaPhoneProvider.getNewInternalId(), true)); // don't need the id
+					runQueuedBackgroundTask(getNarrativeTemplateRunnable(currentFrame.getParentId(), true));
 				} else {
 					UIUtilities.showToast(FrameEditorActivity.this, R.string.make_template_add_content);
 				}
 				return true;
 
 			case R.id.menu_delete_narrative:
-				deleteNarrativeDialog(mFrameInternalId);
+				FrameItem currentFrame = FramesManager.findFrameByInternalId(getContentResolver(), mFrameInternalId);
+				if (currentFrame != null) {
+					deleteNarrativeDialog(currentFrame.getParentId());
+				}
 				return true;
 
 			case R.id.menu_back_without_editing:
@@ -291,7 +299,6 @@ public class FrameEditorActivity extends MediaPhoneActivity {
 	}
 
 	private void loadFrameElements() {
-		mAddNewFrame = false;
 		if (mFrameInternalId == null) {
 			// editing an existing frame
 			final Intent intent = getIntent();
@@ -303,49 +310,89 @@ public class FrameEditorActivity extends MediaPhoneActivity {
 			// adding a new frame
 			if (mFrameInternalId == null) {
 				mAddNewFrame = true;
+				return; // we'll add the new frame and load elements in onWindowFocusChanged for a better UI experience
 			}
 		}
 
-		// reset interface
+		// reset interface and media inheritance
 		mReloadImagePath = null;
 		mFrameAudioItems.clear();
-		((CenteredImageTextButton) findViewById(R.id.button_take_picture_video))
-				.setCompoundDrawablesWithIntrinsicBounds(0, android.R.drawable.ic_menu_camera, 0, 0);
+		CenteredImageTextButton imageButton = (CenteredImageTextButton) findViewById(R.id.button_take_picture_video);
+		imageButton.setCompoundDrawablesWithIntrinsicBounds(0, R.drawable.ic_frame_image, 0, 0);
 		// (audio buttons are loaded/reset after audio files are loaded)
-		((CenteredImageTextButton) findViewById(R.id.button_add_text)).setText("");
-
-		// load existing content into buttons
-		if (!mAddNewFrame) {
-			ArrayList<MediaItem> frameComponents = MediaManager.findMediaByParentId(getContentResolver(),
-					mFrameInternalId);
-			boolean imageLoaded = false;
-			boolean audioLoaded = false;
-			boolean textLoaded = false;
-			for (MediaItem currentItem : frameComponents) {
-				final int currentType = currentItem.getType();
-				if (!imageLoaded
-						&& (currentType == MediaPhoneProvider.TYPE_IMAGE_BACK
-								|| currentType == MediaPhoneProvider.TYPE_IMAGE_FRONT || currentType == MediaPhoneProvider.TYPE_VIDEO)) {
-					mReloadImagePath = currentItem.getFile().getAbsolutePath();
-					imageLoaded = true;
-
-				} else if (!audioLoaded && currentType == MediaPhoneProvider.TYPE_AUDIO) {
-					mFrameAudioItems.put(currentItem.getInternalId(), currentItem.getDurationMilliseconds());
-					if (mFrameAudioItems.size() >= MAX_AUDIO_ITEMS) {
-						audioLoaded = true;
+		CenteredImageTextButton textButton = (CenteredImageTextButton) findViewById(R.id.button_add_text);
+		textButton.setText("");
+		textButton.setCompoundDrawablesWithIntrinsicBounds(0, R.drawable.ic_frame_text, 0, 0);
+
+		// reset media inheritance
+		mImageInherited = null;
+		mImageLinkingDrawable = 0;
+		mAudioInherited = null;
+		mAudioLinkingIndex = -1;
+		mAudioLinkingDrawable = 0;
+		mTextInherited = null;
+
+		// load existing content into buttons (no need to do any of this on new frames)
+		ArrayList<MediaItem> frameComponents = MediaManager.findMediaByParentId(getContentResolver(), mFrameInternalId);
+		boolean imageLoaded = false;
+		boolean audioLoaded = false;
+		boolean textLoaded = false;
+		for (MediaItem currentItem : frameComponents) {
+			final int currentType = currentItem.getType();
+			final boolean spanFrames = currentItem.getSpanFrames();
+			final boolean inheritedMedia = !currentItem.getParentId().equals(mFrameInternalId);
+			if (!imageLoaded
+					&& (currentType == MediaPhoneProvider.TYPE_IMAGE_BACK
+							|| currentType == MediaPhoneProvider.TYPE_IMAGE_FRONT || currentType == MediaPhoneProvider.TYPE_VIDEO)) {
+				mReloadImagePath = currentItem.getFile().getAbsolutePath();
+				if (spanFrames) {
+					// this was originally going to be done in onDraw of CenteredImageTextButton, but there's a
+					// bizarre bug that causes the canvas to be translated just over 8000 pixels to the left before
+					// it's given to our onDraw method - instead we now use a layer drawable when loading
+					if (inheritedMedia) {
+						mImageInherited = currentItem.getInternalId();
+						mImageLinkingDrawable = R.drawable.ic_frame_image_locked;
+					} else {
+						mImageLinkingDrawable = R.drawable.ic_frame_image_spanning;
+					}
+				}
+				imageLoaded = true;
+
+			} else if (!audioLoaded && currentType == MediaPhoneProvider.TYPE_AUDIO) {
+				// we could inherit multiple audio items, but this becomes too complex, so we currently only allow one
+				mFrameAudioItems.put(currentItem.getInternalId(), currentItem.getDurationMilliseconds());
+				if (spanFrames) {
+					mAudioLinkingIndex = mFrameAudioItems.size() - 1;
+					if (inheritedMedia) {
+						mAudioInherited = currentItem.getInternalId();
+						mAudioLinkingDrawable = R.drawable.ic_frame_audio_locked;
+					} else {
+						mAudioLinkingDrawable = R.drawable.ic_frame_audio_spanning;
 					}
+				}
+				if (mFrameAudioItems.size() >= MediaPhone.MAX_AUDIO_ITEMS) {
+					audioLoaded = true;
+				}
 
-				} else if (!textLoaded && currentType == MediaPhoneProvider.TYPE_TEXT) {
-					String textSnippet = IOUtilities.getFileContentSnippet(currentItem.getFile().getAbsolutePath(),
-							getResources().getInteger(R.integer.text_snippet_length));
-					((CenteredImageTextButton) findViewById(R.id.button_add_text)).setText(textSnippet);
-					textLoaded = true;
+			} else if (!textLoaded && currentType == MediaPhoneProvider.TYPE_TEXT) {
+				String textSnippet = IOUtilities.getFileContentSnippet(currentItem.getFile().getAbsolutePath(),
+						getResources().getInteger(R.integer.text_snippet_length));
+				textButton.setText(textSnippet);
+				if (spanFrames) {
+					if (inheritedMedia) {
+						mTextInherited = currentItem.getInternalId();
+						textButton.setCompoundDrawablesWithIntrinsicBounds(0, R.drawable.ic_frame_text_locked, 0, 0);
+					} else {
+						textButton.setCompoundDrawablesWithIntrinsicBounds(0, R.drawable.ic_frame_text_spanning, 0, 0);
+					}
 				}
+				textLoaded = true;
 			}
-
-			saveLastEditedFrame(mFrameInternalId); // this is now the last edited frame
 		}
 
+		// this is now the last edited frame - save our position
+		saveLastEditedFrame(mFrameInternalId);
+
 		// update the interface (image is loaded in onWindowFocusChanged so we know the button's size)
 		reloadAudioButtons();
 	}
@@ -354,27 +401,27 @@ public class FrameEditorActivity extends MediaPhoneActivity {
 		final Intent intent = getIntent();
 		if (intent == null) {
 			UIUtilities.showToast(FrameEditorActivity.this, R.string.error_loading_frame_editor);
+			mFrameInternalId = "-1"; // so we exit
 			onBackPressed();
 			return;
 		}
 
+		ContentResolver contentResolver = getContentResolver();
 		String intentNarrativeId = intent.getStringExtra(getString(R.string.extra_parent_id));
 		final boolean insertNewNarrative = intentNarrativeId == null;
 		final String narrativeId = insertNewNarrative ? MediaPhoneProvider.getNewInternalId() : intentNarrativeId;
-		final String insertBeforeId = intent.getStringExtra(getString(R.string.extra_insert_before_id));
-		final String insertAfterId = intent.getStringExtra(getString(R.string.extra_insert_after_id));
+
+		// default to inserting at the end if no before/after id is given
+		final String afterId = intent.getStringExtra(getString(R.string.extra_insert_after_id));
+		final String insertAfterId = afterId == null ? FramesManager.findLastFrameByParentId(contentResolver,
+				narrativeId) : afterId;
 
 		// don't load the frame's icon yet - it will be loaded (or deleted) when we return
-		Resources res = getResources();
-		ContentResolver contentResolver = getContentResolver();
 		FrameItem newFrame = new FrameItem(narrativeId, -1);
-		FramesManager.addFrame(res, contentResolver, newFrame, false);
+		FramesManager.addFrame(getResources(), contentResolver, newFrame, false);
 		mFrameInternalId = newFrame.getInternalId();
 
-		// note: not a background task any more, because it causes concurrency problems with deleting after back press
-		int narrativeSequenceIdIncrement = res.getInteger(R.integer.frame_narrative_sequence_increment);
 		int narrativeSequenceId = 0;
-
 		if (insertNewNarrative) {
 			// new narrative required
 			NarrativeItem newNarrative = new NarrativeItem(narrativeId,
@@ -382,54 +429,21 @@ public class FrameEditorActivity extends MediaPhoneActivity {
 			NarrativesManager.addNarrative(contentResolver, newNarrative);
 
 		} else {
-			// default to inserting at the end if no before/after id is given
-			if (insertBeforeId == null && insertAfterId == null) {
-				narrativeSequenceId = FramesManager.findLastFrameNarrativeSequenceId(contentResolver, narrativeId)
-						+ narrativeSequenceIdIncrement;
-
-			} else {
-				// insert new frame - increment necessary frames after the new frame's position
-				boolean insertAtStart = FrameItem.KEY_FRAME_ID_START.equals(insertBeforeId);
-				ArrayList<FrameItem> narrativeFrames = FramesManager.findFramesByParentId(contentResolver, narrativeId);
-				narrativeFrames.remove(0); // don't edit the newly inserted frame yet
-
-				int previousNarrativeSequenceId = -1;
-				boolean frameFound = false;
-				for (FrameItem frame : narrativeFrames) {
-					if (!frameFound && (insertAtStart || frame.getInternalId().equals(insertBeforeId))) {
-						frameFound = true;
-						narrativeSequenceId = frame.getNarrativeSequenceId();
-					}
-					if (frameFound) {
-						int currentNarrativeSequenceId = frame.getNarrativeSequenceId();
-						if (currentNarrativeSequenceId <= narrativeSequenceId
-								|| currentNarrativeSequenceId <= previousNarrativeSequenceId) {
-
-							frame.setNarrativeSequenceId(currentNarrativeSequenceId
-									+ Math.max(narrativeSequenceId - currentNarrativeSequenceId,
-											previousNarrativeSequenceId - currentNarrativeSequenceId) + 1);
-							if (insertAtStart) {
-								FramesManager.updateFrame(res, contentResolver, frame, true);
-								insertAtStart = false;
-							} else {
-								FramesManager.updateFrame(contentResolver, frame);
-							}
-							previousNarrativeSequenceId = frame.getNarrativeSequenceId();
-						} else {
-							break;
-						}
-					}
-					if (!frameFound && frame.getInternalId().equals(insertAfterId)) {
-						frameFound = true;
-						narrativeSequenceId = frame.getNarrativeSequenceId() + narrativeSequenceIdIncrement;
+			narrativeSequenceId = adjustNarrativeSequenceIds(narrativeId, insertAfterId);
+
+			if (insertAfterId != null && !FrameItem.KEY_FRAME_ID_START.equals(insertAfterId)) {
+				// get and update any inherited media
+				ArrayList<MediaItem> inheritedMedia = MediaManager.findMediaByParentId(contentResolver, insertAfterId);
+				for (final MediaItem media : inheritedMedia) {
+					if (media.getSpanFrames()) {
+						MediaManager.addMediaLink(contentResolver, mFrameInternalId, media.getInternalId());
 					}
 				}
 			}
 		}
 
-		FrameItem thisFrame = FramesManager.findFrameByInternalId(contentResolver, mFrameInternalId);
-		thisFrame.setNarrativeSequenceId(narrativeSequenceId);
-		FramesManager.updateFrame(contentResolver, thisFrame);
+		newFrame.setNarrativeSequenceId(narrativeSequenceId);
+		FramesManager.updateFrame(contentResolver, newFrame);
 	}
 
 	private void reloadAudioButtons() {
@@ -438,10 +452,18 @@ public class FrameEditorActivity extends MediaPhoneActivity {
 				(CenteredImageTextButton) findViewById(R.id.button_record_audio_3) };
 		audioButtons[2].setText("");
 
+		// reset locked (inherited) media
+		for (CenteredImageTextButton button : audioButtons) {
+			button.setCompoundDrawablesWithIntrinsicBounds(0, R.drawable.ic_frame_audio, 0, 0);
+		}
+
 		// load the audio content
 		int audioIndex = 0;
 		for (Entry<String, Integer> audioMedia : mFrameAudioItems.entrySet()) {
 			audioButtons[audioIndex].setText(StringUtilities.millisecondsToTimeString(audioMedia.getValue(), false));
+			if (audioIndex == mAudioLinkingIndex) {
+				audioButtons[audioIndex].setCompoundDrawablesWithIntrinsicBounds(0, mAudioLinkingDrawable, 0, 0);
+			}
 			audioIndex += 1;
 		}
 
@@ -470,7 +492,17 @@ public class FrameEditorActivity extends MediaPhoneActivity {
 				.getWidth() : cameraButton.getHeight()) * resourceValue.getFloat());
 		BitmapDrawable cachedIcon = new BitmapDrawable(resources, BitmapUtilities.loadAndCreateScaledBitmap(imagePath,
 				pictureSize, pictureSize, BitmapUtilities.ScalingLogic.CROP, true));
-		cameraButton.setCompoundDrawablesWithIntrinsicBounds(null, cachedIcon, null, null);
+		if (mImageLinkingDrawable != 0) {
+			Drawable[] layers = new Drawable[2];
+			layers[0] = cachedIcon;
+			layers[1] = resources.getDrawable(mImageLinkingDrawable);
+			LayerDrawable layerDrawable = new LayerDrawable(layers);
+			layerDrawable.setLayerInset(1, pictureSize - layers[1].getIntrinsicHeight(),
+					pictureSize - layers[1].getIntrinsicWidth(), 0, 0);
+			cameraButton.setCompoundDrawablesWithIntrinsicBounds(null, layerDrawable, null, null);
+		} else {
+			cameraButton.setCompoundDrawablesWithIntrinsicBounds(null, cachedIcon, null, null);
+		}
 	}
 
 	private void changeFrames(String newFrameId) {
@@ -495,14 +527,12 @@ public class FrameEditorActivity extends MediaPhoneActivity {
 
 	@Override
 	protected boolean swipeNext() {
-		return switchFrames(mFrameInternalId, R.id.menu_next_frame, R.string.extra_internal_id, false,
-				FrameEditorActivity.class);
+		return switchFrames(mFrameInternalId, R.id.menu_next_frame, null, false);
 	}
 
 	@Override
 	protected boolean swipePrevious() {
-		return switchFrames(mFrameInternalId, R.id.menu_previous_frame, R.string.extra_internal_id, false,
-				FrameEditorActivity.class);
+		return switchFrames(mFrameInternalId, R.id.menu_previous_frame, null, false);
 	}
 
 	private int getAudioIndex(int buttonId) {
@@ -517,6 +547,42 @@ public class FrameEditorActivity extends MediaPhoneActivity {
 		return -1;
 	}
 
+	private void editImage(String parentId) {
+		final Intent takePictureIntent = new Intent(FrameEditorActivity.this, CameraActivity.class);
+		takePictureIntent.putExtra(getString(R.string.extra_parent_id), parentId);
+		startActivityForResult(takePictureIntent, MediaPhone.R_id_intent_picture_editor);
+	}
+
+	private void editAudio(String parentId, int selectedAudioIndex, boolean preventSpanning) {
+		final Intent recordAudioIntent = new Intent(FrameEditorActivity.this, AudioActivity.class);
+		recordAudioIntent.putExtra(getString(R.string.extra_parent_id), parentId);
+
+		// index of -1 means don't edit existing
+		if (selectedAudioIndex >= 0) {
+			int currentIndex = 0;
+			for (String audioMediaId : mFrameAudioItems.keySet()) {
+				if (currentIndex == selectedAudioIndex) {
+					recordAudioIntent.putExtra(getString(R.string.extra_internal_id), audioMediaId);
+					break;
+				}
+				currentIndex += 1;
+			}
+		}
+
+		// unless we're editing (or replacing) inherited audio, or editing a single item we need to stop frame spanning
+		if (preventSpanning) {
+			recordAudioIntent.putExtra(getString(R.string.extra_prevent_frame_spanning), true);
+		}
+
+		startActivityForResult(recordAudioIntent, MediaPhone.R_id_intent_audio_editor);
+	}
+
+	private void editText(String parentId) {
+		final Intent addTextIntent = new Intent(FrameEditorActivity.this, TextActivity.class);
+		addTextIntent.putExtra(getString(R.string.extra_parent_id), parentId);
+		startActivityForResult(addTextIntent, MediaPhone.R_id_intent_text_editor);
+	}
+
 	public void handleButtonClicks(View currentButton) {
 		if (!verifyButtonClick(currentButton)) {
 			return;
@@ -529,32 +595,108 @@ public class FrameEditorActivity extends MediaPhoneActivity {
 				break;
 
 			case R.id.button_take_picture_video:
-				final Intent takePictureIntent = new Intent(FrameEditorActivity.this, CameraActivity.class);
-				takePictureIntent.putExtra(getString(R.string.extra_parent_id), mFrameInternalId);
-				startActivityForResult(takePictureIntent, MediaPhone.R_id_intent_picture_editor);
+				if (mImageInherited != null) {
+					AlertDialog.Builder builder = new AlertDialog.Builder(FrameEditorActivity.this);
+					builder.setTitle(R.string.span_media_edit_image_title);
+					builder.setMessage(R.string.span_media_edit_image);
+					builder.setIcon(android.R.drawable.ic_dialog_info);
+					builder.setNegativeButton(R.string.span_media_edit_original, new DialogInterface.OnClickListener() {
+						@Override
+						public void onClick(DialogInterface dialog, int which) {
+							// find the parent frame of the media item we want to edit, switch to it, then edit
+							MediaItem inheritedImage = MediaManager.findMediaByInternalId(getContentResolver(),
+									mImageInherited);
+							if (inheritedImage != null) {
+								final String newFrameId = inheritedImage.getParentId();
+								saveLastEditedFrame(newFrameId);
+								editImage(newFrameId);
+							}
+						}
+					});
+					builder.setPositiveButton(R.string.span_media_add_new, new DialogInterface.OnClickListener() {
+						@Override
+						public void onClick(DialogInterface dialog, int whichButton) {
+							endLinkedMediaItem(mImageInherited, mFrameInternalId); // remove the existing media link
+							editImage(mFrameInternalId);
+						}
+					});
+					AlertDialog alert = builder.create();
+					alert.show();
+				} else {
+					editImage(mFrameInternalId);
+				}
 				break;
 
 			case R.id.button_record_audio_1:
 			case R.id.button_record_audio_2:
 			case R.id.button_record_audio_3:
-				final Intent recordAudioIntent = new Intent(FrameEditorActivity.this, AudioActivity.class);
-				recordAudioIntent.putExtra(getString(R.string.extra_parent_id), mFrameInternalId);
-				int selectedAudioIndex = getAudioIndex(buttonId);
-				int currentIndex = 0;
-				for (String audioMediaId : mFrameAudioItems.keySet()) {
-					if (currentIndex == selectedAudioIndex) {
-						recordAudioIntent.putExtra(getString(R.string.extra_internal_id), audioMediaId);
-						break;
-					}
-					currentIndex += 1;
+				final int selectedAudioIndex = getAudioIndex(buttonId);
+				if (mAudioInherited != null && selectedAudioIndex == mAudioLinkingIndex) {
+					AlertDialog.Builder builder = new AlertDialog.Builder(FrameEditorActivity.this);
+					builder.setTitle(R.string.span_media_edit_audio_title);
+					builder.setMessage(R.string.span_media_edit_audio);
+					builder.setIcon(android.R.drawable.ic_dialog_info);
+					builder.setNegativeButton(R.string.span_media_edit_original, new DialogInterface.OnClickListener() {
+						@Override
+						public void onClick(DialogInterface dialog, int which) {
+							// find the parent frame of the media item we want to edit, switch to it, then edit
+							MediaItem inheritedAudio = MediaManager.findMediaByInternalId(getContentResolver(),
+									mAudioInherited);
+							if (inheritedAudio != null) {
+								final String newFrameId = inheritedAudio.getParentId();
+								saveLastEditedFrame(newFrameId);
+								editAudio(mFrameInternalId, selectedAudioIndex, false);
+							}
+						}
+					});
+					builder.setPositiveButton(R.string.span_media_add_new, new DialogInterface.OnClickListener() {
+						@Override
+						public void onClick(DialogInterface dialog, int whichButton) {
+							// remove the existing media links and edit a new audio item
+							endLinkedMediaItem(mAudioInherited, mFrameInternalId);
+							editAudio(mFrameInternalId, -1, false); // spanning is now allowed
+						}
+					});
+					AlertDialog alert = builder.create();
+					alert.show();
+				} else {
+					boolean preventSpanning = mAudioLinkingIndex >= 0 && selectedAudioIndex != mAudioLinkingIndex;
+					editAudio(mFrameInternalId, selectedAudioIndex, preventSpanning); // no spanning if not already
 				}
-				startActivityForResult(recordAudioIntent, MediaPhone.R_id_intent_audio_editor);
 				break;
 
 			case R.id.button_add_text:
-				final Intent addTextIntent = new Intent(FrameEditorActivity.this, TextActivity.class);
-				addTextIntent.putExtra(getString(R.string.extra_parent_id), mFrameInternalId);
-				startActivityForResult(addTextIntent, MediaPhone.R_id_intent_text_editor);
+				if (mTextInherited != null) {
+					AlertDialog.Builder builder = new AlertDialog.Builder(FrameEditorActivity.this);
+					builder.setTitle(R.string.span_media_edit_text_title);
+					builder.setMessage(R.string.span_media_edit_text);
+					builder.setIcon(android.R.drawable.ic_dialog_info);
+					builder.setNegativeButton(R.string.span_media_edit_original, new DialogInterface.OnClickListener() {
+						@Override
+						public void onClick(DialogInterface dialog, int which) {
+							// find the parent frame of the media item we want to edit, switch to it, then edit
+							MediaItem inheritedText = MediaManager.findMediaByInternalId(getContentResolver(),
+									mTextInherited);
+							if (inheritedText != null) {
+								final String newFrameId = inheritedText.getParentId();
+								saveLastEditedFrame(newFrameId);
+								editText(newFrameId);
+							}
+						}
+					});
+					builder.setPositiveButton(R.string.span_media_add_new, new DialogInterface.OnClickListener() {
+						@Override
+						public void onClick(DialogInterface dialog, int whichButton) {
+							// remove the existing media links and edit a new text item
+							endLinkedMediaItem(mTextInherited, mFrameInternalId);
+							editText(mFrameInternalId);
+						}
+					});
+					AlertDialog alert = builder.create();
+					alert.show();
+				} else {
+					editText(mFrameInternalId);
+				}
 				break;
 
 			case R.id.button_delete_frame:
@@ -562,7 +704,7 @@ public class FrameEditorActivity extends MediaPhoneActivity {
 				builder.setTitle(R.string.delete_frame_confirmation);
 				builder.setMessage(R.string.delete_frame_hint);
 				builder.setIcon(android.R.drawable.ic_dialog_alert);
-				builder.setNegativeButton(android.R.string.cancel, null);
+				builder.setNegativeButton(R.string.button_cancel, null);
 				builder.setPositiveButton(R.string.button_delete, new DialogInterface.OnClickListener() {
 					@Override
 					public void onClick(DialogInterface dialog, int whichButton) {
@@ -593,13 +735,8 @@ public class FrameEditorActivity extends MediaPhoneActivity {
 						setBackButtonIcons(FrameEditorActivity.this, R.id.button_finished_editing, 0, true);
 					}
 
-				} else if (resultCode == R.id.result_audio_ok_exit) {
-					// no point reloading if we're going to exit
-					// done this way (rather than reloading in this activity) so we get switching right/left animations
-					onBackPressed();
-				} else if (resultCode == R.id.result_audio_cancelled_exit) {
-					onBackPressed();
 				} else if (resultCode == R.id.result_narrative_deleted_exit) {
+					// no point reloading if we're going to exit
 					onBackPressed();
 				}
 				break;
diff --git a/src/ac/robinson/mediaphone/activity/NarrativeBrowserActivity.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/activity/NarrativeBrowserActivity.java
similarity index 97%
rename from src/ac/robinson/mediaphone/activity/NarrativeBrowserActivity.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/activity/NarrativeBrowserActivity.java
index fb222b1..41d64bd 100644
--- a/src/ac/robinson/mediaphone/activity/NarrativeBrowserActivity.java
+++ b/MediaPhone/src/main/java/ac/robinson/mediaphone/activity/NarrativeBrowserActivity.java
@@ -107,9 +107,6 @@ public class NarrativeBrowserActivity extends BrowserActivity {
 			// initialise preferences on first run, and perform an upgrade if applicable
 			PreferenceManager.setDefaultValues(this, R.xml.preferences, true);
 			UpgradeManager.upgradeApplication(NarrativeBrowserActivity.this);
-
-			// delete old media on startup (but not on screen rotation) - immediate task so we don't block the queue
-			runImmediateBackgroundTask(getMediaCleanupRunnable());
 		}
 
 		initialiseNarrativesView();
@@ -169,6 +166,7 @@ public class NarrativeBrowserActivity extends BrowserActivity {
 	protected void onDestroy() {
 		if (isFinishing()) {
 			updateListPositions(0, 0);
+			runQueuedBackgroundTask(getMediaCleanupRunnable()); // delete old media on exit
 		}
 		ImageCacheUtilities.cleanupCache();
 		super.onDestroy();
@@ -561,7 +559,7 @@ public class NarrativeBrowserActivity extends BrowserActivity {
 	}
 
 	private class FrameClickListener implements AdapterView.OnItemClickListener {
-		public void onItemClick(AdapterView<?> parent, View view, int position, long insertNewFrameBefore) {
+		public void onItemClick(AdapterView<?> parent, View view, int position, long insertNewFrameAfter) {
 			if (view != null && parent != null) {
 				getAndSaveNarrativeId(parent);
 				final FrameViewHolder holder = (FrameViewHolder) view.getTag();
@@ -570,12 +568,12 @@ public class NarrativeBrowserActivity extends BrowserActivity {
 				} else if (FrameItem.KEY_FRAME_ID_START.equals(holder.frameInternalId)
 						|| FrameItem.KEY_FRAME_ID_END.equals(holder.frameInternalId)) {
 					if (FrameItem.KEY_FRAME_ID_START.equals(holder.frameInternalId)) {
-						insertFrame(mCurrentSelectedNarrativeId, FrameItem.KEY_FRAME_ID_START);
+						insertFrameAfter(mCurrentSelectedNarrativeId, FrameItem.KEY_FRAME_ID_START);
 					} else {
-						insertFrame(mCurrentSelectedNarrativeId, null);
+						insertFrameAfter(mCurrentSelectedNarrativeId, null); // null = insert at end
 					}
-				} else if (insertNewFrameBefore != 0) {
-					insertFrame(mCurrentSelectedNarrativeId, holder.frameInternalId);
+				} else if (insertNewFrameAfter != 0) {
+					insertFrameAfter(mCurrentSelectedNarrativeId, holder.frameInternalId);
 				} else {
 					editFrame(holder.frameInternalId);
 				}
@@ -586,13 +584,13 @@ public class NarrativeBrowserActivity extends BrowserActivity {
 	private class FrameLongClickListener implements AdapterView.OnItemLongClickListener {
 		@Override
 		// this is a hack to allow long pressing one or two items via the same listener
-		public boolean onItemLongClick(AdapterView<?> parent, View view, int position, long insertNewFrameBefore) {
+		public boolean onItemLongClick(AdapterView<?> parent, View view, int position, long insertNewFrameAfter) {
 			if (view != null && parent != null) {
 				getAndSaveNarrativeId(parent);
 				final FrameViewHolder holder = (FrameViewHolder) view.getTag();
-				if (insertNewFrameBefore != 0) {
+				if (insertNewFrameAfter != 0) {
 					// used to be just on single press, but that made it confusing when a long double press did nothing
-					insertFrame(mCurrentSelectedNarrativeId, holder.frameInternalId);
+					insertFrameAfter(mCurrentSelectedNarrativeId, holder.frameInternalId);
 				} else {
 					playNarrative(holder.frameInternalId);
 				}
@@ -601,10 +599,10 @@ public class NarrativeBrowserActivity extends BrowserActivity {
 		}
 	}
 
-	private void insertFrame(String parentId, String insertBeforeId) {
+	private void insertFrameAfter(String parentId, String insertAfterId) {
 		final Intent frameEditorIntent = new Intent(NarrativeBrowserActivity.this, FrameEditorActivity.class);
 		frameEditorIntent.putExtra(getString(R.string.extra_parent_id), parentId);
-		frameEditorIntent.putExtra(getString(R.string.extra_insert_before_id), insertBeforeId);
+		frameEditorIntent.putExtra(getString(R.string.extra_insert_after_id), insertAfterId);
 		startActivityForResult(frameEditorIntent, MediaPhone.R_id_intent_frame_editor);
 	}
 
@@ -615,7 +613,7 @@ public class NarrativeBrowserActivity extends BrowserActivity {
 	}
 
 	private void playNarrative(String startFrameId) {
-		final Intent framePlayerIntent = new Intent(NarrativeBrowserActivity.this, NarrativePlayerActivity.class);
+		final Intent framePlayerIntent = new Intent(NarrativeBrowserActivity.this, PlaybackActivity.class);
 		framePlayerIntent.putExtra(getString(R.string.extra_internal_id), startFrameId);
 		startActivityForResult(framePlayerIntent, MediaPhone.R_id_intent_narrative_player);
 	}
@@ -627,7 +625,7 @@ public class NarrativeBrowserActivity extends BrowserActivity {
 			AlertDialog.Builder builder = new AlertDialog.Builder(NarrativeBrowserActivity.this);
 			builder.setTitle(R.string.title_add);
 			builder.setIcon(android.R.drawable.ic_dialog_info);
-			builder.setNegativeButton(android.R.string.cancel, null);
+			builder.setNegativeButton(R.string.button_cancel, null);
 			builder.setItems(items, new DialogInterface.OnClickListener() {
 				@Override
 				public void onClick(DialogInterface dialog, int item) {
diff --git a/MediaPhone/src/main/java/ac/robinson/mediaphone/activity/PlaybackActivity.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/activity/PlaybackActivity.java
new file mode 100644
index 0000000..1dea291
--- /dev/null
+++ b/MediaPhone/src/main/java/ac/robinson/mediaphone/activity/PlaybackActivity.java
@@ -0,0 +1,1181 @@
+/*
+ *  This file is part of Com-Me.
+ * 
+ *  Com-Me is free software; you can redistribute it and/or modify it 
+ *  under the terms of the GNU Lesser General Public License as 
+ *  published by the Free Software Foundation; either version 3 of the 
+ *  License, or (at your option) any later version.
+ *
+ *  Com-Me is distributed in the hope that it will be useful, but WITHOUT 
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
+ *  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General 
+ *  Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with Com-Me.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ac.robinson.mediaphone.activity;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+
+import ac.robinson.mediaphone.MediaPhone;
+import ac.robinson.mediaphone.MediaPhoneActivity;
+import ac.robinson.mediaphone.R;
+import ac.robinson.mediaphone.provider.FrameItem;
+import ac.robinson.mediaphone.provider.FramesManager;
+import ac.robinson.mediaphone.provider.MediaPhoneProvider;
+import ac.robinson.mediaphone.provider.NarrativeItem;
+import ac.robinson.mediaphone.provider.NarrativesManager;
+import ac.robinson.mediaphone.provider.PlaybackMediaHolder;
+import ac.robinson.mediaphone.provider.PlaybackNarrativeDescriptor;
+import ac.robinson.mediaphone.util.SystemUiHider;
+import ac.robinson.mediaphone.view.SendToBackRelativeLayout;
+import ac.robinson.util.BitmapUtilities;
+import ac.robinson.util.DebugUtilities;
+import ac.robinson.util.IOUtilities;
+import ac.robinson.util.UIUtilities;
+import ac.robinson.view.AutoResizeTextView;
+import ac.robinson.view.PlaybackController;
+import android.annotation.TargetApi;
+import android.content.ContentResolver;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.content.res.Configuration;
+import android.graphics.Bitmap;
+import android.graphics.Point;
+import android.media.AudioManager;
+import android.media.MediaPlayer;
+import android.media.MediaPlayer.OnCompletionListener;
+import android.media.MediaPlayer.OnErrorListener;
+import android.media.MediaPlayer.OnPreparedListener;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.Handler;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.animation.Animation;
+import android.view.animation.AnimationUtils;
+import android.widget.ImageView;
+
+import com.larvalabs.svgandroid.SVGParser;
+
+public class PlaybackActivity extends MediaPhoneActivity {
+
+	// time (ms) to begin caching media before it should play - needs to be larger than PLAYBACK_UPDATE_INTERVAL_MILLIS
+	// but should be smaller than most frame durations (default frame duration: 2500 ms) for best performance
+	private static final int PRELOAD_SIZE = 1000;
+	private static final int PLAYBACK_UPDATE_INTERVAL_MILLIS = 100; // how often to update the playback state (in ms)
+
+	private static final int AUTO_HIDE_INITIAL_DELAY_MILLIS = 250; // ms after startup before hide if mAutoHide set
+	private static final int AUTO_HIDE_DELAY_MILLIS = 3000; // ms after interaction before hiding if mAutoHide is set
+	private static final boolean TOGGLE_HIDE_ON_CLICK = true; // whether to toggle system UI on interaction or just show
+	private static final int UI_HIDER_FLAGS = SystemUiHider.FLAG_HIDE_NAVIGATION; // SystemUiHider.getInstance() flags
+
+	private boolean mAutoHide = true; // whether to hide system UI after AUTO_HIDE_DELAY_MILLIS ms
+
+	// the maximum number of audio items that will be played (or cached) at once - note that for preloading to work
+	// effectively we need to specify more than the ui allows (i.e., UI number (3) x 2 = 6)
+	private static final int MAX_AUDIO_ITEMS = 6;
+	private static final int MAX_AUDIO_LOADING_ERRORS = 2; // times an audio item can fail to load before we give up
+
+	private SystemUiHider mSystemUiHider; // for handling system UI hiding
+	private Point mScreenSize; // for loading images at the correct size
+	private int mFadeOutAnimationDuration; // for loading images so the fade completes when they should start
+
+	private ArrayList<PlaybackMediaHolder> mNarrativeContent = null; // the list of media items to play, start time asc
+	private ArrayList<PlaybackMediaHolder> mCurrentPlaybackItems = new ArrayList<PlaybackMediaHolder>();
+	private ArrayList<PlaybackMediaHolder> mOldPlaybackItems = new ArrayList<PlaybackMediaHolder>();
+
+	// this map holds the start times of every frame (ignoring content that spans multiple frames)
+	private LinkedHashMap<Integer, String> mTimeToFrameMap = new LinkedHashMap<Integer, String>();
+
+	private String mNarrativeInternalId = null; // the narrative we're playing
+
+	private int mNarrativeContentIndex = 0; // the next mNarrativeContent item to be processed
+
+	private int mPlaybackPositionMilliseconds = 0; // the current playback time, in milliseconds
+	private int mPlaybackDurationMilliseconds = 0; // the duration of the narrative, in milliseconds
+
+	private boolean mFinishedLoadingImages = false; // for tracking image loads, particularly during very short frames
+	private String mCurrentPlaybackImagePath = null; // cached path for avoiding reloads where possible
+	private String mBackgroundPlaybackImagePath = null; // cached next image path for avoiding reloads where possible
+	private Bitmap mAudioPictureBitmap = null; // cached audio icon for avoiding reloads where possible
+
+	private ArrayList<CustomMediaPlayer> mMediaPlayers = new ArrayList<CustomMediaPlayer>(MAX_AUDIO_ITEMS);
+
+	private boolean mPlaying = true; // whether we're currently playing or paused
+	private boolean mWasPlaying = false; // for saving the playback state while performing other actions
+	private boolean mStateChanged = false; // whether we must reload/resize as the screen has rotated or state changed
+
+	// UI elements for displaying, caching and animating media
+	private SendToBackRelativeLayout mPlaybackRoot;
+	private ImageView mCurrentPlaybackImage;
+	private ImageView mBackgroundPlaybackImage;
+	private AutoResizeTextView mPlaybackText;
+	private AutoResizeTextView mPlaybackTextWithImage;
+	private Animation mFadeOutAnimation;
+	private PlaybackController mPlaybackController;
+
+	@Override
+	protected void onCreate(Bundle savedInstanceState) {
+		super.onCreate(savedInstanceState);
+		UIUtilities.configureActionBar(this, true, true, R.string.title_playback, 0);
+		setContentView(R.layout.playback_view);
+
+		setupUI(); // initialise the interface and fullscreen controls/timeouts
+		refreshPlayback(); // initialise (and start) playback
+	}
+
+	@Override
+	protected void onPostCreate(Bundle savedInstanceState) {
+		super.onPostCreate(savedInstanceState);
+		delayedHide(AUTO_HIDE_INITIAL_DELAY_MILLIS); // the initial hide is shorter, for better presentation
+	}
+
+	@Override
+	public void onConfigurationChanged(Configuration newConfig) {
+		super.onConfigurationChanged(newConfig);
+
+		// our screen size has most likely changed - must reload cached images
+		resetImagePaths();
+		mAudioPictureBitmap = null;
+
+		// update the cached screen size
+		mScreenSize = UIUtilities.getScreenSize(getWindowManager());
+
+		// reload media - no playback delay so we can load immediately
+		mStateChanged = true;
+		mMediaAdvanceHandler.removeCallbacks(mMediaAdvanceRunnable);
+		mMediaAdvanceHandler.post(mMediaAdvanceRunnable);
+	}
+
+	@Override
+	protected void onDestroy() {
+		mHideHandler.removeCallbacks(mHideRunnable);
+		mMediaAdvanceHandler.removeCallbacks(mMediaAdvanceRunnable);
+		mImageLoadHandler.removeCallbacks(mImageLoadRunnable);
+		releasePlayers();
+		super.onDestroy();
+	}
+
+	@Override
+	public void onBackPressed() {
+		// when playing from the frame editor we need to track narrative deletion so we can exit the parent activity
+		boolean narrativeDeleted = false;
+		if (mNarrativeInternalId != null) {
+			NarrativeItem deletedNarrative = NarrativesManager.findNarrativeByInternalId(getContentResolver(),
+					mNarrativeInternalId);
+			if (deletedNarrative != null && deletedNarrative.getDeleted()) {
+				narrativeDeleted = true;
+				setResult(R.id.result_narrative_deleted_exit);
+			}
+		}
+
+		// otherwise, we save the last viewed frame so we can jump to that one in the narrative browser
+		if (!narrativeDeleted) {
+			saveLastEditedFrame(getCurrentFrameId());
+		}
+
+		super.onBackPressed();
+	}
+
+	private String getCurrentFrameId() {
+		String currentFrame = null;
+		for (LinkedHashMap.Entry<Integer, String> entry : mTimeToFrameMap.entrySet()) {
+			if (mPlaybackPositionMilliseconds >= entry.getKey()) {
+				currentFrame = entry.getValue();
+			} else {
+				break;
+			}
+		}
+		return currentFrame;
+	}
+
+	@Override
+	public boolean onCreateOptionsMenu(Menu menu) {
+		MenuInflater inflater = getMenuInflater();
+		inflater.inflate(R.menu.export_narrative, menu);
+		inflater.inflate(R.menu.edit_frame, menu);
+		inflater.inflate(R.menu.make_template, menu);
+		inflater.inflate(R.menu.delete_narrative, menu);
+		return super.onCreateOptionsMenu(menu);
+	}
+
+	@Override
+	public boolean onOptionsItemSelected(MenuItem item) {
+		handleNonPlaybackButtonClick(true);
+		if (mNarrativeInternalId != null) {
+			switch (item.getItemId()) {
+				case R.id.menu_make_template:
+					runQueuedBackgroundTask(getNarrativeTemplateRunnable(mNarrativeInternalId, true));
+					return true;
+
+				case R.id.menu_edit_frame:
+					final String currentFrameId = getCurrentFrameId();
+					mSystemUiHider.show(); // need to show before the calculation for image size in frame editor
+
+					final Intent frameEditorIntent = new Intent(PlaybackActivity.this, FrameEditorActivity.class);
+					frameEditorIntent.putExtra(getString(R.string.extra_internal_id), currentFrameId);
+					startActivityForResult(frameEditorIntent, MediaPhone.R_id_intent_frame_editor);
+
+					// make sure we reload playback when returning
+					mNarrativeContent = null;
+
+					// make sure not using any out of date images - done here so the ui will have updated before return
+					mCurrentPlaybackImage.setImageDrawable(null);
+					mBackgroundPlaybackImage.setImageDrawable(null);
+					resetImagePaths();
+
+					// make sure we return to the current frame
+					final Intent selfIntent = getIntent();
+					if (selfIntent != null) {
+						selfIntent.putExtra(getString(R.string.extra_internal_id), currentFrameId);
+						setIntent(selfIntent);
+					}
+					return true;
+
+				case R.id.menu_delete_narrative:
+					deleteNarrativeDialog(mNarrativeInternalId);
+					return true;
+
+				case R.id.menu_export_narrative:
+					exportContent(mNarrativeInternalId, false);
+					return true;
+			}
+		}
+		return super.onOptionsItemSelected(item);
+	}
+
+	@Override
+	protected void loadPreferences(SharedPreferences mediaPhoneSettings) {
+		// no normal preferences apply to this activity
+	}
+
+	@Override
+	protected void configureInterfacePreferences(SharedPreferences mediaPhoneSettings) {
+		// note: the soft back button preference is ignored during playback - we always show the button
+	}
+
+	@Override
+	public void onWindowFocusChanged(boolean hasFocus) {
+		if (hasFocus) {
+			if (!mPlaying) {
+				handleNonPlaybackButtonClick(false); // resume normal auto-hiding
+				refreshPlayback(); // update to remove deleted items from frame editing
+			}
+		}
+	}
+
+	/**
+	 * When clicking a button that is not part of the playback interface, we need to pause playback (in case a new
+	 * activity is launched, for example). We also temporarily stop hiding the playback bar. On the second call, we
+	 * resume hiding (and playback).
+	 * 
+	 * @param pause true if playback should be paused, false to resume after a non-playback action
+	 */
+	private void handleNonPlaybackButtonClick(boolean pause) {
+		if (pause) {
+			mAutoHide = false;
+			mWasPlaying = mPlaying;
+			if (mPlaying) {
+				mMediaController.pause();
+				mPlaybackController.refreshController();
+			}
+		} else {
+			if (mWasPlaying) {
+				mMediaController.play();
+				mPlaybackController.refreshController();
+			}
+			mWasPlaying = false;
+			mAutoHide = true;
+			delayedHide(AUTO_HIDE_DELAY_MILLIS);
+		}
+	}
+
+	private void setupUI() {
+
+		// keep hold of key UI elements
+		mPlaybackRoot = (SendToBackRelativeLayout) findViewById(R.id.playback_root);
+		mCurrentPlaybackImage = (ImageView) findViewById(R.id.playback_image);
+		mBackgroundPlaybackImage = (ImageView) findViewById(R.id.playback_image_background);
+		mPlaybackText = (AutoResizeTextView) findViewById(R.id.playback_text);
+		mPlaybackTextWithImage = (AutoResizeTextView) findViewById(R.id.playback_text_with_image);
+
+		// set up a SystemUiHider instance to control the system UI for this activity
+		final View controlsView = findViewById(R.id.playback_controls_wrapper);
+		final View contentView = mPlaybackRoot;
+		mSystemUiHider = SystemUiHider.getInstance(PlaybackActivity.this, contentView, UI_HIDER_FLAGS);
+		mSystemUiHider.setup();
+		mSystemUiHider.setOnVisibilityChangeListener(new SystemUiHider.OnVisibilityChangeListener() {
+
+			int mControlsHeight;
+			int mShortAnimTime;
+
+			@Override
+			@TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)
+			public void onVisibilityChange(boolean visible) {
+				if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {
+					// if the ViewPropertyAnimator API is available (Honeycomb MR2 and later), use it to animate the
+					// playback controls at the bottom of the screen (sliding up or down)
+					if (mControlsHeight == 0) {
+						mControlsHeight = controlsView.getHeight();
+					}
+					if (mShortAnimTime == 0) {
+						mShortAnimTime = getResources().getInteger(android.R.integer.config_shortAnimTime);
+					}
+					controlsView.animate().translationY(visible ? 0 : mControlsHeight).setDuration(mShortAnimTime);
+				} else {
+					// if the animation isn't available, simply show or hide (fading out) the playback controls
+					controlsView.clearAnimation();
+					if (!visible && controlsView.getVisibility() == View.VISIBLE) {
+						controlsView.startAnimation(AnimationUtils.loadAnimation(PlaybackActivity.this,
+								android.R.anim.fade_out));
+					}
+					controlsView.setVisibility(visible ? View.VISIBLE : View.GONE);
+				}
+
+				// schedule the next hide
+				if (visible) {
+					delayedHide(AUTO_HIDE_DELAY_MILLIS);
+				}
+			}
+		});
+
+		// set up non-playback button clicks
+		mPlaybackController = ((PlaybackController) findViewById(R.id.playback_controller));
+		mPlaybackController.setButtonListeners(new View.OnClickListener() {
+			@Override
+			public void onClick(View v) {
+				onBackPressed();
+			}
+		}, new View.OnClickListener() {
+			@Override
+			public void onClick(View v) {
+				handleNonPlaybackButtonClick(true);
+				if (mNarrativeInternalId != null) {
+					exportContent(mNarrativeInternalId, false);
+				}
+			}
+		});
+
+		// this animation is used between image frames - the duration value is subtracted from image items' durations so
+		// that they appear in the right place when fully loaded; use / 2 for exactly in the middle of the animation, or
+		// / 3 for nearer to the end of the animation
+		mFadeOutAnimation = AnimationUtils.loadAnimation(PlaybackActivity.this, android.R.anim.fade_out);
+		mFadeOutAnimationDuration = (int) mFadeOutAnimation.getDuration() / 3;
+
+		// make sure that the volume controls always control media volume (rather than ringtone etc.)
+		setVolumeControlStream(AudioManager.STREAM_MUSIC);
+
+		// cache screen size
+		mScreenSize = UIUtilities.getScreenSize(getWindowManager());
+
+		// make sure any user interaction will trigger manually showing or hiding the system UI
+		View.OnClickListener systemUIClickHandler = new View.OnClickListener() {
+			@Override
+			public void onClick(View view) {
+				// TODO: there's still an issue with having to double press to show this on some devices (for example
+				// HTC Sensation API v15), and that multiple toggles don't hide the system UI properly every other time
+				// on others, resulting in text being invisible for a short while (for example Nexus 7 API v17)
+				if (TOGGLE_HIDE_ON_CLICK) {
+					mSystemUiHider.toggle();
+				} else {
+					mSystemUiHider.show();
+				}
+			}
+		};
+		mCurrentPlaybackImage.setOnClickListener(systemUIClickHandler);
+		mBackgroundPlaybackImage.setOnClickListener(systemUIClickHandler);
+		mPlaybackText.setOnClickListener(systemUIClickHandler);
+		mPlaybackTextWithImage.setOnClickListener(systemUIClickHandler);
+	}
+
+	// handler and runnable for system UI hiding
+	Handler mHideHandler = new Handler();
+	Runnable mHideRunnable = new Runnable() {
+		@Override
+		public void run() {
+			if (mAutoHide) {
+				mSystemUiHider.hide();
+			}
+		}
+	};
+
+	/**
+	 * Schedules a call to mSystemUiHider.hide(), cancelling any previously scheduled calls
+	 * 
+	 * @param delayMillis how long to wait before hiding, in milliseconds
+	 */
+	private void delayedHide(int delayMillis) {
+		mHideHandler.removeCallbacks(mHideRunnable);
+		mHideHandler.postDelayed(mHideRunnable, delayMillis);
+	}
+
+	/**
+	 * Piggyback on touch events to stop scheduled hide() operations and prevent jarring hide during interaction
+	 */
+	@Override
+	public boolean dispatchTouchEvent(MotionEvent event) {
+		delayedHide(AUTO_HIDE_DELAY_MILLIS);
+		return super.dispatchTouchEvent(event);
+	}
+
+	/**
+	 * Piggyback on trackball events to stop scheduled hide() operations and prevent jarring hide during interaction
+	 */
+	@Override
+	public boolean dispatchTrackballEvent(MotionEvent event) {
+		delayedHide(AUTO_HIDE_DELAY_MILLIS);
+		return super.dispatchTrackballEvent(event);
+	}
+
+	// handler and runnable for scheduling playback advances
+	Handler mMediaAdvanceHandler = new Handler();
+	Runnable mMediaAdvanceRunnable = new Runnable() {
+		@Override
+		public void run() {
+			if (!mPlaybackController.isDragging()) {
+				if (mPlaying || mStateChanged) {
+					if (mPlaying) {
+						mPlaybackPositionMilliseconds += Math.min(PLAYBACK_UPDATE_INTERVAL_MILLIS,
+								mPlaybackDurationMilliseconds - mPlaybackPositionMilliseconds);
+					}
+					refreshPlayback();
+				}
+			} else {
+				delayedPlaybackAdvance(); // if dragging we still want to keep playing, just not advancing the timer
+			}
+		}
+	};
+
+	/**
+	 * Schedules a call to refreshPlayback() (via mMediaAdvanceRunnable), cancelling any previously scheduled calls
+	 */
+	private void delayedPlaybackAdvance() {
+		int delayMillis = Math.min(PLAYBACK_UPDATE_INTERVAL_MILLIS, mPlaybackDurationMilliseconds
+				- mPlaybackPositionMilliseconds);
+
+		// we limit the lower bound to 50ms because otherwise we'd overload the message queue and nothing would happen
+		mMediaAdvanceHandler.removeCallbacks(mMediaAdvanceRunnable);
+		mMediaAdvanceHandler.postDelayed(mMediaAdvanceRunnable, delayMillis < 50 ? 50 : delayMillis);
+	}
+
+	// handler and runnable for scheduling loading the full quality image when seeking
+	Handler mImageLoadHandler = new Handler();
+	Runnable mImageLoadRunnable = new Runnable() {
+		@Override
+		public void run() {
+			if (mCurrentPlaybackImagePath != null) {
+				// don't fade in the image here - if we do, we can possibly get a race condition with loading and
+				// fading, resulting in both being shown, one on top of the other; best to just load in place
+				loadScreenSizedImageInBackground(mCurrentPlaybackImage, mCurrentPlaybackImagePath, true,
+						MediaPhoneActivity.FadeType.NONE);
+			}
+		}
+	};
+
+	/**
+	 * Schedules a load of the image in mCurrentPlaybackImagePath, cancelling any previously scheduled load requests
+	 */
+	private void delayedImageLoad(int delayMs) {
+		mImageLoadHandler.removeCallbacks(mImageLoadRunnable);
+		mImageLoadHandler.postDelayed(mImageLoadRunnable, delayMs);
+	}
+
+	/**
+	 * Initialise everything required for playback
+	 * 
+	 * @return true if initialisation succeeded, false otherwise
+	 */
+	private boolean initialisePlayback() {
+		// we need the parent id of the narrative we want to load
+		final Intent intent = getIntent();
+		String startFrameId = null;
+		if (intent != null) {
+			startFrameId = intent.getStringExtra(getString(R.string.extra_internal_id));
+		}
+		if (startFrameId == null) {
+			return false;
+		}
+
+		// load narrative content TODO: lazily load - AsyncTask? (but remember single-threading on newer SDK versions)
+		ContentResolver contentResolver = getContentResolver();
+		FrameItem currentFrame = FramesManager.findFrameByInternalId(contentResolver, startFrameId);
+		if (currentFrame == null) {
+			return false;
+		}
+		mNarrativeInternalId = currentFrame.getParentId();
+		NarrativeItem currentNarrative = NarrativesManager.findNarrativeByInternalId(contentResolver,
+				mNarrativeInternalId);
+		PlaybackNarrativeDescriptor narrativeProperties = new PlaybackNarrativeDescriptor(mFadeOutAnimationDuration);
+		mNarrativeContent = currentNarrative.getPlaybackContent(contentResolver, startFrameId, narrativeProperties);
+		mCurrentPlaybackItems.clear();
+
+		// initialise the start time (of the requested frame) and the narrative's duration
+		mNarrativeContentIndex = 0;
+		mPlaybackPositionMilliseconds = narrativeProperties.mNarrativeStartTime;
+		mPlaybackDurationMilliseconds = narrativeProperties.mNarrativeDuration;
+		mTimeToFrameMap = narrativeProperties.mTimeToFrameMap;
+
+		// reset and release audio players; a new set will be built up when needed
+		releasePlayers();
+
+		// initialise the media controller and set up a listener for when manual seek ends
+		mPlaybackController.setMediaPlayerControl(mMediaController);
+		mPlaybackController.setUseCustomSeekButtons(true); // we handle rewind/ffwd ourselves
+		mPlaybackController.setSeekEndedListener(new PlaybackController.SeekEndedListener() {
+			@Override
+			public void seekEnded() {
+				// when a drag/seek ends we need to make sure we don't continue reloading any cached images
+				cancelLoadingScreenSizedImageInBackground(mCurrentPlaybackImage);
+				mImageLoadHandler.removeCallbacks(mImageLoadRunnable);
+
+				// the current and previous cached images are highly likely to be wrong - reload
+				resetImagePaths();
+
+				// like in seekTo, this is inefficient, but probably not worth working around
+				mNarrativeContentIndex = 0;
+
+				// schedule playback to continue
+				if (mPlaying) {
+					playPreparedAudio(true);
+				} else {
+					pauseAudio();
+				}
+				mStateChanged = true; // we've changed state - forces a reload when playback is paused
+				delayedPlaybackAdvance();
+			}
+		});
+
+		return true;
+	}
+
+	/**
+	 * Refresh the current playback state, loading media where appropriate. Will call initialisePlayback() first if
+	 * mNarrativeContent is null
+	 * 
+	 * <b>Note:</b> this should never be called directly, except for in onCreate when first starting and in seekTo (a
+	 * special case) - use delayedPlaybackAdvance() at all other times
+	 */
+	private void refreshPlayback() {
+		// first load - initialise narrative content and audio players
+		if (mNarrativeContent == null) {
+			if (!initialisePlayback()) {
+				UIUtilities.showToast(PlaybackActivity.this, R.string.error_loading_narrative_player);
+				onBackPressed();
+				return;
+			}
+		}
+
+		// we must have narrative content to be able to play
+		final int narrativeSize = mNarrativeContent.size();
+		if (narrativeSize <= 0) {
+			UIUtilities.showToast(PlaybackActivity.this, R.string.error_loading_narrative_player);
+			onBackPressed();
+			return;
+		}
+
+		// we preload content to speed up transitions and more accurately keep playback time
+		final int preCachedPlaybackTime = mPlaybackPositionMilliseconds + PRELOAD_SIZE;
+
+		// remove any media that is now outdated (also stopping outdated audio in the process)
+		boolean itemsRemoved = false;
+		if (mNarrativeContentIndex == 0) { // if we're resetting, remove all items to preserve their order
+			mCurrentPlaybackItems.clear();
+			itemsRemoved = true;
+		} else {
+			mOldPlaybackItems.clear();
+			for (PlaybackMediaHolder holder : mCurrentPlaybackItems) {
+				if (holder.getStartTime(true) > preCachedPlaybackTime
+						|| holder.getEndTime(true) <= mPlaybackPositionMilliseconds) {
+					mOldPlaybackItems.add(holder);
+					if (holder.mMediaType == MediaPhoneProvider.TYPE_AUDIO) {
+						CustomMediaPlayer p = getExistingAudio(holder.mMediaPath);
+						if (p != null) {
+							try {
+								p.stop();
+							} catch (IllegalStateException e) {
+							}
+							p.resetCustomAttributes();
+						}
+						break;
+					}
+				}
+			}
+			itemsRemoved = mCurrentPlaybackItems.removeAll(mOldPlaybackItems);
+		}
+
+		// now get any media that covers the current timestamp plus our preload period
+		boolean itemsAdded = false;
+		for (int i = mNarrativeContentIndex; i < narrativeSize; i++) {
+			final PlaybackMediaHolder holder = mNarrativeContent.get(i);
+			if (holder.getStartTime(true) <= preCachedPlaybackTime
+					&& holder.getEndTime(true) > mPlaybackPositionMilliseconds
+					&& new File(holder.mMediaPath).length() > 0) {
+				if (!mCurrentPlaybackItems.contains(holder)) {
+					mCurrentPlaybackItems.add(holder);
+				}
+				mNarrativeContentIndex = i + 1;
+				itemsAdded = true;
+			} else if (holder.getStartTime(true) > preCachedPlaybackTime) {
+				break;
+			}
+		}
+
+		// check if we're at the end of playback - pause if so; if dragging, then this is ok (will check after)
+		if (!mPlaybackController.isDragging() && mPlaybackPositionMilliseconds >= mPlaybackDurationMilliseconds) {
+			mPlaying = false;
+			mPlaybackController.refreshController();
+			if (mAutoHide && !mSystemUiHider.isVisible()) {
+				mSystemUiHider.show();
+			}
+		}
+
+		// check whether we need to reload any existing content (due to screen rotation); if not, exit
+		if (!itemsRemoved && !itemsAdded) {
+			boolean mustReload = mStateChanged;
+			if (!mustReload) {
+				// media items that we might have missed (started within the time period) need to be loaded
+				for (PlaybackMediaHolder holder : mCurrentPlaybackItems) {
+					final int timeDifference = mPlaybackPositionMilliseconds - holder.getStartTime(true);
+					if (timeDifference > 0 && timeDifference <= PLAYBACK_UPDATE_INTERVAL_MILLIS) {
+						mustReload = true;
+						break;
+					}
+				}
+			}
+			if (!mustReload) {
+				delayedPlaybackAdvance();
+				return; // nothing else to do
+			}
+		}
+
+		mStateChanged = false; // if we get here we're reloading, so reset rotation tracking
+
+		// load images and audio before text so we can set up their display/playback at the right times
+		// TODO: there are potential memory issues here - setting an ImageView's drawable doesn't reliably clear the
+		// memory allocated to the existing drawable - do we need to get the drawables and recycle the bitmaps?
+		// (if so, need to beware of recycling the audio image bitmap, or just check for isRecycled() on load)
+		PlaybackMediaHolder textItem = null;
+		boolean hasImage = false;
+		boolean hasAudio = false;
+		for (PlaybackMediaHolder holder : mCurrentPlaybackItems) {
+			// no need to check end time - we've removed invalid items already
+			boolean itemAppliesNow = holder.getStartTime(true) <= mPlaybackPositionMilliseconds;
+
+			switch (holder.mMediaType) {
+				case MediaPhoneProvider.TYPE_IMAGE_FRONT:
+				case MediaPhoneProvider.TYPE_IMAGE_BACK:
+				case MediaPhoneProvider.TYPE_VIDEO:
+
+					hasImage |= itemAppliesNow;
+					if (mPlaybackController.isDragging()) {
+
+						// while dragging we need to trade off good UI performance against memory usage (could
+						// overflow limit if we just background loaded everything) - instead, load a downscaled
+						// version on the UI thread then update to show the full resolution version after a timeout
+						if (itemAppliesNow && !holder.mMediaPath.equals(mCurrentPlaybackImagePath)) {
+							cancelLoadingScreenSizedImageInBackground(mCurrentPlaybackImage);
+							Bitmap scaledBitmap = null;
+							try {
+								scaledBitmap = BitmapUtilities.loadAndCreateScaledBitmap(holder.mMediaPath,
+										mScreenSize.x, mScreenSize.y, BitmapUtilities.ScalingLogic.DOWNSCALE, true);
+							} catch (Throwable t) {
+								// out of memory...
+							}
+							mCurrentPlaybackImage.setImageBitmap(scaledBitmap);
+
+							mCurrentPlaybackImagePath = holder.mMediaPath;
+							mBackgroundPlaybackImagePath = null; // any previously cached image will now be wrong
+
+							delayedImageLoad(PLAYBACK_UPDATE_INTERVAL_MILLIS);
+						}
+
+					} else if (itemAppliesNow && mCurrentPlaybackImagePath == null) {
+
+						// if an item applies now and there's nothing stored in the current path it's the first image
+						// - for the first image, it's a better UI experience if loading happens in situ (~250ms)
+						if (holder.mMediaPath.equals(mBackgroundPlaybackImagePath)) {
+							// if the first frame wasn't an image, then we'll have already loaded it in the background
+							swapBackgroundImage();
+						} else {
+							Bitmap scaledBitmap = null;
+							try {
+								scaledBitmap = BitmapUtilities.loadAndCreateScaledBitmap(holder.mMediaPath,
+										mScreenSize.x, mScreenSize.y, BitmapUtilities.ScalingLogic.FIT, true);
+							} catch (Throwable t) { // out of memory...
+							}
+							mCurrentPlaybackImage.setImageBitmap(scaledBitmap);
+						}
+						mCurrentPlaybackImagePath = holder.mMediaPath;
+
+					} else if (!holder.mMediaPath.equals(mCurrentPlaybackImagePath)) {
+
+						// preload the next image (making sure not to reload either the current or multiple nexts)
+						// did try preloading a downscaled version here while the full version was loading, but that
+						// led to out of memory errors on some devices - just load the normal version instead
+						if (!mFinishedLoadingImages && !holder.mMediaPath.equals(mBackgroundPlaybackImagePath)) {
+							mImageLoadHandler.removeCallbacks(mImageLoadRunnable); // no need to load prevs any more
+							loadScreenSizedImageInBackground(mBackgroundPlaybackImage, holder.mMediaPath, true,
+									MediaPhoneActivity.FadeType.NONE);
+							mBackgroundPlaybackImagePath = holder.mMediaPath;
+							mFinishedLoadingImages = true;
+
+						} else if (itemAppliesNow) {
+							// if necessary, swap the preloaded image to replace the current image
+							swapBackgroundImage();
+							mCurrentPlaybackImagePath = holder.mMediaPath;
+						}
+					}
+					break;
+
+				case MediaPhoneProvider.TYPE_AUDIO:
+					if (getExistingAudio(holder.mMediaPath) == null) {
+						CustomMediaPlayer currentMediaPlayer = getEmptyPlayer();
+						if (currentMediaPlayer == null) {
+							// no available audio players - most likely trying to cache too far in advance; ignore
+							break;
+						} else {
+							currentMediaPlayer.mMediaPath = holder.mMediaPath;
+							currentMediaPlayer.mMediaStartTime = holder.getStartTime(true);
+							currentMediaPlayer.mPlaybackPrepared = false;
+						}
+
+						FileInputStream playerInputStream = null;
+						boolean dataLoaded = false;
+						int dataLoadingErrorCount = 0;
+						while (!dataLoaded && dataLoadingErrorCount <= MAX_AUDIO_LOADING_ERRORS) {
+							try {
+								// can't play from data dir (private; permissions don't work), must use input stream
+								currentMediaPlayer.reset();
+
+								playerInputStream = new FileInputStream(new File(holder.mMediaPath));
+								currentMediaPlayer.setDataSource(playerInputStream.getFD());
+								currentMediaPlayer.setLooping(false);
+								currentMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
+								currentMediaPlayer.setOnPreparedListener(mMediaPlayerPreparedListener);
+								currentMediaPlayer.setOnCompletionListener(mMediaPlayerCompletionListener);
+								currentMediaPlayer.setOnErrorListener(mMediaPlayerErrorListener);
+								currentMediaPlayer.prepareAsync();
+								dataLoaded = true;
+							} catch (Throwable t) {
+								// sometimes setDataSource fails mysteriously - loop to open, rather than failing
+								dataLoaded = false;
+								dataLoadingErrorCount += 1;
+							} finally {
+								IOUtilities.closeStream(playerInputStream);
+								playerInputStream = null;
+							}
+						}
+
+						if (!dataLoaded) {
+							// we couldn't load anything - reset this player so we can reuse it
+							currentMediaPlayer.resetCustomAttributes();
+						} else {
+							hasAudio |= itemAppliesNow;
+						}
+					} else {
+						hasAudio |= itemAppliesNow;
+					}
+					break;
+
+				case MediaPhoneProvider.TYPE_TEXT:
+					if (itemAppliesNow) {
+						textItem = holder; // text is loaded after all other content
+					}
+					break;
+			}
+		}
+
+		// no image content on this frame - remove
+		if (!hasImage && !hasAudio) {
+			mCurrentPlaybackImage.setImageDrawable(null);
+			mImageLoadHandler.removeCallbacks(mImageLoadRunnable);
+			mCurrentPlaybackImagePath = null; // the current image is highly likely to be wrong - reload
+		}
+
+		// load text last so we know whether we've loaded image/audio or not
+		if (textItem != null) {
+			// TODO: currently we load text every time - could check, but this would require loading the file anyway...
+			String textContents = IOUtilities.getFileContents(textItem.mMediaPath).trim();
+			if (!TextUtils.isEmpty(textContents)) {
+				if (hasImage) {
+					mPlaybackText.setVisibility(View.GONE);
+					mPlaybackTextWithImage.setText(textContents);
+					mPlaybackTextWithImage.setVisibility(View.VISIBLE);
+				} else {
+					mPlaybackTextWithImage.setVisibility(View.GONE);
+					mPlaybackText.setText(textContents);
+					mPlaybackText.setVisibility(View.VISIBLE);
+				}
+			} else {
+				mPlaybackText.setVisibility(View.GONE);
+				mPlaybackTextWithImage.setVisibility(View.GONE);
+			}
+		} else {
+			mPlaybackText.setVisibility(View.GONE);
+			mPlaybackTextWithImage.setVisibility(View.GONE);
+
+			// an audio-only frame - show the audio icon
+			if (!hasImage && hasAudio) {
+				if (mAudioPictureBitmap == null) {
+					try {
+						mAudioPictureBitmap = SVGParser.getSVGFromResource(getResources(), R.raw.ic_audio_playback)
+								.getBitmap(mScreenSize.x, mScreenSize.y);
+					} catch (Throwable t) { // out of memory, or parse error...
+					}
+				}
+				mCurrentPlaybackImagePath = String.valueOf(R.raw.ic_audio_playback); // now the current image
+				mCurrentPlaybackImage.setImageBitmap(mAudioPictureBitmap);
+			}
+		}
+
+		// start/seek any pre-cached audio players that might now be ready
+		if (hasAudio) {
+			playPreparedAudio(false);
+		}
+
+		// queue advancing the playback handler
+		delayedPlaybackAdvance();
+	}
+
+	private void swapBackgroundImage() {
+		// if the image hasn't yet loaded, it's likely we're playing a narrative with really short frames - to try to
+		// keep up with playback, cancel loading and just show a downscaled version; queuing the full-sized version
+		if (mBackgroundPlaybackImage.getTag() != null) {
+			// TODO: check that this doesn't cause problems on low-capability v14+ devices (e.g., HTC Sensation)
+			cancelLoadingScreenSizedImageInBackground(mBackgroundPlaybackImage);
+			Bitmap scaledBitmap = null;
+			try {
+				scaledBitmap = BitmapUtilities.loadAndCreateScaledBitmap(mBackgroundPlaybackImagePath, mScreenSize.x,
+						mScreenSize.y, BitmapUtilities.ScalingLogic.DOWNSCALE, true);
+			} catch (Throwable t) { // out of memory...
+			}
+			mBackgroundPlaybackImage.setImageBitmap(scaledBitmap);
+
+			// load the full-resolution image, but wait longer here just in case we're loading lots of short frames
+			delayedImageLoad(PLAYBACK_UPDATE_INTERVAL_MILLIS * 5);
+		}
+
+		ImageView temp = mCurrentPlaybackImage;
+		mCurrentPlaybackImage = mBackgroundPlaybackImage;
+		mBackgroundPlaybackImage = temp;
+
+		// the new image should be at the back to fade between frames - use a custom layout for this
+		mPlaybackRoot.sendChildToBack(mCurrentPlaybackImage);
+		mCurrentPlaybackImage.setVisibility(View.VISIBLE);
+
+		// now fade out the old image
+		// TODO: if we've seeked, and swap from a null image before loading, this looks bad; probably a non-problem...
+		mBackgroundPlaybackImage.startAnimation(mFadeOutAnimation);
+		mBackgroundPlaybackImage.setVisibility(View.GONE);
+
+		// mBackgroundPlaybackImage.setImageDrawable(null); // don't do this - transitions look bad
+		mBackgroundPlaybackImagePath = null;
+		mFinishedLoadingImages = false;
+	}
+
+	/**
+	 * Reset our cached image paths when reloading from, for example, a screen rotation, or an edit operation
+	 */
+	private void resetImagePaths() {
+		mCurrentPlaybackImagePath = null;
+		mBackgroundPlaybackImagePath = null;
+		mFinishedLoadingImages = false;
+	}
+
+	/**
+	 * Check whether the given file is currently being played by one of our CustomMediaPlayer instances. If so, return
+	 * the player; if not, return null.
+	 * 
+	 * @param audioPath
+	 * @return the CustomMediaPlayer that is playing this file, or null if the file is not being played
+	 */
+	private CustomMediaPlayer getExistingAudio(String audioPath) {
+		if (audioPath == null) {
+			return null;
+		}
+		for (CustomMediaPlayer p : mMediaPlayers) {
+			if (audioPath.equals(p.mMediaPath)) {
+				return p;
+			}
+		}
+		return null;
+	}
+
+	/**
+	 * Get a free CustomMediaPlayer from the global list
+	 * 
+	 * @return an unused CustomMediaPlayer
+	 */
+	private CustomMediaPlayer getEmptyPlayer() {
+		for (CustomMediaPlayer p : mMediaPlayers) {
+			if (p.mMediaPath == null) {
+				p.resetCustomAttributes();
+				return p;
+			}
+		}
+		if (mMediaPlayers.size() < MAX_AUDIO_ITEMS) {
+			final CustomMediaPlayer p = new CustomMediaPlayer();
+			mMediaPlayers.add(p);
+			return p;
+		}
+		return null;
+	}
+
+	/**
+	 * If the narrative is playing, start/resume/seek any audio items that are prepared, but only when <b>all</b> items
+	 * that apply to the current playback position have been prepared. If any applicable items are not prepared, nothing
+	 * will be done.
+	 */
+	private void playPreparedAudio(boolean force) {
+		if (mPlaying) {
+			boolean allPrepared = true;
+			boolean hasAudio = false; // if there's no audio we'd still be allPrepared mode otherwise
+			for (CustomMediaPlayer player : mMediaPlayers) {
+				if (player.mMediaPath != null) {
+					hasAudio = true;
+					if (player.mMediaStartTime <= mPlaybackPositionMilliseconds && !player.mPlaybackPrepared) {
+						allPrepared = false;
+						break;
+					}
+				}
+			}
+			if (hasAudio && allPrepared) {
+				for (CustomMediaPlayer player : mMediaPlayers) {
+					if (player.mPlaybackPrepared) {
+						try {
+							if (player.mMediaStartTime <= mPlaybackPositionMilliseconds
+									&& player.mMediaEndTime > mPlaybackPositionMilliseconds) {
+								if (!player.isPlaying() && (force || !player.mHasPlayed)) {
+									player.seekTo(mPlaybackPositionMilliseconds - player.mMediaStartTime);
+									player.start();
+								}
+							} else {
+								if (player.isPlaying()) {
+									player.pause();
+								}
+							}
+						} catch (IllegalStateException e) {
+							player.resetCustomAttributes();
+						}
+					}
+				}
+			}
+		}
+	}
+
+	private void seekPlayingAudio() {
+		for (CustomMediaPlayer player : mMediaPlayers) {
+			if (player.mMediaStartTime <= mPlaybackPositionMilliseconds
+					&& player.mMediaEndTime > mPlaybackPositionMilliseconds) {
+				if (player.mPlaybackPrepared) {
+					try {
+						player.seekTo(mPlaybackPositionMilliseconds - player.mMediaStartTime);
+						if (!player.isPlaying()) {
+							player.start();
+						}
+					} catch (IllegalStateException e) {
+						player.resetCustomAttributes();
+					}
+				}
+			} else {
+				if (player.mPlaybackPrepared) {
+					try {
+						if (player.isPlaying()) {
+							player.pause();
+						}
+					} catch (IllegalStateException e) {
+						player.resetCustomAttributes();
+					}
+				}
+
+				// need to track whether audio has played to deal with timing errors between visuals and audio;
+				// but when seeking need to re-enable audio that has already been played so it can be replayed
+				player.mHasPlayed = false;
+			}
+		}
+	}
+
+	private void pauseAudio() {
+		for (CustomMediaPlayer player : mMediaPlayers) {
+			if (player.mPlaybackPrepared) {
+				try {
+					if (player.isPlaying()) {
+						player.pause();
+					}
+				} catch (IllegalStateException e) {
+					player.resetCustomAttributes();
+				}
+			}
+		}
+	}
+
+	private OnPreparedListener mMediaPlayerPreparedListener = new OnPreparedListener() {
+		@Override
+		public void onPrepared(MediaPlayer mp) {
+			if (mp instanceof CustomMediaPlayer) {
+				CustomMediaPlayer player = (CustomMediaPlayer) mp;
+				player.mPlaybackPrepared = true;
+				player.mMediaEndTime = player.mMediaStartTime + player.getDuration();
+			}
+			playPreparedAudio(false); // play audio if appropriate - will wait for all applicable items to be prepared
+		}
+	};
+
+	private OnCompletionListener mMediaPlayerCompletionListener = new OnCompletionListener() {
+		@Override
+		public void onCompletion(MediaPlayer mp) {
+			// at the moment we don't need to do anything here
+		}
+	};
+
+	private OnErrorListener mMediaPlayerErrorListener = new OnErrorListener() {
+		@Override
+		public boolean onError(MediaPlayer mp, int what, int extra) {
+			if (MediaPhone.DEBUG)
+				Log.d(DebugUtilities.getLogTag(this), "Playback error - what: " + what + ", extra: " + extra);
+			return false; // not handled -> onCompletionListener will be called
+		}
+	};
+
+	/**
+	 * Releases all CustomMediaPlayer instances
+	 */
+	private void releasePlayers() {
+		for (CustomMediaPlayer p : mMediaPlayers) {
+			p.release();
+		}
+		mMediaPlayers.clear();
+	}
+
+	/**
+	 * A custom MediaPlayer that can store the file path of the item being played, its start time in the narrative, and
+	 * whether the player has been prepared
+	 */
+	private class CustomMediaPlayer extends MediaPlayer {
+		public boolean mPlaybackPrepared = false;
+		public boolean mHasPlayed = false;
+		public String mMediaPath = null;
+		public int mMediaStartTime = 0;
+		public int mMediaEndTime = 0;
+
+		public void resetCustomAttributes() {
+			mPlaybackPrepared = false;
+			mHasPlayed = false;
+			mMediaPath = null;
+			mMediaStartTime = 0;
+			mMediaEndTime = 0;
+			reset();
+		}
+
+		@Override
+		public void start() {
+			mHasPlayed = true;
+			super.start();
+		}
+	}
+
+	/**
+	 * Handler for user interaction with the narrative player. Most operations are self explanatory, but seeking is
+	 * slightly more complex as we need to ensure that media items are loaded at the correct time and in the right order
+	 */
+	private PlaybackController.MediaPlayerControl mMediaController = new PlaybackController.MediaPlayerControl() {
+		@Override
+		public void play() {
+			if (mPlaybackPositionMilliseconds >= mPlaybackDurationMilliseconds) {
+				// if we've reached the end of playback, start again from the beginning
+				mNarrativeContentIndex = 0;
+				mPlaybackPositionMilliseconds = 0;
+				resetImagePaths();
+			}
+			mPlaying = true;
+			playPreparedAudio(true);
+			delayedPlaybackAdvance();
+		}
+
+		@Override
+		public void pause() {
+			// TODO: stop sending handler messages? (rather than just not updating) - need to consider seeking if so
+			mPlaying = false;
+			pauseAudio();
+		}
+
+		@Override
+		public int getDuration() {
+			return mPlaybackDurationMilliseconds;
+		}
+
+		@Override
+		public int getCurrentPosition() {
+			return mPlaybackPositionMilliseconds;
+		}
+
+		@Override
+		public void seekTo(int pos) {
+			if (pos < mPlaybackPositionMilliseconds) {
+				// seeking backwards is far less efficient than forwards - we can't just loop back until we find a
+				// limit, because the list is ordered by start time and items can last a long time (we would need a list
+				// of items ordered by end time to be able to seek backwards more efficiently)
+				mNarrativeContentIndex = 0;
+			}
+
+			// update the playback position and seek audio to the correct place
+			mPlaybackPositionMilliseconds = pos;
+			seekPlayingAudio();
+
+			// we call refreshPlayback directly, so must stop any queued playback advances
+			mMediaAdvanceHandler.removeCallbacks(mMediaAdvanceRunnable);
+			refreshPlayback();
+		}
+
+		@Override
+		public void seekButton(int direction) {
+			// find the previous and next frames in the frame map
+			int previousFrameTime = 0;
+			int tempFrameTime = 0;
+			int nextFrameTime = mPlaybackDurationMilliseconds;
+			int comparisonTime = mPlaybackPositionMilliseconds + 1; // to allow repeated pressing of next key
+			for (int time : mTimeToFrameMap.keySet()) {
+				if (time < comparisonTime) {
+					previousFrameTime = tempFrameTime;
+					tempFrameTime = time;
+				} else {
+					nextFrameTime = time;
+					break;
+				}
+			}
+
+			// cancel pending images and reset cached paths
+			cancelLoadingScreenSizedImageInBackground(mCurrentPlaybackImage);
+			resetImagePaths(); // any previously cached image will now be wrong
+
+			if (direction < 0) {
+				mNarrativeContentIndex = 0; // as in seekTo(), seeking backwards is far less efficient than forwards
+				mPlaybackPositionMilliseconds = previousFrameTime;
+			} else {
+				mPlaybackPositionMilliseconds = nextFrameTime;
+			}
+			playPreparedAudio(true);
+
+			// we call refreshPlayback directly, so must stop any queued playback advances
+			mMediaAdvanceHandler.removeCallbacks(mMediaAdvanceRunnable);
+			refreshPlayback();
+		}
+
+		@Override
+		public boolean isPlaying() {
+			return mPlaying;
+		}
+	};
+}
diff --git a/src/ac/robinson/mediaphone/activity/PreferencesActivity.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/activity/PreferencesActivity.java
similarity index 100%
rename from src/ac/robinson/mediaphone/activity/PreferencesActivity.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/activity/PreferencesActivity.java
diff --git a/src/ac/robinson/mediaphone/activity/SaveNarrativeActivity.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/activity/SaveNarrativeActivity.java
similarity index 97%
rename from src/ac/robinson/mediaphone/activity/SaveNarrativeActivity.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/activity/SaveNarrativeActivity.java
index 35125ba..8bf9e20 100644
--- a/src/ac/robinson/mediaphone/activity/SaveNarrativeActivity.java
+++ b/MediaPhone/src/main/java/ac/robinson/mediaphone/activity/SaveNarrativeActivity.java
@@ -121,7 +121,7 @@ public class SaveNarrativeActivity extends MediaPhoneActivity {
 		layout.addView(input);
 		nameDialog.setView(layout);
 
-		nameDialog.setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
+		nameDialog.setPositiveButton(R.string.button_save, new DialogInterface.OnClickListener() {
 			@Override
 			public void onClick(DialogInterface dialog, int button) {
 				File outputDirectory = new File(Environment
@@ -139,7 +139,7 @@ public class SaveNarrativeActivity extends MediaPhoneActivity {
 			}
 		});
 
-		nameDialog.setNegativeButton(android.R.string.cancel, new DialogInterface.OnClickListener() {
+		nameDialog.setNegativeButton(R.string.button_cancel, new DialogInterface.OnClickListener() {
 			@Override
 			public void onClick(DialogInterface dialog, int button) {
 				dialog.dismiss();
diff --git a/src/ac/robinson/mediaphone/activity/TemplateBrowserActivity.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/activity/TemplateBrowserActivity.java
similarity index 96%
rename from src/ac/robinson/mediaphone/activity/TemplateBrowserActivity.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/activity/TemplateBrowserActivity.java
index 46bb54a..ae3b4be 100644
--- a/src/ac/robinson/mediaphone/activity/TemplateBrowserActivity.java
+++ b/MediaPhone/src/main/java/ac/robinson/mediaphone/activity/TemplateBrowserActivity.java
@@ -24,7 +24,6 @@ import ac.robinson.mediaphone.BrowserActivity;
 import ac.robinson.mediaphone.MediaPhone;
 import ac.robinson.mediaphone.R;
 import ac.robinson.mediaphone.provider.FrameAdapter;
-import ac.robinson.mediaphone.provider.MediaPhoneProvider;
 import ac.robinson.mediaphone.provider.NarrativeAdapter;
 import ac.robinson.mediaphone.provider.NarrativeItem;
 import ac.robinson.mediaphone.provider.NarrativesManager;
@@ -73,7 +72,6 @@ public class TemplateBrowserActivity extends BrowserActivity {
 	private boolean mFingerUp = true;
 
 	private View mFrameAdapterEmptyView = null;
-	private String mNewNarrativeInternalId = null;
 
 	@Override
 	protected void onCreate(Bundle savedInstanceState) {
@@ -356,10 +354,8 @@ public class TemplateBrowserActivity extends BrowserActivity {
 		public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
 			// sometimes we get the event without the view (they released at the last minute?)
 			if (view != null && parent != null) {
-				mNewNarrativeInternalId = MediaPhoneProvider.getNewInternalId();
 				runQueuedBackgroundTask(getNarrativeTemplateRunnable(
-						((FrameAdapter) ((HorizontalListView) parent).getAdapter()).getParentFilter(),
-						mNewNarrativeInternalId, false));
+						((FrameAdapter) ((HorizontalListView) parent).getAdapter()).getParentFilter(), false));
 			}
 		}
 	}
@@ -383,7 +379,7 @@ public class TemplateBrowserActivity extends BrowserActivity {
 				builder.setTitle(R.string.template_actions);
 				// builder.setMessage(R.string.edit_template_hint);
 				builder.setIcon(android.R.drawable.ic_dialog_info);
-				builder.setNegativeButton(android.R.string.cancel, null);
+				builder.setNegativeButton(R.string.button_cancel, null);
 				builder.setItems(items, new DialogInterface.OnClickListener() {
 					@Override
 					public void onClick(DialogInterface dialog, int item) {
@@ -396,7 +392,7 @@ public class TemplateBrowserActivity extends BrowserActivity {
 								builder.setTitle(R.string.delete_template_confirmation);
 								builder.setMessage(R.string.delete_template_hint);
 								builder.setIcon(android.R.drawable.ic_dialog_alert);
-								builder.setNegativeButton(android.R.string.cancel, null);
+								builder.setNegativeButton(R.string.button_cancel, null);
 								builder.setPositiveButton(R.string.button_delete,
 										new DialogInterface.OnClickListener() {
 											@Override
@@ -410,15 +406,13 @@ public class TemplateBrowserActivity extends BrowserActivity {
 														R.string.delete_template_succeeded);
 											}
 										});
-								AlertDialog alert = builder.create();
-								alert.show();
+								builder.show();
 								break;
 						}
 						dialog.dismiss();
 					}
 				});
-				AlertDialog alert = builder.create();
-				alert.show();
+				builder.show();
 			}
 			return true;
 		}
diff --git a/src/ac/robinson/mediaphone/activity/TextActivity.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/activity/TextActivity.java
similarity index 70%
rename from src/ac/robinson/mediaphone/activity/TextActivity.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/activity/TextActivity.java
index 8d8298f..b66db6e 100644
--- a/src/ac/robinson/mediaphone/activity/TextActivity.java
+++ b/MediaPhone/src/main/java/ac/robinson/mediaphone/activity/TextActivity.java
@@ -55,30 +55,22 @@ public class TextActivity extends MediaPhoneActivity {
 
 	private String mMediaItemInternalId = null;
 	private boolean mHasEditedMedia = false;
-	private boolean mShowOptionsMenu = false;
-	private boolean mSwitchedFrames = false;
 
 	private EditText mEditText;
 
 	@Override
 	protected void onCreate(Bundle savedInstanceState) {
 		super.onCreate(savedInstanceState);
-		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
-			setTheme(R.style.default_light_theme); // light looks *much* better beyond honeycomb
-		}
 		UIUtilities.configureActionBar(this, true, true, R.string.title_frame_editor, R.string.title_text);
 		setContentView(R.layout.text_view);
 
 		mEditText = (EditText) findViewById(R.id.text_view);
 		mMediaItemInternalId = null;
-		mShowOptionsMenu = false;
-		mSwitchedFrames = false;
 
 		// load previous state on screen rotation
 		if (savedInstanceState != null) {
 			mMediaItemInternalId = savedInstanceState.getString(getString(R.string.extra_internal_id));
 			mHasEditedMedia = savedInstanceState.getBoolean(getString(R.string.extra_media_edited));
-			mSwitchedFrames = savedInstanceState.getBoolean(getString(R.string.extra_switched_frames));
 			if (mHasEditedMedia) {
 				setBackButtonIcons(TextActivity.this, R.id.button_finished_text, 0, true);
 			}
@@ -92,26 +84,13 @@ public class TextActivity extends MediaPhoneActivity {
 	public void onSaveInstanceState(Bundle savedInstanceState) {
 		savedInstanceState.putString(getString(R.string.extra_internal_id), mMediaItemInternalId);
 		savedInstanceState.putBoolean(getString(R.string.extra_media_edited), mHasEditedMedia);
-		savedInstanceState.putBoolean(getString(R.string.extra_switched_frames), mSwitchedFrames);
 		super.onSaveInstanceState(savedInstanceState);
 	}
 
-	@Override
-	public void onWindowFocusChanged(boolean hasFocus) {
-		super.onWindowFocusChanged(hasFocus);
-		if (hasFocus) {
-			if (mShowOptionsMenu) {
-				mShowOptionsMenu = false;
-				openOptionsMenu();
-			}
-			registerForSwipeEvents(); // here to avoid crashing due to double-swiping
-		}
-	}
-
 	@Override
 	protected void onResume() {
 		super.onResume();
-		// we want to get notifications when the text is changed (but after adding existing text)
+		// we want to get notifications when the text is changed (but after adding existing text in onCreate)
 		mEditText.addTextChangedListener(mTextWatcher);
 	}
 
@@ -126,7 +105,7 @@ public class TextActivity extends MediaPhoneActivity {
 		@Override
 		public void onTextChanged(CharSequence s, int start, int before, int count) {
 			if (!mHasEditedMedia) {
-				mHasEditedMedia = true; // so the action bar refreshes to the correct icon
+				mHasEditedMedia = true; // so we keep the same icon on rotation
 				setBackButtonIcons(TextActivity.this, R.id.button_finished_text, 0, true);
 			}
 			mHasEditedMedia = true;
@@ -151,7 +130,48 @@ public class TextActivity extends MediaPhoneActivity {
 
 		final MediaItem textMediaItem = MediaManager.findMediaByInternalId(getContentResolver(), mMediaItemInternalId);
 		if (textMediaItem != null) {
-			saveCurrentText(textMediaItem);
+			// check whether we need to save the text or delete the media item (if empty)
+			final Editable mediaText = mEditText.getText();
+			if (!TextUtils.isEmpty(mediaText)) {
+				if (mHasEditedMedia) {
+
+					// update the text duration if not user-set (note negative value)
+					if (textMediaItem.getDurationMilliseconds() <= 0) {
+						textMediaItem.setDurationMilliseconds(-MediaItem.getTextDurationMilliseconds(mediaText
+								.toString()));
+						MediaManager.updateMedia(getContentResolver(), textMediaItem);
+					}
+
+					Runnable textUpdateRunnable = new Runnable() {
+						@Override
+						public void run() {
+							// save the current text
+							FileOutputStream fileOutputStream = null;
+							try {
+								fileOutputStream = new FileOutputStream(textMediaItem.getFile());
+								fileOutputStream.write(mediaText.toString().getBytes());
+								// fileOutputStream.flush(); // does nothing in FileOutputStream
+							} catch (Throwable t) {
+								// no need to update the icon - nothing has changed
+							} finally {
+								IOUtilities.closeStream(fileOutputStream);
+							}
+						}
+					};
+
+					// update this frame's icon with the new text; propagate to following frames if applicable
+					updateMediaFrameIcons(textMediaItem, textUpdateRunnable);
+				}
+			} else {
+				// delete the media item
+				textMediaItem.setDeleted(true);
+				MediaManager.updateMedia(getContentResolver(), textMediaItem);
+
+				// we've been deleted - propagate changes to our parent frame and any following frames
+				inheritMediaAndDeleteItemLinks(textMediaItem.getParentId(), textMediaItem, null);
+			}
+
+			// save the id of the frame we're part of so that the frame editor gets notified
 			saveLastEditedFrame(textMediaItem.getParentId());
 		}
 
@@ -179,24 +199,29 @@ public class TextActivity extends MediaPhoneActivity {
 	@Override
 	public boolean onCreateOptionsMenu(Menu menu) {
 		MenuInflater inflater = getMenuInflater();
-		setupMenuNavigationButtonsFromMedia(inflater, menu, getContentResolver(), mMediaItemInternalId, mHasEditedMedia);
+		createMediaMenuNavigationButtons(inflater, menu, mHasEditedMedia);
 		return super.onCreateOptionsMenu(menu);
 	}
 
 	@Override
-	public boolean onOptionsItemSelected(MenuItem item) {
-		final int itemId = item.getItemId();
-		switch (itemId) {
-			case R.id.menu_previous_frame:
-			case R.id.menu_next_frame:
-				performSwitchFrames(itemId, true);
-				return true;
+	public boolean onPrepareOptionsMenu(Menu menu) {
+		prepareMediaMenuNavigationButtons(menu, mMediaItemInternalId);
+		return super.onPrepareOptionsMenu(menu);
+	}
 
+	@Override
+	public boolean onOptionsItemSelected(MenuItem item) {
+		switch (item.getItemId()) {
 			case R.id.menu_add_frame:
 				final MediaItem textMediaItem = MediaManager.findMediaByInternalId(getContentResolver(),
 						mMediaItemInternalId);
-				if (textMediaItem != null && saveCurrentText(textMediaItem)) {
-					runQueuedBackgroundTask(getFrameSplitterRunnable(mMediaItemInternalId));
+				if (textMediaItem != null && !TextUtils.isEmpty(mEditText.getText())) {
+					final String newFrameId = insertFrameAfterMedia(textMediaItem);
+					final Intent addTextIntent = new Intent(TextActivity.this, TextActivity.class);
+					addTextIntent.putExtra(getString(R.string.extra_parent_id), newFrameId);
+					startActivity(addTextIntent);
+
+					onBackPressed();
 				} else {
 					UIUtilities.showToast(TextActivity.this, R.string.split_text_add_content);
 				}
@@ -240,8 +265,6 @@ public class TextActivity extends MediaPhoneActivity {
 			final Intent intent = getIntent();
 			if (intent != null) {
 				parentInternalId = intent.getStringExtra(getString(R.string.extra_parent_id));
-				mShowOptionsMenu = intent.getBooleanExtra(getString(R.string.extra_show_options_menu), false);
-				mSwitchedFrames = intent.getBooleanExtra(getString(R.string.extra_switched_frames), false);
 			}
 			if (parentInternalId == null) {
 				UIUtilities.showToast(TextActivity.this, R.string.error_loading_text_editor);
@@ -250,7 +273,7 @@ public class TextActivity extends MediaPhoneActivity {
 				return;
 			}
 
-			// get existing content if it exists
+			// get existing content if it exists (ignores links)
 			mMediaItemInternalId = FrameItem.getTextContentId(contentResolver, parentInternalId);
 
 			// add a new media item if it doesn't already exist
@@ -265,11 +288,14 @@ public class TextActivity extends MediaPhoneActivity {
 		// load any existing text
 		final MediaItem textMediaItem = MediaManager.findMediaByInternalId(contentResolver, mMediaItemInternalId);
 		if (textMediaItem != null) {
-			if (TextUtils.isEmpty(mEditText.getText().toString())) { // don't delete existing (i.e. changed) content
+			updateSpanFramesButtonIcon(R.id.button_toggle_mode_text, textMediaItem.getSpanFrames(), false);
+
+			if (TextUtils.isEmpty(mEditText.getText())) { // don't delete existing (i.e. changed) content
 				mEditText.setText(IOUtilities.getFileContents(textMediaItem.getFile().getAbsolutePath()).toString());
 			}
 			// show the keyboard as a further hint (below Honeycomb it is automatic)
-			if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) { // TODO: improve these keyboard manipulations
+			// TODO: improve/remove these keyboard manipulations
+			if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
 				try {
 					InputMethodManager manager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
 					manager.toggleSoftInput(InputMethodManager.SHOW_FORCED, 0);
@@ -285,67 +311,6 @@ public class TextActivity extends MediaPhoneActivity {
 		}
 	}
 
-	private boolean saveCurrentText(MediaItem textMediaItem) {
-		String mediaText = mEditText.getText().toString();
-		if (!TextUtils.isEmpty(mediaText)) {
-			if (mHasEditedMedia) {
-				FileOutputStream fileOutputStream = null;
-				try {
-					fileOutputStream = new FileOutputStream(textMediaItem.getFile());
-					fileOutputStream.write(mediaText.getBytes());
-					fileOutputStream.flush(); // does nothing in FileOutputStream
-				} catch (Throwable t) {
-					return false;
-				} finally {
-					IOUtilities.closeStream(fileOutputStream);
-				}
-
-				// update the icon
-				runImmediateBackgroundTask(getFrameIconUpdaterRunnable(textMediaItem.getParentId()));
-			}
-			return true;
-		} else {
-			// so we don't leave an empty stub
-			textMediaItem.setDeleted(true);
-			MediaManager.updateMedia(getContentResolver(), textMediaItem);
-
-			// update the icon to remove the text
-			runImmediateBackgroundTask(getFrameIconUpdaterRunnable(textMediaItem.getParentId()));
-			return false;
-		}
-	}
-
-	@Override
-	protected void onBackgroundTaskCompleted(int taskId) {
-		if (taskId == R.id.split_frame_task_complete) {
-			mEditText.setText(""); // otherwise we copy to the new frame
-			mHasEditedMedia = true; // because now the original media item has a new id, so must reload in editor
-			setBackButtonIcons(TextActivity.this, R.id.button_finished_text, 0, false);
-		}
-	}
-
-	private boolean performSwitchFrames(int itemId, boolean showOptionsMenu) {
-		if (mMediaItemInternalId != null) {
-			final MediaItem textMediaItem = MediaManager.findMediaByInternalId(getContentResolver(),
-					mMediaItemInternalId);
-			if (textMediaItem != null) {
-				return switchFrames(textMediaItem.getParentId(), itemId, R.string.extra_parent_id, showOptionsMenu,
-						TextActivity.class);
-			}
-		}
-		return false;
-	}
-
-	@Override
-	protected boolean swipeNext() {
-		return performSwitchFrames(R.id.menu_next_frame, false);
-	}
-
-	@Override
-	protected boolean swipePrevious() {
-		return performSwitchFrames(R.id.menu_previous_frame, false);
-	}
-
 	public void handleButtonClicks(View currentButton) {
 		if (!verifyButtonClick(currentButton)) {
 			return;
@@ -356,12 +321,30 @@ public class TextActivity extends MediaPhoneActivity {
 				onBackPressed();
 				break;
 
+			case R.id.button_toggle_mode_text:
+				// TODO: only relevant for text, but if they update text, set spanning, then update text again we end up
+				// updating all following frame icons twice, which is unnecessary. Could track whether they've entered
+				// text after toggling frame spanning, but this may be overkill for a situation that rarely happens?
+				final MediaItem textMediaItem = MediaManager.findMediaByInternalId(getContentResolver(),
+						mMediaItemInternalId);
+				if (textMediaItem != null && !TextUtils.isEmpty(mEditText.getText())) {
+					mHasEditedMedia = true; // so we update/inherit on exit and show the media edited icon
+					setBackButtonIcons(TextActivity.this, R.id.button_finished_text, 0, true);
+					boolean frameSpanning = toggleFrameSpanningMedia(textMediaItem);
+					updateSpanFramesButtonIcon(R.id.button_toggle_mode_text, frameSpanning, true);
+					UIUtilities.showToast(TextActivity.this, frameSpanning ? R.string.span_text_multiple_frames
+							: R.string.span_text_single_frame);
+				} else {
+					UIUtilities.showToast(TextActivity.this, R.string.span_text_add_content);
+				}
+				break;
+
 			case R.id.button_delete_text:
 				final AlertDialog.Builder builder = new AlertDialog.Builder(TextActivity.this);
 				builder.setTitle(R.string.delete_text_confirmation);
 				builder.setMessage(R.string.delete_text_hint);
 				builder.setIcon(android.R.drawable.ic_dialog_alert);
-				builder.setNegativeButton(android.R.string.cancel, null);
+				builder.setNegativeButton(R.string.button_cancel, null);
 				builder.setPositiveButton(R.string.button_delete, new DialogInterface.OnClickListener() {
 					@Override
 					public void onClick(DialogInterface dialog, int whichButton) {
@@ -370,8 +353,7 @@ public class TextActivity extends MediaPhoneActivity {
 						onBackPressed();
 					}
 				});
-				final AlertDialog alert = builder.create();
-				alert.show();
+				builder.show();
 				break;
 		}
 	}
diff --git a/src/ac/robinson/mediaphone/importing/BluetoothObserver.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/importing/BluetoothObserver.java
similarity index 100%
rename from src/ac/robinson/mediaphone/importing/BluetoothObserver.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/importing/BluetoothObserver.java
diff --git a/src/ac/robinson/mediaphone/importing/ImportedFileParser.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/importing/ImportedFileParser.java
similarity index 100%
rename from src/ac/robinson/mediaphone/importing/ImportedFileParser.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/importing/ImportedFileParser.java
diff --git a/src/ac/robinson/mediaphone/provider/FrameAdapter.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/provider/FrameAdapter.java
similarity index 98%
rename from src/ac/robinson/mediaphone/provider/FrameAdapter.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/provider/FrameAdapter.java
index 9d042fc..adf30be 100644
--- a/src/ac/robinson/mediaphone/provider/FrameAdapter.java
+++ b/MediaPhone/src/main/java/ac/robinson/mediaphone/provider/FrameAdapter.java
@@ -46,7 +46,7 @@ import android.widget.ProgressBar;
 
 public class FrameAdapter extends CursorAdapter implements FilterQueryProvider {
 
-	//TODO: switch to Loader like in NarrativeAdapter (and load these at query time)
+	// TODO: switch to Loader like in NarrativeAdapter (and load these at query time)
 	private final int mInternalIdIndex;
 	private final int mParentIdIndex;
 
@@ -183,7 +183,7 @@ public class FrameAdapter extends CursorAdapter implements FilterQueryProvider {
 
 		final CrossFadeDrawable transition = new CrossFadeDrawable(mDefaultIconBitmap, null);
 		transition.setCallback(view);
-		transition.setCrossFadeEnabled(true);
+		transition.setCrossFadeEnabled(false);
 		holder.transition = transition;
 
 		return view;
@@ -199,7 +199,7 @@ public class FrameAdapter extends CursorAdapter implements FilterQueryProvider {
 
 		if (FrameItem.KEY_FRAME_ID_START.equals(holder.frameInternalId)
 				|| FrameItem.KEY_FRAME_ID_END.equals(holder.frameInternalId)) {
-			holder.display.setImageResource(R.drawable.ic_menu_add);
+			holder.display.setImageResource(R.drawable.ic_narratives_add);
 			// holder.display.setBackgroundResource(R.drawable.button_white_small);
 			holder.loader.setVisibility(View.GONE);
 			holder.queryIcon = false;
diff --git a/src/ac/robinson/mediaphone/provider/FrameItem.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/provider/FrameItem.java
similarity index 97%
rename from src/ac/robinson/mediaphone/provider/FrameItem.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/provider/FrameItem.java
index 1c02d95..169cf5d 100644
--- a/src/ac/robinson/mediaphone/provider/FrameItem.java
+++ b/MediaPhone/src/main/java/ac/robinson/mediaphone/provider/FrameItem.java
@@ -22,7 +22,6 @@ package ac.robinson.mediaphone.provider;
 
 import java.io.File;
 import java.util.ArrayList;
-import java.util.Iterator;
 
 import ac.robinson.mediaphone.MediaPhone;
 import ac.robinson.mediaphone.R;
@@ -36,10 +35,10 @@ import android.database.Cursor;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Paint;
+import android.graphics.Paint.Align;
 import android.graphics.Rect;
 import android.graphics.RectF;
 import android.graphics.Typeface;
-import android.graphics.Paint.Align;
 import android.net.Uri;
 import android.os.Build;
 import android.provider.BaseColumns;
@@ -56,8 +55,6 @@ public class FrameItem implements BaseColumns {
 	public static final String[] PROJECTION_ALL = new String[] { FrameItem._ID, FrameItem.INTERNAL_ID,
 			FrameItem.PARENT_ID, FrameItem.SEQUENCE_ID, FrameItem.DATE_CREATED, FrameItem.DELETED };
 
-	public static final String[] PROJECTION_SEQEUENCE_ID = new String[] { FrameItem.SEQUENCE_ID };
-
 	public static final String[] PROJECTION_INTERNAL_ID = new String[] { FrameItem.INTERNAL_ID };
 
 	public static enum NavigationMode {
@@ -147,14 +144,15 @@ public class FrameItem implements BaseColumns {
 	}
 
 	/**
-	 * Get existing text content if it exists
+	 * Get existing text content if it exists. Note: does <b>not</b> include links.
 	 * 
 	 * @param contentResolver
 	 * @param parentInternalId The internal ID of the frame to search within
 	 * @return The internal ID of the text content, or null if none exists
 	 */
 	public static String getTextContentId(ContentResolver contentResolver, String parentInternalId) {
-		ArrayList<MediaItem> frameComponents = MediaManager.findMediaByParentId(contentResolver, parentInternalId);
+		ArrayList<MediaItem> frameComponents = MediaManager.findMediaByParentId(contentResolver, parentInternalId,
+				false);
 		for (MediaItem media : frameComponents) {
 			if (media.getType() == MediaPhoneProvider.TYPE_TEXT) {
 				return media.getInternalId();
@@ -164,14 +162,15 @@ public class FrameItem implements BaseColumns {
 	}
 
 	/**
-	 * Get existing image content if it exists
+	 * Get existing image content if it exists. Note: does <b>not</b> include links.
 	 * 
 	 * @param contentResolver
 	 * @param parentInternalId The internal ID of the frame to search within
 	 * @return The internal ID of the image content, or null if none exists
 	 */
 	public static String getImageContentId(ContentResolver contentResolver, String parentInternalId) {
-		ArrayList<MediaItem> frameComponents = MediaManager.findMediaByParentId(contentResolver, parentInternalId);
+		ArrayList<MediaItem> frameComponents = MediaManager.findMediaByParentId(contentResolver, parentInternalId,
+				false);
 		for (MediaItem media : frameComponents) {
 			switch (media.getType()) {
 				case MediaPhoneProvider.TYPE_IMAGE_BACK:
@@ -222,9 +221,7 @@ public class FrameItem implements BaseColumns {
 		int iconHeight = res.getDimensionPixelSize(R.dimen.frame_icon_height);
 
 		// load the image icon and prepare the other media items
-		Iterator<MediaItem> iterator = frameComponents.iterator();
-		while (iterator.hasNext()) {
-			MediaItem currentItem = iterator.next();
+		for (MediaItem currentItem : frameComponents) {
 			int currentType = currentItem.getType();
 
 			if (!imageLoaded
diff --git a/src/ac/robinson/mediaphone/provider/FramesManager.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/provider/FramesManager.java
similarity index 74%
rename from src/ac/robinson/mediaphone/provider/FramesManager.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/provider/FramesManager.java
index a3d7861..473a0bd 100644
--- a/src/ac/robinson/mediaphone/provider/FramesManager.java
+++ b/MediaPhone/src/main/java/ac/robinson/mediaphone/provider/FramesManager.java
@@ -59,8 +59,26 @@ public class FramesManager {
 		mDeletedSelection = selection.toString();
 	}
 
+	/**
+	 * Update a list of frame icons, removing all icons from the cache first to ensure the old version is not displayed
+	 * 
+	 * @param frameIds
+	 */
+	public static void reloadFrameIcons(Resources resources, ContentResolver contentResolver, ArrayList<String> frameIds) {
+		for (String frameId : frameIds) {
+			ImageCacheUtilities.setLoadingIcon(FrameItem.getCacheId(frameId));
+		}
+		for (String frameId : frameIds) {
+			reloadFrameIcon(resources, contentResolver, frameId);
+		}
+	}
+
 	public static void reloadFrameIcon(Resources resources, ContentResolver contentResolver, FrameItem frame,
 			boolean frameIsInDatabase) {
+		if (frame == null) {
+			return; // if run from switchFrames then the existing frame could have been deleted - ignore
+		}
+
 		final String frameCacheId = frame.getCacheId();
 		ImageCacheUtilities.setLoadingIcon(frameCacheId);
 
@@ -108,8 +126,8 @@ public class FramesManager {
 	}
 
 	/**
-	 * Note: to delete a frame item, do setDeleted the item itself and then update to the database. On the next
-	 * application launch, the frame's media files will be deleted and the database entry will be cleaned up. This
+	 * Note: to delete a frame item, do setDeleted on the item itself and then update to the database. On the next
+	 * application exit, the frame's media files will be deleted and the database entry will be cleaned up. This
 	 * approach speeds up interaction and means that we only need one background thread semi-regularly for deletion
 	 */
 	public static boolean deleteFrameFromBackgroundTask(ContentResolver contentResolver, String frameId) {
@@ -230,16 +248,16 @@ public class FramesManager {
 		return null;
 	}
 
-	public static int findLastFrameNarrativeSequenceId(ContentResolver contentResolver, String parentId) {
+	public static String findLastFrameByParentId(ContentResolver contentResolver, String parentId) {
 		final String[] arguments1 = mArguments1;
 		arguments1[0] = parentId;
 		Cursor c = null;
 		try {
-			c = contentResolver.query(FrameItem.CONTENT_URI, FrameItem.PROJECTION_SEQEUENCE_ID,
-					mFrameParentIdSelection, arguments1, FrameItem.DEFAULT_SORT_ORDER);
+			c = contentResolver.query(FrameItem.CONTENT_URI, FrameItem.PROJECTION_INTERNAL_ID, mFrameParentIdSelection,
+					arguments1, FrameItem.DEFAULT_SORT_ORDER);
 			if (c.moveToLast()) {
 				// for speed, don't get the whole FrameItem
-				final int lastId = c.getInt(c.getColumnIndexOrThrow(FrameItem.SEQUENCE_ID));
+				final String lastId = c.getString(c.getColumnIndexOrThrow(FrameItem.INTERNAL_ID));
 				return lastId;
 			}
 		} finally {
@@ -247,13 +265,13 @@ public class FramesManager {
 				c.close();
 			}
 		}
-		return -1; // no existing frames (but should not happen)
+		return null; // no existing frames (but should not happen)
 	}
 
 	public static int countFramesByParentId(ContentResolver contentResolver, String parentId) {
 		final String[] arguments1 = mArguments1;
 		arguments1[0] = parentId;
-		Cursor c = contentResolver.query(FrameItem.CONTENT_URI, FrameItem.PROJECTION_SEQEUENCE_ID, // doesn't matter
+		Cursor c = contentResolver.query(FrameItem.CONTENT_URI, FrameItem.PROJECTION_INTERNAL_ID,
 				mFrameParentIdSelection, arguments1, FrameItem.DEFAULT_SORT_ORDER);
 		final int count = c.getCount();
 		c.close();
@@ -279,4 +297,53 @@ public class FramesManager {
 		}
 		return frameIds;
 	}
+
+	/**
+	 * Returns a list of the frame ids following the given frame id. If includePrevious is set then the frame before the
+	 * given frame will also be included. If not then the list will start from one after the current frame. If
+	 * includePrevious is true, the first element of the returned list may be null (as the start frame could be the
+	 * first frame of the narrative).
+	 * 
+	 * @param frameId
+	 * @param includeCurrentAndPrevious Whether to include the previous frame in the list as well
+	 */
+	public static ArrayList<String> getFollowingFrameIds(ContentResolver contentResolver, String frameId,
+			boolean includeCurrentAndPrevious) {
+		if (frameId == null) {
+			return null;
+		}
+		FrameItem parentFrame = findFrameByInternalId(contentResolver, frameId);
+		return getFollowingFrameIds(contentResolver, parentFrame, includeCurrentAndPrevious);
+	}
+
+	public static ArrayList<String> getFollowingFrameIds(ContentResolver contentResolver, FrameItem parentFrame,
+			boolean includePrevious) {
+		if (parentFrame == null) {
+			return null;
+		}
+
+		final String parentFrameId = parentFrame.getInternalId();
+		ArrayList<String> narrativeFrameIds = findFrameIdsByParentId(contentResolver, parentFrame.getParentId());
+		ArrayList<String> idsToRemove = new ArrayList<>();
+
+		// used to use an iterator here, but it turns out that remove() can fail silently (!)
+		String previousFrameId = null;
+		for (final String frameId : narrativeFrameIds) {
+			idsToRemove.add(frameId);
+			if (parentFrameId.equals(frameId)) {
+				break;
+			}
+			previousFrameId = frameId;
+		}
+
+		// remove irrelevant frames; preserve previous if necessary
+		if (includePrevious) {
+			idsToRemove.remove(previousFrameId);
+		}
+		narrativeFrameIds.removeAll(idsToRemove);
+		if (includePrevious && previousFrameId == null) {
+			narrativeFrameIds.add(0, null); // need this null to show that no previous frame is present
+		}
+		return narrativeFrameIds;
+	}
 }
diff --git a/src/ac/robinson/mediaphone/provider/MediaItem.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/provider/MediaItem.java
similarity index 79%
rename from src/ac/robinson/mediaphone/provider/MediaItem.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/provider/MediaItem.java
index 0ec5c64..f07d7b1 100644
--- a/src/ac/robinson/mediaphone/provider/MediaItem.java
+++ b/MediaPhone/src/main/java/ac/robinson/mediaphone/provider/MediaItem.java
@@ -39,21 +39,27 @@ public class MediaItem implements BaseColumns {
 	public static final Uri CONTENT_URI = Uri.parse(MediaPhoneProvider.URI_PREFIX + MediaPhoneProvider.URI_AUTHORITY
 			+ MediaPhoneProvider.URI_SEPARATOR + MediaPhoneProvider.MEDIA_LOCATION);
 
-	public static final String[] PROJECTION_ALL = new String[] { MediaItem._ID, MediaItem.INTERNAL_ID,
-			MediaItem.PARENT_ID, MediaItem.DATE_CREATED, MediaItem.FILE_EXTENSION, MediaItem.DURATION, MediaItem.TYPE,
-			MediaItem.DELETED };
-
-	public static final String[] PROJECTION_INTERNAL_ID = new String[] { MediaItem.INTERNAL_ID };
+	public static final Uri CONTENT_URI_LINK = Uri.parse(MediaPhoneProvider.URI_PREFIX
+			+ MediaPhoneProvider.URI_AUTHORITY + MediaPhoneProvider.URI_SEPARATOR
+			+ MediaPhoneProvider.MEDIA_LINKS_LOCATION);
 
 	public static final String INTERNAL_ID = "internal_id";
 	public static final String PARENT_ID = "parent_id";
 	public static final String DATE_CREATED = "date_created";
-	public static final String FILE_EXTENSION = "file_name"; //incorrect name for legacy compatibility
+	public static final String FILE_EXTENSION = "file_name"; // incorrect name for legacy compatibility
 	public static final String DURATION = "duration";
 	public static final String TYPE = "type";
+	public static final String SPAN_FRAMES = "span_frames";
 	public static final String DELETED = "deleted";
 
-	public static final String DEFAULT_SORT_ORDER = MediaItem.TYPE + " ASC, " + DATE_CREATED + " ASC";
+	public static final String[] PROJECTION_ALL = new String[] { MediaItem._ID, INTERNAL_ID, PARENT_ID, DATE_CREATED,
+			FILE_EXTENSION, DURATION, TYPE, SPAN_FRAMES, DELETED };
+
+	public static final String[] PROJECTION_INTERNAL_ID = new String[] { INTERNAL_ID };
+
+	public static final String[] PROJECTION_PARENT_ID = new String[] { PARENT_ID };
+
+	public static final String DEFAULT_SORT_ORDER = TYPE + " ASC, " + DATE_CREATED + " ASC";
 
 	private String mInternalId;
 	private String mParentId;
@@ -61,6 +67,7 @@ public class MediaItem implements BaseColumns {
 	private String mFileExtension;
 	private int mDuration;
 	private int mType;
+	private int mSpanFrames;
 	private int mDeleted;
 
 	public MediaItem(String internalId, String parentId, String fileExtension, int type) {
@@ -70,6 +77,7 @@ public class MediaItem implements BaseColumns {
 		setFileExtension(fileExtension);
 		mDuration = -1;
 		mType = type;
+		mSpanFrames = 0;
 		mDeleted = 0;
 	}
 
@@ -100,7 +108,7 @@ public class MediaItem implements BaseColumns {
 	public String getFileExtension() {
 		return mFileExtension;
 	}
-	
+
 	public void setFileExtension(String fileExtension) {
 		mFileExtension = (fileExtension != null ? fileExtension.toLowerCase(Locale.ENGLISH) : null);
 	}
@@ -144,6 +152,24 @@ public class MediaItem implements BaseColumns {
 		return mDuration;
 	}
 
+	/**
+	 * Whether this media item is set to span multiple frames
+	 * 
+	 * @return
+	 */
+	public boolean getSpanFrames() {
+		return mSpanFrames == 0 ? false : true;
+	}
+
+	/**
+	 * Set whether this media item should span multiple frames
+	 * 
+	 * @param spanFrames
+	 */
+	public void setSpanFrames(boolean spanFrames) {
+		mSpanFrames = spanFrames ? 1 : 0;
+	}
+
 	public boolean getDeleted() {
 		return mDeleted == 0 ? false : true;
 	}
@@ -151,7 +177,7 @@ public class MediaItem implements BaseColumns {
 	public void setDeleted(boolean deleted) {
 		mDeleted = deleted ? 1 : 0;
 	}
-	
+
 	/**
 	 * 
 	 * @return The bitmap representing this media item, or null if it is not an image or video
@@ -179,14 +205,17 @@ public class MediaItem implements BaseColumns {
 		return mediaBitmap;
 	}
 
+	/**
+	 * Get the duration of a text string (number of words/lines * word duration in settings), or 0 if empty
+	 * 
+	 * @param textString
+	 * @return
+	 */
 	public static int getTextDurationMilliseconds(String textString) {
-		int frameDuration = MediaPhone.PLAYBACK_EXPORT_MINIMUM_FRAME_DURATION;
+		int frameDuration = 0;
 		if (!TextUtils.isEmpty(textString)) {
 			String[] stringLines = textString.split("[ \\n]+");
 			frameDuration = MediaPhone.PLAYBACK_EXPORT_WORD_DURATION * stringLines.length;
-			if (frameDuration < MediaPhone.PLAYBACK_EXPORT_MINIMUM_FRAME_DURATION) {
-				frameDuration = MediaPhone.PLAYBACK_EXPORT_MINIMUM_FRAME_DURATION;
-			}
 		}
 		return frameDuration;
 	}
@@ -199,10 +228,19 @@ public class MediaItem implements BaseColumns {
 		values.put(FILE_EXTENSION, mFileExtension);
 		values.put(DURATION, mDuration);
 		values.put(TYPE, mType);
+		values.put(SPAN_FRAMES, mSpanFrames);
 		values.put(DELETED, mDeleted);
 		return values;
 	}
 
+	public static ContentValues getLinkContentValues(String frameId, String mediaId) {
+		final ContentValues values = new ContentValues();
+		values.put(INTERNAL_ID, mediaId);
+		values.put(PARENT_ID, frameId);
+		values.put(DELETED, 0);
+		return values;
+	}
+
 	public static MediaItem fromExisting(MediaItem existing, String newInternalId, String newParentId,
 			long newCreationDate) {
 		final MediaItem media = new MediaItem();
@@ -212,6 +250,7 @@ public class MediaItem implements BaseColumns {
 		media.mCreationDate = newCreationDate;
 		media.mDuration = existing.mDuration;
 		media.mType = existing.mType;
+		media.mSpanFrames = existing.mSpanFrames;
 		media.mDeleted = existing.mDeleted;
 		return media;
 	}
@@ -224,6 +263,7 @@ public class MediaItem implements BaseColumns {
 		media.mCreationDate = c.getLong(c.getColumnIndexOrThrow(DATE_CREATED));
 		media.mDuration = c.getInt(c.getColumnIndex(DURATION));
 		media.mType = c.getInt(c.getColumnIndexOrThrow(TYPE));
+		media.mSpanFrames = c.getInt(c.getColumnIndexOrThrow(SPAN_FRAMES));
 		media.mDeleted = c.getInt(c.getColumnIndexOrThrow(DELETED));
 		return media;
 	}
@@ -231,6 +271,6 @@ public class MediaItem implements BaseColumns {
 	@Override
 	public String toString() {
 		return this.getClass().getName() + "[" + mInternalId + "," + mParentId + "," + mCreationDate + ","
-				+ mFileExtension + "," + mDuration + "," + mType + "," + mDeleted + "]";
+				+ mFileExtension + "," + mDuration + "," + mType + "," + mSpanFrames + "," + mDeleted + "]";
 	}
 }
diff --git a/MediaPhone/src/main/java/ac/robinson/mediaphone/provider/MediaManager.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/provider/MediaManager.java
new file mode 100644
index 0000000..a275781
--- /dev/null
+++ b/MediaPhone/src/main/java/ac/robinson/mediaphone/provider/MediaManager.java
@@ -0,0 +1,454 @@
+/*
+ *  Copyright (C) 2012 Simon Robinson
+ * 
+ *  This file is part of Com-Me.
+ * 
+ *  Com-Me is free software; you can redistribute it and/or modify it 
+ *  under the terms of the GNU Lesser General Public License as 
+ *  published by the Free Software Foundation; either version 3 of the 
+ *  License, or (at your option) any later version.
+ *
+ *  Com-Me is distributed in the hope that it will be useful, but WITHOUT 
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
+ *  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General 
+ *  Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with Com-Me.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ac.robinson.mediaphone.provider;
+
+import java.util.ArrayList;
+
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.net.Uri;
+
+public class MediaManager {
+
+	private static String[] mArguments1 = new String[1];
+	private static String[] mArguments2 = new String[2];
+
+	private static String mMediaInternalIdSelection;
+	private static String mMediaInternalIdNotDeletedSelection;
+	private static String mMediaInternalIdAndParentIdSelection;
+	private static String mMediaParentIdSelection;
+	private static String mDeletedSelection;
+	static {
+		StringBuilder selection = new StringBuilder();
+		selection.append(MediaItem.INTERNAL_ID);
+		selection.append("=?");
+		mMediaInternalIdSelection = selection.toString();
+
+		selection.setLength(0); // clears
+		selection.append("(");
+		selection.append(MediaItem.DELETED);
+		selection.append("=0 AND ");
+		selection.append(MediaItem.INTERNAL_ID);
+		selection.append("=?");
+		selection.append(")");
+		mMediaInternalIdNotDeletedSelection = selection.toString();
+
+		selection.setLength(0); // clears
+		selection.append("(");
+		selection.append(MediaItem.INTERNAL_ID);
+		selection.append("=? AND ");
+		selection.append(MediaItem.PARENT_ID);
+		selection.append("=?");
+		selection.append(")");
+		mMediaInternalIdAndParentIdSelection = selection.toString();
+
+		selection.setLength(0); // clears
+		selection.append("(");
+		selection.append(MediaItem.DELETED);
+		selection.append("=0 AND (");
+		selection.append(MediaItem.PARENT_ID);
+		selection.append("=?");
+		selection.append("))"); // extra ) is to contain OR for multiple parent selections
+		mMediaParentIdSelection = selection.toString();
+
+		selection.setLength(0);
+		selection.append(MediaItem.DELETED);
+		selection.append("!=0");
+		mDeletedSelection = selection.toString();
+	}
+
+	public static MediaItem addMedia(ContentResolver contentResolver, MediaItem media) {
+		final Uri uri = contentResolver.insert(MediaItem.CONTENT_URI, media.getContentValues());
+		if (uri != null) {
+			return media;
+		}
+		return null;
+	}
+
+	/**
+	 * Note: to delete a media item, do setDeleted on the item itself and then update to the database. On the next
+	 * application exit, the media file will be deleted and the database entry will be cleaned up. This approach is used
+	 * to speed up interaction and so that we only need to run one background thread semi-regularly for deletion
+	 */
+	public static boolean deleteMediaFromBackgroundTask(ContentResolver contentResolver, String internalId) {
+		final String[] arguments1 = mArguments1;
+		arguments1[0] = internalId;
+		int count = contentResolver.delete(MediaItem.CONTENT_URI, mMediaInternalIdSelection, arguments1);
+		return count > 0;
+	}
+
+	public static boolean addMediaLink(ContentResolver contentResolver, String frameId, String mediaId) {
+		final Uri uri = contentResolver.insert(MediaItem.CONTENT_URI_LINK,
+				MediaItem.getLinkContentValues(frameId, mediaId));
+		if (uri != null) {
+			return true;
+		}
+		return false;
+	}
+
+	/**
+	 * For deleting all media links to an item when the entire spanning media has been removed (ie. from its first
+	 * frame)
+	 * 
+	 * @param contentResolver
+	 * @param mediaId
+	 * @return The number of links deleted
+	 */
+	public static int deleteMediaLinks(ContentResolver contentResolver, String mediaId) {
+		final String[] arguments1 = mArguments1;
+		arguments1[0] = mediaId;
+		final ContentValues contentValues = new ContentValues();
+		contentValues.put(MediaItem.DELETED, 1);
+		int count = contentResolver.update(MediaItem.CONTENT_URI_LINK, contentValues,
+				mMediaInternalIdNotDeletedSelection, arguments1);
+		return count;
+	}
+
+	/**
+	 * For deleting a media link when only the current media item has been removed (i.e. when replacing a long running
+	 * media item with another in the current frame)
+	 * 
+	 * @param contentResolver
+	 * @param frameId
+	 * @param mediaId
+	 * @return
+	 */
+	public static boolean deleteMediaLink(ContentResolver contentResolver, String frameId, String mediaId) {
+		final String[] arguments2 = mArguments2;
+		arguments2[0] = mediaId;
+		arguments2[1] = frameId;
+		final ContentValues contentValues = new ContentValues();
+		contentValues.put(MediaItem.DELETED, 1);
+		int count = contentResolver.update(MediaItem.CONTENT_URI_LINK, contentValues,
+				mMediaInternalIdAndParentIdSelection, arguments2);
+		return count == 1;
+	}
+
+	/**
+	 * Note: to delete a media link, use deleteMediaLink to set deleted, rather than actually removing. On the next
+	 * application exit, the link will be deleted and the database entry will be cleaned up. This approach is used to
+	 * speed up interaction and so that we only need to run one background thread semi-regularly for deletion
+	 */
+	public static boolean deleteMediaLinkFromBackgroundTask(ContentResolver contentResolver, String internalId) {
+		final String[] arguments1 = mArguments1;
+		arguments1[0] = internalId;
+		int count = contentResolver.delete(MediaItem.CONTENT_URI_LINK, mMediaInternalIdSelection, arguments1);
+		return count > 0;
+	}
+
+	public static boolean updateMedia(ContentResolver contentResolver, MediaItem media) {
+		final String[] arguments1 = mArguments1;
+		arguments1[0] = media.getInternalId();
+		int count = contentResolver.update(MediaItem.CONTENT_URI, media.getContentValues(), mMediaInternalIdSelection,
+				arguments1);
+		return count == 1;
+	}
+
+	@Deprecated
+	public static boolean changeMediaId(ContentResolver contentResolver, String oldMediaItemInternalId,
+			String newMediaItemInternalId) {
+		final String[] arguments1 = mArguments1;
+		arguments1[0] = oldMediaItemInternalId;
+		final ContentValues contentValues = new ContentValues();
+		contentValues.put(MediaItem.INTERNAL_ID, newMediaItemInternalId);
+		int count = contentResolver.update(MediaItem.CONTENT_URI, contentValues, mMediaInternalIdSelection, arguments1);
+		return count == 1;
+	}
+
+	public static MediaItem findMediaByInternalId(ContentResolver contentResolver, String internalId) {
+		final String[] arguments1 = mArguments1;
+		arguments1[0] = internalId;
+		return findMedia(contentResolver, mMediaInternalIdSelection, arguments1);
+	}
+
+	private static MediaItem findMedia(ContentResolver contentResolver, String clause, String[] arguments) {
+		Cursor c = null;
+		try {
+			// could add sort order here, but we assume no duplicates...
+			c = contentResolver.query(MediaItem.CONTENT_URI, MediaItem.PROJECTION_ALL, clause, arguments,
+					MediaItem.DEFAULT_SORT_ORDER);
+			if (c.moveToFirst()) {
+				final MediaItem media = MediaItem.fromCursor(c);
+				return media;
+			}
+		} finally {
+			if (c != null) {
+				c.close();
+			}
+		}
+		return null;
+	}
+
+	/**
+	 * Add '?' placeholders to mMediaParentIdSelection to deal with linked media items
+	 * 
+	 * @param numPlaceholders
+	 * @return
+	 */
+	private static String addPlaceholders(int numPlaceholders) {
+		if (numPlaceholders > 0) {
+			StringBuilder selection = new StringBuilder(mMediaParentIdSelection);
+			selection.setLength(selection.length() - 2); // delete the ending ))
+			selection.append(" OR ");
+			selection.append(MediaItem.INTERNAL_ID);
+			selection.append(" IN (?");
+			for (int i = 1; i < numPlaceholders; i++) {
+				selection.append(",?");
+			}
+			selection.append(")))");
+			return selection.toString();
+		}
+		return mMediaParentIdSelection;
+	}
+
+	/**
+	 * Get all frames that link to a specific media item.
+	 * 
+	 * @param contentResolver
+	 * @param mediaId
+	 * @return
+	 */
+	public static ArrayList<String> findLinkedParentIdsByMediaId(ContentResolver contentResolver, String mediaId) {
+		final ArrayList<String> parentIds = new ArrayList<>();
+		final String[] arguments1 = mArguments1;
+		arguments1[0] = mediaId;
+		Cursor c = null;
+		try {
+			c = contentResolver.query(MediaItem.CONTENT_URI_LINK, MediaItem.PROJECTION_PARENT_ID,
+					mMediaInternalIdNotDeletedSelection, arguments1, null);
+
+			if (c.getCount() > 0) {
+				final int columnIndex = c.getColumnIndexOrThrow(MediaItem.PARENT_ID);
+				while (c.moveToNext()) {
+					final String linkId = c.getString(columnIndex);
+					parentIds.add(linkId);
+				}
+			}
+		} finally {
+			if (c != null) {
+				c.close();
+			}
+		}
+		return parentIds;
+	}
+
+	/**
+	 * Get the number of frames that link to a specific media item.
+	 * 
+	 * @param contentResolver
+	 * @param mediaId
+	 * @return
+	 */
+	public static int countLinkedParentIdsByMediaId(ContentResolver contentResolver, String mediaId) {
+		final String[] arguments1 = mArguments1;
+		arguments1[0] = mediaId;
+		Cursor c = null;
+		try {
+			c = contentResolver.query(MediaItem.CONTENT_URI_LINK, MediaItem.PROJECTION_PARENT_ID,
+					mMediaInternalIdNotDeletedSelection, arguments1, null);
+			return c.getCount();
+		} finally {
+			if (c != null) {
+				c.close();
+			}
+		}
+	}
+
+	/**
+	 * Get all media items that are linked to a specific frame. Note: *only* includes links; not normal items
+	 * 
+	 * @param contentResolver
+	 * @param parentId
+	 * @return
+	 */
+	public static ArrayList<String> findLinkedMediaIdsByParentId(ContentResolver contentResolver, String parentId) {
+		final ArrayList<String> subIds = new ArrayList<>();
+		final String[] arguments1 = mArguments1;
+		arguments1[0] = parentId;
+		Cursor c = null;
+		try {
+			c = contentResolver.query(MediaItem.CONTENT_URI_LINK, MediaItem.PROJECTION_INTERNAL_ID,
+					mMediaParentIdSelection, arguments1, null);
+
+			if (c.getCount() > 0) {
+				final int columnIndex = c.getColumnIndexOrThrow(MediaItem.INTERNAL_ID);
+				while (c.moveToNext()) {
+					final String linkId = c.getString(columnIndex);
+					subIds.add(linkId);
+				}
+			}
+		} finally {
+			if (c != null) {
+				c.close();
+			}
+		}
+		return subIds;
+	}
+
+	/**
+	 * Gets a cursor that includes any media linked to this frame id, following the same pattern as
+	 * ContentResolver.query(). Media that isn't actually owned by this frame but is included in the query will have a
+	 * different parentId
+	 * 
+	 * @param contentResolver
+	 * @param parentId
+	 * @return
+	 */
+	private static Cursor getLinkedParentIdMediaCursor(ContentResolver contentResolver, String[] projection,
+			String parentId, String sortOrder) {
+
+		final String[] arguments1 = mArguments1;
+		arguments1[0] = parentId;
+
+		// first resolve links to other media items from the MediaLinks table
+		ArrayList<String> subIds = findLinkedMediaIdsByParentId(contentResolver, parentId);
+
+		// if there are links then we need to add the other media ids to the current query
+		if (subIds.size() > 0) {
+			subIds.add(0, parentId); // make sure we include the requested parent at the start of the WHERE clause
+
+			// note: more than 999 placeholders is not supported in SQLite, but we shouldn't have more than 1 photo,
+			// 3 audio and 1 text items linked at most
+			return contentResolver.query(MediaItem.CONTENT_URI, projection, addPlaceholders(subIds.size() - 1),
+					subIds.toArray(new String[subIds.size()]), sortOrder);
+		} else {
+			// otherwise we just perform the normal query
+			return contentResolver.query(MediaItem.CONTENT_URI, projection, mMediaParentIdSelection, arguments1,
+					sortOrder);
+		}
+	}
+
+	public static ArrayList<MediaItem> findMediaByParentId(ContentResolver contentResolver, String parentId) {
+		return findMediaByParentId(contentResolver, parentId, true);
+	}
+
+	public static ArrayList<MediaItem> findMediaByParentId(ContentResolver contentResolver, String parentId,
+			boolean includeLinks) {
+		final ArrayList<MediaItem> medias = new ArrayList<>();
+		Cursor c = null;
+		try {
+			if (includeLinks) {
+				c = getLinkedParentIdMediaCursor(contentResolver, MediaItem.PROJECTION_ALL, parentId,
+						MediaItem.DEFAULT_SORT_ORDER);
+			} else {
+				final String[] arguments1 = mArguments1;
+				arguments1[0] = parentId;
+				c = contentResolver.query(MediaItem.CONTENT_URI, MediaItem.PROJECTION_ALL, mMediaParentIdSelection,
+						arguments1, MediaItem.DEFAULT_SORT_ORDER);
+			}
+			if (c.getCount() > 0) {
+				while (c.moveToNext()) {
+					final MediaItem media = MediaItem.fromCursor(c);
+					medias.add(media);
+				}
+			}
+		} finally {
+			if (c != null) {
+				c.close();
+			}
+		}
+		return medias;
+	}
+
+	public static ArrayList<String> findMediaIdsByParentId(ContentResolver contentResolver, String parentId) {
+		return findMediaIdsByParentId(contentResolver, parentId, true);
+	}
+
+	public static ArrayList<String> findMediaIdsByParentId(ContentResolver contentResolver, String parentId,
+			boolean includeLinks) {
+		final ArrayList<String> mediaIds = new ArrayList<String>();
+		Cursor c = null;
+		try {
+			if (includeLinks) {
+				c = getLinkedParentIdMediaCursor(contentResolver, MediaItem.PROJECTION_INTERNAL_ID, parentId, null);
+			} else {
+				final String[] arguments1 = mArguments1;
+				arguments1[0] = parentId;
+				c = contentResolver.query(MediaItem.CONTENT_URI, MediaItem.PROJECTION_INTERNAL_ID,
+						mMediaParentIdSelection, arguments1, MediaItem.DEFAULT_SORT_ORDER);
+			}
+			if (c.getCount() > 0) {
+				final int columnIndex = c.getColumnIndexOrThrow(MediaItem.INTERNAL_ID);
+				while (c.moveToNext()) {
+					final String index = c.getString(columnIndex);
+					mediaIds.add(index);
+				}
+			}
+		} finally {
+			if (c != null) {
+				c.close();
+			}
+		}
+
+		return mediaIds;
+	}
+
+	public static int countMediaByParentId(ContentResolver contentResolver, String parentId) {
+		return countMediaByParentId(contentResolver, parentId, true);
+	}
+
+	public static int countMediaByParentId(ContentResolver contentResolver, String parentId, boolean includeLinks) {
+		Cursor c = null;
+		try {
+			if (includeLinks) {
+				c = getLinkedParentIdMediaCursor(contentResolver, MediaItem.PROJECTION_INTERNAL_ID, parentId, null);
+			} else {
+				final String[] arguments1 = mArguments1;
+				arguments1[0] = parentId;
+				c = contentResolver.query(MediaItem.CONTENT_URI, MediaItem.PROJECTION_INTERNAL_ID,
+						mMediaParentIdSelection, arguments1, null);
+			}
+			return c.getCount();
+		} finally {
+			if (c != null) {
+				c.close();
+			}
+		}
+	}
+
+	public static ArrayList<String> findDeletedMedia(ContentResolver contentResolver) {
+		return findDeletedMedia(contentResolver, MediaItem.CONTENT_URI);
+	}
+
+	public static ArrayList<String> findDeletedMediaLinks(ContentResolver contentResolver) {
+		return findDeletedMedia(contentResolver, MediaItem.CONTENT_URI_LINK);
+	}
+
+	private static ArrayList<String> findDeletedMedia(ContentResolver contentResolver, Uri contentUri) {
+		final ArrayList<String> mediaIds = new ArrayList<String>();
+		Cursor c = null;
+		try {
+			c = contentResolver.query(contentUri, MediaItem.PROJECTION_INTERNAL_ID, mDeletedSelection, null, null);
+			if (c.getCount() > 0) {
+				final int columnIndex = c.getColumnIndexOrThrow(MediaItem.INTERNAL_ID);
+				while (c.moveToNext()) {
+					mediaIds.add(c.getString(columnIndex));
+				}
+			}
+		} finally {
+			if (c != null) {
+				c.close();
+			}
+		}
+		return mediaIds;
+	}
+}
diff --git a/src/ac/robinson/mediaphone/provider/MediaPhoneProvider.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/provider/MediaPhoneProvider.java
similarity index 82%
rename from src/ac/robinson/mediaphone/provider/MediaPhoneProvider.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/provider/MediaPhoneProvider.java
index 89fb4c7..a4ddd6b 100644
--- a/src/ac/robinson/mediaphone/provider/MediaPhoneProvider.java
+++ b/MediaPhone/src/main/java/ac/robinson/mediaphone/provider/MediaPhoneProvider.java
@@ -44,7 +44,7 @@ public class MediaPhoneProvider extends ContentProvider {
 
 	public static final String URI_AUTHORITY = MediaPhone.APPLICATION_NAME;
 	private static final String DATABASE_NAME = URI_AUTHORITY + ".db";
-	private static final int DATABASE_VERSION = 1;
+	private static final int DATABASE_VERSION = 2;
 
 	public static final String URI_PREFIX = "content://";
 	public static final String URI_SEPARATOR = File.separator;
@@ -53,6 +53,7 @@ public class MediaPhoneProvider extends ContentProvider {
 	public static final String NARRATIVES_LOCATION = "narratives";
 	public static final String FRAMES_LOCATION = "frames";
 	public static final String MEDIA_LOCATION = "media";
+	public static final String MEDIA_LINKS_LOCATION = "media_links";
 	public static final String TEMPLATES_LOCATION = "templates";
 
 	// NOTE: these are *not* the same as the MediaTablet type classifiers
@@ -68,6 +69,7 @@ public class MediaPhoneProvider extends ContentProvider {
 		URI_MATCHER.addURI(URI_AUTHORITY, NARRATIVES_LOCATION, R.id.uri_narratives);
 		URI_MATCHER.addURI(URI_AUTHORITY, FRAMES_LOCATION, R.id.uri_frames);
 		URI_MATCHER.addURI(URI_AUTHORITY, MEDIA_LOCATION, R.id.uri_media);
+		URI_MATCHER.addURI(URI_AUTHORITY, MEDIA_LINKS_LOCATION, R.id.uri_media_links);
 		URI_MATCHER.addURI(URI_AUTHORITY, TEMPLATES_LOCATION, R.id.uri_templates);
 	}
 
@@ -97,6 +99,9 @@ public class MediaPhoneProvider extends ContentProvider {
 			case R.id.uri_media:
 				qb.setTables(MEDIA_LOCATION);
 				break;
+			case R.id.uri_media_links:
+				qb.setTables(MEDIA_LINKS_LOCATION);
+				break;
 			case R.id.uri_templates:
 				qb.setTables(TEMPLATES_LOCATION);
 				break;
@@ -124,6 +129,7 @@ public class MediaPhoneProvider extends ContentProvider {
 			case R.id.uri_narratives:
 			case R.id.uri_frames:
 			case R.id.uri_media:
+			case R.id.uri_media_links:
 			case R.id.uri_templates:
 				return "vnd.android.cursor.dir/vnd." + URI_PACKAGE; // do these need to be unique?
 			default:
@@ -158,6 +164,10 @@ public class MediaPhoneProvider extends ContentProvider {
 				rowId = db.insert(MEDIA_LOCATION, null, values);
 				contentUri = MediaItem.CONTENT_URI;
 				break;
+			case R.id.uri_media_links:
+				rowId = db.insert(MEDIA_LINKS_LOCATION, null, values);
+				contentUri = MediaItem.CONTENT_URI_LINK;
+				break;
 			case R.id.uri_templates:
 				rowId = db.insert(TEMPLATES_LOCATION, null, values);
 				contentUri = NarrativeItem.TEMPLATE_CONTENT_URI;
@@ -187,6 +197,9 @@ public class MediaPhoneProvider extends ContentProvider {
 			case R.id.uri_media:
 				count = db.delete(MEDIA_LOCATION, selectionClause, selectionArgs);
 				break;
+			case R.id.uri_media_links:
+				count = db.delete(MEDIA_LINKS_LOCATION, selectionClause, selectionArgs);
+				break;
 			case R.id.uri_templates:
 				count = db.delete(TEMPLATES_LOCATION, selectionClause, selectionArgs);
 				break;
@@ -223,6 +236,9 @@ public class MediaPhoneProvider extends ContentProvider {
 			case R.id.uri_media:
 				rowsAffected = db.update(MEDIA_LOCATION, values, selectionClause, selectionArgs);
 				break;
+			case R.id.uri_media_links:
+				rowsAffected = db.update(MEDIA_LINKS_LOCATION, values, selectionClause, selectionArgs);
+				break;
 			case R.id.uri_templates:
 				rowsAffected = db.update(TEMPLATES_LOCATION, values, selectionClause, selectionArgs);
 				break;
@@ -283,12 +299,15 @@ public class MediaPhoneProvider extends ContentProvider {
 					+ MediaItem.FILE_EXTENSION + " TEXT, " // the file extension of this media item
 					+ MediaItem.DURATION + " INTEGER, " // the duration of this media item
 					+ MediaItem.DATE_CREATED + " INTEGER, " // the timestamp when this media item was created
+					+ MediaItem.SPAN_FRAMES + " INTEGER, " // whether this media item spans multiple frames
 					+ MediaItem.DELETED + " INTEGER);"); // whether this media item has been deleted
 			db.execSQL("CREATE INDEX " + MEDIA_LOCATION + "Index" + MediaItem.INTERNAL_ID + " ON " + MEDIA_LOCATION
 					+ "(" + MediaItem.INTERNAL_ID + ");");
 			db.execSQL("CREATE INDEX " + MEDIA_LOCATION + "Index" + MediaItem.PARENT_ID + " ON " + MEDIA_LOCATION + "("
 					+ MediaItem.PARENT_ID + ");");
 
+			createMediaLinksTable(db);
+
 			db.execSQL("CREATE TABLE " + TEMPLATES_LOCATION + " (" //
 					+ NarrativeItem._ID + " INTEGER PRIMARY KEY, " // required for Android Adapters
 					+ NarrativeItem.INTERNAL_ID + " TEXT, " // the GUID of this template item
@@ -299,22 +318,50 @@ public class MediaPhoneProvider extends ContentProvider {
 					+ TEMPLATES_LOCATION + "(" + NarrativeItem.INTERNAL_ID + ");");
 		}
 
+		// in a separate function as it's used in both upgrade and creation
+		private void createMediaLinksTable(SQLiteDatabase db) {
+			db.execSQL("CREATE TABLE IF NOT EXISTS " + MEDIA_LINKS_LOCATION + " (" //
+					+ MediaItem._ID + " INTEGER PRIMARY KEY, " // required for Android Adapters
+					+ MediaItem.INTERNAL_ID + " TEXT, " // the GUID of the linked media item
+					+ MediaItem.PARENT_ID + " TEXT, " // the GUID of the parent this media item is linked to
+					+ MediaItem.DELETED + " INTEGER);"); // whether this link has been deleted
+			db.execSQL("CREATE INDEX IF NOT EXISTS " + MEDIA_LINKS_LOCATION + "Index" + MediaItem.INTERNAL_ID + " ON "
+					+ MEDIA_LINKS_LOCATION + "(" + MediaItem.INTERNAL_ID + ");");
+			db.execSQL("CREATE INDEX IF NOT EXISTS " + MEDIA_LINKS_LOCATION + "Index" + MediaItem.PARENT_ID + " ON "
+					+ MEDIA_LINKS_LOCATION + "(" + MediaItem.PARENT_ID + ");");
+		}
+
 		@Override
 		public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-			if (MediaPhone.DEBUG) {
-				Log.d(DebugUtilities.getLogTag(this), "Database upgrade requested from version " + oldVersion + " to "
-						+ newVersion + " - ignoring.");
+			Log.i(DebugUtilities.getLogTag(this), "Database upgrade requested from version " + oldVersion + " to "
+					+ newVersion);
+
+			// TODO: backup database if necessary (also: check for read only database?)
+
+			// must always check whether the items we're upgrading already exist, just in case a downgrade has occurred
+			switch (newVersion) {
+				case 2:
+					Cursor c = null;
+					try {
+						c = db.rawQuery("SELECT * FROM " + MEDIA_LOCATION + " LIMIT 0,1", null);
+						if (c.getColumnIndex(MediaItem.SPAN_FRAMES) < 0) {
+							db.execSQL("ALTER TABLE " + MEDIA_LOCATION + " ADD COLUMN " + MediaItem.SPAN_FRAMES
+									+ " INTEGER;");
+						}
+					} finally {
+						if (c != null) {
+							c.close();
+						}
+					}
+					createMediaLinksTable(db);
+					break;
 			}
-			// backup database if necessary
 		}
 
 		@Override
 		public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-			if (MediaPhone.DEBUG) {
-				Log.d(DebugUtilities.getLogTag(this), "Database downgrade requested from version " + oldVersion
-						+ " to " + newVersion + " - ignoring.");
-			}
-			// backup database if necessary
+			Log.i(DebugUtilities.getLogTag(this), "Database downgrade requested from version " + oldVersion + " to "
+					+ newVersion + " - ignoring.");
 		}
 	}
 }
diff --git a/src/ac/robinson/mediaphone/provider/NarrativeAdapter.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/provider/NarrativeAdapter.java
similarity index 98%
rename from src/ac/robinson/mediaphone/provider/NarrativeAdapter.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/provider/NarrativeAdapter.java
index 31ff6f3..a87b073 100644
--- a/src/ac/robinson/mediaphone/provider/NarrativeAdapter.java
+++ b/MediaPhone/src/main/java/ac/robinson/mediaphone/provider/NarrativeAdapter.java
@@ -49,7 +49,7 @@ public class NarrativeAdapter extends CursorAdapter {
 	private FrameAdapter mEmptyAdapter;
 
 	// must *not* be static - will leak on destroy otherwise...
-	private final HashMap<String, FrameAdapter> mFrameAdapters = new HashMap<String, FrameAdapter>();
+	private final HashMap<String, FrameAdapter> mFrameAdapters = new HashMap<>();
 
 	public NarrativeAdapter(BrowserActivity activity, boolean showKeyFrames, boolean isTemplateView) {
 		super(activity, null, 0); // null cursor and no auto querying - we use a loader to manage cursors
@@ -156,7 +156,7 @@ public class NarrativeAdapter extends CursorAdapter {
 				int horizontalPosition = adapter.getHorizontalPosition();
 				if (horizontalPosition > 0 && horizontalPosition > frameWidth) {
 					if (scrollPositions == null) {
-						scrollPositions = new HashMap<String, Integer>();
+						scrollPositions = new HashMap<>();
 					}
 					scrollPositions.put(adapter.getParentFilter(), adapter.getHorizontalPosition());
 					if (scrollPositions.size() > 20) {
diff --git a/MediaPhone/src/main/java/ac/robinson/mediaphone/provider/NarrativeItem.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/provider/NarrativeItem.java
new file mode 100644
index 0000000..7f0aaed
--- /dev/null
+++ b/MediaPhone/src/main/java/ac/robinson/mediaphone/provider/NarrativeItem.java
@@ -0,0 +1,462 @@
+/*
+ *  Copyright (C) 2012 Simon Robinson
+ * 
+ *  This file is part of Com-Me.
+ * 
+ *  Com-Me is free software; you can redistribute it and/or modify it 
+ *  under the terms of the GNU Lesser General Public License as 
+ *  published by the Free Software Foundation; either version 3 of the 
+ *  License, or (at your option) any later version.
+ *
+ *  Com-Me is distributed in the hope that it will be useful, but WITHOUT 
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
+ *  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General 
+ *  Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with Com-Me.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ac.robinson.mediaphone.provider;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+
+import ac.robinson.mediaphone.MediaPhone;
+import ac.robinson.mediautilities.FrameMediaContainer;
+import ac.robinson.util.IOUtilities;
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.net.Uri;
+import android.provider.BaseColumns;
+
+public class NarrativeItem implements BaseColumns {
+
+	public static final Uri NARRATIVE_CONTENT_URI = Uri.parse(MediaPhoneProvider.URI_PREFIX
+			+ MediaPhoneProvider.URI_AUTHORITY + MediaPhoneProvider.URI_SEPARATOR
+			+ MediaPhoneProvider.NARRATIVES_LOCATION);
+
+	public static final Uri TEMPLATE_CONTENT_URI = Uri.parse(MediaPhoneProvider.URI_PREFIX
+			+ MediaPhoneProvider.URI_AUTHORITY + MediaPhoneProvider.URI_SEPARATOR
+			+ MediaPhoneProvider.TEMPLATES_LOCATION);
+
+	public static final String[] PROJECTION_ALL = new String[] { NarrativeItem._ID, NarrativeItem.INTERNAL_ID,
+			NarrativeItem.DATE_CREATED, NarrativeItem.SEQUENCE_ID, NarrativeItem.DELETED };
+
+	public static final String[] PROJECTION_INTERNAL_ID = new String[] { NarrativeItem.INTERNAL_ID };
+
+	public static final String MAX_ID = "max_id";
+	public static final String[] PROJECTION_NEXT_EXTERNAL_ID = new String[] { "MAX(" + NarrativeItem.SEQUENCE_ID
+			+ ") as " + MAX_ID };
+
+	// for keeping track of the helper narrative (so we don't add multiple copies later)
+	public static final String HELPER_NARRATIVE_ID = "936df7b0-72b9-11e2-bcfd-0800200c9a66"; // *DO NOT CHANGE*
+
+	public static final String INTERNAL_ID = "internal_id";
+	public static final String DATE_CREATED = "date_created";
+	public static final String SEQUENCE_ID = "sequence_id";
+	public static final String DELETED = "deleted";
+
+	public static final String SELECTION_NOT_DELETED = DELETED + "=0";
+
+	public static final String DEFAULT_SORT_ORDER = SEQUENCE_ID + " DESC"; // seq id, not date, in case date is wrong
+
+	private String mInternalId;
+	private long mCreationDate;
+	private int mSequenceId;
+	private int mDeleted;
+
+	public NarrativeItem(String internalId, int externalId) {
+		mInternalId = internalId;
+		mCreationDate = System.currentTimeMillis();
+		mSequenceId = externalId;
+		mDeleted = 0;
+	}
+
+	public NarrativeItem(int externalId) {
+		this(MediaPhoneProvider.getNewInternalId(), externalId);
+	}
+
+	public NarrativeItem() {
+		this(0);
+	}
+
+	public String getInternalId() {
+		return mInternalId;
+	}
+
+	public long getCreationDate() {
+		return mCreationDate;
+	}
+
+	public int getSequenceId() {
+		return mSequenceId;
+	}
+
+	public void setSequenceId(int sequenceId) {
+		mSequenceId = sequenceId;
+	}
+
+	public boolean getDeleted() {
+		return mDeleted == 0 ? false : true;
+	}
+
+	public void setDeleted(boolean deleted) {
+		mDeleted = deleted ? 1 : 0;
+	}
+
+	/**
+	 * Parses this narrative's content, returning a compacted version of each frame. Used for exporting a narrative's
+	 * content. Items that span more than one frame are simply repeated; except for audio, which is spread evenly over
+	 * all the frames it applies to.
+	 * 
+	 * @param contentResolver
+	 * @return
+	 */
+	public ArrayList<FrameMediaContainer> getContentList(ContentResolver contentResolver) {
+
+		ArrayList<FrameMediaContainer> exportedContent = new ArrayList<FrameMediaContainer>();
+		HashMap<String, Integer> longRunningAudio = new HashMap<String, Integer>(); // so we can adjust durations
+
+		ArrayList<FrameItem> narrativeFrames = FramesManager.findFramesByParentId(contentResolver, mInternalId);
+		for (FrameItem frame : narrativeFrames) {
+			final String frameId = frame.getInternalId();
+			ArrayList<MediaItem> frameComponents = MediaManager.findMediaByParentId(contentResolver, frameId);
+
+			final FrameMediaContainer currentContainer = new FrameMediaContainer(frameId,
+					frame.getNarrativeSequenceId());
+
+			currentContainer.mParentId = frame.getParentId();
+
+			for (MediaItem media : frameComponents) {
+				final String mediaPath = media.getFile().getAbsolutePath();
+				final int mediaType = media.getType();
+				final int mediaDuration = media.getDurationMilliseconds();
+				boolean spanningAudio = false;
+
+				switch (mediaType) {
+					case MediaPhoneProvider.TYPE_IMAGE_FRONT:
+						currentContainer.mImageIsFrontCamera = true;
+					case MediaPhoneProvider.TYPE_IMAGE_BACK:
+					case MediaPhoneProvider.TYPE_VIDEO:
+						currentContainer.mImagePath = mediaPath;
+						if (mediaDuration > 0) { // preserve custom user-set durations
+							currentContainer.mImageDuration = mediaDuration;
+							currentContainer.updateFrameMaxDuration(mediaDuration);
+						}
+						break;
+
+					case MediaPhoneProvider.TYPE_TEXT:
+						currentContainer.mTextContent = IOUtilities.getFileContents(mediaPath);
+						if (mediaDuration > 0) { // preserve custom user-set durations
+							currentContainer.mTextDuration = mediaDuration;
+							currentContainer.updateFrameMaxDuration(mediaDuration);
+						}
+						break;
+
+					case MediaPhoneProvider.TYPE_AUDIO:
+						int insertedIndex = currentContainer.addAudioFile(mediaPath, mediaDuration);
+						spanningAudio = media.getSpanFrames();
+						if (spanningAudio && insertedIndex >= 0) {
+							currentContainer.mSpanningAudioIndex = insertedIndex; // only 1 spanning item per frame
+						}
+						break;
+				}
+
+				// frame spanning images and text can just be repeated; audio needs to be split between frames
+				// here we count the number of frames to split between so we can equalise later
+				if (spanningAudio) {
+					if (frameId.equals(media.getParentId())) {
+						longRunningAudio.put(mediaPath, 1); // this is the actual parent frame
+						currentContainer.mSpanningAudioRoot = true;
+					} else {
+						// this is a linked frame - increase the count
+						Integer existingAudioCount = longRunningAudio.remove(mediaPath);
+						if (existingAudioCount != null) {
+							longRunningAudio.put(mediaPath, existingAudioCount + 1);
+						}
+					}
+				} else {
+					// for other media we just use the normal maximum duration
+					currentContainer.updateFrameMaxDuration(mediaDuration);
+				}
+			}
+
+			exportedContent.add(currentContainer);
+		}
+
+		// now check all long-running audio tracks to split the audio's duration between all spanned frames
+		// TODO: this doesn't really respect/control other non-spanning audio (e.g., a longer sub-track than
+		// duration/count) - should decide whether it's best to split lengths equally regardless of this; adapt and pad
+		// equally but leaving a longer duration for the sub-track; or, use sub-track duration as frame duration
+		// note: if changing this behaviour, be sure to account for the similar version in getPlaybackContent
+		for (FrameMediaContainer container : exportedContent) {
+			boolean longAudioFound = false;
+			for (int i = 0, n = container.mAudioPaths.size(); i < n; i++) {
+				final Integer audioCount = longRunningAudio.get(container.mAudioPaths.get(i));
+				if (audioCount != null) {
+					container.updateFrameMaxDuration((int) Math.ceil(container.mAudioDurations.get(i)
+							/ (float) audioCount));
+					longAudioFound = true;
+				}
+			}
+
+			// don't allow non-spanned frames to be shorter than the minimum duration (unless user-requested)
+			if (!longAudioFound && container.mFrameMaxDuration <= 0) {
+				container.updateFrameMaxDuration(MediaPhone.PLAYBACK_EXPORT_MINIMUM_FRAME_DURATION);
+			}
+		}
+		return exportedContent;
+	}
+
+	/**
+	 * Parse this narrative's content, returning a list of timed media items. The given PlaybackNarrativeDescriptor
+	 * contains options for parsing, and is returned with important initialisation values (start time, for example).
+	 * 
+	 * Note: start time could easily be calculated from the narrative descriptor's mTimeToFrameMap, but as we're looping
+	 * through every frame anyway it's more efficient to calculate it here.
+	 * 
+	 * @param contentResolver
+	 * @param startingFrame
+	 * @param narrativeDescriptor
+	 * @return
+	 */
+	public ArrayList<PlaybackMediaHolder> getPlaybackContent(ContentResolver contentResolver, String startingFrame,
+			PlaybackNarrativeDescriptor narrativeDescriptor) {
+
+		final ArrayList<PlaybackMediaHolder> narrativeContent = new ArrayList<>();
+		final HashMap<String, Integer> longRunningAudioCounts = new HashMap<>(); // to adjust durations
+		final LinkedHashMap<Integer, String> mTimeToFrameMap = narrativeDescriptor.mTimeToFrameMap; // to track frames
+
+		int narrativeTime = 0;
+		int narrativeDuration = 0;
+		boolean frameFound = startingFrame == null ? true : false;
+		boolean imageAdjustment = narrativeDescriptor.mNarrativeImageAdjustment > 0;
+
+		PlaybackMediaHolder previousFrameImage = null;
+		PlaybackMediaHolder previousFrameText = null;
+		PlaybackMediaHolder lastAudioItem = null; // the last audio item in the narrative
+
+		ArrayList<FrameItem> narrativeFrames = FramesManager.findFramesByParentId(contentResolver, mInternalId);
+		int currentFrame = 0;
+		int lastFrame = narrativeFrames.size() - 1;
+		for (FrameItem frame : narrativeFrames) {
+			final String frameId = frame.getInternalId();
+			mTimeToFrameMap.put(narrativeTime, frameId); // store the frame's start time
+			ArrayList<MediaItem> frameComponents = MediaManager.findMediaByParentId(contentResolver, frameId);
+
+			int frameDuration = 0;
+			int textDuration = 0;
+
+			// return the start time of the requested starting frame
+			if (!frameFound) {
+				if (frameId.equals(startingFrame)) {
+					narrativeDescriptor.mNarrativeStartTime = narrativeTime;
+					frameFound = true;
+				}
+			}
+
+			// first we need to deal with durations; specifically audio - it's far more complex to play than images/text
+			// because we try to fit the items it spans nicely over the duration of its playback
+			// for other media items we just naively take the default or user-requested duration TODO: improve this!
+			boolean hasSpanningAudio = false;
+			int audioItemsAdded = 0;
+			for (MediaItem media : frameComponents) {
+				final int mediaType = media.getType();
+				final int mediaDuration = media.getDurationMilliseconds();
+				if (mediaType == MediaPhoneProvider.TYPE_AUDIO) {
+					final String mediaPath = media.getFile().getAbsolutePath();
+					final int audioEndTime = narrativeTime + mediaDuration;
+					PlaybackMediaHolder audioItem = null;
+					if (media.getSpanFrames()) {
+						hasSpanningAudio = true;
+						if (frameId.equals(media.getParentId())) {
+							// this is the actual parent frame of a long-running item - count how many items link here
+							final int linkedItemCount = MediaManager.countLinkedParentIdsByMediaId(contentResolver,
+									media.getInternalId()) + 1; // +1 to count this frame as well
+							longRunningAudioCounts.put(mediaPath, linkedItemCount);
+							frameDuration = Math.max((int) Math.ceil(mediaDuration / (float) linkedItemCount),
+									frameDuration);
+
+							// add this item to the playback list
+							audioItem = new PlaybackMediaHolder(frameId, media.getInternalId(), mediaPath, mediaType,
+									narrativeTime, audioEndTime, 0, 0);
+							narrativeContent.add(audioItem);
+							audioItemsAdded += 1;
+
+							// because of rounding errors, we could be wrong in the narrative duration here - correct
+							narrativeDuration = Math.max(narrativeDuration, audioEndTime);
+						} else {
+							// if we've inherited this audio then no need to add to playback, just calculate duration
+							// TODO: very naive currently - should we split more evenly to account for other lengths?
+							// note: if changing behaviour, be sure to account for the similar version in getContentList
+							frameDuration = Math.max(
+									(int) Math.ceil(mediaDuration / (float) longRunningAudioCounts.get(mediaPath)),
+									frameDuration);
+						}
+					} else {
+						// a normal non-spanning audio item - update duration and add
+						frameDuration = Math.max(mediaDuration, frameDuration);
+						audioItem = new PlaybackMediaHolder(frameId, media.getInternalId(), mediaPath, mediaType,
+								narrativeTime, audioEndTime, 0, 0);
+						narrativeContent.add(audioItem);
+						audioItemsAdded += 1;
+					}
+
+					// store the last audio item for displaying it at the end of playback when no other items present
+					if (audioItem != null) {
+						if (lastAudioItem == null) {
+							lastAudioItem = audioItem;
+						} else if (audioEndTime > lastAudioItem.getEndTime(false)) {
+							lastAudioItem = audioItem;
+						}
+					}
+				} else {
+					// another type of media - just update frame duration from user-set media duration
+					// TODO: allow for, e.g., text spanning multiple images but with user-set durations
+					frameDuration = Math.max(mediaDuration, frameDuration);
+
+					// note that calculated text durations are stored as negative numbers so we can keep track of what's
+					// generated and what's user-selected; we only use the calculated value if it's greater than the
+					// minimum duration and if we're not fitting content to spanning audio
+					if (mediaType == MediaPhoneProvider.TYPE_TEXT) {
+						textDuration = Math.abs(mediaDuration);
+					}
+				}
+			}
+
+			// set the minimum frame duration if not inherited from audio or user-requested
+			if (!hasSpanningAudio && frameDuration <= 0) {
+				frameDuration = Math.max(MediaPhone.PLAYBACK_EXPORT_MINIMUM_FRAME_DURATION,
+						Math.max(frameDuration, textDuration)); // TODO: scale text proportionally when spanning audio?
+			}
+
+			// now deal with images (only one item of this type per frame)
+			// note that we adjust image timings so that their crossfade ends when the next image starts - this requires
+			// shifting images earlier in the playback queue so that they can be set up in time
+			// if this is the last item we add 1ms to the end of the item so it stays visible after playback completes
+			// TODO: spread the crossfade over the beginning and the end of the image so that timings are more accurate?
+			final int mediaEndTime = narrativeTime + frameDuration;
+			boolean lastFrameAdjustments = currentFrame == lastFrame && imageAdjustment;
+			narrativeDuration = Math.max(narrativeDuration, mediaEndTime);
+			PlaybackMediaHolder frameImage = null;
+			for (MediaItem media : frameComponents) {
+				final int mediaType = media.getType();
+				if (mediaType == MediaPhoneProvider.TYPE_IMAGE_FRONT || mediaType == MediaPhoneProvider.TYPE_IMAGE_BACK
+						|| mediaType == MediaPhoneProvider.TYPE_VIDEO) {
+
+					// check whether this is a duplicate of the previous item - if so, just extend that item's duration
+					if (media.getSpanFrames() && previousFrameImage != null
+							&& media.getInternalId().equals(previousFrameImage.mMediaItemId)) {
+
+						int replacementPosition = narrativeContent.indexOf(previousFrameImage);
+						frameImage = new PlaybackMediaHolder(previousFrameImage.mParentFrameId,
+								previousFrameImage.mMediaItemId, previousFrameImage.mMediaPath,
+								previousFrameImage.mMediaType, previousFrameImage.getStartTime(false), mediaEndTime,
+								imageAdjustment ? narrativeDescriptor.mNarrativeImageAdjustment : 0,
+								lastFrameAdjustments ? -1
+										: (imageAdjustment ? narrativeDescriptor.mNarrativeImageAdjustment : 0));
+						narrativeContent.set(replacementPosition, frameImage);
+						previousFrameImage = frameImage; // we've replaced the old item
+
+					} else {
+
+						frameImage = new PlaybackMediaHolder(frameId, media.getInternalId(), media.getFile()
+								.getAbsolutePath(), mediaType, narrativeTime, mediaEndTime,
+								imageAdjustment ? narrativeDescriptor.mNarrativeImageAdjustment : 0,
+								lastFrameAdjustments ? -1
+										: (imageAdjustment ? narrativeDescriptor.mNarrativeImageAdjustment : 0));
+						narrativeContent.add(narrativeContent.size() - audioItemsAdded, frameImage);
+					}
+					break;
+				}
+			}
+
+			// finally, add the text (only one item of this type per frame)
+			// if this is the last item we add 1ms to the end of the item so it stays visible after playback completes
+			PlaybackMediaHolder frameText = null;
+			for (MediaItem media : frameComponents) {
+				if (media.getType() == MediaPhoneProvider.TYPE_TEXT) {
+
+					// check whether this is a duplicate of the previous item - if so, just extend that item's duration
+					if (media.getSpanFrames() && previousFrameText != null
+							&& media.getInternalId().equals(previousFrameText.mMediaItemId)) {
+
+						int replacementPosition = narrativeContent.indexOf(previousFrameText);
+						frameText = new PlaybackMediaHolder(previousFrameText.mParentFrameId,
+								previousFrameText.mMediaItemId, previousFrameText.mMediaPath,
+								previousFrameText.mMediaType, previousFrameText.getStartTime(false), mediaEndTime, 0,
+								lastFrameAdjustments ? -1 : 0);
+						narrativeContent.set(replacementPosition, frameText);
+						previousFrameText = frameText; // we've replaced the old item
+
+					} else {
+
+						frameText = new PlaybackMediaHolder(frameId, media.getInternalId(), media.getFile()
+								.getAbsolutePath(), MediaPhoneProvider.TYPE_TEXT, narrativeTime, mediaEndTime, 0,
+								lastFrameAdjustments ? -1 : 0);
+						narrativeContent.add(frameText);
+					}
+
+					// if we're coming to a text only frame from an image, we tweak its end time to align with text
+					if (imageAdjustment && frameImage == null && previousFrameImage != null) {
+						// no need to deal with lastFrameAdjustments as this will never be the last item
+						int replacementPosition = narrativeContent.indexOf(previousFrameImage);
+						previousFrameImage = new PlaybackMediaHolder(previousFrameImage.mParentFrameId,
+								previousFrameImage.mMediaItemId, previousFrameImage.mMediaPath,
+								previousFrameImage.mMediaType, previousFrameImage.getStartTime(false),
+								previousFrameImage.getEndTime(false), narrativeDescriptor.mNarrativeImageAdjustment, 0);
+						narrativeContent.set(replacementPosition, previousFrameImage);
+					}
+					break;
+				}
+			}
+
+			// if we've got just audio on a frame and we're the last frame we need to adjust the last audio item to add
+			// an extra 1ms so that it remains in view when playback stops
+			if (lastFrameAdjustments && frameImage == null && frameText == null && lastAudioItem != null) {
+				int replacementPosition = narrativeContent.indexOf(lastAudioItem);
+				lastAudioItem = new PlaybackMediaHolder(lastAudioItem.mParentFrameId, lastAudioItem.mMediaItemId,
+						lastAudioItem.mMediaPath, lastAudioItem.mMediaType, lastAudioItem.getStartTime(false),
+						lastAudioItem.getEndTime(false), 0, -1);
+				narrativeContent.set(replacementPosition, lastAudioItem);
+
+			}
+
+			narrativeTime += frameDuration;
+			currentFrame += 1;
+			previousFrameImage = frameImage;
+			previousFrameText = frameText;
+		}
+
+		narrativeDescriptor.mNarrativeDuration = narrativeDuration;
+		return narrativeContent;
+	}
+
+	public ContentValues getContentValues() {
+		final ContentValues values = new ContentValues();
+		values.put(INTERNAL_ID, mInternalId);
+		values.put(DATE_CREATED, mCreationDate);
+		values.put(SEQUENCE_ID, mSequenceId);
+		values.put(DELETED, mDeleted);
+		return values;
+	}
+
+	public static NarrativeItem fromCursor(Cursor c) {
+		final NarrativeItem narrative = new NarrativeItem();
+		narrative.mInternalId = c.getString(c.getColumnIndexOrThrow(INTERNAL_ID));
+		narrative.mCreationDate = c.getLong(c.getColumnIndexOrThrow(DATE_CREATED));
+		narrative.mSequenceId = c.getInt(c.getColumnIndexOrThrow(SEQUENCE_ID));
+		narrative.mDeleted = c.getInt(c.getColumnIndexOrThrow(DELETED));
+		return narrative;
+	}
+
+	@Override
+	public String toString() {
+		return this.getClass().getName() + "[" + mInternalId + "," + mCreationDate + "," + mSequenceId + "," + mDeleted
+				+ "]";
+	}
+}
diff --git a/src/ac/robinson/mediaphone/provider/NarrativesManager.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/provider/NarrativesManager.java
similarity index 89%
rename from src/ac/robinson/mediaphone/provider/NarrativesManager.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/provider/NarrativesManager.java
index 2026b68..235119c 100644
--- a/src/ac/robinson/mediaphone/provider/NarrativesManager.java
+++ b/MediaPhone/src/main/java/ac/robinson/mediaphone/provider/NarrativesManager.java
@@ -67,9 +67,9 @@ public class NarrativesManager {
 	}
 
 	/**
-	 * Note: to delete an item, do setDeleted the item itself and then update to the database. On the next application
-	 * launch, the item's frames and media files will be deleted and the database entry will be cleaned up. This
-	 * approach speeds up interaction and means that we only need one background thread semi-regularly for deletion
+	 * Note: to delete an item, do setDeleted on the item itself and then update to the database. On the next
+	 * application exit, the item's frames and media files will be deleted and the database entry will be cleaned up.
+	 * This approach speeds up interaction and means that we only need one background thread semi-regularly for deletion
 	 */
 	public static boolean deleteTemplateFromBackgroundTask(ContentResolver contentResolver, String internalId) {
 		return deleteItemFromBackgroundTask(NarrativeItem.TEMPLATE_CONTENT_URI, contentResolver, internalId);
@@ -77,8 +77,8 @@ public class NarrativesManager {
 
 	/**
 	 * Note: to delete an item, do setDeleted the item itself and then update to the database. On the next application
-	 * launch, the item's frames and media files will be deleted and the database entry will be cleaned up. This
-	 * approach speeds up interaction and means that we only need one background thread semi-regularly for deletion
+	 * exit, the item's frames and media files will be deleted and the database entry will be cleaned up. This approach
+	 * speeds up interaction and means that we only need one background thread semi-regularly for deletion
 	 */
 	public static boolean deleteNarrativeFromBackgroundTask(ContentResolver contentResolver, String internalId) {
 		return deleteItemFromBackgroundTask(NarrativeItem.NARRATIVE_CONTENT_URI, contentResolver, internalId);
@@ -86,8 +86,8 @@ public class NarrativesManager {
 
 	/**
 	 * Note: to delete an item, do setDeleted the item itself and then update to the database. On the next application
-	 * launch, the item's frames and media files will be deleted and the database entry will be cleaned up. This
-	 * approach speeds up interaction and means that we only need one background thread semi-regularly for deletion
+	 * exit, the item's frames and media files will be deleted and the database entry will be cleaned up. This approach
+	 * speeds up interaction and means that we only need one background thread semi-regularly for deletion
 	 */
 	public static boolean deleteItemFromBackgroundTask(Uri contentType, ContentResolver contentResolver,
 			String internalId) {
@@ -195,7 +195,7 @@ public class NarrativesManager {
 	}
 
 	private static ArrayList<String> findDeletedItems(Uri contentType, ContentResolver contentResolver) {
-		final ArrayList<String> narrativeIds = new ArrayList<String>();
+		final ArrayList<String> narrativeIds = new ArrayList<>();
 		Cursor c = null;
 		try {
 			c = contentResolver.query(contentType, NarrativeItem.PROJECTION_INTERNAL_ID, mDeletedSelection, null, null);
diff --git a/MediaPhone/src/main/java/ac/robinson/mediaphone/provider/PlaybackMediaHolder.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/provider/PlaybackMediaHolder.java
new file mode 100644
index 0000000..0693755
--- /dev/null
+++ b/MediaPhone/src/main/java/ac/robinson/mediaphone/provider/PlaybackMediaHolder.java
@@ -0,0 +1,53 @@
+/*
+ *  This file is part of Com-Me.
+ * 
+ *  Com-Me is free software; you can redistribute it and/or modify it 
+ *  under the terms of the GNU Lesser General Public License as 
+ *  published by the Free Software Foundation; either version 3 of the 
+ *  License, or (at your option) any later version.
+ *
+ *  Com-Me is distributed in the hope that it will be useful, but WITHOUT 
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
+ *  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General 
+ *  Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with Com-Me.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ac.robinson.mediaphone.provider;
+
+public class PlaybackMediaHolder {
+	public final String mParentFrameId;
+	public final String mMediaItemId;
+
+	public final String mMediaPath;
+	public final int mMediaType;
+
+	private final int mMediaStartTime;
+	private final int mMediaEndTime;
+
+	private final int mPlaybackOffsetStart;
+	private final int mPlaybackOffsetEnd;
+
+	public PlaybackMediaHolder(String parentId, String mediaId, String mediaPath, int mediaType, int startTime,
+			int endTime, int playbackOffsetStart, int playbackOffsetEnd) {
+		mParentFrameId = parentId;
+		mMediaItemId = mediaId;
+		mMediaPath = mediaPath;
+		mMediaType = mediaType;
+		mMediaStartTime = startTime;
+		mMediaEndTime = endTime;
+		mPlaybackOffsetStart = playbackOffsetStart;
+		mPlaybackOffsetEnd = playbackOffsetEnd;
+	}
+
+	public int getStartTime(boolean includePlaybackOffset) {
+		return includePlaybackOffset ? mMediaStartTime - mPlaybackOffsetStart : mMediaStartTime;
+	}
+
+	public int getEndTime(boolean includePlaybackOffset) {
+		return includePlaybackOffset ? mMediaEndTime - mPlaybackOffsetEnd : mMediaEndTime;
+	}
+}
diff --git a/MediaPhone/src/main/java/ac/robinson/mediaphone/provider/PlaybackNarrativeDescriptor.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/provider/PlaybackNarrativeDescriptor.java
new file mode 100644
index 0000000..446d87d
--- /dev/null
+++ b/MediaPhone/src/main/java/ac/robinson/mediaphone/provider/PlaybackNarrativeDescriptor.java
@@ -0,0 +1,38 @@
+/*
+ *  This file is part of Com-Me.
+ * 
+ *  Com-Me is free software; you can redistribute it and/or modify it 
+ *  under the terms of the GNU Lesser General Public License as 
+ *  published by the Free Software Foundation; either version 3 of the 
+ *  License, or (at your option) any later version.
+ *
+ *  Com-Me is distributed in the hope that it will be useful, but WITHOUT 
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
+ *  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General 
+ *  Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with Com-Me.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ac.robinson.mediaphone.provider;
+
+import java.util.LinkedHashMap;
+
+public class PlaybackNarrativeDescriptor {
+	public final int mNarrativeImageAdjustment;
+	public int mNarrativeStartTime = 0;
+	public int mNarrativeDuration = 0;
+	public final LinkedHashMap<Integer, String> mTimeToFrameMap = new LinkedHashMap<>(); 
+
+	/**
+	 * 
+	 * @param imageAdjustment an adjustment, in milliseconds to subtract from the start time of images in order to make
+	 *            sure they appear at the right time during playback (due to crossfade). Must be either zero or
+	 *            positive.
+	 */
+	public PlaybackNarrativeDescriptor(int imageAdjustment) {
+		mNarrativeImageAdjustment = imageAdjustment;
+	}
+}
diff --git a/src/ac/robinson/mediaphone/provider/UpgradeManager.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/provider/UpgradeManager.java
similarity index 100%
rename from src/ac/robinson/mediaphone/provider/UpgradeManager.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/provider/UpgradeManager.java
diff --git a/MediaPhone/src/main/java/ac/robinson/mediaphone/util/SystemUiHider.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/util/SystemUiHider.java
new file mode 100644
index 0000000..f42b800
--- /dev/null
+++ b/MediaPhone/src/main/java/ac/robinson/mediaphone/util/SystemUiHider.java
@@ -0,0 +1,174 @@
+/*
+ *  This file is part of Com-Me.
+ * 
+ *  Com-Me is free software; you can redistribute it and/or modify it 
+ *  under the terms of the GNU Lesser General Public License as 
+ *  published by the Free Software Foundation; either version 3 of the 
+ *  License, or (at your option) any later version.
+ *
+ *  Com-Me is distributed in the hope that it will be useful, but WITHOUT 
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
+ *  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General 
+ *  Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with Com-Me.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ac.robinson.mediaphone.util;
+
+import android.app.Activity;
+import android.os.Build;
+import android.view.View;
+
+/**
+ * A utility class that helps with showing and hiding system UI such as the status bar and navigation/system bar. This
+ * class uses backward-compatibility techniques described in <a href=
+ * "http://developer.android.com/training/backward-compatible-ui/index.html"> Creating Backward-Compatible UIs</a> to
+ * ensure that devices running any version of Android OS are supported. More specifically, there are separate
+ * implementations of this abstract class: for newer devices, {@link #getInstance} will return a
+ * {@link SystemUiHiderHoneycomb} instance, while on older devices {@link #getInstance} will return a
+ * {@link SystemUiHiderBase} instance.
+ * <p>
+ * For more on system bars, see <a href="http://developer.android.com/design/get-started/ui-overview.html#system-bars">
+ * System Bars</a>.
+ * 
+ * @see android.view.View#setSystemUiVisibility(int)
+ * @see android.view.WindowManager.LayoutParams#FLAG_FULLSCREEN
+ */
+public abstract class SystemUiHider {
+	/**
+	 * When this flag is set, the {@link android.view.WindowManager.LayoutParams#FLAG_LAYOUT_IN_SCREEN} flag will be set
+	 * on older devices, making the status bar "float" on top of the activity layout. This is most useful when there are
+	 * no controls at the top of the activity layout.
+	 * <p>
+	 * This flag isn't used on newer devices because the <a
+	 * href="http://developer.android.com/design/patterns/actionbar.html">action bar</a>, the most important structural
+	 * element of an Android app, should be visible and not obscured by the system UI.
+	 */
+	public static final int FLAG_LAYOUT_IN_SCREEN_OLDER_DEVICES = 0x1;
+
+	/**
+	 * When this flag is set, {@link #show()} and {@link #hide()} will toggle the visibility of the status bar. If there
+	 * is a navigation bar, show and hide will toggle low profile mode.
+	 */
+	public static final int FLAG_FULLSCREEN = 0x2;
+
+	/**
+	 * When this flag is set, {@link #show()} and {@link #hide()} will toggle the visibility of the navigation bar, if
+	 * it's present on the device and the device allows hiding it. In cases where the navigation bar is present but
+	 * cannot be hidden, show and hide will toggle low profile mode.
+	 */
+	public static final int FLAG_HIDE_NAVIGATION = FLAG_FULLSCREEN | 0x4;
+
+	/**
+	 * The activity associated with this UI hider object.
+	 */
+	protected Activity mActivity;
+
+	/**
+	 * The view on which {@link View#setSystemUiVisibility(int)} will be called.
+	 */
+	protected View mAnchorView;
+
+	/**
+	 * The current UI hider flags.
+	 * 
+	 * @see #FLAG_FULLSCREEN
+	 * @see #FLAG_HIDE_NAVIGATION
+	 * @see #FLAG_LAYOUT_IN_SCREEN_OLDER_DEVICES
+	 */
+	protected int mFlags;
+
+	/**
+	 * The current visibility callback.
+	 */
+	protected OnVisibilityChangeListener mOnVisibilityChangeListener = sDummyListener;
+
+	/**
+	 * Creates and returns an instance of {@link SystemUiHider} that is appropriate for this device. The object will be
+	 * either a {@link SystemUiHiderBase} or {@link SystemUiHiderHoneycomb} depending on the device.
+	 * 
+	 * @param activity The activity whose window's system UI should be controlled by this class.
+	 * @param anchorView The view on which {@link View#setSystemUiVisibility(int)} will be called.
+	 * @param flags Either 0 or any combination of {@link #FLAG_FULLSCREEN}, {@link #FLAG_HIDE_NAVIGATION}, and
+	 *            {@link #FLAG_LAYOUT_IN_SCREEN_OLDER_DEVICES}.
+	 */
+	public static SystemUiHider getInstance(Activity activity, View anchorView, int flags) {
+		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
+			return new SystemUiHiderHoneycomb(activity, anchorView, flags);
+		} else {
+			return new SystemUiHiderBase(activity, anchorView, flags);
+		}
+	}
+
+	protected SystemUiHider(Activity activity, View anchorView, int flags) {
+		mActivity = activity;
+		mAnchorView = anchorView;
+		mFlags = flags;
+	}
+
+	/**
+	 * Sets up the system UI hider. Should be called from {@link Activity#onCreate}.
+	 */
+	public abstract void setup();
+
+	/**
+	 * Returns whether or not the system UI is visible.
+	 */
+	public abstract boolean isVisible();
+
+	/**
+	 * Hide the system UI.
+	 */
+	public abstract void hide();
+
+	/**
+	 * Show the system UI.
+	 */
+	public abstract void show();
+
+	/**
+	 * Toggle the visibility of the system UI.
+	 */
+	public void toggle() {
+		if (isVisible()) {
+			hide();
+		} else {
+			show();
+		}
+	}
+
+	/**
+	 * Registers a callback, to be triggered when the system UI visibility changes.
+	 */
+	public void setOnVisibilityChangeListener(OnVisibilityChangeListener listener) {
+		if (listener == null) {
+			listener = sDummyListener;
+		}
+
+		mOnVisibilityChangeListener = listener;
+	}
+
+	/**
+	 * A dummy no-op callback for use when there is no other listener set.
+	 */
+	private static OnVisibilityChangeListener sDummyListener = new OnVisibilityChangeListener() {
+		@Override
+		public void onVisibilityChange(boolean visible) {
+		}
+	};
+
+	/**
+	 * A callback interface used to listen for system UI visibility changes.
+	 */
+	public interface OnVisibilityChangeListener {
+		/**
+		 * Called when the system UI visibility has changed.
+		 * 
+		 * @param visible True if the system UI is visible.
+		 */
+		public void onVisibilityChange(boolean visible);
+	}
+}
diff --git a/MediaPhone/src/main/java/ac/robinson/mediaphone/util/SystemUiHiderBase.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/util/SystemUiHiderBase.java
new file mode 100644
index 0000000..671135e
--- /dev/null
+++ b/MediaPhone/src/main/java/ac/robinson/mediaphone/util/SystemUiHiderBase.java
@@ -0,0 +1,78 @@
+/*
+ *  This file is part of Com-Me.
+ * 
+ *  Com-Me is free software; you can redistribute it and/or modify it 
+ *  under the terms of the GNU Lesser General Public License as 
+ *  published by the Free Software Foundation; either version 3 of the 
+ *  License, or (at your option) any later version.
+ *
+ *  Com-Me is distributed in the hope that it will be useful, but WITHOUT 
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
+ *  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General 
+ *  Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with Com-Me.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ac.robinson.mediaphone.util;
+
+import android.app.Activity;
+import android.view.View;
+import android.view.WindowManager;
+
+/**
+ * A base implementation of {@link SystemUiHider}. Uses APIs available in all API levels to show and hide the status
+ * bar.
+ */
+public class SystemUiHiderBase extends SystemUiHider {
+	/**
+	 * Whether or not the system UI is currently visible. This is a cached value from calls to {@link #hide()} and
+	 * {@link #show()}.
+	 */
+	private boolean mVisible = true;
+
+	/**
+	 * Constructor not intended to be called by clients. Use {@link SystemUiHider#getInstance} to obtain an instance.
+	 */
+	protected SystemUiHiderBase(Activity activity, View anchorView, int flags) {
+		super(activity, anchorView, flags);
+	}
+
+	@Override
+	public void setup() {
+		if ((mFlags & FLAG_LAYOUT_IN_SCREEN_OLDER_DEVICES) == 0) {
+			mActivity.getWindow()
+					.setFlags(
+							WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN
+									| WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,
+							WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN
+									| WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS);
+		}
+	}
+
+	@Override
+	public boolean isVisible() {
+		return mVisible;
+	}
+
+	@Override
+	public void hide() {
+		if ((mFlags & FLAG_FULLSCREEN) != 0) {
+			mActivity.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
+					WindowManager.LayoutParams.FLAG_FULLSCREEN);
+		}
+		mOnVisibilityChangeListener.onVisibilityChange(false);
+		mVisible = false;
+	}
+
+	@Override
+	public void show() {
+		if ((mFlags & FLAG_FULLSCREEN) != 0) {
+			mActivity.getWindow().setFlags(0, WindowManager.LayoutParams.FLAG_FULLSCREEN);
+		}
+		mOnVisibilityChangeListener.onVisibilityChange(true);
+		mVisible = true;
+	}
+}
diff --git a/MediaPhone/src/main/java/ac/robinson/mediaphone/util/SystemUiHiderHoneycomb.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/util/SystemUiHiderHoneycomb.java
new file mode 100644
index 0000000..d49ff0f
--- /dev/null
+++ b/MediaPhone/src/main/java/ac/robinson/mediaphone/util/SystemUiHiderHoneycomb.java
@@ -0,0 +1,138 @@
+/*
+ *  This file is part of Com-Me.
+ * 
+ *  Com-Me is free software; you can redistribute it and/or modify it 
+ *  under the terms of the GNU Lesser General Public License as 
+ *  published by the Free Software Foundation; either version 3 of the 
+ *  License, or (at your option) any later version.
+ *
+ *  Com-Me is distributed in the hope that it will be useful, but WITHOUT 
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
+ *  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General 
+ *  Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with Com-Me.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ac.robinson.mediaphone.util;
+
+import android.annotation.SuppressLint;
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.os.Build;
+import android.view.View;
+import android.view.WindowManager;
+
+/**
+ * An API 11+ implementation of {@link SystemUiHider}. Uses APIs available in Honeycomb and later (specifically
+ * {@link View#setSystemUiVisibility(int)}) to show and hide the system UI.
+ */
+@TargetApi(Build.VERSION_CODES.HONEYCOMB)
+public class SystemUiHiderHoneycomb extends SystemUiHiderBase {
+	/**
+	 * Flags for {@link View#setSystemUiVisibility(int)} to use when showing the system UI.
+	 */
+	private int mShowFlags;
+
+	/**
+	 * Flags for {@link View#setSystemUiVisibility(int)} to use when hiding the system UI.
+	 */
+	private int mHideFlags;
+
+	/**
+	 * Flags to test against the first parameter in
+	 * {@link android.view.View.OnSystemUiVisibilityChangeListener#onSystemUiVisibilityChange(int)} to determine the
+	 * system UI visibility state.
+	 */
+	private int mTestFlags;
+
+	/**
+	 * Whether or not the system UI is currently visible. This is cached from
+	 * {@link android.view.View.OnSystemUiVisibilityChangeListener}.
+	 */
+	private boolean mVisible = true;
+
+	/**
+	 * Constructor not intended to be called by clients. Use {@link SystemUiHider#getInstance} to obtain an instance.
+	 */
+	@SuppressLint("InlinedApi")
+	protected SystemUiHiderHoneycomb(Activity activity, View anchorView, int flags) {
+		super(activity, anchorView, flags);
+
+		mShowFlags = View.SYSTEM_UI_FLAG_VISIBLE;
+		mHideFlags = View.SYSTEM_UI_FLAG_LOW_PROFILE;
+		mTestFlags = View.SYSTEM_UI_FLAG_LOW_PROFILE;
+
+		if ((mFlags & FLAG_FULLSCREEN) != 0) {
+			// If the client requested fullscreen, add flags relevant to hiding the status bar. Note that some of these
+			// constants are new as of API 16 (Jelly Bean). It is safe to use them, as they are inlined at compile-time
+			// and do nothing on pre-Jelly Bean devices.
+			mShowFlags |= View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN;
+			mHideFlags |= View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_FULLSCREEN;
+		}
+
+		if ((mFlags & FLAG_HIDE_NAVIGATION) != 0) {
+			// If the client requested hiding navigation, add relevant flags.
+			mShowFlags |= View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION;
+			mHideFlags |= View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;
+			mTestFlags |= View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;
+		}
+	}
+
+	/** {@inheritDoc} */
+	@Override
+	public void setup() {
+		mAnchorView.setOnSystemUiVisibilityChangeListener(mSystemUiVisibilityChangeListener);
+	}
+
+	/** {@inheritDoc} */
+	@Override
+	public void hide() {
+		mAnchorView.setSystemUiVisibility(mHideFlags);
+	}
+
+	/** {@inheritDoc} */
+	@Override
+	public void show() {
+		mAnchorView.setSystemUiVisibility(mShowFlags);
+	}
+
+	/** {@inheritDoc} */
+	@Override
+	public boolean isVisible() {
+		return mVisible;
+	}
+
+	private View.OnSystemUiVisibilityChangeListener mSystemUiVisibilityChangeListener = new View.OnSystemUiVisibilityChangeListener() {
+		@Override
+		public void onSystemUiVisibilityChange(int vis) {
+			// Test against mTestFlags to see if the system UI is visible.
+			if ((vis & mTestFlags) != 0) {
+				if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {
+					// Pre-Jelly Bean, we must manually hide the action bar and use the old window flags API.
+					mActivity.getActionBar().hide();
+					mActivity.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
+							WindowManager.LayoutParams.FLAG_FULLSCREEN);
+				}
+
+				// Trigger the registered listener and cache the visibility state.
+				mOnVisibilityChangeListener.onVisibilityChange(false);
+				mVisible = false;
+
+			} else {
+				mAnchorView.setSystemUiVisibility(mShowFlags);
+				if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {
+					// Pre-Jelly Bean, we must manually show the action bar and use the old window flags API.
+					mActivity.getActionBar().show();
+					mActivity.getWindow().setFlags(0, WindowManager.LayoutParams.FLAG_FULLSCREEN);
+				}
+
+				// Trigger the registered listener and cache the visibility state.
+				mOnVisibilityChangeListener.onVisibilityChange(true);
+				mVisible = true;
+			}
+		}
+	};
+}
diff --git a/src/ac/robinson/mediaphone/view/CameraView.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/view/CameraView.java
similarity index 100%
rename from src/ac/robinson/mediaphone/view/CameraView.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/view/CameraView.java
diff --git a/src/ac/robinson/mediaphone/view/FrameViewHolder.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/view/FrameViewHolder.java
similarity index 100%
rename from src/ac/robinson/mediaphone/view/FrameViewHolder.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/view/FrameViewHolder.java
diff --git a/src/ac/robinson/mediaphone/view/HorizontalListView.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/view/HorizontalListView.java
similarity index 95%
rename from src/ac/robinson/mediaphone/view/HorizontalListView.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/view/HorizontalListView.java
index 661b62e..cd58a80 100644
--- a/src/ac/robinson/mediaphone/view/HorizontalListView.java
+++ b/MediaPhone/src/main/java/ac/robinson/mediaphone/view/HorizontalListView.java
@@ -72,7 +72,7 @@ public class HorizontalListView extends AdapterView<ListAdapter> {
 	protected Scroller mScroller;
 	private GestureDetector mGestureDetector;
 	private HorizontalGestureListener mGestureListener = new HorizontalGestureListener();
-	private Queue<View> mRemovedViewQueue = new LinkedList<View>();
+	private Queue<View> mRemovedViewQueue = new LinkedList<>();
 	private OnItemSelectedListener mOnItemSelected;
 	private OnItemClickListener mOnItemClicked;
 	private OnItemLongClickListener mOnItemLongClicked;
@@ -672,10 +672,10 @@ public class HorizontalListView extends AdapterView<ListAdapter> {
 						resetPressState();
 
 						// this is a hack to pass both ids in a standard event handler
-						int maxId = Math.max(primaryViewId, secondaryViewId);
+						int minId = Math.min(primaryViewId, secondaryViewId);
 						if (mOnItemLongClicked != null) {
 							mOnItemLongClicked.onItemLongClick(HorizontalListView.this,
-									(maxId == primaryViewId ? primaryView : secondaryView), mLeftViewIndex + 1 + maxId,
+									(minId == primaryViewId ? primaryView : secondaryView), mLeftViewIndex + 1 + minId,
 									1);
 						}
 					}
@@ -832,10 +832,10 @@ public class HorizontalListView extends AdapterView<ListAdapter> {
 						View secondaryView = getChildAt(secondaryViewId);
 
 						// this is a hack to pass both ids in a standard event handler
-						int maxId = Math.max(selectedChild, secondaryViewId);
+						int minId = Math.min(selectedChild, secondaryViewId);
 						playSoundEffect(SoundEffectConstants.CLICK); // play the default button click (respects prefs)
-						mOnItemClicked.onItemClick(HorizontalListView.this, (maxId == selectedChild ? child
-								: secondaryView), mLeftViewIndex + 1 + maxId, 1);
+						mOnItemClicked.onItemClick(HorizontalListView.this, (minId == selectedChild ? child
+								: secondaryView), mLeftViewIndex + 1 + minId, 1);
 					}
 				}
 
diff --git a/src/ac/robinson/mediaphone/view/NarrativeViewHolder.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/view/NarrativeViewHolder.java
similarity index 100%
rename from src/ac/robinson/mediaphone/view/NarrativeViewHolder.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/view/NarrativeViewHolder.java
diff --git a/src/ac/robinson/mediaphone/view/NarrativesListView.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/view/NarrativesListView.java
similarity index 100%
rename from src/ac/robinson/mediaphone/view/NarrativesListView.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/view/NarrativesListView.java
diff --git a/src/ac/robinson/mediaphone/view/PressableRelativeLayout.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/view/PressableRelativeLayout.java
similarity index 90%
rename from src/ac/robinson/mediaphone/view/PressableRelativeLayout.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/view/PressableRelativeLayout.java
index 5561b84..ecc5792 100644
--- a/src/ac/robinson/mediaphone/view/PressableRelativeLayout.java
+++ b/MediaPhone/src/main/java/ac/robinson/mediaphone/view/PressableRelativeLayout.java
@@ -30,10 +30,10 @@ import android.widget.RelativeLayout;
 
 public class PressableRelativeLayout extends RelativeLayout {
 
-	public static final int PLAY_ICON = android.R.drawable.ic_media_play; // or ic_menu_play_clip
-	public static final int EDIT_ICON = android.R.drawable.ic_menu_manage;
-	public static final int EDIT_ICON_LEFT = R.drawable.edit_icon_left;
-	public static final int EDIT_ICON_RIGHT = R.drawable.edit_icon_right;
+	public static final int PLAY_ICON = R.drawable.ic_menu_play;
+	public static final int EDIT_ICON = R.drawable.ic_menu_settings;
+	public static final int EDIT_ICON_LEFT = R.drawable.ic_narratives_insert_left;
+	public static final int EDIT_ICON_RIGHT = R.drawable.ic_narratives_insert_right;
 
 	private ImageView mOverlayView;
 	private Integer mOverlayResource;
diff --git a/src/ac/robinson/mediaphone/view/SeekBarPreference.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/view/SeekBarPreference.java
similarity index 100%
rename from src/ac/robinson/mediaphone/view/SeekBarPreference.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/view/SeekBarPreference.java
diff --git a/src/ac/robinson/mediaphone/view/SeekBarRelativeLayout.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/view/SeekBarRelativeLayout.java
similarity index 100%
rename from src/ac/robinson/mediaphone/view/SeekBarRelativeLayout.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/view/SeekBarRelativeLayout.java
diff --git a/MediaPhone/src/main/java/ac/robinson/mediaphone/view/SendToBackRelativeLayout.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/view/SendToBackRelativeLayout.java
new file mode 100644
index 0000000..8c7d7ea
--- /dev/null
+++ b/MediaPhone/src/main/java/ac/robinson/mediaphone/view/SendToBackRelativeLayout.java
@@ -0,0 +1,46 @@
+/*
+ *  This file is part of Com-Me.
+ * 
+ *  Com-Me is free software; you can redistribute it and/or modify it 
+ *  under the terms of the GNU Lesser General Public License as 
+ *  published by the Free Software Foundation; either version 3 of the 
+ *  License, or (at your option) any later version.
+ *
+ *  Com-Me is distributed in the hope that it will be useful, but WITHOUT 
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
+ *  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General 
+ *  Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with Com-Me.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ac.robinson.mediaphone.view;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.view.View;
+import android.widget.RelativeLayout;
+
+public class SendToBackRelativeLayout extends RelativeLayout {
+	public SendToBackRelativeLayout(Context context) {
+		super(context);
+	}
+
+	public SendToBackRelativeLayout(Context context, AttributeSet attrs) {
+		super(context, attrs);
+	}
+
+	public SendToBackRelativeLayout(Context context, AttributeSet attrs, int defStyle) {
+		super(context, attrs, defStyle);
+	}
+
+	public void sendChildToBack(View child) {
+		int index = indexOfChild(child);
+		if (index > 0) {
+			detachViewFromParent(index);
+			attachViewToParent(child, 0, child.getLayoutParams());
+		}
+	}
+}
diff --git a/src/ac/robinson/mediaphone/view/VUMeter.java b/MediaPhone/src/main/java/ac/robinson/mediaphone/view/VUMeter.java
similarity index 100%
rename from src/ac/robinson/mediaphone/view/VUMeter.java
rename to MediaPhone/src/main/java/ac/robinson/mediaphone/view/VUMeter.java
diff --git a/src/ac/robinson/mediaphone/activity/NarrativePlayerActivity.java b/src/ac/robinson/mediaphone/activity/NarrativePlayerActivity.java
deleted file mode 100644
index f6a9d6e..0000000
--- a/src/ac/robinson/mediaphone/activity/NarrativePlayerActivity.java
+++ /dev/null
@@ -1,779 +0,0 @@
-/*
- *  Copyright (C) 2012 Simon Robinson
- * 
- *  This file is part of Com-Me.
- * 
- *  Com-Me is free software; you can redistribute it and/or modify it 
- *  under the terms of the GNU Lesser General Public License as 
- *  published by the Free Software Foundation; either version 3 of the 
- *  License, or (at your option) any later version.
- *
- *  Com-Me is distributed in the hope that it will be useful, but WITHOUT 
- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
- *  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General 
- *  Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with Com-Me.
- *  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package ac.robinson.mediaphone.activity;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.util.ArrayList;
-
-import ac.robinson.mediaphone.MediaPhone;
-import ac.robinson.mediaphone.MediaPhoneActivity;
-import ac.robinson.mediaphone.R;
-import ac.robinson.mediaphone.provider.FrameItem;
-import ac.robinson.mediaphone.provider.FramesManager;
-import ac.robinson.mediaphone.provider.MediaPhoneProvider;
-import ac.robinson.mediaphone.provider.NarrativeItem;
-import ac.robinson.mediaphone.provider.NarrativesManager;
-import ac.robinson.mediautilities.FrameMediaContainer;
-import ac.robinson.util.BitmapUtilities;
-import ac.robinson.util.DebugUtilities;
-import ac.robinson.util.IOUtilities;
-import ac.robinson.util.UIUtilities;
-import ac.robinson.view.AutoResizeTextView;
-import ac.robinson.view.CustomMediaController;
-import android.content.ContentResolver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.content.res.AssetFileDescriptor;
-import android.content.res.Resources;
-import android.graphics.Bitmap;
-import android.media.AudioManager;
-import android.media.MediaPlayer;
-import android.media.MediaPlayer.OnCompletionListener;
-import android.media.MediaPlayer.OnErrorListener;
-import android.media.MediaPlayer.OnPreparedListener;
-import android.media.SoundPool;
-import android.os.Build;
-import android.os.Bundle;
-import android.text.TextUtils;
-import android.util.Log;
-import android.util.TypedValue;
-import android.view.Menu;
-import android.view.MenuInflater;
-import android.view.MenuItem;
-import android.view.MotionEvent;
-import android.view.View;
-import android.widget.ImageView;
-import android.widget.ImageView.ScaleType;
-import android.widget.RelativeLayout;
-
-import com.larvalabs.svgandroid.SVGParser;
-
-public class NarrativePlayerActivity extends MediaPhoneActivity {
-
-	private final int EXTRA_AUDIO_ITEMS = 2; // 3 audio items max, but only 2 for sound pool (other is in MediaPlayer)
-	private SoundPool mSoundPool;
-	private ArrayList<Integer> mFrameSounds;
-	private int mNumExtraSounds;
-	private boolean mMediaPlayerPrepared;
-	private boolean mSoundPoolPrepared;
-	private AssetFileDescriptor mSilenceFileDescriptor = null;
-	private boolean mSilenceFilePlaying;
-	private long mPlaybackStartTime;
-	private long mPlaybackPauseTime;
-
-	private MediaPlayer mMediaPlayer;
-	private boolean mMediaPlayerError;
-	private boolean mHasPlayed;
-	private boolean mIsLoading;
-	private TouchCallbackCustomMediaController mMediaController;
-	private ArrayList<FrameMediaContainer> mNarrativeContentList;
-	private int mNarrativeDuration;
-	private int mPlaybackPosition;
-	private int mInitialPlaybackOffset;
-	private int mNonAudioOffset;
-	private FrameMediaContainer mCurrentFrameContainer;
-	private Bitmap mAudioPictureBitmap = null;
-
-	private boolean mShowBackButton = false; // loaded from preferences on startup
-
-	@Override
-	protected void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		UIUtilities.configureActionBar(this, true, true, R.string.title_playback, 0);
-		UIUtilities.actionBarVisibility(this, false);
-		setContentView(R.layout.narrative_player);
-
-		// so that the volume controls always control media volume (rather than ringtone etc.)
-		setVolumeControlStream(AudioManager.STREAM_MUSIC);
-
-		mIsLoading = false;
-		mMediaPlayerError = false;
-
-		// load previous state on screen rotation
-		mHasPlayed = false; // will begin playing if not playing already; used to stop unplayable narratives
-		mPlaybackPosition = -1;
-		if (savedInstanceState != null) {
-			// mIsPlaying = savedInstanceState.getBoolean(getString(R.string.extra_is_playing));
-			mPlaybackPosition = savedInstanceState.getInt(getString(R.string.extra_playback_position));
-			mInitialPlaybackOffset = savedInstanceState.getInt(getString(R.string.extra_playback_offset));
-			mNonAudioOffset = savedInstanceState.getInt(getString(R.string.extra_playback_non_audio_offset));
-		} else {
-			UIUtilities.setFullScreen(getWindow()); // start in full screen so initial playback bar hiding is smoother
-		}
-	}
-
-	@Override
-	public void onSaveInstanceState(Bundle savedInstanceState) {
-		// savedInstanceState.putBoolean(getString(R.string.extra_is_playing), mIsPlaying);
-		savedInstanceState.putInt(getString(R.string.extra_playback_position), mPlaybackPosition);
-		savedInstanceState.putInt(getString(R.string.extra_playback_offset),
-				mMediaPlayerController.getCurrentPosition() - mPlaybackPosition);
-		savedInstanceState.putInt(getString(R.string.extra_playback_non_audio_offset), mNonAudioOffset);
-		super.onSaveInstanceState(savedInstanceState);
-	}
-
-	@Override
-	public void onWindowFocusChanged(boolean hasFocus) {
-		super.onWindowFocusChanged(hasFocus);
-		if (hasFocus) {
-			if (!mHasPlayed) {
-				preparePlayback();
-			} else {
-				if (mMediaPlayer != null && mMediaPlayer.isPlaying()) { // don't hide the controller if we're paused
-					showMediaController(CustomMediaController.DEFAULT_VISIBILITY_TIMEOUT);
-				}
-			}
-		} else {
-			showMediaController(-1); // so if we're interacting with an overlay we don't constantly hide/show
-			UIUtilities.setNonFullScreen(getWindow()); // so we don't have to wait for the playback bar to hide before
-														// showing the notification bar
-		}
-	}
-
-	@Override
-	protected void onPause() {
-		super.onPause();
-		pauseMediaController();
-	}
-
-	@Override
-	protected void onDestroy() {
-		releasePlayer();
-		super.onDestroy();
-	}
-
-	@Override
-	public void onBackPressed() {
-		if (mCurrentFrameContainer != null) {
-			NarrativeItem deletedNarrative = NarrativesManager.findNarrativeByInternalId(getContentResolver(),
-					mCurrentFrameContainer.mParentId);
-			if (deletedNarrative != null && deletedNarrative.getDeleted()) {
-				setResult(R.id.result_narrative_deleted_exit);
-			} else {
-				saveLastEditedFrame(mCurrentFrameContainer.mFrameId);
-			}
-		}
-		super.onBackPressed();
-	}
-
-	@Override
-	public boolean onCreateOptionsMenu(Menu menu) {
-		// TODO: if we couldn't open a temporary directory then exporting won't work
-		MenuInflater inflater = getMenuInflater();
-		inflater.inflate(R.menu.export_narrative, menu);
-		inflater.inflate(R.menu.make_template, menu);
-		inflater.inflate(R.menu.delete_narrative, menu);
-		return super.onCreateOptionsMenu(menu);
-	}
-
-	@Override
-	public boolean onOptionsItemSelected(MenuItem item) {
-		pauseMediaController();
-		final int itemId = item.getItemId();
-		switch (itemId) {
-			case R.id.menu_make_template:
-				FrameItem templateFrame = FramesManager.findFrameByInternalId(getContentResolver(),
-						mCurrentFrameContainer.mFrameId);
-				runQueuedBackgroundTask(getNarrativeTemplateRunnable(templateFrame.getParentId(),
-						MediaPhoneProvider.getNewInternalId(), true)); // don't need the id
-				// TODO: do we need to keep the screen on?
-				return true;
-
-			case R.id.menu_delete_narrative:
-				deleteNarrativeDialog(mCurrentFrameContainer.mFrameId);
-				return true;
-
-			case R.id.menu_export_narrative:
-				exportNarrative();
-				return true;
-
-			default:
-				return super.onOptionsItemSelected(item);
-		}
-	}
-
-	@Override
-	protected void loadPreferences(SharedPreferences mediaPhoneSettings) {
-		// no normal preferences apply to this activity
-	}
-
-	@Override
-	protected void configureInterfacePreferences(SharedPreferences mediaPhoneSettings) {
-		// the soft back button (necessary in some circumstances)
-		mShowBackButton = Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB
-				&& mediaPhoneSettings.getBoolean(getString(R.string.key_show_back_button),
-						getResources().getBoolean(R.bool.default_show_back_button));
-		setMediaControllerListeners(); // TODO: do we need to do this here?
-	}
-
-	private void preparePlayback() {
-		if (mNarrativeContentList != null && mNarrativeContentList.size() > 0 && mMediaPlayer != null
-				&& mSoundPool != null && mMediaController != null && mPlaybackPosition >= 0) {
-			return; // no need to re-initialise
-		}
-
-		// need the parent id
-		final Intent intent = getIntent();
-		if (intent == null) {
-			UIUtilities.showToast(NarrativePlayerActivity.this, R.string.error_loading_narrative_player);
-			onBackPressed();
-			return;
-		}
-		String startFrameId = intent.getStringExtra(getString(R.string.extra_internal_id));
-
-		// TODO: lazily load (either via AsyncTask/Thread, or ImageCache for low-quality versions, later replaced)
-		ContentResolver contentResolver = getContentResolver();
-		FrameItem currentFrame = FramesManager.findFrameByInternalId(contentResolver, startFrameId);
-		NarrativeItem currentNarrative = NarrativesManager.findNarrativeByInternalId(contentResolver,
-				currentFrame.getParentId());
-		mNarrativeContentList = currentNarrative.getContentList(contentResolver);
-
-		// first launch
-		boolean updatePosition = mPlaybackPosition < 0;
-		if (updatePosition) {
-			mInitialPlaybackOffset = 0;
-			mNonAudioOffset = 0;
-		}
-		mNarrativeDuration = 0;
-		for (FrameMediaContainer container : mNarrativeContentList) {
-			if (updatePosition && startFrameId.equals(container.mFrameId)) {
-				updatePosition = false;
-				mPlaybackPosition = mNarrativeDuration;
-			}
-			mNarrativeDuration += container.mFrameMaxDuration;
-		}
-		if (mPlaybackPosition < 0) {
-			mPlaybackPosition = 0;
-			mInitialPlaybackOffset = 0;
-			mNonAudioOffset = 0;
-		}
-
-		mCurrentFrameContainer = getMediaContainer(mPlaybackPosition, true);
-
-		releasePlayer();
-		mMediaPlayer = new MediaPlayer();
-		mSoundPool = new SoundPool(EXTRA_AUDIO_ITEMS, AudioManager.STREAM_MUSIC, 100);
-		mFrameSounds = new ArrayList<Integer>();
-
-		mMediaController = new TouchCallbackCustomMediaController(this);
-		setMediaControllerListeners();
-
-		RelativeLayout parentLayout = (RelativeLayout) findViewById(R.id.narrative_playback_container);
-		RelativeLayout.LayoutParams controllerLayout = new RelativeLayout.LayoutParams(
-				RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.WRAP_CONTENT);
-		controllerLayout.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);
-		controllerLayout.setMargins(0, 0, 0, getResources().getDimensionPixelSize(R.dimen.button_padding));
-		parentLayout.addView(mMediaController, controllerLayout);
-		mMediaController.setAnchorView(findViewById(R.id.image_playback));
-		showMediaController(CustomMediaController.DEFAULT_VISIBILITY_TIMEOUT); // (can use 0 for permanent visibility)
-
-		mHasPlayed = true;
-		prepareMediaItems(mCurrentFrameContainer);
-	}
-
-	public void handleButtonClicks(View currentButton) {
-		if (!verifyButtonClick(currentButton)) {
-			return;
-		}
-
-		showMediaController(CustomMediaController.DEFAULT_VISIBILITY_TIMEOUT);
-		UIUtilities.setNonFullScreen(getWindow()); // so we don't have to wait for the playback bar to hide before
-													// showing the notification bar
-	}
-
-	private void showMediaController(int timeout) {
-		if (mMediaController != null) {
-			if (!mMediaController.isShowing() || timeout <= 0) {
-				mMediaController.show(timeout);
-			} else {
-				mMediaController.refreshShowTimeout();
-			}
-		}
-	}
-
-	private void makeMediaItemsVisible(boolean mediaControllerIsShowing) {
-		// make sure the text view is visible above the playback bar
-		Resources res = getResources();
-		int mediaControllerHeight = res.getDimensionPixelSize(R.dimen.media_controller_height);
-		if (mCurrentFrameContainer != null && mCurrentFrameContainer.mImagePath != null) {
-			AutoResizeTextView textView = (AutoResizeTextView) findViewById(R.id.text_playback);
-			RelativeLayout.LayoutParams textLayout = (RelativeLayout.LayoutParams) textView.getLayoutParams();
-			int textPadding = res.getDimensionPixelSize(R.dimen.playback_text_padding);
-			textLayout.setMargins(0, 0, 0, (mediaControllerIsShowing ? mediaControllerHeight : textPadding));
-			textView.setLayoutParams(textLayout);
-		}
-	}
-
-	private void pauseMediaController() {
-		mMediaPlayerController.pause();
-		showMediaController(-1); // to keep on showing until done here
-		UIUtilities.releaseKeepScreenOn(getWindow());
-	}
-
-	private void setMediaControllerListeners() {
-		if (mMediaController != null) {
-			mMediaController.setPrevNextListeners(new View.OnClickListener() {
-				@Override
-				public void onClick(View v) {
-					pauseMediaController();
-					exportNarrative();
-				}
-			}, mShowBackButton ? new View.OnClickListener() {
-				@Override
-				public void onClick(View v) {
-					onBackPressed();
-				}
-			} : null);
-		}
-	}
-
-	private void exportNarrative() {
-		if (mCurrentFrameContainer != null) {
-			FrameItem exportFrame = FramesManager.findFrameByInternalId(getContentResolver(),
-					mCurrentFrameContainer.mFrameId);
-			if (exportFrame != null) {
-				exportContent(exportFrame.getParentId(), false);
-			}
-		}
-	}
-
-	private FrameMediaContainer getMediaContainer(int narrativePlaybackPosition, boolean updatePlaybackPosition) {
-		mIsLoading = true;
-		int currentPosition = 0;
-		for (FrameMediaContainer container : mNarrativeContentList) {
-			int newPosition = currentPosition + container.mFrameMaxDuration;
-			if (narrativePlaybackPosition >= currentPosition && narrativePlaybackPosition < newPosition) {
-				if (updatePlaybackPosition) {
-					mPlaybackPosition = currentPosition;
-				}
-				return container;
-			}
-			currentPosition = newPosition;
-		}
-		return null;
-	}
-
-	private void prepareMediaItems(FrameMediaContainer container) {
-		// load the audio for the media player
-		Resources res = getResources();
-		mSoundPoolPrepared = false;
-		mMediaPlayerPrepared = false;
-		mMediaPlayerError = false;
-		mNonAudioOffset = 0;
-		unloadSoundPool();
-		mSoundPool.setOnLoadCompleteListener(mSoundPoolLoadListener);
-		mNumExtraSounds = 0;
-		String currentAudioItem = null;
-		boolean soundPoolAllowed = !DebugUtilities.hasSoundPoolBug();
-		for (int i = 0, n = container.mAudioDurations.size(); i < n; i++) {
-			if (container.mAudioDurations.get(i).intValue() == container.mFrameMaxDuration) {
-				currentAudioItem = container.mAudioPaths.get(i);
-			} else {
-				// playing *anything* in SoundPool at the same time as MediaPlayer crashes on Galaxy Tab
-				if (soundPoolAllowed) {
-					mSoundPool.load(container.mAudioPaths.get(i), 1);
-					mNumExtraSounds += 1;
-				}
-			}
-		}
-		if (mNumExtraSounds == 0) {
-			mSoundPoolPrepared = true;
-		}
-
-		FileInputStream playerInputStream = null;
-		mSilenceFilePlaying = false;
-		boolean dataLoaded = false;
-		int dataLoadingErrorCount = 0;
-		while (!dataLoaded && dataLoadingErrorCount <= 2) {
-			try {
-				mMediaPlayer.reset();
-				if (currentAudioItem == null || (!(new File(currentAudioItem).exists()))) {
-					mSilenceFilePlaying = true;
-					if (mSilenceFileDescriptor == null) {
-						mSilenceFileDescriptor = res.openRawResourceFd(R.raw.silence_100ms);
-					}
-					mMediaPlayer.setDataSource(mSilenceFileDescriptor.getFileDescriptor(),
-							mSilenceFileDescriptor.getStartOffset(), mSilenceFileDescriptor.getDeclaredLength());
-				} else {
-					// can't play from data directory (they're private; permissions don't work), must use an input
-					// stream - original was: mMediaPlayer.setDataSource(currentAudioItem);
-					playerInputStream = new FileInputStream(new File(currentAudioItem));
-					mMediaPlayer.setDataSource(playerInputStream.getFD());
-				}
-				dataLoaded = true;
-			} catch (Throwable t) {
-				// sometimes setDataSource fails for mysterious reasons - loop to open it, rather than failing
-				dataLoaded = false;
-				dataLoadingErrorCount += 1;
-			} finally {
-				IOUtilities.closeStream(playerInputStream);
-			}
-		}
-
-		try {
-			if (dataLoaded) {
-				mMediaPlayer.setLooping(false);
-				mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
-				mMediaPlayer.setOnPreparedListener(mMediaPlayerPreparedListener);
-				// mMediaPlayer.setOnCompletionListener(mMediaPlayerCompletionListener); // done later - better pausing
-				mMediaPlayer.setOnErrorListener(mMediaPlayerErrorListener);
-				mMediaPlayer.prepareAsync();
-			} else {
-				throw new IllegalStateException();
-			}
-		} catch (Throwable t) {
-			UIUtilities.showToast(NarrativePlayerActivity.this, R.string.error_loading_narrative_player);
-			onBackPressed();
-			return;
-		}
-
-		// load the image
-		ImageView photoDisplay = (ImageView) findViewById(R.id.image_playback);
-		if (container.mImagePath != null && new File(container.mImagePath).exists()) {
-			Bitmap scaledBitmap = BitmapUtilities.loadAndCreateScaledBitmap(container.mImagePath,
-					photoDisplay.getWidth(), photoDisplay.getHeight(), BitmapUtilities.ScalingLogic.FIT, true);
-			photoDisplay.setImageBitmap(scaledBitmap);
-			photoDisplay.setScaleType(ScaleType.CENTER_INSIDE);
-		} else if (TextUtils.isEmpty(container.mTextContent)) { // no text and no image: audio icon
-			if (mAudioPictureBitmap == null) {
-				mAudioPictureBitmap = SVGParser.getSVGFromResource(res, R.raw.ic_audio_playback).getBitmap(
-						photoDisplay.getWidth(), photoDisplay.getHeight());
-			}
-			photoDisplay.setImageBitmap(mAudioPictureBitmap);
-			photoDisplay.setScaleType(ScaleType.FIT_CENTER);
-		} else {
-			photoDisplay.setImageDrawable(null);
-		}
-
-		// load the text
-		AutoResizeTextView textView = (AutoResizeTextView) findViewById(R.id.text_playback);
-		if (!TextUtils.isEmpty(container.mTextContent)) {
-			textView.setTextSize(TypedValue.COMPLEX_UNIT_PX, res.getDimensionPixelSize(R.dimen.playback_text));
-			textView.setText(container.mTextContent);
-			RelativeLayout.LayoutParams textLayout = new RelativeLayout.LayoutParams(
-					RelativeLayout.LayoutParams.WRAP_CONTENT, RelativeLayout.LayoutParams.WRAP_CONTENT);
-			textLayout.addRule(RelativeLayout.CENTER_HORIZONTAL);
-			int textViewHeight = res.getDimensionPixelSize(R.dimen.media_controller_height);
-			int textViewPadding = res.getDimensionPixelSize(R.dimen.playback_text_padding);
-			if (container.mImagePath != null) {
-				textView.setMaxHeight(res.getDimensionPixelSize(R.dimen.playback_maximum_text_height_with_image));
-				textLayout.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);
-				textLayout.setMargins(0, 0, 0, (mMediaController.isShowing() ? textViewHeight : textViewPadding));
-				textView.setBackgroundResource(R.drawable.rounded_playback_text);
-				textView.setTextColor(res.getColor(R.color.export_text_with_image));
-			} else {
-				textView.setMaxHeight(photoDisplay.getHeight()); // no way to clear, so set to parent height
-				textLayout.addRule(RelativeLayout.CENTER_VERTICAL);
-				textLayout.setMargins(0, 0, 0, textViewPadding);
-				textView.setBackgroundColor(res.getColor(android.R.color.transparent));
-				textView.setTextColor(res.getColor(R.color.export_text_no_image));
-			}
-			textView.setLayoutParams(textLayout);
-			textView.setVisibility(View.VISIBLE);
-		} else {
-			textView.setVisibility(View.GONE);
-		}
-	}
-
-	private void unloadSoundPool() {
-		for (Integer soundId : mFrameSounds) {
-			mSoundPool.stop(soundId);
-			mSoundPool.unload(soundId);
-		}
-		mFrameSounds.clear();
-	}
-
-	private void releasePlayer() {
-		UIUtilities.releaseKeepScreenOn(getWindow());
-		// release controller first, so we don't play to a null player
-		if (mMediaController != null) {
-			mMediaController.hide();
-			((RelativeLayout) findViewById(R.id.narrative_playback_container)).removeView(mMediaController);
-			mMediaController.setMediaPlayer(null);
-			mMediaController = null;
-		}
-		if (mMediaPlayer != null) {
-			try {
-				mMediaPlayer.stop();
-			} catch (IllegalStateException e) {
-			}
-			mMediaPlayer.release();
-			mMediaPlayer = null;
-		}
-		if (mSoundPool != null) {
-			unloadSoundPool();
-			mSoundPool.release();
-			mSoundPool = null;
-		}
-	}
-
-	private CustomMediaController.MediaPlayerControl mMediaPlayerController = new CustomMediaController.MediaPlayerControl() {
-		@Override
-		public void start() {
-			mPlaybackPauseTime = -1;
-			if (mPlaybackPosition < 0) { // so we return to the start when playing from the end
-				mPlaybackPosition = 0;
-				mInitialPlaybackOffset = 0;
-				mNonAudioOffset = 0;
-				mCurrentFrameContainer = getMediaContainer(mPlaybackPosition, true);
-				prepareMediaItems(mCurrentFrameContainer);
-			} else {
-				if (mMediaPlayer != null && mSoundPool != null) {
-					mMediaPlayer.setOnCompletionListener(mMediaPlayerCompletionListener);
-					mPlaybackStartTime = System.currentTimeMillis() - mMediaPlayer.getCurrentPosition();
-					mMediaPlayer.start();
-					mSoundPool.autoResume(); // TODO: check this works
-					showMediaController(CustomMediaController.DEFAULT_VISIBILITY_TIMEOUT);
-				} else {
-					UIUtilities.showToast(NarrativePlayerActivity.this, R.string.error_loading_narrative_player);
-					onBackPressed();
-					return;
-				}
-			}
-			UIUtilities.acquireKeepScreenOn(getWindow());
-		}
-
-		@Override
-		public void pause() {
-			mIsLoading = false;
-			if (mPlaybackPauseTime < 0) { // save the time paused, but don't overwrite if we call pause multiple times
-				mPlaybackPauseTime = System.currentTimeMillis();
-			}
-			if (mMediaPlayer != null) {
-				mMediaPlayer.setOnCompletionListener(null); // make sure we don't continue accidentally
-				mMediaPlayer.pause();
-			}
-			if (mSoundPool != null) {
-				mSoundPool.autoPause(); // TODO: check this works
-			}
-			showMediaController(-1); // to keep on showing until done here
-			UIUtilities.releaseKeepScreenOn(getWindow());
-		}
-
-		@Override
-		public int getDuration() {
-			return mNarrativeDuration;
-		}
-
-		@Override
-		public int getCurrentPosition() {
-			if (mPlaybackPosition < 0) {
-				return mNarrativeDuration;
-			} else {
-				int rootPlaybackPosition = mPlaybackPosition + mNonAudioOffset;
-				if (mSilenceFilePlaying) {
-					// must calculate the actual time at the point of pausing, rather than the current time
-					if (mPlaybackPauseTime > 0) {
-						rootPlaybackPosition += (int) (mPlaybackPauseTime - mPlaybackStartTime);
-					} else {
-						rootPlaybackPosition += (int) (System.currentTimeMillis() - mPlaybackStartTime);
-					}
-				} else {
-					rootPlaybackPosition += (mMediaPlayer != null ? mMediaPlayer.getCurrentPosition() : 0);
-				}
-				return rootPlaybackPosition;
-			}
-		}
-
-		@Override
-		public void seekTo(int pos) {
-			int actualPos = pos - mPlaybackPosition;
-			if (mPlaybackPosition < 0) { // so we allow seeking from the end
-				mPlaybackPosition = mNarrativeDuration - mCurrentFrameContainer.mFrameMaxDuration;
-			}
-			mPlaybackPauseTime = -1; // we'll be playing after this call
-			if (actualPos >= 0 && actualPos < mCurrentFrameContainer.mFrameMaxDuration) {
-				if (mIsLoading
-						|| (actualPos < mMediaPlayer.getDuration() && mCurrentFrameContainer.mAudioPaths.size() > 0)) {
-					if (!mIsLoading) {
-						if (mMediaController.isDragging()) {
-							mMediaPlayer.setOnCompletionListener(mMediaPlayerCompletionListener);
-						}
-						mPlaybackStartTime = System.currentTimeMillis() - actualPos;
-						mMediaPlayer.seekTo(actualPos); // TODO: seek others (is it even possible with soundpool?)
-						if (!mMediaPlayer.isPlaying()) { // we started from the end
-							mMediaPlayer.start();
-							UIUtilities.acquireKeepScreenOn(getWindow());
-						}
-					} else {
-						// still loading - come here so we don't reload the same item again
-					}
-				} else {
-					// for image- or text-only frames
-					mNonAudioOffset = actualPos;
-					if (mMediaController.isDragging()) {
-						mMediaPlayer.setOnCompletionListener(mMediaPlayerCompletionListener);
-					}
-					mPlaybackStartTime = System.currentTimeMillis();
-					mMediaPlayer.seekTo(0); // TODO: seek others (is it even possible with soundpool?)
-					mMediaPlayer.start();
-					mMediaController.setProgress();
-				}
-			} else if (pos >= 0 && pos < mNarrativeDuration) {
-				FrameMediaContainer newContainer = getMediaContainer(pos, true);
-				if (newContainer != mCurrentFrameContainer) {
-					mCurrentFrameContainer = newContainer;
-					prepareMediaItems(mCurrentFrameContainer);
-					mInitialPlaybackOffset = pos - mPlaybackPosition;
-				} else {
-					mIsLoading = false;
-				}
-			}
-		}
-
-		@Override
-		public boolean isPlaying() {
-			return mMediaPlayer == null ? false : mMediaPlayer.isPlaying();
-		}
-
-		@Override
-		public boolean isLoading() {
-			return mIsLoading;
-		}
-
-		@Override
-		public int getBufferPercentage() {
-			return 0;
-		}
-
-		@Override
-		public boolean canPause() {
-			return true;
-		}
-
-		@Override
-		public boolean canSeekBackward() {
-			return true;
-		}
-
-		@Override
-		public boolean canSeekForward() {
-			return true;
-		}
-
-		@Override
-		public void onControllerVisibilityChange(boolean visible) {
-			makeMediaItemsVisible(visible);
-			if (visible) {
-				UIUtilities.setNonFullScreen(getWindow());
-			} else {
-				UIUtilities.setFullScreen(getWindow());
-			}
-		}
-	};
-
-	private class TouchCallbackCustomMediaController extends CustomMediaController {
-		private TouchCallbackCustomMediaController(Context context) {
-			super(context);
-		}
-
-		@Override
-		public boolean onInterceptTouchEvent(MotionEvent event) {
-			switch (event.getAction()) {
-				case MotionEvent.ACTION_DOWN:
-					UIUtilities.setNonFullScreen(getWindow()); // so we don't have to wait for the playback bar to hide
-																// before showing the notification bar
-					break;
-			}
-			return false;
-		}
-	}
-
-	private void startPlayers() {
-		// so that we don't start playing after pause if we were loading
-		if (mIsLoading) {
-			for (Integer soundId : mFrameSounds) {
-				mSoundPool.play(soundId, 1, 1, 1, 0, 1f); // volume is % of *current*, rather than maximum
-				// TODO: seek to mInitialPlaybackOffset
-			}
-
-			mMediaPlayer.setOnCompletionListener(mMediaPlayerCompletionListener);
-			mPlaybackStartTime = System.currentTimeMillis() - mInitialPlaybackOffset;
-			mMediaPlayer.seekTo(mInitialPlaybackOffset);
-			mMediaPlayer.start();
-
-			mIsLoading = false;
-			mMediaController.setMediaPlayer(mMediaPlayerController);
-
-			UIUtilities.acquireKeepScreenOn(getWindow());
-		}
-	}
-
-	private SoundPool.OnLoadCompleteListener mSoundPoolLoadListener = new SoundPool.OnLoadCompleteListener() {
-		@Override
-		public void onLoadComplete(SoundPool soundPool, int sampleId, int status) {
-			mFrameSounds.add(sampleId);
-			if (mFrameSounds.size() >= mNumExtraSounds) {
-				mSoundPoolPrepared = true;
-			}
-			if (mSoundPoolPrepared && mMediaPlayerPrepared) {
-				startPlayers();
-			}
-		}
-	};
-
-	private OnPreparedListener mMediaPlayerPreparedListener = new OnPreparedListener() {
-		@Override
-		public void onPrepared(MediaPlayer mp) {
-			mMediaPlayerPrepared = true;
-			if (mSoundPoolPrepared) {
-				startPlayers();
-			}
-		}
-	};
-
-	private OnCompletionListener mMediaPlayerCompletionListener = new OnCompletionListener() {
-		@Override
-		public void onCompletion(MediaPlayer mp) {
-			if (mMediaPlayerError) {
-				// releasePlayer(); // don't do this, as it means the player will be null; instead we resume from errors
-				mCurrentFrameContainer = getMediaContainer(mPlaybackPosition, false);
-				prepareMediaItems(mCurrentFrameContainer);
-				mMediaPlayerError = false;
-				return;
-			}
-			mInitialPlaybackOffset = 0;
-			int currentPosition = mMediaPlayerController.getCurrentPosition()
-					+ (mMediaPlayer.getDuration() - mMediaPlayer.getCurrentPosition()) + 1;
-			if (currentPosition < mNarrativeDuration) {
-				mMediaPlayerController.seekTo(currentPosition);
-			} else if (!mMediaController.isDragging()) {
-				// move to just before the end (accounting for mNarrativeDuration errors)
-				mMediaPlayerController.seekTo(currentPosition - 2);
-				pauseMediaController(); // will also show the controller if applicable
-				mPlaybackPosition = -1; // so we start from the beginning
-			}
-		}
-	};
-
-	private OnErrorListener mMediaPlayerErrorListener = new OnErrorListener() {
-		@Override
-		public boolean onError(MediaPlayer mp, int what, int extra) {
-			mMediaPlayerError = true;
-			// UIUtilities.showToast(NarrativePlayerActivity.this, R.string.error_loading_narrative_player);
-			if (MediaPhone.DEBUG)
-				Log.d(DebugUtilities.getLogTag(this), "Playback error - what: " + what + ", extra: " + extra);
-			return false; // not handled -> onCompletionListener will be called
-		}
-	};
-}
diff --git a/src/ac/robinson/mediaphone/provider/MediaManager.java b/src/ac/robinson/mediaphone/provider/MediaManager.java
deleted file mode 100644
index 60a5f0a..0000000
--- a/src/ac/robinson/mediaphone/provider/MediaManager.java
+++ /dev/null
@@ -1,196 +0,0 @@
-/*
- *  Copyright (C) 2012 Simon Robinson
- * 
- *  This file is part of Com-Me.
- * 
- *  Com-Me is free software; you can redistribute it and/or modify it 
- *  under the terms of the GNU Lesser General Public License as 
- *  published by the Free Software Foundation; either version 3 of the 
- *  License, or (at your option) any later version.
- *
- *  Com-Me is distributed in the hope that it will be useful, but WITHOUT 
- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
- *  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General 
- *  Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with Com-Me.
- *  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package ac.robinson.mediaphone.provider;
-
-import java.util.ArrayList;
-
-import android.content.ContentResolver;
-import android.content.ContentValues;
-import android.database.Cursor;
-import android.net.Uri;
-
-public class MediaManager {
-
-	private static String[] mArguments1 = new String[1];
-
-	private static String mMediaInternalIdSelection;
-	private static String mMediaParentIdSelection;
-	private static String mDeletedSelection;
-	static {
-		StringBuilder selection = new StringBuilder();
-		selection.append(MediaItem.INTERNAL_ID);
-		selection.append("=?");
-		mMediaInternalIdSelection = selection.toString();
-
-		selection.setLength(0); // clears
-		selection.append("(");
-		selection.append(MediaItem.DELETED);
-		selection.append("=0 AND ");
-		selection.append(MediaItem.PARENT_ID);
-		selection.append("=?");
-		selection.append(")");
-		mMediaParentIdSelection = selection.toString();
-
-		selection.setLength(0);
-		selection.append(MediaItem.DELETED);
-		selection.append("!=0");
-		mDeletedSelection = selection.toString();
-	}
-
-	public static MediaItem addMedia(ContentResolver contentResolver, MediaItem media) {
-		final Uri uri = contentResolver.insert(MediaItem.CONTENT_URI, media.getContentValues());
-		if (uri != null) {
-			return media;
-		}
-		return null;
-	}
-
-	/**
-	 * Note: to delete a media item, do setDeleted the item itself and then update to the database. On the next
-	 * application launch, the media file will be deleted and the database entry will be cleaned up. This approach is
-	 * used to speed up interaction and so that we only need to run one background thread semi-regularly for deletion
-	 */
-	public static boolean deleteMediaFromBackgroundTask(ContentResolver contentResolver, String internalId) {
-		final String[] arguments1 = mArguments1;
-		arguments1[0] = internalId;
-		int count = contentResolver.delete(MediaItem.CONTENT_URI, mMediaInternalIdSelection, arguments1);
-		return count > 0;
-	}
-
-	public static boolean updateMedia(ContentResolver contentResolver, MediaItem media) {
-		final String[] arguments1 = mArguments1;
-		arguments1[0] = media.getInternalId();
-		int count = contentResolver.update(MediaItem.CONTENT_URI, media.getContentValues(), mMediaInternalIdSelection,
-				arguments1);
-		return count == 1;
-	}
-
-	public static boolean changeMediaId(ContentResolver contentResolver, String oldMediaItemInternalId,
-			String newMediaItemInternalId) {
-		final String[] arguments1 = mArguments1;
-		arguments1[0] = oldMediaItemInternalId;
-		final ContentValues contentValues = new ContentValues();
-		contentValues.put(MediaItem.INTERNAL_ID, newMediaItemInternalId);
-		int count = contentResolver.update(MediaItem.CONTENT_URI, contentValues, mMediaInternalIdSelection, arguments1);
-		return count == 1;
-	}
-
-	public static MediaItem findMediaByInternalId(ContentResolver contentResolver, String internalId) {
-		final String[] arguments1 = mArguments1;
-		arguments1[0] = internalId;
-		return findMedia(contentResolver, mMediaInternalIdSelection, arguments1);
-	}
-
-	private static MediaItem findMedia(ContentResolver contentResolver, String clause, String[] arguments) {
-		Cursor c = null;
-		try {
-			// could add sort order here, but we assume no duplicates...
-			c = contentResolver.query(MediaItem.CONTENT_URI, MediaItem.PROJECTION_ALL, clause, arguments,
-					MediaItem.DEFAULT_SORT_ORDER);
-			if (c.moveToFirst()) {
-				final MediaItem media = MediaItem.fromCursor(c);
-				return media;
-			}
-		} finally {
-			if (c != null) {
-				c.close();
-			}
-		}
-		return null;
-	}
-
-	public static ArrayList<MediaItem> findMediaByParentId(ContentResolver contentResolver, String parentId) {
-		final String[] arguments1 = mArguments1;
-		arguments1[0] = parentId;
-		final ArrayList<MediaItem> medias = new ArrayList<MediaItem>();
-		Cursor c = null;
-		try {
-			c = contentResolver.query(MediaItem.CONTENT_URI, MediaItem.PROJECTION_ALL, mMediaParentIdSelection,
-					arguments1, MediaItem.DEFAULT_SORT_ORDER);
-			if (c.getCount() > 0) {
-				while (c.moveToNext()) {
-					final MediaItem media = MediaItem.fromCursor(c);
-					medias.add(media);
-				}
-			}
-		} finally {
-			if (c != null) {
-				c.close();
-			}
-		}
-		return medias;
-	}
-
-	public static ArrayList<String> findMediaIdsByParentId(ContentResolver contentResolver, String parentId) {
-		final String[] arguments;
-		arguments = mArguments1;
-		arguments[0] = parentId;
-		final ArrayList<String> mediaIds = new ArrayList<String>();
-		Cursor c = null;
-		try {
-			c = contentResolver.query(MediaItem.CONTENT_URI, MediaItem.PROJECTION_INTERNAL_ID, mMediaParentIdSelection,
-					arguments, null);
-			if (c.getCount() > 0) {
-				final int columnIndex = c.getColumnIndexOrThrow(MediaItem.INTERNAL_ID);
-				while (c.moveToNext()) {
-					final String index = c.getString(columnIndex);
-					mediaIds.add(index);
-				}
-			}
-		} finally {
-			if (c != null) {
-				c.close();
-			}
-		}
-
-		return mediaIds;
-	}
-
-	public static int countMediaByParentId(ContentResolver contentResolver, String parentId) {
-		final String[] arguments1 = mArguments1;
-		arguments1[0] = parentId;
-		Cursor c = contentResolver.query(MediaItem.CONTENT_URI, MediaItem.PROJECTION_INTERNAL_ID,
-				mMediaParentIdSelection, arguments1, MediaItem.DEFAULT_SORT_ORDER);
-		final int count = c.getCount();
-		c.close();
-		return count;
-	}
-
-	public static ArrayList<String> findDeletedMedia(ContentResolver contentResolver) {
-		final ArrayList<String> mediaIds = new ArrayList<String>();
-		Cursor c = null;
-		try {
-			c = contentResolver.query(MediaItem.CONTENT_URI, MediaItem.PROJECTION_INTERNAL_ID, mDeletedSelection, null,
-					null);
-			if (c.getCount() > 0) {
-				final int columnIndex = c.getColumnIndexOrThrow(MediaItem.INTERNAL_ID);
-				while (c.moveToNext()) {
-					mediaIds.add(c.getString(columnIndex));
-				}
-			}
-		} finally {
-			if (c != null) {
-				c.close();
-			}
-		}
-		return mediaIds;
-	}
-}
diff --git a/src/ac/robinson/mediaphone/provider/NarrativeItem.java b/src/ac/robinson/mediaphone/provider/NarrativeItem.java
deleted file mode 100644
index 3419915..0000000
--- a/src/ac/robinson/mediaphone/provider/NarrativeItem.java
+++ /dev/null
@@ -1,188 +0,0 @@
-/*
- *  Copyright (C) 2012 Simon Robinson
- * 
- *  This file is part of Com-Me.
- * 
- *  Com-Me is free software; you can redistribute it and/or modify it 
- *  under the terms of the GNU Lesser General Public License as 
- *  published by the Free Software Foundation; either version 3 of the 
- *  License, or (at your option) any later version.
- *
- *  Com-Me is distributed in the hope that it will be useful, but WITHOUT 
- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
- *  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General 
- *  Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with Com-Me.
- *  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package ac.robinson.mediaphone.provider;
-
-import java.util.ArrayList;
-
-import ac.robinson.mediaphone.MediaPhone;
-import ac.robinson.mediautilities.FrameMediaContainer;
-import ac.robinson.util.IOUtilities;
-import android.content.ContentResolver;
-import android.content.ContentValues;
-import android.database.Cursor;
-import android.net.Uri;
-import android.provider.BaseColumns;
-import android.text.TextUtils;
-
-public class NarrativeItem implements BaseColumns {
-
-	public static final Uri NARRATIVE_CONTENT_URI = Uri.parse(MediaPhoneProvider.URI_PREFIX
-			+ MediaPhoneProvider.URI_AUTHORITY + MediaPhoneProvider.URI_SEPARATOR
-			+ MediaPhoneProvider.NARRATIVES_LOCATION);
-
-	public static final Uri TEMPLATE_CONTENT_URI = Uri.parse(MediaPhoneProvider.URI_PREFIX
-			+ MediaPhoneProvider.URI_AUTHORITY + MediaPhoneProvider.URI_SEPARATOR
-			+ MediaPhoneProvider.TEMPLATES_LOCATION);
-
-	public static final String[] PROJECTION_ALL = new String[] { NarrativeItem._ID, NarrativeItem.INTERNAL_ID,
-			NarrativeItem.DATE_CREATED, NarrativeItem.SEQUENCE_ID, NarrativeItem.DELETED };
-
-	public static final String[] PROJECTION_INTERNAL_ID = new String[] { NarrativeItem.INTERNAL_ID };
-
-	public static final String MAX_ID = "max_id";
-	public static final String[] PROJECTION_NEXT_EXTERNAL_ID = new String[] { "MAX(" + NarrativeItem.SEQUENCE_ID
-			+ ") as " + MAX_ID };
-
-	// for keeping track of the helper narrative (so we don't add multiple copies later)
-	public static final String HELPER_NARRATIVE_ID = "936df7b0-72b9-11e2-bcfd-0800200c9a66"; // *DO NOT CHANGE*
-
-	public static final String INTERNAL_ID = "internal_id";
-	public static final String DATE_CREATED = "date_created";
-	public static final String SEQUENCE_ID = "sequence_id";
-	public static final String DELETED = "deleted";
-
-	public static final String SELECTION_NOT_DELETED = DELETED + "=0";
-
-	public static final String DEFAULT_SORT_ORDER = DATE_CREATED + " DESC";
-
-	private String mInternalId;
-	private long mCreationDate;
-	private int mSequenceId;
-	private int mDeleted;
-
-	public NarrativeItem(String internalId, int externalId) {
-		mInternalId = internalId;
-		mCreationDate = System.currentTimeMillis();
-		mSequenceId = externalId;
-		mDeleted = 0;
-	}
-
-	public NarrativeItem(int externalId) {
-		this(MediaPhoneProvider.getNewInternalId(), externalId);
-	}
-
-	public NarrativeItem() {
-		this(0);
-	}
-
-	public String getInternalId() {
-		return mInternalId;
-	}
-
-	public long getCreationDate() {
-		return mCreationDate;
-	}
-
-	public int getSequenceId() {
-		return mSequenceId;
-	}
-
-	public void setSequenceId(int sequenceId) {
-		mSequenceId = sequenceId;
-	}
-
-	public boolean getDeleted() {
-		return mDeleted == 0 ? false : true;
-	}
-
-	public void setDeleted(boolean deleted) {
-		mDeleted = deleted ? 1 : 0;
-	}
-
-	public ArrayList<FrameMediaContainer> getContentList(ContentResolver contentResolver) {
-
-		ArrayList<FrameMediaContainer> exportedContent = new ArrayList<FrameMediaContainer>();
-
-		ArrayList<FrameItem> narrativeFrames = FramesManager.findFramesByParentId(contentResolver, mInternalId);
-		for (FrameItem frame : narrativeFrames) {
-
-			ArrayList<MediaItem> frameComponents = MediaManager.findMediaByParentId(contentResolver,
-					frame.getInternalId());
-
-			final FrameMediaContainer currentContainer = new FrameMediaContainer(frame.getInternalId(),
-					frame.getNarrativeSequenceId());
-
-			currentContainer.mParentId = frame.getParentId();
-
-			for (MediaItem media : frameComponents) {
-
-				switch (media.getType()) {
-					case MediaPhoneProvider.TYPE_IMAGE_FRONT:
-						currentContainer.mImageIsFrontCamera = true;
-					case MediaPhoneProvider.TYPE_IMAGE_BACK:
-					case MediaPhoneProvider.TYPE_VIDEO:
-						currentContainer.mImagePath = media.getFile().getAbsolutePath();
-						break;
-
-					case MediaPhoneProvider.TYPE_TEXT:
-						currentContainer.mTextContent = IOUtilities.getFileContents(media.getFile().getAbsolutePath());
-						if (!TextUtils.isEmpty(currentContainer.mTextContent)) {
-							currentContainer.updateFrameMaxDuration(MediaItem
-									.getTextDurationMilliseconds(currentContainer.mTextContent));
-						} else {
-							currentContainer.mTextContent = null;
-						}
-						break;
-
-					case MediaPhoneProvider.TYPE_AUDIO:
-						currentContainer.addAudioFile(media.getFile().getAbsolutePath(),
-								media.getDurationMilliseconds());
-						break;
-				}
-
-				currentContainer.updateFrameMaxDuration(media.getDurationMilliseconds());
-			}
-
-			// don't allow frames to be shorter than the minimum duration
-			if (currentContainer.mFrameMaxDuration <= 0) {
-				currentContainer.updateFrameMaxDuration(MediaPhone.PLAYBACK_EXPORT_MINIMUM_FRAME_DURATION);
-			}
-
-			exportedContent.add(currentContainer);
-		}
-
-		return exportedContent;
-	}
-
-	public ContentValues getContentValues() {
-		final ContentValues values = new ContentValues();
-		values.put(INTERNAL_ID, mInternalId);
-		values.put(DATE_CREATED, mCreationDate);
-		values.put(SEQUENCE_ID, mSequenceId);
-		values.put(DELETED, mDeleted);
-		return values;
-	}
-
-	public static NarrativeItem fromCursor(Cursor c) {
-		final NarrativeItem narrative = new NarrativeItem();
-		narrative.mInternalId = c.getString(c.getColumnIndexOrThrow(INTERNAL_ID));
-		narrative.mCreationDate = c.getLong(c.getColumnIndexOrThrow(DATE_CREATED));
-		narrative.mSequenceId = c.getInt(c.getColumnIndexOrThrow(SEQUENCE_ID));
-		narrative.mDeleted = c.getInt(c.getColumnIndexOrThrow(DELETED));
-		return narrative;
-	}
-
-	@Override
-	public String toString() {
-		return this.getClass().getName() + "[" + mInternalId + "," + mCreationDate + "," + mSequenceId + "," + mDeleted
-				+ "]";
-	}
-}
