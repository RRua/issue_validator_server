diff --git a/app/src/main/java/com/amaze/filemanager/activities/MainActivity.java b/app/src/main/java/com/amaze/filemanager/activities/MainActivity.java
index 21488312b..0fb3c92a8 100644
--- a/app/src/main/java/com/amaze/filemanager/activities/MainActivity.java
+++ b/app/src/main/java/com/amaze/filemanager/activities/MainActivity.java
@@ -45,23 +45,6 @@ import android.os.Environment;
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.service.quicksettings.TileService;
-import androidx.annotation.ColorInt;
-import androidx.annotation.DrawableRes;
-import androidx.annotation.IdRes;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.annotation.RequiresApi;
-import com.google.android.material.appbar.AppBarLayout;
-import com.google.android.material.bottomsheet.BottomSheetDialogFragment;
-import com.google.android.material.floatingactionbutton.FloatingActionButton;
-import com.google.android.material.snackbar.Snackbar;
-
-import androidx.annotation.StringRes;
-import androidx.fragment.app.Fragment;
-import androidx.fragment.app.FragmentTransaction;
-import androidx.loader.app.LoaderManager;
-import androidx.loader.content.CursorLoader;
-import androidx.loader.content.Loader;
 import android.text.TextUtils;
 import android.view.KeyEvent;
 import android.view.Menu;
@@ -75,6 +58,19 @@ import android.view.animation.DecelerateInterpolator;
 import android.widget.FrameLayout;
 import android.widget.Toast;
 
+import androidx.annotation.ColorInt;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.IdRes;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RequiresApi;
+import androidx.annotation.StringRes;
+import androidx.fragment.app.Fragment;
+import androidx.fragment.app.FragmentTransaction;
+import androidx.loader.app.LoaderManager;
+import androidx.loader.content.CursorLoader;
+import androidx.loader.content.Loader;
+
 import com.afollestad.materialdialogs.DialogAction;
 import com.afollestad.materialdialogs.MaterialDialog;
 import com.amaze.filemanager.R;
@@ -83,24 +79,24 @@ import com.amaze.filemanager.asynchronous.asynctasks.CloudLoaderAsyncTask;
 import com.amaze.filemanager.asynchronous.asynctasks.DeleteTask;
 import com.amaze.filemanager.asynchronous.asynctasks.MoveFiles;
 import com.amaze.filemanager.asynchronous.asynctasks.PrepareCopyTask;
+import com.amaze.filemanager.asynchronous.management.ServiceWatcherUtil;
 import com.amaze.filemanager.asynchronous.services.CopyService;
 import com.amaze.filemanager.database.CloudContract;
 import com.amaze.filemanager.database.CloudHandler;
-import com.amaze.filemanager.database.CryptHandler;
+import com.amaze.filemanager.database.ExplorerDatabase;
 import com.amaze.filemanager.database.TabHandler;
 import com.amaze.filemanager.database.UtilsHandler;
-import com.amaze.filemanager.database.models.CloudEntry;
+import com.amaze.filemanager.database.models.explorer.CloudEntry;
 import com.amaze.filemanager.database.models.OperationData;
-import com.amaze.filemanager.database.models.Tab;
+import com.amaze.filemanager.database.models.explorer.Tab;
 import com.amaze.filemanager.exceptions.CloudPluginException;
 import com.amaze.filemanager.filesystem.FileUtil;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.PasteHelper;
 import com.amaze.filemanager.filesystem.RootHelper;
-import com.amaze.filemanager.filesystem.usb.SingletonUsbOtg;
-import com.amaze.filemanager.filesystem.ssh.CustomSshJConfig;
 import com.amaze.filemanager.filesystem.ssh.SshConnectionPool;
+import com.amaze.filemanager.filesystem.usb.SingletonUsbOtg;
 import com.amaze.filemanager.filesystem.usb.UsbOtgRepresentation;
 import com.amaze.filemanager.fragments.AppsListFragment;
 import com.amaze.filemanager.fragments.CloudSheetFragment;
@@ -128,12 +124,14 @@ import com.amaze.filemanager.utils.MainActivityHelper;
 import com.amaze.filemanager.utils.OTGUtil;
 import com.amaze.filemanager.utils.OpenMode;
 import com.amaze.filemanager.utils.PreferenceUtils;
-import com.amaze.filemanager.asynchronous.management.ServiceWatcherUtil;
 import com.amaze.filemanager.utils.Utils;
 import com.amaze.filemanager.utils.application.AppConfig;
 import com.amaze.filemanager.utils.files.FileUtils;
 import com.amaze.filemanager.utils.theme.AppTheme;
 import com.cloudrail.si.CloudRail;
+import com.google.android.material.appbar.AppBarLayout;
+import com.google.android.material.bottomsheet.BottomSheetDialogFragment;
+import com.google.android.material.snackbar.Snackbar;
 import com.leinardi.android.speeddial.SpeedDialActionItem;
 import com.leinardi.android.speeddial.SpeedDialOverlayLayout;
 import com.leinardi.android.speeddial.SpeedDialView;
@@ -283,7 +281,7 @@ public class MainActivity extends PermissionsActivity implements SmbConnectionLi
 
         dataUtils.registerOnDataChangedListener(this);
 
-        CustomSshJConfig.init();
+
         AppConfig.getInstance().setMainActivityContext(this);
 
         setContentView(R.layout.main_toolbar);
@@ -293,7 +291,7 @@ public class MainActivity extends PermissionsActivity implements SmbConnectionLi
             }
         });
         initialiseViews();
-        tabHandler = new TabHandler(this);
+        tabHandler = new TabHandler();
         utilsHandler = AppConfig.getInstance().getUtilsHandler();
         cloudHandler = new CloudHandler(this);
 
@@ -1207,13 +1205,8 @@ public class MainActivity extends PermissionsActivity implements SmbConnectionLi
         // TODO: https://developer.android.com/reference/android/app/Activity.html#onDestroy%28%29
         closeInteractiveShell();
 
-        tabHandler.close();
-        utilsHandler.close();
-        cloudHandler.close();
+        ExplorerDatabase.getInstance().close();
 
-        CryptHandler cryptHandler = new CryptHandler(this);
-        cryptHandler.close();
-        
         SshConnectionPool.getInstance().expungeAllConnections();
     }
 
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/CloudLoaderAsyncTask.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/CloudLoaderAsyncTask.java
index 53c6cd2b9..a139ac58d 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/CloudLoaderAsyncTask.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/CloudLoaderAsyncTask.java
@@ -8,7 +8,7 @@ import android.widget.Toast;
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.MainActivity;
 import com.amaze.filemanager.database.CloudHandler;
-import com.amaze.filemanager.database.models.CloudEntry;
+import com.amaze.filemanager.database.models.explorer.CloudEntry;
 import com.amaze.filemanager.exceptions.CloudPluginException;
 import com.amaze.filemanager.utils.DataUtils;
 import com.amaze.filemanager.utils.OpenMode;
@@ -89,7 +89,7 @@ public class CloudLoaderAsyncTask extends AsyncTask<Void, Void, Boolean> {
                                 // we already have the entry and saved state, get it
 
                                 try {
-                                    cloudStorageDrive.loadAsString(savedCloudEntryGdrive.getPersistData());
+                                    cloudStorageDrive.loadAsString(savedCloudEntryGdrive.getPersistData().value);
                                 } catch (ParseException e) {
                                     e.printStackTrace();
                                     // we need to update the persist string as existing one is been compromised
@@ -157,7 +157,7 @@ public class CloudLoaderAsyncTask extends AsyncTask<Void, Void, Boolean> {
                             if ((savedCloudEntryDropbox = cloudHandler.findEntry(OpenMode.DROPBOX)) != null) {
                                 // we already have the entry and saved state, get it
                                 try {
-                                    cloudStorageDropbox.loadAsString(savedCloudEntryDropbox.getPersistData());
+                                    cloudStorageDropbox.loadAsString(savedCloudEntryDropbox.getPersistData().value);
                                 } catch (ParseException e) {
                                     e.printStackTrace();
                                     // we need to persist data again
@@ -221,7 +221,7 @@ public class CloudLoaderAsyncTask extends AsyncTask<Void, Void, Boolean> {
                             if ((savedCloudEntryBox = cloudHandler.findEntry(OpenMode.BOX)) != null) {
                                 // we already have the entry and saved state, get it
                                 try {
-                                    cloudStorageBox.loadAsString(savedCloudEntryBox.getPersistData());
+                                    cloudStorageBox.loadAsString(savedCloudEntryBox.getPersistData().value);
                                 } catch (ParseException e) {
                                     e.printStackTrace();
                                     // we need to persist data again
@@ -282,7 +282,7 @@ public class CloudLoaderAsyncTask extends AsyncTask<Void, Void, Boolean> {
                             if ((savedCloudEntryOnedrive = cloudHandler.findEntry(OpenMode.ONEDRIVE)) != null) {
                                 // we already have the entry and saved state, get it
                                 try {
-                                    cloudStorageOnedrive.loadAsString(savedCloudEntryOnedrive.getPersistData());
+                                    cloudStorageOnedrive.loadAsString(savedCloudEntryOnedrive.getPersistData().value);
                                 } catch (ParseException e) {
                                     e.printStackTrace();
                                     // we need to persist data again
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/DeleteTask.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/DeleteTask.java
index 0b4cf3b62..6e0ddada5 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/DeleteTask.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/DeleteTask.java
@@ -160,7 +160,7 @@ public class DeleteTask extends AsyncTask<ArrayList<HybridFileParcelable>, Strin
         // delete file entry from encrypted database
         for (HybridFileParcelable file : files) {
             if (file.getName().endsWith(CryptUtil.CRYPT_EXTENSION)) {
-                CryptHandler handler = new CryptHandler(cd);
+                CryptHandler handler = new CryptHandler();
                 handler.clear(file.getPath());
             }
         }
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/MoveFiles.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/MoveFiles.java
index b23bc837c..1fa69b3a2 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/MoveFiles.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/MoveFiles.java
@@ -27,7 +27,7 @@ import android.widget.Toast;
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.MainActivity;
 import com.amaze.filemanager.database.CryptHandler;
-import com.amaze.filemanager.database.models.EncryptedEntry;
+import com.amaze.filemanager.database.models.explorer.EncryptedEntry;
 import com.amaze.filemanager.exceptions.ShellNotRunningException;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
@@ -182,7 +182,7 @@ public class MoveFiles extends AsyncTask<ArrayList<String>, String, Boolean> {
                         if (file.getName().endsWith(CryptUtil.CRYPT_EXTENSION)) {
                             try {
 
-                                CryptHandler cryptHandler = new CryptHandler(context);
+                                CryptHandler cryptHandler = new CryptHandler();
                                 EncryptedEntry oldEntry = cryptHandler.findEntry(file.getPath());
                                 EncryptedEntry newEntry = new EncryptedEntry();
                                 newEntry.setId(oldEntry.getId());
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/services/CopyService.java b/app/src/main/java/com/amaze/filemanager/asynchronous/services/CopyService.java
index f0b52e922..3bfe61278 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/services/CopyService.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/services/CopyService.java
@@ -41,7 +41,7 @@ import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.MainActivity;
 import com.amaze.filemanager.asynchronous.asynctasks.DeleteTask;
 import com.amaze.filemanager.database.CryptHandler;
-import com.amaze.filemanager.database.models.EncryptedEntry;
+import com.amaze.filemanager.database.models.explorer.EncryptedEntry;
 import com.amaze.filemanager.exceptions.ShellNotRunningException;
 import com.amaze.filemanager.filesystem.FileUtil;
 import com.amaze.filemanager.filesystem.HybridFile;
@@ -306,7 +306,7 @@ public class CopyService extends AbstractProgressiveService {
                 if (sourceFile.getName().endsWith(CryptUtil.CRYPT_EXTENSION)) {
                     try {
 
-                        CryptHandler cryptHandler = new CryptHandler(getApplicationContext());
+                        CryptHandler cryptHandler = new CryptHandler();
                         EncryptedEntry oldEntry = cryptHandler.findEntry(sourceFile.getPath());
                         EncryptedEntry newEntry = new EncryptedEntry();
 
diff --git a/app/src/main/java/com/amaze/filemanager/database/CloudHandler.java b/app/src/main/java/com/amaze/filemanager/database/CloudHandler.java
index 164d7c15d..4ebe41736 100644
--- a/app/src/main/java/com/amaze/filemanager/database/CloudHandler.java
+++ b/app/src/main/java/com/amaze/filemanager/database/CloudHandler.java
@@ -1,31 +1,21 @@
 package com.amaze.filemanager.database;
 
-import android.content.ContentValues;
 import android.content.Context;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
 
-import com.amaze.filemanager.database.models.CloudEntry;
+import androidx.annotation.NonNull;
+
+import com.amaze.filemanager.database.models.explorer.CloudEntry;
 import com.amaze.filemanager.exceptions.CloudPluginException;
 import com.amaze.filemanager.fragments.CloudSheetFragment;
-import com.amaze.filemanager.utils.files.CryptUtil;
 import com.amaze.filemanager.utils.OpenMode;
 
-import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 
 /**
  * Created by vishal on 18/4/17.
  */
-
-public class CloudHandler extends SQLiteOpenHelper {
-
-    protected static final String TABLE_CLOUD_PERSIST = "cloud";
-
-    protected static final String COLUMN_CLOUD_ID = "_id";
-    protected static final String COLUMN_CLOUD_SERVICE = "service";
-    protected static final String COLUMN_CLOUD_PERSIST = "persist";
+public class CloudHandler {
 
     public static final String CLOUD_PREFIX_BOX = "box:/";
     public static final String CLOUD_PREFIX_DROPBOX = "dropbox:/";
@@ -37,47 +27,12 @@ public class CloudHandler extends SQLiteOpenHelper {
     public static final String CLOUD_NAME_ONE_DRIVE = "One Drive";
     public static final String CLOUD_NAME_BOX = "Box";
 
+    private final ExplorerDatabase database;
+    private final Context context;
 
-    private Context context;
-
-    public CloudHandler(Context context) {
-        super(context, TabHandler.DATABASE_NAME, null, TabHandler.DATABASE_VERSION);
+    public CloudHandler(@NonNull Context context) {
         this.context = context;
-    }
-
-    @Override
-    public void onCreate(SQLiteDatabase db) {
-
-        String CREATE_TAB_TABLE = "CREATE TABLE " + TabHandler.TABLE_TAB + "("
-                + TabHandler.COLUMN_TAB_NO + " INTEGER PRIMARY KEY,"
-                + TabHandler.COLUMN_PATH + " TEXT,"
-                + TabHandler.COLUMN_HOME + " TEXT" +
-                ")";
-
-        String CREATE_TABLE_ENCRYPTED = "CREATE TABLE " + TabHandler.TABLE_ENCRYPTED + "("
-                + TabHandler.COLUMN_ENCRYPTED_ID + " INTEGER PRIMARY KEY,"
-                + TabHandler.COLUMN_ENCRYPTED_PATH + " TEXT,"
-                + TabHandler.COLUMN_ENCRYPTED_PASSWORD + " TEXT"
-                + ")";
-
-        String CREATE_TABLE_CLOUD = "CREATE TABLE " + CloudHandler.TABLE_CLOUD_PERSIST + "("
-                + CloudHandler.COLUMN_CLOUD_ID
-                + " INTEGER PRIMARY KEY,"
-                + CloudHandler.COLUMN_CLOUD_SERVICE + " INTEGER,"
-                + CloudHandler.COLUMN_CLOUD_PERSIST + " TEXT" + ")";
-
-        db.execSQL(CREATE_TAB_TABLE);
-        db.execSQL(CREATE_TABLE_ENCRYPTED);
-        db.execSQL(CREATE_TABLE_CLOUD);
-    }
-
-    @Override
-    public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {
-
-        sqLiteDatabase.execSQL("DROP TABLE IF EXISTS " + TabHandler.TABLE_TAB);
-        sqLiteDatabase.execSQL("DROP TABLE IF EXISTS " + TabHandler.TABLE_ENCRYPTED);
-        sqLiteDatabase.execSQL("DROP TABLE IF EXISTS " + CloudHandler.TABLE_CLOUD_PERSIST);
-        onCreate(sqLiteDatabase);
+        this.database = ExplorerDatabase.getInstance();
     }
 
     public void addEntry(CloudEntry cloudEntry) throws CloudPluginException {
@@ -85,33 +40,11 @@ public class CloudHandler extends SQLiteOpenHelper {
         if (!CloudSheetFragment.isCloudProviderAvailable(context))
             throw new CloudPluginException();
 
-        ContentValues contentValues = new ContentValues();
-        //contentValues.put(COLUMN_ENCRYPTED_ID, encryptedEntry.getId());
-        contentValues.put(COLUMN_CLOUD_SERVICE, cloudEntry.getServiceType().ordinal());
-
-        try {
-
-            contentValues.put(COLUMN_CLOUD_PERSIST, CryptUtil.encryptPassword(context,
-                    cloudEntry.getPersistData()));
-        } catch (Exception e) {
-            e.printStackTrace();
-            // failed to encrypt, revert back to plain
-            contentValues.put(COLUMN_CLOUD_PERSIST, cloudEntry.getPersistData());
-        }
-
-        SQLiteDatabase sqLiteDatabase = getWritableDatabase();
-        sqLiteDatabase.insert(TABLE_CLOUD_PERSIST, null, contentValues);
+        database.cloudEntryDao().insert(cloudEntry);
     }
 
     public void clear(OpenMode serviceType) {
-        try {
-            SQLiteDatabase sqLiteDatabase = getWritableDatabase();
-
-            sqLiteDatabase.delete(TABLE_CLOUD_PERSIST, COLUMN_CLOUD_SERVICE + " = ?",
-                    new String[]{serviceType.ordinal() + ""});
-        } catch (NumberFormatException e) {
-            e.printStackTrace();
-        }
+        database.cloudEntryDao().delete(database.cloudEntryDao().findByServiceType(serviceType.ordinal()));
     }
 
     public void updateEntry(OpenMode serviceType, CloudEntry newCloudEntry)
@@ -120,22 +53,7 @@ public class CloudHandler extends SQLiteOpenHelper {
         if (!CloudSheetFragment.isCloudProviderAvailable(context))
             throw new CloudPluginException();
 
-        SQLiteDatabase sqLiteDatabase = getWritableDatabase();
-        ContentValues contentValues = new ContentValues();
-        contentValues.put(COLUMN_CLOUD_ID, newCloudEntry.getId());
-        contentValues.put(COLUMN_CLOUD_SERVICE, newCloudEntry.getServiceType().ordinal());
-        try {
-
-            contentValues.put(COLUMN_CLOUD_PERSIST, CryptUtil.encryptPassword(context,
-                    newCloudEntry.getPersistData()));
-        } catch (Exception e) {
-            e.printStackTrace();
-            // failed to encrypt, revert back to plain
-            contentValues.put(COLUMN_CLOUD_PERSIST, newCloudEntry.getPersistData());
-        }
-
-        sqLiteDatabase.update(TABLE_CLOUD_PERSIST, contentValues, COLUMN_CLOUD_SERVICE + " = ?",
-                new String[]{serviceType.ordinal() + ""});
+        database.cloudEntryDao().update(newCloudEntry);
     }
 
     public CloudEntry findEntry(OpenMode serviceType) throws CloudPluginException {
@@ -143,27 +61,7 @@ public class CloudHandler extends SQLiteOpenHelper {
         if (!CloudSheetFragment.isCloudProviderAvailable(context))
             throw new CloudPluginException();
 
-        String query = "Select * FROM " + TABLE_CLOUD_PERSIST + " WHERE " + COLUMN_CLOUD_SERVICE
-                        + "= \"" + serviceType.ordinal() + "\"";
-        SQLiteDatabase sqLiteDatabase = getReadableDatabase();
-        Cursor cursor = sqLiteDatabase.rawQuery(query, null);
-        CloudEntry cloudEntry = new CloudEntry();
-        if (cursor.moveToFirst()) {
-            cloudEntry.setId((cursor.getInt(0)));
-            cloudEntry.setServiceType(serviceType);
-            try {
-                cloudEntry.setPersistData(CryptUtil.decryptPassword(context, cursor.getString(2)));
-            } catch (Exception e) {
-                e.printStackTrace();
-                cloudEntry.setPersistData("");
-                return cloudEntry;
-            }
-
-            cursor.close();
-        } else {
-            cloudEntry = null;
-        }
-        return cloudEntry;
+        return database.cloudEntryDao().findByServiceType(serviceType.ordinal());
     }
 
     public List<CloudEntry> getAllEntries() throws CloudPluginException {
@@ -171,39 +69,6 @@ public class CloudHandler extends SQLiteOpenHelper {
         if (!CloudSheetFragment.isCloudProviderAvailable(context))
             throw new CloudPluginException();
 
-        List<CloudEntry> entryList = new ArrayList<>();
-
-        // Select all query
-        String query = "Select * FROM " + TABLE_CLOUD_PERSIST;
-
-        SQLiteDatabase sqLiteDatabase = getReadableDatabase();
-        Cursor cursor = null;
-        try {
-            cursor = sqLiteDatabase.rawQuery(query, null);
-            // Looping through all rows and adding them to list
-            if (cursor.getCount() > 0 && cursor.moveToFirst()) {
-                do {
-                    CloudEntry cloudEntry = new CloudEntry();
-                    cloudEntry.setId((cursor.getInt(0)));
-                    cloudEntry.setServiceType(OpenMode.getOpenMode(cursor.getInt(1)));
-                    try {
-                        cloudEntry.setPersistData(CryptUtil.decryptPassword(context, cursor.getString(2)));
-                    } catch (Exception e) {
-                        e.printStackTrace();
-                        cloudEntry.setPersistData("");
-                        entryList.add(cloudEntry);
-                        continue;
-                    }
-
-                    entryList.add(cloudEntry);
-                } while (cursor.moveToNext());
-            }
-        } finally {
-            if (cursor != null) {
-                cursor.close();
-            }
-        }
-
-        return entryList;
+        return Arrays.asList(database.cloudEntryDao().list());
     }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/database/CryptHandler.java b/app/src/main/java/com/amaze/filemanager/database/CryptHandler.java
index 63a09a9c6..59348afe0 100644
--- a/app/src/main/java/com/amaze/filemanager/database/CryptHandler.java
+++ b/app/src/main/java/com/amaze/filemanager/database/CryptHandler.java
@@ -1,135 +1,39 @@
 package com.amaze.filemanager.database;
 
-import android.content.ContentValues;
-import android.content.Context;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
+import com.amaze.filemanager.database.models.explorer.EncryptedEntry;
 
-import com.amaze.filemanager.database.models.EncryptedEntry;
-import com.amaze.filemanager.utils.files.CryptUtil;
-
-import java.io.IOException;
-import java.security.GeneralSecurityException;
-import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 
 /**
  * Created by vishal on 15/4/17.
  */
 
-public class CryptHandler extends SQLiteOpenHelper {
-
-    private static final String DATABASE_NAME = "explorer.db";
-    private static final String TABLE_ENCRYPTED = "encrypted";
-
-    private static final String COLUMN_ENCRYPTED_ID = "_id";
-    private static final String COLUMN_ENCRYPTED_PATH = "path";
-    private static final String COLUMN_ENCRYPTED_PASSWORD = "password";
+public class CryptHandler {
 
-    private Context context;
+    private final ExplorerDatabase database;
 
-    public CryptHandler(Context context) {
-        super(context, DATABASE_NAME, null, TabHandler.DATABASE_VERSION);
-        this.context = context;
+    public CryptHandler() {
+        database = ExplorerDatabase.getInstance();
     }
 
-    @Override
-    public void onCreate(SQLiteDatabase db) {
-
-        String CREATE_TABLE_ENCRYPTED = "CREATE TABLE " + TABLE_ENCRYPTED + "("
-                + COLUMN_ENCRYPTED_ID
-                + " INTEGER PRIMARY KEY,"
-                + COLUMN_ENCRYPTED_PATH + " TEXT," + COLUMN_ENCRYPTED_PASSWORD + " TEXT" + ")";
-
-        db.execSQL(CREATE_TABLE_ENCRYPTED);
-    }
-
-    @Override
-    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-
-        db.execSQL("DROP TABLE IF EXISTS " + TABLE_ENCRYPTED);
-        onCreate(db);
-    }
-
-    public void addEntry(EncryptedEntry encryptedEntry) throws GeneralSecurityException, IOException {
-
-        ContentValues contentValues = new ContentValues();
-        //contentValues.put(COLUMN_ENCRYPTED_ID, encryptedEntry.getId());
-        contentValues.put(COLUMN_ENCRYPTED_PATH, encryptedEntry.getPath());
-        contentValues.put(COLUMN_ENCRYPTED_PASSWORD, CryptUtil.encryptPassword(context,
-                encryptedEntry.getPassword()));
-
-        SQLiteDatabase sqLiteDatabase = getWritableDatabase();
-        sqLiteDatabase.insert(TABLE_ENCRYPTED, null, contentValues);
+    public void addEntry(EncryptedEntry encryptedEntry) {
+        database.encryptedEntryDao().insert(encryptedEntry);
     }
 
     public void clear(String path) {
-        try {
-            SQLiteDatabase sqLiteDatabase = getWritableDatabase();
-            sqLiteDatabase.delete(TABLE_ENCRYPTED, COLUMN_ENCRYPTED_PATH + " = ?", new String[]{path});
-        } catch (NumberFormatException e) {
-            e.printStackTrace();
-        }
+        database.encryptedEntryDao().delete(database.encryptedEntryDao().select(path));
     }
 
-    public void updateEntry(EncryptedEntry oldEncryptedEntry, EncryptedEntry newEncryptedEntry) throws GeneralSecurityException, IOException  {
-        SQLiteDatabase sqLiteDatabase = getWritableDatabase();
-        ContentValues contentValues = new ContentValues();
-        contentValues.put(COLUMN_ENCRYPTED_ID, newEncryptedEntry.getId());
-        contentValues.put(COLUMN_ENCRYPTED_PATH, newEncryptedEntry.getPath());
-        contentValues.put(COLUMN_ENCRYPTED_PASSWORD, CryptUtil.encryptPassword(context,
-                newEncryptedEntry.getPassword()));
-
-        sqLiteDatabase.update(TABLE_ENCRYPTED, contentValues, COLUMN_ENCRYPTED_ID + " = ?",
-                new String[]{oldEncryptedEntry.getId() + ""});
+    public void updateEntry(EncryptedEntry oldEncryptedEntry, EncryptedEntry newEncryptedEntry) {
+        database.encryptedEntryDao().update(newEncryptedEntry);
     }
 
-    public EncryptedEntry findEntry(String path) throws GeneralSecurityException, IOException {
-        String query = "Select * FROM " + TABLE_ENCRYPTED + " WHERE " + COLUMN_ENCRYPTED_PATH
-                + "= \"" + path + "\"";
-        SQLiteDatabase sqLiteDatabase = getReadableDatabase();
-        Cursor cursor = sqLiteDatabase.rawQuery(query, null);
-        EncryptedEntry encryptedEntry = new EncryptedEntry();
-        if (cursor.moveToFirst()) {
-            encryptedEntry.setId((cursor.getInt(0)));
-            encryptedEntry.setPath(cursor.getString(1));
-            encryptedEntry.setPassword(CryptUtil.decryptPassword(context, cursor.getString(2)));
-            cursor.close();
-        } else {
-            encryptedEntry = null;
-        }
-        return encryptedEntry;
+    public EncryptedEntry findEntry(String path) {
+        return database.encryptedEntryDao().select(path);
     }
 
-    public List<EncryptedEntry> getAllEntries() throws GeneralSecurityException, IOException {
-        List<EncryptedEntry> entryList = new ArrayList<EncryptedEntry>();
-        // Select all query
-        String query = "Select * FROM " + TABLE_ENCRYPTED;
-
-        SQLiteDatabase sqLiteDatabase = getReadableDatabase();
-        Cursor cursor = null;
-        try {
-            cursor = sqLiteDatabase.rawQuery(query, null);
-            // Looping through all rows and adding them to list
-            boolean hasNext = cursor.moveToFirst();
-            while(hasNext) {
-                EncryptedEntry encryptedEntry = new EncryptedEntry();
-                encryptedEntry.setId((cursor.getInt(0)));
-                encryptedEntry.setPath(cursor.getString(1));
-                encryptedEntry.setPassword(CryptUtil.decryptPassword(context,
-                        cursor.getString(2)));
-
-                entryList.add(encryptedEntry);
-
-                hasNext = cursor.moveToNext();
-            }
-        } finally {
-            if (cursor != null) {
-                cursor.close();
-            }
-        }
-
-        return entryList;
+    public List<EncryptedEntry> getAllEntries()  {
+        return Arrays.asList(database.encryptedEntryDao().list());
     }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/database/ExplorerDatabase.java b/app/src/main/java/com/amaze/filemanager/database/ExplorerDatabase.java
new file mode 100644
index 000000000..ff7aae0b9
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/ExplorerDatabase.java
@@ -0,0 +1,128 @@
+/*
+ * ExplorerDatabase.java
+ *
+ * Copyright (C) 2020 Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.database;
+
+import android.content.Context;
+
+import androidx.annotation.NonNull;
+import androidx.room.Database;
+import androidx.room.Room;
+import androidx.room.RoomDatabase;
+import androidx.room.migration.Migration;
+import androidx.sqlite.db.SupportSQLiteDatabase;
+//import androidx.room.migration.Migration;
+//import androidx.sqlite.db.SupportSQLiteDatabase;
+
+import com.amaze.filemanager.database.daos.CloudEntryDao;
+import com.amaze.filemanager.database.daos.EncryptedEntryDao;
+import com.amaze.filemanager.database.daos.SortDao;
+import com.amaze.filemanager.database.daos.TabDao;
+import com.amaze.filemanager.database.models.explorer.CloudEntry;
+import com.amaze.filemanager.database.models.explorer.EncryptedEntry;
+import com.amaze.filemanager.database.models.explorer.Sort;
+import com.amaze.filemanager.database.models.explorer.Tab;
+
+@Database(entities = {Tab.class, Sort.class, EncryptedEntry.class, CloudEntry.class}, version = 7, exportSchema = false)
+public abstract class ExplorerDatabase extends RoomDatabase {
+
+    abstract TabDao tabDao();
+    abstract SortDao sortDao();
+    abstract EncryptedEntryDao encryptedEntryDao();
+    abstract CloudEntryDao cloudEntryDao();
+
+    private static final String DATABASE_NAME = "explorer.db";
+    private static final int DATABASE_VERSION = 7;
+
+    public static final String TABLE_TAB = "tab";
+    public static final String TABLE_CLOUD_PERSIST = "cloud";
+    public static final String TABLE_ENCRYPTED = "encrypted";
+    public static final String TABLE_SORT = "sort";
+
+    public static final String COLUMN_TAB_NO = "tab_no";
+    public static final String COLUMN_PATH = "path";
+    public static final String COLUMN_HOME = "home";
+
+    public static final String COLUMN_ENCRYPTED_ID = "_id";
+    public static final String COLUMN_ENCRYPTED_PATH = "path";
+    public static final String COLUMN_ENCRYPTED_PASSWORD = "password";
+
+    public static final String COLUMN_CLOUD_ID = "_id";
+    public static final String COLUMN_CLOUD_SERVICE = "service";
+    public static final String COLUMN_CLOUD_PERSIST = "persist";
+
+    public static final String COLUMN_SORT_PATH = "path";
+    public static final String COLUMN_SORT_TYPE = "type";
+
+    private static final String TEMP_TABLE_PREFIX ="temp_";
+
+    private static final Migration MIGRATION_6_7 = new Migration(6, DATABASE_VERSION) {
+        @Override
+        public void migrate(@NonNull SupportSQLiteDatabase database) {
+            database.execSQL("CREATE TABLE " + TEMP_TABLE_PREFIX + TABLE_TAB + "(" +
+                    COLUMN_TAB_NO + " INTEGER PRIMARY KEY NOT NULL, " +
+                    COLUMN_PATH + " TEXT, " +
+                    COLUMN_HOME + " TEXT)");
+            database.execSQL("INSERT INTO " + TEMP_TABLE_PREFIX + TABLE_TAB + " SELECT * FROM " + TABLE_TAB);
+            database.execSQL("DROP TABLE " + TABLE_TAB);
+            database.execSQL("ALTER TABLE " + TEMP_TABLE_PREFIX + TABLE_TAB + " RENAME TO " + TABLE_TAB);
+
+            database.execSQL("CREATE TABLE " + TEMP_TABLE_PREFIX + TABLE_SORT + "(" +
+                    COLUMN_SORT_PATH + " TEXT PRIMARY KEY NOT NULL, " +
+                    COLUMN_SORT_TYPE + " INTEGER NOT NULL)");
+            database.execSQL("INSERT INTO " + TEMP_TABLE_PREFIX + TABLE_SORT + " SELECT * FROM " + TABLE_SORT);
+            database.execSQL("DROP TABLE " + TABLE_SORT);
+            database.execSQL("ALTER TABLE " + TEMP_TABLE_PREFIX + TABLE_SORT + " RENAME TO " + TABLE_SORT);
+
+            database.execSQL("CREATE TABLE " + TEMP_TABLE_PREFIX + TABLE_ENCRYPTED + "(" +
+                    COLUMN_ENCRYPTED_ID + " INTEGER PRIMARY KEY NOT NULL," +
+                    COLUMN_ENCRYPTED_PATH + " TEXT," +
+                    COLUMN_ENCRYPTED_PASSWORD + " TEXT)");
+            database.execSQL("INSERT INTO " + TEMP_TABLE_PREFIX + TABLE_ENCRYPTED + " SELECT * FROM " + TABLE_ENCRYPTED);
+            database.execSQL("DROP TABLE " + TABLE_ENCRYPTED);
+            database.execSQL("ALTER TABLE " + TEMP_TABLE_PREFIX + TABLE_ENCRYPTED + " RENAME TO " + TABLE_ENCRYPTED);
+
+            database.execSQL("CREATE TABLE " + TEMP_TABLE_PREFIX + TABLE_CLOUD_PERSIST + "(" +
+                    COLUMN_CLOUD_ID + " INTEGER PRIMARY KEY NOT NULL," +
+                    COLUMN_CLOUD_SERVICE + " INTEGER," +
+                    COLUMN_CLOUD_PERSIST + " TEXT)");
+            database.execSQL("INSERT INTO " + TEMP_TABLE_PREFIX + TABLE_CLOUD_PERSIST + " SELECT * FROM " + TABLE_CLOUD_PERSIST);
+            database.execSQL("DROP TABLE " + TABLE_CLOUD_PERSIST);
+            database.execSQL("ALTER TABLE " + TEMP_TABLE_PREFIX + TABLE_CLOUD_PERSIST + " RENAME TO " + TABLE_CLOUD_PERSIST);
+        }
+    };
+
+    private static ExplorerDatabase INSTANCE;
+
+    public synchronized static void initialize(@NonNull Context context){
+        android.util.Log.d("ROOM", "Initialize explorer.db");
+        if(INSTANCE == null) {
+            INSTANCE = Room.databaseBuilder(context, ExplorerDatabase.class, DATABASE_NAME)
+                    .addMigrations(MIGRATION_6_7)
+                    .allowMainThreadQueries()
+                    .build();
+        }
+    }
+
+    public static final ExplorerDatabase getInstance(){
+        return INSTANCE;
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/database/SortHandler.java b/app/src/main/java/com/amaze/filemanager/database/SortHandler.java
index 9a76aa247..721332e39 100644
--- a/app/src/main/java/com/amaze/filemanager/database/SortHandler.java
+++ b/app/src/main/java/com/amaze/filemanager/database/SortHandler.java
@@ -1,20 +1,13 @@
 package com.amaze.filemanager.database;
 
-import android.content.ContentValues;
 import android.content.Context;
 import android.content.SharedPreferences;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
 import android.preference.PreferenceManager;
 import androidx.annotation.Nullable;
-import android.text.TextUtils;
 
-import com.amaze.filemanager.database.models.Sort;
+import com.amaze.filemanager.database.models.explorer.Sort;
 
-import java.util.ArrayList;
 import java.util.HashSet;
-import java.util.List;
 import java.util.Set;
 
 import static com.amaze.filemanager.fragments.preference_fragments.PreferencesConstants.PREFERENCE_SORTBY_ONLY_THIS;
@@ -23,13 +16,9 @@ import static com.amaze.filemanager.fragments.preference_fragments.PreferencesCo
  * Created by Ning on 5/28/2018.
  */
 
-public class SortHandler extends SQLiteOpenHelper {
+public class SortHandler {
 
-    private static final String DATABASE_NAME = "explorer.db";
-    public static final String TABLE_SORT = "sort";
-
-    public static final String COLUMN_SORT_PATH = "path";
-    public static final String COLUMN_SORT_TYPE = "type";
+    private final ExplorerDatabase database;
 
     public static int getSortType(Context context, String path) {
         SharedPreferences sharedPref = PreferenceManager.getDefaultSharedPreferences(context);
@@ -39,7 +28,7 @@ public class SortHandler extends SQLiteOpenHelper {
         if (!onlyThis) {
             return globalSortby;
         }
-        SortHandler sortHandler = new SortHandler(context);
+        SortHandler sortHandler = new SortHandler();
         Sort sort = sortHandler.findEntry(path);
         if (sort == null) {
             return globalSortby;
@@ -47,102 +36,24 @@ public class SortHandler extends SQLiteOpenHelper {
         return sort.type;
     }
 
-    public SortHandler(Context context) {
-        super(context, DATABASE_NAME, null, TabHandler.DATABASE_VERSION);
-    }
-
-    @Override
-    public void onCreate(SQLiteDatabase db) {
-        String CREATE_TABLE_SORT = "CREATE TABLE " + TABLE_SORT + "("
-                + COLUMN_SORT_PATH
-                + " TEXT PRIMARY KEY,"
-                + COLUMN_SORT_TYPE + " INTEGER" + ")";
-
-        db.execSQL(CREATE_TABLE_SORT);
-    }
-
-    @Override
-    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-        onCreate(db);
+    public SortHandler() {
+        database = ExplorerDatabase.getInstance();
     }
 
     public void addEntry(Sort sort) {
-        if (TextUtils.isEmpty(sort.path)) {
-            return;
-        }
-        ContentValues contentValues = new ContentValues();
-        contentValues.put(COLUMN_SORT_PATH, sort.path);
-        contentValues.put(COLUMN_SORT_TYPE, sort.type);
-
-        SQLiteDatabase sqLiteDatabase = getWritableDatabase();
-        sqLiteDatabase.insert(TABLE_SORT, null, contentValues);
+        database.sortDao().insert(sort);
     }
 
     public void clear(String path) {
-        try {
-            SQLiteDatabase sqLiteDatabase = getWritableDatabase();
-            sqLiteDatabase.delete(TABLE_SORT, COLUMN_SORT_PATH + " = ?", new String[]{path});
-        } catch (NumberFormatException e) {
-            e.printStackTrace();
-        }
+        database.sortDao().clear(database.sortDao().find(path));
     }
 
     public void updateEntry(Sort oldSort, Sort newSort) {
-        if (TextUtils.isEmpty(oldSort.path) || TextUtils.isEmpty(newSort.path)) {
-            return;
-        }
-
-        SQLiteDatabase sqLiteDatabase = getWritableDatabase();
-        ContentValues contentValues = new ContentValues();
-        contentValues.put(COLUMN_SORT_PATH, newSort.path);
-        contentValues.put(COLUMN_SORT_TYPE, newSort.type);
-
-        sqLiteDatabase.update(TABLE_SORT, contentValues, COLUMN_SORT_PATH + " = ?",
-                new String[]{oldSort.path});
+        database.sortDao().update(newSort);
     }
 
     @Nullable
     public Sort findEntry(String path) {
-        if (TextUtils.isEmpty(path)) {
-            return null;
-        }
-
-        String query = "Select * FROM " + TABLE_SORT + " WHERE " + COLUMN_SORT_PATH
-                + "= \"" + path + "\"";
-        SQLiteDatabase sqLiteDatabase = getReadableDatabase();
-        Cursor cursor = sqLiteDatabase.rawQuery(query, null);
-        Sort sort;
-        if (cursor.moveToFirst()) {
-            sort = new Sort(cursor.getString(0), cursor.getInt(1));
-            cursor.close();
-        } else {
-            sort = null;
-        }
-        return sort;
-    }
-
-    public List<Sort> getAllEntries() {
-        List<Sort> entryList = new ArrayList<>();
-        // Select all query
-        String query = "Select * FROM " + TABLE_SORT;
-
-        SQLiteDatabase sqLiteDatabase = getReadableDatabase();
-        Cursor cursor = null;
-        try {
-            cursor = sqLiteDatabase.rawQuery(query, null);
-            // Looping through all rows and adding them to list
-            boolean hasNext = cursor.moveToFirst();
-            while (hasNext) {
-                Sort sort = new Sort(cursor.getString(0), cursor.getInt(1));
-                entryList.add(sort);
-                hasNext = cursor.moveToNext();
-            }
-        } finally {
-            if (cursor != null) {
-                cursor.close();
-            }
-        }
-
-        return entryList;
+        return database.sortDao().find(path);
     }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/database/TabHandler.java b/app/src/main/java/com/amaze/filemanager/database/TabHandler.java
index c3ee8d175..ea974b916 100644
--- a/app/src/main/java/com/amaze/filemanager/database/TabHandler.java
+++ b/app/src/main/java/com/amaze/filemanager/database/TabHandler.java
@@ -19,140 +19,43 @@
 
 package com.amaze.filemanager.database;
 
-import android.content.ContentValues;
-import android.content.Context;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 
-import com.amaze.filemanager.database.models.Tab;
+import com.amaze.filemanager.database.models.explorer.Tab;
 
-import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 
-import androidx.annotation.Nullable;
-
 /**
  * Created by Vishal on 9/17/2014.
  */
-public class TabHandler extends SQLiteOpenHelper {
-
-    protected static final int DATABASE_VERSION = 6;
-    protected static final String DATABASE_NAME = "explorer.db";
-    protected static final String TABLE_TAB = "tab";
-
-    protected static final String COLUMN_TAB_NO = "tab_no";
-    protected static final String COLUMN_LABEL = "label";
-    protected static final String COLUMN_PATH = "path";
-    protected static final String COLUMN_HOME = "home";
+public class TabHandler {
 
-    protected static final String TABLE_ENCRYPTED = "encrypted";
+    private final ExplorerDatabase database;
 
-    protected static final String COLUMN_ENCRYPTED_ID = "_id";
-    protected static final String COLUMN_ENCRYPTED_PATH = "path";
-    protected static final String COLUMN_ENCRYPTED_PASSWORD = "password";
-
-    public TabHandler(Context context) {
-        super(context, DATABASE_NAME, null, DATABASE_VERSION);
-        // The call to onUpgrade() is not performed unless getWritableDatabase() is called.
-        // See more at https://github.com/TeamAmaze/AmazeFileManager/pull/1262
-        getWritableDatabase();
+    public TabHandler() {
+        database = ExplorerDatabase.getInstance();
     }
 
-    @Override
-    public void onCreate(SQLiteDatabase db) {
-        String CREATE_TAB_TABLE = "CREATE TABLE IF NOT EXISTS " + TABLE_TAB + "("
-                + COLUMN_TAB_NO + " INTEGER PRIMARY KEY,"
-                + COLUMN_PATH + " TEXT,"
-                + COLUMN_HOME + " TEXT" +
-                ")";
-
-        String CREATE_TABLE_ENCRYPTED = "CREATE TABLE IF NOT EXISTS " + TABLE_ENCRYPTED + "("
-                + COLUMN_ENCRYPTED_ID + " INTEGER PRIMARY KEY,"
-                + COLUMN_ENCRYPTED_PATH + " TEXT,"
-                + COLUMN_ENCRYPTED_PASSWORD + " TEXT"
-                + ")";
-
-        String CREATE_TABLE_CLOUD = "CREATE TABLE IF NOT EXISTS " + CloudHandler.TABLE_CLOUD_PERSIST + "("
-                + CloudHandler.COLUMN_CLOUD_ID
-                + " INTEGER PRIMARY KEY,"
-                + CloudHandler.COLUMN_CLOUD_SERVICE + " INTEGER,"
-                + CloudHandler.COLUMN_CLOUD_PERSIST + " TEXT" + ")";
-
-        String CREATE_TABLE_SORT = "CREATE TABLE IF NOT EXISTS " + SortHandler.TABLE_SORT + "("
-                + SortHandler.COLUMN_SORT_PATH + " TEXT PRIMARY KEY,"
-                + SortHandler.COLUMN_SORT_TYPE + " INTEGER"
-                + ")";
-
-        db.execSQL(CREATE_TAB_TABLE);
-        db.execSQL(CREATE_TABLE_ENCRYPTED);
-        db.execSQL(CREATE_TABLE_CLOUD);
-        db.execSQL(CREATE_TABLE_SORT);
-    }
-
-    @Override
-    public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i2) {
-        onCreate(sqLiteDatabase);
-    }
-
-    @Override
-    public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-        onUpgrade(db, oldVersion, newVersion);
-    }
-
-    public void addTab(Tab tab) {
-        ContentValues contentValues = new ContentValues();
-        contentValues.put(COLUMN_TAB_NO, tab.tabNumber);
-        contentValues.put(COLUMN_PATH, tab.path);
-        contentValues.put(COLUMN_HOME, tab.home);
-        SQLiteDatabase sqLiteDatabase = this.getWritableDatabase();
-        sqLiteDatabase.insert(TABLE_TAB, null, contentValues);
+    public void addTab(@NonNull Tab tab) {
+        database.tabDao().insertTab(tab);
     }
 
     public void clear() {
-        try {
-            SQLiteDatabase sqLiteDatabase = getWritableDatabase();
-            sqLiteDatabase.delete(TABLE_TAB, COLUMN_TAB_NO + " = ?", new String[]{"" + 1});
-            sqLiteDatabase.delete(TABLE_TAB, COLUMN_TAB_NO + " = ?", new String[]{"" + 2});
-        } catch (NumberFormatException e) {
-            e.printStackTrace();
-        }
+        database.tabDao().clear();
     }
 
     @Nullable
     public Tab findTab(int tabNo) {
-        String query = "Select * FROM " + TABLE_TAB + " WHERE " + COLUMN_TAB_NO + "= \"" + tabNo + "\"";
-        SQLiteDatabase sqLiteDatabase = this.getWritableDatabase();
-        Cursor cursor = sqLiteDatabase.rawQuery(query, null);
-        Tab tab;
-        if (cursor.moveToFirst()) {
-            tab = new Tab(cursor.getInt(0), cursor.getString(1),
-                    cursor.getString(2));
-            cursor.close();
-        } else {
-            tab = null;
-        }
-        return tab;
+        return database.tabDao().find(tabNo);
     }
 
     public List<Tab> getAllTabs() {
+        return Arrays.asList(database.tabDao().list());
+    }
 
-        List<Tab> tabList = new ArrayList<>();
-        // Select all query
-        SQLiteDatabase sqLiteDatabase = getReadableDatabase();
-        Cursor cursor = sqLiteDatabase.query(TABLE_TAB, null, null, null, null, null, null);
-        boolean hasNext = cursor.moveToFirst();
-
-        // Looping through all rows and adding them to list
-        while (hasNext) {
-            Tab tab = new Tab(cursor.getInt(0), cursor.getString(1),
-                    cursor.getString(2));
-            //Adding them to list
-            tabList.add(tab);
-            hasNext = cursor.moveToNext();
-        }
-        cursor.close();
-
-        return tabList;
+    public void close() {
+        database.close();
     }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/database/UtilitiesDatabase.java b/app/src/main/java/com/amaze/filemanager/database/UtilitiesDatabase.java
new file mode 100644
index 000000000..999883454
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/UtilitiesDatabase.java
@@ -0,0 +1,250 @@
+/*
+ * UtilitiesDatabase.java
+ *
+ * Copyright (C) 2020 Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam <emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com>
+ * and contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.database;
+
+import android.content.Context;
+
+import androidx.annotation.NonNull;
+import androidx.room.Database;
+import androidx.room.Room;
+import androidx.room.RoomDatabase;
+import androidx.room.migration.Migration;
+import androidx.sqlite.db.SupportSQLiteDatabase;
+
+import com.amaze.filemanager.database.daos.BookmarkEntryDao;
+import com.amaze.filemanager.database.daos.GridEntryDao;
+import com.amaze.filemanager.database.daos.HiddenEntryDao;
+import com.amaze.filemanager.database.daos.HistoryEntryDao;
+import com.amaze.filemanager.database.daos.ListEntryDao;
+import com.amaze.filemanager.database.daos.SftpEntryDao;
+import com.amaze.filemanager.database.daos.SmbEntryDao;
+import com.amaze.filemanager.database.models.utilities.Bookmark;
+import com.amaze.filemanager.database.models.utilities.Grid;
+import com.amaze.filemanager.database.models.utilities.Hidden;
+import com.amaze.filemanager.database.models.utilities.History;
+import com.amaze.filemanager.database.models.utilities.List;
+import com.amaze.filemanager.database.models.utilities.SftpEntry;
+import com.amaze.filemanager.database.models.utilities.SmbEntry;
+
+@Database(entities = {Bookmark.class, Grid.class, Hidden.class, History.class, List.class, SmbEntry.class, SftpEntry.class}, version = 4, exportSchema = false)
+public abstract class UtilitiesDatabase extends RoomDatabase {
+
+    abstract HiddenEntryDao hiddenEntryDao();
+
+    abstract GridEntryDao gridEntryDao();
+
+    abstract ListEntryDao listEntryDao();
+
+    abstract HistoryEntryDao historyEntryDao();
+
+    abstract BookmarkEntryDao bookmarkEntryDao();
+
+    abstract SmbEntryDao smbEntryDao();
+
+    abstract SftpEntryDao sftpEntryDao();
+
+    private static final String DATABASE_NAME = "utilities.db";
+
+    public static final String TABLE_HISTORY = "history";
+    public static final String TABLE_HIDDEN = "hidden";
+    public static final String TABLE_LIST = "list";
+    public static final String TABLE_GRID = "grid";
+    public static final String TABLE_BOOKMARKS = "bookmarks";
+    public static final String TABLE_SMB = "smb";
+    public static final String TABLE_SFTP = "sftp";
+
+    public static final String COLUMN_ID = "_id";
+    public static final String COLUMN_PATH = "path";
+    public static final String COLUMN_NAME = "name";
+    public static final String COLUMN_HOST_PUBKEY = "pub_key";
+    public static final String COLUMN_PRIVATE_KEY_NAME = "ssh_key_name";
+    public static final String COLUMN_PRIVATE_KEY = "ssh_key";
+
+    private static final String TEMP_TABLE_PREFIX ="temp_";
+
+    private static String queryHistory = "CREATE TABLE IF NOT EXISTS " + TABLE_HISTORY + " ("
+            + COLUMN_ID + " INTEGER PRIMARY KEY,"
+            + COLUMN_PATH + " TEXT UNIQUE"
+            + ");";
+
+    private static String queryHidden = "CREATE TABLE IF NOT EXISTS " + TABLE_HIDDEN + " ("
+            + COLUMN_ID + " INTEGER PRIMARY KEY,"
+            + COLUMN_PATH + " TEXT UNIQUE"
+            + ");";
+
+    private static String queryList = "CREATE TABLE IF NOT EXISTS " + TABLE_LIST + " ("
+            + COLUMN_ID + " INTEGER PRIMARY KEY,"
+            + COLUMN_PATH + " TEXT UNIQUE"
+            + ");";
+
+    private static String queryGrid = "CREATE TABLE IF NOT EXISTS " + TABLE_GRID + " ("
+            + COLUMN_ID + " INTEGER PRIMARY KEY,"
+            + COLUMN_PATH + " TEXT UNIQUE"
+            + ");";
+
+    private static String queryBookmarks = "CREATE TABLE IF NOT EXISTS " + TABLE_BOOKMARKS + " ("
+            + COLUMN_ID + " INTEGER PRIMARY KEY,"
+            + COLUMN_NAME + " TEXT,"
+            + COLUMN_PATH + " TEXT UNIQUE"
+            + ");";
+
+    private static String querySmb = "CREATE TABLE IF NOT EXISTS " + TABLE_SMB + " ("
+            + COLUMN_ID + " INTEGER PRIMARY KEY,"
+            + COLUMN_NAME + " TEXT,"
+            + COLUMN_PATH + " TEXT UNIQUE"
+            + ");";
+
+    private static final String querySftp = "CREATE TABLE IF NOT EXISTS " + TABLE_SFTP + " ("
+            + COLUMN_ID + " INTEGER PRIMARY KEY,"
+            + COLUMN_NAME + " TEXT,"
+            + COLUMN_PATH + " TEXT UNIQUE,"
+            + COLUMN_HOST_PUBKEY + " TEXT,"
+            + COLUMN_PRIVATE_KEY_NAME + " TEXT,"
+            + COLUMN_PRIVATE_KEY + " TEXT"
+            + ");";
+
+    private static UtilitiesDatabase INSTANCE;
+
+    private static final Migration MIGRATION_1_2 = new Migration(1,2) {
+        @Override
+        public void migrate(@NonNull SupportSQLiteDatabase database) {
+            database.execSQL("CREATE TABLE IF NOT EXISTS " + TABLE_SFTP + " ("
+                    + COLUMN_ID + " INTEGER PRIMARY KEY,"
+                    + COLUMN_NAME + " TEXT,"
+                    + COLUMN_PATH + " TEXT UNIQUE,"
+                    + COLUMN_HOST_PUBKEY + " TEXT,"
+                    + COLUMN_PRIVATE_KEY_NAME + " TEXT,"
+                    + COLUMN_PRIVATE_KEY + " TEXT"
+                    + ");");
+        }
+    };
+
+    private static final Migration MIGRATION_2_3 = new Migration(2,3) {
+        @Override
+        public void migrate(@NonNull SupportSQLiteDatabase database) {
+            String backupTable = TEMP_TABLE_PREFIX + TABLE_HISTORY;
+            database.execSQL(queryHistory.replace(TABLE_HISTORY, backupTable));
+            database.execSQL("INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_HISTORY + " group by path;");
+            database.execSQL("DROP TABLE " + TABLE_HISTORY + ";");
+            database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_HISTORY + ";");
+
+            backupTable = TEMP_TABLE_PREFIX + TABLE_HIDDEN;
+            database.execSQL(queryHidden.replace(TABLE_HIDDEN, backupTable));
+            database.execSQL("INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_HIDDEN + " group by path;");
+            database.execSQL("DROP TABLE " + TABLE_HIDDEN + ";");
+            database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_HIDDEN + ";");
+
+            backupTable = TEMP_TABLE_PREFIX + TABLE_LIST;
+            database.execSQL(queryList.replace(TABLE_LIST, backupTable));
+            database.execSQL("INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_LIST + " group by path;");
+            database.execSQL("DROP TABLE " + TABLE_LIST + ";");
+            database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_LIST + ";");
+
+            backupTable = TEMP_TABLE_PREFIX + TABLE_GRID;
+            database.execSQL(queryGrid.replace(TABLE_GRID, backupTable));
+            database.execSQL("INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_GRID + " group by path;");
+            database.execSQL("DROP TABLE " + TABLE_GRID + ";");
+            database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_GRID + ";");
+
+            backupTable = TEMP_TABLE_PREFIX + TABLE_BOOKMARKS;
+            database.execSQL(queryBookmarks.replace(TABLE_BOOKMARKS, backupTable));
+            database.execSQL("INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_BOOKMARKS + " group by path;");
+            database.execSQL("DROP TABLE " + TABLE_BOOKMARKS + ";");
+            database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_BOOKMARKS + ";");
+
+            backupTable = TEMP_TABLE_PREFIX + TABLE_SMB;
+            database.execSQL(querySmb.replace(TABLE_SMB, backupTable));
+            database.execSQL("INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_SMB + " group by path;");
+            database.execSQL("DROP TABLE " + TABLE_SMB + ";");
+            database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_SMB + ";");
+
+            backupTable = TEMP_TABLE_PREFIX + TABLE_SFTP;
+            database.execSQL(querySftp.replace(TABLE_SFTP, backupTable));
+            database.execSQL("INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_SFTP + " group by path;");
+            database.execSQL("DROP TABLE " + TABLE_SFTP + ";");
+            database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_SFTP + ";");
+        }
+    };
+
+    private static final Migration MIGRATION_3_4 = new Migration(3,4) {
+        @Override
+        public void migrate(@NonNull SupportSQLiteDatabase database) {
+            String backupTable = TEMP_TABLE_PREFIX + TABLE_HISTORY;
+            database.execSQL(queryHistory.replace(TABLE_HISTORY, backupTable).replace("PRIMARY KEY,", "PRIMARY KEY NOT NULL,"));
+            database.execSQL("INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_HISTORY + " group by path;");
+            database.execSQL("DROP TABLE " + TABLE_HISTORY + ";");
+            database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_HISTORY + ";");
+
+            backupTable = TEMP_TABLE_PREFIX + TABLE_HIDDEN;
+            database.execSQL(queryHidden.replace(TABLE_HIDDEN, backupTable).replace("PRIMARY KEY,", "PRIMARY KEY NOT NULL,"));
+            database.execSQL("INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_HIDDEN + " group by path;");
+            database.execSQL("DROP TABLE " + TABLE_HIDDEN + ";");
+            database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_HIDDEN + ";");
+
+            backupTable = TEMP_TABLE_PREFIX + TABLE_LIST;
+            database.execSQL(queryList.replace(TABLE_LIST, backupTable).replace("PRIMARY KEY,", "PRIMARY KEY NOT NULL,"));
+            database.execSQL("INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_LIST + " group by path;");
+            database.execSQL("DROP TABLE " + TABLE_LIST + ";");
+            database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_LIST + ";");
+
+            backupTable = TEMP_TABLE_PREFIX + TABLE_GRID;
+            database.execSQL(queryGrid.replace(TABLE_GRID, backupTable).replace("PRIMARY KEY,", "PRIMARY KEY NOT NULL,"));
+            database.execSQL("INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_GRID + " group by path;");
+            database.execSQL("DROP TABLE " + TABLE_GRID + ";");
+            database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_GRID + ";");
+
+            backupTable = TEMP_TABLE_PREFIX + TABLE_BOOKMARKS;
+            database.execSQL(queryBookmarks.replace(TABLE_BOOKMARKS, backupTable).replace("PRIMARY KEY,", "PRIMARY KEY NOT NULL,"));
+            database.execSQL("INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_BOOKMARKS + " group by path;");
+            database.execSQL("DROP TABLE " + TABLE_BOOKMARKS + ";");
+            database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_BOOKMARKS + ";");
+
+            backupTable = TEMP_TABLE_PREFIX + TABLE_SMB;
+            database.execSQL(querySmb.replace(TABLE_SMB, backupTable).replace("PRIMARY KEY,", "PRIMARY KEY NOT NULL,"));
+            database.execSQL("INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_SMB + " group by path;");
+            database.execSQL("DROP TABLE " + TABLE_SMB + ";");
+            database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_SMB + ";");
+
+            backupTable = TEMP_TABLE_PREFIX + TABLE_SFTP;
+            database.execSQL(querySftp.replace(TABLE_SFTP, backupTable).replace("PRIMARY KEY,", "PRIMARY KEY NOT NULL,"));
+            database.execSQL("INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_SFTP + " group by path;");
+            database.execSQL("DROP TABLE " + TABLE_SFTP + ";");
+            database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_SFTP + ";");
+        }
+    };
+
+    public synchronized static void initialize(@NonNull Context context){
+        android.util.Log.d("ROOM", "Initialize utilities.db");
+        if(INSTANCE == null) {
+            INSTANCE = Room.databaseBuilder(context, UtilitiesDatabase.class, DATABASE_NAME)
+                    .allowMainThreadQueries()
+                    .addMigrations(MIGRATION_1_2, MIGRATION_2_3, MIGRATION_3_4)
+                    .build();
+        }
+    }
+
+    public static final UtilitiesDatabase getInstance(){
+        return INSTANCE;
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/database/UtilsHandler.java b/app/src/main/java/com/amaze/filemanager/database/UtilsHandler.java
index 323e874fd..68daaa8cd 100644
--- a/app/src/main/java/com/amaze/filemanager/database/UtilsHandler.java
+++ b/app/src/main/java/com/amaze/filemanager/database/UtilsHandler.java
@@ -1,16 +1,18 @@
 package com.amaze.filemanager.database;
 
-import android.content.ContentValues;
 import android.content.Context;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
 import android.os.Environment;
 import android.util.Log;
 import android.widget.Toast;
 
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.database.models.OperationData;
+import com.amaze.filemanager.database.models.utilities.Bookmark;
+import com.amaze.filemanager.database.models.utilities.Grid;
+import com.amaze.filemanager.database.models.utilities.Hidden;
+import com.amaze.filemanager.database.models.utilities.History;
+import com.amaze.filemanager.database.models.utilities.SftpEntry;
+import com.amaze.filemanager.database.models.utilities.SmbEntry;
 import com.amaze.filemanager.filesystem.ssh.SshClientUtils;
 import com.amaze.filemanager.utils.SmbUtil;
 import com.amaze.filemanager.utils.application.AppConfig;
@@ -22,8 +24,9 @@ import java.io.File;
 import java.io.IOException;
 import java.security.GeneralSecurityException;
 import java.util.ArrayList;
-import java.util.List;
+import java.util.Arrays;
 import java.util.LinkedList;
+import java.util.List;
 
 /**
  * Created by Vishal on 29-05-2017.
@@ -33,138 +36,14 @@ import java.util.LinkedList;
  * Try to use these functions from a background thread
  */
 
-public class UtilsHandler extends SQLiteOpenHelper {
+public class UtilsHandler  {
 
     private Context context;
 
-    private static final String DATABASE_NAME = "utilities.db";
-    private static final int DATABASE_VERSION = 3;  // increment only when making change in schema
-
-    private static final String TABLE_HISTORY = "history";
-    private static final String TABLE_HIDDEN = "hidden";
-    private static final String TABLE_LIST = "list";
-    private static final String TABLE_GRID = "grid";
-    private static final String TABLE_BOOKMARKS = "bookmarks";
-    private static final String TABLE_SMB = "smb";
-    private static final String TABLE_SFTP = "sftp";
-
-    private static final String COLUMN_ID = "_id";
-    private static final String COLUMN_PATH = "path";
-    private static final String COLUMN_NAME = "name";
-    private static final String COLUMN_HOST_PUBKEY = "pub_key";
-    private static final String COLUMN_PRIVATE_KEY_NAME = "ssh_key_name";
-    private static final String COLUMN_PRIVATE_KEY = "ssh_key";
-    private final String TEMP_TABLE_PREFIX ="temp_";
-
-    private String queryHistory = "CREATE TABLE IF NOT EXISTS " + TABLE_HISTORY + " ("
-            + COLUMN_ID + " INTEGER PRIMARY KEY,"
-            + COLUMN_PATH + " TEXT UNIQUE"
-            + ");";
-
-    private String queryHidden = "CREATE TABLE IF NOT EXISTS " + TABLE_HIDDEN + " ("
-            + COLUMN_ID + " INTEGER PRIMARY KEY,"
-            + COLUMN_PATH + " TEXT UNIQUE"
-            + ");";
-
-    private String queryList = "CREATE TABLE IF NOT EXISTS " + TABLE_LIST + " ("
-            + COLUMN_ID + " INTEGER PRIMARY KEY,"
-            + COLUMN_PATH + " TEXT UNIQUE"
-            + ");";
-
-    private String queryGrid = "CREATE TABLE IF NOT EXISTS " + TABLE_GRID + " ("
-            + COLUMN_ID + " INTEGER PRIMARY KEY,"
-            + COLUMN_PATH + " TEXT UNIQUE"
-            + ");";
-
-    private String queryBookmarks = "CREATE TABLE IF NOT EXISTS " + TABLE_BOOKMARKS + " ("
-            + COLUMN_ID + " INTEGER PRIMARY KEY,"
-            + COLUMN_NAME + " TEXT,"
-            + COLUMN_PATH + " TEXT UNIQUE"
-            + ");";
-
-    private String querySmb = "CREATE TABLE IF NOT EXISTS " + TABLE_SMB + " ("
-            + COLUMN_ID + " INTEGER PRIMARY KEY,"
-            + COLUMN_NAME + " TEXT,"
-            + COLUMN_PATH + " TEXT UNIQUE"
-            + ");";
-
-    private static final String querySftp = "CREATE TABLE IF NOT EXISTS " + TABLE_SFTP + " ("
-            + COLUMN_ID + " INTEGER PRIMARY KEY,"
-            + COLUMN_NAME + " TEXT,"
-            + COLUMN_PATH + " TEXT UNIQUE,"
-            + COLUMN_HOST_PUBKEY + " TEXT,"
-            + COLUMN_PRIVATE_KEY_NAME + " TEXT,"
-            + COLUMN_PRIVATE_KEY + " TEXT"
-            + ");";
-
     public UtilsHandler(Context context) {
-        super(context, DATABASE_NAME, null, DATABASE_VERSION);
         this.context = context;
     }
 
-    @Override
-    public void onCreate(SQLiteDatabase db) {
-        db.execSQL(queryHistory);
-        db.execSQL(queryHidden);
-        db.execSQL(queryList);
-        db.execSQL(queryGrid);
-        db.execSQL(queryBookmarks);
-        db.execSQL(querySmb);
-        db.execSQL(querySftp);
-    }
-
-    @Override
-    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-        switch(oldVersion){
-            case 1:
-                db.execSQL(querySftp);
-            case 2:
-                String backupTable = TEMP_TABLE_PREFIX + TABLE_HISTORY;
-                db.execSQL(queryHistory.replace(TABLE_HISTORY, backupTable));
-                db.execSQL("INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_HISTORY + " group by path;");
-                db.execSQL("DROP TABLE " + TABLE_HISTORY + ";");
-                db.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_HISTORY + ";");
-
-                backupTable = TEMP_TABLE_PREFIX + TABLE_HIDDEN;
-                db.execSQL(queryHidden.replace(TABLE_HIDDEN, backupTable));
-                db.execSQL("INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_HIDDEN + " group by path;");
-                db.execSQL("DROP TABLE " + TABLE_HIDDEN + ";");
-                db.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_HIDDEN + ";");
-
-                backupTable = TEMP_TABLE_PREFIX + TABLE_LIST;
-                db.execSQL(queryList.replace(TABLE_LIST, backupTable));
-                db.execSQL("INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_LIST + " group by path;");
-                db.execSQL("DROP TABLE " + TABLE_LIST + ";");
-                db.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_LIST + ";");
-
-                backupTable = TEMP_TABLE_PREFIX + TABLE_GRID;
-                db.execSQL(queryGrid.replace(TABLE_GRID, backupTable));
-                db.execSQL("INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_GRID + " group by path;");
-                db.execSQL("DROP TABLE " + TABLE_GRID + ";");
-                db.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_GRID + ";");
-
-                backupTable = TEMP_TABLE_PREFIX + TABLE_BOOKMARKS;
-                db.execSQL(queryBookmarks.replace(TABLE_BOOKMARKS, backupTable));
-                db.execSQL("INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_BOOKMARKS + " group by path;");
-                db.execSQL("DROP TABLE " + TABLE_BOOKMARKS + ";");
-                db.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_BOOKMARKS + ";");
-
-                backupTable = TEMP_TABLE_PREFIX + TABLE_SMB;
-                db.execSQL(querySmb.replace(TABLE_SMB, backupTable));
-                db.execSQL("INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_SMB + " group by path;");
-                db.execSQL("DROP TABLE " + TABLE_SMB + ";");
-                db.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_SMB + ";");
-
-                backupTable = TEMP_TABLE_PREFIX + TABLE_SFTP;
-                db.execSQL(querySftp.replace(TABLE_SFTP, backupTable));
-                db.execSQL("INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_SFTP + " group by path;");
-                db.execSQL("DROP TABLE " + TABLE_SFTP + ";");
-                db.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_SFTP + ";");
-            default:
-                break;
-        }
-    }
-
     public enum Operation {
         HISTORY,
         HIDDEN,
@@ -179,18 +58,30 @@ public class UtilsHandler extends SQLiteOpenHelper {
         AppConfig.runInBackground(() -> {
             switch (operationData.type) {
                 case HIDDEN:
+                    UtilitiesDatabase.getInstance().hiddenEntryDao().insert(new Hidden(operationData.path));
+                    break;
                 case HISTORY:
+                    UtilitiesDatabase.getInstance().historyEntryDao().insert(new History(operationData.path));
+                    break;
                 case LIST:
+                    UtilitiesDatabase.getInstance().listEntryDao().insert(new com.amaze.filemanager.database.models.utilities.List(operationData.path));
+                    break;
                 case GRID:
-                    setPath(operationData.type, operationData.path);
+                    UtilitiesDatabase.getInstance().gridEntryDao().insert(new Grid(operationData.path));
                     break;
                 case BOOKMARKS:
+                    UtilitiesDatabase.getInstance().bookmarkEntryDao().insert(new Bookmark(operationData.name, operationData.path));
+                    break;
                 case SMB:
-                    setPath(operationData.type, operationData.name, operationData.path);
+                    UtilitiesDatabase.getInstance().smbEntryDao().insert(new SmbEntry(operationData.name, operationData.path));
                     break;
                 case SFTP:
-                    addSsh(operationData.name, operationData.path, operationData.hostKey,
-                            operationData.sshKeyName, operationData.sshKey);
+                    UtilitiesDatabase.getInstance().sftpEntryDao()
+                            .insert(new SftpEntry(operationData.path,
+                                    operationData.name,
+                                    operationData.hostKey,
+                                    operationData.sshKeyName,
+                                    operationData.sshKey));
                     break;
                 default:
                     throw new IllegalStateException("Unidentified operation!");
@@ -202,10 +93,16 @@ public class UtilsHandler extends SQLiteOpenHelper {
         AppConfig.runInBackground(() -> {
             switch (operationData.type) {
                 case HIDDEN:
+                    UtilitiesDatabase.getInstance().hiddenEntryDao().deleteByPath(operationData.path);
+                    break;
                 case HISTORY:
+                    UtilitiesDatabase.getInstance().historyEntryDao().deleteByPath(operationData.path);
+                    break;
                 case LIST:
+                    UtilitiesDatabase.getInstance().listEntryDao().deleteByPath(operationData.path);
+                    break;
                 case GRID:
-                    removePath(operationData.type, operationData.path);
+                    UtilitiesDatabase.getInstance().gridEntryDao().deleteByPath(operationData.path);
                     break;
                 case BOOKMARKS:
                     removeBookmarksPath(operationData.name, operationData.path);
@@ -238,227 +135,116 @@ public class UtilsHandler extends SQLiteOpenHelper {
         }
     }
 
-    public void addSsh(String name, String path, String hostKey, String sshKeyName, String sshKey) {
-        SQLiteDatabase database = getWritableDatabase();
-        ContentValues values = new ContentValues();
-        values.put(COLUMN_NAME, name);
-        values.put(COLUMN_PATH, path);
-        values.put(COLUMN_HOST_PUBKEY, hostKey);
-        if(sshKey != null && !"".equals(sshKey))
-        {
-            values.put(COLUMN_PRIVATE_KEY_NAME, sshKeyName);
-            values.put(COLUMN_PRIVATE_KEY, sshKey);
-        }
-
-        database.insert(getTableForOperation(Operation.SFTP), null, values);
-    }
-
     public void updateSsh(String connectionName, String oldConnectionName, String path,
                           String hostKey, String sshKeyName, String sshKey) {
 
-        SQLiteDatabase database = getWritableDatabase();
+        SftpEntry entry = UtilitiesDatabase.getInstance().sftpEntryDao().findByName(oldConnectionName);
+
+        entry.name = connectionName;
+        entry.path = path;
+        entry.hostKey = hostKey;
 
-        ContentValues values = new ContentValues();
-        values.put(COLUMN_NAME, connectionName);
-        values.put(COLUMN_PATH, path);
-        values.put(COLUMN_HOST_PUBKEY, hostKey);
         if(sshKeyName != null && sshKey != null) {
-            values.put(COLUMN_PRIVATE_KEY_NAME, sshKeyName);
-            values.put(COLUMN_PRIVATE_KEY, sshKey);
+            entry.sshKeyName = sshKeyName;
+            entry.sshKey = sshKey;
         }
 
-        database.update(getTableForOperation(Operation.SFTP), values, String.format("%s=?", COLUMN_NAME),
-                new String[]{oldConnectionName});
+        UtilitiesDatabase.getInstance().sftpEntryDao().update(entry);
     }
 
     public LinkedList<String> getHistoryLinkedList() {
-        SQLiteDatabase sqLiteDatabase = getReadableDatabase();
-        Cursor cursor = sqLiteDatabase.query(getTableForOperation(Operation.HISTORY), null,
-                null, null, null, null, null);
-
         LinkedList<String> paths = new LinkedList<>();
-        boolean hasNext = cursor.moveToFirst();
-        while (hasNext) {
-            paths.push(cursor.getString(cursor.getColumnIndex(COLUMN_PATH)));
-            hasNext = cursor.moveToNext();
+        for(History history : UtilitiesDatabase.getInstance().historyEntryDao().list()) {
+            paths.add(history.path);
         }
-        cursor.close();
-
         return paths;
     }
 
     public ConcurrentRadixTree<VoidValue> getHiddenFilesConcurrentRadixTree() {
         ConcurrentRadixTree<VoidValue> paths = new ConcurrentRadixTree<>(new DefaultCharArrayNodeFactory());
 
-        Cursor cursor = getReadableDatabase().query(getTableForOperation(Operation.HIDDEN), null,
-                null, null, null, null, null);
-        boolean hasNext = cursor.moveToFirst();
-        while (hasNext) {
-            paths.put(cursor.getString(cursor.getColumnIndex(COLUMN_PATH)), VoidValue.SINGLETON);
-            hasNext = cursor.moveToNext();
+        for(String path : UtilitiesDatabase.getInstance().hiddenEntryDao().listPaths()) {
+            paths.put(path, VoidValue.SINGLETON);
         }
-        cursor.close();
-
         return paths;
     }
 
     public ArrayList<String> getListViewList() {
-        return getPath(Operation.LIST);
+        return new ArrayList<>(Arrays.asList(UtilitiesDatabase.getInstance().listEntryDao().listPaths()));
     }
 
     public ArrayList<String> getGridViewList() {
-        return getPath(Operation.GRID);
+        return new ArrayList<>(Arrays.asList(UtilitiesDatabase.getInstance().gridEntryDao().listPaths()));
     }
 
     public ArrayList<String[]> getBookmarksList() {
 
-        SQLiteDatabase sqLiteDatabase = getReadableDatabase();
-
-        Cursor cursor = sqLiteDatabase.query(getTableForOperation(Operation.BOOKMARKS), null,
-                null, null, null, null, null);
-
-        boolean hasNext = cursor.moveToFirst();
         ArrayList<String[]> row = new ArrayList<>();
-        while (hasNext) {
-            row.add(new String[] {
-                    cursor.getString(cursor.getColumnIndex(COLUMN_NAME)),
-                    cursor.getString(cursor.getColumnIndex(COLUMN_PATH))
-            });
-            hasNext = cursor.moveToNext();
+        for(Bookmark bookmark : UtilitiesDatabase.getInstance().bookmarkEntryDao().list()) {
+            row.add(new String[]{bookmark.name, bookmark.path});
         }
-        cursor.close();
         return row;
     }
 
     public ArrayList<String[]> getSmbList() {
-        SQLiteDatabase sqLiteDatabase = getReadableDatabase();
+        ArrayList<String[]> retval = new ArrayList<String[]>();
+        for(SmbEntry entry : UtilitiesDatabase.getInstance().smbEntryDao().list()) {
 
-        Cursor cursor = sqLiteDatabase.query(getTableForOperation(Operation.SMB), null,
-                null, null, null, null, null);
-        boolean hasNext = cursor.moveToFirst();
-        ArrayList<String[]> row = new ArrayList<>();
-        while (hasNext) {
             try {
-                row.add(new String[] {
-                        cursor.getString(cursor.getColumnIndex(COLUMN_NAME)),
-                        SmbUtil.getSmbDecryptedPath(context, cursor.getString(cursor.getColumnIndex(COLUMN_PATH)))
-                });
+                String path = SmbUtil.getSmbDecryptedPath(context, entry.path);
+                retval.add(new String[] { entry.name, path });
             } catch (GeneralSecurityException | IOException e) {
                 e.printStackTrace();
 
                 // failing to decrypt the path, removing entry from database
                 Toast.makeText(context, context.getString(R.string.failed_smb_decrypt_path), Toast.LENGTH_LONG).show();
-                removeSmbPath(cursor.getString(cursor.getColumnIndex(COLUMN_NAME)),
-                        "");
+                removeSmbPath(entry.name,"");
                 continue;
             }
-            hasNext = cursor.moveToNext();
+
         }
-        cursor.close();
-        return row;
+        return retval;
     }
 
     public List<String[]> getSftpList()
     {
-        SQLiteDatabase sqLiteDatabase = getReadableDatabase();
-
-        Cursor cursor = sqLiteDatabase.query(getTableForOperation(Operation.SFTP),
-                new String[]{COLUMN_NAME,COLUMN_PATH},
-                null, null, null, null, COLUMN_ID);
-
-        boolean hasNext = cursor.moveToFirst();
         ArrayList<String[]> retval = new ArrayList<String[]>();
-        while(hasNext)
-        {
-            String path = SshClientUtils.decryptSshPathAsNecessary(cursor.getString(cursor.getColumnIndex(COLUMN_PATH)));
+        for(SftpEntry entry : UtilitiesDatabase.getInstance().sftpEntryDao().list()) {
+            String path = SshClientUtils.decryptSshPathAsNecessary(entry.path);
 
             if(path == null) {
-                Log.e("ERROR", "Error decrypting path: " + cursor.getString(cursor.getColumnIndex(COLUMN_PATH)));
-
+                Log.e("ERROR", "Error decrypting path: " + entry.path);
                 // failing to decrypt the path, removing entry from database
                 Toast.makeText(context,
                         context.getString(R.string.failed_smb_decrypt_path),
                         Toast.LENGTH_LONG).show();
-//                    removeSmbPath(cursor.getString(cursor.getColumnIndex(COLUMN_NAME)),
-//                            "");
-                continue;
             } else {
-                retval.add(new String[]{
-                    cursor.getString(cursor.getColumnIndex(COLUMN_NAME)),
-                    path
-                });
+                retval.add(new String[]{entry.name, path});
             }
-            hasNext = cursor.moveToNext();
         }
-        cursor.close();
         return retval;
     }
 
     public String getSshHostKey(String uri)
     {
         uri = SshClientUtils.encryptSshPathAsNecessary(uri);
-        if(uri != null)
-        {
-            SQLiteDatabase sqLiteDatabase = getReadableDatabase();
-
-            Cursor result = sqLiteDatabase.query(TABLE_SFTP, new String[]{COLUMN_HOST_PUBKEY},
-                    COLUMN_PATH + " = ?", new String[]{uri},
-                    null, null, null);
-            if(result.moveToFirst())
-            {
-                String retval = result.getString(0);
-                result.close();
-                return retval;
-            }
-            else
-            {
-                result.close();
-                return null;
-            }
-        }
-        else
-        {
+        if(uri != null) {
+            return UtilitiesDatabase.getInstance().sftpEntryDao().getSshHostKey(uri);
+        } else {
             return null;
         }
     }
 
-    public String getSshAuthPrivateKeyName(String uri)
-    {
-        return getSshAuthPrivateKeyColumn(uri, COLUMN_PRIVATE_KEY_NAME);
-    }
-
-    public String getSshAuthPrivateKey(String uri)
-    {
-        return getSshAuthPrivateKeyColumn(uri, COLUMN_PRIVATE_KEY);
+    public String getSshAuthPrivateKeyName(String uri) {
+        return UtilitiesDatabase.getInstance().sftpEntryDao().getSshAuthPrivateKeyName(uri);
     }
 
-    private String getSshAuthPrivateKeyColumn(String uri, String columnName) {
-        //If connection is using key authentication, no need to decrypt the path at all
-        SQLiteDatabase sqLiteDatabase = getReadableDatabase();
-        Cursor result = sqLiteDatabase.query(TABLE_SFTP, new String[]{columnName},
-                COLUMN_PATH + " = ?", new String[]{uri},
-                null, null, null);
-        if(result.moveToFirst())
-        {
-            try {
-                return result.getString(0);
-            }
-            finally {
-                result.close();
-            }
-        }
-        else {
-            result.close();
-            return null;
-        }
+    public String getSshAuthPrivateKey(String uri) {
+        return UtilitiesDatabase.getInstance().sftpEntryDao().getSshAuthPrivateKey(uri);
     }
 
     private void removeBookmarksPath(String name, String path) {
-
-        SQLiteDatabase sqLiteDatabase = getWritableDatabase();
-
-        sqLiteDatabase.delete(TABLE_BOOKMARKS, COLUMN_NAME + " = ? AND " + COLUMN_PATH + " = ?",
-                new String[] {name, path});
+        UtilitiesDatabase.getInstance().bookmarkEntryDao().deleteByNameAndPath(name, path);
     }
 
     /**
@@ -467,156 +253,42 @@ public class UtilsHandler extends SQLiteOpenHelper {
      *             we must encrypt it's password fiend first first
      */
     private void removeSmbPath(String name, String path) {
-
-        SQLiteDatabase sqLiteDatabase = getWritableDatabase();
-
-        try {
-            if (path.equals("")) {
-                // we don't have a path, remove the entry with this name
-                throw new IOException();
-            }
-
-            sqLiteDatabase.delete(TABLE_SMB, COLUMN_NAME + " = ? AND " + COLUMN_PATH + " = ?",
-                    new String[] {name, SmbUtil.getSmbEncryptedPath(context, path)});
-        } catch (IOException | GeneralSecurityException e) {
-            e.printStackTrace();
-            // force remove entry, we end up deleting all entries with same name
-
-            sqLiteDatabase.delete(TABLE_SMB, COLUMN_NAME + " = ?",
-                    new String[] {name});
-        }
+        if(path.equals(""))
+            UtilitiesDatabase.getInstance().smbEntryDao().deleteByName(name);
+        else
+            UtilitiesDatabase.getInstance().smbEntryDao().deleteByNameAndPath(name, path);
     }
 
     private void removeSftpPath(String name, String path) {
-
-        SQLiteDatabase sqLiteDatabase = getWritableDatabase();
-
-        try
-        {
-            if (path.equals("")) {
-                // we don't have a path, remove the entry with this name
-                throw new IOException();
-            }
-
-            sqLiteDatabase.delete(TABLE_SFTP, COLUMN_NAME + " = ? AND " + COLUMN_PATH + " = ?",
-                    new String[] {name, SshClientUtils.encryptSshPathAsNecessary(path)});
-
-        }
-        catch (IOException e)
-        {
-            e.printStackTrace();
-            // force remove entry, we end up deleting all entries with same name
-            sqLiteDatabase.delete(TABLE_SFTP, COLUMN_NAME + " = ?",
-                    new String[] {name});
-        }
+        if(path.equals(""))
+            UtilitiesDatabase.getInstance().sftpEntryDao().deleteByName(name);
+        else
+            UtilitiesDatabase.getInstance().sftpEntryDao().deleteByNameAndPath(name, path);
     }
 
     public void renameBookmark(String oldName, String oldPath, String newName, String newPath) {
-        renamePath(Operation.BOOKMARKS, oldName, oldPath, newName, newPath);
-    }
+        Bookmark bookmark = UtilitiesDatabase.getInstance().bookmarkEntryDao().findByNameAndPath(oldName, oldPath);
+        bookmark.name = newName;
+        bookmark.path = newPath;
 
-    public void renameSMB(String oldName, String oldPath, String newName, String newPath) {
-        renamePath(Operation.SMB, oldName, oldPath, newName, newPath);
-    }
-
-    private void setPath(Operation operation, String path) {
-        SQLiteDatabase sqLiteDatabase = getWritableDatabase();
-        ContentValues contentValues = new ContentValues();
-        contentValues.put(COLUMN_PATH, path);
-
-        if(Operation.HISTORY.equals(operation))
-            sqLiteDatabase.delete(getTableForOperation(operation), "path = ?", new String[]{path});
-
-        sqLiteDatabase.insert(getTableForOperation(operation), null, contentValues);
+        UtilitiesDatabase.getInstance().bookmarkEntryDao().update(bookmark);
     }
 
-    private void setPath(Operation operation, String name, String path) {
-        SQLiteDatabase sqLiteDatabase = getWritableDatabase();
-        ContentValues contentValues = new ContentValues();
-        contentValues.put(COLUMN_NAME, name);
-        contentValues.put(COLUMN_PATH, path);
-
-        sqLiteDatabase.insert(getTableForOperation(operation), null, contentValues);
-    }
-
-    private ArrayList<String> getPath(Operation operation) {
-
-        SQLiteDatabase sqLiteDatabase = getReadableDatabase();
-        Cursor cursor = sqLiteDatabase.query(getTableForOperation(operation), null,
-                null, null, null, null, null);
-
-        ArrayList<String> paths = new ArrayList<>();
-
-        switch (operation) {
-            case LIST:
-            case GRID:
-                boolean hasNext = cursor.moveToFirst();
-                while (hasNext) {
-                    paths.add(cursor.getString(cursor.getColumnIndex(COLUMN_PATH)));
-                    hasNext = cursor.moveToNext();
-                }
-                cursor.close();
-                return paths;
-            default:
-                return null;
-        }
-    }
-
-    private void removePath(Operation operation, String path) {
-
-        SQLiteDatabase sqLiteDatabase = getWritableDatabase();
+    public void renameSMB(String oldName, String oldPath, String newName, String newPath) {
+        SmbEntry smbEntry = UtilitiesDatabase.getInstance().smbEntryDao().findByNameAndPath(oldName, oldPath);
+        smbEntry.name = newName;
+        smbEntry.path = newPath;
 
-        sqLiteDatabase.delete(getTableForOperation(operation), COLUMN_PATH + "=?",
-                new String[] {path});
+        UtilitiesDatabase.getInstance().smbEntryDao().update(smbEntry);
     }
 
     public void clearTable(Operation table) {
-        getWritableDatabase().delete(getTableForOperation(table), null, null);
-    }
-
-    private void renamePath(Operation operation, String name, String path) {
-        SQLiteDatabase sqLiteDatabase = getWritableDatabase();
-        ContentValues contentValues = new ContentValues();
-        contentValues.put(COLUMN_NAME, name);
-        contentValues.put(COLUMN_PATH, path);
-
-        sqLiteDatabase.update(getTableForOperation(operation), contentValues,
-                COLUMN_PATH + "=?", new String[] {name});
-    }
-
-    private void renamePath(Operation operation, String oldName, String oldPath,
-                               String newName, String newPath) {
-        SQLiteDatabase sqLiteDatabase = getWritableDatabase();
-        ContentValues contentValues = new ContentValues();
-        contentValues.put(COLUMN_NAME, newName);
-        contentValues.put(COLUMN_PATH, newPath);
-
-        sqLiteDatabase.update(getTableForOperation(operation), contentValues, COLUMN_NAME
-                + "=? AND " + COLUMN_PATH + "=?", new String[] {oldName, oldPath});
-    }
-
-    /**
-     * Return table string for corresponding {@link Operation}
-     */
-    private String getTableForOperation(Operation operation) {
-
-        switch (operation) {
+        switch(table) {
             case HISTORY:
-                return TABLE_HISTORY;
-            case HIDDEN:
-                return TABLE_HIDDEN;
-            case LIST:
-                return TABLE_LIST;
-            case GRID:
-                return TABLE_GRID;
-            case BOOKMARKS:
-                return TABLE_BOOKMARKS;
-            case SMB:
-                return TABLE_SMB;
-            case SFTP:
-                return TABLE_SFTP;
+                UtilitiesDatabase.getInstance().historyEntryDao().clear();
+                break;
             default:
-                return null;
+                break;
         }
     }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/database/daos/BookmarkEntryDao.java b/app/src/main/java/com/amaze/filemanager/database/daos/BookmarkEntryDao.java
new file mode 100644
index 000000000..9a57fe01e
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/daos/BookmarkEntryDao.java
@@ -0,0 +1,31 @@
+package com.amaze.filemanager.database.daos;
+
+import androidx.room.Dao;
+import androidx.room.Insert;
+import androidx.room.Query;
+import androidx.room.Update;
+
+import com.amaze.filemanager.database.models.utilities.Bookmark;
+
+import static com.amaze.filemanager.database.UtilitiesDatabase.COLUMN_NAME;
+import static com.amaze.filemanager.database.UtilitiesDatabase.COLUMN_PATH;
+import static com.amaze.filemanager.database.UtilitiesDatabase.TABLE_BOOKMARKS;
+
+@Dao
+public interface BookmarkEntryDao {
+
+    @Insert
+    public void insert(Bookmark instance);
+
+    @Update
+    public void update(Bookmark instance);
+
+    @Query("SELECT * FROM " + TABLE_BOOKMARKS)
+    public Bookmark[] list();
+
+    @Query("SELECT * FROM " + TABLE_BOOKMARKS + " WHERE " + COLUMN_NAME + " = :name AND " + COLUMN_PATH + " = :path")
+    public Bookmark findByNameAndPath(String name, String path);
+
+    @Query("DELETE FROM " + TABLE_BOOKMARKS + " WHERE " + COLUMN_NAME + " = :name AND " + COLUMN_PATH + " = :path")
+    public void deleteByNameAndPath(String name, String path);
+}
diff --git a/app/src/main/java/com/amaze/filemanager/database/daos/CloudEntryDao.java b/app/src/main/java/com/amaze/filemanager/database/daos/CloudEntryDao.java
new file mode 100644
index 000000000..a7b7260d5
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/daos/CloudEntryDao.java
@@ -0,0 +1,51 @@
+/*
+ * CloudEntryDao.java
+ *
+ * Copyright (C) 2020 Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.database.daos;
+
+import androidx.room.Dao;
+import androidx.room.Delete;
+import androidx.room.Insert;
+import androidx.room.Query;
+import androidx.room.Update;
+
+import com.amaze.filemanager.database.models.explorer.CloudEntry;
+
+@Dao
+public interface CloudEntryDao {
+
+    @Insert
+    public void insert(CloudEntry entry);
+
+    @Query("SELECT * FROM cloud WHERE service = :serviceType")
+    public CloudEntry findByServiceType(int serviceType);
+
+    @Query("SELECT * FROM cloud")
+    public CloudEntry[] list();
+
+    @Update
+    public void update(CloudEntry entry);
+
+    @Delete
+    public void delete(CloudEntry entry);
+
+
+}
diff --git a/app/src/main/java/com/amaze/filemanager/database/daos/EncryptedEntryDao.java b/app/src/main/java/com/amaze/filemanager/database/daos/EncryptedEntryDao.java
new file mode 100644
index 000000000..356a3d0da
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/daos/EncryptedEntryDao.java
@@ -0,0 +1,49 @@
+/*
+ * EncryptedEntryDao.java
+ *
+ * Copyright (C) 2020 Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.database.daos;
+
+import androidx.room.Dao;
+import androidx.room.Delete;
+import androidx.room.Insert;
+import androidx.room.Query;
+import androidx.room.Update;
+
+import com.amaze.filemanager.database.models.explorer.EncryptedEntry;
+
+@Dao
+public interface EncryptedEntryDao {
+
+    @Insert
+    public void insert(EncryptedEntry entry);
+
+    @Query("SELECT * FROM encrypted WHERE path = :path")
+    public EncryptedEntry select(String path);
+
+    @Update
+    public void update(EncryptedEntry entry);
+
+    @Delete
+    public void delete(EncryptedEntry entry);
+
+    @Query("SELECT * FROM encrypted")
+    public EncryptedEntry[] list();
+}
diff --git a/app/src/main/java/com/amaze/filemanager/database/daos/GridEntryDao.java b/app/src/main/java/com/amaze/filemanager/database/daos/GridEntryDao.java
new file mode 100644
index 000000000..a0f39f23a
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/daos/GridEntryDao.java
@@ -0,0 +1,27 @@
+package com.amaze.filemanager.database.daos;
+
+import androidx.room.Dao;
+import androidx.room.Insert;
+import androidx.room.Query;
+import androidx.room.Update;
+
+import com.amaze.filemanager.database.models.utilities.Grid;
+
+import static com.amaze.filemanager.database.UtilitiesDatabase.COLUMN_PATH;
+import static com.amaze.filemanager.database.UtilitiesDatabase.TABLE_GRID;
+
+@Dao
+public interface GridEntryDao {
+
+    @Insert
+    public void insert(Grid instance);
+
+    @Update
+    public void update(Grid instance);
+
+    @Query("SELECT " + COLUMN_PATH + " FROM " + TABLE_GRID)
+    public String[] listPaths();
+
+    @Query("DELETE FROM " + TABLE_GRID + " WHERE " + COLUMN_PATH + " = :path")
+    public void deleteByPath(String path);
+}
diff --git a/app/src/main/java/com/amaze/filemanager/database/daos/HiddenEntryDao.java b/app/src/main/java/com/amaze/filemanager/database/daos/HiddenEntryDao.java
new file mode 100644
index 000000000..ef6fa3bf1
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/daos/HiddenEntryDao.java
@@ -0,0 +1,27 @@
+package com.amaze.filemanager.database.daos;
+
+import androidx.room.Dao;
+import androidx.room.Insert;
+import androidx.room.Query;
+import androidx.room.Update;
+
+import com.amaze.filemanager.database.models.utilities.Hidden;
+
+import static com.amaze.filemanager.database.UtilitiesDatabase.COLUMN_PATH;
+import static com.amaze.filemanager.database.UtilitiesDatabase.TABLE_HIDDEN;
+
+@Dao
+public interface HiddenEntryDao {
+
+    @Insert
+    public void insert(Hidden instance);
+
+    @Update
+    public void update(Hidden instance);
+
+    @Query("SELECT " + COLUMN_PATH + " FROM " + TABLE_HIDDEN)
+    public String[] listPaths();
+
+    @Query("DELETE FROM " + TABLE_HIDDEN + " WHERE " + COLUMN_PATH + " = :path")
+    public void deleteByPath(String path);
+}
diff --git a/app/src/main/java/com/amaze/filemanager/database/daos/HistoryEntryDao.java b/app/src/main/java/com/amaze/filemanager/database/daos/HistoryEntryDao.java
new file mode 100644
index 000000000..b0ce5a583
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/daos/HistoryEntryDao.java
@@ -0,0 +1,31 @@
+package com.amaze.filemanager.database.daos;
+
+import androidx.room.Dao;
+import androidx.room.Insert;
+import androidx.room.OnConflictStrategy;
+import androidx.room.Query;
+import androidx.room.Update;
+
+import com.amaze.filemanager.database.models.utilities.History;
+
+import static com.amaze.filemanager.database.UtilitiesDatabase.COLUMN_PATH;
+import static com.amaze.filemanager.database.UtilitiesDatabase.TABLE_HISTORY;
+
+@Dao
+public interface HistoryEntryDao {
+
+    @Insert(onConflict = OnConflictStrategy.REPLACE)
+    public void insert(History instance);
+
+    @Update
+    public void update(History instance);
+
+    @Query("SELECT * FROM " + TABLE_HISTORY)
+    public History[] list();
+
+    @Query("DELETE FROM " + TABLE_HISTORY + " WHERE " + COLUMN_PATH + " = :path")
+    public void deleteByPath(String path);
+
+    @Query("DELETE FROM " + TABLE_HISTORY)
+    public void clear();
+}
diff --git a/app/src/main/java/com/amaze/filemanager/database/daos/ListEntryDao.java b/app/src/main/java/com/amaze/filemanager/database/daos/ListEntryDao.java
new file mode 100644
index 000000000..4f2373530
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/daos/ListEntryDao.java
@@ -0,0 +1,28 @@
+package com.amaze.filemanager.database.daos;
+
+import androidx.room.Dao;
+import androidx.room.Insert;
+import androidx.room.OnConflictStrategy;
+import androidx.room.Query;
+import androidx.room.Update;
+
+import com.amaze.filemanager.database.models.utilities.List;
+
+import static com.amaze.filemanager.database.UtilitiesDatabase.COLUMN_PATH;
+import static com.amaze.filemanager.database.UtilitiesDatabase.TABLE_LIST;
+
+@Dao
+public interface ListEntryDao {
+
+    @Insert(onConflict = OnConflictStrategy.REPLACE)
+    public void insert(List instance);
+
+    @Update
+    public void update(List instance);
+
+    @Query("SELECT " + COLUMN_PATH + " FROM " + TABLE_LIST)
+    public String[] listPaths();
+
+    @Query("DELETE FROM " + TABLE_LIST + " WHERE " + COLUMN_PATH + " = :path")
+    public void deleteByPath(String path);
+}
diff --git a/app/src/main/java/com/amaze/filemanager/database/daos/SftpEntryDao.java b/app/src/main/java/com/amaze/filemanager/database/daos/SftpEntryDao.java
new file mode 100644
index 000000000..e02cb1f9f
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/daos/SftpEntryDao.java
@@ -0,0 +1,49 @@
+package com.amaze.filemanager.database.daos;
+
+import androidx.room.Dao;
+import androidx.room.Insert;
+import androidx.room.Query;
+import androidx.room.Update;
+
+import com.amaze.filemanager.database.models.utilities.SftpEntry;
+
+import static com.amaze.filemanager.database.UtilitiesDatabase.COLUMN_HOST_PUBKEY;
+import static com.amaze.filemanager.database.UtilitiesDatabase.COLUMN_NAME;
+import static com.amaze.filemanager.database.UtilitiesDatabase.COLUMN_PATH;
+import static com.amaze.filemanager.database.UtilitiesDatabase.COLUMN_PRIVATE_KEY;
+import static com.amaze.filemanager.database.UtilitiesDatabase.COLUMN_PRIVATE_KEY_NAME;
+import static com.amaze.filemanager.database.UtilitiesDatabase.TABLE_SFTP;
+
+@Dao
+public interface SftpEntryDao {
+
+    @Insert
+    public void insert(SftpEntry instance);
+
+    @Update
+    public void update(SftpEntry instance);
+
+    @Query("SELECT * FROM " + TABLE_SFTP)
+    public SftpEntry[] list();
+
+    @Query("SELECT * FROM " + TABLE_SFTP + " WHERE " + COLUMN_NAME + " = :name AND " + COLUMN_PATH + " = :path")
+    public SftpEntry findByNameAndPath(String name, String path);
+
+    @Query("SELECT * FROM " + TABLE_SFTP + " WHERE " + COLUMN_NAME + " = :name")
+    public SftpEntry findByName(String name);
+
+    @Query("SELECT " + COLUMN_HOST_PUBKEY + " FROM " + TABLE_SFTP + " WHERE PATH = :uri")
+    public String getSshHostKey(String uri);
+
+    @Query("SELECT " + COLUMN_PRIVATE_KEY_NAME + " FROM " + TABLE_SFTP + " WHERE PATH = :uri")
+    public String getSshAuthPrivateKeyName(String uri);
+
+    @Query("SELECT " + COLUMN_PRIVATE_KEY + " FROM " + TABLE_SFTP + " WHERE PATH = :uri")
+    public String getSshAuthPrivateKey(String uri);
+
+    @Query("DELETE FROM " + TABLE_SFTP + " WHERE " + COLUMN_NAME + " = :name")
+    public void deleteByName(String name);
+
+    @Query("DELETE FROM " + TABLE_SFTP + " WHERE " + COLUMN_NAME + " = :name AND " + COLUMN_PATH + " = :path")
+    public void deleteByNameAndPath(String name, String path);
+}
diff --git a/app/src/main/java/com/amaze/filemanager/database/daos/SmbEntryDao.java b/app/src/main/java/com/amaze/filemanager/database/daos/SmbEntryDao.java
new file mode 100644
index 000000000..599d54843
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/daos/SmbEntryDao.java
@@ -0,0 +1,34 @@
+package com.amaze.filemanager.database.daos;
+
+import androidx.room.Dao;
+import androidx.room.Insert;
+import androidx.room.Query;
+import androidx.room.Update;
+
+import com.amaze.filemanager.database.models.utilities.SmbEntry;
+
+import static com.amaze.filemanager.database.UtilitiesDatabase.COLUMN_NAME;
+import static com.amaze.filemanager.database.UtilitiesDatabase.COLUMN_PATH;
+import static com.amaze.filemanager.database.UtilitiesDatabase.TABLE_SMB;
+
+@Dao
+public interface SmbEntryDao {
+
+    @Insert
+    public void insert(SmbEntry instance);
+
+    @Update
+    public void update(SmbEntry instance);
+
+    @Query("SELECT * FROM " + TABLE_SMB)
+    public SmbEntry[] list();
+
+    @Query("SELECT * FROM " + TABLE_SMB + " WHERE " + COLUMN_NAME + " = :name AND " + COLUMN_PATH + " = :path")
+    public SmbEntry findByNameAndPath(String name, String path);
+
+    @Query("DELETE FROM " + TABLE_SMB + " WHERE " + COLUMN_NAME + " = :name")
+    public void deleteByName(String name);
+
+    @Query("DELETE FROM " + TABLE_SMB + " WHERE " + COLUMN_NAME + " = :name AND " + COLUMN_PATH + " = :path")
+    public void deleteByNameAndPath(String name, String path);
+}
diff --git a/app/src/main/java/com/amaze/filemanager/database/daos/SortDao.java b/app/src/main/java/com/amaze/filemanager/database/daos/SortDao.java
new file mode 100644
index 000000000..5809325ae
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/daos/SortDao.java
@@ -0,0 +1,49 @@
+/*
+ * SortDao.java
+ *
+ * Copyright (C) 2020 Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.database.daos;
+
+import androidx.room.Dao;
+import androidx.room.Delete;
+import androidx.room.Insert;
+import androidx.room.Query;
+import androidx.room.Update;
+
+import com.amaze.filemanager.database.models.explorer.Sort;
+
+@Dao
+public interface SortDao {
+
+    @Insert
+    public void insert(Sort entity);
+
+    @Query("SELECT * FROM sort WHERE path = :path")
+    public Sort find(String path);
+
+//    @Query("SELECT * FROM sort")
+//    public Sort[] list();
+
+    @Delete
+    public void clear(Sort entity);
+
+    @Update
+    public void update(Sort entity);
+}
diff --git a/app/src/main/java/com/amaze/filemanager/database/daos/TabDao.java b/app/src/main/java/com/amaze/filemanager/database/daos/TabDao.java
new file mode 100644
index 000000000..4e977888d
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/daos/TabDao.java
@@ -0,0 +1,44 @@
+/*
+ * TabDao.java
+ *
+ * Copyright (C) 2020 Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.database.daos;
+
+import androidx.room.Dao;
+import androidx.room.Insert;
+import androidx.room.OnConflictStrategy;
+import androidx.room.Query;
+
+import com.amaze.filemanager.database.models.explorer.Tab;
+
+@Dao
+public interface TabDao {
+    @Insert(onConflict = OnConflictStrategy.REPLACE)
+    public void insertTab(Tab tab);
+
+    @Query("DELETE FROM tab WHERE tab_no IN (1,2);")
+    public void clear();
+
+    @Query("SELECT * FROM tab WHERE tab_no = :tabNo")
+    public Tab find(int tabNo);
+
+    @Query("SELECT * FROM tab")
+    public Tab[] list();
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/amaze/filemanager/database/models/CloudEntry.java b/app/src/main/java/com/amaze/filemanager/database/models/CloudEntry.java
deleted file mode 100644
index ea0a9aaa5..000000000
--- a/app/src/main/java/com/amaze/filemanager/database/models/CloudEntry.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package com.amaze.filemanager.database.models;
-
-import com.amaze.filemanager.utils.OpenMode;
-
-/**
- * Created by vishal on 18/4/17.
- */
-
-public class CloudEntry {
-
-    private int _id;
-    private OpenMode serviceType;
-    private String persistData;
-
-    public CloudEntry() {}
-
-    public CloudEntry(OpenMode serviceType, String persistData) {
-        this.serviceType = serviceType;
-        this.persistData = persistData;
-    }
-
-    public void setId(int _id) {
-        this._id = _id;
-    }
-
-    public int getId() {
-        return this._id;
-    }
-
-    public void setPersistData(String persistData) {
-        this.persistData = persistData;
-    }
-
-    public String getPersistData() {
-        return this.persistData;
-    }
-
-    /**
-     * Set the service type
-     * Support values from {@link com.amaze.filemanager.utils.OpenMode}
-     */
-    public void setServiceType(OpenMode openMode) {
-        this.serviceType = openMode;
-    }
-
-    /**
-     * Returns ordinal value of service from {@link com.amaze.filemanager.utils.OpenMode}
-     */
-    public OpenMode getServiceType() {
-        return this.serviceType;
-    }
-}
diff --git a/app/src/main/java/com/amaze/filemanager/database/models/EncryptedEntry.java b/app/src/main/java/com/amaze/filemanager/database/models/EncryptedEntry.java
deleted file mode 100644
index ea890bc65..000000000
--- a/app/src/main/java/com/amaze/filemanager/database/models/EncryptedEntry.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package com.amaze.filemanager.database.models;
-
-/**
- * Created by vishal on 8/4/17.
- */
-
-public class EncryptedEntry {
-
-    private int _id;
-    private String path, password;
-
-    public EncryptedEntry() {}
-
-    public EncryptedEntry(String path, String password) {
-        this.path = path;
-        this.password = password;
-    }
-
-    public void setId(int _id) {
-        this._id = _id;
-    }
-
-    public int getId() {
-        return this._id;
-    }
-
-    public void setPath(String path) {
-        this.path = path;
-    }
-
-    public String getPath() {
-        return this.path;
-    }
-
-    public void setPassword(String password) {
-        this.password = password;
-    }
-
-    public String getPassword() {
-        return this.password;
-    }
-}
diff --git a/app/src/main/java/com/amaze/filemanager/database/models/Sort.java b/app/src/main/java/com/amaze/filemanager/database/models/StringWrapper.java
similarity index 69%
rename from app/src/main/java/com/amaze/filemanager/database/models/Sort.java
rename to app/src/main/java/com/amaze/filemanager/database/models/StringWrapper.java
index 47fab5a1c..2d05da6a4 100644
--- a/app/src/main/java/com/amaze/filemanager/database/models/Sort.java
+++ b/app/src/main/java/com/amaze/filemanager/database/models/StringWrapper.java
@@ -1,6 +1,7 @@
 /*
- * Copyright (C) 2018 Emmanuel Messulam <emmanuelbendavid@gmail.com>
- * Copyright (C) 2014 Vishal Nehra <vishalmeham2@gmail.com>
+ * StringWrapper.java
+ *
+ * Copyright (C) 2020 Raymond Lai <airwave209gt at gmail.com> and Contributors.
  *
  * This file is part of Amaze File Manager.
  *
@@ -20,16 +21,16 @@
 
 package com.amaze.filemanager.database.models;
 
-/**
- * Created by Ning on 5/28/2018.
- */
-public class Sort {
-    public final String path;
-    public final int type;
+public class StringWrapper {
 
-    public Sort(String path, int type) {
-        this.path = path;
-        this.type = type;
+    public final String value;
+
+    public StringWrapper(String value) {
+        this.value = value;
     }
 
+    @Override
+    public String toString() {
+        return value;
+    }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/database/models/explorer/CloudEntry.java b/app/src/main/java/com/amaze/filemanager/database/models/explorer/CloudEntry.java
new file mode 100644
index 000000000..f769e4ffc
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/models/explorer/CloudEntry.java
@@ -0,0 +1,93 @@
+/*
+ * CloudEntry.java
+ *
+ * Copyright (C) 2017-2020 Vishal Nehra <vishalmeham2@gmail.com>,
+ * John Carlson <jawnnypoo@gmail.com>, Emmanuel Messulam <emmanuelbendavid@gmail.com>,
+ * Raymond Lai <airwave209gt at gmail.com> and contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.database.models.explorer;
+
+import androidx.room.ColumnInfo;
+import androidx.room.Entity;
+import androidx.room.PrimaryKey;
+import androidx.room.TypeConverters;
+
+import com.amaze.filemanager.database.ExplorerDatabase;
+import com.amaze.filemanager.database.models.StringWrapper;
+import com.amaze.filemanager.database.typeconverters.EncryptedStringTypeConverter;
+import com.amaze.filemanager.database.typeconverters.OpenModeTypeConverter;
+import com.amaze.filemanager.utils.OpenMode;
+
+/**
+ * Created by vishal on 18/4/17.
+ */
+@Entity(tableName = ExplorerDatabase.TABLE_CLOUD_PERSIST)
+public class CloudEntry {
+
+    @PrimaryKey(autoGenerate = true)
+    @ColumnInfo(name = ExplorerDatabase.COLUMN_CLOUD_ID)
+    private int _id;
+
+    @ColumnInfo(name = ExplorerDatabase.COLUMN_CLOUD_SERVICE)
+    @TypeConverters(OpenModeTypeConverter.class)
+    private OpenMode serviceType;
+
+    @ColumnInfo(name = ExplorerDatabase.COLUMN_CLOUD_PERSIST)
+    @TypeConverters(EncryptedStringTypeConverter.class)
+    private StringWrapper persistData;
+
+    public CloudEntry() {}
+
+    public CloudEntry(OpenMode serviceType, String persistData) {
+        this.serviceType = serviceType;
+        this.persistData = new StringWrapper(persistData);
+    }
+
+    public void setId(int _id) {
+        this._id = _id;
+    }
+
+    public int getId() {
+        return this._id;
+    }
+
+    public void setPersistData(StringWrapper persistData) {
+        this.persistData = persistData;
+    }
+
+    public StringWrapper getPersistData() {
+        return this.persistData;
+    }
+
+    /**
+     * Set the service type
+     * Support values from {@link com.amaze.filemanager.utils.OpenMode}
+     */
+    public void setServiceType(OpenMode openMode) {
+        this.serviceType = openMode;
+    }
+
+    /**
+     * Returns ordinal value of service from {@link com.amaze.filemanager.utils.OpenMode}
+     */
+    public OpenMode getServiceType() {
+        return this.serviceType;
+    }
+
+}
diff --git a/app/src/main/java/com/amaze/filemanager/database/models/explorer/EncryptedEntry.java b/app/src/main/java/com/amaze/filemanager/database/models/explorer/EncryptedEntry.java
new file mode 100644
index 000000000..56e866075
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/models/explorer/EncryptedEntry.java
@@ -0,0 +1,82 @@
+/*
+ * EncryptedEntry.java
+ *
+ * Copyright (C) 2017-2020 Vishal Nehra <vishalmeham2@gmail.com>,
+ * John Carlson <jawnnypoo@gmail.com>, Raymond Lai <airwave209gt at gmail.com>
+ * and contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.database.models.explorer;
+
+import androidx.room.ColumnInfo;
+import androidx.room.Entity;
+import androidx.room.PrimaryKey;
+import androidx.room.TypeConverters;
+
+import com.amaze.filemanager.database.ExplorerDatabase;
+import com.amaze.filemanager.database.models.StringWrapper;
+import com.amaze.filemanager.database.typeconverters.EncryptedStringTypeConverter;
+
+/**
+ * Created by vishal on 8/4/17.
+ */
+@Entity(tableName = ExplorerDatabase.TABLE_ENCRYPTED)
+public class EncryptedEntry {
+
+    @PrimaryKey(autoGenerate = true)
+    @ColumnInfo(name = ExplorerDatabase.COLUMN_ENCRYPTED_ID)
+    private int _id;
+
+    @ColumnInfo(name = ExplorerDatabase.COLUMN_ENCRYPTED_PATH)
+    private String path;
+
+    @ColumnInfo(name = ExplorerDatabase.COLUMN_ENCRYPTED_PASSWORD)
+    @TypeConverters(EncryptedStringTypeConverter.class)
+    private StringWrapper password;
+
+    public EncryptedEntry() {}
+
+    public EncryptedEntry(String path, String unencryptedPassword) {
+        this.path = path;
+        this.password = new StringWrapper(unencryptedPassword);
+    }
+
+    public void setId(int _id) {
+        this._id = _id;
+    }
+
+    public int getId() {
+        return this._id;
+    }
+
+    public void setPath(String path) {
+        this.path = path;
+    }
+
+    public String getPath() {
+        return this.path;
+    }
+
+    public void setPassword(StringWrapper password) {
+        this.password = password;
+    }
+
+    public StringWrapper getPassword() {
+        return this.password;
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/database/models/explorer/Sort.java b/app/src/main/java/com/amaze/filemanager/database/models/explorer/Sort.java
new file mode 100644
index 000000000..aee21de4c
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/models/explorer/Sort.java
@@ -0,0 +1,50 @@
+/*
+ * Sort.java
+ *
+ * Copyright (C) 2014-2020 Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam <emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com>
+ * and contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.database.models.explorer;
+
+import androidx.annotation.NonNull;
+import androidx.room.ColumnInfo;
+import androidx.room.Entity;
+import androidx.room.PrimaryKey;
+
+import com.amaze.filemanager.database.ExplorerDatabase;
+
+/**
+ * Created by Ning on 5/28/2018.
+ */
+@Entity(tableName = ExplorerDatabase.TABLE_SORT)
+public class Sort {
+
+    @PrimaryKey @NonNull
+    @ColumnInfo(name = ExplorerDatabase.COLUMN_SORT_PATH)
+    public final String path;
+
+    @ColumnInfo(name = ExplorerDatabase.COLUMN_SORT_TYPE)
+    public final int type;
+
+    public Sort(@NonNull String path, int type) {
+        this.path = path;
+        this.type = type;
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/database/models/Tab.java b/app/src/main/java/com/amaze/filemanager/database/models/explorer/Tab.java
similarity index 62%
rename from app/src/main/java/com/amaze/filemanager/database/models/Tab.java
rename to app/src/main/java/com/amaze/filemanager/database/models/explorer/Tab.java
index 28319b0e2..7637e670e 100644
--- a/app/src/main/java/com/amaze/filemanager/database/models/Tab.java
+++ b/app/src/main/java/com/amaze/filemanager/database/models/explorer/Tab.java
@@ -1,6 +1,9 @@
 /*
- * Copyright (C) 2018 Emmanuel Messulam <emmanuelbendavid@gmail.com>
- * Copyright (C) 2014 Vishal Nehra <vishalmeham2@gmail.com>
+ * Tab.java
+ *
+ * Copyright (C) 2014-2020 Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam <emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com>
+ * and contributors.
  *
  * This file is part of Amaze File Manager.
  *
@@ -18,22 +21,36 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.database.models;
+package com.amaze.filemanager.database.models.explorer;
 
 import android.content.SharedPreferences;
 
+import androidx.annotation.Nullable;
+import androidx.room.ColumnInfo;
+import androidx.room.Entity;
+import androidx.room.PrimaryKey;
+
+import com.amaze.filemanager.database.ExplorerDatabase;
 import com.amaze.filemanager.utils.files.FileUtils;
 
 /**
  * Created by Vishal on 9/17/2014
  */
+@Entity(tableName = ExplorerDatabase.TABLE_TAB)
 public class Tab {
+
+    @PrimaryKey
+    @ColumnInfo(name = ExplorerDatabase.COLUMN_TAB_NO)
     public final int tabNumber;
+
+    @ColumnInfo(name = ExplorerDatabase.COLUMN_PATH)
     public final String path;
+
+    @ColumnInfo(name = ExplorerDatabase.COLUMN_HOME)
     public final String home;
 
-    public Tab(int tabNo, String path, String home) {
-        this.tabNumber = tabNo;
+    public Tab(int tabNumber, String path, String home) {
+        this.tabNumber = tabNumber;
         this.path = path;
         this.home = home;
     }
diff --git a/app/src/main/java/com/amaze/filemanager/database/models/utilities/Bookmark.java b/app/src/main/java/com/amaze/filemanager/database/models/utilities/Bookmark.java
new file mode 100644
index 000000000..6dec1386b
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/models/utilities/Bookmark.java
@@ -0,0 +1,35 @@
+/*
+ * Bookmark.java
+ *
+ * Copyright (C) 2020 Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam <emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com>
+ * and contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.database.models.utilities;
+
+import androidx.room.Entity;
+
+import com.amaze.filemanager.database.UtilitiesDatabase;
+
+@Entity(tableName = UtilitiesDatabase.TABLE_BOOKMARKS)
+public class Bookmark extends OperationDataWithName {
+    public Bookmark(String name, String path) {
+        super(name, path);
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/database/models/utilities/Grid.java b/app/src/main/java/com/amaze/filemanager/database/models/utilities/Grid.java
new file mode 100644
index 000000000..c43687e99
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/models/utilities/Grid.java
@@ -0,0 +1,36 @@
+/*
+ * Grid.java
+ *
+ * Copyright (C) 2020 Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam <emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com>
+ * and contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.database.models.utilities;
+
+import androidx.room.Entity;
+
+import com.amaze.filemanager.database.UtilitiesDatabase;
+
+@Entity(tableName = UtilitiesDatabase.TABLE_GRID)
+public class Grid extends OperationData {
+
+    public Grid(String path) {
+        super(path);
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/database/models/utilities/Hidden.java b/app/src/main/java/com/amaze/filemanager/database/models/utilities/Hidden.java
new file mode 100644
index 000000000..abc3d01cf
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/models/utilities/Hidden.java
@@ -0,0 +1,37 @@
+/*
+ * Hidden.java
+ *
+ * Copyright (C) 2020 Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam <emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com>
+ * and contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.database.models.utilities;
+
+import androidx.room.Entity;
+
+import com.amaze.filemanager.database.UtilitiesDatabase;
+
+@Entity(tableName = UtilitiesDatabase.TABLE_HIDDEN)
+public class Hidden extends OperationData {
+
+    public Hidden(String path) {
+        super(path);
+    }
+
+}
diff --git a/app/src/main/java/com/amaze/filemanager/database/models/utilities/History.java b/app/src/main/java/com/amaze/filemanager/database/models/utilities/History.java
new file mode 100644
index 000000000..8a5d9e1ae
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/models/utilities/History.java
@@ -0,0 +1,36 @@
+/*
+ * History.java
+ *
+ * Copyright (C) 2020 Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam <emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com>
+ * and contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.database.models.utilities;
+
+import androidx.room.Entity;
+
+import com.amaze.filemanager.database.UtilitiesDatabase;
+
+@Entity(tableName = UtilitiesDatabase.TABLE_HISTORY)
+public class History extends OperationData {
+
+    public History(String path) {
+        super(path);
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/database/models/utilities/List.java b/app/src/main/java/com/amaze/filemanager/database/models/utilities/List.java
new file mode 100644
index 000000000..070d198be
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/models/utilities/List.java
@@ -0,0 +1,37 @@
+/*
+ * List.java
+ *
+ * Copyright (C) 2020 Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam <emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com>
+ * and contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.database.models.utilities;
+
+import androidx.room.Entity;
+
+import com.amaze.filemanager.database.UtilitiesDatabase;
+
+@Entity(tableName = UtilitiesDatabase.TABLE_LIST)
+public class List extends OperationData {
+
+    public List(String path) {
+        super(path);
+    }
+
+}
diff --git a/app/src/main/java/com/amaze/filemanager/database/models/utilities/OperationData.java b/app/src/main/java/com/amaze/filemanager/database/models/utilities/OperationData.java
new file mode 100644
index 000000000..7886bad04
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/models/utilities/OperationData.java
@@ -0,0 +1,50 @@
+/*
+ * OperationData.java
+ *
+ * Copyright (C) 2020 Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam <emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com>
+ * and contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.database.models.utilities;
+
+import androidx.room.ColumnInfo;
+import androidx.room.PrimaryKey;
+
+import com.amaze.filemanager.database.UtilitiesDatabase;
+
+public abstract class OperationData {
+
+    @PrimaryKey(autoGenerate = true)
+    @ColumnInfo(name = UtilitiesDatabase.COLUMN_ID)
+    public int _id;
+
+    @ColumnInfo(name = UtilitiesDatabase.COLUMN_PATH)
+    public String path;
+
+    public OperationData(String path) {
+        this.path = path;
+    }
+
+    @Override
+    public String toString() {
+        return new StringBuilder("OperationData type=[")
+                .append(getClass().getSimpleName())
+                .append("],path=[").append(path).append("]").toString();
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/database/models/utilities/OperationDataWithName.java b/app/src/main/java/com/amaze/filemanager/database/models/utilities/OperationDataWithName.java
new file mode 100644
index 000000000..d30b7921f
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/models/utilities/OperationDataWithName.java
@@ -0,0 +1,39 @@
+/*
+ * OperationDataWithName.java
+ *
+ * Copyright (C) 2020 Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam <emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com>
+ * and contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.database.models.utilities;
+
+import androidx.room.ColumnInfo;
+
+import com.amaze.filemanager.database.UtilitiesDatabase;
+
+public abstract class OperationDataWithName extends OperationData {
+
+    @ColumnInfo(name = UtilitiesDatabase.COLUMN_NAME)
+    public String name;
+
+    public OperationDataWithName(String name, String path) {
+        super(path);
+        this.name = name;
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/database/models/utilities/SftpEntry.java b/app/src/main/java/com/amaze/filemanager/database/models/utilities/SftpEntry.java
new file mode 100644
index 000000000..83d54b3ca
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/models/utilities/SftpEntry.java
@@ -0,0 +1,64 @@
+/*
+ * SftpEntry.java
+ *
+ * Copyright (C) 2020 Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam <emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com>
+ * and contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.database.models.utilities;
+
+import android.text.TextUtils;
+
+import androidx.room.ColumnInfo;
+import androidx.room.Entity;
+
+import com.amaze.filemanager.database.UtilitiesDatabase;
+
+@Entity(tableName = UtilitiesDatabase.TABLE_SFTP)
+public class SftpEntry extends OperationDataWithName {
+
+    @ColumnInfo(name = UtilitiesDatabase.COLUMN_HOST_PUBKEY)
+    public String hostKey;
+
+    @ColumnInfo(name = UtilitiesDatabase.COLUMN_PRIVATE_KEY_NAME)
+    public String sshKeyName;
+
+    @ColumnInfo(name = UtilitiesDatabase.COLUMN_PRIVATE_KEY)
+    public String sshKey;
+
+    public SftpEntry(String path, String name, String hostKey, String sshKeyName, String sshKey) {
+        super(name, path);
+        this.hostKey = hostKey;
+        this.sshKeyName = sshKeyName;
+        this.sshKey = sshKey;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder(super.toString());
+
+        if(!TextUtils.isEmpty(hostKey))
+            sb.append(",hostKey=[").append(hostKey).append(']');
+
+        if(!TextUtils.isEmpty(sshKeyName))
+            sb.append(",sshKeyName=[").append(sshKeyName).append("],sshKey=[redacted]");
+
+        return sb.toString();
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/database/models/utilities/SmbEntry.java b/app/src/main/java/com/amaze/filemanager/database/models/utilities/SmbEntry.java
new file mode 100644
index 000000000..fc1820250
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/models/utilities/SmbEntry.java
@@ -0,0 +1,36 @@
+/*
+ * SmbEntry.java
+ *
+ * Copyright (C) 2020 Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam <emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com>
+ * and contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.database.models.utilities;
+
+import androidx.room.Entity;
+
+import com.amaze.filemanager.database.UtilitiesDatabase;
+
+@Entity(tableName = UtilitiesDatabase.TABLE_SMB)
+public class SmbEntry extends OperationDataWithName {
+
+    public SmbEntry(String name, String path) {
+        super(name, path);
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/database/typeconverters/EncryptedStringTypeConverter.java b/app/src/main/java/com/amaze/filemanager/database/typeconverters/EncryptedStringTypeConverter.java
new file mode 100644
index 000000000..b273ede83
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/typeconverters/EncryptedStringTypeConverter.java
@@ -0,0 +1,53 @@
+/*
+ * EncryptedStringTypeConverter.java
+ *
+ * Copyright (C) 2020 Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.database.typeconverters;
+
+import androidx.room.TypeConverter;
+
+import com.amaze.filemanager.database.models.StringWrapper;
+import com.amaze.filemanager.utils.application.AppConfig;
+import com.amaze.filemanager.utils.files.CryptUtil;
+
+public class EncryptedStringTypeConverter {
+
+    private static final String TAG = EncryptedStringTypeConverter.class.getSimpleName();
+
+    @TypeConverter
+    public static StringWrapper toPassword(String encryptedStringEntryInDb) {
+        try {
+            return new StringWrapper(CryptUtil.decryptPassword(AppConfig.getInstance(), encryptedStringEntryInDb));
+        } catch (Exception e) {
+            android.util.Log.e(TAG, "Error decrypting password", e);
+            return null;
+        }
+    }
+
+    @TypeConverter
+    public static String fromPassword(StringWrapper unencryptedPasswordString) {
+        try {
+            return CryptUtil.encryptPassword(AppConfig.getInstance(), unencryptedPasswordString.value);
+        } catch (Exception e) {
+            android.util.Log.e(TAG, "Error encrypting password", e);
+            return null;
+        }
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/database/typeconverters/OpenModeTypeConverter.java b/app/src/main/java/com/amaze/filemanager/database/typeconverters/OpenModeTypeConverter.java
new file mode 100644
index 000000000..68ee38920
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/typeconverters/OpenModeTypeConverter.java
@@ -0,0 +1,39 @@
+/*
+ * OpenModeTypeConverter.java
+ *
+ * Copyright (C) 2020 Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.database.typeconverters;
+
+import androidx.room.TypeConverter;
+
+import com.amaze.filemanager.utils.OpenMode;
+
+public class OpenModeTypeConverter {
+
+    @TypeConverter
+    public static int fromOpenMode(OpenMode from) {
+        return from.ordinal();
+    }
+
+    @TypeConverter
+    public static OpenMode fromDatabaseValue(int from) {
+        return OpenMode.getOpenMode(from);
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/fragments/MainFragment.java b/app/src/main/java/com/amaze/filemanager/fragments/MainFragment.java
index 78bb44f74..82cc79d36 100644
--- a/app/src/main/java/com/amaze/filemanager/fragments/MainFragment.java
+++ b/app/src/main/java/com/amaze/filemanager/fragments/MainFragment.java
@@ -83,8 +83,8 @@ import com.amaze.filemanager.asynchronous.handlers.FileHandler;
 import com.amaze.filemanager.database.CloudHandler;
 import com.amaze.filemanager.database.CryptHandler;
 import com.amaze.filemanager.database.SortHandler;
-import com.amaze.filemanager.database.models.EncryptedEntry;
-import com.amaze.filemanager.database.models.Tab;
+import com.amaze.filemanager.database.models.explorer.EncryptedEntry;
+import com.amaze.filemanager.database.models.explorer.Tab;
 import com.amaze.filemanager.filesystem.CustomFileObserver;
 import com.amaze.filemanager.filesystem.FileUtil;
 import com.amaze.filemanager.filesystem.HybridFile;
@@ -949,7 +949,7 @@ public class MainFragment extends Fragment implements BottomBarButtonPath {
      */
     private static EncryptedEntry findEncryptedEntry(Context context, String path) throws Exception {
 
-        CryptHandler handler = new CryptHandler(context);
+        CryptHandler handler = new CryptHandler();
 
         EncryptedEntry matchedEntry = null;
         // find closest path which matches with database entry
diff --git a/app/src/main/java/com/amaze/filemanager/fragments/TabFragment.java b/app/src/main/java/com/amaze/filemanager/fragments/TabFragment.java
index 06391a8a2..22a7bbf39 100644
--- a/app/src/main/java/com/amaze/filemanager/fragments/TabFragment.java
+++ b/app/src/main/java/com/amaze/filemanager/fragments/TabFragment.java
@@ -24,7 +24,7 @@ import android.widget.ImageView;
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.MainActivity;
 import com.amaze.filemanager.database.TabHandler;
-import com.amaze.filemanager.database.models.Tab;
+import com.amaze.filemanager.database.models.explorer.Tab;
 import com.amaze.filemanager.fragments.preference_fragments.PreferencesConstants;
 import com.amaze.filemanager.ui.ColorCircleDrawable;
 import com.amaze.filemanager.ui.colors.UserColorPreferences;
@@ -79,7 +79,7 @@ public class TabFragment extends Fragment
     public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
         ViewGroup rootView = (ViewGroup) inflater.inflate(R.layout.tabfragment, container, false);
 
-        tabHandler = new TabHandler(getContext());
+        tabHandler = new TabHandler();
         fragmentManager = getActivity().getSupportFragmentManager();
 
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
@@ -105,6 +105,7 @@ public class TabFragment extends Fragment
         if (savedInstanceState == null) {
             int lastOpenTab = sharedPrefs.getInt(PreferencesConstants.PREFERENCE_CURRENT_TAB, PreferenceUtils.DEFAULT_CURRENT_TAB);
             MainActivity.currentTab = lastOpenTab;
+
             Tab tab1 = tabHandler.findTab(1);
             Tab tab2 = tabHandler.findTab(2);
 
@@ -209,7 +210,7 @@ public class TabFragment extends Fragment
 
     public void updatepaths(int pos) {
         if (tabHandler == null)
-            tabHandler = new TabHandler(getActivity());
+            tabHandler = new TabHandler();
         int i = 1;
 
         // Getting old path from database before clearing
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/GeneralDialogCreation.java b/app/src/main/java/com/amaze/filemanager/ui/dialogs/GeneralDialogCreation.java
index 30eb27fec..94c392951 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/dialogs/GeneralDialogCreation.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/GeneralDialogCreation.java
@@ -68,7 +68,7 @@ import com.amaze.filemanager.asynchronous.asynctasks.GenerateHashesTask;
 import com.amaze.filemanager.asynchronous.asynctasks.LoadFolderSpaceDataTask;
 import com.amaze.filemanager.asynchronous.services.EncryptService;
 import com.amaze.filemanager.database.SortHandler;
-import com.amaze.filemanager.database.models.Sort;
+import com.amaze.filemanager.database.models.explorer.Sort;
 import com.amaze.filemanager.exceptions.ShellNotRunningException;
 import com.amaze.filemanager.filesystem.FileUtil;
 import com.amaze.filemanager.filesystem.HybridFile;
@@ -1035,7 +1035,7 @@ public class GeneralDialogCreation {
 
     private static void onSortTypeSelected(MainFragment m, SharedPreferences sharedPref, Set<String> onlyThisFloders, MaterialDialog dialog, boolean desc) {
         final int sortType = desc ? dialog.getSelectedIndex() + 4 : dialog.getSelectedIndex();
-        SortHandler sortHandler = new SortHandler(m.getContext());
+        SortHandler sortHandler = new SortHandler();
         if (onlyThisFloders.contains(m.getCurrentPath())) {
             Sort oldSort = sortHandler.findEntry(m.getCurrentPath());
             Sort newSort = new Sort(m.getCurrentPath(), sortType);
diff --git a/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java b/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java
index bd04440b2..8e894b715 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java
@@ -49,7 +49,7 @@ import com.amaze.filemanager.asynchronous.management.ServiceWatcherUtil;
 import com.amaze.filemanager.asynchronous.services.ZipService;
 import com.amaze.filemanager.database.CloudHandler;
 import com.amaze.filemanager.database.CryptHandler;
-import com.amaze.filemanager.database.models.EncryptedEntry;
+import com.amaze.filemanager.database.models.explorer.EncryptedEntry;
 import com.amaze.filemanager.filesystem.FileUtil;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
@@ -302,7 +302,7 @@ public class MainActivityHelper {
                         if (oldPath.endsWith(CryptUtil.CRYPT_EXTENSION)) {
                             try {
 
-                                CryptHandler cryptHandler = new CryptHandler(context);
+                                CryptHandler cryptHandler = new CryptHandler();
                                 EncryptedEntry oldEntry = cryptHandler.findEntry(oldPath);
                                 EncryptedEntry newEntry = new EncryptedEntry();
                                 newEntry.setId(oldEntry.getId());
diff --git a/app/src/main/java/com/amaze/filemanager/utils/application/AppConfig.java b/app/src/main/java/com/amaze/filemanager/utils/application/AppConfig.java
index c99491bf0..85799eed5 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/application/AppConfig.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/application/AppConfig.java
@@ -35,7 +35,10 @@ import androidx.appcompat.app.AppCompatDelegate;
 
 import android.widget.Toast;
 
+import com.amaze.filemanager.database.UtilitiesDatabase;
 import com.amaze.filemanager.database.UtilsHandler;
+import com.amaze.filemanager.database.ExplorerDatabase;
+import com.amaze.filemanager.filesystem.ssh.CustomSshJConfig;
 import com.amaze.filemanager.utils.LruBitmapCache;
 import com.amaze.filemanager.utils.ScreenUtils;
 import com.amaze.filemanager.utils.provider.UtilitiesProvider;
@@ -73,6 +76,11 @@ public class AppConfig extends GlideApplication {
         sBackgroundHandlerThread = new HandlerThread("app_background");
         mInstance = this;
 
+        android.util.Log.d("TEST", "AppConfig.init");
+        CustomSshJConfig.init();
+        ExplorerDatabase.initialize(this);
+        UtilitiesDatabase.initialize(this);
+
         utilsProvider = new UtilitiesProvider(this);
         mUtilsHandler = new UtilsHandler(this);
 
diff --git a/app/src/main/java/com/amaze/filemanager/utils/files/EncryptDecryptUtils.java b/app/src/main/java/com/amaze/filemanager/utils/files/EncryptDecryptUtils.java
index c6887ed53..496ff3767 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/files/EncryptDecryptUtils.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/files/EncryptDecryptUtils.java
@@ -12,7 +12,7 @@ import com.amaze.filemanager.activities.MainActivity;
 import com.amaze.filemanager.asynchronous.services.DecryptService;
 import com.amaze.filemanager.asynchronous.services.EncryptService;
 import com.amaze.filemanager.database.CryptHandler;
-import com.amaze.filemanager.database.models.EncryptedEntry;
+import com.amaze.filemanager.database.models.explorer.EncryptedEntry;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.fragments.MainFragment;
 import com.amaze.filemanager.fragments.preference_fragments.PreferencesConstants;
@@ -45,7 +45,7 @@ public class EncryptDecryptUtils {
      */
     public static void startEncryption(Context c, final String path, final String password,
                                        Intent intent) throws GeneralSecurityException, IOException {
-        CryptHandler cryptHandler = new CryptHandler(c);
+        CryptHandler cryptHandler = new CryptHandler();
         String destPath = path.substring(0, path.lastIndexOf('/')+1)
                 .concat(intent.getStringExtra(EncryptService.TAG_ENCRYPT_TARGET));
 
@@ -102,7 +102,7 @@ public class EncryptDecryptUtils {
             return;
         }
 
-        switch (encryptedEntry.getPassword()) {
+        switch (encryptedEntry.getPassword().value) {
             case PreferencesConstants.ENCRYPT_PASSWORD_FINGERPRINT:
                 try {
                     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
@@ -128,7 +128,7 @@ public class EncryptDecryptUtils {
                 break;
             default:
                 GeneralDialogCreation.showDecryptDialog(c, mainActivity, decryptIntent,
-                        utilsProvider.getAppTheme(), encryptedEntry.getPassword(),
+                        utilsProvider.getAppTheme(), encryptedEntry.getPassword().value,
                         decryptButtonCallbackInterface);
                 break;
         }
@@ -142,7 +142,7 @@ public class EncryptDecryptUtils {
      */
     private static EncryptedEntry findEncryptedEntry(Context context, String path) throws GeneralSecurityException, IOException {
 
-        CryptHandler handler = new CryptHandler(context);
+        CryptHandler handler = new CryptHandler();
 
         EncryptedEntry matchedEntry = null;
         // find closest path which matches with database entry
