diff --git a/app/src/main/java/com/ds/avare/PrefActivity.java b/app/src/main/java/com/ds/avare/PrefActivity.java
index fe03fa80..9340d913 100644
--- a/app/src/main/java/com/ds/avare/PrefActivity.java
+++ b/app/src/main/java/com/ds/avare/PrefActivity.java
@@ -11,12 +11,12 @@ Redistribution and use in source and binary forms, with or without modification,
 */
 
 package com.ds.avare;
+import com.ds.avare.connections.BTOutConnection;
 import com.ds.avare.gps.GpsInterface;
 import com.ds.avare.storage.Preferences;
 import com.ds.avare.utils.Helper;
 
 import android.content.ComponentName;
-import android.content.Context;
 import android.content.Intent;
 import android.content.ServiceConnection;
 import android.location.GpsStatus;
@@ -119,7 +119,7 @@ public class PrefActivity extends PreferenceActivity {
         /*
          * This should update preferences in static memory
          */
-        new Preferences(this);
+        Preferences pref = new Preferences(this);
 
         getApplicationContext().unbindService(mConnection);
         
@@ -132,6 +132,8 @@ public class PrefActivity extends PreferenceActivity {
             mService.getTiles().forceReload();
             mService.getUDWMgr().forceReload();	// Tell the UDWs to reload as well
             mService.getExternalPlanMgr().forceReload(); // Reload plans too
+            BTOutConnection.getInstance(this).disconnect();
+            BTOutConnection.getInstance(this).connect(pref.getAutopilotBluetoothDevice(), false);
         }
     }
 }
diff --git a/app/src/main/java/com/ds/avare/StorageService.java b/app/src/main/java/com/ds/avare/StorageService.java
index d72d58ad..5e439836 100644
--- a/app/src/main/java/com/ds/avare/StorageService.java
+++ b/app/src/main/java/com/ds/avare/StorageService.java
@@ -30,6 +30,7 @@ import android.support.v4.app.NotificationCompat;
 import com.ds.avare.adsb.TfrCache;
 import com.ds.avare.adsb.TrafficCache;
 import com.ds.avare.cap.DrawCapLines;
+import com.ds.avare.connections.BTOutConnection;
 import com.ds.avare.externalFlightPlan.ExternalPlanMgr;
 import com.ds.avare.flight.Checklist;
 import com.ds.avare.flight.FlightStatus;
@@ -39,6 +40,7 @@ import com.ds.avare.gps.ExtendedGpsParams;
 import com.ds.avare.gps.Gps;
 import com.ds.avare.gps.GpsInterface;
 import com.ds.avare.gps.GpsParams;
+import com.ds.avare.instruments.AutoPilot;
 import com.ds.avare.instruments.CDI;
 import com.ds.avare.instruments.DistanceRings;
 import com.ds.avare.instruments.EdgeDistanceTape;
@@ -50,7 +52,6 @@ import com.ds.avare.instruments.VNAV;
 import com.ds.avare.instruments.VSI;
 import com.ds.avare.network.ShapeFetcher;
 import com.ds.avare.network.TFRFetcher;
-import com.ds.avare.orientation.Orientation;
 import com.ds.avare.orientation.OrientationInterface;
 import com.ds.avare.place.Area;
 import com.ds.avare.place.Destination;
@@ -270,10 +271,11 @@ public class StorageService extends Service {
     private DistanceRings mDistanceRings;
     
     private DrawCapLines mCap;
-    
 
     private ExternalPlanMgr mExternalPlanMgr;
-    
+
+    private AutoPilot mAutoPilot;
+
     /*
      * Watches GPS to notify of phases of flight
      */
@@ -491,6 +493,11 @@ public class StorageService extends Service {
         mFuelTimer = new FuelTimer(getApplicationContext());
         mUpTimer = new UpTimer();
 
+        // Create a BlueTooth Output connection and give it to the autopilot
+        BTOutConnection btOut = BTOutConnection.getInstance(this);
+        btOut.connect(mDataSource.getPreferences().getAutopilotBluetoothDevice(), false);
+        mAutoPilot = new AutoPilot(btOut);
+
         mTimer.scheduleAtFixedRate(gpsTime, 1000, 1000);
         
         /*
@@ -594,10 +601,13 @@ public class StorageService extends Service {
                     if(mDestination != null) {
                         mDestination.updateTo(getGpsParams());
                     }
-                    
+
+                    // Tell the autopilot where we are and where we intend to go
+                    mAutoPilot.setGpsData(mGpsParams, mPlan, mDestination);
+
                     // Calculate course line deviation - this must be AFTER the destination update
                     // since the CDI uses the destination in its calculations
-                    getCDI().calcDeviation(mDestination, getPlan());
+                    getCDI().calcDeviation(mDestination, mPlan);
 
                     mLastLocationUpdate = System.currentTimeMillis();
                 }
@@ -688,6 +698,9 @@ public class StorageService extends Service {
             mGps.stop();
         }
 
+        // Tell the autopilot we are shutting down
+        mAutoPilot.shutdown();
+
         super.onDestroy();
         stopForegroundService();
         
@@ -1362,6 +1375,7 @@ public class StorageService extends Service {
         mChecklist = cl;
     }
 
+    public AutoPilot getAutoPilot() { return mAutoPilot; }
 
     public EdgeDistanceTape getEdgeTape() {
     	return mEdgeDistanceTape;
diff --git a/app/src/main/java/com/ds/avare/connections/BTOutConnection.java b/app/src/main/java/com/ds/avare/connections/BTOutConnection.java
new file mode 100644
index 00000000..93082095
--- /dev/null
+++ b/app/src/main/java/com/ds/avare/connections/BTOutConnection.java
@@ -0,0 +1,213 @@
+/*
+Copyright (c) 2019, Apps4Av Inc. (apps4av.com)
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+    *     * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+    *
+    *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+package com.ds.avare.connections;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothSocket;
+import android.content.Context;
+
+import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import java.util.UUID;
+
+/**
+ *
+ * @author rwalker
+ * A Bluetooth Output connection
+ */
+public class BTOutConnection extends Connection {
+    private static final UUID mMyUUID = UUID.fromString("00001101-0000-1000-8000-00805F9B34FB");
+    private static BTOutConnection mConnection;
+    private static BluetoothSocket mBTSocket;
+    private static BluetoothAdapter mBTAdapter;
+    private static String mName;
+    private static boolean mAutoReconnect;
+    private static boolean mConnectInProgress;
+    private static OutputStream mOutStream = null;
+
+    // We are a singleton class.
+    public static BTOutConnection getInstance(Context ctx) {
+        if(null == mConnection) {
+            mConnection = new BTOutConnection();
+        }
+        return mConnection;
+    }
+
+    // Private constructor only called from the getInstance() method
+    private BTOutConnection() {
+        super("Bluetooth Output");
+        mBTAdapter = BluetoothAdapter.getDefaultAdapter();
+    }
+
+    @Override
+    public List<String> getDevices() {
+        return new ArrayList<>();
+    }
+
+    @Override
+    public String getConnDevice() {
+        return mName;
+    }
+
+    @Override
+    public boolean connect(String to, boolean secure) {
+        // If there is no bluetooth, there is nothing we can do
+        if(null == mBTAdapter) {
+            setState(DEAD); // Set to dead since there is no chance of re-opening
+            return false;
+        }
+
+        // If we are already connected, do nothing
+        if(isConnected()) {
+            return true;
+        }
+
+        // Save off the device name to connect with. This will be used
+        // to re-open the connection in the future if we have any troubles.
+        mName = to;
+
+        // Do the connection and set auto re-connect
+        mAutoReconnect = true;
+        doReconnect();
+
+        return true;
+    }
+
+    @Override
+    public void disconnect() {
+
+        if(isConnected()) {
+
+            // Close the stream
+            if (null != mOutStream) {
+                try {
+                    mOutStream.close();
+                } catch (Exception ignore) {
+
+                }
+                mOutStream = null;
+            }
+
+            // Now close the socket
+            if (null != mBTSocket) {
+                try {
+                    mBTSocket.close();
+                } catch (Exception ignore) {
+
+                }
+                mBTSocket = null;
+            }
+        }
+
+        // We are fully closed
+        setState(DISCONNECTED);
+
+        // We were explicitly told to disconnect, so disable the reconnect logic
+        mAutoReconnect = false;
+    }
+
+    // reconnect to the bluetooth stream with the device name we saved off
+    private void reconnect() {
+
+        // A couple flags to check before we blindly start this process
+        if(mConnectInProgress || isConnected()) {
+            return;
+        }
+
+        // Flag that we are in process
+        mConnectInProgress = true;
+
+        // Get the collection of bluetooth devices from the system
+        BluetoothDevice btDevice = null;
+        Set<BluetoothDevice> setDevices = mBTAdapter.getBondedDevices();
+
+        // Search for a device with the desired name.
+        for(BluetoothDevice btd : setDevices) {
+            if(btd.getName().equalsIgnoreCase(mName)) {
+                btDevice = btd;
+            }
+        }
+
+        // tell bluetooth to stop scanning. it's a power issue
+        mBTAdapter.cancelDiscovery();
+
+        if(null == btDevice) {
+            // If we did not find it, then time to leave after indicating that we don't want to
+            // auto reconnect
+            mAutoReconnect = false;
+            mConnectInProgress = false;
+            setState(DEAD); // Set to dead since there is no chance of re-opening
+            return;
+        }
+
+        // create a socket to communicate over.
+        try { mBTSocket = btDevice.createRfcommSocketToServiceRecord(mMyUUID);
+            // we got the socket, now connect it.
+            try { mBTSocket.connect();
+                // connection OK, now get the output stream
+                try { mOutStream = mBTSocket.getOutputStream();
+                } catch (Exception ex) {
+                    // Failed to get the output stream
+                    mBTSocket.close();
+                    mConnectInProgress = false;
+                    return;
+                }
+            } catch (Exception ex) {
+                // socket failed to connect
+                mBTSocket.close();
+                mConnectInProgress = false;
+                return;
+            }
+        } catch (Exception ex) {
+            // failed to create socket
+            mConnectInProgress = false;
+            return;
+        }
+
+        // Set the normal running flags
+        setState(CONNECTED);
+        mConnectInProgress = false;
+    }
+
+    // Write this chunk of data to the connection. If we have a failure, then start the
+    // reconnection sequence.
+    @Override
+    public void write(byte[] aData) {
+        if(isConnected()) {
+            // We are connected, attempt to write the data
+            try {
+                mOutStream.write(aData, 0, aData.length);
+            } catch (Exception ex) {
+                // The write failed. Clean up the connection and attempt to reopen it
+                disconnect();
+                mAutoReconnect = true;  // re-enable the auto-reconnect flag
+                doReconnect();            }
+        } else {
+            // We are not connected. Attempt reconnect
+            doReconnect();
+        }
+    }
+
+    // Create a thread to call the reconnect logic
+    private void doReconnect() {
+        if(mAutoReconnect) {
+            new Thread(new Runnable() {
+                public void run() {
+                    reconnect();
+                }
+            }).start();
+        }
+    }
+}
diff --git a/app/src/main/java/com/ds/avare/connections/Connection.java b/app/src/main/java/com/ds/avare/connections/Connection.java
index a351c25e..4288fbb8 100644
--- a/app/src/main/java/com/ds/avare/connections/Connection.java
+++ b/app/src/main/java/com/ds/avare/connections/Connection.java
@@ -33,6 +33,7 @@ public abstract class Connection {
     protected static final int CONNECTED = 1;
     protected static final int CONNECTING = 2;
     protected static final int DISCONNECTED = 0;
+    protected static final int DEAD = -1;
 
     private String mName = "";
 
@@ -114,6 +115,13 @@ public abstract class Connection {
     public boolean isConnected() {
         return getState() == Connection.CONNECTED;
     }
+    public boolean isConnecting() {
+        return getState() == Connection.CONNECTING;
+    }
+
+    public boolean isDead() {
+        return getState() == Connection.DEAD;
+    }
 
 
     /**
@@ -226,6 +234,7 @@ public abstract class Connection {
 
     public abstract boolean connect(String param, boolean securely);
 
+    public abstract void write(byte[] aData);
 
     /**
      * Posting a location hence do from UI thread
diff --git a/app/src/main/java/com/ds/avare/connections/ConnectionFactory.java b/app/src/main/java/com/ds/avare/connections/ConnectionFactory.java
index 1472767c..f10ff53a 100644
--- a/app/src/main/java/com/ds/avare/connections/ConnectionFactory.java
+++ b/app/src/main/java/com/ds/avare/connections/ConnectionFactory.java
@@ -21,24 +21,30 @@ import com.ds.avare.R;
  * Created by zkhan on 9/22/16.
  */
 public class ConnectionFactory {
+    public static final String CF_BlueToothConnectionIn  = "BlueToothConnectionIn";
+    public static final String CF_BlueToothConnectionOut = "BlueToothConnectionOut";
+    public static final String CF_WifiConnection         = "WifiConnection";
+    public static final String CF_FileConnectionIn       = "FileConnectionIn";
+    public static final String CF_GPSSimulatorConnection = "GPSSimulatorConnection";
+    public static final String CF_MsfsConnection         = "MsfsConnection";
+    public static final String CF_USBConnectionIn        = "USBConnectionIn";
+    public static final String CF_XplaneConnection       = "XplaneConnection";
 
     public static Connection getConnection(String type, Context ctx) {
-        if(type.equals("BlueToothConnectionIn")) {
-        }
-        if(type.equals("BlueToothConnectionOut")) {
-        }
-        if(type.equals("FileConnectionIn")) {
-        }
-        if(type.equals("GPSSimulatorConnection")) {
-        }
-        if(type.equals("MsfsConnection")) {
-        }
-        if(type.equals("USBConnectionIn")) {
-        }
-        if(type.equals("WifiConnection")) {
-            return WifiConnection.getInstance(ctx);
-        }
-        if(type.equals("XplaneConnection")) {
+        switch(type) {
+            case CF_BlueToothConnectionOut:
+                return BTOutConnection.getInstance(ctx);
+
+            case CF_WifiConnection:
+                return WifiConnection.getInstance(ctx);
+
+            case CF_BlueToothConnectionIn:
+            case CF_FileConnectionIn:
+            case CF_GPSSimulatorConnection:
+            case CF_MsfsConnection:
+            case CF_USBConnectionIn:
+            case CF_XplaneConnection:
+                break;
         }
         return null;
     }
@@ -49,7 +55,8 @@ public class ConnectionFactory {
  */
     public static String getActiveConnections(Context ctx) {
         String s = "";
-        s += getConnection("WifiConnection", ctx).isConnected() ?  "," + ctx.getString(R.string.WIFI) : "";
+        s += getConnection(CF_WifiConnection, ctx).isConnected() ?  "," + ctx.getString(R.string.WIFI) : "";
+        s += getConnection(CF_BlueToothConnectionOut, ctx).isConnected() ?  "," + ctx.getString(R.string.BTOut) : "";
         if(s.startsWith(",")) {
             s = s.substring(1);
         }
diff --git a/app/src/main/java/com/ds/avare/connections/WifiConnection.java b/app/src/main/java/com/ds/avare/connections/WifiConnection.java
index 98b136bd..6bb7b714 100644
--- a/app/src/main/java/com/ds/avare/connections/WifiConnection.java
+++ b/app/src/main/java/com/ds/avare/connections/WifiConnection.java
@@ -176,6 +176,9 @@ public class WifiConnection extends Connection {
         return "";
     }
 
+    @Override
+    public void write(byte[] aData) { return; };
+
     /**
      * 
      * @return
diff --git a/app/src/main/java/com/ds/avare/gps/Gps.java b/app/src/main/java/com/ds/avare/gps/Gps.java
index 8cc3fe49..e8f898fa 100644
--- a/app/src/main/java/com/ds/avare/gps/Gps.java
+++ b/app/src/main/java/com/ds/avare/gps/Gps.java
@@ -15,9 +15,11 @@ import java.util.List;
 import java.util.Timer;
 import java.util.TimerTask;
 
+import com.ds.avare.nmea.GGAPacket;
 import com.ds.avare.storage.Preferences;
 
 import android.content.Context;
+import android.location.GpsSatellite;
 import android.location.GpsStatus;
 import android.location.GpsStatus.NmeaListener;
 import android.location.Location;
@@ -66,6 +68,22 @@ public class Gps implements LocationListener, android.location.GpsStatus.Listene
         
     private static final int GPS_PERIOD_LONG_MS = 8000;
 
+    // Some global properties of the GPS itself that are required
+    // when driving an autopilot
+    private static int mSatCount;
+    private static double mGeoid;
+    private static double mHorDil;
+
+    static int getSatCount() {
+        return mSatCount;
+    }
+    static double getGeoid() {
+        return mGeoid;
+    }
+    static double getHorDil() {
+        return mHorDil;
+    }
+
     /**
      * 
      */
@@ -86,7 +104,7 @@ public class Gps implements LocationListener, android.location.GpsStatus.Listene
 
     /**
      * 
-     * @return
+     * @return void
      */
     public static boolean isGpsAvailable(Context ctx) {
         
@@ -107,7 +125,7 @@ public class Gps implements LocationListener, android.location.GpsStatus.Listene
     
     /**
      * 
-     * @return
+     * @return void
      */
     public static Location getLastLocation(Context ctx) {
         LocationManager lm = (LocationManager)ctx.getSystemService(Context.LOCATION_SERVICE);
@@ -204,7 +222,7 @@ public class Gps implements LocationListener, android.location.GpsStatus.Listene
 
     /**
      * 
-     * @return
+     * @return boolean
      */
     public static boolean isGpsDisabled(Context ctx, Preferences pref) {
         LocationManager lm = (LocationManager)ctx.getSystemService(Context.LOCATION_SERVICE);
@@ -225,7 +243,13 @@ public class Gps implements LocationListener, android.location.GpsStatus.Listene
             return;
         }
         GpsStatus gpsStatus = mLocationManager.getGpsStatus(null);
-        mGpsCallback.statusCallback(gpsStatus);           
+        mGpsCallback.statusCallback(gpsStatus);
+        mSatCount = 0;
+        for (GpsSatellite sat : gpsStatus.getSatellites()) {
+            if(sat.usedInFix()) {
+                mSatCount++;
+            }
+        }
     }
 
     /**
@@ -344,18 +368,39 @@ public class Gps implements LocationListener, android.location.GpsStatus.Listene
     @Override
     public void onNmeaReceived(long timestamp, String nmea) {
         /*
-         * Use this for altitude.
+         * Use this for altitude and some GPS status values
          */
-        if(nmea.startsWith("$GPGGA")) {
+        if(nmea.startsWith(GGAPacket.TAG)) {
+            // Horozontal dilution
             String val[] = nmea.split(",");
-            if(val.length > 9) {
+            if(val.length > GGAPacket.HD) {
                 try {
-                    mAltitude = Double.parseDouble(val[9]);
+                    mHorDil = Double.parseDouble(val[GGAPacket.HD]);
+                }
+                catch (Exception e) {
+                    mHorDil = 0;
+                }
+            }
+
+            // Altitude
+            if(val.length > GGAPacket.ALT) {
+                try {
+                    mAltitude = Double.parseDouble(val[GGAPacket.ALT]);
                 }
                 catch (Exception e) {
                     mAltitude = 0;
                 }
             }
+
+            //Height above the WGS-84 Ellipsoid
+            if(val.length > GGAPacket.GEOID) {
+                try {
+                    mGeoid = Double.parseDouble(val[GGAPacket.GEOID]);
+                }
+                catch (Exception e) {
+                    mGeoid = 0;
+                }
+            }
         }
     }
 }
diff --git a/app/src/main/java/com/ds/avare/gps/GpsParams.java b/app/src/main/java/com/ds/avare/gps/GpsParams.java
index a5db89a2..65fd1368 100644
--- a/app/src/main/java/com/ds/avare/gps/GpsParams.java
+++ b/app/src/main/java/com/ds/avare/gps/GpsParams.java
@@ -19,6 +19,8 @@ import android.location.Location;
 import com.ds.avare.position.Scale;
 import com.ds.avare.storage.Preferences;
 
+import java.util.Locale;
+
 /**
  * @author zkhan
  * A class to hold GPS params in the format we need
@@ -33,11 +35,13 @@ public class GpsParams {
     private Scale  mScale;
     private float  mDeclination;
     private long   mTime;
-    
+    private int    mSatCount;
+    private double mGeoid;
+    private double mHorDil;
 
 
     /**
-     * @param location
+     * @param location a location object
      */
     public GpsParams(Location location) {
         
@@ -50,6 +54,9 @@ public class GpsParams {
             mScale = new Scale();
             mDeclination = 0;
             mTime = 0;
+            mSatCount = 0;
+            mGeoid = 0;
+            mHorDil = 1;
             return;
         }
         
@@ -70,11 +77,17 @@ public class GpsParams {
         mScale = new Scale();
         
         mTime = location.getTime();
+
+        // These items come from the base GPS object since they are not part
+        // of the position information, but rather properties of the gps receiver itself
+        mSatCount = Gps.getSatCount();
+        mHorDil   = Gps.getHorDil();
+        mGeoid    = Gps.getGeoid();
     }
 
     /***
      * Make an exact copy from the RightHandSide into a newly allocated LeftHandSide object
-     * @param rhs
+     * @param rhs source of the object to deep copy
      * @return Duplicate copy of the right hand side
      */
     public static GpsParams copy(GpsParams rhs) {
@@ -87,13 +100,16 @@ public class GpsParams {
         lhs.mScale       = rhs.mScale;
         lhs.mDeclination = rhs.mDeclination;
         lhs.mTime        = rhs.mTime;
+        lhs.mSatCount    = rhs.mSatCount;
+        lhs.mGeoid       = rhs.mGeoid;
+        lhs.mHorDil      = rhs.mHorDil;
         return lhs;
     }
 
     /**
      * Speed in location to speed in params
-     * @param locationSpeed
-     * @return
+     * @param locationSpeed speed
+     * @return double
      */
     public static double speedConvert(double locationSpeed) {
     	return locationSpeed / Preferences.speedConversion;
@@ -101,8 +117,8 @@ public class GpsParams {
 
     /**
      * Altitude in location to altitude in params
-     * @param locationAltitude
-     * @return
+     * @param locationAltitude altitude
+     * @return double
      */
     public static double altitudeConvert(double locationAltitude) {
         return locationAltitude / Preferences.heightConversion;
@@ -115,6 +131,13 @@ public class GpsParams {
     public double getSpeed() {
         return mSpeed;
     }
+
+    public double getSpeedInKnots() {
+        if (Preferences.isKnots())  return mSpeed;              // Already in KNOTS
+        if (Preferences.isMPH())    return mSpeed * Preferences.MI_TO_NM;   // MPH to KNOTS
+        return mSpeed * Preferences.KM_TO_NM;                               // KPH to KNOTS
+    }
+
     /**
      * @return 
      * double Current longitude
@@ -131,21 +154,25 @@ public class GpsParams {
     }
     /**
      * @return
-     * double Current altitude preferred distance unit (e.g. feet or meters)
+     * double Current altitude in feet
      */
     public double getAltitude() {
         return mAltitude;
     }
-    
+
+    public double getAltitudeInMeters() {
+        return mAltitude / Preferences.heightConversion;
+    }
+
     /**
-     * @return
+     * @return double
      */
     public double getBearing() {
         return mBearing;
     }
 
     /**
-     * @return
+     * @return Scale
      */
     public Scale getScale() {
         return mScale;
@@ -153,7 +180,7 @@ public class GpsParams {
 
     /**
      * 
-     * @return
+     * @return double
      */
     public double getDeclinition() {
         return mDeclination;
@@ -169,7 +196,7 @@ public class GpsParams {
     
     /***
      * Convert the latitude into string format of Deg Min Sec
-     * @return
+     * @return String
      */
     public String getLatStringDMS() {
     	return (mLatitude >= 0 ? "N" : "S") + getDMS(Math.abs(mLatitude));
@@ -177,7 +204,7 @@ public class GpsParams {
     
     /***
      * Convert the longitude into string format of Deg Min Sec
-     * @return
+     * @return String
      */
     public String getLonStringDMS() {
     	return (mLongitude >= 0 ? "E" : "W") + getDMS(Math.abs(mLongitude));
@@ -185,7 +212,7 @@ public class GpsParams {
 
     /***
      * Convert the indicated double value into a deg/min/sec string representation 
-     * @param frac
+     * @param frac fractional position value
      * @return DD MM SS.SS format
      */
 	private String getDMS(double frac) {
@@ -203,12 +230,12 @@ public class GpsParams {
 		double sec = frac * 60;
 
 		// Place all those values into a string and return
-		return String.format("%02.0f\u00B0 %02.0f\' %02.2f\"", deg, min, sec);
+		return String.format(Locale.getDefault(),"%02.0f\u00B0 %02.0f\' %02.2f\"", deg, min, sec);
     }
 
     /**
      *
-     * @param speed
+     * @param speed how fast
      */
     public void setSpeed(int speed) {
          mSpeed = speed;
@@ -216,7 +243,7 @@ public class GpsParams {
 
     /**
      *
-     * @param altitude
+     * @param altitude how high
      */
     public void setAltitude(int altitude) {
         mAltitude = altitude;
@@ -229,4 +256,10 @@ public class GpsParams {
     public void setLatitude(double lat) {
         mLatitude = lat;
     }
+
+    public int getSatCount() { return mSatCount; }
+
+    public double getHorDil() { return mHorDil; }
+
+    public double getGeoid() { return mGeoid; };
 }
diff --git a/app/src/main/java/com/ds/avare/instruments/AutoPilot.java b/app/src/main/java/com/ds/avare/instruments/AutoPilot.java
new file mode 100644
index 00000000..1f646666
--- /dev/null
+++ b/app/src/main/java/com/ds/avare/instruments/AutoPilot.java
@@ -0,0 +1,214 @@
+/*
+Copyright (c) 2019, Apps4Av Inc. (apps4av.com)
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+    *     * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+    *
+    *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+package com.ds.avare.instruments;
+
+import com.ds.avare.connections.Connection;
+import com.ds.avare.gps.GpsParams;
+import com.ds.avare.nmea.BODPacket;
+import com.ds.avare.nmea.GGAPacket;
+import com.ds.avare.nmea.RMBPacket;
+import com.ds.avare.nmea.RMCPacket;
+import com.ds.avare.place.Destination;
+import com.ds.avare.place.Plan;
+import com.ds.avare.position.Projection;
+import com.ds.avare.utils.Helper;
+
+import java.util.concurrent.ConcurrentLinkedQueue;
+
+import static android.os.SystemClock.sleep;
+
+/**
+ *
+ * @author rwalker
+ * All functionality required to generate the NMEA sentances to drive an autopilot
+ */
+public class AutoPilot {
+
+    private ConcurrentLinkedQueue<WorkItem> mWorkItems; // A collection of position reports
+    private Connection mConnection;                     // Where to send the NMEA data
+    private boolean    mShutdown;                       // true when we need to shutdown
+    private Thread mThread;                             // thread to do the bulk of the work
+
+    // an item of GPS data that needs processing. We maintain a queue of these items
+    // that gets processed on a background thread.
+    private class WorkItem {
+        private Plan         mPlan;
+        private Destination  mDest;
+        private GpsParams    mGpsParams;
+
+        private WorkItem(GpsParams gpsParams, Plan plan, Destination dest) {
+            mGpsParams = gpsParams;
+            mPlan = plan;
+            mDest = dest;
+        }
+    }
+
+    // Create an autopilot object.
+    public AutoPilot(Connection aConnection) {
+
+        // Init our member variables
+        mConnection = aConnection;
+        mShutdown   = false;
+        mWorkItems  = new ConcurrentLinkedQueue<>();
+
+        // Create a thread that will do the bulk of the work.
+        // Read an item from the work queue, formulate the NMEA sentences, write
+        // those sentences to the connection.
+        mThread = new Thread(new Runnable() {
+            public void run() {
+                WorkItem workItem;
+                while(!mShutdown) { // Stay here till told to shutdown
+                    // data packets are added to the mWorkItems list
+                    while (null != (workItem = mWorkItems.poll())) {
+
+                        // extract the items for clarity and speed
+                        GpsParams gpsParams = workItem.mGpsParams;
+                        Destination dest    = workItem.mDest;
+                        Plan plan           = workItem.mPlan;
+
+                        // Create NMEA packet #1
+                        RMCPacket rmcPacket = new RMCPacket(
+                                gpsParams.getTime(),
+                                gpsParams.getLatitude(),
+                                gpsParams.getLongitude(),
+                                gpsParams.getSpeedInKnots(),
+                                gpsParams.getBearing(),
+                                gpsParams.getDeclinition()
+                        );
+                        String apText = rmcPacket.getPacket();
+
+                        // Create NMEA packet #2
+                        GGAPacket ggaPacket = new GGAPacket(
+                                gpsParams.getTime(),
+                                gpsParams.getLatitude(),
+                                gpsParams.getLongitude(),
+                                gpsParams.getAltitudeInMeters(),
+                                gpsParams.getSatCount(),
+                                gpsParams.getGeoid(),
+                                gpsParams.getHorDil()
+                        );
+                        apText += ggaPacket.getPacket();
+
+                        // If we have a destination set, then we need to add some more sentences
+                        // to tell the autopilot how to steer
+                        if (null != dest) {
+                            String startID = "";
+
+                            // This is the bearing from our starting point, to our current
+                            // destination
+                            double brgOrig = Projection.getStaticBearing(
+                                    dest.getLocationInit().getLongitude(),
+                                    dest.getLocationInit().getLatitude(),
+                                    dest.getLocation().getLongitude(),
+                                    dest.getLocation().getLatitude());
+
+                            // If we have a flight plan active, then we may need to re-calc the
+                            // original bearing based upon the most recently passed waypoint in the plan.
+                            if (null != plan) {
+                                if (plan.isActive()) {
+                                    int nnp = plan.findNextNotPassed();
+                                    if (nnp > 0) {
+                                        Destination prevDest = plan.getDestination(nnp - 1);
+                                        if (null != prevDest) {
+                                            startID = prevDest.getID();
+                                            brgOrig = Projection.getStaticBearing(
+                                                    prevDest.getLocation().getLongitude(),
+                                                    prevDest.getLocation().getLatitude(),
+                                                    dest.getLocation().getLongitude(),
+                                                    dest.getLocation().getLatitude());
+                                        }
+                                    }
+                                }
+                            }
+
+                            // Calculate how many miles we are to the side of the course line
+                            double deviation = dest.getDistanceInNM() *
+                                    Math.sin(Math.toRadians(Helper.angularDifference(brgOrig, dest.getBearing())));
+
+                            // If we are to the left of the course line, then make our deviation negative.
+                            if(Helper.leftOfCourseLine(dest.getBearing(),  brgOrig)) {
+                                deviation = -deviation;
+                            }
+
+                            // Limit our station IDs to 4 chars max so we don't exceed the 80 char
+                            // sentence limit. A "GPS" fix has a temp name that is quite long
+                            if(startID.length() > 4) {
+                                startID = "gSRC";
+                            }
+
+                            String endID = dest.getID();
+                            if(endID.length() > 4) {
+                                endID = "gDST";
+                            }
+
+                            // We now have all the info to create NMEA packet #3
+                            RMBPacket rmbPacket = new RMBPacket(
+                                    dest.getDistanceInNM(),
+                                    dest.getBearing(),
+                                    dest.getLocation().getLongitude(),
+                                    dest.getLocation().getLatitude(),
+                                    endID,
+                                    startID,
+                                    deviation,
+                                    gpsParams.getSpeedInKnots(),
+                                    (null != plan) && (!plan.isActive() && plan.allWaypointsPassed())
+                            );
+                            apText += rmbPacket.getPacket();
+
+                            // Now for the final NMEA packet
+                            BODPacket bodPacket = new BODPacket(
+                                    endID,
+                                    startID,
+                                    brgOrig,
+                                    (brgOrig + dest.getDeclination())
+                            );
+                            apText += bodPacket.getPacket();
+                        }
+
+                        // Write this block of NMEA data to the output connection
+                        mConnection.write(apText.getBytes());
+
+                        // A single workitem has just been processed. Sleep for a bit
+                        // then go look for the next one
+                        try {
+                            sleep(100);
+                        } catch (Exception ignore) {  }
+                    }
+                }
+            }
+        });
+
+        // Fire up that background thread
+        mThread.start();
+    }
+
+    // Called when we have new GPS data to process against the plan.
+    public void setGpsData(GpsParams gpsParams, Plan plan, Destination dest) {
+        if(!mConnection.isDead()) {
+            mWorkItems.add(new WorkItem(gpsParams, plan, dest));
+        }
+    }
+
+    // System is shutting down. Shut down our connection, then tell the
+    // background thread to terminate.
+    public void shutdown() {
+        mShutdown = true;
+        try { mThread.join();
+        } catch (Exception ignore) { }
+        mConnection.disconnect();
+    }
+
+    // Is the autopilot fully connected
+    public boolean isConnected() {
+        return mConnection.isConnected();
+    }
+}
diff --git a/app/src/main/java/com/ds/avare/instruments/EdgeDistanceTape.java b/app/src/main/java/com/ds/avare/instruments/EdgeDistanceTape.java
index e800f0a2..628281be 100644
--- a/app/src/main/java/com/ds/avare/instruments/EdgeDistanceTape.java
+++ b/app/src/main/java/com/ds/avare/instruments/EdgeDistanceTape.java
@@ -112,11 +112,11 @@ public class EdgeDistanceTape {
 	 */
 	@SuppressLint("DefaultLocale")
 	public void draw(Canvas canvas, Scale scale, float pixPerUnit, 
-			int homeX, int homeY, int top, int width, int height) {
+			int homeX, int homeY, int top, int width, int height, int backColor) {
 		
 		// Set color and transparency for the shadow
-	    mPaint.setColor(Color.BLACK);// shadow color is black
-	    mPaint.setAlpha(0x7F);		// Make it see-thru
+	    mPaint.setColor(backColor);// shadow color is black
+	    mPaint.setAlpha(0x4F);		// Make it see-thru
 
 		// the vertical shadow down the left of the display
 	    mPaint.setStrokeWidth(mBgndWidth);		// Line width
diff --git a/app/src/main/java/com/ds/avare/nmea/BODPacket.java b/app/src/main/java/com/ds/avare/nmea/BODPacket.java
index 03ed0ba5..b0b1cf37 100644
--- a/app/src/main/java/com/ds/avare/nmea/BODPacket.java
+++ b/app/src/main/java/com/ds/avare/nmea/BODPacket.java
@@ -11,6 +11,8 @@ Redistribution and use in source and binary forms, with or without modification,
 */
 package com.ds.avare.nmea;
 
+import java.util.Locale;
+
 /**
  * 
  * @author zkhan
@@ -18,36 +20,28 @@ package com.ds.avare.nmea;
  */
 public class BODPacket extends Packet {
     
-    public BODPacket(double idDest, double idStart, double bearingTrue, double bearingMag) {
-        
-        if(idDest < 0 || idStart < 0) {
-            mPacket = "";
-            return;
-        }
-        
+    public BODPacket(String idDest, String idStart, double bearingTrue, double bearingMag) {
         mPacket = "$GPBOD,";
         
         /*
          * Put bearingTrue
          */
-        mPacket += String.format("%05.1f", bearingTrue);
+        mPacket += String.format(Locale.getDefault(),"%05.1f", bearingTrue);
         mPacket += ",T,";
 
         /*
          * Put bearingMag
          */
-        mPacket += String.format("%05.1f", bearingMag);
+        mPacket += String.format(Locale.getDefault(),"%05.1f", bearingMag);
         mPacket += ",M,";
 
-        int idi = (int)idDest;
-        mPacket += String.format("%03d", idi);
+        // Destination
+        mPacket += idDest;
         mPacket += ",";
-        idi = (int)idStart;
-        mPacket += String.format("%03d", idi);
+
+        // Start
+        mPacket += idStart;
         
-      
         assemble();
-        
     }
-
 }
diff --git a/app/src/main/java/com/ds/avare/nmea/GGAPacket.java b/app/src/main/java/com/ds/avare/nmea/GGAPacket.java
index c10546a7..6b19b6ae 100644
--- a/app/src/main/java/com/ds/avare/nmea/GGAPacket.java
+++ b/app/src/main/java/com/ds/avare/nmea/GGAPacket.java
@@ -23,10 +23,34 @@ import java.util.TimeZone;
  */
 public class GGAPacket extends Packet {
 
-    public GGAPacket(long time, double latitude, double longitude, double altitude) {
-        mPacket = "$GPGGA,";
-        
-        
+    /*
+     * $GPGGA,hhmmss.ss,llll.ll,a,yyyyy.yy,a,x,xx,x.x,x.x,M,x.x,M,x.x,xxxx*hh
+     * 1    = UTC of Position
+     * 2    = Latitude
+     * 3    = N or S
+     * 4    = Longitude
+     * 5    = E or W
+     * 6    = GPS quality indicator (0=invalid; 1=GPS fix; 2=Diff. GPS fix)
+     * 7    = Number of satellites in use [not those in view]
+     * 8    = Horizontal dilution of position
+     * 9    = Antenna altitude above/below mean sea level (geoid)
+     * 10   = M-Meters  (Antenna height unit)
+     * 11   = Geoidal separation (Diff. between WGS-84 earth ellipsoid and
+     *        mean sea level.  -=geoid is below WGS-84 ellipsoid)
+     * 12   = M-Meters  (Units of geoidal separation)
+     * 13   = Age in seconds since last update from diff. reference station (NOT USED)
+     * 14   = Diff. reference station ID# (NOT USED)
+     * 15   = Checksum
+     */
+
+    public static final String TAG = "$GPGGA";
+    public static final int HD     = 8;
+    public static final int ALT    = 9;
+    public static final int GEOID  = 11;
+
+    public GGAPacket(long time, double latitude, double longitude, double altitude, int satCount, double geoid, double horDil) {
+        mPacket = TAG + ",";
+
         /*
          * Convert to UTC system time, and format to hhmmss as in NMEA
          */
@@ -44,9 +68,9 @@ public class GGAPacket extends Packet {
             
             lat = (int)latitude;
             deg = (latitude - (double)lat) * 60.0;
-            
-            mPacket += String.format("%02d", lat);
-            mPacket += String.format("%06.3f", deg);
+
+            mPacket += String.format(Locale.getDefault(), "%02d", lat);
+            mPacket += String.format(Locale.getDefault(),"%06.3f", deg);
             mPacket += ",N,";
         }
         else {
@@ -55,10 +79,10 @@ public class GGAPacket extends Packet {
             latitude = -latitude;
             lat = (int)latitude;
             deg = (latitude - (double)lat) * 60.0;
-            
-            mPacket += String.format("%02d", lat);
-            mPacket += String.format("%06.3f", deg);
-            mPacket += ",S,";            
+
+            mPacket += String.format(Locale.getDefault(),"%02d", lat);
+            mPacket += String.format(Locale.getDefault(),"%06.3f", deg);
+            mPacket += ",S,";
         }
 
         /*
@@ -70,9 +94,9 @@ public class GGAPacket extends Packet {
             
             lon = (int)longitude;
             deg = (longitude - (double)lon) * 60.0;
-            
-            mPacket += String.format("%03d", lon);
-            mPacket += String.format("%06.3f", deg);
+
+            mPacket += String.format(Locale.getDefault(),"%03d", lon);
+            mPacket += String.format(Locale.getDefault(),"%06.3f", deg);
             mPacket += ",E,";
         }
         else {
@@ -81,42 +105,37 @@ public class GGAPacket extends Packet {
             longitude = -longitude;
             lon = (int)longitude;
             deg = (longitude - (double)lon) * 60.0;
-            
-            mPacket += String.format("%03d", lon);
-            mPacket += String.format("%06.3f", deg);
-            mPacket += ",W,";            
+
+            mPacket += String.format(Locale.getDefault(),"%03d", lon);
+            mPacket += String.format(Locale.getDefault(),"%06.3f", deg);
+            mPacket += ",W,";
         }
 
         /*
-         * Sim mode
+         * A true GPS fix
          */
-        mPacket += "8,";
+        mPacket += "1,";
         
         /*
-         * Do not have satellite info
+         * How many satellites used in this fix.
          */
-        mPacket += "00,";
+        mPacket += String.format(Locale.getDefault(),"%02d,", satCount);
 
         /*
          * Horizontal dilution 
          */
-        mPacket += "1.0,";
+        mPacket += String.format(Locale.getDefault(),"%1.1f,", horDil);
         
         /*
-         * Put altitude
+         * Put altitude in METERS
          */
-        mPacket += String.format("%.1f", altitude);
-        mPacket += ",M,";
+        mPacket += String.format(Locale.getDefault(),"%.1f,M,", altitude);
 
         /*
-         * XXX:
-         * Calculate geoid
-         * 
-         * Add couple of empty fields
+         * GEOID and a couple of empty fields
          */
-        mPacket += "0.0,M,,";
+        mPacket += String.format(Locale.getDefault(),"%.1f,M,,", geoid);
 
         assemble();
     }
-
 }
diff --git a/app/src/main/java/com/ds/avare/nmea/Packet.java b/app/src/main/java/com/ds/avare/nmea/Packet.java
index 9b6e7552..3cc7dd27 100644
--- a/app/src/main/java/com/ds/avare/nmea/Packet.java
+++ b/app/src/main/java/com/ds/avare/nmea/Packet.java
@@ -17,6 +17,9 @@ public class Packet {
         
         int xor = MessageFactory.checkSum(mPacket.getBytes());
         String ma = Integer.toHexString(xor).toUpperCase(Locale.getDefault());
+        if(ma.length() < 2) {   // The checksum needs to be 2 ascii digits
+            mPacket += "0";
+        }
         mPacket += ma;
         mPacket += "\r\n";
     }
diff --git a/app/src/main/java/com/ds/avare/nmea/RMBPacket.java b/app/src/main/java/com/ds/avare/nmea/RMBPacket.java
index 34e730af..60f46d2f 100644
--- a/app/src/main/java/com/ds/avare/nmea/RMBPacket.java
+++ b/app/src/main/java/com/ds/avare/nmea/RMBPacket.java
@@ -11,6 +11,8 @@ Redistribution and use in source and binary forms, with or without modification,
 */
 package com.ds.avare.nmea;
 
+import java.util.Locale;
+
 /**
  * 
  * @author zkhan
@@ -18,37 +20,30 @@ package com.ds.avare.nmea;
  */
 public class RMBPacket extends Packet {
     
-    public RMBPacket(long time, double distance, double bearing, double longitude, double latitude, double idNext, double idOrig, double deviation, double speed) {
-        
-        if(idOrig < 0 || idNext < 0) {
-            mPacket = "";
-            return;
-        }
-        
+    public RMBPacket(double distance, double bearing, double longitude, double latitude, String idNext, String idOrig, double deviation, double speed, boolean planComplete) {
         mPacket = "$GPRMB,";
         
         //valid
         mPacket += "A,";
 
         // deviation
-        String dir = "R";
+        String dir = "L";
         if(deviation < 0) {
-            dir = "L";
+            dir = "R";
             deviation = -deviation;
         }
         if(deviation > 9.99) {
             deviation = 9.99;
         }
-        mPacket += String.format("%04.2f", deviation);
+        mPacket += String.format(Locale.getDefault(),"%04.2f", deviation);
         mPacket += ",";
         mPacket += dir;
         mPacket += ",";
-        
-        int idi = (int)idOrig;
-        mPacket += String.format("%03d", idi);
+
+        mPacket += idOrig;
         mPacket += ",";
-        idi = (int)idNext;
-        mPacket += String.format("%03d", idi);
+
+        mPacket += idNext;
         mPacket += ",";
         
         /*
@@ -60,9 +55,9 @@ public class RMBPacket extends Packet {
             
             lat = (int)latitude;
             deg = (latitude - (double)lat) * 60.0;
-            
-            mPacket += String.format("%02d", lat);
-            mPacket += String.format("%06.3f", deg);
+
+            mPacket += String.format(Locale.getDefault(),"%02d", lat);
+            mPacket += String.format(Locale.getDefault(),"%06.3f", deg);
             mPacket += ",N,";
         }
         else {
@@ -71,10 +66,10 @@ public class RMBPacket extends Packet {
             latitude = -latitude;
             lat = (int)latitude;
             deg = (latitude - (double)lat) * 60.0;
-            
-            mPacket += String.format("%02d", lat);
-            mPacket += String.format("%06.3f", deg);
-            mPacket += ",S,";            
+
+            mPacket += String.format(Locale.getDefault(),"%02d", lat);
+            mPacket += String.format(Locale.getDefault(),"%06.3f", deg);
+            mPacket += ",S,";
         }
 
         /*
@@ -86,9 +81,9 @@ public class RMBPacket extends Packet {
             
             lon = (int)longitude;
             deg = (longitude - (double)lon) * 60.0;
-            
-            mPacket += String.format("%03d", lon);
-            mPacket += String.format("%06.3f", deg);
+
+            mPacket += String.format(Locale.getDefault(),"%03d", lon);
+            mPacket += String.format(Locale.getDefault(),"%06.3f", deg);
             mPacket += ",E,";
         }
         else {
@@ -97,32 +92,37 @@ public class RMBPacket extends Packet {
             longitude = -longitude;
             lon = (int)longitude;
             deg = (longitude - (double)lon) * 60.0;
-            
-            mPacket += String.format("%03d", lon);
-            mPacket += String.format("%06.3f", deg);
-            mPacket += ",W,";            
+
+            mPacket +=  String.format(Locale.getDefault(),"%03d", lon);
+            mPacket += String.format(Locale.getDefault(),"%06.3f", deg);
+            mPacket += ",W,";
         }
 
         /*
          * Put range
          */
-        mPacket += String.format("%05.1f", distance);
+        if(distance >= 1000) {
+            distance = 999.9;
+        }
+        mPacket += String.format(Locale.getDefault(),"%05.1f", distance);
         mPacket += ",";
 
         /*
          * Put bearing
          */
-        mPacket += String.format("%05.1f", bearing);
+        mPacket += String.format(Locale.getDefault(),"%05.1f", bearing);
         mPacket += ",";
 
         /*
-         * Put speed in m/s, convert to knots (this is because NMEA speed is in knots)
+         * Put speed
          */
-        mPacket += String.format("%05.1f", speed / 0.514444);
-        mPacket += ",V";
+        mPacket += String.format(Locale.getDefault(),"%05.1f,", speed);
+
+        /*
+         * Final item is whether or not we have arrived at our final destination
+         */
+        mPacket += planComplete ? "A" : "V";
       
         assemble();
-        
     }
-
 }
diff --git a/app/src/main/java/com/ds/avare/nmea/RMCPacket.java b/app/src/main/java/com/ds/avare/nmea/RMCPacket.java
index ad7df49c..6a4a9992 100644
--- a/app/src/main/java/com/ds/avare/nmea/RMCPacket.java
+++ b/app/src/main/java/com/ds/avare/nmea/RMCPacket.java
@@ -25,16 +25,8 @@ import android.hardware.GeomagneticField;
  */
 public class RMCPacket extends Packet {
     
-    public RMCPacket(long time, double latitude, double longitude, double speed, double bearing) {
+    public RMCPacket(long time, double latitude, double longitude, double speed, double bearing, double dec) {
         mPacket = "$GPRMC,";
-        
-        
-        /*
-         * Variation
-         */
-        GeomagneticField gmf = new GeomagneticField((float)latitude, 
-                (float)longitude, 0, time);
-        double dec = -gmf.getDeclination();
 
         /*
          * Convert to UTC system time, and format to hhmmss as in NMEA
@@ -43,7 +35,7 @@ public class RMCPacket extends Packet {
         SimpleDateFormat sdf = new SimpleDateFormat("HHmmss", Locale.US);
         sdf.setTimeZone(TimeZone.getTimeZone("UTC"));
         mPacket += sdf.format(date) + ",";
-        
+
         mPacket += "A,";
 
         /*
@@ -55,9 +47,9 @@ public class RMCPacket extends Packet {
             
             lat = (int)latitude;
             deg = (latitude - (double)lat) * 60.0;
-            
-            mPacket += String.format("%02d", lat);
-            mPacket += String.format("%06.3f", deg);
+
+            mPacket += String.format(Locale.getDefault(),"%02d", lat);
+            mPacket += String.format(Locale.getDefault(),"%06.3f", deg);
             mPacket += ",N,";
         }
         else {
@@ -66,10 +58,10 @@ public class RMCPacket extends Packet {
             latitude = -latitude;
             lat = (int)latitude;
             deg = (latitude - (double)lat) * 60.0;
-            
-            mPacket += String.format("%02d", lat);
-            mPacket += String.format("%06.3f", deg);
-            mPacket += ",S,";            
+
+            mPacket += String.format(Locale.getDefault(),"%02d", lat);
+            mPacket += String.format(Locale.getDefault(),"%06.3f", deg);
+            mPacket += ",S,";
         }
 
         /*
@@ -81,9 +73,9 @@ public class RMCPacket extends Packet {
             
             lon = (int)longitude;
             deg = (longitude - (double)lon) * 60.0;
-            
-            mPacket += String.format("%03d", lon);
-            mPacket += String.format("%06.3f", deg);
+
+            mPacket += String.format(Locale.getDefault(),"%03d", lon);
+            mPacket += String.format(Locale.getDefault(),"%06.3f", deg);
             mPacket += ",E,";
         }
         else {
@@ -92,22 +84,22 @@ public class RMCPacket extends Packet {
             longitude = -longitude;
             lon = (int)longitude;
             deg = (longitude - (double)lon) * 60.0;
-            
-            mPacket += String.format("%03d", lon);
-            mPacket += String.format("%06.3f", deg);
-            mPacket += ",W,";            
+
+            mPacket += String.format(Locale.getDefault(),"%03d", lon);
+            mPacket += String.format(Locale.getDefault(),"%06.3f", deg);
+            mPacket += ",W,";
         }
 
         /*
-         * Put speed in m/s, convert to knots (this is because NMEA speed is in knots)
+         * Put speed knots
          */
-        mPacket += String.format("%05.1f", speed / 0.514444);
+        mPacket += String.format(Locale.getDefault(),"%05.1f", speed);
         mPacket += ",";
 
         /*
          * Put bearing
          */
-        mPacket += String.format("%05.1f", bearing);
+        mPacket += String.format(Locale.getDefault(),"%05.1f", bearing);
         mPacket += ",";
 
         /*
@@ -123,16 +115,14 @@ public class RMCPacket extends Packet {
          */
         if(dec < 0) {
             dec = -dec;
-            mPacket += String.format("%05.1f", dec);
+            mPacket += String.format(Locale.getDefault(),"%05.1f", dec);
             mPacket += ",E";
         }
         else {
-            mPacket += String.format("%05.1f", dec);
-            mPacket += ",W";            
+            mPacket += String.format(Locale.getDefault(),"%05.1f", dec);
+            mPacket += ",W";
         }
       
         assemble();
-        
     }
-
 }
diff --git a/app/src/main/java/com/ds/avare/place/Destination.java b/app/src/main/java/com/ds/avare/place/Destination.java
index 5e0bc1e5..a99a546d 100644
--- a/app/src/main/java/com/ds/avare/place/Destination.java
+++ b/app/src/main/java/com/ds/avare/place/Destination.java
@@ -121,9 +121,9 @@ public class Destination extends Observable {
         mPref = new Preferences(service.getApplicationContext());
         mService = service;
         mTrackShape = new TrackShape();
-        mEte = new String("--:--");
-        mEta = new String("--:--");
-        mFuel = new String("-.-");
+        mEte = "--:--";
+        mEta = "--:--";
+        mFuel = "-.-";
         mParams = new LinkedHashMap<String, String>();
 
         mEteSec = Long.MAX_VALUE;
@@ -415,6 +415,12 @@ public class Destination extends Observable {
         return mDistance;
     }
 
+    public double getDistanceInNM() {
+        if (Preferences.isKnots())  return mDistance;              // Already in nautical miles
+        if (Preferences.isMPH())    return mDistance * Preferences.MI_TO_NM;   // miles to nautical
+        return mDistance * Preferences.KM_TO_NM;                               // kilometers to nautical
+    }
+
     /**
      * 
      * @return
diff --git a/app/src/main/java/com/ds/avare/place/Plan.java b/app/src/main/java/com/ds/avare/place/Plan.java
index 4cc6304c..d537ca7c 100644
--- a/app/src/main/java/com/ds/avare/place/Plan.java
+++ b/app/src/main/java/com/ds/avare/place/Plan.java
@@ -132,7 +132,7 @@ public class Plan implements Observer {
 
     /**
      * 
-     * @return
+     * @return The number of waypoints in this plan
      */
     public int getDestinationNumber() {
 
@@ -271,6 +271,18 @@ public class Plan implements Observer {
         return 0;
     }
 
+    /*
+     * Have all the waypoints been passed ? In other words, is this plan complete ?
+     */
+    public boolean allWaypointsPassed() {
+        for (int id = 0; id < getDestinationNumber(); id++) {
+            if (!mPassed[id]) {
+                return false;
+            }
+        }
+        return true;
+    }
+
     /*
      * If passed
      */
@@ -849,6 +861,11 @@ public class Plan implements Observer {
     	return mSuspend;
     }
 
+    // Is the plan paused ?
+    public boolean isPaused() {
+        return mSuspend;
+    }
+
     /**
      * Put this plan in JSON array
      * 
diff --git a/app/src/main/java/com/ds/avare/shapes/Shape.java b/app/src/main/java/com/ds/avare/shapes/Shape.java
index af277a01..36e7b2ab 100644
--- a/app/src/main/java/com/ds/avare/shapes/Shape.java
+++ b/app/src/main/java/com/ds/avare/shapes/Shape.java
@@ -162,7 +162,7 @@ public abstract class Shape {
 	                if(null == plan) {
 	                	paint.setColor(color);
 	                } else {
-	                	paint.setColor(TrackShape.getLegColor(plan.findNextNotPassed(), mCoords.get(coord).getLeg()));
+	                	paint.setColor(TrackShape.getLegColor(plan, mCoords.get(coord).getLeg()));
 	                }
 
 	                c.drawLine(x1, y1, x2, y2, paint);
diff --git a/app/src/main/java/com/ds/avare/shapes/TrackShape.java b/app/src/main/java/com/ds/avare/shapes/TrackShape.java
index d5e394be..d8ebeec3 100644
--- a/app/src/main/java/com/ds/avare/shapes/TrackShape.java
+++ b/app/src/main/java/com/ds/avare/shapes/TrackShape.java
@@ -32,14 +32,28 @@ public class TrackShape extends Shape {
     private static final int LEG_PREV = Color.GRAY;
     private static final int LEG_CURRENT = Color.MAGENTA;
     private static final int LEG_NEXT = Color.CYAN;
+    private static final int LEG_PAUSED = Color.YELLOW;
 
-    public static int getLegColor(int dstNxt, int segNum) {
+    // Get the color of the leg segment to draw.
+    public static int getLegColor(Plan plan, int segNum) {
+
+        // Is this plan paused ?
+        boolean bPlanIsPaused = plan.isPaused();
+
+        // get the "current" leg segment hat is active
+        int dstNxt = plan.findNextNotPassed();
+
+        //  Check for a future segment
         if (dstNxt <= segNum) {
-            return LEG_NEXT;
+            return bPlanIsPaused ? LEG_PAUSED :LEG_NEXT;
+
+        // Check for the current segment, always drawn in its color
         } else if (dstNxt - 1 == segNum) {
             return LEG_CURRENT;
+
+        // Otherwise, it's a previously completed segment
         } else {
-            return LEG_PREV;
+            return bPlanIsPaused ? LEG_PAUSED :LEG_PREV;
         }
     }
 
diff --git a/app/src/main/java/com/ds/avare/storage/Preferences.java b/app/src/main/java/com/ds/avare/storage/Preferences.java
index 7cdbb2f7..dc71eeab 100644
--- a/app/src/main/java/com/ds/avare/storage/Preferences.java
+++ b/app/src/main/java/com/ds/avare/storage/Preferences.java
@@ -27,6 +27,7 @@ import android.view.WindowManager;
 
 import com.ds.avare.MainActivity;
 import com.ds.avare.R;
+import com.ds.avare.utils.BTListPreferenceWithSummary;
 import com.ds.avare.utils.BitmapHolder;
 
 import java.io.File;
@@ -101,9 +102,11 @@ public class Preferences {
     private SharedPreferences mPref;
     private Context mContext;
 
-    public static double NM_TO_MI = 1.15078;
-    public static double NM_TO_KM = 1.852;
-    public static double MS_TO_KT = 1.94384;
+    public static final double NM_TO_MI = 1.15078;
+    public static final double NM_TO_KM = 1.852;
+    public static final double MS_TO_KT = 1.94384;
+    public static final double MI_TO_NM = 0.868976;
+    public static final double KM_TO_NM = 0.539957;
 
     /**
      * @param ctx
@@ -144,6 +147,10 @@ public class Preferences {
         }
     }
 
+    public static boolean isKnots() { return distanceConversionUnit.equals("nm"); }
+    public static boolean isMPH()   { return distanceConversionUnit.equals("mi"); }
+    public static boolean isKPH()   { return distanceConversionUnit.equals("km"); }
+
     /**
      * @return
      */
@@ -1246,6 +1253,10 @@ public class Preferences {
     public String getWiFiPort() {
         return mPref.getString(mContext.getString(R.string.WIFIPort), "4000");
     }
+
+    public String getAutopilotBluetoothDevice() {
+        return mPref.getString(mContext.getString(R.string.AutopilotBTDevice), BTListPreferenceWithSummary.NONE);
+    }
 }
 
 
diff --git a/app/src/main/java/com/ds/avare/utils/BTListPreferenceWithSummary.java b/app/src/main/java/com/ds/avare/utils/BTListPreferenceWithSummary.java
new file mode 100644
index 00000000..020921a2
--- /dev/null
+++ b/app/src/main/java/com/ds/avare/utils/BTListPreferenceWithSummary.java
@@ -0,0 +1,93 @@
+/*
+Copyright (c) 2019, Apps4Av Inc. (apps4av.com)
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+    *     * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+    *
+    *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+package com.ds.avare.utils;
+
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.content.Context;
+import android.preference.ListPreference;
+import android.util.AttributeSet;
+
+import java.util.Set;
+
+/**
+ *
+ * @author rwalker
+ * A custom list preference configuration control that populates the items
+ * with paired bluetooth connections.
+ */
+public class BTListPreferenceWithSummary extends ListPreference {
+    public static final String NONE="OFF";
+    private String mOriginalSummary;
+    private CharSequence[] mSelections;
+
+    public BTListPreferenceWithSummary(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        mOriginalSummary = super.getSummary().toString();
+        mSelections = getSelections();
+        super.setEntries(mSelections);
+        super.setEntryValues(mSelections);
+        super.setDefaultValue(NONE);
+    }
+
+    public BTListPreferenceWithSummary(Context context) {
+        super(context);
+        mOriginalSummary = super.getSummary().toString();
+        mSelections = getSelections();
+        super.setEntries(mSelections);
+        super.setEntryValues(mSelections);
+        super.setDefaultValue(NONE);
+    }
+
+    @Override
+    public void setValue(String value) {
+        for(CharSequence sel : mSelections) {
+            if(sel.equals(value)) {
+                super.setValue(value);
+                setSummary(mOriginalSummary + " (" + value + ")");
+                return;
+            }
+        }
+        super.setValue(NONE);
+        setSummary(mOriginalSummary + " (" + value + ")");
+    }
+
+    @Override
+    public void setSummary(CharSequence summary) {
+        super.setSummary(mOriginalSummary + " (" + getEntry() + ")");
+    }
+
+    // Build and return an array of all available Bluetooth paired names
+    private CharSequence[] getSelections() {
+        BluetoothAdapter btAdapter = BluetoothAdapter.getDefaultAdapter();
+        if (null != btAdapter) {
+            int idx = 0;
+            Set<BluetoothDevice> setDevices = btAdapter.getBondedDevices();
+            CharSequence[] entries = new CharSequence[setDevices.size() + 1];
+            entries[idx++] = NONE;
+
+            for (BluetoothDevice btd : setDevices) {
+                entries[idx++] = btd.getName();
+            }
+
+            // tell bluetooth to stop scanning. it's a power issue
+            btAdapter.cancelDiscovery();
+            return entries;
+        }
+
+        CharSequence[] entries = new CharSequence[1];
+        entries[0] = NONE;
+        return entries;
+    }
+}
diff --git a/app/src/main/java/com/ds/avare/utils/CalendarHelper.java b/app/src/main/java/com/ds/avare/utils/CalendarHelper.java
index 86f74b84..e9ad667b 100644
--- a/app/src/main/java/com/ds/avare/utils/CalendarHelper.java
+++ b/app/src/main/java/com/ds/avare/utils/CalendarHelper.java
@@ -36,4 +36,8 @@ public class CalendarHelper {
     {
         return mCalendar.get(MINUTE);
     }
+    public int getSecond()
+    {
+        return mCalendar.get(Calendar.SECOND);
+    }
 }
diff --git a/app/src/main/java/com/ds/avare/utils/Helper.java b/app/src/main/java/com/ds/avare/utils/Helper.java
index d2186f7b..0ba1d0e5 100644
--- a/app/src/main/java/com/ds/avare/utils/Helper.java
+++ b/app/src/main/java/com/ds/avare/utils/Helper.java
@@ -216,6 +216,7 @@ public class Helper {
         // Break the hours and minutes out
         int eteHr  = eteRaw.hour;
         int eteMin = eteRaw.minute;
+        int eteSec = eteRaw.second;
 
         // Hours greater than 99 are not displayable
         if(eteHr > 99) {
@@ -223,13 +224,18 @@ public class Helper {
         }
 
         // Get the current local time hours and minutes
-        int etaHr = calendar.getHour();
+        int etaHr  = calendar.getHour();
         int etaMin = calendar.getMinute();
+        int etaSec = calendar.getSecond();
 
         // Add in our ETE to the current time, accounting for rollovers
+        etaSec += eteSec;   // Add the estimated seconds enroute to "now"
+        if(etaSec > 59) { etaSec -= 60; etaMin++; }	// account for seconds rollover
+
         etaMin += eteMin;	// Add the estimated minutes enroute to "now"
         if(etaMin > 59) { etaMin -= 60; etaHr++; }	// account for minute rollover
-        etaHr += eteHr;	// Now add the hours enroute
+
+        etaHr += eteHr;	    // Now add the hours enroute
         while(etaHr > 23) { etaHr -= 24; }	// account for midnight rollover
 
         // Format the hours and minutes
@@ -665,21 +671,17 @@ public class Helper {
 
     /***
      * Is the brgTrue to the left of the brgCourse line (extended).
-     * @param brgTrue true bearing to destination from current location
-     * @param brgCourse bearing to dest on COURSE line
+     * @param bT true bearing to destination from current location
+     * @param bC bearing on current COURSE line
      * @return true if it is LEFT, false if RIGHT
      */
-    public static boolean leftOfCourseLine(double brgTrue, double brgCourse) {
-    	if(brgCourse <= 180) {
-    		if(brgTrue >= brgCourse && brgTrue <= brgCourse + 180)
-    			return true;
-    		return false;
-    	}
+    public static boolean leftOfCourseLine(double bT, double bC) {
+        if(bC <= 180) {
+            return (bT >= bC && bT <= bC + 180);
+        }
 
-    	// brgCourse will be > 180 at this point
-    	if(brgTrue > brgCourse || brgTrue < brgCourse - 180)
-    		return true;
-    	return false;
+        // brgCourse will be > 180 at this point
+        return (bT > bC || bT < bC - 180);
     }
     
     /**
diff --git a/app/src/main/java/com/ds/avare/utils/InfoLines.java b/app/src/main/java/com/ds/avare/utils/InfoLines.java
index 38bd4e5d..3b8776df 100644
--- a/app/src/main/java/com/ds/avare/utils/InfoLines.java
+++ b/app/src/main/java/com/ds/avare/utils/InfoLines.java
@@ -460,7 +460,7 @@ public class InfoLines {
         if (mPref.isShowBackground()) {
             aPaint.setShadowLayer(0, 0, 0, 0);
             aPaint.setColor(aTextColorOpposite);
-            aPaint.setAlpha(0x7f);
+            aPaint.setAlpha(0x4f);
             canvas.drawRect(0, 0, mDisplayWidth, mShadowY, aPaint);
             aPaint.setAlpha(0xff);
         }
diff --git a/app/src/main/java/com/ds/avare/views/LocationView.java b/app/src/main/java/com/ds/avare/views/LocationView.java
index 5d405f04..f4d80331 100644
--- a/app/src/main/java/com/ds/avare/views/LocationView.java
+++ b/app/src/main/java/com/ds/avare/views/LocationView.java
@@ -912,17 +912,18 @@ public class LocationView extends View implements MultiTouchObjectCanvas<Object>
      * @param canvas what to draw them on
      */
     private void drawEdgeMarkers(Canvas canvas) {
-    	if(mPref.isShowEdgeTape()) {
-	        if(mPointProjection == null) {
-		        int x = (int)(mOrigin.getOffsetX(mGpsParams.getLongitude()));
-		        int y = (int)(mOrigin.getOffsetY(mGpsParams.getLatitude()));
-		        float pixPerNm = mOrigin.getPixelsInNmAtLatitude(1, mGpsParams.getLatitude());
-		      	mService.getEdgeTape().draw(canvas, mScale, pixPerNm, x, y, 
-		      			(int) mService.getInfoLines().getHeight(), getWidth(), getHeight());
-	        }
-    	}
+        if(mPref.isShowEdgeTape()) {
+            if(mPointProjection == null) {
+                int x = (int)(mOrigin.getOffsetX(mGpsParams.getLongitude()));
+                int y = (int)(mOrigin.getOffsetY(mGpsParams.getLatitude()));
+                float pixPerNm = mOrigin.getPixelsInNmAtLatitude(1, mGpsParams.getLatitude());
+                mService.getEdgeTape().draw(canvas, mScale, pixPerNm, x, y,
+                        (int) mService.getInfoLines().getHeight(), getWidth(), getHeight(),
+                        mService.getAutoPilot().isConnected() ? Color.BLUE : TEXT_COLOR_OPPOSITE);
+            }
+        }
     }
-    
+
     // Display all of the user defined waypoints if configured to do so
     private void drawUserDefinedWaypoints(Canvas canvas, DrawingContext ctx) {
         if(mPointProjection == null) {
@@ -940,10 +941,10 @@ public class LocationView extends View implements MultiTouchObjectCanvas<Object>
     // Draw the top status lines
     private void drawStatusLines(Canvas canvas) {
         mService.getInfoLines().drawCornerTextsDynamic(canvas, mPaint,
-                TEXT_COLOR, TEXT_COLOR_OPPOSITE, 4,
+                TEXT_COLOR, mService.getAutoPilot().isConnected() ? Color.BLUE : TEXT_COLOR_OPPOSITE, 4,
                 getWidth(), getHeight(), mErrorStatus, getPriorityMessage());
     }
-    
+
     // Display the nav comments
     private void drawNavComments(Canvas canvas) {
         NavComments navComments = mService.getNavComments();
