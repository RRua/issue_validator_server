diff --git a/app/src/androidTest/java/cc/calliope/mini/ApplicationTest.java b/app/src/androidTest/java/cc/calliope/mini/ApplicationTest.java
deleted file mode 100644
index 9bc3f6c..0000000
--- a/app/src/androidTest/java/cc/calliope/mini/ApplicationTest.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (c) 2015, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *  Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- *
- *  Redistributions in binary form must reproduce the above copyright notice,
- *   this list of conditions and the following disclaimer in the documentation
- *   and/or other materials provided with the distribution.
- *
- *  Neither the name of copyright holder nor the names of its
- *   contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package cc.calliope.miniy;
-
-import android.app.Application;
-import android.test.ApplicationTestCase;
-
-/**
- * <a href="http://d.android.com/tools/testing/testing_android.html">Testing Fundamentals</a>
- */
-public class ApplicationTest extends ApplicationTestCase<Application> {
-    public ApplicationTest() {
-        super(Application.class);
-    }
-}
\ No newline at end of file
diff --git a/app/src/androidTest/java/cc/calliope/mini/ExampleInstrumentedTest.java b/app/src/androidTest/java/cc/calliope/mini/ExampleInstrumentedTest.java
new file mode 100644
index 0000000..2e91fbc
--- /dev/null
+++ b/app/src/androidTest/java/cc/calliope/mini/ExampleInstrumentedTest.java
@@ -0,0 +1,26 @@
+package cc.calliope.mini;
+
+import android.content.Context;
+
+import androidx.test.platform.app.InstrumentationRegistry;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.junit.Assert.*;
+
+/**
+ * Instrumented test, which will execute on an Android device.
+ *
+ * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
+ */
+@RunWith(AndroidJUnit4.class)
+public class ExampleInstrumentedTest {
+    @Test
+    public void useAppContext() {
+        // Context of the app under test.
+        Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
+        assertEquals("cc.calliope.mini_v2", appContext.getPackageName());
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/Aggregator.kt b/app/src/main/java/cc/calliope/mini/Aggregator.kt
new file mode 100644
index 0000000..4b4abc7
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/Aggregator.kt
@@ -0,0 +1,21 @@
+package cc.calliope.mini
+
+import no.nordicsemi.android.kotlin.ble.core.ServerDevice
+import no.nordicsemi.android.kotlin.ble.core.scanner.BleScanResult
+import no.nordicsemi.android.kotlin.ble.core.scanner.BleScanResultData
+import no.nordicsemi.android.kotlin.ble.core.scanner.BleScanResults
+
+class Aggregator {
+    private val devices = mutableMapOf<ServerDevice, MutableList<BleScanResultData>>()
+
+    private val results
+        get() = devices.map { BleScanResults(it.key, it.value) }
+
+    fun aggregate(scanItem: BleScanResult): List<BleScanResults> {
+        val data = scanItem.data
+        devices.getOrPut(scanItem.device) { mutableListOf() }.let {
+            if (data != null) it.add(data)
+        }
+        return results
+    }
+}
diff --git a/app/src/main/java/cc/calliope/mini/App.java b/app/src/main/java/cc/calliope/mini/App.java
new file mode 100644
index 0000000..da8327e
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/App.java
@@ -0,0 +1,32 @@
+package cc.calliope.mini;
+
+import android.app.Application;
+import android.util.Log;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+import androidx.annotation.IntDef;
+import cc.calliope.mini.utils.Utils;
+
+public class App extends Application {
+    public static final int APP_STATE_STANDBY = 0;
+    public static final int APP_STATE_CONNECTING = 1;
+    public static final int APP_STATE_FLASHING = 2;
+    public static final int APP_STATE_DISCONNECTING = 3;
+
+    @IntDef({APP_STATE_STANDBY, APP_STATE_CONNECTING, APP_STATE_FLASHING, APP_STATE_DISCONNECTING})
+    @Retention(RetentionPolicy.SOURCE)
+    public @interface AppState {
+    }
+    private int appState;
+
+    public int getAppState() {
+        return appState;
+    }
+
+    public void setAppState(@AppState int appState) {
+        Utils.log(Log.ASSERT, "APP", "State: " + appState);
+        this.appState = appState;
+    }
+}
diff --git a/app/src/main/java/cc/calliope/mini/AppCompatPreferenceActivity.java b/app/src/main/java/cc/calliope/mini/AppCompatPreferenceActivity.java
deleted file mode 100644
index 5542043..0000000
--- a/app/src/main/java/cc/calliope/mini/AppCompatPreferenceActivity.java
+++ /dev/null
@@ -1,109 +0,0 @@
-package cc.calliope.mini;
-
-import android.content.res.Configuration;
-import android.os.Bundle;
-import android.preference.PreferenceActivity;
-import android.support.annotation.LayoutRes;
-import android.support.annotation.Nullable;
-import android.support.v7.app.ActionBar;
-import android.support.v7.app.AppCompatDelegate;
-import android.support.v7.widget.Toolbar;
-import android.view.MenuInflater;
-import android.view.View;
-import android.view.ViewGroup;
-
-/**
- * A {@link android.preference.PreferenceActivity} which implements and proxies the necessary calls
- * to be used with AppCompat.
- */
-public abstract class AppCompatPreferenceActivity extends PreferenceActivity {
-
-    private AppCompatDelegate mDelegate;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        getDelegate().installViewFactory();
-        getDelegate().onCreate(savedInstanceState);
-        super.onCreate(savedInstanceState);
-    }
-
-    @Override
-    protected void onPostCreate(Bundle savedInstanceState) {
-        super.onPostCreate(savedInstanceState);
-        getDelegate().onPostCreate(savedInstanceState);
-    }
-
-    public ActionBar getSupportActionBar() {
-        return getDelegate().getSupportActionBar();
-    }
-
-    public void setSupportActionBar(@Nullable Toolbar toolbar) {
-        getDelegate().setSupportActionBar(toolbar);
-    }
-
-    @Override
-    public MenuInflater getMenuInflater() {
-        return getDelegate().getMenuInflater();
-    }
-
-    @Override
-    public void setContentView(@LayoutRes int layoutResID) {
-        getDelegate().setContentView(layoutResID);
-    }
-
-    @Override
-    public void setContentView(View view) {
-        getDelegate().setContentView(view);
-    }
-
-    @Override
-    public void setContentView(View view, ViewGroup.LayoutParams params) {
-        getDelegate().setContentView(view, params);
-    }
-
-    @Override
-    public void addContentView(View view, ViewGroup.LayoutParams params) {
-        getDelegate().addContentView(view, params);
-    }
-
-    @Override
-    protected void onPostResume() {
-        super.onPostResume();
-        getDelegate().onPostResume();
-    }
-
-    @Override
-    protected void onTitleChanged(CharSequence title, int color) {
-        super.onTitleChanged(title, color);
-        getDelegate().setTitle(title);
-    }
-
-    @Override
-    public void onConfigurationChanged(Configuration newConfig) {
-        super.onConfigurationChanged(newConfig);
-        getDelegate().onConfigurationChanged(newConfig);
-    }
-
-    @Override
-    protected void onStop() {
-        super.onStop();
-        getDelegate().onStop();
-    }
-
-    @Override
-    protected void onDestroy() {
-        super.onDestroy();
-        getDelegate().onDestroy();
-    }
-
-    public void invalidateOptionsMenu() {
-        getDelegate().invalidateOptionsMenu();
-    }
-
-    private AppCompatDelegate getDelegate() {
-        if (mDelegate == null) {
-            mDelegate = AppCompatDelegate.create(this, null);
-        }
-        return mDelegate;
-    }
-}
diff --git a/app/src/main/java/cc/calliope/mini/CurrentDevice.kt b/app/src/main/java/cc/calliope/mini/CurrentDevice.kt
new file mode 100644
index 0000000..29ca840
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/CurrentDevice.kt
@@ -0,0 +1,27 @@
+package cc.calliope.mini
+
+import android.os.Parcel
+import android.os.Parcelable
+
+data class CurrentDevice(
+    var address: String,
+    var pattern: String
+) : Parcelable {
+    constructor(parcel: Parcel) : this(
+        parcel.readString() ?: "",
+        parcel.readString() ?: ""
+    )
+
+    override fun writeToParcel(parcel: Parcel, flags: Int) {
+        parcel.writeString(address)
+        parcel.writeString(pattern)
+    }
+
+    override fun describeContents(): Int = 0
+
+    companion object CREATOR : Parcelable.Creator<CurrentDevice> {
+        override fun createFromParcel(parcel: Parcel): CurrentDevice = CurrentDevice(parcel)
+
+        override fun newArray(size: Int): Array<CurrentDevice?> = arrayOfNulls(size)
+    }
+}
diff --git a/app/src/main/java/cc/calliope/mini/DFUActivity.java b/app/src/main/java/cc/calliope/mini/DFUActivity.java
deleted file mode 100644
index 3506738..0000000
--- a/app/src/main/java/cc/calliope/mini/DFUActivity.java
+++ /dev/null
@@ -1,330 +0,0 @@
-package cc.calliope.mini;
-
-import android.arch.lifecycle.ViewModelProviders;
-import android.bluetooth.BluetoothDevice;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.os.Bundle;
-import android.support.v4.content.LocalBroadcastManager;
-import android.support.v7.app.AppCompatActivity;
-import android.util.Log;
-import android.widget.TextView;
-
-import java.lang.reflect.Method;
-
-import cc.calliope.mini.adapter.ExtendedBluetoothDevice;
-import cc.calliope.mini.service.DfuService;
-import cc.calliope.mini.viewmodels.BlinkyViewModel;
-import no.nordicsemi.android.error.GattError;
-
-public class DFUActivity extends AppCompatActivity {
-
-
-    private DFUResultReceiver dfuResultReceiver;
-    private static final String TAG = DFUActivity.class.getSimpleName();
-
-    private int mActivityState;
-
-    private String m_BinSizeStats = "0";
-    private String m_MicroBitFirmware = "0.0";
-    private long starttime;
-
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity_dfu);
-
-        final Intent intent = getIntent();
-        final ExtendedBluetoothDevice device = intent.getParcelableExtra("cc.calliope.mini.EXTRA_DEVICE");
-
-        Bundle extras = intent.getExtras();
-        final String file = extras.getString("EXTRA_FILE");
-
-        final String deviceName = device.getName();
-
-        final BlinkyViewModel viewModel = ViewModelProviders.of(this).get(BlinkyViewModel.class);
-        final TextView deviceInfo = findViewById(R.id.statusInfo);
-
-//        unpairDevice(device.getDevice());
-//        deviceInfo.setText("Repairing...");
-//        pairDevice(device.getDevice());
-        // TODO: https://stackoverflow.com/questions/19047995/programmatically-pair-bluetooth-device-without-the-user-entering-pin
-
-//        viewModel.connect(device);
-//        deviceInfo.setText("warte auf Mini... (A+B+Reset)");
-//        viewModel.isDeviceReady().observe(this, deviceReady -> {
-//            viewModel.startDFU();
-            initiateFlashing();
-//        });
-
-    }
-
-
-
-    private void pairDevice(BluetoothDevice device) {
-        try {
-            Log.d(TAG, "Start Pairing...");
-
-            //waitingForBonding = true;
-
-            Method m = device.getClass()
-                    .getMethod("createBond", (Class[]) null);
-            m.invoke(device, (Object[]) null);
-
-            Log.d(TAG, "Pairing finished.");
-        } catch (Exception e) {
-            Log.e(TAG, e.getMessage());
-        }
-    }
-
-    private void unpairDevice(BluetoothDevice device) {
-        try {
-            Method m = device.getClass()
-                    .getMethod("removeBond", (Class[]) null);
-            m.invoke(device, (Object[]) null);
-        } catch (Exception e) {
-            Log.e(TAG, e.getMessage());
-        }
-    }
-
-
-    /**
-     * Prepares for flashing process.
-     * <p/>
-     * <p>>Unregisters DFU receiver, sets activity state to the find device state,
-     * registers callbacks requisite for flashing and starts flashing.</p>
-     */
-    protected void initiateFlashing() {
-        if(dfuResultReceiver != null) {
-            LocalBroadcastManager.getInstance(DFUActivity.this).unregisterReceiver(dfuResultReceiver);
-            dfuResultReceiver = null;
-        }
-//        setActivityState(cc.calliope.mini.data.model.ui.FlashActivityState.FLASH_STATE_FIND_DEVICE);
-        registerCallbacksForFlashing();
-        startFlashing();
-    }
-
-    /**
-     * Updates UI of current connection status and device name.
-     */
-    private void setConnectedDeviceText() {
-        // TODO
-            return;
-    }
-
-
-    /**
-     * Creates and starts service to flash a program to a micro:bit board.
-     */
-    protected void startFlashing() {
-//        logi(">>>>>>>>>>>>>>>>>>> startFlashing called  >>>>>>>>>>>>>>>>>>>  ");
-        //Reset all stats value
-//        m_BinSizeStats = "0";
-//        m_MicroBitFirmware = "0.0";
-//        m_HexFileSizeStats = FileUtils.getFileSize(mProgramToSend.filePath);
-
-        final Intent intent = getIntent();
-        final ExtendedBluetoothDevice device = intent.getParcelableExtra("cc.calliope.mini.EXTRA_DEVICE");
-
-        Bundle extras = intent.getExtras();
-        final String file = extras.getString("EXTRA_FILE");
-
-//        MBApp application = MBApp.getApp();
-
-//        final Intent service = new Intent(application, DfuService.class);
-        final Intent service = new Intent(this, DfuService.class);
-
-//        service.putExtra(DfuService.EXTRA_DEVICE_ADDRESS, currentMicrobit.mAddress);
-//        service.putExtra(DfuService.EXTRA_DEVICE_NAME, currentMicrobit.mPattern);
-//        service.putExtra(DfuService.EXTRA_DEVICE_PAIR_CODE, currentMicrobit.mPairingCode);
-//        service.putExtra(DfuService.EXTRA_FILE_MIME_TYPE, DfuService.MIME_TYPE_OCTET_STREAM);
-//        service.putExtra(DfuService.EXTRA_FILE_PATH, mProgramToSend.filePath); // a path or URI must be provided.
-//        service.putExtra(DfuService.EXTRA_KEEP_BOND, false);
-//        service.putExtra(DfuService.INTENT_REQUESTED_PHASE, 2);
-
-        service.putExtra(DfuService.EXTRA_DEVICE_ADDRESS, device.getAddress());
-        service.putExtra(DfuService.EXTRA_DEVICE_NAME, device.getName());
-        service.putExtra(DfuService.EXTRA_DEVICE_PAIR_CODE, 0);
-        service.putExtra(DfuService.EXTRA_FILE_MIME_TYPE, DfuService.MIME_TYPE_OCTET_STREAM);
-        service.putExtra(DfuService.EXTRA_FILE_PATH, file); // a path or URI must be provided.
-        service.putExtra(DfuService.EXTRA_KEEP_BOND, false);
-        service.putExtra(DfuService.INTENT_REQUESTED_PHASE, 2);
-
-        Log.i("DFUExtra", "mAddress: "+device.getAddress());
-        Log.i("DFUExtra", "mPattern: "+device.getName());
-        Log.i("DFUExtra", "mPairingCode: "+0);
-        Log.i("DFUExtra", "MIME_TYPE_OCTET_STREAM: "+DfuService.MIME_TYPE_OCTET_STREAM);
-        Log.i("DFUExtra", "filePath: "+file);
-
-        Log.i("DFUExtra", "Start Flashing");
-
-        startService(service);
-
-    }
-
-    /**
-     * Registers callbacks that allows to handle flashing process
-     * and react to flashing progress, errors and log some messages.
-     */
-    private void registerCallbacksForFlashing() {
-        IntentFilter filter = new IntentFilter();
-        filter.addAction(DfuService.BROADCAST_PROGRESS);
-        filter.addAction(DfuService.BROADCAST_ERROR);
-        filter.addAction(DfuService.BROADCAST_LOG);
-        dfuResultReceiver = new DFUResultReceiver();
-
-        LocalBroadcastManager.getInstance(DFUActivity.this).registerReceiver(dfuResultReceiver, filter);
-    }
-
-
-
-    /**
-     * Represents a broadcast receiver that allows to handle states of
-     * flashing process.
-     */
-    class DFUResultReceiver extends BroadcastReceiver {
-
-        private boolean isCompleted = false;
-        private boolean inInit = false;
-        private boolean inProgress = false;
-
-//        private View.OnClickListener okFinishFlashingHandler = new View.OnClickListener() {
-//            @Override
-//            public void onClick(View v) {
-//            }
-//        };
-
-        long starttime = 0;
-        long millis = 0;
-
-        @Override
-        public void onReceive(Context context, Intent intent) {
-
-            final TextView deviceInfo = findViewById(R.id.statusInfo);
-            final TextView timerText = findViewById(R.id.timerText);
-            String message = "Broadcast intent detected " + intent.getAction();
-//            logi("DFUResultReceiver.onReceive :: " + message);
-            Log.e("DFUResultReceiver", " "+intent.getAction());
-            if(intent.getAction().equals(DfuService.BROADCAST_LOG) || intent.getAction().equals(DfuService.BROADCAST_ERROR)) {
-                String state = intent.getStringExtra(DfuService.EXTRA_DATA);
-                Log.w("DFULogStatus", " "+state);
-            } else if(intent.getAction().equals(DfuService.BROADCAST_PROGRESS)) {
-
-                int state = intent.getIntExtra(DfuService.EXTRA_DATA, 0);
-                Log.w("DFUResultStatus", " "+state);
-
-                if(starttime == 0)
-                    starttime = System.currentTimeMillis();
-                millis = System.currentTimeMillis() - starttime;
-
-
-                timerText.setText(millis + "");
-
-                if(millis >= 20000 && state < 0 && state != -5) {
-//                    timerText.setText(millis + " RESTART"); // TODO Restart activity OR dfu if it hängs
-//                    this.recreate();
-//                    Intent intentX = getIntent();
-//                    finish();
-//                    startActivity(intentX);
-                }
-
-                if(state < 0) {
-//                    deviceInfo.setText("Initialisiere... "+state);
-                    timerText.setText(R.string.info_text_uploading_init);
-
-                    switch(state) {
-                        case DfuService.PROGRESS_STARTING:
-                            break;
-                        case DfuService.PROGRESS_COMPLETED:
-                            if(!isCompleted) {
-                                dfuResultReceiver = null;
-                            }
-                            Log.e("OWN", "Fertig");
-                            isCompleted = true;
-                            inInit = false;
-                            inProgress = false;
-
-                            finish();
-
-                            break;
-                        case DfuService.PROGRESS_DISCONNECTING:
-                            Log.e(TAG, "Progress disconnecting");
-                            break;
-
-                        case DfuService.PROGRESS_CONNECTING:
-                            if((!inInit) && (!isCompleted)) {
-
-//                                countOfReconnecting = 0;
-                            }
-
-                            inInit = true;
-                            isCompleted = false;
-                            break;
-                        case DfuService.PROGRESS_VALIDATING:
-                            break;
-                        case DfuService.PROGRESS_WAITING_REBOOT:
-                            break;
-                        case DfuService.PROGRESS_VALIDATION_FAILED:
-                            dfuResultReceiver = null;
-                            break;
-                        case DfuService.PROGRESS_ABORTED:
-                            dfuResultReceiver = null;
-//                            removeReconnectionRunnable();
-                            break;
-                        case DfuService.PROGRESS_SERVICE_NOT_FOUND:
-                            Log.e(TAG, "service not found");
-                            dfuResultReceiver = null;
-//                            removeReconnectionRunnable();
-                            break;
-
-                    }
-                } else if((state > 0) && (state < 100)) {
-                    deviceInfo.setText(state+"%");
-                    timerText.setText(R.string.info_text_uploading);
-                    if(!inProgress) {
-
-                        inProgress = true;
-
-                    }
-
-                }
-            } else if(intent.getAction().equals(DfuService.BROADCAST_ERROR)) {
-                deviceInfo.setText("Fehler!");
-                int errorCode = intent.getIntExtra(DfuService.EXTRA_DATA, 0);
-
-                if(errorCode == DfuService.ERROR_FILE_INVALID) {
-//                    notAValidFlashHexFile = true;
-                }
-
-                String error_message = GattError.parse(errorCode);
-
-                if(errorCode == DfuService.ERROR_FILE_INVALID) {
-//                    error_message += getString(R.string.reset_microbit_because_of_hex_file_wrong);
-                }
-                deviceInfo.setText("Fehler! "+error_message);
-                dfuResultReceiver = null;
-
-//                removeReconnectionRunnable();
-            } else if(intent.getAction().equals(DfuService.BROADCAST_LOG)) {
-                //Only used for Stats at the moment
-                String data;
-                int logLevel = intent.getIntExtra(DfuService.EXTRA_LOG_LEVEL, 0);
-                switch(logLevel) {
-                    case DfuService.LOG_LEVEL_BINARY_SIZE:
-                        data = intent.getStringExtra(DfuService.EXTRA_DATA);
-                        m_BinSizeStats = data;
-                        break;
-                    case DfuService.LOG_LEVEL_FIRMWARE:
-                        data = intent.getStringExtra(DfuService.EXTRA_DATA);
-                        m_MicroBitFirmware = data;
-                        break;
-                }
-            }
-        }
-
-    }
-
-}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/ExtendedBluetoothDevice.java b/app/src/main/java/cc/calliope/mini/ExtendedBluetoothDevice.java
new file mode 100644
index 0000000..11d3f17
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/ExtendedBluetoothDevice.java
@@ -0,0 +1,179 @@
+/*
+ * Copyright (c) 2010 - 2017, Nordic Semiconductor ASA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form, except as embedded into a Nordic
+ *    Semiconductor ASA integrated circuit in a product or a software update for
+ *    such product, must reproduce the above copyright notice, this list of
+ *    conditions and the following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * 4. This software, with or without modification, must only be used with a
+ *    Nordic Semiconductor ASA integrated circuit.
+ *
+ * 5. Any software provided in binary form under this license must not be reverse
+ *    engineered, decompiled, modified and/or disassembled.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package cc.calliope.mini;
+
+import android.bluetooth.BluetoothDevice;
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import java.util.Date;
+import java.util.Objects;
+
+import androidx.annotation.NonNull;
+import cc.calliope.mini.utils.Version;
+import no.nordicsemi.android.support.v18.scanner.ScanResult;
+
+public class ExtendedBluetoothDevice implements Parcelable {
+
+    private static final long RELEVANT_LIMIT; //the time during which the device is relevant in ms
+
+    static {
+        if (Version.VERSION_O_AND_NEWER) {
+            RELEVANT_LIMIT = 5000;
+        } else {
+            RELEVANT_LIMIT = 10000;
+        }
+    }
+
+    private final BluetoothDevice device;
+    private String name;
+    private String pattern;
+    private int rssi;
+    private long recentUpdate;
+
+    public ExtendedBluetoothDevice(final ScanResult scanResult) {
+        this.device = scanResult.getDevice();
+        this.name = scanResult.getScanRecord().getDeviceName();
+        this.pattern = "00000";
+        this.rssi = scanResult.getRssi();
+        this.recentUpdate = new Date().getTime();
+    }
+
+    public BluetoothDevice getDevice() {
+        return device;
+    }
+
+    public String getAddress() {
+        return device.getAddress();
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public String getPattern() {
+        return pattern;
+    }
+
+    public void setName(final String name) {
+        this.name = name;
+    }
+
+    public void setPattern(final String pattern) {
+        this.pattern = pattern;
+    }
+
+    public int getRssi() {
+        return rssi;
+    }
+
+    public void setRssi(final int rssi) {
+        this.rssi = rssi;
+    }
+
+    public float getRecentUpdate() {
+        return recentUpdate;
+    }
+
+    public void setRecentUpdate(long recentUpdate) {
+        this.recentUpdate = recentUpdate;
+    }
+
+    public boolean isRelevant() {
+        long currentTime = new Date().getTime();
+        return currentTime - recentUpdate < RELEVANT_LIMIT;
+    }
+
+    public boolean matches(final ScanResult scanResult) {
+        return device.getAddress().equals(scanResult.getDevice().getAddress());
+    }
+
+    @Override
+    public boolean equals(final Object o) {
+        if (o instanceof ExtendedBluetoothDevice) {
+            final ExtendedBluetoothDevice that = (ExtendedBluetoothDevice) o;
+            return device.getAddress().equals(that.device.getAddress());
+        }
+        return super.equals(o);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(device.getAddress());
+    }
+
+    @NonNull
+    @Override
+    public String toString() {
+        return device.getAddress() + " " + pattern;
+    }
+
+    // Parcelable implementation
+
+    private ExtendedBluetoothDevice(final Parcel in) {
+        device = in.readParcelable(BluetoothDevice.class.getClassLoader());
+        name = in.readString();
+        pattern = in.readString();
+        rssi = in.readInt();
+    }
+
+    @Override
+    public void writeToParcel(final Parcel parcel, final int flags) {
+        parcel.writeParcelable(device, flags);
+        parcel.writeString(name);
+        parcel.writeString(pattern);
+        parcel.writeInt(rssi);
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    public static final Creator<ExtendedBluetoothDevice> CREATOR = new Creator<>() {
+        @Override
+        public ExtendedBluetoothDevice createFromParcel(final Parcel source) {
+            return new ExtendedBluetoothDevice(source);
+        }
+
+        @Override
+        public ExtendedBluetoothDevice[] newArray(final int size) {
+            return new ExtendedBluetoothDevice[size];
+        }
+    };
+}
diff --git a/app/src/main/java/cc/calliope/mini/FileWrapper.java b/app/src/main/java/cc/calliope/mini/FileWrapper.java
new file mode 100644
index 0000000..c91b91b
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/FileWrapper.java
@@ -0,0 +1,47 @@
+package cc.calliope.mini;
+
+import java.io.File;
+
+import cc.calliope.mini.fragment.editors.Editor;
+
+public class FileWrapper {
+    private final File file;
+    private final Editor editor;
+
+    public FileWrapper(File file, Editor editor) {
+        this.file = file;
+        this.editor = editor;
+    }
+
+    public File getFile() {
+        return file;
+    }
+
+    public Editor getEditor() {
+        return editor;
+    }
+
+    public String getName(){
+        return file.getName();
+    }
+
+    public long lastModified(){
+        return file.lastModified();
+    }
+
+    public String getAbsolutePath(){
+        return file.getAbsolutePath();
+    }
+
+    public boolean exists(){
+        return file.exists();
+    }
+
+    public boolean delete(){
+        return file.delete();
+    }
+
+    public boolean renameTo(File dest){
+        return file.renameTo(dest);
+    }
+}
diff --git a/app/src/main/java/cc/calliope/mini/InfoActivity.java b/app/src/main/java/cc/calliope/mini/InfoActivity.java
deleted file mode 100644
index b0f47ba..0000000
--- a/app/src/main/java/cc/calliope/mini/InfoActivity.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package cc.calliope.mini;
-
-
-import android.content.Intent;
-import android.os.Bundle;
-import android.support.v7.app.AppCompatActivity;
-import android.text.Html;
-import android.text.Spanned;
-import android.view.View;
-import android.widget.ImageView;
-import android.widget.TextView;
-
-public class InfoActivity extends AppCompatActivity {
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity_info);
-
-        TextView tv = findViewById(R.id.infoTextView);
-        Spanned sp = Html.fromHtml( getString(R.string.info_text));
-        tv.setText(sp);
-
-        ImageView button_back = findViewById(R.id.button_back);
-        button_back.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                final Intent intent = new Intent(InfoActivity.this, MainActivity.class);
-                startActivity(intent);
-            }
-        });
-
-
-    }
-}
diff --git a/app/src/main/java/cc/calliope/mini/LetterMapping.kt b/app/src/main/java/cc/calliope/mini/LetterMapping.kt
new file mode 100644
index 0000000..3febe1f
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/LetterMapping.kt
@@ -0,0 +1,15 @@
+package cc.calliope.mini;
+
+enum class LetterMapping(val number: Char) {
+    Z('1'), U('1'),
+    V('2'), O('2'),
+    G('3'), I('3'),
+    P('4'), E('4'),
+    T('5'), A('5');
+
+    companion object {
+        fun getNumber(letter: Char): Char {
+            return values().firstOrNull { it.name[0] == letter.uppercaseChar() }?.number ?: letter
+        }
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/MBApp.java b/app/src/main/java/cc/calliope/mini/MBApp.java
deleted file mode 100644
index e5e91c9..0000000
--- a/app/src/main/java/cc/calliope/mini/MBApp.java
+++ /dev/null
@@ -1,68 +0,0 @@
-package cc.calliope.mini;
-
-import android.app.Application;
-import android.graphics.Typeface;
-import android.util.Log;
-
-//import com.samsung.microbit.core.GoogleAnalyticsManager;
-
-/**
- * Represents a custom class of the app.
- * Provides some resources that use along app modules,
- * such as app context, font styles and etc.
- */
-public class MBApp extends Application {
-
-    private static MBApp app = null;
-
-    private Typeface mTypeface;
-    private Typeface mBoldTypeface;
-    private Typeface mRobotoTypeface;
-
-    private boolean justPaired;
-
-    @Override
-    public void onCreate() {
-        super.onCreate();
-        app = this;
-        initTypefaces();
-//        GoogleAnalyticsManager.createInstance(this);
-
-        Log.d("MBApp OWN", "App Created");
-    }
-
-    /**
-     * Creates font styles from the assets and initializes typefaces.
-     */
-    private void initTypefaces() {
-        mTypeface = Typeface.createFromAsset(getAssets(), "fonts/GT-Walsheim.otf");
-        mBoldTypeface = Typeface.createFromAsset(getAssets(), "fonts/GT-Walsheim-Bold.otf");
-        mRobotoTypeface = Typeface.createFromAsset(getAssets(), "fonts/Roboto-Regular.ttf");
-    }
-
-    public void setJustPaired(boolean justPaired) {
-        this.justPaired = justPaired;
-    }
-
-    public boolean isJustPaired() {
-        return justPaired;
-    }
-
-    public Typeface getTypeface() {
-        return mTypeface;
-    }
-
-    public Typeface getTypefaceBold() {
-        return mBoldTypeface;
-    }
-
-    public Typeface getRobotoTypeface() {
-        return mRobotoTypeface;
-    }
-
-    public static MBApp getApp() {
-        Log.d("MBApp OWN", "TEST");
-        return app;
-    }
-
-}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/MainActivity.java b/app/src/main/java/cc/calliope/mini/MainActivity.java
deleted file mode 100644
index 1fbb06f..0000000
--- a/app/src/main/java/cc/calliope/mini/MainActivity.java
+++ /dev/null
@@ -1,107 +0,0 @@
-package cc.calliope.mini;
-
-import android.content.Intent;
-import android.os.Bundle;
-import android.support.constraint.ConstraintLayout;
-import android.support.v7.app.AppCompatActivity;
-import android.view.View;
-import android.widget.ImageView;
-import android.widget.TextView;
-
-import cc.calliope.mini.adapter.ExtendedBluetoothDevice;
-
-public class MainActivity extends AppCompatActivity {
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity_main);
-
-        final Intent intent = getIntent();
-        final ExtendedBluetoothDevice device = intent.getParcelableExtra("cc.calliope.mini.EXTRA_DEVICE");
-        if (device != null) {
-
-            final String deviceName = device.getName();
-
-            final TextView deviceInfo = findViewById(R.id.deviceInfo);
-            deviceInfo.setText(deviceName + " " + R.string.text_connected_with);
-
-            final ImageView pattern1 = findViewById(R.id.pattern1);
-            final ImageView pattern2 = findViewById(R.id.pattern2);
-            final ImageView pattern3 = findViewById(R.id.pattern3);
-            final ImageView pattern4 = findViewById(R.id.pattern4);
-            final ImageView pattern5 = findViewById(R.id.pattern5);
-            pattern1.setImageResource(device.getDevicePattern(0));
-            pattern2.setImageResource(device.getDevicePattern(1));
-            pattern3.setImageResource(device.getDevicePattern(2));
-            pattern4.setImageResource(device.getDevicePattern(3));
-            pattern5.setImageResource(device.getDevicePattern(4));
-        }
-
-        ImageView button_info = findViewById(R.id.button_info);
-        button_info.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                final Intent intent = new Intent(MainActivity.this, InfoActivity.class);
-                startActivity(intent);
-            }
-        });
-
-        ConstraintLayout button_scanner = findViewById(R.id.button_scanner);
-        button_scanner.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                final Intent intent = new Intent(MainActivity.this, ScannerActivity.class);
-                startActivity(intent);
-            }
-        });
-
-        ConstraintLayout buttonDemoScript = findViewById(R.id.buttonDemoScript);
-        buttonDemoScript.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                final Intent intent = new Intent(MainActivity.this, editorAcitvity.class);
-                if(device != null) intent.putExtra("cc.calliope.mini.EXTRA_DEVICE", device);
-                intent.putExtra("TARGET_NAME", "BIBLIOTHEK");
-                intent.putExtra("TARGET_URL", getString(R.string.start_programm_url) );
-                startActivity(intent);
-            }
-        });
-
-        ConstraintLayout button_editor = findViewById(R.id.button_editor);
-        button_editor.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                final Intent intent = new Intent(MainActivity.this, selectEditorActivity.class);
-                if(device != null) intent.putExtra("cc.calliope.mini.EXTRA_DEVICE", device);
-                startActivity(intent);
-            }
-        });
-
-        ConstraintLayout button_code = findViewById(R.id.button_code);
-        button_code.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                final Intent intent = new Intent(MainActivity.this, myCodeActivity.class);
-                if(device != null) intent.putExtra("cc.calliope.mini.EXTRA_DEVICE", device);
-                startActivity(intent);
-            }
-        });
-
-
-    }
-
-    public void foo() {
- //       final Intent intent = new Intent(this, ScannerActivity.class);
-//        intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);
-  //      startActivity(intent);
-    }
-
-
-
-
-
-
-
-
-}
diff --git a/app/src/main/java/cc/calliope/mini/MyDeviceKt.kt b/app/src/main/java/cc/calliope/mini/MyDeviceKt.kt
new file mode 100644
index 0000000..618950b
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/MyDeviceKt.kt
@@ -0,0 +1,50 @@
+package cc.calliope.mini
+
+import android.os.SystemClock
+import cc.calliope.mini.utils.Version
+import no.nordicsemi.android.kotlin.ble.core.ServerDevice
+import no.nordicsemi.android.kotlin.ble.core.scanner.BleScanResultData
+import no.nordicsemi.android.kotlin.ble.core.scanner.BleScanResults
+
+class MyDeviceKt(bleScanResults: BleScanResults) {
+    companion object {
+        private val RELEVANT_LIMIT: Int = if (Version.VERSION_O_AND_NEWER) 5 else 10 // Секунди
+    }
+
+    private var serverDevice: ServerDevice = bleScanResults.device
+    private var bleScanResultData: BleScanResultData? = bleScanResults.lastScanResult
+
+    fun getAddress(): String {
+        return serverDevice.address
+    }
+
+    fun getName(): String {
+        return serverDevice.name
+    }
+
+    fun isBonded(): Boolean {
+        return serverDevice.isBonded
+    }
+
+    fun getPattern(): String {
+        val pattern = "[a-zA-Z :]+\\[([A-Z]{5})]".toRegex()
+        return pattern.find(serverDevice.name.uppercase())?.groupValues?.get(1) ?: ""
+    }
+
+    fun getNumPattern(): String {
+        return getPattern().map { LetterMapping.getNumber(it) }.joinToString("")
+    }
+
+    fun isActual(): Boolean {
+        bleScanResultData?.let {
+            val timeSinceBoot = nanosecondsToSeconds(SystemClock.elapsedRealtimeNanos())
+            val timeSinceScan = nanosecondsToSeconds(it.timestampNanos)
+            return timeSinceBoot - timeSinceScan < RELEVANT_LIMIT
+        }
+        return false
+    }
+
+    private fun nanosecondsToSeconds(nanoseconds: Long): Double {
+        return nanoseconds / 1_000_000_000.0
+    }
+}
diff --git a/app/src/main/java/cc/calliope/mini/PatternMatrixView.java b/app/src/main/java/cc/calliope/mini/PatternMatrixView.java
new file mode 100644
index 0000000..1afce5e
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/PatternMatrixView.java
@@ -0,0 +1,169 @@
+package cc.calliope.mini;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.drawable.Drawable;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.MotionEvent;
+import android.view.View;
+
+import androidx.annotation.DrawableRes;
+import androidx.annotation.NonNull;
+import androidx.core.content.ContextCompat;
+
+
+public class PatternMatrixView extends View {
+
+    private static final int SIZE = 5;
+    private final boolean[][] cell = new boolean[SIZE][SIZE];
+    private final String[][] letter = {
+            {"Z", "V", "G", "P", "T"},
+            {"U", "O", "I", "E", "A"}
+    };
+    private float cellSize;
+    private Drawable cellOnDrawable;
+    private Drawable cellOffDrawable;
+
+    public interface OnPatternChangeListener {
+        void onPatternChanged(String pattern);
+    }
+
+    private OnPatternChangeListener onPatternChangeListener;
+
+    public PatternMatrixView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        init();
+    }
+
+    public PatternMatrixView(Context context) {
+        super(context);
+        init();
+    }
+
+    private void init() {
+        setCheckBoxDrawables(R.drawable.pattern_selected, R.drawable.pattern_unselected);
+        for (int column = 0; column < SIZE; column++) {
+            cell[column][SIZE - 1] = true;
+        }
+    }
+
+    public void setOnCheckedChangeListener(OnPatternChangeListener listener) {
+        this.onPatternChangeListener = listener;
+    }
+
+    public void setCheckBoxDrawables(@DrawableRes int onDrawableRes, @DrawableRes int offDrawableRes) {
+        cellOnDrawable = ContextCompat.getDrawable(getContext(), onDrawableRes);
+        cellOffDrawable = ContextCompat.getDrawable(getContext(), offDrawableRes);
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        int width = MeasureSpec.getSize(widthMeasureSpec);
+        cellSize = width / (float) SIZE;
+        setMeasuredDimension(width, (int) (cellSize * SIZE));
+    }
+
+    @Override
+    protected void onDraw(@NonNull Canvas canvas) {
+        super.onDraw(canvas);
+        for (int i = 0; i < SIZE; i++) {
+            for (int j = 0; j < SIZE; j++) {
+                Drawable drawable = cell[i][j] ? cellOnDrawable : cellOffDrawable;
+                int left = (int) (i * cellSize);
+                int top = (int) (j * cellSize);
+                int right = (int) ((i + 1) * cellSize);
+                int bottom = (int) ((j + 1) * cellSize);
+
+                drawable.setBounds(left, top, right, bottom);
+                drawable.draw(canvas);
+            }
+        }
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+        int action = event.getAction();
+        int column = (int) (event.getX() / cellSize);
+        int number = (int) (event.getY() / cellSize);
+
+        if (action == MotionEvent.ACTION_DOWN) {
+            Log.i("MAIN", "column: " + column + "; Y: " + number);
+            if (column < SIZE && number < SIZE) {
+                if (cell[column][number] && number < SIZE - 1 && (number == 0 || !cell[column][number - 1])) {
+                    number++;
+                }
+                setColumn(column, number);
+
+                if (onPatternChangeListener != null) {
+                    onPatternChangeListener.onPatternChanged(getPattern());
+                }
+                return true;
+            }
+        }else if(action == MotionEvent.ACTION_UP){
+            if (column < SIZE && number < SIZE) {
+                return true;
+            }else {
+                return performClick();
+            }
+        }
+        return super.onTouchEvent(event);
+    }
+
+    @Override
+    public boolean performClick() {
+        return super.performClick();
+    }
+
+    private void setColumn(int column, int number) {
+        if (column < SIZE && number < SIZE) {
+            for (int i = 0; i < SIZE; i++) {
+                cell[column][i] = false;
+            }
+            for (int i = number; i < SIZE; i++) {
+                cell[column][i] = true;
+            }
+            invalidate();
+        }
+    }
+
+    public String getPattern() {
+        int[] counts = new int[SIZE];
+
+        for (int column = 0; column < SIZE; column++) {
+            for (int number = 0; number < SIZE; number++) {
+                if (cell[column][number]) {
+                    counts[column]++;
+                }
+            }
+        }
+
+        StringBuilder result = new StringBuilder();
+        for (int column = 0; column < counts.length; column++) {
+            result.append(letter[column % 2][counts[column] - 1]);
+        }
+
+        return result.toString();
+    }
+
+    public void setPattern(String pattern) {
+        if (pattern.length() != SIZE) {
+            throw new IllegalArgumentException("The string must contain " + SIZE + " letters.");
+        }
+
+        for (int i = 0; i < pattern.length(); i++) {
+            String letterToFind = String.valueOf(pattern.charAt(i)).toUpperCase();
+            int number = SIZE - (findLetterInMatrix(letterToFind, i % 2) + 1);
+            setColumn(i, number);
+        }
+    }
+
+    private int findLetterInMatrix(String letterToFind, int row) {
+        for (int i = 0; i < letter[row].length; i++) {
+            if (letter[row][i].equals(letterToFind)) {
+                return i;
+            }
+        }
+        throw new IllegalArgumentException("The letter '" + letterToFind + "' is not found in the matrix.");
+    }
+}
diff --git a/app/src/main/java/cc/calliope/mini/ProgressCollector.java b/app/src/main/java/cc/calliope/mini/ProgressCollector.java
new file mode 100644
index 0000000..2caeb58
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/ProgressCollector.java
@@ -0,0 +1,239 @@
+package cc.calliope.mini;
+
+import android.bluetooth.BluetoothDevice;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.ContextWrapper;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.util.Log;
+
+
+import org.microbit.android.partialflashing.PartialFlashingBaseService;
+
+import androidx.annotation.NonNull;
+import androidx.lifecycle.DefaultLifecycleObserver;
+import androidx.lifecycle.LifecycleOwner;
+import androidx.localbroadcastmanager.content.LocalBroadcastManager;
+import cc.calliope.mini.service.DfuControlService;
+import cc.calliope.mini.service.DfuService;
+import cc.calliope.mini.utils.Utils;
+import no.nordicsemi.android.dfu.DfuBaseService;
+import no.nordicsemi.android.error.GattError;
+
+import static android.bluetooth.BluetoothDevice.ACTION_BOND_STATE_CHANGED;
+import static android.bluetooth.BluetoothDevice.ERROR;
+import static android.bluetooth.BluetoothDevice.EXTRA_BOND_STATE;
+import static cc.calliope.mini.service.DfuControlService.UNIDENTIFIED;
+import static cc.calliope.mini.service.DfuControlService.EXTRA_BOARD_VERSION;
+import static cc.calliope.mini.service.DfuControlService.EXTRA_ERROR_CODE;
+import static cc.calliope.mini.service.DfuControlService.EXTRA_ERROR_MESSAGE;
+
+public class ProgressCollector extends ContextWrapper implements DefaultLifecycleObserver {
+    private static final String TAG = "ProgressCollector";
+    private final Context context;
+    private ProgressListener listener;
+
+    private final BroadcastReceiver bondStateReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            final BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+            if (device == null) {
+                return;
+            }
+
+            final String action = intent.getAction();
+            if (action == null) {
+                return;
+            }
+
+            // Take action depending on new bond state
+            if (action.equals(ACTION_BOND_STATE_CHANGED)) {
+                final int bondState = intent.getIntExtra(EXTRA_BOND_STATE, ERROR);
+                final int previousBondState = intent.getIntExtra(BluetoothDevice.EXTRA_PREVIOUS_BOND_STATE, ERROR);
+                listener.onBonding(device, bondState, previousBondState);
+            }
+        }
+    };
+
+    private final BroadcastReceiver dfuServiceReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            final String action = intent.getAction();
+            if (action == null) {
+                return;
+            }
+
+            switch (action) {
+                case DfuService.BROADCAST_PROGRESS -> {
+                    int extra = intent.getIntExtra(DfuService.EXTRA_DATA, 0);
+                    switch (extra) {
+                        case DfuService.PROGRESS_CONNECTING -> listener.onDeviceConnecting();
+                        case DfuService.PROGRESS_STARTING -> listener.onProcessStarting();
+                        case DfuService.PROGRESS_ENABLING_DFU_MODE -> listener.onEnablingDfuMode();
+                        case DfuService.PROGRESS_VALIDATING -> listener.onFirmwareValidating();
+                        case DfuService.PROGRESS_DISCONNECTING -> listener.onDeviceDisconnecting();
+                        case DfuService.PROGRESS_COMPLETED -> listener.onCompleted();
+                        case DfuService.PROGRESS_ABORTED -> listener.onAborted();
+                        default -> listener.onProgressChanged(extra);
+                    }
+                }
+                case DfuService.BROADCAST_ERROR -> {
+                    int code = intent.getIntExtra(DfuBaseService.EXTRA_DATA, 0);
+                    int type = intent.getIntExtra(DfuBaseService.EXTRA_ERROR_TYPE, 0);
+                    String message = switch (type) {
+                        case DfuBaseService.ERROR_TYPE_COMMUNICATION_STATE ->
+                                GattError.parseConnectionError(code);
+                        case DfuBaseService.ERROR_TYPE_DFU_REMOTE ->
+                                GattError.parseDfuRemoteError(code);
+                        default -> GattError.parse(code);
+                    };
+                    listener.onError(code, message);
+                }
+            }
+        }
+    };
+
+    private final BroadcastReceiver dfuControlServiceReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            final String action = intent.getAction();
+            if (action == null) {
+                return;
+            }
+
+            switch (action) {
+                case DfuControlService.BROADCAST_START -> listener.onEnablingDfuMode();
+                case DfuControlService.BROADCAST_COMPLETED -> {
+                    int boardVersion = intent.getIntExtra(EXTRA_BOARD_VERSION, UNIDENTIFIED);
+                    listener.onStartDfuService(boardVersion);
+                }
+                case DfuControlService.BROADCAST_FAILED -> listener.onDeviceDisconnecting();
+                case DfuControlService.BROADCAST_ERROR -> {
+                    int code = intent.getIntExtra(EXTRA_ERROR_CODE, -1);
+                    String message = intent.getStringExtra(EXTRA_ERROR_MESSAGE);
+                    listener.onError(code, message);
+                }
+            }
+        }
+    };
+
+    private final BroadcastReceiver partialFlashingServiceReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            final String action = intent.getAction();
+            if (action == null) {
+                return;
+            }
+
+            switch (action) {
+                case PartialFlashingBaseService.BROADCAST_PROGRESS -> {
+                    int percent = intent.getIntExtra(PartialFlashingBaseService.EXTRA_PROGRESS, 0);
+                    listener.onProgressChanged(percent);
+                }
+                case PartialFlashingBaseService.BROADCAST_START -> listener.onProcessStarting();
+                case PartialFlashingBaseService.BROADCAST_COMPLETE -> {
+                    listener.onCompleted();
+                    listener.onDeviceDisconnecting();
+                }
+                case PartialFlashingBaseService.BROADCAST_PF_FAILED -> {
+                    listener.onError(-1, "Partial Flashing FAILED");
+                }
+                case PartialFlashingBaseService.BROADCAST_PF_ATTEMPT_DFU -> {
+                    listener.onAttemptDfuMode();
+                }
+            }
+        }
+    };
+
+    public ProgressCollector(Context context) {
+        super(context);
+        this.context = context;
+        if (context instanceof ProgressListener) {
+            this.listener = (ProgressListener) context;
+        }
+    }
+
+    public void registerOnProgressListener(ProgressListener listener) {
+        this.listener = listener;
+    }
+
+    @Override
+    public void onCreate(@NonNull LifecycleOwner owner) {
+        DefaultLifecycleObserver.super.onCreate(owner);
+        Utils.log(TAG, "onCreate");
+    }
+
+    @Override
+    public void onStart(@NonNull LifecycleOwner owner) {
+        DefaultLifecycleObserver.super.onStart(owner);
+        Utils.log(TAG, "onStart");
+    }
+
+    @Override
+    public void onResume(@NonNull LifecycleOwner owner) {
+        DefaultLifecycleObserver.super.onResume(owner);
+        Utils.log(TAG, "onResume");
+    }
+
+    @Override
+    public void onPause(@NonNull LifecycleOwner owner) {
+        DefaultLifecycleObserver.super.onPause(owner);
+        Utils.log(TAG, "onPause");
+    }
+
+    @Override
+    public void onStop(@NonNull LifecycleOwner owner) {
+        DefaultLifecycleObserver.super.onStop(owner);
+        Utils.log(TAG, "onStop");
+    }
+
+    @Override
+    public void onDestroy(@NonNull LifecycleOwner owner) {
+        DefaultLifecycleObserver.super.onDestroy(owner);
+        Utils.log(TAG, "onDestroy");
+    }
+
+    public void registerReceivers() {
+        Utils.log(Log.WARN, TAG, "registerReceivers() listener: " + listener);
+        if (listener == null) {
+            return;
+        }
+        //BondStateReceiver
+        IntentFilter bondStateFilter = new IntentFilter();
+        bondStateFilter.addAction(ACTION_BOND_STATE_CHANGED);
+        registerReceiver(bondStateReceiver, bondStateFilter);
+
+        //DfuService
+        IntentFilter dfuServiceFilter = new IntentFilter();
+        dfuServiceFilter.addAction(DfuService.BROADCAST_PROGRESS);
+        dfuServiceFilter.addAction(DfuService.BROADCAST_ERROR);
+        LocalBroadcastManager.getInstance(context).registerReceiver(dfuServiceReceiver, dfuServiceFilter);
+
+        //DfuControlService
+        IntentFilter dfuControlServiceFilter = new IntentFilter();
+        dfuControlServiceFilter.addAction(DfuControlService.BROADCAST_START);
+        dfuControlServiceFilter.addAction(DfuControlService.BROADCAST_COMPLETED);
+        dfuControlServiceFilter.addAction(DfuControlService.BROADCAST_FAILED);
+        dfuControlServiceFilter.addAction(DfuControlService.BROADCAST_ERROR);
+        LocalBroadcastManager.getInstance(context).registerReceiver(dfuControlServiceReceiver, dfuControlServiceFilter);
+
+        //PartialFlashingService
+        IntentFilter partialFlashingServiceFilter = new IntentFilter();
+        partialFlashingServiceFilter.addAction(PartialFlashingBaseService.BROADCAST_PROGRESS);
+        partialFlashingServiceFilter.addAction(PartialFlashingBaseService.BROADCAST_START);
+        partialFlashingServiceFilter.addAction(PartialFlashingBaseService.BROADCAST_COMPLETE);
+        partialFlashingServiceFilter.addAction(PartialFlashingBaseService.BROADCAST_PF_FAILED);
+        partialFlashingServiceFilter.addAction(PartialFlashingBaseService.BROADCAST_PF_ATTEMPT_DFU);
+        LocalBroadcastManager.getInstance(context).registerReceiver(partialFlashingServiceReceiver, partialFlashingServiceFilter);
+
+    }
+
+    public void unregisterReceivers() {
+        Utils.log(Log.WARN, TAG, "unregisterReceivers()");
+        unregisterReceiver(bondStateReceiver);
+        LocalBroadcastManager.getInstance(context).unregisterReceiver(dfuServiceReceiver);
+        LocalBroadcastManager.getInstance(context).unregisterReceiver(dfuControlServiceReceiver);
+        LocalBroadcastManager.getInstance(context).unregisterReceiver(partialFlashingServiceReceiver);
+    }
+}
diff --git a/app/src/main/java/cc/calliope/mini/ProgressListener.java b/app/src/main/java/cc/calliope/mini/ProgressListener.java
new file mode 100644
index 0000000..a38efa7
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/ProgressListener.java
@@ -0,0 +1,35 @@
+package cc.calliope.mini;
+
+import android.bluetooth.BluetoothDevice;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+import androidx.annotation.IntDef;
+import androidx.annotation.NonNull;
+
+import static android.bluetooth.BluetoothDevice.BOND_BONDED;
+import static android.bluetooth.BluetoothDevice.BOND_BONDING;
+import static android.bluetooth.BluetoothDevice.BOND_NONE;
+
+import static cc.calliope.mini.service.DfuControlService.HardwareVersion;
+
+public interface ProgressListener {
+    @IntDef({BOND_BONDING, BOND_BONDED, BOND_NONE})
+    @Retention(RetentionPolicy.SOURCE)
+    @interface BondState {
+    }
+
+    void onDeviceConnecting();
+    void onProcessStarting();
+    void onAttemptDfuMode();
+    void onEnablingDfuMode();
+    void onFirmwareValidating();
+    void onDeviceDisconnecting();
+    void onCompleted();
+    void onAborted();
+    void onStartDfuService(@HardwareVersion final int hardwareVersion);
+    void onProgressChanged(int percent);
+    void onBonding(@NonNull BluetoothDevice device, @BondState int bondState, @BondState int previousBondState);
+    void onError(int code, String message);
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/ScanViewModelKt.kt b/app/src/main/java/cc/calliope/mini/ScanViewModelKt.kt
new file mode 100644
index 0000000..9525abf
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/ScanViewModelKt.kt
@@ -0,0 +1,49 @@
+package cc.calliope.mini
+
+import android.app.Application
+import androidx.lifecycle.AndroidViewModel
+import androidx.lifecycle.LiveData
+import androidx.lifecycle.MutableLiveData
+import androidx.lifecycle.viewModelScope
+import kotlinx.coroutines.cancel
+import kotlinx.coroutines.flow.launchIn
+import kotlinx.coroutines.flow.map
+import kotlinx.coroutines.flow.onEach
+import no.nordicsemi.android.kotlin.ble.core.scanner.BleNumOfMatches
+import no.nordicsemi.android.kotlin.ble.core.scanner.BleScanMode
+import no.nordicsemi.android.kotlin.ble.core.scanner.BleScanResults
+import no.nordicsemi.android.kotlin.ble.core.scanner.BleScannerCallbackType
+import no.nordicsemi.android.kotlin.ble.core.scanner.BleScannerMatchMode
+import no.nordicsemi.android.kotlin.ble.core.scanner.BleScannerSettings
+import no.nordicsemi.android.kotlin.ble.scanner.BleScanner
+
+class ScanViewModelKt(application: Application) : AndroidViewModel(application) {
+
+    private val _devices = MutableLiveData<List<BleScanResults>>()
+    val devices: LiveData<List<BleScanResults>> get() = _devices
+
+    fun startScan() {
+        val context = getApplication<Application>().applicationContext
+        val settings = BleScannerSettings(
+            BleScanMode.SCAN_MODE_BALANCED,
+            0L,
+            BleScannerCallbackType.CALLBACK_TYPE_ALL_MATCHES,
+            BleNumOfMatches.MATCH_NUM_MAX_ADVERTISEMENT,
+            BleScannerMatchMode.MATCH_MODE_AGGRESSIVE,
+            false,
+            null
+        )
+        //Create aggregator which will concat scan records with a device
+        val aggregator = Aggregator()
+
+        BleScanner(context).scan(settings)
+            .map { aggregator.aggregate(it) }// Add new device and return an aggregated list
+            .onEach { _devices.value = it } // Propagated state to UI
+            .launchIn(viewModelScope) // Scanning will stop after we leave the screen
+    }
+
+    fun stopScan() {
+        viewModelScope.cancel()
+    }
+}
+
diff --git a/app/src/main/java/cc/calliope/mini/ScannerActivity.java b/app/src/main/java/cc/calliope/mini/ScannerActivity.java
deleted file mode 100644
index cf7dab1..0000000
--- a/app/src/main/java/cc/calliope/mini/ScannerActivity.java
+++ /dev/null
@@ -1,270 +0,0 @@
-/*
- * Copyright (c) 2015, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *  Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- *
- *  Redistributions in binary form must reproduce the above copyright notice,
- *   this list of conditions and the following disclaimer in the documentation
- *   and/or other materials provided with the distribution.
- *
- *  Neither the name of copyright holder nor the names of its
- *   contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package cc.calliope.mini;
-
-import android.Manifest;
-import android.arch.lifecycle.ViewModelProviders;
-import android.bluetooth.BluetoothAdapter;
-import android.content.Intent;
-import android.graphics.drawable.AnimationDrawable;
-import android.net.Uri;
-import android.os.Build;
-import android.os.Bundle;
-import android.provider.Settings;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.support.v4.app.ActivityCompat;
-import android.support.v7.app.AppCompatActivity;
-import android.support.v7.widget.DividerItemDecoration;
-import android.support.v7.widget.LinearLayoutManager;
-import android.support.v7.widget.RecyclerView;
-import android.support.v7.widget.SimpleItemAnimator;
-import android.util.Log;
-import android.view.View;
-import android.widget.Button;
-import android.widget.ImageView;
-
-import butterknife.BindView;
-import butterknife.ButterKnife;
-import butterknife.OnClick;
-import cc.calliope.mini.adapter.DevicesAdapter;
-import cc.calliope.mini.adapter.ExtendedBluetoothDevice;
-import cc.calliope.mini.utils.Utils;
-import cc.calliope.mini.viewmodels.ScannerLiveData;
-import cc.calliope.mini.viewmodels.ScannerViewModel;
-
-public class ScannerActivity extends AppCompatActivity implements DevicesAdapter.OnItemClickListener {
-	private static final int REQUEST_ACCESS_FINE_LOCATION = 1022; // random number
-	private static final int REQUEST_ACCESS_BLUETOOTH_SCAN = 1023; // random number
-
-
-
-	private ScannerViewModel mScannerViewModel;
-	private AnimationDrawable pairAnimation;
-
-	@BindView(R.id.state_scanning) View mScanningView;
-	@BindView(R.id.no_devices)View mEmptyView;
-	@BindView(R.id.no_location_permission) View mNoLocationPermissionView;
-	@BindView(R.id.action_grant_location_permission) Button mGrantPermissionButton;
-	@BindView(R.id.action_permission_settings) Button mPermissionSettingsButton;
-	@BindView(R.id.no_location)	View mNoLocationView;
-	@BindView(R.id.bluetooth_off) View mNoBluetoothView;
-    @BindView(R.id.pairAnimationLayout) View mPairAnimation;
-
-	@Override
-	protected void onCreate(@Nullable final Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		setContentView(R.layout.activity_scanner);
-		ButterKnife.bind(this);
-
-//		final Toolbar toolbar = findViewById(R.id.toolbar);
-//		setSupportActionBar(toolbar);
-//		getSupportActionBar().setTitle(R.string.app_name);
-
-		// Create view model containing utility methods for scanning
-		mScannerViewModel = ViewModelProviders.of(this).get(ScannerViewModel.class);
-		mScannerViewModel.getScannerState().observe(this, this::startScan);
-
-		// Configure the recycler view
-		final RecyclerView recyclerView = findViewById(R.id.recycler_view_ble_devices);
-		recyclerView.setLayoutManager(new LinearLayoutManager(this));
-		final DividerItemDecoration dividerItemDecoration = new DividerItemDecoration(recyclerView.getContext(), DividerItemDecoration.VERTICAL);
-		recyclerView.addItemDecoration(dividerItemDecoration);
-		((SimpleItemAnimator) recyclerView.getItemAnimator()).setSupportsChangeAnimations(false);
-		final DevicesAdapter adapter = new DevicesAdapter(this, mScannerViewModel.getScannerState());
-		adapter.setOnItemClickListener(this);
-		recyclerView.setAdapter(adapter);
-
-        ImageView rocketImage = findViewById(R.id.pair_animation);
-        rocketImage.setBackgroundResource(R.drawable.pair_animation);
-        pairAnimation = (AnimationDrawable) rocketImage.getBackground();
-	}
-
-    @Override
-    protected void onStart() {
-		super.onStart();
-		pairAnimation.start();
-    }
-
-	@Override
-	protected void onStop() {
-		super.onStop();
-		stopScan();
-	}
-
-	@Override
-	public void onItemClick(final ExtendedBluetoothDevice device) {
-		final Intent controlMiniIntent = new Intent(this, cc.calliope.mini.MainActivity.class);
-		Log.i("DEVICE", device+"");
-		Log.i("DEVICE", device.getName()+"");
-		Log.i("DEVICE", device.getPattern()+"");
-
-		controlMiniIntent.putExtra("cc.calliope.mini.EXTRA_DEVICE", device);
-
-		startActivity(controlMiniIntent);
-	}
-
-//	private void pairDevice(BluetoothDevice device) {
-//		try {
-//			Log.d("PAIRING", "Start Pairing...");
-//
-//			//waitingForBonding = true;
-//
-//			Method m = device.getClass()
-//					.getMethod("createBond", (Class[]) null);
-//			m.invoke(device, (Object[]) null);
-//
-//			Log.d("PAIRING", "Pairing finished.");
-//		} catch (Exception e) {
-//			Log.e("PAIRING", e.getMessage());
-//		}
-//	}
-//
-//	private void unpairDevice(BluetoothDevice device) {
-//		try {
-//			Method m = device.getClass()
-//					.getMethod("removeBond", (Class[]) null);
-//			m.invoke(device, (Object[]) null);
-//		} catch (Exception e) {
-//			Log.e("PAIRING", e.getMessage());
-//		}
-
-
-	@Override
-	public void onRequestPermissionsResult(final int requestCode, @NonNull final String[] permissions, @NonNull final int[] grantResults) {
-		super.onRequestPermissionsResult(requestCode, permissions, grantResults);
-		switch (requestCode) {
-			case REQUEST_ACCESS_FINE_LOCATION:
-				mScannerViewModel.refresh();
-				break;
-		}
-	}
-
-	@OnClick(R.id.action_enable_location)
-	public void onEnableLocationClicked() {
-		final Intent intent = new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS);
-		startActivity(intent);
-	}
-
-	@OnClick(R.id.action_enable_bluetooth)
-	public void onEnableBluetoothClicked() {
-		final Intent enableIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
-		startActivity(enableIntent);
-	}
-
-	private static final String[] BLE_PERMISSIONS = new String[]{
-			Manifest.permission.ACCESS_COARSE_LOCATION,
-			Manifest.permission.ACCESS_FINE_LOCATION
-	};
-
-	private static final String[] ANDROID_12_BLE_PERMISSIONS = new String[]{
-			Manifest.permission.BLUETOOTH_SCAN,
-			Manifest.permission.BLUETOOTH_CONNECT,
-			Manifest.permission.ACCESS_FINE_LOCATION
-	};
-
-	@OnClick(R.id.action_grant_location_permission)
-	public void onGrantLocationPermissionClicked() {
-		Utils.markLocationPermissionRequested(this);
-		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
-			Log.i("PERMISSIONS", "12");
-			ActivityCompat.requestPermissions(this, ANDROID_12_BLE_PERMISSIONS, REQUEST_ACCESS_BLUETOOTH_SCAN);
-		} else {
-			Log.i("PERMISSIONS", "LEGACY");
-			ActivityCompat.requestPermissions(this, BLE_PERMISSIONS, REQUEST_ACCESS_FINE_LOCATION);
-		}
-	}
-
-	@OnClick(R.id.action_permission_settings)
-	public void onPermissionSettingsClicked() {
-		final Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
-		intent.setData(Uri.fromParts("package", getPackageName(), null));
-		startActivity(intent);
-	}
-
-	/**
-	 * Start scanning for Bluetooth devices or displays a message based on the scanner state.
-	 */
-	private void startScan(final ScannerLiveData state) {
-		Log.v("Scan Permission: ", Utils.isBluetoothScanPermissionsGranted(this)+"");
-		Log.v("Location Permission: ", Utils.isLocationPermissionsGranted(this)+"");
-		Log.v("Version", Build.VERSION.SDK_INT+"");
-		// First, check the Location permission. This is required on Marshmallow onwards in order to scan for Bluetooth LE devices.
-		if (Utils.isLocationPermissionsGranted(this)
-		&& (Build.VERSION.SDK_INT < Build.VERSION_CODES.S || Utils.isBluetoothScanPermissionsGranted(this))
-		) {
-			mNoLocationPermissionView.setVisibility(View.GONE);
-
-			// Bluetooth must be enabled
-			if (state.isBluetoothEnabled()) {
-				mNoBluetoothView.setVisibility(View.GONE);
-
-				// We are now OK to start scanning
-				mScannerViewModel.startScan();
-				mScanningView.setVisibility(View.VISIBLE);
-
-                mPairAnimation.setVisibility(View.VISIBLE);
-
-				if (state.isEmpty()) {
-					mEmptyView.setVisibility(View.VISIBLE);
-
-					if (!Utils.isLocationRequired(this) || Utils.isLocationEnabled(this)) {
-						mNoLocationView.setVisibility(View.INVISIBLE);
-					} else {
-						mNoLocationView.setVisibility(View.VISIBLE);
-					}
-				} else {
-					mEmptyView.setVisibility(View.GONE);
-				}
-			} else {
-				mNoBluetoothView.setVisibility(View.VISIBLE);
-				mScanningView.setVisibility(View.INVISIBLE);
-				mEmptyView.setVisibility(View.GONE);
-			}
-		} else {
-			mNoLocationPermissionView.setVisibility(View.VISIBLE);
-			mNoBluetoothView.setVisibility(View.GONE);
-			mScanningView.setVisibility(View.INVISIBLE);
-			mEmptyView.setVisibility(View.GONE);
-
-			final boolean deniedForever = Utils.isLocationPermissionDeniedForever(this);
-			mGrantPermissionButton.setVisibility(deniedForever ? View.GONE : View.VISIBLE);
-			mPermissionSettingsButton.setVisibility(deniedForever ? View.VISIBLE : View.GONE);
-		}
-	}
-
-	/**
-	 * stop scanning for bluetooth devices.
-	 */
-	private void stopScan() {
-		mScannerViewModel.stopScan();
-	}
-}
diff --git a/app/src/main/java/cc/calliope/mini/SplashScreenActivity.java b/app/src/main/java/cc/calliope/mini/SplashScreenActivity.java
deleted file mode 100644
index 7d5e526..0000000
--- a/app/src/main/java/cc/calliope/mini/SplashScreenActivity.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (c) 2015, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *  Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- *
- *  Redistributions in binary form must reproduce the above copyright notice,
- *   this list of conditions and the following disclaimer in the documentation
- *   and/or other materials provided with the distribution.
- *
- *  Neither the name of copyright holder nor the names of its
- *   contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package cc.calliope.mini;
-
-import android.app.Activity;
-
-import android.content.Intent;
-import android.os.Bundle;
-import android.os.Handler;
-
-public class SplashScreenActivity extends Activity {
-	private static final int DURATION = 500;
-
-	@Override
-	protected void onCreate(final Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		setContentView(R.layout.activity_splash_screen);
-
-		new Handler().postDelayed(() -> {
-			final Intent intent = new Intent(SplashScreenActivity.this, MainActivity.class);
-			intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);
-			startActivity(intent);
-			finish();
-		}, DURATION);
-	}
-
-	@Override
-	public void onBackPressed() {
-		// We don't want the splash screen to be interrupted
-	}
-}
diff --git a/app/src/main/java/cc/calliope/mini/activity/FlashingActivity.java b/app/src/main/java/cc/calliope/mini/activity/FlashingActivity.java
new file mode 100644
index 0000000..49d98d9
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/activity/FlashingActivity.java
@@ -0,0 +1,676 @@
+package cc.calliope.mini.activity;
+
+import android.Manifest;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.os.Bundle;
+import android.os.Handler;
+import android.util.Log;
+import android.view.View;
+import android.widget.TextView;
+
+import com.google.android.material.snackbar.Snackbar;
+
+import org.microbit.android.partialflashing.PartialFlashingBaseService;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.Arrays;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipOutputStream;
+
+import androidx.activity.result.ActivityResultLauncher;
+import androidx.activity.result.contract.ActivityResultContracts;
+import androidx.annotation.NonNull;
+import androidx.appcompat.app.AppCompatActivity;
+import androidx.core.app.ActivityCompat;
+
+import cc.calliope.mini.service.PartialFlashingService;
+import cc.calliope.mini.ProgressCollector;
+import cc.calliope.mini.ExtendedBluetoothDevice;
+import cc.calliope.mini.service.DfuControlService;
+import cc.calliope.mini.ProgressListener;
+import cc.calliope.mini.R;
+import cc.calliope.mini.databinding.ActivityDfuBinding;
+import cc.calliope.mini.service.DfuService;
+import cc.calliope.mini.utils.FileUtils;
+import cc.calliope.mini.utils.Preference;
+import cc.calliope.mini.utils.StaticExtra;
+import cc.calliope.mini.utils.Utils;
+import cc.calliope.mini.utils.Version;
+import cc.calliope.mini.views.BoardProgressBar;
+import no.nordicsemi.android.dfu.DfuBaseService;
+import no.nordicsemi.android.dfu.DfuServiceInitiator;
+
+import static android.bluetooth.BluetoothDevice.BOND_BONDED;
+import static android.bluetooth.BluetoothDevice.BOND_BONDING;
+import static android.bluetooth.BluetoothDevice.BOND_NONE;
+import static cc.calliope.mini.service.DfuControlService.UNIDENTIFIED;
+import static cc.calliope.mini.service.DfuControlService.MINI_V1;
+import static cc.calliope.mini.service.DfuControlService.MINI_V2;
+import static cc.calliope.mini.service.DfuControlService.HardwareVersion;
+
+public class FlashingActivity extends AppCompatActivity implements ProgressListener {
+    private static final String TAG = "FlashingActivity";
+    private static final int NUMBER_OF_RETRIES = 3;
+    private static final int REBOOT_TIME = 2000; // time required by the device to reboot, ms
+    private static final int DELAY_TO_FINISH_ACTIVITY = 5000; // delay to finish activity after flashing
+    private static final int SNACKBAR_DURATION = 10000; // how long to display the snackbar message.
+    private ActivityDfuBinding binding;
+    private TextView progress;
+    private TextView status;
+    private BoardProgressBar progressBar;
+    private final Handler timerHandler = new Handler();
+    private final Runnable deferredFinish = this::finish;
+    private BluetoothDevice currentDevice;
+    private String pattern;
+    private String filePath;
+    private ProgressCollector progressCollector;
+
+    ActivityResultLauncher<Intent> bluetoothEnableResultLauncher = registerForActivityResult(
+            new ActivityResultContracts.StartActivityForResult(), result -> {
+                checkBluetooth();
+            }
+    );
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        binding = ActivityDfuBinding.inflate(getLayoutInflater());
+        setContentView(binding.getRoot());
+
+        status = binding.statusTextView;
+        progress = binding.progressTextView;
+        progressBar = binding.progressBar;
+
+        binding.retryButton.setOnClickListener(this::onRetryClicked);
+
+        progressCollector = new ProgressCollector(this);
+        getLifecycle().addObserver(progressCollector);
+        progressCollector.registerReceivers();
+
+        initFlashing();
+    }
+
+    @Override
+    protected void onDestroy() {
+        binding = null;
+        super.onDestroy();
+        progressCollector.unregisterReceivers();
+    }
+
+    @Override
+    public void onDeviceConnecting() {
+        status.setText(R.string.flashing_device_connecting);
+        Utils.log(Log.WARN, TAG, "onDeviceConnecting");
+    }
+
+    @Override
+    public void onProcessStarting() {
+        status.setText(R.string.flashing_process_starting);
+        Utils.log(Log.WARN, TAG, "onProcessStarting");
+    }
+
+    @Override
+    public void onAttemptDfuMode() {
+        startDfuControlService();
+    }
+
+    @Override
+    public void onEnablingDfuMode() {
+        status.setText(R.string.flashing_enabling_dfu_mode);
+        Utils.log(Log.WARN, TAG, "onEnablingDfuMode");
+    }
+
+    @Override
+    public void onFirmwareValidating() {
+        status.setText(R.string.flashing_firmware_validating);
+        Utils.log(Log.WARN, TAG, "onFirmwareValidating");
+    }
+
+    @Override
+    public void onDeviceDisconnecting() {
+        status.setText(R.string.flashing_device_disconnecting);
+        finishActivity();
+        Utils.log(Log.WARN, TAG, "onDeviceDisconnecting");
+    }
+
+    @Override
+    public void onCompleted() {
+        progress.setText(String.format(getString(R.string.flashing_percent), 100));
+        status.setText(R.string.flashing_completed);
+        progressBar.setProgress(DfuService.PROGRESS_COMPLETED);
+        Utils.log(Log.WARN, TAG, "onCompleted");
+    }
+
+    @Override
+    public void onAborted() {
+        status.setText(R.string.flashing_aborted);
+        Utils.log(Log.WARN, TAG, "onAborted");
+    }
+
+    @Override
+    public void onProgressChanged(int percent) {
+        if (percent >= 0 && percent <= 100) {
+            progress.setText(String.format(getString(R.string.flashing_percent), percent));
+            status.setText(R.string.flashing_uploading);
+            progressBar.setProgress(percent);
+        }
+    }
+
+    @Override
+    public void onStartDfuService(int hardwareVersion) {
+        Utils.log(Log.ASSERT, "DeviceInformation", "Board version: " + hardwareVersion);
+
+        startFlashing(hardwareVersion);
+        Utils.log(Log.ASSERT, TAG, "onDfuControlCompleted");
+    }
+
+    @Override
+    public void onBonding(@NonNull BluetoothDevice device, int bondState, int previousBondState) {
+        if (!currentDevice.getAddress().equals(device.getAddress())) {
+            return;
+        }
+        progress.setText("");
+
+        switch (bondState) {
+            case BOND_BONDING -> status.setText(R.string.bonding_started);
+            case BOND_BONDED -> status.setText(R.string.bonding_succeeded);
+            case BOND_NONE -> status.setText(R.string.bonding_not_succeeded);
+        }
+    }
+
+    @Override
+    public void onError(int code, String message) {
+        if (code == 4110) {
+            if ((Version.VERSION_S_AND_NEWER && ActivityCompat.checkSelfPermission(this, Manifest.permission.BLUETOOTH_CONNECT) != PackageManager.PERMISSION_GRANTED)
+                    && ActivityCompat.checkSelfPermission(this, Manifest.permission.BLUETOOTH) != PackageManager.PERMISSION_GRANTED) {
+                Utils.log(Log.ERROR, TAG, "BLUETOOTH permission no granted");
+                return;
+            }
+            currentDevice.createBond();
+        }
+        progressBar.setProgress(0);
+        binding.retryButton.setVisibility(View.VISIBLE);
+        String error = String.format(getString(R.string.flashing_error), code, message);
+        Utils.errorSnackbar(binding.getRoot(), error).show();
+//        progress.setText(String.format(getString(R.string.flashing_error), code));
+        status.setText(error);
+        Utils.log(Log.ERROR, TAG, "ERROR " + code + ", " + message);
+    }
+
+    private void onRetryClicked(View view) {
+        view.setVisibility(View.INVISIBLE);
+        checkBluetooth();
+    }
+
+    private void finishActivity() {
+        timerHandler.postDelayed(deferredFinish, DELAY_TO_FINISH_ACTIVITY);
+    }
+
+    private void initFlashing() {
+        ExtendedBluetoothDevice extendedDevice;
+
+        try {
+            Intent intent = getIntent();
+            extendedDevice = intent.getParcelableExtra(StaticExtra.EXTRA_DEVICE);
+            filePath = intent.getStringExtra(StaticExtra.EXTRA_FILE_PATH);
+        } catch (NullPointerException exception) {
+            Utils.log(Log.ERROR, TAG, "NullPointerException: " + exception.getMessage());
+            return;
+        }
+
+        if (extendedDevice == null || filePath == null) {
+            Utils.log(Log.ERROR, TAG, "No Extra received");
+            return;
+        }
+
+        currentDevice = extendedDevice.getDevice();
+        pattern = extendedDevice.getPattern();
+
+        Utils.log(Log.INFO, TAG, "Device: " + extendedDevice.getAddress() + " " + extendedDevice.getName());
+        Utils.log(Log.INFO, TAG, "File path: " + filePath);
+
+        checkBluetooth();
+    }
+
+    private void checkBluetooth() {
+        if (Utils.isBluetoothEnabled()) {
+            if (Preference.getBoolean(getApplicationContext(), Preference.PREF_KEY_ENABLE_PARTIAL_FLASHING, false)) {
+                startPartialFlashing();
+            } else {
+                startDfuControlService();
+            }
+        } else {
+            showBluetoothDisabledWarning();
+        }
+    }
+
+    private void startPartialFlashing() {
+        Utils.log(TAG, "Starting PartialFlashing Service...");
+
+        Intent service = new Intent(this, PartialFlashingService.class);
+        service.putExtra(PartialFlashingBaseService.EXTRA_DEVICE_ADDRESS, currentDevice.getAddress());
+        service.putExtra(PartialFlashingBaseService.EXTRA_FILE_PATH, filePath); // a path or URI must be provided.
+        startService(service);
+    }
+
+    private void startDfuControlService() {
+        Utils.log(TAG, "Starting DfuControl Service...");
+
+        Intent service = new Intent(this, DfuControlService.class);
+        service.putExtra(DfuControlService.EXTRA_DEVICE_ADDRESS, currentDevice.getAddress());
+        startService(service);
+    }
+
+    @SuppressWarnings("deprecation")
+    private void startFlashing(@HardwareVersion final int hardwareVersion) {
+        Utils.log(Log.INFO, TAG, "Starting DFU Service...");
+
+        if (hardwareVersion == UNIDENTIFIED) {
+            Utils.log(Log.ERROR, TAG, "BOARD_UNIDENTIFIED");
+            return;
+        }
+
+        HexToDfu hexToDFU = universalHexToDFU(filePath, hardwareVersion);
+        String hexPath = hexToDFU.getPath();
+        int hexSize = hexToDFU.getSize();
+
+        Utils.log(Log.DEBUG, TAG, "Path: " + hexPath);
+        Utils.log(Log.DEBUG, TAG, "Size: " + hexSize);
+
+        if (hexSize == -1) {
+            return;
+        }
+
+        if (hardwareVersion == MINI_V1) {
+            new DfuServiceInitiator(currentDevice.getAddress())
+                    .setDeviceName(pattern)
+                    .setPrepareDataObjectDelay(300L)
+                    .setNumberOfRetries(NUMBER_OF_RETRIES)
+                    .setRebootTime(REBOOT_TIME)
+                    .setForceDfu(true)
+                    .setKeepBond(true)
+                    .setMbrSize(0x1000)
+                    .setBinOrHex(DfuBaseService.TYPE_APPLICATION, hexPath)
+                    .start(this, DfuService.class);
+        } else {
+            String initPacketPath;
+            String zipPath;
+
+            try {
+                initPacketPath = createDFUInitPacket(hexSize);
+                zipPath = createDFUZip(initPacketPath, hexPath);
+            } catch (IOException e) {
+                Utils.log(Log.ERROR, TAG, "Failed to create init packet");
+                e.printStackTrace();
+                return;
+            }
+
+            if (zipPath == null) {
+                Utils.log(Log.ERROR, TAG, "Failed to create ZIP");
+                return;
+            }
+
+            new DfuServiceInitiator(currentDevice.getAddress())
+                    .setDeviceName(pattern)
+                    .setPrepareDataObjectDelay(300L)
+                    .setNumberOfRetries(NUMBER_OF_RETRIES)
+                    .setRebootTime(REBOOT_TIME)
+                    .setKeepBond(true)
+                    .setPacketsReceiptNotificationsEnabled(true)
+                    .setUnsafeExperimentalButtonlessServiceInSecureDfuEnabled(true)
+                    .setZip(zipPath)
+                    .start(this, DfuService.class);
+        }
+    }
+
+    /**
+     * Create zip for DFU
+     */
+    private String createDFUZip(String... srcFiles) throws IOException {
+        byte[] buffer = new byte[1024];
+
+        File zipFile = new File(getCacheDir() + "/update.zip");
+        if (zipFile.exists()) {
+            if (zipFile.delete()) {
+                if (!zipFile.createNewFile()) {
+                    return null;
+                }
+            } else {
+                return null;
+            }
+        }
+
+        FileOutputStream fileOutputStream = new FileOutputStream(getCacheDir() + "/update.zip");
+        ZipOutputStream zipOutputStream = new ZipOutputStream(fileOutputStream);
+
+        for (String file : srcFiles) {
+
+            File srcFile = new File(file);
+            FileInputStream fileInputStream = new FileInputStream(srcFile);
+            zipOutputStream.putNextEntry(new ZipEntry(srcFile.getName()));
+
+            int length;
+            while ((length = fileInputStream.read(buffer)) > 0) {
+                zipOutputStream.write(buffer, 0, length);
+            }
+
+            zipOutputStream.closeEntry();
+            fileInputStream.close();
+
+        }
+
+        // close the ZipOutputStream
+        zipOutputStream.close();
+
+        return getCacheDir() + "/update.zip";
+    }
+
+    private String createDFUInitPacket(int hexLength) throws IOException {
+        ByteArrayOutputStream outputInitPacket;
+        outputInitPacket = new ByteArrayOutputStream();
+
+        Utils.log(Log.VERBOSE, TAG, "DFU App Length: " + hexLength);
+
+        outputInitPacket.write("microbit_app".getBytes()); // "microbit_app"
+        outputInitPacket.write(new byte[]{0x1, 0, 0, 0});  // Init packet version
+        outputInitPacket.write(ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).putInt(hexLength).array());  // App size
+        outputInitPacket.write(new byte[]{0, 0, 0, 0x0});  // Hash Size. 0: Ignore Hash
+        outputInitPacket.write(new byte[]{
+                0, 0, 0, 0, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0, 0, 0
+        }); // Hash
+
+        // Write to temp file
+        File initPacket = new File(this.getCacheDir() + "/application.dat");
+        if (initPacket.exists()) {
+            initPacket.delete();
+        }
+        initPacket.createNewFile();
+
+        FileOutputStream outputStream;
+        outputStream = new FileOutputStream(initPacket);
+        outputStream.write(outputInitPacket.toByteArray());
+        outputStream.flush();
+
+        // Should return from here
+        return initPacket.getAbsolutePath();
+    }
+
+    private static class HexToDfu {
+        private final String path;
+        private final int size;
+
+        public HexToDfu(String path, int size) {
+            this.path = path;
+            this.size = size;
+        }
+
+        public String getPath() {
+            return path;
+        }
+
+        public int getSize() {
+            return size;
+        }
+    }
+
+    private HexToDfu universalHexToDFU(String inputPath, @HardwareVersion int hardwareVersion) {
+        FileInputStream fis;
+        ByteArrayOutputStream outputHex;
+        outputHex = new ByteArrayOutputStream();
+
+        ByteArrayOutputStream test = new ByteArrayOutputStream();
+
+        FileOutputStream outputStream;
+
+        int application_size = 0;
+        int next = 0;
+        boolean records_wanted = true;
+        boolean is_fat = false;
+        boolean is_v2 = false;
+        boolean uses_ESA = false;
+        ByteArrayOutputStream lastELA = new ByteArrayOutputStream();
+        ByteArrayOutputStream lastESA = new ByteArrayOutputStream();
+
+        try {
+            fis = new FileInputStream(inputPath);
+            byte[] bs = new byte[Integer.valueOf(FileUtils.getFileSize(inputPath))];
+            int i = 0;
+            i = fis.read(bs);
+
+            for (int b_x = 0; b_x < bs.length - 1; /* empty */) {
+
+                // Get record from following bytes
+                char b_type = (char) bs[b_x + 8];
+
+                // Find next record start, or EOF
+                next = 1;
+                while ((b_x + next) < i && bs[b_x + next] != ':') {
+                    next++;
+                }
+
+                // Switch type and determine what to do with this record
+                switch (b_type) {
+                    case 'A': // Block start
+                        is_fat = true;
+                        records_wanted = false;
+
+                        // Check data for id
+                        if (bs[b_x + 9] == '9' && bs[b_x + 10] == '9' && bs[b_x + 11] == '0' && bs[b_x + 12] == '0') {
+                            records_wanted = (hardwareVersion == MINI_V1);
+                        } else if (bs[b_x + 9] == '9' && bs[b_x + 10] == '9' && bs[b_x + 11] == '0' && bs[b_x + 12] == '1') {
+                            records_wanted = (hardwareVersion == MINI_V1);
+                        } else if (bs[b_x + 9] == '9' && bs[b_x + 10] == '9' && bs[b_x + 11] == '0' && bs[b_x + 12] == '3') {
+                            records_wanted = (hardwareVersion == MINI_V2);
+                        }
+                        break;
+                    case 'E':
+                        break;
+                    case '4':
+                        ByteArrayOutputStream currentELA = new ByteArrayOutputStream();
+                        currentELA.write(bs, b_x, next);
+
+                        uses_ESA = false;
+
+                        // If ELA has changed write
+                        if (!currentELA.toString().equals(lastELA.toString())) {
+                            lastELA.reset();
+                            lastELA.write(bs, b_x, next);
+                            Utils.log(Log.VERBOSE, TAG, "TEST ELA " + lastELA.toString());
+                            outputHex.write(bs, b_x, next);
+                        }
+
+                        break;
+                    case '2':
+                        uses_ESA = true;
+
+                        ByteArrayOutputStream currentESA = new ByteArrayOutputStream();
+                        currentESA.write(bs, b_x, next);
+
+                        // If ESA has changed write
+                        if (!Arrays.equals(currentESA.toByteArray(), lastESA.toByteArray())) {
+                            lastESA.reset();
+                            lastESA.write(bs, b_x, next);
+                            outputHex.write(bs, b_x, next);
+                        }
+                        break;
+                    case '1':
+                        // EOF
+                        // Ensure KV storage is erased
+                        if (hardwareVersion == MINI_V1) {
+                            String kv_address = ":020000040003F7\n";
+                            String kv_data = ":1000000000000000000000000000000000000000F0\n";
+                            outputHex.write(kv_address.getBytes());
+                            outputHex.write(kv_data.getBytes());
+                        }
+
+                        // Write final block
+                        outputHex.write(bs, b_x, next);
+                        break;
+                    case 'D': // V2 section of Universal Hex
+                        // Remove D
+                        bs[b_x + 8] = '0';
+                        // Find first \n. PXT adds in extra padding occasionally
+                        int first_cr = 0;
+                        while (bs[b_x + first_cr] != '\n') {
+                            first_cr++;
+                        }
+
+                        // Skip 1 word records
+                        // TODO: Pad this record for uPY FS scratch
+                        if (bs[b_x + 2] == '1') break;
+
+                        // Recalculate checksum
+                        int checksum = (charToInt((char) bs[b_x + first_cr - 2]) * 16) + charToInt((char) bs[b_x + first_cr - 1]) + 0xD;
+                        String checksum_hex = Integer.toHexString(checksum);
+                        checksum_hex = "00" + checksum_hex.toUpperCase(); // Pad to ensure we have 2 characters
+                        checksum_hex = checksum_hex.substring(checksum_hex.length() - 2);
+                        bs[b_x + first_cr - 2] = (byte) checksum_hex.charAt(0);
+                        bs[b_x + first_cr - 1] = (byte) checksum_hex.charAt(1);
+                    case '3':
+                    case '5':
+                    case '0':
+                        // Copy record to hex
+                        // Record starts at b_x, next long
+                        // Calculate address of record
+                        int b_a = 0;
+                        if (lastELA.size() > 0 && !uses_ESA) {
+                            b_a = (charToInt((char) lastELA.toByteArray()[9]) << 12) | (charToInt((char) lastELA.toByteArray()[10]) << 8) | (charToInt((char) lastELA.toByteArray()[11]) << 4) | (charToInt((char) lastELA.toByteArray()[12]));
+                            b_a = b_a << 16;
+                        }
+                        if (lastESA.size() > 0 && uses_ESA) {
+                            b_a = (charToInt((char) lastESA.toByteArray()[9]) << 12) | (charToInt((char) lastESA.toByteArray()[10]) << 8) | (charToInt((char) lastESA.toByteArray()[11]) << 4) | (charToInt((char) lastESA.toByteArray()[12]));
+                            b_a = b_a * 16;
+                        }
+
+                        int b_raddr = (charToInt((char) bs[b_x + 3]) << 12) | (charToInt((char) bs[b_x + 4]) << 8) | (charToInt((char) bs[b_x + 5]) << 4) | (charToInt((char) bs[b_x + 6]));
+                        int b_addr = b_a | b_raddr;
+
+                        int lower_bound = 0;
+                        int upper_bound = 0;
+                        //MICROBIT_V1 lower_bound = 0x18000; upper_bound = 0x38000;
+                        //Memory range nRF51 (S130 v2.0.x) 0x0001B000 - 0x0003AC00 (127 kB)
+                        //0x00014000 - 0x0003C800
+                        if (hardwareVersion == MINI_V1) {
+                            lower_bound = 0x18000;
+                            upper_bound = 0x3BBFF;
+                        }
+                        //MICROBIT_V2 lower_bound = 0x27000; upper_bound = 0x71FFF;
+                        //Memory range nRF52833 (S113 v7.0.x) Application area (incl. free space) 0x0001C000 - 0x00078000 (368 kB)
+                        if (hardwareVersion == MINI_V2) {
+                            lower_bound = 0x1C000;
+                            upper_bound = 0x77000;
+                        }
+
+                        // Check for Cortex-M4 Vector Table
+                        if (b_addr == 0x10 && bs[b_x + 41] != 'E' && bs[b_x + 42] != '0') { // Vectors exist
+                            is_v2 = true;
+                        }
+
+                        if ((records_wanted || !is_fat) && b_addr >= lower_bound && b_addr < upper_bound) {
+
+                            outputHex.write(bs, b_x, next);
+                            // Add to app size
+                            application_size = application_size + charToInt((char) bs[b_x + 1]) * 16 + charToInt((char) bs[b_x + 2]);
+                        } else {
+                            // Log.v(TAG, "TEST " + Integer.toHexString(b_addr) + " BA " + b_a + " LELA " + lastELA.toString() + " " + uses_ESA);
+                            // test.write(bs, b_x, next);
+                        }
+
+                        break;
+                    case 'C':
+                    case 'B':
+                        records_wanted = false;
+                        break;
+                    default:
+                        Utils.log(Log.ERROR, TAG, "Record type not recognised; TYPE: " + b_type);
+                }
+
+                // Record handled. Move to next ':'
+                if ((b_x + next) >= i) {
+                    break;
+                } else {
+                    b_x = b_x + next;
+                }
+
+            }
+
+            byte[] output = outputHex.toByteArray();
+            byte[] testBytes = test.toByteArray();
+
+            Utils.log(Log.VERBOSE, TAG, "Finished parsing HEX. Writing application HEX for flashing");
+
+            try {
+                File hexToFlash = new File(this.getCacheDir() + "/application.hex");
+                if (hexToFlash.exists()) {
+                    hexToFlash.delete();
+                }
+                hexToFlash.createNewFile();
+
+                outputStream = new FileOutputStream(hexToFlash);
+                outputStream.write(output);
+                outputStream.flush();
+
+                // Should return from here
+                Utils.log(Log.VERBOSE, TAG, hexToFlash.getAbsolutePath());
+
+                /*
+                if(hardwareVersion == MICROBIT_V2 && (!is_v2 && !is_fat)) {
+                    ret[1] = Integer.toString(-1); // Invalidate hex file
+                }
+                 */
+
+                return new HexToDfu(hexToFlash.getAbsolutePath(), application_size);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+
+        } catch (FileNotFoundException e) {
+            Utils.log(Log.ERROR, TAG, "File not found.");
+            e.printStackTrace();
+        } catch (IOException e) {
+            Utils.log(Log.ERROR, TAG, "IO Exception.");
+            e.printStackTrace();
+        }
+
+        // Should not reach this
+        return new HexToDfu(null, -1);
+    }
+
+    /**
+     * Convert a HEX char to int
+     */
+    int charToInt(char in) {
+        // 0 - 9
+        if (in - '0' >= 0 && in - '0' < 10) {
+            return (in - '0');
+        }
+        // A - F
+        return in - 55;
+    }
+
+    private void showBluetoothDisabledWarning() {
+        Snackbar snackbar = Utils.errorSnackbar(binding.getRoot(), getString(R.string.error_snackbar_bluetooth_disable));
+        snackbar.setDuration(SNACKBAR_DURATION)
+                .setAction(R.string.button_enable, this::startBluetoothEnableActivity)
+                .show();
+    }
+
+    public void startBluetoothEnableActivity(View view) {
+        Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
+        bluetoothEnableResultLauncher.launch(enableBtIntent);
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/activity/MainActivity.java b/app/src/main/java/cc/calliope/mini/activity/MainActivity.java
new file mode 100644
index 0000000..24db27f
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/activity/MainActivity.java
@@ -0,0 +1,185 @@
+package cc.calliope.mini.activity;
+
+import android.Manifest;
+import android.content.pm.PackageManager;
+import android.content.res.Configuration;
+import android.os.Build;
+import android.os.Bundle;
+import android.util.Log;
+import android.view.View;
+import android.view.WindowManager;
+import android.widget.AdapterView;
+
+import java.io.File;
+import java.util.List;
+
+import androidx.activity.result.ActivityResultLauncher;
+import androidx.activity.result.contract.ActivityResultContracts;
+import androidx.annotation.NonNull;
+import androidx.annotation.RequiresApi;
+import androidx.core.content.ContextCompat;
+import androidx.navigation.NavController;
+import androidx.navigation.Navigation;
+import androidx.navigation.ui.NavigationUI;
+
+import cc.calliope.mini.popup.PopupItem;
+import cc.calliope.mini.R;
+import cc.calliope.mini.databinding.ActivityMainBinding;
+import cc.calliope.mini.dialog.scripts.ScriptsFragment;
+import cc.calliope.mini.utils.Utils;
+import cc.calliope.mini.utils.Version;
+
+public class MainActivity extends ScannerActivity {
+    private static final String TAG = "MainActivity";
+    private ActivityMainBinding binding;
+    private boolean fullScreen = false;
+    private int currentFragment;
+    private int previousFragment;
+    private final ActivityResultLauncher<String> pushNotificationPermissionLauncher =
+            registerForActivityResult(new ActivityResultContracts.RequestPermission(), isGranted -> {
+                if (isGranted) {
+                    Utils.log(Log.INFO, TAG, "NotificationPermission is Granted");
+                } else {
+                    Utils.log(Log.WARN, TAG, "NotificationPermission NOT Granted");
+                }
+            });
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        binding = ActivityMainBinding.inflate(getLayoutInflater());
+        setContentView(binding.getRoot());
+
+        setPatternFab(binding.patternFab);
+
+        NavController navController = Navigation.findNavController(this, R.id.navigation_host_fragment);
+        navController.addOnDestinationChangedListener((controller, destination, arguments) -> {
+            previousFragment = currentFragment;
+            currentFragment = destination.getId();
+
+            if (currentFragment == R.id.navigation_web) {
+                binding.bottomNavigation.setVisibility(View.GONE);
+                binding.patternFab.moveDown();
+            } else if (previousFragment == R.id.navigation_web){
+                binding.bottomNavigation.setVisibility(View.VISIBLE);
+                binding.patternFab.moveUp();
+            }
+
+            if (currentFragment == R.id.navigation_help) {
+                binding.patternFab.setVisibility(View.GONE);
+            } else if (previousFragment == R.id.navigation_help){
+                binding.patternFab.setVisibility(View.VISIBLE);
+            }
+
+            Utils.log(Log.ASSERT, TAG, "Destination id: " + destination.getId());
+            Utils.log(Log.ASSERT, TAG, "Select item id: " + binding.bottomNavigation.getSelectedItemId());
+        });
+        NavigationUI.setupWithNavController(binding.bottomNavigation, navController);
+
+        if (Version.VERSION_TIRAMISU_AND_NEWER) {
+            requestPushNotificationPermission();
+        }
+
+        externalStorageVolumes();
+    }
+
+    private void externalStorageVolumes() {
+        File[] externalStorageVolumes = ContextCompat.getExternalFilesDirs(getApplicationContext(), null);
+        for (File externalDir : externalStorageVolumes) {
+            Utils.log(Log.ASSERT, TAG, "Found dir at : " + externalDir);
+        }
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        disableFullScreenMode();
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        binding = null;
+    }
+
+    @Override
+    public void onBackPressed() {
+        if (fullScreen) {
+            disableFullScreenMode();
+        } else {
+            super.onBackPressed();
+        }
+    }
+
+//    @Override
+//    public void onItemFabMenuClicked(View view) {
+//        super.onItemFabMenuClicked(view);
+//        if (view.getId() == R.id.itemFullScreen) {
+//            if (fullScreen) {
+//                disableFullScreenMode();
+//            } else {
+//                enableFullScreenMode();
+//            }
+//        } else if (view.getId() == R.id.itemScripts) {
+//            ScriptsFragment scriptsFragment = new ScriptsFragment();
+//            scriptsFragment.show(getSupportFragmentManager(), "Bottom Sheet Dialog Fragment");
+//        }
+//    }
+
+    public void onPopupMenuItemClick(AdapterView<?> parent, View view, int position, long id) {
+        super.onPopupMenuItemClick(parent, view, position, id);
+        if (position == 1) {
+            ScriptsFragment scriptsFragment = new ScriptsFragment();
+            scriptsFragment.show(getSupportFragmentManager(), "Bottom Sheet Dialog Fragment");
+        }else if(position == 2){
+            if (fullScreen) {
+                disableFullScreenMode();
+            } else {
+                enableFullScreenMode();
+            }
+        }
+    }
+
+    private void enableFullScreenMode() {
+        fullScreen = true;
+        binding.bottomNavigation.setVisibility(View.GONE);
+        getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
+    }
+
+    private void disableFullScreenMode() {
+        fullScreen = false;
+        binding.bottomNavigation.setVisibility(View.VISIBLE);
+        getWindow().clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
+    }
+
+    @Override
+    public void addPopupMenuItems(List<PopupItem> popupItems) {
+        super.addPopupMenuItems(popupItems);
+        popupItems.add(new PopupItem(R.string.menu_fab_scripts, R.drawable.ic_coding_black_24dp));
+        popupItems.add(new PopupItem(R.string.menu_fab_full_screen, fullScreen ?
+                R.drawable.ic_disable_full_screen_24dp : R.drawable.ic_enable_full_screen_24dp));
+    }
+
+    public void onConfigurationChanged(@NonNull Configuration newConfig) {
+        super.onConfigurationChanged(newConfig);
+        Utils.log(Log.WARN, TAG, "onConfigurationChanged");
+        if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) {
+            Utils.log(Log.WARN, TAG, "ORIENTATION_LANDSCAPE");
+
+        } else if (newConfig.orientation == Configuration.ORIENTATION_PORTRAIT) {
+            Utils.log(Log.WARN, TAG, "ORIENTATION_PORTRAIT");
+        }
+        if (currentFragment != R.id.navigation_web) {
+            recreate();
+        }
+    }
+
+    @RequiresApi(api = Build.VERSION_CODES.TIRAMISU)
+    private void requestPushNotificationPermission() {
+        if (ContextCompat.checkSelfPermission(this, Manifest.permission.POST_NOTIFICATIONS)
+                != PackageManager.PERMISSION_GRANTED) {
+            pushNotificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS);
+        }
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/activity/NoPermissionActivity.java b/app/src/main/java/cc/calliope/mini/activity/NoPermissionActivity.java
new file mode 100644
index 0000000..ed1559c
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/activity/NoPermissionActivity.java
@@ -0,0 +1,71 @@
+package cc.calliope.mini.activity;
+
+import androidx.appcompat.app.AppCompatActivity;
+import androidx.core.app.ActivityCompat;
+import cc.calliope.mini.R;
+import cc.calliope.mini.databinding.ActivityNoPermissionBinding;
+import cc.calliope.mini.utils.Permission;
+import cc.calliope.mini.utils.Version;
+
+import android.content.Intent;
+import android.net.Uri;
+import android.os.Bundle;
+import android.provider.Settings;
+import android.view.View;
+
+public class NoPermissionActivity extends AppCompatActivity implements View.OnClickListener {
+    private static final int REQUEST_CODE = 1022; // random number
+    private NoPermissionContent content;
+    private ActivityNoPermissionBinding binding;
+    private boolean deniedForever;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        binding = ActivityNoPermissionBinding.inflate(getLayoutInflater());
+        setContentView(binding.getRoot());
+
+        binding.actionButton.setOnClickListener(this);
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        if (!Permission.isAccessGranted(this, Permission.BLUETOOTH_PERMISSIONS)) {
+            deniedForever = Permission.isAccessDeniedForever(this, Permission.BLUETOOTH_PERMISSIONS);
+            content = NoPermissionContent.BLUETOOTH;
+            updateUi();
+        } else if (!Version.VERSION_S_AND_NEWER && !Permission.isAccessGranted(this, Permission.LOCATION_PERMISSIONS)) {
+            deniedForever = Permission.isAccessDeniedForever(this, Permission.LOCATION_PERMISSIONS);
+            content = NoPermissionContent.LOCATION;
+            updateUi();
+        } else if (Version.VERSION_TIRAMISU_AND_NEWER && !Permission.isAccessGranted(this, Permission.POST_NOTIFICATIONS)) {
+            deniedForever = Permission.isAccessDeniedForever(this, Permission.LOCATION_PERMISSIONS);
+            content = NoPermissionContent.NOTIFICATIONS;
+            updateUi();
+        } else {
+            finish();
+        }
+    }
+
+    @Override
+    public void onClick(View v) {
+        if (deniedForever) {
+            Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
+            Uri uri = Uri.fromParts("package", getPackageName(), null);
+            intent.setData(uri);
+            startActivity(intent);
+        } else {
+            Permission.markPermissionRequested(this, content.getPermissionsArray());
+            ActivityCompat.requestPermissions(this, content.getPermissionsArray(), REQUEST_CODE);
+        }
+    }
+
+    private void updateUi() {
+        binding.iconImageView.setImageResource(content.getIcResId());
+        binding.titleTextView.setText(content.getTitleResId());
+        binding.messageTextView.setText(content.getMessageResId());
+        binding.actionButton.setText(deniedForever ? R.string.settings_btn_permission : R.string.action_btn_permission);
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/activity/NoPermissionContent.java b/app/src/main/java/cc/calliope/mini/activity/NoPermissionContent.java
new file mode 100644
index 0000000..ff0f287
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/activity/NoPermissionContent.java
@@ -0,0 +1,44 @@
+package cc.calliope.mini.activity;
+
+import android.os.Build;
+
+import androidx.annotation.RequiresApi;
+import cc.calliope.mini.R;
+import cc.calliope.mini.utils.Permission;
+
+public enum NoPermissionContent {
+    BLUETOOTH(R.drawable.ic_bluetooth_disabled, R.string.title_bluetooth_permission, R.string.info_bluetooth_permission, Permission.BLUETOOTH_PERMISSIONS),
+
+    LOCATION(R.drawable.ic_location_disabled, R.string.title_location_permission, R.string.info_location_permission, Permission.LOCATION_PERMISSIONS),
+
+    @RequiresApi(api = Build.VERSION_CODES.TIRAMISU)
+    NOTIFICATIONS(R.drawable.ic_notifications, R.string.title_notification_permission, R.string.info_notification_permission, Permission.POST_NOTIFICATIONS);
+
+    private final int icResId;
+    private final int titleResId;
+    private final int messageResId;
+    private final String[] permissionsArray;
+
+    NoPermissionContent(int icResId, int titleResId, int messageResId, String[] permissionsArray) {
+        this.icResId = icResId;
+        this.titleResId = titleResId;
+        this.messageResId = messageResId;
+        this.permissionsArray = permissionsArray;
+    }
+
+    public int getIcResId() {
+        return icResId;
+    }
+
+    public int getTitleResId() {
+        return titleResId;
+    }
+
+    public int getMessageResId() {
+        return messageResId;
+    }
+
+    public String[] getPermissionsArray() {
+        return permissionsArray;
+    }
+}
diff --git a/app/src/main/java/cc/calliope/mini/ui/activity/NotificationActivity.java b/app/src/main/java/cc/calliope/mini/activity/NotificationActivity.java
similarity index 70%
rename from app/src/main/java/cc/calliope/mini/ui/activity/NotificationActivity.java
rename to app/src/main/java/cc/calliope/mini/activity/NotificationActivity.java
index 8e504ce..bf817e5 100644
--- a/app/src/main/java/cc/calliope/mini/ui/activity/NotificationActivity.java
+++ b/app/src/main/java/cc/calliope/mini/activity/NotificationActivity.java
@@ -1,12 +1,11 @@
-package cc.calliope.mini.ui.activity;
+package cc.calliope.mini.activity;
+
+import androidx.appcompat.app.AppCompatActivity;
 
-import android.app.Activity;
 import android.content.Intent;
 import android.os.Bundle;
 
-//import cc.calliope.mini.core.GoogleAnalyticsManager;
-
-public class NotificationActivity extends Activity {
+public class NotificationActivity extends AppCompatActivity {
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
@@ -16,12 +15,11 @@ public class NotificationActivity extends Activity {
         // If this activity is the root activity of the task, the app is not running
         if(isTaskRoot()) {
             // Start the app before finishing
-//            final Intent intent = new Intent(this, HomeActivity.class);
-//            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-//            intent.putExtras(getIntent().getExtras()); // copy all extras
-//            startActivity(intent);
+            final Intent intent = new Intent(this, FlashingActivity.class);
+            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+            intent.putExtras(getIntent().getExtras()); // copy all extras
+            startActivity(intent);
         }
-
         // Now finish, which will drop you to the activity at which you were at the top of the task stack
         finish();
     }
@@ -37,5 +35,4 @@ public class NotificationActivity extends Activity {
         super.onStop();
 //        GoogleAnalyticsManager.getInstance().activityStop(this);
     }
-
 }
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/activity/OpenHexActivity.java b/app/src/main/java/cc/calliope/mini/activity/OpenHexActivity.java
new file mode 100644
index 0000000..535ce61
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/activity/OpenHexActivity.java
@@ -0,0 +1,154 @@
+package cc.calliope.mini.activity;
+
+import android.Manifest;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.net.Uri;
+import android.os.Bundle;
+import android.util.Log;
+
+import org.apache.commons.io.FilenameUtils;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.UnsupportedEncodingException;
+import java.net.URLDecoder;
+
+import androidx.annotation.NonNull;
+import androidx.core.app.ActivityCompat;
+import androidx.core.content.ContextCompat;
+import cc.calliope.mini.R;
+import cc.calliope.mini.ExtendedBluetoothDevice;
+import cc.calliope.mini.databinding.ActivityHexBinding;
+import cc.calliope.mini.fragment.editors.Editor;
+import cc.calliope.mini.utils.FileUtils;
+import cc.calliope.mini.utils.StaticExtra;
+import cc.calliope.mini.utils.Utils;
+import cc.calliope.mini.utils.Version;
+import cc.calliope.mini.viewmodels.ScannerLiveData;
+
+
+public class OpenHexActivity extends ScannerActivity {
+    private static final int REQUEST_CODE_PERMISSIONS = 123;
+    private ActivityHexBinding binding;
+    private ExtendedBluetoothDevice device;
+    private boolean isStartFlashing;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        binding = ActivityHexBinding.inflate(getLayoutInflater());
+        setContentView(binding.getRoot());
+
+        if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
+            // Запитуємо дозвіл на читання зовнішнього сховища
+            ActivityCompat.requestPermissions(this, new String[] { Manifest.permission.READ_EXTERNAL_STORAGE }, REQUEST_CODE_PERMISSIONS);
+        }
+
+        setPatternFab(binding.patternFab);
+
+        Intent intent = getIntent();
+        String action = intent.getAction();
+        String type = intent.getType();
+        String scheme = intent.getScheme();
+
+        Log.w("HexActivity", "action: " + action);
+        Log.w("HexActivity", "type: " + type);
+        Log.w("HexActivity", "scheme: " + scheme);
+
+        if (Intent.ACTION_VIEW.equals(action) && type != null /*&& type.equals("application/octet-stream")*/) {
+            Uri uri = intent.getData();
+            String decodedUri;
+
+            try {
+                decodedUri = URLDecoder.decode(uri.toString(), "UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                throw new RuntimeException(e);
+            }
+
+            String name = FilenameUtils.getBaseName(decodedUri);
+
+            binding.infoTextView.setText(
+                    String.format(getString(R.string.open_hex_info), name)
+            );
+
+            binding.flashButton.setOnClickListener(v -> {
+                try {
+                    File file = FileUtils.getFile(this, Editor.LIBRARY.toString(), name);
+                    if (file == null) {
+                        return;
+                    }
+
+                    isStartFlashing = true;
+                    copyFile(uri, file);
+                    startDFUActivity(file);
+                } catch (IOException e) {
+                    throw new RuntimeException(e);
+                }
+            });
+        }
+
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        if (isStartFlashing) {
+            finish();
+        }
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        binding = null;
+    }
+
+    @Override
+    protected void scanResults(final ScannerLiveData state) {
+        super.scanResults(state);
+        device = state.getCurrentDevice();
+    }
+
+    @Override
+    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
+        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
+
+        if (Version.VERSION_TIRAMISU_AND_NEWER || (requestCode == REQUEST_CODE_PERMISSIONS && grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED)) {
+            // Дозвіл на читання зовнішнього сховища отримано
+            Log.w("HexActivity", "Дозвіл на читання зовнішнього сховища отримано");
+        }else{
+            finish();
+        }
+    }
+
+    public void copyFile(Uri uri, File destFile) throws IOException {
+        InputStream inputStream = getContentResolver().openInputStream(uri);
+        OutputStream outputStream = new FileOutputStream(destFile);
+
+        byte[] buffer = new byte[1024];
+        int length;
+        while ((length = inputStream.read(buffer)) > 0) {
+            outputStream.write(buffer, 0, length);
+        }
+
+        outputStream.flush();
+        outputStream.close();
+        inputStream.close();
+    }
+
+    private void startDFUActivity(File file) {
+        if (device != null && device.isRelevant()) {
+            final Intent intent = new Intent(this, FlashingActivity.class);
+            intent.putExtra(StaticExtra.EXTRA_DEVICE, device);
+            intent.putExtra(StaticExtra.EXTRA_FILE_PATH, file.getAbsolutePath());
+            startActivity(intent);
+        } else {
+            Utils.errorSnackbar(binding.getRoot(), getString(R.string.error_snackbar_no_connected)).show();
+        }
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/activity/ScannerActivity.java b/app/src/main/java/cc/calliope/mini/activity/ScannerActivity.java
new file mode 100644
index 0000000..ee48ebb
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/activity/ScannerActivity.java
@@ -0,0 +1,370 @@
+package cc.calliope.mini.activity;
+
+import android.bluetooth.BluetoothAdapter;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.graphics.Color;
+import android.graphics.drawable.ColorDrawable;
+import android.os.Bundle;
+import android.util.DisplayMetrics;
+import android.util.Log;
+import android.view.View;
+import android.view.Window;
+import android.view.WindowManager;
+import android.view.animation.OvershootInterpolator;
+import android.widget.AdapterView;
+import android.widget.ListView;
+import android.widget.PopupWindow;
+import android.widget.RatingBar;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+import androidx.activity.result.ActivityResultLauncher;
+import androidx.activity.result.contract.ActivityResultContracts;
+import androidx.annotation.NonNull;
+import androidx.appcompat.app.AppCompatActivity;
+import androidx.constraintlayout.widget.ConstraintLayout;
+import androidx.core.view.ViewCompat;
+import androidx.fragment.app.Fragment;
+import androidx.fragment.app.FragmentManager;
+import androidx.lifecycle.Observer;
+import androidx.lifecycle.ViewModelProvider;
+
+import cc.calliope.mini.App;
+import cc.calliope.mini.MyDeviceKt;
+import cc.calliope.mini.ScanViewModelKt;
+import cc.calliope.mini.dialog.pattern.PatternEnum;
+import cc.calliope.mini.popup.PopupAdapter;
+import cc.calliope.mini.popup.PopupItem;
+import cc.calliope.mini.R;
+import cc.calliope.mini.ExtendedBluetoothDevice;
+import cc.calliope.mini.dialog.pattern.PatternDialogFragment;
+import cc.calliope.mini.utils.Permission;
+import cc.calliope.mini.utils.Utils;
+import cc.calliope.mini.utils.Version;
+import cc.calliope.mini.viewmodels.ScannerLiveData;
+import cc.calliope.mini.viewmodels.ScannerViewModel;
+import cc.calliope.mini.views.FobParams;
+import cc.calliope.mini.views.MovableFloatingActionButton;
+import no.nordicsemi.android.kotlin.ble.core.scanner.BleScanResults;
+
+public abstract class ScannerActivity extends AppCompatActivity implements DialogInterface.OnDismissListener {
+    private static final int SNACKBAR_DURATION = 10000; // how long to display the snackbar message.
+    private static boolean requestWasSent = false;
+//    private ScannerViewModel scannerViewModel;
+    private ScanViewModelKt viewModel;
+    private MovableFloatingActionButton patternFab;
+    private ConstraintLayout rootView;
+    private int screenWidth;
+    private int screenHeight;
+    private App app;
+    private PopupWindow popupWindow;
+    private int popupMenuWidth;
+    private int popupMenuHeight;
+
+    ActivityResultLauncher<Intent> bluetoothEnableResultLauncher = registerForActivityResult(
+            new ActivityResultContracts.StartActivityForResult(), result -> {
+            }
+    );
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        app = (App) getApplication();
+
+//        scannerViewModel = new ViewModelProvider(this).get(ScannerViewModel.class);
+//        scannerViewModel.getScannerState().observe(this, this::scanResults);
+
+        viewModel = new ViewModelProvider(this).get(ScanViewModelKt.class);
+        viewModel.getDevices().observe(this, new Observer<List<BleScanResults>>() {
+            @Override
+            public void onChanged(List<BleScanResults> scanResults) {
+//                Log.w(TAG, "_________________________________________________");
+//                for (BleScanResults results : scanResults) {
+//                    MyDeviceKt device = new MyDeviceKt(results);
+//
+//                    if (!device.getPattern().isEmpty() && matchesPattern("51422", device.getPattern())) {
+//                        int level = device.isActual() ? Log.DEBUG : Log.ASSERT;
+//
+//                        Log.println(level, "scannerViewModel",
+//                                "address: " + device.getAddress() + ", " +
+//                                "pattern: " + device.getPattern() + ", " +
+//                                "numPattern: " + device.getNumPattern() + ", " +
+//                                "bonded: " + device.isBonded() + ", " +
+//                                "actual: " + device.isActual());
+//                    }
+//                }
+            }
+        });
+    }
+
+    public void onPatternChange(int column, float value){
+        Utils.log(Log.ASSERT, "BAR_MAIN", "Column " + column + ": " + value);
+    }
+
+    private static boolean matchesPattern(String numberPattern, String letterPattern) {
+        return false;
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        requestWasSent = false;
+        checkPermission();
+        readDisplayMetrics();
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+//        scannerViewModel.stopScan();
+    }
+
+    @Override
+    public void onDismiss(final DialogInterface dialog) {
+        //Fragment dialog had been dismissed
+//        fab.setVisibility(View.VISIBLE);
+    }
+
+    private void readDisplayMetrics() {
+        WindowManager windowManager = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
+        DisplayMetrics displayMetrics = new DisplayMetrics();
+        windowManager.getDefaultDisplay().getMetrics(displayMetrics);
+        screenWidth = displayMetrics.widthPixels;
+        screenHeight = displayMetrics.heightPixels;
+    }
+
+    public void setContentView(ConstraintLayout view) {
+        super.setContentView(view);
+        this.rootView = view;
+    }
+
+    public void setPatternFab(MovableFloatingActionButton patternFab) {
+        this.patternFab = patternFab;
+        this.patternFab.setOnClickListener(this::onFabClick);
+    }
+
+    private void checkPermission() {
+        boolean isBluetoothAccessGranted = Permission.isAccessGranted(this, Permission.BLUETOOTH_PERMISSIONS);
+        boolean isLocationAccessGranted = Version.VERSION_S_AND_NEWER || Permission.isAccessGranted(this, Permission.LOCATION_PERMISSIONS);
+        boolean isNotificationAccessGranted = !Version.VERSION_TIRAMISU_AND_NEWER || Permission.isAccessGranted(this, Permission.POST_NOTIFICATIONS) ||
+                Permission.isAccessDeniedForever(this, Permission.POST_NOTIFICATIONS);
+
+        if (isBluetoothAccessGranted && isLocationAccessGranted && isNotificationAccessGranted) {
+            if (!Utils.isBluetoothEnabled()) {
+                showBluetoothDisabledWarning();
+            } else if (!Version.VERSION_S_AND_NEWER && !Utils.isLocationEnabled(this)) {
+                showLocationDisabledWarning();
+            }
+//            scannerViewModel.startScan();
+            viewModel.startScan();
+        } else {
+            startNoPermissionActivity();
+        }
+    }
+
+    protected void scanResults(ScannerLiveData state) {
+        if (hasOpenedPatternDialog()) {
+            return;
+        }
+
+        if (!state.isBluetoothEnabled() && !requestWasSent) {
+            showBluetoothDisabledWarning();
+        }
+
+        setDevice(state.getCurrentDevice());
+    }
+
+    protected void setDevice(ExtendedBluetoothDevice device) {
+        if (patternFab != null) {
+            boolean colorGreen = (device != null && device.isRelevant()) || app.getAppState() != App.APP_STATE_STANDBY;
+            int color = colorGreen ? R.color.green : R.color.orange;
+            patternFab.setColor(color);
+        }
+    }
+
+    private void showPatternDialog(FobParams params) {
+//        scannerViewModel.startScan(); // On older devices, "auto-start" scanning does not work after bluetooth is turned on.
+
+        FragmentManager fragmentManager = getSupportFragmentManager();
+        PatternDialogFragment dialogFragment = PatternDialogFragment.newInstance(params);
+        dialogFragment.show(fragmentManager, "fragment_pattern");
+    }
+
+    private void showBluetoothDisabledWarning() {
+        Utils.errorSnackbar(rootView, getString(R.string.error_snackbar_bluetooth_disable))
+                .setDuration(SNACKBAR_DURATION)
+                .setAction(R.string.button_enable, this::startBluetoothEnableActivity)
+                .show();
+    }
+
+    private void showLocationDisabledWarning() {
+        Utils.errorSnackbar(rootView, getString(R.string.error_snackbar_location_disable))
+                .show();
+    }
+
+    private void startNoPermissionActivity() {
+        Intent intent = new Intent(this, NoPermissionActivity.class);
+        startActivity(intent);
+    }
+
+    public void startBluetoothEnableActivity(View view) {
+        requestWasSent = true;
+        Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
+        bluetoothEnableResultLauncher.launch(enableBtIntent);
+    }
+
+    public void onFabClick(View view) {
+        createPopupMenu(view);
+        showPopupMenu(view);
+    }
+
+    private void createPopupMenu(View view) {
+        List<PopupItem> popupItems = new ArrayList<>();
+        addPopupMenuItems(popupItems);
+
+        final ListView listView = new ListView(this);
+        listView.setAdapter(new PopupAdapter(this,
+                (Math.round(view.getX()) <= screenWidth / 2) ? PopupAdapter.TYPE_START : PopupAdapter.TYPE_END,
+                popupItems)
+        );
+        listView.setDivider(null);
+        listView.setOnItemClickListener(this::onPopupMenuItemClick);
+
+        //get max item measured width
+        popupMenuHeight = 0;
+        for (int i = 0; i < listView.getAdapter().getCount(); i++) {
+            View listItem = listView.getAdapter().getView(i, null, listView);
+            listItem.measure(View.MeasureSpec.UNSPECIFIED, View.MeasureSpec.UNSPECIFIED);
+            int width = listItem.getMeasuredWidth();
+            if (width > popupMenuWidth) {
+                popupMenuWidth = width;
+            }
+            popupMenuHeight += listItem.getMeasuredHeight();
+        }
+
+        popupWindow = new PopupWindow(listView, popupMenuWidth, WindowManager.LayoutParams.WRAP_CONTENT, true);
+        popupWindow.setTouchable(true);
+        popupWindow.setFocusable(true);
+        popupWindow.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
+        popupWindow.setOnDismissListener(() -> onDismissPopupMenu(view));
+    }
+
+    public void addPopupMenuItems(List<PopupItem> popupItems) {
+        popupItems.add(new PopupItem(R.string.menu_fab_connect, R.drawable.ic_connect));
+    }
+
+    public void onPopupMenuItemClick(AdapterView<?> parent, View view, int position, long id) {
+        Utils.log(Log.ASSERT, "SA", "position: " + position);
+        popupWindow.dismiss();
+        if (position == 0) {
+            if (app.getAppState() == App.APP_STATE_STANDBY) {
+                showPatternDialog(new FobParams(
+                        patternFab.getWidth(),
+                        patternFab.getHeight(),
+                        patternFab.getX(),
+                        patternFab.getY()
+                ));
+            } else {
+                startFlashingActivity();
+            }
+        }
+    }
+
+    private void showPopupMenu(View view) {
+        Offset offset = getOffset(view);
+        popupWindow.showAsDropDown(view, offset.getX(), offset.getY());
+        dimBackground(0.5f);  // затемнюємо фон до 50%
+        ViewCompat.animate(view)
+                .rotation(45.0F)
+                .withLayer().setDuration(300)
+                .setInterpolator(new OvershootInterpolator(10.0F))
+                .start();
+    }
+
+    private void onDismissPopupMenu(View view) {
+        dimBackground(1.0f);
+        ViewCompat.animate(view)
+                .rotation(0.0F)
+                .withLayer().setDuration(300)
+                .setInterpolator(new OvershootInterpolator(10.0F))
+                .start();
+    }
+
+    private void dimBackground(float dimAmount) {
+        Window window = getWindow();
+        WindowManager.LayoutParams layoutParams = window.getAttributes();
+        layoutParams.alpha = dimAmount;
+        window.setAttributes(layoutParams);
+    }
+
+    private class Offset {
+        private final int x;
+        private final int y;
+
+        public Offset(int x, int y) {
+            this.x = x;
+            this.y = y;
+        }
+
+        public int getX() {
+            return x;
+        }
+
+        public int getY() {
+            return y;
+        }
+
+        @NonNull
+        @Override
+        public String toString() {
+            return "Offset{" +
+                    "x=" + x +
+                    ", y=" + y +
+                    '}';
+        }
+    }
+
+    private Offset getOffset(View view) {
+        int x;
+        int y;
+
+        if (Math.round(view.getX()) <= screenWidth / 2) {
+            x = Utils.convertDpToPixel(this, 8);
+        } else {
+            x = (Utils.convertDpToPixel(this, 8) - view.getWidth() + popupMenuWidth) * -1;
+        }
+
+        if (Math.round(view.getY()) <= screenHeight / 2) {
+            y = Utils.convertDpToPixel(this, 4);
+        } else {
+            y = (Utils.convertDpToPixel(this, 4) + view.getHeight() + popupMenuHeight) * -1;
+        }
+
+        return new Offset(x, y);
+    }
+
+    private void startFlashingActivity() {
+        final Intent intent = new Intent(this, FlashingActivity.class);
+        startActivity(intent);
+    }
+
+    private boolean hasOpenedPatternDialog() {
+        List<Fragment> fragments = getSupportFragmentManager().getFragments();
+        for (Fragment fragment : fragments) {
+            if (fragment instanceof PatternDialogFragment) {
+                return true;
+            }
+        }
+        return false;
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/activity/SettingsActivity.java b/app/src/main/java/cc/calliope/mini/activity/SettingsActivity.java
new file mode 100644
index 0000000..4e1e8bf
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/activity/SettingsActivity.java
@@ -0,0 +1,19 @@
+package cc.calliope.mini.activity;
+
+import android.os.Bundle;
+import androidx.appcompat.app.AppCompatActivity;
+import cc.calliope.mini.R;
+import cc.calliope.mini.fragment.settings.SettingsFragment;
+
+public class SettingsActivity extends AppCompatActivity {
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_settings);
+
+        getSupportFragmentManager().beginTransaction()
+                .add(R.id.fragment_container, new SettingsFragment())
+                .commit();
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/adapter/DevicesAdapter.java b/app/src/main/java/cc/calliope/mini/adapter/DevicesAdapter.java
deleted file mode 100644
index 882e425..0000000
--- a/app/src/main/java/cc/calliope/mini/adapter/DevicesAdapter.java
+++ /dev/null
@@ -1,159 +0,0 @@
-/*
- * Copyright (c) 2015, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *  Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- *
- *  Redistributions in binary form must reproduce the above copyright notice,
- *   this list of conditions and the following disclaimer in the documentation
- *   and/or other materials provided with the distribution.
- *
- *  Neither the name of copyright holder nor the names of its
- *   contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package cc.calliope.mini.adapter;
-
-import android.content.Context;
-import android.support.annotation.NonNull;
-import android.support.v7.widget.RecyclerView;
-import android.text.TextUtils;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.ImageView;
-import android.widget.TextView;
-import android.widget.Toast;
-
-import java.util.List;
-
-import butterknife.BindView;
-import butterknife.ButterKnife;
-import cc.calliope.mini.ScannerActivity;
-import cc.calliope.mini.R;
-import cc.calliope.mini.viewmodels.ScannerLiveData;
-//import cc.calliope.mini.R;
-
-@SuppressWarnings("unused")
-public class DevicesAdapter extends RecyclerView.Adapter<DevicesAdapter.ViewHolder> {
-	private final ScannerActivity mContext;
-	private final List<ExtendedBluetoothDevice> mDevices;
-	private OnItemClickListener mOnItemClickListener;
-
-	@FunctionalInterface
-	public interface OnItemClickListener {
-		void onItemClick(final ExtendedBluetoothDevice device);
-	}
-
-	public void setOnItemClickListener(final Context context) {
-		mOnItemClickListener = (OnItemClickListener) context;
-	}
-
-	public DevicesAdapter(final ScannerActivity activity, final ScannerLiveData scannerLiveData) {
-		mContext = activity;
-		mDevices = scannerLiveData.getDevices();
-		scannerLiveData.observe(activity, devices -> {
-			final Integer i = devices.getUpdatedDeviceIndex();
-			if (i != null)
-				notifyItemChanged(i);
-			else
-				notifyDataSetChanged();
-		});
-	}
-
-//	public int getDevicePattern(char character) {
-//
-//		if ("ZU".contains(String.valueOf(character)))
-//		return R.drawable.pattern1;
-//		if ("VO".contains(String.valueOf(character)))
-//			return R.drawable.pattern2;
-//		if ("GI".contains(String.valueOf(character)))
-//		return R.drawable.pattern3;
-//		if ("PE".contains(String.valueOf(character)))
-//			return R.drawable.pattern4;
-//		if ("TA".contains(String.valueOf(character)))
-//			return R.drawable.pattern5;
-//		else
-//			return R.drawable.pattern0;
-//	}
-
-	@NonNull
-	@Override
-	public ViewHolder onCreateViewHolder(@NonNull final ViewGroup parent, final int viewType) {
-		final View layoutView = LayoutInflater.from(mContext).inflate(R.layout.device_item, parent, false);
-		return new ViewHolder(layoutView);
-	}
-
-	@Override
-	public void onBindViewHolder(@NonNull final ViewHolder holder, final int position) {
-		final ExtendedBluetoothDevice device = mDevices.get(position);
-		final String deviceName = device.getName();
-		final String devicePattern = device.getPattern();
-
-		if (!TextUtils.isEmpty(deviceName))
-			holder.deviceName.setText(deviceName);
-		else
-			holder.deviceName.setText(R.string.unknown_device);
-		holder.deviceAddress.setText(device.getAddress());
-		final int rssiPercent = (int) (100.0f * (127.0f + device.getRssi()) / (127.0f + 20.0f));
-		holder.rssi.setImageLevel(rssiPercent);
-		holder.pattern1.setImageResource(device.getDevicePattern(0));
-		holder.pattern2.setImageResource(device.getDevicePattern(1));
-		holder.pattern3.setImageResource(device.getDevicePattern(2));
-		holder.pattern4.setImageResource(device.getDevicePattern(3));
-		holder.pattern5.setImageResource(device.getDevicePattern(4));
-	}
-
-	@Override
-	public long getItemId(final int position) {
-		return position;
-	}
-
-	@Override
-	public int getItemCount() {
-		return mDevices.size();
-	}
-
-	public boolean isEmpty() {
-		return getItemCount() == 0;
-	}
-
-
-	final class ViewHolder extends RecyclerView.ViewHolder {
-		@BindView(R.id.device_address) TextView deviceAddress;
-		@BindView(R.id.device_name) TextView deviceName;
-		@BindView(R.id.rssi) ImageView rssi;
-		@BindView(R.id.pattern1) ImageView pattern1;
-		@BindView(R.id.pattern2) ImageView pattern2;
-		@BindView(R.id.pattern3) ImageView pattern3;
-		@BindView(R.id.pattern4) ImageView pattern4;
-		@BindView(R.id.pattern5) ImageView pattern5;
-
-		private ViewHolder(final View view) {
-			super(view);
-			ButterKnife.bind(this, view);
-
-			view.findViewById(R.id.device_container).setOnClickListener(v -> {
-				if (mOnItemClickListener != null) {
-					mOnItemClickListener.onItemClick(mDevices.get(getAdapterPosition()));
-				}
-			});
-		}
-	}
-}
diff --git a/app/src/main/java/cc/calliope/mini/adapter/ExtendedBluetoothDevice.java b/app/src/main/java/cc/calliope/mini/adapter/ExtendedBluetoothDevice.java
deleted file mode 100644
index 994a197..0000000
--- a/app/src/main/java/cc/calliope/mini/adapter/ExtendedBluetoothDevice.java
+++ /dev/null
@@ -1,160 +0,0 @@
-/*
- * Copyright (c) 2010 - 2017, Nordic Semiconductor ASA
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form, except as embedded into a Nordic
- *    Semiconductor ASA integrated circuit in a product or a software update for
- *    such product, must reproduce the above copyright notice, this list of
- *    conditions and the following disclaimer in the documentation and/or other
- *    materials provided with the distribution.
- *
- * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
- *    contributors may be used to endorse or promote products derived from this
- *    software without specific prior written permission.
- *
- * 4. This software, with or without modification, must only be used with a
- *    Nordic Semiconductor ASA integrated circuit.
- *
- * 5. Any software provided in binary form under this license must not be reverse
- *    engineered, decompiled, modified and/or disassembled.
- *
- * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
- * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
- * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package cc.calliope.mini.adapter;
-
-import android.bluetooth.BluetoothDevice;
-import android.os.Parcel;
-import android.os.Parcelable;
-
-import cc.calliope.mini.R;
-import no.nordicsemi.android.support.v18.scanner.ScanResult;
-
-public class ExtendedBluetoothDevice implements Parcelable {
-	private final BluetoothDevice device;
-	private String name;
-	private String pattern;
-	private int rssi;
-
-	public ExtendedBluetoothDevice(final ScanResult scanResult) {
-		this.device = scanResult.getDevice();
-		this.name = scanResult.getScanRecord().getDeviceName();
-		this.pattern = "00000";
-		this.rssi = scanResult.getRssi();
-	}
-
-	public BluetoothDevice getDevice() {
-		return device;
-	}
-
-	public String getAddress() {
-		return device.getAddress();
-	}
-
-	public String getName() {
-		return name;
-	}
-
-	public String getPattern() {
-		return pattern;
-	}
-
-	public int getDevicePattern(int characterPosition) {
-
-		try {
-			char character = pattern.charAt(characterPosition);
-
-			if ("ZU".contains(String.valueOf(character)))
-				return R.drawable.pattern1;
-			if ("VO".contains(String.valueOf(character)))
-				return R.drawable.pattern2;
-			if ("GI".contains(String.valueOf(character)))
-				return R.drawable.pattern3;
-			if ("PE".contains(String.valueOf(character)))
-				return R.drawable.pattern4;
-			if ("TA".contains(String.valueOf(character)))
-				return R.drawable.pattern5;
-			else
-				return R.drawable.pattern0;
-		} catch (Exception e) {
-			return R.drawable.pattern0;
-		}
-	}
-
-	public void setName(final String name) {
-		this.name = name;
-	}
-
-	public void setPattern(final String pattern) {
-		this.pattern = pattern;
-	}
-
-	public int getRssi() {
-		return rssi;
-	}
-
-	public void setRssi(final int rssi) {
-		this.rssi = rssi;
-	}
-
-	public boolean matches(final ScanResult scanResult) {
-		return device.getAddress().equals(scanResult.getDevice().getAddress());
-	}
-
-	@Override
-	public boolean equals(final Object o) {
-		if (o instanceof ExtendedBluetoothDevice) {
-			final ExtendedBluetoothDevice that = (ExtendedBluetoothDevice) o;
-			return device.getAddress().equals(that.device.getAddress());
-		}
-		return super.equals(o);
-	}
-
-	// Parcelable implementation
-
-	private ExtendedBluetoothDevice(final Parcel in) {
-		this.device = in.readParcelable(BluetoothDevice.class.getClassLoader());
-		this.name = in.readString();
-		this.pattern = in.readString();
-		this.rssi = in.readInt();
-	}
-
-	@Override
-	public void writeToParcel(final Parcel parcel, final int flags) {
-		parcel.writeParcelable(device, flags);
-		parcel.writeString(name);
-		parcel.writeString(pattern);
-		parcel.writeInt(rssi);
-	}
-
-	@Override
-	public int describeContents() {
-		return 0;
-	}
-
-	public static final Creator<ExtendedBluetoothDevice> CREATOR = new Creator<ExtendedBluetoothDevice>() {
-		@Override
-		public ExtendedBluetoothDevice createFromParcel(final Parcel source) {
-			return new ExtendedBluetoothDevice(source);
-		}
-
-		@Override
-		public ExtendedBluetoothDevice[] newArray(final int size) {
-			return new ExtendedBluetoothDevice[size];
-		}
-	};
-}
diff --git a/app/src/main/java/cc/calliope/mini/adapter/HexFilesAdapter.java b/app/src/main/java/cc/calliope/mini/adapter/HexFilesAdapter.java
deleted file mode 100644
index 15b2104..0000000
--- a/app/src/main/java/cc/calliope/mini/adapter/HexFilesAdapter.java
+++ /dev/null
@@ -1,216 +0,0 @@
-package cc.calliope.mini.adapter;
-
-import android.app.AlertDialog;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.net.Uri;
-import android.preference.PreferenceManager;
-import android.support.v4.content.FileProvider;
-import android.text.InputType;
-import android.util.Log;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.ArrayAdapter;
-import android.widget.Button;
-import android.widget.EditText;
-import android.widget.ImageButton;
-import android.widget.ListView;
-import android.widget.TextView;
-import android.widget.Toast;
-
-import com.github.marlonlom.utilities.timeago.TimeAgo;
-
-import java.io.File;
-import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Locale;
-
-import cc.calliope.mini.DFUActivity;
-import cc.calliope.mini.R;
-import cc.calliope.mini.datamodel.HexFile;
-
-public class HexFilesAdapter extends ArrayAdapter<HexFile> {
-
-    Button btnUpload,btnShare;
-    ExtendedBluetoothDevice device;
-    Context ParentContext;
-
-    public HexFilesAdapter(Context context, ArrayList<HexFile> items, ExtendedBluetoothDevice SelectedDevice) {
-
-        super(context, 0, items);
-        device = SelectedDevice;
-        ParentContext = context;
-    }
-
-
-
-    @Override
-
-    public View getView(int position, View convertView, ViewGroup parent) {
-
-        // Get the data item for this position
-
-        HexFile HexFile = getItem(position);
-
-        // Check if an existing view is being reused, otherwise inflate the view
-
-        if (convertView == null) {
-            convertView = LayoutInflater.from(getContext()).inflate(R.layout.hex_file_list_item, parent, false);
-        }
-
-        // Lookup view for data population
-        TextView tvSource = (TextView) convertView.findViewById(R.id.tvSource);
-        TextView tvDate = (TextView) convertView.findViewById(R.id.tvDate);
-        TextView tvTime = (TextView) convertView.findViewById(R.id.tvTime);
-
-//        Locale LocaleBylanguageTag = Locale.forLanguageTag("de");
-//        TimeAgoMessages messages = new TimeAgoMessages.Builder().withLocale(LocaleBylanguageTag).build();
-//
-//        String timeAgoText = TimeAgo.using(HexFile.lastModified, messages);
-        String timeAgoText = TimeAgo.using(HexFile.lastModified);
-
-        // Populate the data into the template view using the data object
-        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("EEEE dd.MM.yyyy", Locale.GERMAN);
-        String formattedDate = new SimpleDateFormat("EEEE dd.MM.yyyy", Locale.GERMAN).format(HexFile.lastModified);
-        String formattedTime = new SimpleDateFormat("hh:mm:ss", Locale.GERMAN).format(HexFile.lastModified)+" Uhr";
-
-        tvDate.setText(formattedDate);
-        tvTime.setText(formattedTime+" - "+timeAgoText);
-        tvSource.setText(HexFile.File.getName() + "");
-
-
-        btnUpload = (Button) convertView.findViewById(R.id.btnUpload);
-        btnUpload.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-//                Log.i("SELECTED Position", position + "");
-//                Log.i("SLECTED HexFile", getHexFileName(position));
-                String selectedItem = getHexFile(position).toString();
-
-                if (device != null) {
-                    final Intent intent = new Intent(ParentContext, DFUActivity.class); // ParentContext.this ?
-                    intent.putExtra("cc.calliope.mini.EXTRA_DEVICE", device);
-                    intent.putExtra("EXTRA_FILE", selectedItem);
-                    ParentContext.startActivity(intent);
-                } else {
-                    Toast.makeText(ParentContext, R.string.upload_no_mini_connected, Toast.LENGTH_LONG).show();
-                }
-            }
-        });
-
-        btnShare = (Button) convertView.findViewById(R.id.btnShare);
-        btnShare.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-//                Log.i("BUTTON Share", "AT "+position+" File: "+ getHexFile(position));
-
-                File file = getHexFile(position);
-
-                Intent intentShareFile = new Intent(Intent.ACTION_SEND);
-               // intentShareFile.setType(URLConnection.guessContentTypeFromName(file.getName()));
-                intentShareFile.setType("text/plain");
-                intentShareFile.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
-                Uri uri = FileProvider.getUriForFile(ParentContext, "cc.calliope.fileprovider",  file);
-                intentShareFile.putExtra(Intent.EXTRA_STREAM, uri);
-
-                //if you need
-                //intentShareFile.putExtra(Intent.EXTRA_SUBJECT,"Sharing File Subject);
-                //intentShareFile.putExtra(Intent.EXTRA_TEXT, "Sharing File Description");
-
-                ParentContext.startActivity(Intent.createChooser(intentShareFile, "Share File"));
-
-//                val shareIntent = Intent()
-//                shareIntent.flags = Intent.FLAG_GRANT_READ_URI_PERMISSION
-//                val uri = FileProvider.getUriForFile(this, "cc.calliope.fileprovider", tmpURL)
-//                shareIntent.action = Intent.ACTION_SEND
-//                shareIntent.putExtra(Intent.EXTRA_STREAM, uri)
-//                shareIntent.type = "text/plain"
-//                startActivity(Intent.createChooser(shareIntent, "Datei teilen mit"))
-            }
-        });
-
-
-        ImageButton btnDelete = (ImageButton) convertView.findViewById(R.id.btnDelete);
-        btnDelete.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-//                Log.i("BUTTON Delete", "AT "+position+" File: "+ getHexFile(position));
-
-                File file = getHexFile(position);
-                file.delete();
-//                HexFilesAdapter.notifyDataSetChanged();
-                HexFilesAdapter.this.remove(getItem(position));
-                HexFilesAdapter.this.notifyDataSetChanged();
-
-            }
-        });
-
-
-        Button btnRename = (Button) convertView.findViewById(R.id.btnRename);
-        btnRename.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-//                Log.i("BUTTON RENAME", "AT "+position+" File: "+ getHexFile(position));
-
-                File file = getHexFile(position);
-
-                AlertDialog.Builder builder = new AlertDialog.Builder(view.getContext());
-                builder.setTitle("Rename file");
-
-// Set up the input
-                final EditText input = new EditText(view.getContext());
-
-                input.setText(file.getName());
-// Specify the type of input expected; this, for example, sets the input as a password, and will mask the text
-                input.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_URI);
-                builder.setView(input);
-
-// Set up the buttons
-                builder.setPositiveButton("OK", new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialog, int which) {
-                        String m_Text = input.getText().toString();
-                        //                HexFilesAdapter.this.remove(getItem(position));
-                        File dir = new File(ParentContext.getFilesDir().toString());
-                        if(dir.exists()){
-                            File from = getHexFile(position);
-                            File to = new File(dir,m_Text);
-                            if(from.exists() && !to.exists())
-                                from.renameTo(to);
-                                HexFile newItem = getItem(position);
-                                newItem.File = to;
-
-                                HexFilesAdapter.this.remove(getItem(position));
-                                HexFilesAdapter.this.insert(newItem, position);
-                                HexFilesAdapter.this.notifyDataSetChanged();
-                        }
-
-                    }
-                });
-                builder.setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialog, int which) {
-                        dialog.cancel();
-                    }
-                });
-
-                builder.show();
-
-
-            }
-        });
-
-        // Return the completed view to render on screen
-
-        return convertView;
-    }
-
-    public File getHexFile(int position) {
-        HexFile HexFile = getItem(position);
-        return HexFile.File;
-    }
-
-}
diff --git a/app/src/main/java/cc/calliope/mini/core/GoogleAnalyticsManager.java b/app/src/main/java/cc/calliope/mini/core/GoogleAnalyticsManager.java
deleted file mode 100644
index c727e65..0000000
--- a/app/src/main/java/cc/calliope/mini/core/GoogleAnalyticsManager.java
+++ /dev/null
@@ -1,238 +0,0 @@
-//package cc.calliope.mini.core;
-//
-//import android.app.Activity;
-//import android.content.Context;
-//import android.text.TextUtils;
-//import android.util.Log;
-//
-//import com.google.android.gms.analytics.GoogleAnalytics;
-//import com.google.android.gms.analytics.HitBuilders;
-//import com.google.android.gms.analytics.Tracker;
-//import com.samsung.microbit.MBApp;
-//import com.samsung.microbit.R;
-//import com.samsung.microbit.core.bluetooth.BluetoothUtils;
-//import com.samsung.microbit.data.constants.Constants;
-//import com.samsung.microbit.utils.ProjectsHelper;
-//
-//import java.util.HashMap;
-//
-//
-///**
-// * Allows to send statistics about app work, such as navigation, pairing,
-// * connection and flashing statistics.
-// */
-//public class GoogleAnalyticsManager {
-//
-//    private static final String TAG = GoogleAnalyticsManager.class.getSimpleName();
-//    private static final String PREFS_NAME = "com.samsung.microbit";
-//    private static final String TRACK_ID = "UA-87395020-1";
-//
-//    private static GoogleAnalyticsManager instance = null;
-//
-//    private Tracker mTracker;
-//
-//    private boolean mShareStatistic = false;
-//
-//    private final static int MICROBITS_PAIRED = 1;
-//    private final static int SAVED_PROJECTS = 2;
-//    private final static int HEX_FILE_SIZE = 3;
-//    private final static int BINARY_SIZE = 4;
-//    private final static int FIRMWARE = 5;
-//    private final static int BUTTON = 6;
-//    private final static int DURATION = 7;
-//    private final static int HEX_FILE_FLASH_STATUS = 8;
-//    private final static int STATS_TRACKING_STATUS = 9;
-//    private final static int PAIR_STATUS = 10;
-//    private final static int CONNECT_STATUS = 11;
-//
-//
-//    private GoogleAnalyticsManager(Context context) {
-//
-//        mShareStatistic = context.getSharedPreferences(PREFS_NAME, Context
-//                .MODE_PRIVATE).getBoolean(context.getString(R.string.prefs_share_stats_status), true);
-//
-//        mTracker = GoogleAnalytics.getInstance(context).newTracker(TRACK_ID);
-//    }
-//
-//    public static synchronized GoogleAnalyticsManager createInstance(MBApp mbApp) {
-//        if (instance == null) {
-//            instance = new GoogleAnalyticsManager(mbApp);
-//        }
-//        return instance;
-//    }
-//
-//    /*
-//    Use this method to send events
-//     */
-//    public static GoogleAnalyticsManager getInstance() {
-//        return instance;
-//    }
-//
-//    public void setShareStatistic(boolean shareStatistic) {
-//        this.mShareStatistic = shareStatistic;
-//    }
-//
-//    public void activityStart(Activity activity) {
-//        if (mShareStatistic) {
-//            GoogleAnalytics.getInstance(activity).reportActivityStart(activity);
-//        }
-//    }
-//
-//    public void activityStop(Activity activity) {
-//        if(mShareStatistic) {
-//            GoogleAnalytics.getInstance(activity).reportActivityStop(activity);
-//        }
-//    }
-//
-//    private void sendEvent(final String screenName, final String category, final String action, final HashMap<Integer, String> dimensionsMap) {
-//        mTracker.setScreenName(screenName);
-//
-//        HitBuilders.EventBuilder eventBuilder = new HitBuilders.EventBuilder()
-//                .setCategory(category)
-//                .setAction(action);
-//
-//        for (int key : dimensionsMap.keySet()) {
-//            eventBuilder.setCustomDimension(key, dimensionsMap.get(key));
-//        }
-//
-//        mTracker.send(eventBuilder.build());
-//    }
-//
-//    public void sendAppStats(final String screenName) {
-//        if (mShareStatistic) {
-//            Log.d(TAG, "sendAppStats");
-//            HashMap<Integer, String> eventLabels = new HashMap<>();
-//            eventLabels.put(MICROBITS_PAIRED, Integer.toString(BluetoothUtils.getTotalPairedMicroBitsFromSystem()));
-//            eventLabels.put(SAVED_PROJECTS, Integer.toString(ProjectsHelper.getTotalSavedProjects()));
-//
-//            sendEvent(screenName, "App", "App start", eventLabels);
-//
-//        } else {
-//            Log.d(TAG, "Sharing of stats is disabled by user");
-//        }
-//    }
-//
-//
-//    public void sendViewEventStats(final String screenName) {
-//        if (mShareStatistic) {
-//            mTracker.setScreenName(screenName);
-//            mTracker.send(new HitBuilders.ScreenViewBuilder().build());
-//        } else {
-//            Log.d(TAG, "Sharing of stats is disabled by user");
-//        }
-//    }
-//
-//    public void sendFlashStats(final String screenName, final boolean success, final  String fileName, final String hexsize, final String binsize, final String firmware) {
-//        try {
-//            if (mShareStatistic) {
-//                Log.d(TAG, "sendFlashStats fileName=" + fileName + " hexsize=" + hexsize + "  " +
-//                        "binsize=" + binsize + " microbit_firmwwareversion= " + firmware);
-//                HashMap<Integer, String> eventLabels = new HashMap<>();
-//                eventLabels.put(HEX_FILE_SIZE, hexsize);
-//                eventLabels.put(BINARY_SIZE, binsize);
-//                eventLabels.put(FIRMWARE, firmware);
-//
-//                if (success) {
-//                    eventLabels.put(HEX_FILE_FLASH_STATUS, "success");
-//                } else {
-//                    eventLabels.put(HEX_FILE_FLASH_STATUS, "fail");
-//                }
-//
-//                sendEvent(screenName, "Flash", "Hex file flash", eventLabels);
-//
-//            } else {
-//                Log.d(TAG, "Sharing of stats is disabled by user");
-//            }
-//        } catch (RuntimeException e) {
-//            Log.e(TAG, "Sending stats exception " + e.getMessage());
-//        }
-//    }
-//
-//    public void sendNavigationStats(final String screenName, final String button) {
-//        try {
-//            if (mShareStatistic) {
-//                HashMap<Integer, String> eventLabels = new HashMap<>();
-//                eventLabels.put(BUTTON, button);
-//
-//                sendEvent(screenName, "Navigation", "Click", eventLabels);
-//
-//            } else {
-//                Log.d(TAG, "Sharing of stats is disabled by user");
-//            }
-//        } catch (RuntimeException e) {
-//            Log.e(TAG, "Sending stats exception " + e.getMessage());
-//        }
-//    }
-//
-//    public void sendStatSharing(final String screenName, final boolean enable) {
-//        try {
-//            HashMap<Integer, String> eventLabels = new HashMap<>();
-//            if (enable) {
-//                eventLabels.put(STATS_TRACKING_STATUS, "opt-in");
-//            } else {
-//                eventLabels.put(STATS_TRACKING_STATUS, "opt-out");
-//            }
-//
-//            sendEvent(screenName, "Share Statistics", "Change stats option", eventLabels);
-//
-//        } catch (RuntimeException e) {
-//            Log.e(TAG, "Sending stats exception " + e.getMessage());
-//        }
-//    }
-//
-//    public void sendPairingStats(final String screenName, final boolean paired, final String firmware) {
-//        try {
-//            if (mShareStatistic) {
-//                HashMap<Integer, String> eventLabels = new HashMap<>();
-//                eventLabels.put(FIRMWARE, TextUtils.isEmpty(firmware) ? "-" : firmware);
-//
-//                if (paired) {
-//                    eventLabels.put(PAIR_STATUS, "success");
-//                } else {
-//                    eventLabels.put(PAIR_STATUS, "fail");
-//                }
-//
-//                sendEvent(screenName, "Pairing", "Pair", eventLabels);
-//            } else {
-//                Log.d(TAG, "Sharing of stats is disabled by user");
-//            }
-//        } catch (RuntimeException e) {
-//            Log.e(TAG, "Sending stats exception " + e.getMessage());
-//        }
-//    }
-//
-//    public void sendConnectStats(final String screenName, final Constants.ConnectionState connectionState, final String firmware, final String duration) {
-//        try {
-//            if (mShareStatistic) {
-//                HashMap<Integer, String> eventLabels = new HashMap<>();
-//                Log.d(TAG, "sendConnectStats, firmware " + firmware + " duration " + duration + " connectionState " + connectionState);
-//
-//                eventLabels.put(FIRMWARE, TextUtils.isEmpty(firmware) ? "-" : firmware);
-//                eventLabels.put(DURATION, TextUtils.isEmpty(duration) ? "-" : duration );
-//                switch (connectionState) {
-//                    case SUCCESS:
-//                        Log.d(TAG, "Sending Connection stats - MSG(SUCCESS) - Firmware = " + firmware);
-//                        eventLabels.put(CONNECT_STATUS, "success");
-//                        break;
-//                    case FAIL:
-//                        Log.d(TAG, "Sending Connection stats - MSG(Failed)");
-//                        eventLabels.put(CONNECT_STATUS, "fail");
-//
-//                        break;
-//                    case DISCONNECT:
-//                        Log.d(TAG, "Sending Connection stats - MSG(DISCONNECT) - Firmware = " + firmware + " Duration =" + duration);
-//                        eventLabels.put(CONNECT_STATUS, "disconnect");
-//                        break;
-//                    default:
-//                        break;
-//                }
-//
-//                sendEvent(screenName, "Connection", "Connect", eventLabels);
-//            } else {
-//                Log.d(TAG, "Sharing of stats is disabled by user");
-//            }
-//        } catch (RuntimeException e) {
-//            Log.e(TAG, "Sending stats exception " + e.getMessage());
-//        }
-//    }
-//}
diff --git a/app/src/main/java/cc/calliope/mini/datamodel/ConnectedDevice.java b/app/src/main/java/cc/calliope/mini/datamodel/ConnectedDevice.java
deleted file mode 100644
index 37f39b7..0000000
--- a/app/src/main/java/cc/calliope/mini/datamodel/ConnectedDevice.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package cc.calliope.mini.datamodel;
-
-/**
- * Represents a connected device (a micro:bit board).
- * It contains common information about a micro:bit board such as
- * name, pattern, status, address, etc.
- */
-public class ConnectedDevice {
-
-    public String mName;
-    public String mPattern;
-    public boolean mStatus;
-    public String mAddress;
-    public int mPairingCode;
-    public String mfirmware_version;
-    public long mlast_connection_time;
-
-    public ConnectedDevice() {
-    }
-
-    public ConnectedDevice(String name, String pattern,
-                           boolean status, String address,
-                           int pairingCode, String firmware,
-                           long connectionTime) {
-        this.mName = name;
-        this.mPattern = pattern;
-        this.mStatus = status;
-        this.mAddress = address;
-        this.mPairingCode = pairingCode;
-        this.mfirmware_version = firmware;
-        this.mlast_connection_time = connectionTime;
-    }
-}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/datamodel/HexFile.java b/app/src/main/java/cc/calliope/mini/datamodel/HexFile.java
deleted file mode 100644
index de1ff68..0000000
--- a/app/src/main/java/cc/calliope/mini/datamodel/HexFile.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package cc.calliope.mini.datamodel;
-
-import java.io.File;
-
-public class HexFile {
-    public File File;
-    public long lastModified;
-
-    public HexFile(File File, long lastModified) {
-        this.File = File;
-        this.lastModified = lastModified;
-    }
-}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/datamodel/Project.java b/app/src/main/java/cc/calliope/mini/datamodel/Project.java
deleted file mode 100644
index 74e4168..0000000
--- a/app/src/main/java/cc/calliope/mini/datamodel/Project.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package cc.calliope.mini.datamodel;
-
-/**
- * Represents a program that can be loaded to a micro:bit board.
- * It contains common information about the program such as program name,
- * file path, run status, etc.
- */
-public class Project {
-
-    public final String name;
-    public final long timestamp;
-    public final String filePath;
-    public final String codeUrl;
-    public boolean runStatus;
-    public boolean actionBarExpanded;
-    public boolean inEditMode;
-
-    public Project(String name, String filePath, long timestamp, String codeUrl, boolean runStatus) {
-        this.name = name;
-        this.filePath = filePath;
-        this.timestamp = timestamp;
-        this.codeUrl = codeUrl;
-        this.runStatus = runStatus;
-        this.actionBarExpanded = false;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if(o == null || !(o instanceof Project)) {
-            return false;
-        }
-
-        Project comparedProject = (Project) o;
-
-        return comparedProject.timestamp == timestamp && (comparedProject.filePath != null && filePath != null
-                && comparedProject.filePath.equals(filePath));
-    }
-}
diff --git a/app/src/main/java/cc/calliope/mini/datamodel/ui/BaseActivityState.java b/app/src/main/java/cc/calliope/mini/datamodel/ui/BaseActivityState.java
deleted file mode 100644
index e8a4480..0000000
--- a/app/src/main/java/cc/calliope/mini/datamodel/ui/BaseActivityState.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package cc.calliope.mini.data.model.ui;
-
-/**
- * Base activity states. Used for make handling of connect process
- * automatized.
- *
- * @see com.samsung.microbit.utils.BLEConnectionHandler
- */
-public class BaseActivityState {
-    protected BaseActivityState() {
-    }
-
-    public static final int STATE_IDLE = 1;
-    public static final int STATE_ENABLE_BT_FOR_CONNECT = 2;
-    public static final int STATE_CONNECTING = 3;
-    public static final int STATE_DISCONNECTING = 4;
-}
diff --git a/app/src/main/java/cc/calliope/mini/datamodel/ui/FlashActivityState.java b/app/src/main/java/cc/calliope/mini/datamodel/ui/FlashActivityState.java
deleted file mode 100644
index 8e87a4e..0000000
--- a/app/src/main/java/cc/calliope/mini/datamodel/ui/FlashActivityState.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package cc.calliope.mini.data.model.ui;
-
-/**
- * Activity states of flashing process.
- */
-public class FlashActivityState extends cc.calliope.mini.data.model.ui.BaseActivityState {
-    public static final int STATE_ENABLE_BT_INTERNAL_FLASH_REQUEST = 5;
-    public static final int STATE_ENABLE_BT_EXTERNAL_FLASH_REQUEST = 6;
-    public static final int FLASH_STATE_FIND_DEVICE = 7;
-    public static final int FLASH_STATE_VERIFY_DEVICE = 8;
-    public static final int FLASH_STATE_WAIT_DEVICE_REBOOT = 9;
-    public static final int FLASH_STATE_INIT_DEVICE = 10;
-    public static final int FLASH_STATE_PROGRESS = 11;
-}
diff --git a/app/src/main/java/cc/calliope/mini/datamodel/ui/PairingActivityState.java b/app/src/main/java/cc/calliope/mini/datamodel/ui/PairingActivityState.java
deleted file mode 100644
index b823b46..0000000
--- a/app/src/main/java/cc/calliope/mini/datamodel/ui/PairingActivityState.java
+++ /dev/null
@@ -1,8 +0,0 @@
-package cc.calliope.mini.data.model.ui;
-
-/**
- * Pairing activity states. Used for pair with device.
- */
-public class PairingActivityState extends cc.calliope.mini.data.model.ui.BaseActivityState {
-    public static final int STATE_ENABLE_BT_FOR_PAIRING = 5;
-}
diff --git a/app/src/main/java/cc/calliope/mini/dialog/CustomLinkDialogPreference.java b/app/src/main/java/cc/calliope/mini/dialog/CustomLinkDialogPreference.java
new file mode 100644
index 0000000..8a0a012
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/dialog/CustomLinkDialogPreference.java
@@ -0,0 +1,27 @@
+package cc.calliope.mini.dialog;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import androidx.preference.DialogPreference;
+import cc.calliope.mini.fragment.editors.Editor;
+import cc.calliope.mini.utils.Preference;
+
+import static cc.calliope.mini.utils.Preference.PREF_KEY_CUSTOM_LINK;
+
+public class CustomLinkDialogPreference extends DialogPreference {
+    public CustomLinkDialogPreference(Context context, AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    @Override
+    protected void onClick() {
+        String dialogTitle = getDialogTitle() == null ? "" : getDialogTitle().toString();
+        String link = Preference.getString(getContext(), PREF_KEY_CUSTOM_LINK, Editor.CUSTOM.getUrl());
+        DialogUtils.showEditDialog(getContext(), dialogTitle, link, output -> {
+                    if (shouldPersist()) {
+                        persistString(output);
+                    }
+                }
+        );
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/dialog/DialogUtils.java b/app/src/main/java/cc/calliope/mini/dialog/DialogUtils.java
new file mode 100644
index 0000000..4e5ca38
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/dialog/DialogUtils.java
@@ -0,0 +1,86 @@
+package cc.calliope.mini.dialog;
+
+import android.content.Context;
+import android.graphics.drawable.ColorDrawable;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.Window;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.TextView;
+
+import androidx.appcompat.app.AlertDialog;
+import cc.calliope.mini.R;
+
+public class DialogUtils {
+
+    public static void showEditDialog(Context context, String title, String input, OnEditDialogListener listener) {
+        View view = LayoutInflater.from(context).inflate(R.layout.dialog_edit, null);
+        AlertDialog.Builder builder = new AlertDialog.Builder(context);
+        builder.setView(view);
+
+        TextView dialogTitle = view.findViewById(R.id.dialog_title);
+        EditText dialogInput = view.findViewById(R.id.dialog_input);
+        Button dialogOkButton = view.findViewById(R.id.dialog_ok);
+        Button dialogCancelButton = view.findViewById(R.id.dialog_cancel);
+
+        dialogTitle.setText(title);
+        dialogInput.setText(input);
+
+        AlertDialog alertDialog = builder.create();
+        Window window = alertDialog.getWindow();
+        if (window != null) {
+            window.setBackgroundDrawable(new ColorDrawable(0));
+        }
+
+        dialogOkButton.setOnClickListener(v -> {
+            String inputText = dialogInput.getText().toString();
+            if (listener != null) {
+                listener.onOkButtonClicked(inputText);
+            }
+            alertDialog.dismiss();
+        });
+
+        dialogCancelButton.setOnClickListener(v -> alertDialog.dismiss());
+        alertDialog.show();
+    }
+
+    public static void showWarningDialog(Context context, String title, String message, OnWarningDialogListener listener) {
+        AlertDialog.Builder builder = new AlertDialog.Builder(context);
+        View view = LayoutInflater.from(context).inflate(R.layout.dialog_warning, null);
+        builder.setView(view);
+
+        TextView dialogTitle = view.findViewById(R.id.dialog_title);
+        TextView dialogMessage = view.findViewById(R.id.dialog_message);
+        Button dialogOkButton = view.findViewById(R.id.dialog_ok);
+        Button dialogCancelButton = view.findViewById(R.id.dialog_cancel);
+
+        dialogTitle.setText(title);
+        dialogMessage.setText(message);
+
+        AlertDialog alertDialog = builder.create();
+        Window window = alertDialog.getWindow();
+        if (window != null) {
+            window.setBackgroundDrawable(new ColorDrawable(0));
+        }
+
+        dialogOkButton.setOnClickListener(v -> {
+            if (listener != null) {
+                listener.onOkButtonClicked();
+            }
+            alertDialog.dismiss();
+        });
+
+        dialogCancelButton.setOnClickListener(v -> alertDialog.dismiss());
+
+        alertDialog.show();
+    }
+
+    public interface OnEditDialogListener {
+        void onOkButtonClicked(String output);
+    }
+
+    public interface OnWarningDialogListener {
+        void onOkButtonClicked();
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/dialog/pattern/PatternDialogFragment.java b/app/src/main/java/cc/calliope/mini/dialog/pattern/PatternDialogFragment.java
new file mode 100644
index 0000000..eb22185
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/dialog/pattern/PatternDialogFragment.java
@@ -0,0 +1,264 @@
+package cc.calliope.mini.dialog.pattern;
+
+import android.app.Activity;
+import android.app.Dialog;
+import android.content.DialogInterface;
+import android.graphics.drawable.ColorDrawable;
+import android.os.Bundle;
+import android.util.DisplayMetrics;
+import android.util.Log;
+import android.view.Gravity;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewTreeObserver;
+import android.view.Window;
+import android.view.WindowManager;
+import android.widget.RatingBar;
+
+import java.util.Arrays;
+import java.util.List;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.fragment.app.DialogFragment;
+import androidx.lifecycle.ViewModelProvider;
+
+import cc.calliope.mini.views.FobParams;
+import cc.calliope.mini.R;
+import cc.calliope.mini.ExtendedBluetoothDevice;
+import cc.calliope.mini.databinding.DialogPatternBinding;
+import cc.calliope.mini.utils.Utils;
+import cc.calliope.mini.viewmodels.ScannerLiveData;
+import cc.calliope.mini.viewmodels.ScannerViewModel;
+import cc.calliope.mini.views.SvgPatternBar;
+
+//TODO -> Activity + viewModel
+public class PatternDialogFragment extends DialogFragment {
+    private final static int DIALOG_WIDTH = 220; //dp
+    private final static int DIALOG_HEIGHT = 240; //dp
+    private static final String FOB_PARAMS_PARCELABLE = "fob_params_parcelable";
+    private DialogPatternBinding binding;
+    private Float[] oldPattern = {0f, 0f, 0f, 0f, 0f};
+    private Float[] currentPattern = {0f, 0f, 0f, 0f, 0f};
+
+    private boolean connectClicked = false;
+
+    private ScannerViewModel scannerViewModel;
+//    private ExtendedBluetoothDevice currentDevice;
+
+    public PatternDialogFragment() {
+        // Empty constructor is required for DialogFragment
+        // Make sure not to add arguments to the constructor
+        // Use `newInstance` instead as shown below
+    }
+
+    public static PatternDialogFragment newInstance(FobParams params) {
+        PatternDialogFragment patternDialogFragment = new PatternDialogFragment();
+
+        Bundle args = new Bundle();
+        args.putParcelable(FOB_PARAMS_PARCELABLE, params);
+        patternDialogFragment.setArguments(args);
+
+        return patternDialogFragment;
+    }
+
+    @Override
+    public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container,
+                             Bundle savedInstanceState) {
+        binding = DialogPatternBinding.inflate(inflater, container, false);
+
+
+        // Create view model containing utility methods for scanning
+        scannerViewModel = new ViewModelProvider(requireActivity()).get(ScannerViewModel.class);
+        scannerViewModel.getScannerState().observe(getViewLifecycleOwner(), this::scanResults);
+
+        return binding.getRoot();
+    }
+
+    @Override
+    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
+        super.onViewCreated(view, savedInstanceState);
+
+        customizingDialog(view);
+
+        oldPattern = scannerViewModel.getScannerState().getCurrentPattern();
+        currentPattern = Arrays.copyOf(oldPattern, oldPattern.length);
+
+//        List<SvgPatternBar> pattern = List.of(
+//                binding.patternMatrix.columnA,
+//                binding.patternMatrix.columnB,
+//                binding.patternMatrix.columnC,
+//                binding.patternMatrix.columnD,
+//                binding.patternMatrix.columnE
+//        );
+//
+//        for (int i = 0; i < 5; i++) {
+//            pattern.get(i).setValue(currentPattern[i]);
+//        }
+
+//        binding.patternMatrix.columnA.setValue(currentPattern[0]);
+//        binding.patternMatrix.columnB.setValue(currentPattern[1]);
+//        binding.patternMatrix.columnC.setValue(currentPattern[2]);
+//        binding.patternMatrix.columnD.setValue(currentPattern[3]);
+//        binding.patternMatrix.columnE.setValue(currentPattern[4]);
+//
+//        binding.patternMatrix.columnA.setOnChangeListener((bar, v, b) -> onPatternChange(0, v));
+//        binding.patternMatrix.columnB.setOnChangeListener((bar, v, b) -> onPatternChange(1, v));
+//        binding.patternMatrix.columnC.setOnChangeListener((bar, v, b) -> onPatternChange(2, v));
+//        binding.patternMatrix.columnD.setOnChangeListener((bar, v, b) -> onPatternChange(3, v));
+//        binding.patternMatrix.columnE.setOnChangeListener((bar, v, b) -> onPatternChange(4, v));
+
+        binding.buttonAction.setOnClickListener(view1 -> onConnectClick());
+    }
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+        binding = null;
+    }
+
+    private void customizingDialog(View view) {
+        Dialog dialog = getDialog();
+        if (dialog != null) {
+            Window window = dialog.getWindow();
+            window.setBackgroundDrawable(new ColorDrawable(android.graphics.Color.TRANSPARENT));
+
+            Bundle bundle = getArguments();
+            if (bundle != null) {
+                FobParams fobParams = bundle.getParcelable(FOB_PARAMS_PARCELABLE);
+
+                // set "origin" to top left corner, so to speak
+                window.setGravity(Gravity.TOP | Gravity.START);
+                // after that, setting values for x and y works "naturally"
+                WindowManager.LayoutParams layoutParams = window.getAttributes();
+                layoutParams.x = getPosition(window, fobParams).getX();
+                layoutParams.y = getPosition(window, fobParams).getY();
+
+                window.setAttributes(layoutParams);
+            }
+
+            view.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
+                @Override
+                public void onGlobalLayout() {
+                    view.getViewTreeObserver().removeOnGlobalLayoutListener(this);
+                    Log.v("DIALOG", String.format("Window size: width %d; height %d", view.getWidth(), view.getHeight()));
+                }
+            });
+        }
+    }
+
+    @Override
+    public void onStop() {
+        super.onStop();
+//        scannerViewModel.stopScan();
+    }
+
+    @Override
+    public void onDismiss(@NonNull final DialogInterface dialog) {
+        super.onDismiss(dialog);
+//        if (scannerViewModel.getScannerState().getCurrentDevice() != null) {
+//            pairDevice(scannerViewModel.getScannerState().getCurrentDevice().getDevice());
+//        }
+        if (!connectClicked) {
+            scannerViewModel.setCurrentPattern(oldPattern);
+        } else {
+            scannerViewModel.createBond();
+        }
+
+        final Activity activity = getActivity();
+        if (activity instanceof DialogInterface.OnDismissListener) {
+            ((DialogInterface.OnDismissListener) activity).onDismiss(dialog);
+        }
+    }
+
+    public void onPatternChange(int column, float value){
+        Utils.log(Log.ASSERT, "BAR_MAIN", "Column " + column + ": " + value);
+        currentPattern[column] = value;
+//        scannerViewModel.setCurrentPattern(currentPattern);
+    }
+
+    private void setButtonBackground(ExtendedBluetoothDevice device) {
+//        Log.i("DIALOG: ", "currentDevice: " + device);
+        if (device != null && device.isRelevant()) {
+            binding.buttonAction.setBackgroundResource(R.drawable.btn_connect_green);
+        } else {
+            binding.buttonAction.setBackgroundResource(R.drawable.btn_connect_aqua);
+        }
+    }
+
+    // Call this method to send the data back to the parent fragment
+    public void onConnectClick() {
+        connectClicked = true;
+        dismiss();
+    }
+
+    private void scanResults(final ScannerLiveData state) {
+        // Bluetooth must be enabled
+        if (state.isBluetoothEnabled()) {
+//            scannerViewModel.startScan();
+            setButtonBackground(state.getCurrentDevice());
+        } else {
+            setButtonBackground(null);
+        }
+    }
+
+//    public void savePattern() {
+//        SharedPreferences.Editor edit = PreferenceManager.getDefaultSharedPreferences(getActivity()).edit();
+//        for (int i = 0; i < 5; i++) {
+//            edit.putFloat("PATTERN_" + i, currentPattern.get(i));
+//        }
+//        edit.apply();
+//    }
+//
+//    public void loadPattern() {
+//        SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(getActivity());
+//        for (int i = 0; i < 5; i++) {
+//            currentPattern.set(i, preferences.getFloat("PATTERN_" + i, 0f));
+//        }
+//    }
+
+    private Position getPosition(Window window, FobParams fobParams) {
+        Activity activity = getActivity();
+        if (activity != null) {
+            DisplayMetrics displayMetrics = new DisplayMetrics();
+            window.getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);
+
+            int halfWidth = displayMetrics.widthPixels / 2;
+            int halfHeight = displayMetrics.heightPixels / 2;
+            int fobX = fobParams.getCenterX();
+            int fobY = fobParams.getCenterY();
+            int dialogWidth = Utils.convertDpToPixel(getActivity(), DIALOG_WIDTH);
+            int dialogHeight = Utils.convertDpToPixel(getActivity(), DIALOG_HEIGHT);
+
+            if (fobX <= halfWidth && fobY <= halfHeight) {
+                return new Position(fobX, fobY);
+            } else if (fobX > halfWidth && fobY <= halfHeight) {
+                return new Position(fobX - dialogWidth, fobY);
+            } else if (fobX <= halfWidth) {
+                return new Position(fobX, fobY - dialogHeight);
+            } else {
+                return new Position(fobX - dialogWidth, fobY - dialogHeight);
+            }
+        }
+        return new Position(0, 0);
+    }
+
+    private static class Position {
+        private final int x;
+        private final int y;
+
+        public Position(int x, int y) {
+            this.x = x;
+            this.y = y;
+        }
+
+        public int getX() {
+            return x;
+        }
+
+        public int getY() {
+            return y;
+        }
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/dialog/pattern/PatternEnum.java b/app/src/main/java/cc/calliope/mini/dialog/pattern/PatternEnum.java
new file mode 100644
index 0000000..bdf20d0
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/dialog/pattern/PatternEnum.java
@@ -0,0 +1,32 @@
+package cc.calliope.mini.dialog.pattern;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+public enum PatternEnum {
+        XX(0f),
+        ZU(1f),
+        VO(2f),
+        GI(3f),
+        PE(4f),
+        TA(5f);
+
+        private final float code;
+
+        PatternEnum(final float code) {
+            this.code = code;
+        }
+
+        private static final Map<Float, PatternEnum> BY_CODE_MAP = new LinkedHashMap<>();
+
+        static {
+            for (PatternEnum pattern : PatternEnum.values()) {
+                BY_CODE_MAP.put(pattern.code, pattern);
+            }
+        }
+
+        public static PatternEnum forCode(float code) {
+            return BY_CODE_MAP.get(code);
+        }
+
+    }
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/dialog/scripts/ScriptsFragment.java b/app/src/main/java/cc/calliope/mini/dialog/scripts/ScriptsFragment.java
new file mode 100644
index 0000000..017c1ca
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/dialog/scripts/ScriptsFragment.java
@@ -0,0 +1,347 @@
+package cc.calliope.mini.dialog.scripts;
+
+import android.app.Dialog;
+import android.content.Context;
+import android.content.Intent;
+import android.hardware.usb.UsbDevice;
+import android.hardware.usb.UsbManager;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.ParcelFileDescriptor;
+import android.os.storage.StorageManager;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.FrameLayout;
+import android.widget.TextView;
+
+import com.google.android.material.bottomsheet.BottomSheetBehavior;
+import com.google.android.material.bottomsheet.BottomSheetDialog;
+import com.google.android.material.bottomsheet.BottomSheetDialogFragment;
+
+import org.apache.commons.io.FilenameUtils;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.nio.channels.FileChannel;
+import java.util.ArrayList;
+import java.util.HashMap;
+
+import androidx.activity.result.ActivityResultLauncher;
+import androidx.activity.result.contract.ActivityResultContracts;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RequiresApi;
+import androidx.appcompat.widget.PopupMenu;
+import androidx.core.content.FileProvider;
+import androidx.documentfile.provider.DocumentFile;
+import androidx.fragment.app.FragmentActivity;
+import androidx.lifecycle.ViewModelProvider;
+import androidx.recyclerview.widget.DefaultItemAnimator;
+import androidx.recyclerview.widget.LinearLayoutManager;
+import androidx.recyclerview.widget.RecyclerView;
+import cc.calliope.mini.activity.FlashingActivity;
+import cc.calliope.mini.FileWrapper;
+import cc.calliope.mini.R;
+import cc.calliope.mini.dialog.DialogUtils;
+import cc.calliope.mini.utils.StaticExtra;
+import cc.calliope.mini.ExtendedBluetoothDevice;
+import cc.calliope.mini.databinding.FragmentScriptsBinding;
+import cc.calliope.mini.fragment.editors.Editor;
+import cc.calliope.mini.utils.Utils;
+import cc.calliope.mini.utils.Version;
+import cc.calliope.mini.viewmodels.ScannerViewModel;
+import cc.calliope.mini.views.SimpleDividerItemDecoration;
+
+import static android.app.Activity.RESULT_OK;
+
+
+public class ScriptsFragment extends BottomSheetDialogFragment {
+    private static final String TAG = "ScriptsFragment";
+    private static final String FILE_EXTENSION = ".hex";
+    private FragmentScriptsBinding binding;
+    private FragmentActivity activity;
+    private ScriptsRecyclerAdapter scriptsRecyclerAdapter;
+    private ExtendedBluetoothDevice device;
+    private FrameLayout bottomSheet;
+    private int state = BottomSheetBehavior.STATE_COLLAPSED;
+    private String sourceFilePath;
+
+    private final BottomSheetBehavior.BottomSheetCallback bottomSheetCallback =
+            new BottomSheetBehavior.BottomSheetCallback() {
+                @Override
+                public void onStateChanged(@NonNull View bottomSheet, int newState) {
+                    state = newState;
+                }
+
+                @Override
+                public void onSlide(@NonNull View bottomSheet, float slideOffset) {
+                }
+            };
+
+    @NonNull
+    @Override
+    public Dialog onCreateDialog(Bundle savedInstanceState) {
+        BottomSheetDialog dialog = (BottomSheetDialog) super.onCreateDialog(savedInstanceState);
+        dialog.setOnShowListener(dialogInterface -> {
+            BottomSheetDialog d = (BottomSheetDialog) dialogInterface;
+            bottomSheet = d.findViewById(com.google.android.material.R.id.design_bottom_sheet);
+            if (bottomSheet != null) {
+                BottomSheetBehavior.from(bottomSheet).addBottomSheetCallback(bottomSheetCallback);
+                bottomSheet.setBackgroundColor(android.graphics.Color.TRANSPARENT);
+            }
+        });
+        return dialog;
+    }
+
+    @Override
+    public View onCreateView(@NonNull LayoutInflater inflater,
+                             ViewGroup container, Bundle savedInstanceState) {
+        binding = FragmentScriptsBinding.inflate(inflater, container, false);
+        activity = requireActivity();
+
+        ScannerViewModel scannerViewModel = new ViewModelProvider(activity).get(ScannerViewModel.class);
+        scannerViewModel.getScannerState().observe(getViewLifecycleOwner(), result -> device = result.getCurrentDevice());
+
+        return binding.getRoot();
+    }
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+        BottomSheetBehavior.from(bottomSheet).removeBottomSheetCallback(bottomSheetCallback);
+        binding = null;
+    }
+
+    @Override
+    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
+        ArrayList<FileWrapper> filesList = new ArrayList<>();
+        for (Editor editor : Editor.values()) {
+            filesList.addAll(getFiles(editor));
+        }
+        TextView infoTextView = binding.infoTextView;
+        RecyclerView recyclerView = binding.scriptsRecyclerView;
+
+        if (filesList.isEmpty()) {
+            infoTextView.setVisibility(View.VISIBLE);
+            recyclerView.setVisibility(View.INVISIBLE);
+        } else {
+            infoTextView.setVisibility(View.INVISIBLE);
+            recyclerView.setVisibility(View.VISIBLE);
+            recyclerView.setItemAnimator(new DefaultItemAnimator());
+            recyclerView.setLayoutManager(new LinearLayoutManager(getContext()));
+            scriptsRecyclerAdapter = new ScriptsRecyclerAdapter(filesList);
+            scriptsRecyclerAdapter.setOnItemClickListener(this::openDfuActivity);
+            scriptsRecyclerAdapter.setOnItemLongClickListener(this::openPopupMenu);
+            recyclerView.setAdapter(scriptsRecyclerAdapter);
+            recyclerView.addItemDecoration(new SimpleDividerItemDecoration(activity));
+        }
+    }
+
+    private ArrayList<FileWrapper> getFiles(Editor editor) {
+        File[] filesArray = new File(activity.getFilesDir().toString() + File.separator + editor).listFiles();
+
+        ArrayList<FileWrapper> filesList = new ArrayList<>();
+
+        if (filesArray != null) {
+            for (File file : filesArray) {
+                String name = file.getName();
+                if (name.contains(FILE_EXTENSION)) {
+                    filesList.add(new FileWrapper(file, editor));
+                }
+            }
+        }
+        return filesList;
+    }
+
+    private void openDfuActivity(FileWrapper file) {
+        if (device != null && device.isRelevant()) {
+            final Intent intent = new Intent(activity, FlashingActivity.class);
+            intent.putExtra(StaticExtra.EXTRA_DEVICE, device);
+            intent.putExtra(StaticExtra.EXTRA_FILE_PATH, file.getAbsolutePath());
+            startActivity(intent);
+        } else {
+            if (state == BottomSheetBehavior.STATE_EXPANDED) {
+                BottomSheetBehavior<View> bottomSheetBehavior = BottomSheetBehavior.from(bottomSheet);
+                bottomSheetBehavior.setState(BottomSheetBehavior.STATE_COLLAPSED);
+            }
+            Utils.errorSnackbar(binding.getRoot(), getString(R.string.error_snackbar_no_connected)).show();
+
+        }
+    }
+
+    private void openPopupMenu(View view, FileWrapper file) {
+        PopupMenu popup = new PopupMenu(view.getContext(), view);
+        popup.setOnMenuItemClickListener(item -> {
+            //Non-constant Fields
+            int id = item.getItemId();
+            if (id == R.id.copy) {
+                copyFile(file);
+                return true;
+            } else if (id == R.id.share) {
+                shareFile(file);
+                return true;
+            } else if (id == R.id.rename) {
+                renameFile(file);
+                return true;
+            } else if (id == R.id.remove) {
+                removeFile(file);
+                return true;
+            }
+            return false;
+
+        });
+        popup.inflate(R.menu.scripts_popup_menu);
+        popup.show();
+    }
+
+    private void renameFile(FileWrapper file) {
+        String title = getResources().getString(R.string.title_dialog_rename);
+        String input = FilenameUtils.removeExtension(file.getName());
+
+        DialogUtils.showEditDialog(activity, title, input, output -> {
+            File dir = new File(FilenameUtils.getFullPath(file.getAbsolutePath()));
+            if (dir.exists()) {
+                FileWrapper dest = new FileWrapper(new File(dir, output + FILE_EXTENSION), file.getEditor());
+                if (file.exists()) {
+                    if (!dest.exists() && file.renameTo(dest.getFile())) {
+                        scriptsRecyclerAdapter.change(file, dest);
+                    } else {
+                        Utils.errorSnackbar(binding.getRoot(), getString(R.string.error_snackbar_name_exists)).show();
+                    }
+                }
+            }
+        });
+    }
+
+    private void removeFile(FileWrapper file) {
+        String title = getResources().getString(R.string.title_dialog_rename);
+        String message = String.format(getString(R.string.info_dialog_delete), FilenameUtils.removeExtension(file.getName()));
+
+        DialogUtils.showWarningDialog(activity, title, message, () -> {
+            if (file.delete()) {
+                scriptsRecyclerAdapter.remove(file);
+            }
+        });
+    }
+
+    private void shareFile(FileWrapper file) {
+        if (file.exists()) {
+            Uri uri = FileProvider.getUriForFile(activity, "cc.calliope.file_provider", file.getFile());
+            Intent intent = new Intent(Intent.ACTION_SEND);
+
+            intent.setType("text/plain");
+            intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
+            intent.putExtra(Intent.EXTRA_STREAM, uri);
+            intent.putExtra(Intent.EXTRA_SUBJECT, getString(R.string.subject_dialog_share));
+            intent.putExtra(Intent.EXTRA_TEXT, getString(R.string.text_dialog_share));
+
+            startActivity(Intent.createChooser(intent, getString(R.string.title_dialog_share)));
+        }
+    }
+
+    public void copyFile(FileWrapper file){
+        //TODO if(...)
+        boolean connected = isMiniConnected();
+        Utils.log(TAG, "Mini connected: " + connected);
+
+        sourceFilePath = file.getAbsolutePath();
+
+        if (Version.VERSION_Q_AND_NEWER) {
+            openDocumentTreeNewApi();
+        }else {
+            openDocumentTree();
+        }
+    }
+
+    @RequiresApi(api = Build.VERSION_CODES.Q)
+    private void openDocumentTreeNewApi() {
+        StorageManager storageManager = (StorageManager) activity.getSystemService(Context.STORAGE_SERVICE);
+        Intent intent = storageManager.getPrimaryStorageVolume().createOpenDocumentTreeIntent();
+
+        String targetDirectory = "MINI"; // add your directory to be selected by the user
+        Uri uri = intent.getParcelableExtra("android.provider.extra.INITIAL_URI");
+        String scheme = uri.toString();
+        scheme = scheme.replace("/root/", "/document/");
+        scheme += "%3A" + targetDirectory;
+        uri = Uri.parse(scheme);
+        intent.putExtra("android.provider.extra.INITIAL_URI", uri);
+        treeUriResultLauncher.launch(intent);
+    }
+
+    private void openDocumentTree(){
+        Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT_TREE);
+        treeUriResultLauncher.launch(intent);
+    }
+
+    ActivityResultLauncher<Intent> treeUriResultLauncher = registerForActivityResult(
+            new ActivityResultContracts.StartActivityForResult(), result -> {
+                Utils.log(TAG, "getResultCode: " + result.getResultCode());
+                Utils.log(TAG, "getData: " + result.getData());
+                int resultCode = result.getResultCode();
+                Intent data = result.getData();
+
+                if (resultCode == RESULT_OK) {
+                    if (data != null) {
+                        Uri treeUri = data.getData();
+
+                        // treeUri is the Uri of the file
+                        // If lifelong access is required, use takePersistableUriPermission()
+                        activity.getContentResolver().takePersistableUriPermission(
+                                treeUri,
+                                Intent.FLAG_GRANT_READ_URI_PERMISSION |
+                                        Intent.FLAG_GRANT_WRITE_URI_PERMISSION
+                        );
+                        Utils.log(TAG, "treeUri: " + treeUri);
+                        writeFile(treeUri);
+                    }
+                }
+            }
+    );
+
+    public void writeFile(Uri uri) {
+        try {
+            DocumentFile directory = DocumentFile.fromTreeUri(activity, uri);
+            DocumentFile file = directory.createFile("application/octet-stream", "firmware.hex");
+
+            FileInputStream inputStream = new FileInputStream(sourceFilePath);
+
+            ParcelFileDescriptor parcelFileDescriptor = activity.getContentResolver().openFileDescriptor(file.getUri(), "w");
+            FileOutputStream outputStream = new FileOutputStream(parcelFileDescriptor.getFileDescriptor());
+
+            FileChannel sourceChannel = inputStream.getChannel();
+            FileChannel destinationChannel = outputStream.getChannel();
+
+            destinationChannel.transferFrom(sourceChannel, 0, sourceChannel.size());
+
+            sourceChannel.close();
+            destinationChannel.close();
+            inputStream.close();
+            outputStream.close();
+        } catch (IOException e) {
+            Utils.log(Log.ERROR, TAG, "IOException: " + e.getMessage());
+        }
+    }
+
+    private boolean isMiniConnected(){
+        UsbManager manager = (UsbManager) activity.getSystemService(Context.USB_SERVICE);
+        HashMap<String, UsbDevice> deviceList = manager.getDeviceList();
+        for (UsbDevice device : deviceList.values()) {
+            Utils.log(Log.DEBUG, "USB_Device", "Device Name: " + device.getDeviceName());
+            Utils.log(Log.DEBUG, "USB_Device", "Product Name: " + device.getProductName());
+            Utils.log(Log.DEBUG, "USB_Device", "Manufacturer Name: " + device.getManufacturerName());
+            Utils.log(Log.DEBUG, "USB_Device", "Device Protocol: " + device.getDeviceProtocol());
+
+            String productName = device.getProductName();
+            if(productName != null && productName.contains("Calliope")) {
+                Utils.log(Log.ASSERT, TAG, "it`s Calliope");
+                return true;
+            }
+        }
+        return false;
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/dialog/scripts/ScriptsRecyclerAdapter.java b/app/src/main/java/cc/calliope/mini/dialog/scripts/ScriptsRecyclerAdapter.java
new file mode 100644
index 0000000..e4bf7a0
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/dialog/scripts/ScriptsRecyclerAdapter.java
@@ -0,0 +1,134 @@
+package cc.calliope.mini.dialog.scripts;
+
+import android.os.Build;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import org.apache.commons.io.FilenameUtils;
+
+import java.util.ArrayList;
+import java.util.Comparator;
+
+import androidx.annotation.NonNull;
+import androidx.recyclerview.widget.RecyclerView;
+import cc.calliope.mini.FileWrapper;
+import cc.calliope.mini.R;
+import cc.calliope.mini.utils.Utils;
+
+public class ScriptsRecyclerAdapter extends RecyclerView.Adapter<ScriptsRecyclerAdapter.ViewHolder> {
+    private final ArrayList<FileWrapper> files;
+    private OnItemClickListener onItemClickListener;
+    private OnItemLongClickListener onItemLongClickListener;
+
+    public interface OnItemClickListener {
+        void onItemClick(FileWrapper file);
+    }
+
+    public interface OnItemLongClickListener {
+        void onItemLongClick(View view, FileWrapper file);
+    }
+
+    public ScriptsRecyclerAdapter(ArrayList<FileWrapper> files) {
+        this.files = files;
+        sort();
+    }
+
+    public void setOnItemClickListener(OnItemClickListener listener) {
+        this.onItemClickListener = listener;
+    }
+
+    public void setOnItemLongClickListener(OnItemLongClickListener listener) {
+        this.onItemLongClickListener = listener;
+    }
+
+    @NonNull
+    @Override
+    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
+        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.scripts_item, parent, false);
+        return new ViewHolder(view);
+    }
+
+    @Override
+    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
+        if (files == null)
+            return;
+
+        FileWrapper file = files.get(position);
+        holder.setItem(file);
+        if (onItemClickListener != null) {
+            holder.itemView.setOnClickListener(view -> onItemClickListener.onItemClick(file));
+        }
+
+        if(onItemLongClickListener != null){
+            holder.itemView.setOnLongClickListener(view -> {
+                onItemLongClickListener.onItemLongClick(view, file);
+                return false;
+            });
+        }
+    }
+
+    public boolean isEmpty(){
+        return files.isEmpty();
+    }
+
+    public void remove(FileWrapper file) {
+        int index = files.indexOf(file);
+        if(files.remove(file)) {
+            notifyItemRemoved(index);
+        }
+    }
+
+    public void change(FileWrapper oldFile, FileWrapper newFile){
+        int index = files.indexOf(oldFile);
+        if(files.remove(oldFile)) {
+            files.add(index, newFile);
+            notifyItemChanged(index);
+            sort();
+        }
+    }
+
+    public void sort(){
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
+            files.sort(new CustomComparator());
+        }
+    }
+
+    static class CustomComparator implements Comparator<FileWrapper> {
+        @Override
+        public int compare(FileWrapper file1, FileWrapper file2) {
+            return Long.compare(file2.lastModified(), file1.lastModified());
+        }
+    }
+
+    @Override
+    public int getItemCount() {
+        if (files == null) {
+            return 0;
+        } else {
+            return files.size();
+        }
+    }
+
+    static class ViewHolder extends RecyclerView.ViewHolder{
+        private final TextView name;
+        private final TextView date;
+        private final ImageView icon;
+
+        private ViewHolder(View view) {
+            super(view);
+
+            name = view.findViewById(R.id.hex_file_name_text_view);
+            date = view.findViewById(R.id.hex_file_date_text_view);
+            icon = view.findViewById(R.id.hex_file_icon);
+        }
+
+        void setItem(FileWrapper file) {
+            this.name.setText(FilenameUtils.removeExtension(file.getName()));
+            this.date.setText(Utils.dateFormat(file.lastModified()));
+            this.icon.setImageResource(file.getEditor().getIconResId());
+        }
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/editorAcitvity.java b/app/src/main/java/cc/calliope/mini/editorAcitvity.java
deleted file mode 100644
index 370598c..0000000
--- a/app/src/main/java/cc/calliope/mini/editorAcitvity.java
+++ /dev/null
@@ -1,219 +0,0 @@
-package cc.calliope.mini;
-
-
-import android.content.Intent;
-import android.net.Uri;
-import android.os.StrictMode;
-import android.support.v7.app.AppCompatActivity;
-import android.os.Bundle;
-import android.util.Base64;
-import android.util.Log;
-import android.webkit.DownloadListener;
-import android.webkit.URLUtil;
-import android.webkit.WebChromeClient;
-import android.webkit.WebView;
-import android.webkit.WebViewClient;
-import android.widget.TextView;
-import android.widget.Toast;
-import java.io.BufferedInputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.OutputStreamWriter;
-import java.io.Writer;
-import java.net.URL;
-import java.net.URLConnection;
-import java.net.URLDecoder;
-
-import cc.calliope.mini.adapter.ExtendedBluetoothDevice;
-
-public class editorAcitvity extends AppCompatActivity {
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        int SDK_INT = android.os.Build.VERSION.SDK_INT;
-        if (SDK_INT > 8) {
-            StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder()
-                    .permitAll().build();
-            StrictMode.setThreadPolicy(policy);
-        }
-
-        super.onCreate(savedInstanceState);
-        // setContentView(R.layout.activity_editor_acitvity);
-        WebView webview = new WebView(this);
-        setContentView(webview);
-
-        final Intent intent = getIntent();
-        final ExtendedBluetoothDevice device = intent.getParcelableExtra("cc.calliope.mini.EXTRA_DEVICE");
-        if (device != null) {
-            final String deviceName = device.getName();
-            final String deviceAddress = device.getAddress();
-            Log.i("DEVICE", deviceName);
-            final TextView deviceInfo = findViewById(R.id.deviceInfo);
-        }
-        Bundle extras = intent.getExtras();
-        final String url = extras.getString("TARGET_URL");
-        final String editorName = extras.getString("TARGET_NAME");
-
-        webview.setWebChromeClient(new WebChromeClient());
-        webview.setWebViewClient(new WebViewClient());
-        webview.getSettings().setJavaScriptEnabled(true);
-
-        webview.getSettings().setJavaScriptEnabled(true);
-
-        webview.getSettings().setDomStorageEnabled(true);
-
-        webview.getSettings().setUseWideViewPort(true);
-        webview.getSettings().setLoadWithOverviewMode(true);
-        webview.getSettings().setDatabaseEnabled(true);
-
-        webview.setWebViewClient(new WebViewClient() {
-            @Override
-            public void onPageFinished(WebView view, String url) {
-                super.onPageFinished(webview, url);
-//                Toast.makeText(getApplicationContext(), "Done!", Toast.LENGTH_SHORT).show();
-//                webview.loadUrl("javascript:" +
-//                        "var x = 0; "+
-//                        "checkExist = setInterval(function() { " +
-//                        "if (++x === 100) { clearInterval(checkExist); }" +
-//                        "        var elements = document.querySelectorAll('[data-type=\"calliope2017\"]');" +
-//                        "        if (elements.length) { " +
-//                        "            var evObj = document.createEvent('Events');" +
-//                        "            evObj.initEvent('click', true, false);" +
-//                        "            elements[0].dispatchEvent(evObj);" +
-//                        "            elements[1].dispatchEvent(evObj);" +
-//                        "            elements[2].dispatchEvent(evObj);" +
-//                        "            elements[3].dispatchEvent(evObj);" +
-//                        "            clearInterval(checkExist);" +
-//                        "" +
-//                        "        }" +
-//                        "    }, 100);");
-            }
-
-            @Override
-            public void onReceivedError(WebView view, int errorCode, String description, String failingUrl) {
-                Toast.makeText(getApplicationContext(), "Oh no! " + description, Toast.LENGTH_SHORT).show();
-            }
-        });
-
-        webview.loadUrl(url);
-
-
-        webview.setDownloadListener(new DownloadListener() {
-            public void onDownloadStart(String url, String userAgent,
-                                        String contentDisposition, String mimetype,
-                                        long contentLength) {
-
-                Uri uri = Uri.parse(url);
-                Log.i("URL", url);
-                Log.i("URI", ""+uri);
-
-                //String filetype = url.substring(url.indexOf("/") + 1, url.indexOf(";"));
-                String filename = editorName+"-"+System.currentTimeMillis() + ".hex";
-                File file = new File(getFilesDir() + File.separator + filename);
-                if (file.exists())
-                    file.delete();
-                try {
-                    file.createNewFile();
-                }
-                catch (Exception e) {
-                    e.printStackTrace();
-                    Log.w("CreateFile", "Error writing " + file);
-                }
-
-                Boolean downloadResult = false;
-
-                if (url.startsWith("blob:")) {  // TODO: BLOB Download
-                    Log.i("MODUS", "BLOB");
-                    // Can not be parsed
-                } else if (url.startsWith("data:text/hex")) {  // when url is base64 encoded data
-                    Log.i("MODUS", "HEX");
-                    downloadResult = createAndSaveFileFromHexUrl(url, file);
-                } else if (url.startsWith("data:") && url.contains("base64")) {  // when url is base64 encoded data
-                    Log.i("MODUS", "BASE64");
-                    downloadResult = createAndSaveFileFromBase64Url(url, file);
-                } else if (URLUtil.isValidUrl(url)) { // real download
-                    Log.i("MODUS", "DOWNLOAD");
-                    downloadResult = downloadFileFromURL(url, file);
-                }
-
-                if(downloadResult && device != null) {
-                    final Intent intent = new Intent(editorAcitvity.this, DFUActivity.class);
-                    intent.putExtra("cc.calliope.mini.EXTRA_DEVICE", device);
-                    intent.putExtra("EXTRA_FILE", file.getAbsolutePath());
-                    startActivity(intent);
-                } else if(downloadResult) {
-                    Toast.makeText(getApplicationContext(), R.string.upload_no_mini_connected, Toast.LENGTH_LONG).show();
-                } else {
-                    Toast.makeText(getApplicationContext(), R.string.download_error, Toast.LENGTH_LONG).show();
-                }
-            }
-        });
-}
-
-
-    public Boolean createAndSaveFileFromBase64Url(String url, File file) {
-        try {
-            String base64EncodedString = url.substring(url.indexOf(",") + 1);
-            byte[] decodedBytes = Base64.decode(base64EncodedString, Base64.DEFAULT);
-            OutputStream os = new FileOutputStream(file);
-            os.write(decodedBytes);
-            os.close();
-        } catch (IOException e) {
-            e.printStackTrace();
-            return false;
-        }
-        Log.i("GESPEICHERT", file.toString());
-        return true;
-    }
-
-
-    public Boolean createAndSaveFileFromHexUrl(String url, File file) { // TODO not working yet
-        try {
-            String hexEncodedString = url.substring(url.indexOf(",") + 1);
-            String decodedHex = URLDecoder.decode(hexEncodedString, "utf-8");
-            OutputStream os = new FileOutputStream(file);
-            try (Writer w = new OutputStreamWriter(os, "UTF-8")) {
-                w.write(decodedHex);
-            } catch (IOException e) {
-                e.printStackTrace();
-                return false;
-            }
-        } catch (IOException e) {
-            e.printStackTrace();
-            return false;
-        }
-        Log.i("GESPEICHERT", file.toString());
-        return true;
-    }
-
-
-    public Boolean downloadFileFromURL(final String link, File file) {
-        try {
-            URL url = new URL(link);
-            URLConnection ucon = url.openConnection();
-            ucon.setReadTimeout(5000);
-            ucon.setConnectTimeout(10000);
-
-            InputStream is = ucon.getInputStream();
-            BufferedInputStream inStream = new BufferedInputStream(is, 1024 * 5);
-            FileOutputStream outStream = new FileOutputStream(file);
-            byte[] buff = new byte[5 * 1024];
-            int len;
-            while ((len = inStream.read(buff)) != -1) {
-                outStream.write(buff, 0, len);
-            }
-            outStream.flush();
-            outStream.close();
-            inStream.close();
-        }
-        catch (Exception e) {
-            e.printStackTrace();
-            return false;
-        }
-        return true;
-    }
-
-}
diff --git a/app/src/main/java/cc/calliope/mini/fragment/ZoomOutPageTransformer.java b/app/src/main/java/cc/calliope/mini/fragment/ZoomOutPageTransformer.java
new file mode 100644
index 0000000..3692f03
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/fragment/ZoomOutPageTransformer.java
@@ -0,0 +1,44 @@
+package cc.calliope.mini.fragment;
+
+import android.view.View;
+
+import androidx.viewpager2.widget.ViewPager2;
+
+public class ZoomOutPageTransformer implements ViewPager2.PageTransformer {
+    private static final float MIN_SCALE = 0.85f;
+    private static final float MIN_ALPHA = 0.5f;
+
+    public void transformPage(View view, float position) {
+        int pageWidth = view.getWidth();
+        int pageHeight = view.getHeight();
+
+        if (position < -1) { // [-Infinity,-1)
+            // This page is way off-screen to the left.
+            view.setAlpha(0f);
+
+        } else if (position <= 1) { // [-1,1]
+            // Modify the default slide transition to shrink the page as well
+            float scaleFactor = Math.max(MIN_SCALE, 1 - Math.abs(position));
+            float vertMargin = pageHeight * (1 - scaleFactor) / 2;
+            float horzMargin = pageWidth * (1 - scaleFactor) / 2;
+            if (position < 0) {
+                view.setTranslationX(horzMargin - vertMargin / 2);
+            } else {
+                view.setTranslationX(-horzMargin + vertMargin / 2);
+            }
+
+            // Scale the page down (between MIN_SCALE and 1)
+            view.setScaleX(scaleFactor);
+            view.setScaleY(scaleFactor);
+
+            // Fade the page relative to its size.
+            view.setAlpha(MIN_ALPHA +
+                    (scaleFactor - MIN_SCALE) /
+                            (1 - MIN_SCALE) * (1 - MIN_ALPHA));
+
+        } else { // (1,+Infinity]
+            // This page is way off-screen to the right.
+            view.setAlpha(0f);
+        }
+    }
+}
diff --git a/app/src/main/java/cc/calliope/mini/fragment/editors/Editor.java b/app/src/main/java/cc/calliope/mini/fragment/editors/Editor.java
new file mode 100644
index 0000000..0a939d7
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/fragment/editors/Editor.java
@@ -0,0 +1,55 @@
+package cc.calliope.mini.fragment.editors;
+
+import cc.calliope.mini.R;
+
+public enum Editor {
+
+    MAKECODE(
+            R.string.title_make_code,
+            R.drawable.ic_editors_makecode,
+            R.string.info_make_code,
+            "https://makecode.calliope.cc/?androidapp=1"),
+    ROBERTA(
+            R.string.title_roberta,
+            R.drawable.ic_editors_roberta,
+            R.string.info_roberta,
+            "https://lab.open-roberta.org/#loadSystem&&calliope2017"),
+    LIBRARY(
+            R.string.title_library,
+            R.drawable.ic_editors_library,
+            R.string.info_library,
+            "https://calliope.cc/calliope-mini/25programme#25"),
+    CUSTOM(
+            R.string.title_custom,
+            R.drawable.ic_editors_custom,
+            R.string.info_custom,
+            "https://makecode.microbit.org/?androidapp=1");
+
+    private final int titleResId;
+    private final int iconResId;
+    private final int infoResId;
+    private final String url;
+
+    Editor(int titleResId, int iconResId, int infoResId, String url) {
+        this.titleResId = titleResId;
+        this.iconResId = iconResId;
+        this.infoResId = infoResId;
+        this.url = url;
+    }
+
+    public int getTitleResId() {
+        return titleResId;
+    }
+
+    public int getIconResId() {
+        return iconResId;
+    }
+
+    public int getInfoResId() {
+        return infoResId;
+    }
+
+    public String getUrl() {
+        return url;
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/fragment/editors/EditorsAdapter.java b/app/src/main/java/cc/calliope/mini/fragment/editors/EditorsAdapter.java
new file mode 100644
index 0000000..5ba354d
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/fragment/editors/EditorsAdapter.java
@@ -0,0 +1,22 @@
+package cc.calliope.mini.fragment.editors;
+
+import androidx.annotation.NonNull;
+import androidx.fragment.app.Fragment;
+import androidx.viewpager2.adapter.FragmentStateAdapter;
+
+public class EditorsAdapter extends FragmentStateAdapter {
+    public EditorsAdapter(Fragment fragment) {
+        super(fragment);
+    }
+
+    @NonNull
+    @Override
+    public Fragment createFragment(int position) {
+        return EditorsItemFragment.newInstance(position);
+    }
+
+    @Override
+    public int getItemCount() {
+        return Editor.values().length;
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/fragment/editors/EditorsFragment.java b/app/src/main/java/cc/calliope/mini/fragment/editors/EditorsFragment.java
new file mode 100644
index 0000000..217c980
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/fragment/editors/EditorsFragment.java
@@ -0,0 +1,41 @@
+package cc.calliope.mini.fragment.editors;
+
+import android.os.Bundle;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.google.android.material.tabs.TabLayout;
+import com.google.android.material.tabs.TabLayoutMediator;
+
+import androidx.annotation.NonNull;
+import androidx.fragment.app.Fragment;
+import cc.calliope.mini.fragment.ZoomOutPageTransformer;
+import cc.calliope.mini.databinding.FragmentEditorsBinding;
+
+public class EditorsFragment extends Fragment{
+    private FragmentEditorsBinding binding;
+
+    public View onCreateView(@NonNull LayoutInflater inflater,
+                             ViewGroup container, Bundle savedInstanceState) {
+
+        binding = FragmentEditorsBinding.inflate(inflater, container, false);
+
+        EditorsAdapter adapter = new EditorsAdapter(this);
+
+        binding.editorViewpager.setAdapter(adapter);
+        binding.editorViewpager.setPageTransformer(new ZoomOutPageTransformer());
+
+        new TabLayoutMediator(binding.editorTabDots, binding.editorViewpager, (tab, position) ->
+                tab.setTabLabelVisibility(TabLayout.TAB_LABEL_VISIBILITY_UNLABELED))
+                .attach();
+
+        return binding.getRoot();
+    }
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+        binding = null;
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/fragment/editors/EditorsItemFragment.java b/app/src/main/java/cc/calliope/mini/fragment/editors/EditorsItemFragment.java
new file mode 100644
index 0000000..3c4dab1
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/fragment/editors/EditorsItemFragment.java
@@ -0,0 +1,120 @@
+package cc.calliope.mini.fragment.editors;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.animation.AlphaAnimation;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.fragment.app.Fragment;
+import androidx.navigation.NavController;
+import androidx.navigation.NavDirections;
+import androidx.navigation.Navigation;
+import cc.calliope.mini.R;
+import cc.calliope.mini.databinding.FragmentItemBinding;
+import cc.calliope.mini.utils.Preference;
+import cc.calliope.mini.utils.Utils;
+
+import static cc.calliope.mini.utils.Preference.PREF_KEY_CUSTOM_LINK;
+
+public class EditorsItemFragment extends Fragment {
+    private static final String ARG_POSITION = "arg_position";
+    private FragmentItemBinding binding;
+    private final AlphaAnimation buttonClick = new AlphaAnimation(1F, 0.75F);
+    private Editor editor;
+
+    public static EditorsItemFragment newInstance(int position) {
+        EditorsItemFragment fragment = new EditorsItemFragment();
+        Bundle args = new Bundle();
+        args.putInt(ARG_POSITION, position);
+        fragment.setArguments(args);
+
+        return fragment;
+    }
+
+    @Override
+    public View onCreateView(@NonNull LayoutInflater inflater,
+                             ViewGroup container, Bundle savedInstanceState) {
+        binding = FragmentItemBinding.inflate(inflater, container, false);
+        return binding.getRoot();
+    }
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+        binding = null;
+    }
+
+    @Override
+    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
+        Activity activity = getActivity();
+        Bundle args = getArguments();
+        if (args == null || activity == null)
+            return;
+
+        int position = args.getInt(ARG_POSITION);
+        editor = Editor.values()[position];
+
+
+        binding.titleTextView.setText(editor.getTitleResId());
+        binding.iconImageView.setImageResource(editor.getIconResId());
+        binding.infoTextView.setText(editor.getInfoResId());
+
+        binding.infoTextView.setOnClickListener(this::openEditor);
+        view.setOnClickListener(this::openEditor);
+    }
+
+    private void showWebFragment(String url, String editorName) {
+        Activity activity = getActivity();
+        if (activity == null){
+            return;
+        }
+
+        NavController navController = Navigation.findNavController(activity, R.id.navigation_host_fragment);
+        NavDirections webFragment = EditorsFragmentDirections.actionEditorsToWeb(url, editorName);
+        navController.navigate(webFragment);
+    }
+    private void networkSecurityConfig(String url){
+//        try {
+//            // Завантаження поточної конфігурації
+//            int resId = getResources().getIdentifier("network_security_config", "xml", getPackageName());
+//            NetworkSecurityConfig config = NetworkSecurityConfigProvider.getNetworkSecurityConfig(getApplicationContext());
+//
+//            // Додавання нового домену до виключень
+//            if (config != null) {
+//                Set<Domain> domains = new HashSet<>(config.getDefaultConfig().getPermittedDomains());
+//                domains.add(new Domain(domain));
+//                NetworkSecurityConfig.Builder builder = NetworkSecurityConfig.Builder.fromConfig(config);
+//                builder.addPermittedDomains(domains);
+//                NetworkSecurityConfig newConfig = builder.build();
+//
+//                // Встановлення нової конфігурації
+//                NetworkSecurityConfigProvider.setInstance(newConfig);
+//            }
+//        } catch (IOException e) {
+//            // Обробка помилки
+//            e.printStackTrace();
+//        }
+    }
+
+    private void openEditor(View view){
+        Activity activity = getActivity();
+        if (activity == null){
+            return;
+        }
+
+        view.startAnimation(buttonClick);
+        if (Utils.isNetworkConnected(activity)) {
+            String url = editor.getUrl();
+            if (editor == Editor.CUSTOM) {
+                url = Preference.getString(getContext(), PREF_KEY_CUSTOM_LINK, Editor.CUSTOM.getUrl());
+            }
+            showWebFragment(url, editor.toString());
+        } else {
+            Utils.errorSnackbar(binding.getRoot(), getString(R.string.error_snackbar_no_internet)).show();
+        }
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/fragment/help/HelpFragment.java b/app/src/main/java/cc/calliope/mini/fragment/help/HelpFragment.java
new file mode 100644
index 0000000..71c3476
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/fragment/help/HelpFragment.java
@@ -0,0 +1,50 @@
+package cc.calliope.mini.fragment.help;
+
+import android.content.Intent;
+import android.os.Bundle;
+import android.text.Html;
+import android.text.Spanned;
+import android.text.method.LinkMovementMethod;
+import android.view.LayoutInflater;
+import android.view.MenuItem;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.TextView;
+
+import androidx.annotation.NonNull;
+import androidx.appcompat.widget.Toolbar;
+import androidx.fragment.app.Fragment;
+import cc.calliope.mini.R;
+import cc.calliope.mini.activity.SettingsActivity;
+import cc.calliope.mini.databinding.FragmentHelpBinding;
+
+public class HelpFragment extends Fragment {
+    private FragmentHelpBinding binding;
+
+    public View onCreateView(@NonNull LayoutInflater inflater,
+                             ViewGroup container, Bundle savedInstanceState) {
+
+        binding = FragmentHelpBinding.inflate(inflater, container, false);
+
+        TextView appInfo = binding.appInfo;
+        appInfo.setMovementMethod(LinkMovementMethod.getInstance());
+        Spanned spanned = Html.fromHtml(getString(R.string.info_app));
+        appInfo.setText(spanned);
+
+        // Adding menu items programmatically
+        MenuItem shareMenuItem = binding.topAppBar.getMenu().add(R.string.title_settings);
+        shareMenuItem.setOnMenuItemClickListener(item -> {
+            Intent intent = new Intent(getContext(), SettingsActivity.class);
+            startActivity(intent);
+            return true;
+        });
+
+        return binding.getRoot();
+    }
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+        binding = null;
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/fragment/home/Home.java b/app/src/main/java/cc/calliope/mini/fragment/home/Home.java
new file mode 100644
index 0000000..b5cea82
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/fragment/home/Home.java
@@ -0,0 +1,41 @@
+package cc.calliope.mini.fragment.home;
+
+import cc.calliope.mini.R;
+
+public enum Home {
+
+    WELCOME(
+            R.string.title_welcome,
+            R.drawable.welcome,
+            R.string.info_welcome),
+    BATTERY(
+            R.string.title_battery,
+            R.drawable.anim_battery,
+            R.string.info_battery),
+    DEMO(
+            R.string.title_demo,
+            R.drawable.anim_demo,
+            R.string.info_demo);
+
+    private final int titleResId;
+    private final int iconResId;
+    private final int infoResId;
+
+    Home(int titleResId, int iconResId, int infoResId) {
+        this.titleResId = titleResId;
+        this.iconResId = iconResId;
+        this.infoResId = infoResId;
+    }
+
+    public int getTitleResId() {
+        return titleResId;
+    }
+
+    public int getIconResId() {
+        return iconResId;
+    }
+
+    public int getInfoResId() {
+        return infoResId;
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/fragment/home/HomeAdapter.java b/app/src/main/java/cc/calliope/mini/fragment/home/HomeAdapter.java
new file mode 100644
index 0000000..add5e07
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/fragment/home/HomeAdapter.java
@@ -0,0 +1,22 @@
+package cc.calliope.mini.fragment.home;
+
+import androidx.annotation.NonNull;
+import androidx.fragment.app.Fragment;
+import androidx.viewpager2.adapter.FragmentStateAdapter;
+
+public class HomeAdapter extends FragmentStateAdapter {
+    public HomeAdapter(Fragment fragment) {
+        super(fragment);
+    }
+
+    @NonNull
+    @Override
+    public Fragment createFragment(int position) {
+        return HomeItemFragment.newInstance(position);
+    }
+
+    @Override
+    public int getItemCount() {
+        return Home.values().length;
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/fragment/home/HomeFragment.java b/app/src/main/java/cc/calliope/mini/fragment/home/HomeFragment.java
new file mode 100644
index 0000000..d4b0024
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/fragment/home/HomeFragment.java
@@ -0,0 +1,42 @@
+package cc.calliope.mini.fragment.home;
+
+import android.os.Bundle;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.google.android.material.tabs.TabLayout;
+import com.google.android.material.tabs.TabLayoutMediator;
+
+import androidx.annotation.NonNull;
+import androidx.fragment.app.Fragment;
+
+import cc.calliope.mini.databinding.FragmentHomeBinding;
+import cc.calliope.mini.fragment.ZoomOutPageTransformer;
+
+public class HomeFragment extends Fragment {
+    private FragmentHomeBinding binding;
+
+    public View onCreateView(@NonNull LayoutInflater inflater,
+                             ViewGroup container, Bundle savedInstanceState) {
+
+        binding = FragmentHomeBinding.inflate(inflater, container, false);
+
+        HomeAdapter adapter = new HomeAdapter(this);
+
+        binding.homeViewpager.setAdapter(adapter);
+        binding.homeViewpager.setPageTransformer(new ZoomOutPageTransformer());
+
+        new TabLayoutMediator(binding.homeTabDots, binding.homeViewpager, (tab, position) ->
+                tab.setTabLabelVisibility(TabLayout.TAB_LABEL_VISIBILITY_UNLABELED))
+                .attach();
+
+        return binding.getRoot();
+    }
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+        binding = null;
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/fragment/home/HomeItemFragment.java b/app/src/main/java/cc/calliope/mini/fragment/home/HomeItemFragment.java
new file mode 100644
index 0000000..7577acd
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/fragment/home/HomeItemFragment.java
@@ -0,0 +1,96 @@
+package cc.calliope.mini.fragment.home;
+
+import android.graphics.drawable.AnimationDrawable;
+import android.os.Bundle;
+import android.text.Html;
+import android.text.Spanned;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.fragment.app.Fragment;
+import cc.calliope.mini.databinding.FragmentItemBinding;
+
+
+public class HomeItemFragment extends Fragment {
+    private static final String ARG_POSITION = "arg_position";
+    private FragmentItemBinding binding;
+    private AnimationDrawable animationDrawable;
+
+    public static HomeItemFragment newInstance(int position) {
+        HomeItemFragment fragment = new HomeItemFragment();
+        Bundle args = new Bundle();
+        args.putInt(ARG_POSITION, position);
+        fragment.setArguments(args);
+
+        return fragment;
+    }
+
+    @Override
+    public View onCreateView(@NonNull LayoutInflater inflater,
+                             ViewGroup container, Bundle savedInstanceState) {
+        binding = FragmentItemBinding.inflate(inflater, container, false);
+        return binding.getRoot();
+    }
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+        binding = null;
+    }
+
+    @Override
+    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
+        Bundle args = getArguments();
+        if (args == null)
+            return;
+
+        int position = args.getInt(ARG_POSITION);
+        Home home = Home.values()[position];
+
+        ImageView iconImageView = binding.iconImageView;
+        iconImageView.setImageResource(home.getIconResId());
+        if(position == 1 || position == 2) {
+            animationDrawable = (AnimationDrawable) iconImageView.getDrawable();
+        }
+
+        binding.titleTextView.setText(home.getTitleResId());
+
+        Spanned spanned = Html.fromHtml(getString(home.getInfoResId()));
+        binding.infoTextView.setText(spanned);
+
+//        if (Version.upperOreo) {
+//            binding.infoTextView.setJustificationMode(Layout.JUSTIFICATION_MODE_INTER_WORD);
+//        }
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+
+        if (animationDrawable != null) {
+            animationDrawable.start();
+        }
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+
+        if (animationDrawable != null) {
+            animationDrawable.stop();
+        }
+    }
+
+    @Override
+    public void onStop() {
+        super.onStop();
+
+        if (animationDrawable != null) {
+            animationDrawable.setCallback(null);
+        }
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/fragment/settings/SettingsFragment.java b/app/src/main/java/cc/calliope/mini/fragment/settings/SettingsFragment.java
new file mode 100644
index 0000000..36b54ee
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/fragment/settings/SettingsFragment.java
@@ -0,0 +1,14 @@
+package cc.calliope.mini.fragment.settings;
+
+import android.os.Bundle;
+
+import androidx.preference.PreferenceFragmentCompat;
+import cc.calliope.mini.R;
+
+public class SettingsFragment extends PreferenceFragmentCompat {
+
+    @Override
+    public void onCreatePreferences(Bundle savedInstanceState, String rootKey) {
+        setPreferencesFromResource(R.xml.preferences, rootKey);
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/fragment/web/WebFragment.java b/app/src/main/java/cc/calliope/mini/fragment/web/WebFragment.java
new file mode 100644
index 0000000..05de4cd
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/fragment/web/WebFragment.java
@@ -0,0 +1,340 @@
+package cc.calliope.mini.fragment.web;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Bundle;
+
+import androidx.annotation.NonNull;
+import androidx.fragment.app.Fragment;
+import androidx.lifecycle.ViewModelProvider;
+import cc.calliope.mini.activity.FlashingActivity;
+import cc.calliope.mini.R;
+import cc.calliope.mini.utils.Preference;
+import cc.calliope.mini.utils.StaticExtra;
+import cc.calliope.mini.ExtendedBluetoothDevice;
+import cc.calliope.mini.utils.FileUtils;
+import cc.calliope.mini.utils.Utils;
+import cc.calliope.mini.utils.Version;
+import cc.calliope.mini.viewmodels.ScannerViewModel;
+
+import android.os.StrictMode;
+import android.util.Base64;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.webkit.DownloadListener;
+import android.webkit.JavascriptInterface;
+import android.webkit.URLUtil;
+import android.webkit.WebChromeClient;
+import android.webkit.WebResourceError;
+import android.webkit.WebResourceRequest;
+import android.webkit.WebSettings;
+import android.webkit.WebView;
+import android.webkit.WebViewClient;
+
+import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.io.UnsupportedEncodingException;
+import java.io.Writer;
+import java.net.URL;
+import java.net.URLConnection;
+import java.net.URLDecoder;
+import java.nio.charset.StandardCharsets;
+
+
+/**
+ * A simple {@link Fragment} subclass.
+ * Use the {@link WebFragment#newInstance} factory method to
+ * create an instance of this fragment.
+ */
+public class WebFragment extends Fragment implements DownloadListener {
+
+    private static final String TAG = "WEB_VIEW";
+    private static final String UTF_8 = "UTF-8";
+    private static final String TARGET_URL = "editorUrl";
+    private static final String TARGET_NAME = "editorName";
+    private String editorUrl;
+    private String editorName;
+    private WebView webView;
+    private ExtendedBluetoothDevice device;
+
+    private class JavaScriptInterface {
+        private final Context context;
+
+        public JavaScriptInterface(Context context) {
+            this.context = context;
+        }
+
+        @JavascriptInterface
+        public void getBase64FromBlobData(String url, String name) {
+            Log.d(TAG, "base64Data: " + url);
+            Log.d(TAG, "name: " + name);
+
+            File file = FileUtils.getFile(context, editorName, name);
+            if (file == null) {
+                Utils.errorSnackbar(webView, getString(R.string.error_snackbar_save_file_error)).show();
+            } else {
+                if (createAndSaveFileFromBase64Url(url, file)) {
+                    startDfuActivity(file);
+                } else {
+                    Utils.errorSnackbar(webView, getString(R.string.error_snackbar_download_error)).show();
+                }
+            }
+        }
+
+        public static String getBase64StringFromBlobUrl(String blobUrl, String mimeType) {
+            if (blobUrl.startsWith("blob")) {
+                return "javascript: " +
+                        "var xhr = new XMLHttpRequest();" +
+                        "xhr.open('GET', '" + blobUrl + "', true);" +
+                        "xhr.setRequestHeader('Content-type','" + mimeType + ";charset=UTF-8');" +
+                        "xhr.responseType = 'blob';" +
+                        "xhr.onload = function(e) {" +
+                        "    if (this.status == 200) {" +
+                        "        var blobFile = this.response;" +
+                        "        var name = blobFile.name;" +
+                        "        var reader = new FileReader();" +
+                        "        reader.readAsDataURL(blobFile);" +
+                        "        reader.onloadend = function() {" +
+                        "            base64data = reader.result;" +
+                        "            Android.getBase64FromBlobData(base64data, name);" +
+                        "        }" +
+                        "    }" +
+                        "};" +
+                        "xhr.send();";
+            }
+            return "javascript: console.log('It is not a Blob URL');";
+        }
+    }
+
+    public WebFragment() {
+        // Required empty public constructor
+    }
+
+    /**
+     * Use this factory method to create a new instance of
+     * this fragment using the provided parameters.
+     *
+     * @param editorName Editor name.
+     * @param url        Editor URL.
+     * @return A new instance of fragment WebFragment.
+     */
+
+    public static WebFragment newInstance(@NonNull String url, @NonNull String editorName) {
+        WebFragment fragment = new WebFragment();
+        Bundle args = new Bundle();
+        args.putString(TARGET_URL, url);
+        args.putString(TARGET_NAME, editorName);
+        fragment.setArguments(args);
+        return fragment;
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        Utils.log(Log.ASSERT, TAG, "onCreate");
+
+        StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitAll().build();
+        StrictMode.setThreadPolicy(policy);
+
+        Bundle arguments = getArguments();
+        if (arguments != null) {
+            editorUrl = arguments.getString(TARGET_URL);
+            editorName = arguments.getString(TARGET_NAME);
+        }
+    }
+
+    @SuppressLint("SetJavaScriptEnabled")
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container,
+                             Bundle savedInstanceState) {
+        // Inflate the layout for this fragment
+        View view = inflater.inflate(R.layout.fragment_web, container, false);
+
+        ScannerViewModel scannerViewModel = new ViewModelProvider(requireActivity()).get(ScannerViewModel.class);
+        scannerViewModel.getScannerState().observe(getViewLifecycleOwner(), result -> device = result.getCurrentDevice());
+
+        webView = view.findViewById(R.id.webView);
+        WebSettings webSettings = webView.getSettings();
+
+        webSettings.setJavaScriptEnabled(true);
+        webSettings.setDomStorageEnabled(true);
+        webSettings.setUseWideViewPort(true);
+        webSettings.setLoadWithOverviewMode(true);
+        webSettings.setDatabaseEnabled(true);
+        webSettings.setDefaultTextEncodingName("utf-8");
+
+        webView.addJavascriptInterface(new JavaScriptInterface(getContext()), "Android");
+        webView.setWebChromeClient(new WebChromeClient());
+        webView.setWebViewClient(new WebViewClient() {
+            @Override
+            public void onReceivedError(WebView view, WebResourceRequest request, WebResourceError error) {
+                if (Version.VERSION_M_AND_NEWER) {
+                    Utils.errorSnackbar(webView, "Oh no! " + error.getDescription()).show();
+                } else {
+                    Utils.errorSnackbar(webView, "Oh no! onReceivedError").show();
+                }
+            }
+        });
+        webView.setDownloadListener(this);
+
+        if (savedInstanceState != null) {
+            webView.restoreState(savedInstanceState.getBundle("webViewState"));
+        } else {
+            webView.loadUrl(editorUrl);
+        }
+        return view;
+    }
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+    }
+
+    //TODO завантажувати xml і ділитися ними
+
+    @Override
+    public void onDownloadStart(String url, String userAgent, String contentDisposition, String mimetype, long contentLength) {
+        Log.i(TAG, "editorName: " + editorName);
+        Log.i(TAG, "URL: " + url);
+        Log.i(TAG, "userAgent: " + userAgent);
+        Log.i(TAG, "contentDisposition: " + contentDisposition);
+        Log.i(TAG, "mimetype: " + mimetype);
+        Log.i(TAG, "contentLength: " + contentLength);
+
+        try {
+            String decodedUrl = URLDecoder.decode(url, UTF_8);
+            if (decodedUrl.startsWith("blob:")) {
+                String javaScript = JavaScriptInterface.getBase64StringFromBlobUrl(url, mimetype);
+                Log.v(TAG, "javaScript: " + javaScript);
+                webView.loadUrl(javaScript);
+            } else {
+                selectDownloadMethod(decodedUrl);
+            }
+        } catch (UnsupportedEncodingException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private void selectDownloadMethod(String url) {
+        Context context = getContext();
+        if (context == null) {
+            return;
+        }
+
+        String name = FileUtils.getFileName(url);
+        File file = FileUtils.getFile(context, editorName, name);
+        boolean result = false;
+
+        if (file == null) {
+            Utils.errorSnackbar(webView, getString(R.string.error_snackbar_save_file_error)).show();
+        } else {
+            if (url.startsWith("data:text/hex")) {
+                result = createAndSaveFileFromHexUrl(url, file);
+            } else if (url.startsWith("data:") && url.contains("base64")) {
+                result = createAndSaveFileFromBase64Url(url, file);
+            } else if (URLUtil.isValidUrl(url) && url.endsWith(".hex")) {
+                result = downloadFileFromURL(url, file);
+            }
+            if (result) {
+                startDfuActivity(file);
+            } else {
+                Utils.errorSnackbar(webView, getString(R.string.error_snackbar_download_error)).show();
+            }
+        }
+    }
+
+    public boolean createAndSaveFileFromHexUrl(String url, File file) {
+        try {
+            String hexEncodedString = url.substring(url.indexOf(",") + 1);
+            OutputStream outputStream = new FileOutputStream(file);
+            try (Writer writer = new OutputStreamWriter(outputStream, StandardCharsets.UTF_8)) {
+                writer.write(hexEncodedString);
+            } catch (IOException e) {
+                e.printStackTrace();
+                return false;
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+            return false;
+        }
+        Log.i(TAG, "createAndSaveFileFromHexUrl: " + file.toString());
+        return true;
+    }
+
+    public Boolean createAndSaveFileFromBase64Url(String url, File file) {
+        try {
+            String base64EncodedString = url.substring(url.indexOf(",") + 1);
+            byte[] decodedBytes = Base64.decode(base64EncodedString, Base64.DEFAULT);
+            OutputStream os = new FileOutputStream(file);
+            os.write(decodedBytes);
+            os.close();
+        } catch (IOException e) {
+            e.printStackTrace();
+            return false;
+        }
+        Log.i(TAG, "createAndSaveFileFromBase64Url: " + file.toString());
+        return true;
+    }
+
+
+    public Boolean downloadFileFromURL(String link, File file) {
+        try {
+            URL url = new URL(link);
+            URLConnection ucon = url.openConnection();
+            ucon.setReadTimeout(5000);
+            ucon.setConnectTimeout(10000);
+
+            InputStream is = ucon.getInputStream();
+            BufferedInputStream inStream = new BufferedInputStream(is, 1024 * 5);
+            FileOutputStream outStream = new FileOutputStream(file);
+            byte[] buff = new byte[5 * 1024];
+            int len;
+            while ((len = inStream.read(buff)) != -1) {
+                outStream.write(buff, 0, len);
+            }
+            outStream.flush();
+            outStream.close();
+            inStream.close();
+        } catch (Exception e) {
+            e.printStackTrace();
+            return false;
+        }
+        Log.i(TAG, "downloadFileFromURL: " + file.toString());
+        return true;
+    }
+
+    private void startDfuActivity(File file) {
+        boolean autoFlashing = Preference.getBoolean(getContext(), Preference.PREF_KEY_ENABLE_AUTO_FLASHING, true);
+        if(!autoFlashing){
+            return;
+        }
+
+        if (device != null && device.isRelevant()) {
+            Log.e(TAG, "start DFU Activity");
+            final Intent intent = new Intent(getActivity(), FlashingActivity.class);
+            intent.putExtra(StaticExtra.EXTRA_DEVICE, device);
+            intent.putExtra(StaticExtra.EXTRA_FILE_PATH, file.getAbsolutePath());
+            startActivity(intent);
+        } else {
+            Utils.errorSnackbar(webView, getString(R.string.error_snackbar_no_connected)).show();
+        }
+    }
+
+    @Override
+    public void onSaveInstanceState(@NonNull Bundle outState) {
+        super.onSaveInstanceState(outState);
+        Utils.log(Log.ASSERT, TAG, "onSaveInstanceState");
+        Bundle bundle = new Bundle();
+        webView.saveState(bundle);
+        outState.putBundle("webViewState", bundle);
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/myCodeActivity.java b/app/src/main/java/cc/calliope/mini/myCodeActivity.java
deleted file mode 100644
index 234fac8..0000000
--- a/app/src/main/java/cc/calliope/mini/myCodeActivity.java
+++ /dev/null
@@ -1,98 +0,0 @@
-package cc.calliope.mini;
-
-import android.content.Intent;
-import android.os.Bundle;
-import android.support.v7.app.AppCompatActivity;
-import android.util.Log;
-import android.view.View;
-import android.widget.AdapterView;
-import android.widget.ListView;
-import android.widget.TextView;
-import android.widget.Toast;
-
-import java.io.File;
-import java.util.ArrayList;
-
-import cc.calliope.mini.adapter.ExtendedBluetoothDevice;
-import cc.calliope.mini.adapter.HexFilesAdapter;
-import cc.calliope.mini.datamodel.HexFile;
-
-public class myCodeActivity extends AppCompatActivity {
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity_my_code);
-//        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
-//        setSupportActionBar(toolbar);
-
-        final Intent intent = getIntent();
-        final ExtendedBluetoothDevice device = intent.getParcelableExtra("cc.calliope.mini.EXTRA_DEVICE");
-        if (device != null) {
-            final String deviceName = device.getName();
-            final String deviceAddress = device.getAddress();
-            Log.i("DEVICE", deviceName);
-            final TextView deviceInfo = findViewById(R.id.deviceInfo);
-        }
-
-    //        File mydir = getFilesDir();
-    //        Log.i("Datei", getFilesDir()+"");
-    //        File lister = mydir.getAbsoluteFile();
-    //        for (String list : lister.list())
-    //        {
-    //            Log.i("Datei", list);
-    //        }
-    //
-    //
-    //        final ListView listView = findViewById(R.id.code_list_view);
-    //        ArrayAdapter<String> adapter = new ArrayAdapter<String>(
-    //                this,
-    //                android.R.layout.simple_list_item_1,
-    //                lister.list());
-    //
-    //        listView.setAdapter(adapter);
-
-
-        // Construct the data source
-        ArrayList<HexFile> arrayOfUsers = new ArrayList<HexFile>();
-        // Create the adapter to convert the array to views
-        HexFilesAdapter adapter = new HexFilesAdapter(this, arrayOfUsers, device);
-        // Attach the adapter to a ListView
-        ListView listView = (ListView) findViewById(R.id.code_list_view);
-        listView.setAdapter(adapter);
-
-    //        File mydir = getFilesDir();
-        File dir = new File(getFilesDir().toString());
-    //        Log.i("Datei", getFilesDir()+"");
-    //        File lister = mydir.getAbsoluteFile();
-        File[] files = dir.listFiles();
-    //        for (String list : lister.list())
-        for (File file : files) {
-//                Log.i("Datei", file.toString());
-    //            adapter.add(new HexFile(list, "San Diego"));
-                Long lastmodified = file.lastModified();
-                adapter.insert(new HexFile(file, lastmodified), 0);
-        }
-
-
-        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
-            @Override
-            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
-//                Log.i("SELECTED Position", position + "");
-//                Log.i("SELECTED HexFile", adapter.getHexFileName(position));
-                String selectedItem = adapter.getHexFile(position).toString();
-
-                if (device != null) {
-                    final Intent intent = new Intent(myCodeActivity.this, DFUActivity.class);
-                    intent.putExtra("cc.calliope.mini.EXTRA_DEVICE", device);
-                    intent.putExtra("EXTRA_FILE", selectedItem);
-                    startActivity(intent);
-                } else {
-                    Toast.makeText(getApplicationContext(), R.string.upload_no_mini_connected, Toast.LENGTH_LONG).show();
-                }
-            }
-        });
-
-    }
-
-}
diff --git a/app/src/main/java/cc/calliope/mini/popup/PopupAdapter.java b/app/src/main/java/cc/calliope/mini/popup/PopupAdapter.java
new file mode 100644
index 0000000..0b9336e
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/popup/PopupAdapter.java
@@ -0,0 +1,69 @@
+package cc.calliope.mini.popup;
+
+import android.content.Context;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ArrayAdapter;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import androidx.annotation.IntDef;
+import androidx.annotation.NonNull;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.util.List;
+
+import cc.calliope.mini.R;
+
+public class PopupAdapter extends ArrayAdapter<PopupItem> {
+    private final Context context;
+    private final List<PopupItem> popupItems;
+    private final int type;
+    public static final int TYPE_START = 1;
+    public static final int TYPE_END = 2;
+
+    @IntDef({TYPE_START, TYPE_END})
+    @Retention(RetentionPolicy.SOURCE)
+    public @interface menuType {
+    }
+
+    public PopupAdapter(Context context, @menuType int type, List<PopupItem> popupItems) {
+        super(context,
+                type == TYPE_START ? R.layout.popup_item_start : R.layout.popup_item_end, popupItems);
+        this.context = context;
+        this.type = type;
+        this.popupItems = popupItems;
+    }
+
+    private static class ViewHolder {
+        TextView title;
+        ImageView icon;
+    }
+
+    @NonNull
+    @Override
+    public View getView(int position, View convertView, @NonNull ViewGroup parent) {
+        ViewHolder holder;
+        View view;
+
+        if (convertView == null) {
+            holder = new ViewHolder();
+            LayoutInflater inflater = LayoutInflater.from(context);
+            view = inflater.inflate(
+                    type == TYPE_START ? R.layout.popup_item_start : R.layout.popup_item_end,
+                    parent, false);
+            holder.title = view.findViewById(R.id.custom_menu_item_title);
+            holder.icon = view.findViewById(R.id.custom_menu_item_icon);
+            view.setTag(holder);
+        } else {
+            view = convertView;
+            holder = (ViewHolder) view.getTag();
+        }
+
+        holder.title.setText(popupItems.get(position).getTitleId());
+        holder.icon.setImageResource(popupItems.get(position).getIconId());
+        return view;
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/popup/PopupItem.java b/app/src/main/java/cc/calliope/mini/popup/PopupItem.java
new file mode 100644
index 0000000..f502c73
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/popup/PopupItem.java
@@ -0,0 +1,19 @@
+package cc.calliope.mini.popup;
+
+public class PopupItem {
+    private final int titleId;
+    private final int iconId;
+
+    public PopupItem(int titleId, int iconId) {
+        this.titleId = titleId;
+        this.iconId = iconId;
+    }
+
+    public int getTitleId() {
+        return titleId;
+    }
+
+    public int getIconId() {
+        return iconId;
+    }
+}
diff --git a/app/src/main/java/cc/calliope/mini/profile/BlinkyManager.java b/app/src/main/java/cc/calliope/mini/profile/BlinkyManager.java
deleted file mode 100644
index 2140f6f..0000000
--- a/app/src/main/java/cc/calliope/mini/profile/BlinkyManager.java
+++ /dev/null
@@ -1,150 +0,0 @@
-/*
- * Copyright (c) 2015, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package cc.calliope.mini.profile;
-
-import android.bluetooth.BluetoothGatt;
-import android.bluetooth.BluetoothGattCharacteristic;
-import android.bluetooth.BluetoothGattService;
-import android.content.Context;
-import android.support.annotation.NonNull;
-import android.util.Log;
-
-import java.util.Deque;
-import java.util.LinkedList;
-import java.util.UUID;
-
-import no.nordicsemi.android.ble.BleManager;
-import no.nordicsemi.android.ble.Request;
-import no.nordicsemi.android.log.LogContract;
-
-public class BlinkyManager extends BleManager<BlinkyManagerCallbacks> {
-	/** MINI Service UUID. */
-	public final static UUID LBS_UUID_SERVICE = UUID.fromString("E95D93B0-251D-470A-A062-FA1922DFA9A8");
-	/** BUTTON characteristic UUID. DOESNT EXIST */
-	private final static UUID LBS_UUID_BUTTON_CHAR = UUID.fromString("E95D93B1-251D-470A-A062-FA1922DFA9A8");
-	/** (LED) OPEN FIRMWARE FLASH MODE CHARACTERISTICS UUID. */
-	private final static UUID LBS_UUID_LED_CHAR = UUID.fromString("E95D93B1-251D-470A-A062-FA1922DFA9A8");
-
-	private BluetoothGattCharacteristic mButtonCharacteristic, mLedCharacteristic;
-
-	public BlinkyManager(final Context context) {
-		super(context);
-	}
-
-	@NonNull
-	@Override
-	protected BleManagerGattCallback getGattCallback() {
-		return mGattCallback;
-	}
-
-	@Override
-	protected boolean shouldAutoConnect() {
-		// If you want to connect to the device using autoConnect flag = true, return true here.
-		// Read the documentation of this method.
-//		return super.shouldAutoConnect();
-        return true;
-	}
-
-	/**
-	 * BluetoothGatt callbacks for connection/disconnection, service discovery, receiving indication, etc
-	 */
-	private final BleManagerGattCallback mGattCallback = new BleManagerGattCallback() {
-
-		@Override
-		protected Deque<Request> initGatt(final BluetoothGatt gatt) {
-			final LinkedList<Request> requests = new LinkedList<>();
-			requests.push(Request.newReadRequest(mLedCharacteristic));
-			requests.push(Request.newReadRequest(mButtonCharacteristic));
-			requests.push(Request.newEnableNotificationsRequest(mButtonCharacteristic));
-			return requests;
-		}
-
-		@Override
-		public boolean isRequiredServiceSupported(final BluetoothGatt gatt) {
-			final BluetoothGattService service = gatt.getService(LBS_UUID_SERVICE);
-			if (service != null) {
-				mButtonCharacteristic = service.getCharacteristic(LBS_UUID_BUTTON_CHAR);
-				mLedCharacteristic = service.getCharacteristic(LBS_UUID_LED_CHAR);
-			}
-            Log.i("OWN", "CHARTEST: " + mLedCharacteristic);
-
-			boolean writeRequest = false;
-			if (mLedCharacteristic != null) {
-				final int rxProperties = mLedCharacteristic.getProperties();
-				writeRequest = (rxProperties & BluetoothGattCharacteristic.PROPERTY_WRITE) > 0;
-			}
-
-			return mButtonCharacteristic != null && mLedCharacteristic != null && writeRequest;
-		}
-
-		@Override
-		protected void onDeviceDisconnected() {
-			mButtonCharacteristic = null;
-			mLedCharacteristic = null;
-		}
-
-		@Override
-		protected void onCharacteristicRead(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic) {
-			final int data = characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT8, 0);
-			if (characteristic == mLedCharacteristic) {
-				final boolean ledOn = data == 0x01;
-				log(LogContract.Log.Level.APPLICATION, "LED " + (ledOn ? "ON" : "OFF"));
-				mCallbacks.onDataSent(ledOn);
-			} else {
-				final boolean buttonPressed = data == 0x01;
-				log(LogContract.Log.Level.APPLICATION, "Button " + (buttonPressed ? "pressed" : "released"));
-				mCallbacks.onDataReceived(buttonPressed);
-			}
-		}
-
-		@Override
-		public void onCharacteristicWrite(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic) {
-			// This method is only called for LED characteristic
-			final int data = characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT8, 0);
-			final boolean ledOn = data == 0x01;
-			log(LogContract.Log.Level.APPLICATION, "LED " + (ledOn ? "ON" : "OFF"));
-			mCallbacks.onDataSent(ledOn);
-		}
-
-		@Override
-		public void onCharacteristicNotified(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic) {
-			// This method is only called for Button characteristic
-			final int data = characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT8, 0);
-			final boolean buttonPressed = data == 0x01;
-			log(LogContract.Log.Level.APPLICATION, "Button " + (buttonPressed ? "pressed" : "released"));
-			mCallbacks.onDataReceived(buttonPressed);
-		}
-	};
-
-	public void send() {
-		// Are we connected?
-		Log.i("OWN", "DFU Characteristics: " + mLedCharacteristic);
-
-		if (mLedCharacteristic == null)
-			return;
-
-		final byte[] command = new byte[] {(byte) (0x01)};
-		Log.i("OWN", "turning on DFU");
-		writeCharacteristic(mLedCharacteristic, command);
-	}
-}
diff --git a/app/src/main/java/cc/calliope/mini/receiveFileIntentActivity.java b/app/src/main/java/cc/calliope/mini/receiveFileIntentActivity.java
deleted file mode 100644
index 5445c93..0000000
--- a/app/src/main/java/cc/calliope/mini/receiveFileIntentActivity.java
+++ /dev/null
@@ -1,79 +0,0 @@
-package cc.calliope.mini;
-
-import android.content.Intent;
-import android.net.Uri;
-import android.os.Bundle;
-import android.support.v7.app.AppCompatActivity;
-import android.util.Log;
-import android.widget.Toast;
-
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.InputStream;
-import java.io.OutputStream;
-
-public class receiveFileIntentActivity extends AppCompatActivity {
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity_receive_file_intent);
-
-
-
-        // Get intent, action and MIME type
-        Intent intent = getIntent();
-        String action = intent.getAction();
-        String type = intent.getType();
-
-        if (Intent.ACTION_VIEW.equals(action) && type != null) {
-            Uri uri = getIntent().getData();
-            String extension = uri.toString().substring(uri.toString().lastIndexOf("."));
-            Log.i("INTENT", "TYPE: "+type+" File: "+uri+" Ext: "+extension);
-
-            if(extension.equals(".hex")) {
-                String filename = "RECEIVED-" + System.currentTimeMillis() + ".hex";
-                File file = new File(getFilesDir() + File.separator + filename);
-                if (file.exists())
-                    file.delete();
-                try {
-                    file.createNewFile();
-                } catch (Exception e) {
-                    e.printStackTrace();
-                    Log.w("CreateFile", "Error writing " + file);
-                }
-
-                try {
-                    InputStream in = getContentResolver().openInputStream(uri);
-                    OutputStream out = new FileOutputStream(file);
-                    byte[] buf = new byte[1024];
-                    int len;
-                    while ((len = in.read(buf)) > 0) {
-                        out.write(buf, 0, len);
-                    }
-                    out.close();
-                    in.close();
-
-                    Toast.makeText(getApplicationContext(), "Datei gespeichert", Toast.LENGTH_LONG).show();
-
-                } catch (Exception e) {
-                    e.printStackTrace();
-                    Log.w("CreateFile", "Error" + file);
-                }
-            } else {
-                Toast.makeText(getApplicationContext(), "Falscher Dateityp", Toast.LENGTH_LONG).show();
-            }
-
-        } else {
-            // Handle other intents, such as being started from the home screen
-            Log.i("INTENT", "NOPE");
-            Toast.makeText(getApplicationContext(), "Keine Datei empfangen", Toast.LENGTH_LONG).show();
-        }
-
-        final Intent targetIntent = new Intent(receiveFileIntentActivity.this, MainActivity.class);
-        startActivity(targetIntent);
-
-
-
-    }
-}
diff --git a/app/src/main/java/cc/calliope/mini/selectEditorActivity.java b/app/src/main/java/cc/calliope/mini/selectEditorActivity.java
deleted file mode 100644
index 965f3c9..0000000
--- a/app/src/main/java/cc/calliope/mini/selectEditorActivity.java
+++ /dev/null
@@ -1,126 +0,0 @@
-package cc.calliope.mini;
-
-import android.app.AlertDialog;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.os.Bundle;
-import android.preference.PreferenceManager;
-import android.support.constraint.ConstraintLayout;
-import android.support.v7.app.AppCompatActivity;
-import android.text.InputType;
-import android.util.Log;
-import android.view.View;
-import android.widget.EditText;
-import android.widget.ImageView;
-import android.widget.TextView;
-
-import cc.calliope.mini.adapter.ExtendedBluetoothDevice;
-
-public class selectEditorActivity extends AppCompatActivity {
-
-    private ExtendedBluetoothDevice device = null;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity_select_editor);
-
-        final Intent intent = getIntent();
-        device = intent.getParcelableExtra("cc.calliope.mini.EXTRA_DEVICE");
-        if (device != null) {
-            final String deviceName = device.getName();
-            final String deviceAddress = device.getAddress();
-            Log.i("DEVICE", deviceName);
-            final TextView deviceInfo = findViewById(R.id.deviceInfo);
-        }
-
-//        ConstraintLayout buttonMiniEdit = findViewById(R.id.buttonMiniEdit);
-//        buttonMiniEdit.setOnClickListener(new View.OnClickListener() {
-//            @Override
-//            public void onClick(View view) {
-//                openEditor("https://miniedit.calliope.cc/", "MINIEDIT");
-//            }
-//        });
-
-        ConstraintLayout buttonMakeCode = findViewById(R.id.buttonMakeCode);
-        buttonMakeCode.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                openEditor("https://makecode.calliope.cc", "MAKECODE");
-            }
-        });
-
-        ConstraintLayout buttonNepo = findViewById(R.id.buttonNepo);
-        buttonNepo.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-//                SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(getApplicationContext());
-//                String nepoLink = prefs.getString("NEPO_URL", "https://lab.open-roberta.org/#loadSystem&&calliope2017");
-                openEditor("https://lab.open-roberta.org/#loadSystem&&calliope2017", "NEPO");
-            }
-        });
-
-        ConstraintLayout buttonCustomEditor = findViewById(R.id.buttonCustomEditor);
-        buttonCustomEditor.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(getApplicationContext());
-                String customLink = prefs.getString("CUSTOM_URL", "https://calliope.cc/programmieren/editoren");
-                openEditor(customLink, "CUSTOM");
-            }
-        });
-
-
-
-
-        ImageView buttonEdit = findViewById(R.id.buttonEdit);
-        buttonEdit.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                AlertDialog.Builder builder = new AlertDialog.Builder(view.getContext());
-                builder.setTitle(R.string.set_nepo_link_title);
-
-// Set up the input
-                final EditText input = new EditText(view.getContext());
-
-                SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(getApplicationContext());
-                String customLink = prefs.getString("CUSTOM_URL", "https://calliope.cc/programmieren/editoren");
-                input.setText(customLink);
-// Specify the type of input expected; this, for example, sets the input as a password, and will mask the text
-                input.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_URI);
-                builder.setView(input);
-
-// Set up the buttons
-                builder.setPositiveButton("OK", new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialog, int which) {
-                        //m_Text = input.getText().toString();
-                        SharedPreferences.Editor prefEditor = PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).edit();
-                        prefEditor.putString("CUSTOM_URL", input.getText().toString());
-                        prefEditor.apply();
-                    }
-                });
-                builder.setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialog, int which) {
-                        dialog.cancel();
-                    }
-                });
-
-                builder.show();
-            }
-        });
-
-    }
-
-    protected void openEditor(String editor, String editorName) {
-        final Intent intent = new Intent(selectEditorActivity.this, editorAcitvity.class);
-        if(device != null) intent.putExtra("cc.calliope.mini.EXTRA_DEVICE", device);
-            intent.putExtra("TARGET_NAME", editorName);
-            intent.putExtra("TARGET_URL", editor);
-            startActivity(intent);
-    }
-
-
-}
diff --git a/app/src/main/java/cc/calliope/mini/service/DfuControlService.java b/app/src/main/java/cc/calliope/mini/service/DfuControlService.java
new file mode 100644
index 0000000..dbd678d
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/service/DfuControlService.java
@@ -0,0 +1,376 @@
+package cc.calliope.mini.service;
+
+import android.Manifest;
+import android.app.Service;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothGatt;
+import android.bluetooth.BluetoothGattCallback;
+import android.bluetooth.BluetoothGattCharacteristic;
+import android.bluetooth.BluetoothGattService;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.PackageManager;
+import android.os.Build;
+import android.os.IBinder;
+import android.util.Log;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.reflect.Method;
+import java.util.UUID;
+
+import androidx.annotation.IntDef;
+import androidx.core.app.ActivityCompat;
+import androidx.localbroadcastmanager.content.LocalBroadcastManager;
+import cc.calliope.mini.App;
+import cc.calliope.mini.utils.Utils;
+import cc.calliope.mini.utils.Version;
+
+import static android.bluetooth.BluetoothDevice.ACTION_BOND_STATE_CHANGED;
+import static android.bluetooth.BluetoothDevice.BOND_BONDED;
+import static android.bluetooth.BluetoothDevice.BOND_BONDING;
+import static android.bluetooth.BluetoothDevice.BOND_NONE;
+import static android.bluetooth.BluetoothDevice.ERROR;
+import static android.bluetooth.BluetoothDevice.EXTRA_BOND_STATE;
+import static android.bluetooth.BluetoothGatt.GATT_SUCCESS;
+import static android.bluetooth.BluetoothProfile.STATE_CONNECTED;
+import static android.bluetooth.BluetoothProfile.STATE_DISCONNECTED;
+
+
+public class DfuControlService extends Service {
+    private static final String TAG = "DfuControlService";
+    private static final UUID DEVICE_FIRMWARE_UPDATE_CONTROL_SERVICE_UUID = UUID.fromString("E95D93B0-251D-470A-A062-FA1922DFA9A8");
+    private static final UUID DEVICE_FIRMWARE_UPDATE_CONTROL_CHARACTERISTIC_UUID = UUID.fromString("E95D93B1-251D-470A-A062-FA1922DFA9A8");
+    private static final UUID SECURE_DEVICE_FIRMWARE_UPDATE_SERVICE_UUID = UUID.fromString("0000FE59-0000-1000-8000-00805F9B34FB");
+    private static final int DELAY_TO_CLEAR_CACHE = 2000;
+    public static final String BROADCAST_START = "cc.calliope.mini.DFUControlService.BROADCAST_START";
+    public static final String BROADCAST_COMPLETED = "cc.calliope.mini.DFUControlService.BROADCAST_COMPLETE";
+    public static final String BROADCAST_FAILED = "cc.calliope.mini.DFUControlService.BROADCAST_FAILED";
+    public static final String BROADCAST_ERROR = "cc.calliope.mini.DFUControlService.BROADCAST_ERROR";
+    public static final String EXTRA_BOARD_VERSION = "cc.calliope.mini.DFUControlService.EXTRA_BOARD_VERSION";
+    public static final String EXTRA_ERROR_CODE = "cc.calliope.mini.DFUControlService.EXTRA_ERROR_CODE";
+    public static final String EXTRA_ERROR_MESSAGE = "cc.calliope.mini.DFUControlService.EXTRA_ERROR_MESSAGE";
+    public static final String EXTRA_DEVICE_ADDRESS = "cc.calliope.mini.DFUControlService.EXTRA_DEVICE_ADDRESS";
+    public static final String EXTRA_MAX_RETRIES_NUMBER = "cc.calliope.mini.DFUControlService.EXTRA_MAX_RETRIES_NUMBER";
+    public static final int GATT_DISCONNECTED_BY_DEVICE = 19;
+    private final Object mLock = new Object();
+    private int maxRetries;
+    private int numOfRetries = 0;
+    private boolean isComplete = false;
+    private int bondState;
+    private String deviceAddress;
+    public static final int UNIDENTIFIED = 0;
+    /**
+     * Version 1.x, 2.0, 2,1
+     * https://calliope-mini.github.io/v10/
+     * https://calliope-mini.github.io/v20/
+     * https://calliope-mini.github.io/v21/
+     */
+    public static final int MINI_V1 = 1;
+    /**
+     * New version
+     */
+    public static final int MINI_V2 = 2;
+
+    @IntDef({UNIDENTIFIED, MINI_V1, MINI_V2})
+    @Retention(RetentionPolicy.SOURCE)
+    public @interface HardwareVersion {
+    }
+
+    private int boardVersion = UNIDENTIFIED;
+    private App app;
+
+    private final BroadcastReceiver bondStateReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            final BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+            if (device == null || !device.getAddress().equals(deviceAddress)) {
+                return;
+            }
+
+            final String action = intent.getAction();
+            // Check if action is valid
+            if (action == null) {
+                return;
+            }
+
+            // Take action depending on new bond state
+            if (action.equals(ACTION_BOND_STATE_CHANGED)) {
+                bondState = intent.getIntExtra(EXTRA_BOND_STATE, ERROR);
+                switch (bondState) {
+                    case BOND_BONDING -> Utils.log(Log.WARN, TAG, "Bonding started");
+                    case BOND_BONDED -> {
+                        Utils.log(Log.WARN, TAG, "Bonding succeeded");
+                        synchronized (mLock) {
+                            mLock.notifyAll();
+                        }
+                    }
+                    case BOND_NONE -> {
+                        Utils.log(Log.WARN, TAG, "Oh oh");
+                        synchronized (mLock) {
+                            mLock.notifyAll();
+                        }
+                    }
+                }
+            }
+        }
+    };
+
+    @SuppressWarnings({"MissingPermission"})
+    private final BluetoothGattCallback gattCallback = new BluetoothGattCallback() {
+        @Override
+        public void onConnectionStateChange(final BluetoothGatt gatt, final int status, final int newState) {
+            Utils.log(Log.ASSERT, TAG, "onConnectionStateChange(gatt: " + gatt + ", status: " + status + ", newState: " + newState + ")");
+
+            if (status == GATT_SUCCESS || status == GATT_DISCONNECTED_BY_DEVICE) {
+                if (newState == STATE_CONNECTED) {
+                    if (bondState == BOND_NONE || bondState == BOND_BONDED) {
+                        if (bondState == BOND_BONDED && Build.VERSION.SDK_INT <= Build.VERSION_CODES.N) {
+                            waitFor(1600);
+                        }
+                        boolean result = gatt.discoverServices();
+                        if (!result) {
+                            Utils.log(Log.ERROR, TAG, "discoverServices failed to start");
+                        }
+                    } else if (bondState == BOND_BONDING) {
+                        Utils.log(Log.WARN, TAG, "waiting for bonding to complete");
+                    }
+                } else if (newState == STATE_DISCONNECTED) {
+                    stopService(gatt);
+                }
+            } else {
+                String message = getStringFromResource(GattStatus.get(status).getMessage());
+                gatt.disconnect();
+                sendError(status, message);
+                //stopService(gatt);
+            }
+        }
+
+        @Override
+        public void onServicesDiscovered(final BluetoothGatt gatt, final int status) {
+            Utils.log(Log.ASSERT, TAG, "onServicesDiscovered(status: " + status + ")");
+
+            if (status == GATT_SUCCESS) {
+                startLegacyDfu(gatt);
+            } else {
+                gatt.disconnect();
+                sendError(status, "Services discovered not success");
+            }
+        }
+
+        // Other methods just pass the parameters through
+        @Override
+        public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {
+            Utils.log(Log.ASSERT, TAG, "onCharacteristicWrite(status: " + status + ")");
+
+            if (bondState == BOND_NONE || bondState == BOND_BONDED) {
+                if (status == GATT_SUCCESS) {
+                    isComplete = true;
+                    boardVersion = MINI_V1;
+                } else {
+                    gatt.disconnect();
+                    sendError(status, "Characteristic write not success");
+                }
+            } else if (bondState == BOND_BONDING) {
+                Utils.log(Log.WARN, TAG, "waiting for bonding to complete");
+            }
+        }
+
+        @Override
+        public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {
+            Utils.log(Log.ASSERT, TAG, "onCharacteristicRead(gatt: " + gatt + ", characteristic: " + characteristic + ", status: " + status + ")");
+
+            if (bondState == BOND_NONE || bondState == BOND_BONDED) {
+                if (status == GATT_SUCCESS) {
+                    characteristic.setValue(1, BluetoothGattCharacteristic.FORMAT_UINT8, 0);
+                    try {
+                        Utils.log(Log.DEBUG, TAG, "Writing Flash Command...");
+                        gatt.writeCharacteristic(characteristic);
+                    } catch (Exception e) {
+                        e.printStackTrace();
+                        gatt.disconnect();
+                        sendError(133, e.toString());
+                    }
+                }
+            } else if (bondState == BOND_BONDING) {
+                Utils.log(Log.WARN, TAG, "waiting for bonding to complete");
+            }
+        }
+    };
+
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        return null;
+    }
+
+    @Override
+    public int onStartCommand(Intent intent, int flags, int startId) {
+        Utils.log(Log.DEBUG, TAG, "Сервіс запущений.");
+
+        registerReceiver(bondStateReceiver, new IntentFilter(ACTION_BOND_STATE_CHANGED));
+
+        deviceAddress = intent.getStringExtra(EXTRA_DEVICE_ADDRESS);
+        maxRetries = intent.getIntExtra(EXTRA_MAX_RETRIES_NUMBER, 2);
+
+        app = (App) getApplication();
+        app.setAppState(App.APP_STATE_CONNECTING);
+
+        connect();
+
+        return START_STICKY;
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        unregisterReceiver(bondStateReceiver);
+
+        final Intent broadcast = new Intent(isComplete ? BROADCAST_COMPLETED : BROADCAST_FAILED);
+        broadcast.putExtra(EXTRA_BOARD_VERSION, boardVersion);
+        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(broadcast);
+
+        app.setAppState(App.APP_STATE_STANDBY);
+        Utils.log(Log.DEBUG, TAG, "Сервіс зупинений.");
+    }
+
+    private void connect() {
+        if ((Version.VERSION_S_AND_NEWER && ActivityCompat.checkSelfPermission(this, android.Manifest.permission.BLUETOOTH_CONNECT) != PackageManager.PERMISSION_GRANTED)
+                && ActivityCompat.checkSelfPermission(this, Manifest.permission.BLUETOOTH) != PackageManager.PERMISSION_GRANTED) {
+            Utils.log(Log.ERROR, TAG, "BLUETOOTH permission no granted");
+            return;
+        }
+        Utils.log(Log.DEBUG, TAG, "Connecting to the device...");
+
+        final Intent broadcast = new Intent(BROADCAST_START);
+        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(broadcast);
+
+        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
+
+        if(!adapter.isEnabled()){
+            return;
+        }
+
+        BluetoothDevice device = adapter.getRemoteDevice(deviceAddress);
+        bondState = device.getBondState();
+
+        if (Version.VERSION_O_AND_NEWER) {
+            Utils.log(Log.DEBUG, TAG, "gatt = device.connectGatt(autoConnect = false, TRANSPORT_LE, preferredPhy = LE_1M | LE_2M)");
+            device.connectGatt(this, false, gattCallback,
+                    BluetoothDevice.TRANSPORT_LE,
+                    BluetoothDevice.PHY_LE_1M_MASK | BluetoothDevice.PHY_LE_2M_MASK);
+        } else if (Version.VERSION_M_AND_NEWER) {
+            Utils.log(Log.DEBUG, TAG, "gatt = device.connectGatt(autoConnect = false, TRANSPORT_LE)");
+            device.connectGatt(this, false, gattCallback,
+                    BluetoothDevice.TRANSPORT_LE);
+        } else {
+            Utils.log(Log.DEBUG, TAG, "gatt = device.connectGatt(autoConnect = false)");
+            device.connectGatt(this, false, gattCallback);
+        }
+
+    }
+
+    @SuppressWarnings({"MissingPermission"})
+    private void stopService(BluetoothGatt gatt) {
+        if (bondState == BOND_BONDING) {
+            waitUntilBonded();
+        }
+        clearServicesCache(gatt);
+        gatt.close();
+        stopSelf();
+    }
+
+    @SuppressWarnings({"MissingPermission"})
+    private void startLegacyDfu(BluetoothGatt gatt) {
+        BluetoothGattService legacyDfuService = gatt.getService(DEVICE_FIRMWARE_UPDATE_CONTROL_SERVICE_UUID);
+        if (legacyDfuService == null) {
+            startSecureDfu(gatt);
+            return;
+        }
+
+        final BluetoothGattCharacteristic legacyDfuCharacteristic = legacyDfuService.getCharacteristic(DEVICE_FIRMWARE_UPDATE_CONTROL_CHARACTERISTIC_UUID);
+        if (legacyDfuCharacteristic == null) {
+            gatt.disconnect();
+            sendError(133, "Cannot find DEVICE_FIRMWARE_UPDATE_CONTROL_CHARACTERISTIC_UUID");
+            return;
+        }
+
+        boolean res = gatt.readCharacteristic(legacyDfuCharacteristic);
+        Utils.log(Log.WARN, TAG, "readCharacteristic: " + res);
+    }
+
+    @SuppressWarnings({"MissingPermission"})
+    private void startSecureDfu(BluetoothGatt gatt) {
+        BluetoothGattService secureDfuService = gatt.getService(SECURE_DEVICE_FIRMWARE_UPDATE_SERVICE_UUID);
+        if (secureDfuService == null) {
+            if (numOfRetries < maxRetries) {
+                Utils.log(Log.WARN, TAG, "Retrying to discover services...");
+                numOfRetries++;
+                clearServicesCache(gatt);
+                gatt.discoverServices();
+            } else {
+                gatt.disconnect();
+                sendError(133, "Cannot find services");
+            }
+        } else {
+            isComplete = true;
+            boardVersion = MINI_V2;
+            gatt.disconnect();
+        }
+    }
+
+    protected void clearServicesCache(BluetoothGatt gatt) {
+        try {
+            //noinspection JavaReflectionMemberAccess
+            final Method refresh = gatt.getClass().getMethod("refresh");
+            //noinspection ConstantConditions
+            final boolean success = (boolean) refresh.invoke(gatt);
+            Utils.log(Log.DEBUG, TAG, "Refreshing result: " + success);
+        } catch (final Exception e) {
+            Utils.log(Log.ERROR, TAG, "An exception occurred while refreshing device. " + e);
+        }
+        waitFor(DELAY_TO_CLEAR_CACHE);
+    }
+
+    protected void waitUntilBonded() {
+        try {
+            synchronized (mLock) {
+                while (bondState == BOND_BONDING)
+                    mLock.wait();
+            }
+        } catch (final InterruptedException e) {
+            Utils.log(Log.ERROR, TAG, "Sleeping interrupted, " + e);
+        }
+    }
+
+    protected void waitFor(final long millis) {
+        synchronized (mLock) {
+            try {
+                Utils.log(Log.DEBUG, TAG, "Wait for " + millis + " millis");
+                mLock.wait(millis);
+            } catch (final InterruptedException e) {
+                Utils.log(Log.ERROR, TAG, "Sleeping interrupted, " + e);
+            }
+        }
+    }
+
+    private void sendError(final int code, final String message) {
+        final Intent broadcast = new Intent(BROADCAST_ERROR);
+        broadcast.putExtra(EXTRA_ERROR_CODE, code);
+        broadcast.putExtra(EXTRA_ERROR_MESSAGE, message);
+        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(broadcast);
+        Utils.log(Log.ERROR, TAG, message);
+    }
+
+    private String getStringFromResource(int resId) {
+        try {
+            return getResources().getString(resId);
+        } catch (Exception e) {
+            e.printStackTrace();
+            return "";
+        }
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/service/DfuService.java b/app/src/main/java/cc/calliope/mini/service/DfuService.java
index 72246d5..82d9e8f 100644
--- a/app/src/main/java/cc/calliope/mini/service/DfuService.java
+++ b/app/src/main/java/cc/calliope/mini/service/DfuService.java
@@ -1,14 +1,61 @@
 package cc.calliope.mini.service;
 
 import android.app.Activity;
+import android.content.Intent;
 
-import cc.calliope.mini.ui.activity.NotificationActivity;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.core.app.NotificationCompat;
+import cc.calliope.mini.App;
+import cc.calliope.mini.BuildConfig;
+import cc.calliope.mini.activity.NotificationActivity;
+import cc.calliope.mini.utils.Version;
 import no.nordicsemi.android.dfu.DfuBaseService;
+import no.nordicsemi.android.dfu.DfuServiceInitiator;
 
-public class DfuService extends DfuBaseService {
+public class DfuService extends DfuBaseService{
+    private App app;
 
     @Override
     protected Class<? extends Activity> getNotificationTarget() {
         return NotificationActivity.class;
     }
+
+    @Override
+    public void onCreate() {
+        // Enable Notification Channel for Android OREO
+        if (Version.VERSION_O_AND_NEWER) {
+            DfuServiceInitiator.createDfuNotificationChannel(getApplicationContext());
+        }
+        super.onCreate();
+        app = (App) getApplication();
+        app.setAppState(App.APP_STATE_FLASHING);
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        app.setAppState(App.APP_STATE_STANDBY);
+    }
+
+    @Override
+    protected void onHandleIntent(@Nullable final Intent intent) {
+//        assert intent != null;
+//        final long delay = intent.getLongExtra(DfuBaseService.EXTRA_SCAN_DELAY, 200);
+//        waitFor(delay);
+        super.onHandleIntent(intent);
+    }
+
+    @Override
+    protected boolean isDebug() {
+        // Here return true if you want the service to print more logs in LogCat.
+        // Library's BuildConfig in current version of Android Studio is always set to DEBUG=false, so
+        // make sure you return true or your.app.BuildConfig.DEBUG here.
+        return BuildConfig.DEBUG;
+    }
+
+    @Override
+    protected void updateProgressNotification(@NonNull final NotificationCompat.Builder builder, final int progress) {
+        // Remove Abort action from the notification
+    }
 }
diff --git a/app/src/main/java/cc/calliope/mini/service/GattStatus.java b/app/src/main/java/cc/calliope/mini/service/GattStatus.java
new file mode 100644
index 0000000..0a88eb3
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/service/GattStatus.java
@@ -0,0 +1,80 @@
+package cc.calliope.mini.service;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import cc.calliope.mini.R;
+
+public enum GattStatus {
+    GATT_SUCCESS(0x00, R.string.gatt_success),
+    GATT_INVALID_HANDLE(0x01, R.string.gatt_invalid_handle),
+    GATT_READ_NOT_PERMIT(0x02, R.string.gatt_read_not_permit),
+    GATT_WRITE_NOT_PERMITTED(0x03, R.string.gatt_write_not_permitted),
+    GATT_INVALID_PDU(0x04, R.string.gatt_invalid_pdu),
+    GATT_INSUF_AUTHENTICATION(0x05, R.string.gatt_insuf_authentication),
+    GATT_REQUEST_NOT_SUPPORTED(0x06, R.string.gatt_request_not_supported),
+    GATT_INVALID_OFFSET(0x07, R.string.gatt_invalid_offset),
+    GATT_INSUFFICIENT_AUTHORIZATION(0x08, R.string.gatt_insufficient_authorization),
+    GATT_PREPARE_Q_FULL(0x09, R.string.gatt_prepare_q_full),
+    GATT_NOT_FOUND(0x0A, R.string.gatt_not_found),
+    GATT_NOT_LONG(0x0B, R.string.gatt_not_long),
+    GATT_INSUF_KEY_SIZE(0x0C, R.string.gatt_insuf_key_size),
+    GATT_INVALID_ATTRIBUTE_LENGTH(0x0D, R.string.gatt_invalid_attribute_length),
+    GATT_INVALID_ATTR_LEN(0x0D, R.string.gatt_invalid_attr_len),
+    GATT_ERR_UNLIKELY(0x0E, R.string.gatt_err_unlikely),
+    GATT_INSUFFICIENT_ENCRYPTION(0x0F, R.string.gatt_insufficient_encryption),
+    GATT_UNSUPPORT_GRP_TYPE(0x10, R.string.gatt_unsupport_grp_type),
+    GATT_INSUF_RESOURCE(0x11, R.string.gatt_insuf_resource),
+    GATT_DISCONNECTED_BY_DEVICE(0x13, R.string.gatt_disconnected_by_device),
+    GATT_NO_BONDED(0x16, R.string.gatt_no_bonded),
+    GATT_NO_RESSOURCES(0x80, R.string.gatt_no_ressources),
+    GATT_INTERNAL_ERROR(0x81, R.string.gatt_internal_error),
+    GATT_WRONG_STATE(0x82, R.string.gatt_wrong_state),
+    GATT_DB_FULL(0x83, R.string.gatt_db_full),
+    GATT_BUSY(0x84, R.string.gatt_busy),
+    GATT_ERROR(0x85, R.string.gatt_error),
+    GATT_CMD_STARTED(0x86, R.string.gatt_cmd_started),
+    GATT_ILLEGAL_PARAMETER(0x87, R.string.gatt_illegal_parameter),
+    GATT_PENDING(0x88, R.string.gatt_pending),
+    GATT_AUTH_FAIL(0x89, R.string.gatt_auth_fail),
+    GATT_MORE(0x8A, R.string.gatt_more),
+    GATT_INVALID_CFG(0x8B, R.string.gatt_invalid_cfg),
+    GATT_SERVICE_STARTED(0x8C, R.string.gatt_service_started),
+    GATT_ENCRYPED_NO_MITM(0x8D, R.string.gatt_encryped_no_mitm),
+    GATT_NOT_ENCRYPTED(0x8E, R.string.gatt_not_encrypted),
+    GATT_CONNECTION_CONGESTED(0x8F, R.string.gatt_connection_congested),
+    GATT_FAILURE(0x101, R.string.gatt_failure),
+    GATT_UNIDENTIFIED(0x999, R.string.gatt_unidentified);
+
+    private final Integer code;
+    private final Integer message;
+
+    private static final Map<Integer, GattStatus> lookup = new HashMap<>();
+
+    static {
+        for (GattStatus h : GattStatus.values()) {
+            lookup.put(h.getCode(), h);
+        }
+    }
+
+    GattStatus(Integer code, Integer message) {
+        this.code = code;
+        this.message = message;
+    }
+
+    public static GattStatus get(Integer code) {
+        GattStatus status = lookup.get(code);
+        if (status == null) {
+            return GATT_UNIDENTIFIED;
+        }
+        return status;
+    }
+
+    public Integer getCode() {
+        return code;
+    }
+
+    public Integer getMessage() {
+        return message;
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/service/PartialFlashingService.java b/app/src/main/java/cc/calliope/mini/service/PartialFlashingService.java
new file mode 100644
index 0000000..61ab39c
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/service/PartialFlashingService.java
@@ -0,0 +1,27 @@
+package cc.calliope.mini.service;
+
+import org.microbit.android.partialflashing.PartialFlashingBaseService;
+
+import cc.calliope.mini.App;
+
+public class PartialFlashingService extends PartialFlashingBaseService {
+    private App app;
+
+//    @Override
+//    protected Class<? extends Activity> getNotificationTarget() {
+//        return NotificationActivity.class;
+//    }
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        app = (App) getApplication();
+        app.setAppState(App.APP_STATE_FLASHING);
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        app.setAppState(App.APP_STATE_STANDBY);
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/utils/FileUtils.java b/app/src/main/java/cc/calliope/mini/utils/FileUtils.java
new file mode 100644
index 0000000..69095bd
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/utils/FileUtils.java
@@ -0,0 +1,75 @@
+package cc.calliope.mini.utils;
+
+import android.content.Context;
+import android.util.Log;
+import android.webkit.URLUtil;
+
+import org.apache.commons.io.FilenameUtils;
+import org.apache.commons.lang3.StringUtils;
+
+import java.io.File;
+import java.io.IOException;
+
+public class FileUtils {
+    private static final String TAG = "FileUtils";
+    private static final String FILE_EXTENSION = ".hex";
+
+    public static File getFile(Context context, String editorName, String filename) {
+
+        File dir = new File(context.getFilesDir().toString() + File.separator + editorName);
+        if (!dir.exists() && !dir.mkdirs()) {
+            return null;
+        }
+        Log.w(TAG, "DIR: " + dir);
+
+        File file = new File(dir.getAbsolutePath() + File.separator + filename + FILE_EXTENSION);
+
+        if (!Preference.getBoolean(context, Preference.PREF_KEY_RENAME_FILES, false) && file.exists()) {
+            file.delete();
+        } else {
+            int i = 1;
+            while (file.exists()) {
+                String number = String.format("(%s)", ++i);
+                file = new File(dir.getAbsolutePath() + File.separator + filename + number + FILE_EXTENSION);
+            }
+        }
+
+        try {
+            if (file.createNewFile()) {
+                Log.w(TAG, "createNewFile: " + file);
+                return file;
+            } else {
+                Log.e(TAG, "CreateFile Error, deleting: " + file);
+                if (!file.delete()) {
+                    Log.e(TAG, "Delete Error, deleting: " + file);
+                }
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    public static String getFileName(String url) {
+        int start = url.indexOf("data:");
+        int end = url.indexOf(".hex;");
+        String name;
+
+        if (start != -1 && end != -1) {
+            name = url.substring(start, end); //this will give abc
+            name = StringUtils.remove(name, "data:");
+            name = StringUtils.remove(name, "mini-");
+            return name;
+        } else if (URLUtil.isValidUrl(url) && url.endsWith(".hex")) {
+            return FilenameUtils.getBaseName(url);
+        } else {
+            return "firmware";
+        }
+    }
+
+    public static String getFileSize(String str) {
+        File file = new File(str);
+        return file.exists() ? Long.toString(file.length()) : "0";
+    }
+
+}
diff --git a/app/src/main/java/cc/calliope/mini/utils/Permission.java b/app/src/main/java/cc/calliope/mini/utils/Permission.java
new file mode 100644
index 0000000..d8d5f07
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/utils/Permission.java
@@ -0,0 +1,48 @@
+package cc.calliope.mini.utils;
+
+import android.Manifest;
+import android.app.Activity;
+import android.content.pm.PackageManager;
+import android.os.Build;
+import android.util.Log;
+
+import androidx.annotation.RequiresApi;
+import androidx.core.app.ActivityCompat;
+import androidx.core.content.ContextCompat;
+
+
+public class Permission {
+    public static final String[] BLUETOOTH_PERMISSIONS;
+    static {
+        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.S) {
+            BLUETOOTH_PERMISSIONS = new String[]{Manifest.permission.BLUETOOTH_SCAN, Manifest.permission.BLUETOOTH_CONNECT};
+        } else {
+            BLUETOOTH_PERMISSIONS = new String[]{Manifest.permission.BLUETOOTH, Manifest.permission.BLUETOOTH_ADMIN};
+        }
+    }
+
+    public static final String[] LOCATION_PERMISSIONS = {Manifest.permission.ACCESS_COARSE_LOCATION, Manifest.permission.ACCESS_FINE_LOCATION};
+    @RequiresApi(api = Build.VERSION_CODES.TIRAMISU)
+    public static final String[] POST_NOTIFICATIONS = {Manifest.permission.POST_NOTIFICATIONS};
+
+    public static boolean isAccessGranted(Activity activity, String... permissions) {
+        for (String permission : permissions) {
+            boolean granted = ContextCompat.checkSelfPermission(activity, permission) == PackageManager.PERMISSION_GRANTED;
+            Log.d("PERMISSION", permission + (granted ? " granted" : " denied"));
+            if (!granted) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    public static boolean isAccessDeniedForever(Activity activity, String... permissions) {
+        return !isAccessGranted(activity, permissions) // Location permission must be denied
+                && Preference.getBoolean(activity, permissions[0], false)// Permission must have been requested before
+                && !ActivityCompat.shouldShowRequestPermissionRationale(activity, permissions[0]); // This method should return false
+    }
+
+    public static void markPermissionRequested(Activity activity, String... permissions) {
+        Preference.setBoolean(activity, permissions[0], true);
+    }
+}
diff --git a/app/src/main/java/cc/calliope/mini/utils/Preference.java b/app/src/main/java/cc/calliope/mini/utils/Preference.java
new file mode 100644
index 0000000..d47a27a
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/utils/Preference.java
@@ -0,0 +1,29 @@
+package cc.calliope.mini.utils;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+
+import androidx.preference.PreferenceManager;
+
+public class Preference {
+    public static final String PREF_KEY_ENABLE_AUTO_FLASHING = "pref_key_enable_auto_flashing";
+    public static final String PREF_KEY_RENAME_FILES = "pref_key_rename_files";
+    public static final String PREF_KEY_ENABLE_PARTIAL_FLASHING = "pref_key_enable_partial_flashing";
+    public static final String PREF_KEY_CUSTOM_LINK = "pref_key_custom_link";
+
+
+    public static String getString(Context context, String key, String defValue) {
+        SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context);
+        return sharedPreferences.getString(key, defValue);
+    }
+
+    public static boolean getBoolean(Context context, String key, Boolean defValue){
+        SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context);
+        return sharedPreferences.getBoolean(key, defValue);
+    }
+
+    public static void setBoolean(Context context, String key, Boolean value){
+        SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context);
+        sharedPreferences.edit().putBoolean(key, value).apply();
+    }
+}
diff --git a/app/src/main/java/cc/calliope/mini/utils/StaticExtra.java b/app/src/main/java/cc/calliope/mini/utils/StaticExtra.java
new file mode 100644
index 0000000..48c51b6
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/utils/StaticExtra.java
@@ -0,0 +1,6 @@
+package cc.calliope.mini.utils;
+
+public class StaticExtra {
+    public static final String EXTRA_DEVICE = "cc.calliope.mini.EXTRA_DEVICE";
+    public static final String EXTRA_FILE_PATH = "cc.calliope.mini.EXTRA_FILE_PATH";
+}
diff --git a/app/src/main/java/cc/calliope/mini/utils/Utils.java b/app/src/main/java/cc/calliope/mini/utils/Utils.java
index 4a3e592..bfd8518 100644
--- a/app/src/main/java/cc/calliope/mini/utils/Utils.java
+++ b/app/src/main/java/cc/calliope/mini/utils/Utils.java
@@ -1,147 +1,123 @@
-/*
- * Copyright (c) 2015, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *  Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- *
- *  Redistributions in binary form must reproduce the above copyright notice,
- *   this list of conditions and the following disclaimer in the documentation
- *   and/or other materials provided with the distribution.
- *
- *  Neither the name of copyright holder nor the names of its
- *   contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
 package cc.calliope.mini.utils;
 
-import android.Manifest;
-import android.app.Activity;
 import android.bluetooth.BluetoothAdapter;
 import android.content.Context;
-import android.content.SharedPreferences;
-import android.content.pm.PackageManager;
-import android.os.Build;
-import android.preference.PreferenceManager;
-import android.provider.Settings;
-import android.support.v4.app.ActivityCompat;
-import android.support.v4.content.ContextCompat;
+import android.location.LocationManager;
+import android.net.ConnectivityManager;
+import android.text.format.DateFormat;
+import android.util.DisplayMetrics;
+import android.util.Log;
+import android.view.Gravity;
+import android.view.View;
+import android.widget.FrameLayout;
+import android.widget.LinearLayout;
+
+import com.google.android.material.snackbar.Snackbar;
+
+import java.io.IOException;
+import java.util.Date;
 
 public class Utils {
-	private static final String PREFS_LOCATION_NOT_REQUIRED = "location_not_required";
-	private static final String PREFS_PERMISSION_REQUESTED = "permission_requested";
-
-	/**
-	 * Checks whether Bluetooth is enabled.
-	 * @return true if Bluetooth is enabled, false otherwise.
-	 */
-	public static boolean isBleEnabled() {
-		final BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
-		return adapter != null && adapter.isEnabled();
-	}
-
-	/**
-	 * Checks for required permissions.
-	 *
-	 * @return true if permissions are already granted, false otherwise.
-	 */
-	public static boolean isLocationPermissionsGranted(final Context context) {
-		return ContextCompat.checkSelfPermission(context, Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED;
-	}
-
-
-	/**
-	 * Checks for required permissions.
-	 *
-	 * @return true if permissions are already granted, false otherwise.
-	 */
-	public static boolean isBluetoothScanPermissionsGranted(final Context context) {
-		return ContextCompat.checkSelfPermission(context, Manifest.permission.BLUETOOTH_SCAN) == PackageManager.PERMISSION_GRANTED;
-	}
-
-	/**
-	 * Returns true if location permission has been requested at least twice and
-	 * user denied it, and checked 'Don't ask again'.
-	 * @param activity the activity
-	 * @return true if permission has been denied and the popup will not come up any more, false otherwise
-	 */
-	public static boolean isLocationPermissionDeniedForever(final Activity activity) {
-		final SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(activity);
-
-		return !isLocationPermissionsGranted(activity) // Location permission must be denied
-				&& preferences.getBoolean(PREFS_PERMISSION_REQUESTED, false) // Permission must have been requested before
-				&& !ActivityCompat.shouldShowRequestPermissionRationale(activity, Manifest.permission.ACCESS_COARSE_LOCATION); // This method should return false
-	}
-
-	/**
-	 * On some devices running Android Marshmallow or newer location services must be enabled in order to scan for Bluetooth LE devices.
-	 * This method returns whether the Location has been enabled or not.
-	 *
-	 * @return true on Android 6.0+ if location mode is different than LOCATION_MODE_OFF. It always returns true on Android versions prior to Marshmallow.
-	 */
-	public static boolean isLocationEnabled(final Context context) {
-		if (isMarshmallowOrAbove()) {
-			int locationMode = Settings.Secure.LOCATION_MODE_OFF;
-			try {
-				locationMode = Settings.Secure.getInt(context.getContentResolver(), Settings.Secure.LOCATION_MODE);
-			} catch (final Settings.SettingNotFoundException e) {
-				// do nothing
-			}
-			return locationMode != Settings.Secure.LOCATION_MODE_OFF;
-		}
-		return true;
-	}
-
-	/**
-	 * Location enabled is required on some phones running Android Marshmallow or newer (for example on Nexus and Pixel devices).
-	 *
-	 * @param context the context
-	 * @return false if it is known that location is not required, true otherwise
-	 */
-	public static boolean isLocationRequired(final Context context) {
-		final SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(context);
-		return preferences.getBoolean(PREFS_LOCATION_NOT_REQUIRED, isMarshmallowOrAbove());
-	}
-
-	/**
-	 * When a Bluetooth LE packet is received while Location is disabled it means that Location
-	 * is not required on this device in order to scan for LE devices. This is a case of Samsung phones, for example.
-	 * Save this information for the future to keep the Location info hidden.
-	 * @param context the context
-	 */
-	public static void markLocationNotRequired(final Context context) {
-		final SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(context);
-		preferences.edit().putBoolean(PREFS_LOCATION_NOT_REQUIRED, false).apply();
-	}
-
-	/**
-	 * The first time an app requests a permission there is no 'Don't ask again' checkbox and
-	 * {@link ActivityCompat#shouldShowRequestPermissionRationale(Activity, String)} returns false.
-	 * This situation is similar to a permission being denied forever, so to distinguish both cases
-	 * a flag needs to be saved.
-	 * @param context the context
-	 */
-	public static void markLocationPermissionRequested(final Context context) {
-		final SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(context);
-		preferences.edit().putBoolean(PREFS_PERMISSION_REQUESTED, true).apply();
-	}
-
-	public static boolean isMarshmallowOrAbove() {
-		return Build.VERSION.SDK_INT >= Build.VERSION_CODES.M;
-	}
+    private static final String TAG = "UTILS";
+
+    /**
+     * Checks whether device is connected to network
+     *
+     * @param context the context
+     * @return true if connected, false otherwise.
+     */
+    public static boolean isNetworkConnected(Context context) {
+        ConnectivityManager manager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+        return manager.getActiveNetworkInfo() != null && manager.getActiveNetworkInfo().isConnected();
+    }
+
+    /**
+     * Actually checks if device is connected to internet
+     * (There is a possibility it's connected to a network but not to internet)
+     *
+     * @return true if connected, false otherwise.
+     */
+    public static boolean isInternetAvailable() {
+        String command = "ping -c 1 google.com";
+        try {
+            return Runtime.getRuntime().exec(command).waitFor() == 0;
+        } catch (InterruptedException | IOException e) {
+            e.printStackTrace();
+        }
+        return false;
+    }
+
+    /**
+     * Checks whether Bluetooth is enabled.
+     *
+     * @return true if Bluetooth is enabled, false otherwise.
+     */
+    public static boolean isBluetoothEnabled() {
+        final BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
+        return adapter != null && adapter.isEnabled();
+    }
+
+    /**
+     * On some devices running Android Marshmallow or newer location services must be enabled in order to scan for Bluetooth LE devices.
+     * This method returns whether the Location has been enabled or not.
+     *
+     * @return true on Android 6.0+ if location mode is different than LOCATION_MODE_OFF.
+     */
+    public static boolean isLocationEnabled(final Context context) {
+        LocationManager locationManager = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE);
+        boolean gpsEnabled = false;
+        boolean networkEnabled = false;
+
+        try {
+            gpsEnabled = locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER);
+        } catch (Exception ex) {
+            Log.e(TAG, "isLocationEnabled: " + ex);
+        }
+
+        try {
+            networkEnabled = locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER);
+        } catch (Exception ex) {
+            Log.e(TAG, "isLocationEnabled: " + ex);
+        }
+
+        return gpsEnabled && networkEnabled;
+    }
+
+    public static Snackbar errorSnackbar(View view, String message) {
+        FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(
+                LinearLayout.LayoutParams.MATCH_PARENT,
+                LinearLayout.LayoutParams.WRAP_CONTENT
+        );
+        params.gravity = Gravity.TOP | Gravity.CENTER_HORIZONTAL;
+
+        Snackbar snackbar = Snackbar.make(view, message, Snackbar.LENGTH_LONG);
+        snackbar.getView().setLayoutParams(params);
+        return snackbar;
+    }
+
+    /**
+     * This method converts dp unit to equivalent pixels, depending on device density.
+     *
+     * @param dp      A value in dp (density independent pixels) unit. Which we need to convert into pixels
+     * @param context Context to get resources and device specific display metrics
+     * @return A int value to represent px equivalent to dp depending on device density
+     */
+    public static int convertDpToPixel(Context context, int dp) {
+        return dp * (context.getResources().getDisplayMetrics().densityDpi / DisplayMetrics.DENSITY_DEFAULT);
+    }
+
+    public static String dateFormat(long lastModified) {
+        final String OUTPUT_DATE_FORMAT = "EEEE dd.MM.yyyy HH:mm";
+        Date date = new Date(lastModified);
+
+        return DateFormat.format(OUTPUT_DATE_FORMAT, date.getTime()).toString();
+    }
+
+    public static void log(int priority, String TAG, String message) {
+        Log.println(priority, TAG, "### " + android.os.Process.myTid() + " # " + message);
+    }
+
+    public static void log(String TAG, String message) {
+        log(Log.VERBOSE, TAG, message);
+    }
 }
diff --git a/app/src/main/java/cc/calliope/mini/utils/Version.java b/app/src/main/java/cc/calliope/mini/utils/Version.java
new file mode 100644
index 0000000..582cd03
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/utils/Version.java
@@ -0,0 +1,12 @@
+package cc.calliope.mini.utils;
+
+import android.os.Build;
+
+public class Version {
+    public static final boolean VERSION_M_AND_NEWER = Build.VERSION.SDK_INT >= Build.VERSION_CODES.M;
+    public static final boolean VERSION_N_AND_NEWER = Build.VERSION.SDK_INT >= Build.VERSION_CODES.N;
+    public static final boolean VERSION_O_AND_NEWER = Build.VERSION.SDK_INT >= Build.VERSION_CODES.O;
+    public static final boolean VERSION_Q_AND_NEWER = Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q;
+    public static final boolean VERSION_S_AND_NEWER = Build.VERSION.SDK_INT >= Build.VERSION_CODES.S;
+    public static final boolean VERSION_TIRAMISU_AND_NEWER = Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU;
+}
diff --git a/app/src/main/java/cc/calliope/mini/viewmodels/BlinkyViewModel.java b/app/src/main/java/cc/calliope/mini/viewmodels/BlinkyViewModel.java
deleted file mode 100644
index 6d816b2..0000000
--- a/app/src/main/java/cc/calliope/mini/viewmodels/BlinkyViewModel.java
+++ /dev/null
@@ -1,212 +0,0 @@
-/*
- * Copyright (c) 2015, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *  Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- *
- *  Redistributions in binary form must reproduce the above copyright notice,
- *   this list of conditions and the following disclaimer in the documentation
- *   and/or other materials provided with the distribution.
- *
- *  Neither the name of copyright holder nor the names of its
- *   contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package cc.calliope.mini.viewmodels;
-
-import android.app.Application;
-import android.arch.lifecycle.AndroidViewModel;
-import android.arch.lifecycle.LiveData;
-import android.arch.lifecycle.MutableLiveData;
-import android.bluetooth.BluetoothDevice;
-import android.support.annotation.NonNull;
-import android.util.Log;
-
-import cc.calliope.mini.adapter.ExtendedBluetoothDevice;
-import cc.calliope.mini.profile.BlinkyManager;
-import cc.calliope.mini.profile.BlinkyManagerCallbacks;
-import no.nordicsemi.android.log.LogSession;
-import no.nordicsemi.android.log.Logger;
-
-public class BlinkyViewModel extends AndroidViewModel implements BlinkyManagerCallbacks {
-	private final BlinkyManager mBlinkyManager;
-
-	// Connection states Connecting, Connected, Disconnecting, Disconnected etc.
-	private final MutableLiveData<String> mConnectionState = new MutableLiveData<>();
-
-	// Flag to determine if the device is connected
-	private final MutableLiveData<Boolean> mIsConnected = new MutableLiveData<>();
-
-	// Flag to determine if the device has required services
-	private final SingleLiveEvent<Boolean> mIsSupported = new SingleLiveEvent<>();
-
-	// Flag to determine if the device is ready
-	private final MutableLiveData<Void> mOnDeviceReady = new MutableLiveData<>();
-
-	// Flag that holds the on off state of the LED. On is true, Off is False
-	private final MutableLiveData<Boolean> mLEDState = new MutableLiveData<>();
-
-	// Flag that holds the pressed released state of the button on the devkit. Pressed is true, Released is False
-	private final MutableLiveData<Boolean> mButtonState = new MutableLiveData<>();
-
-	public LiveData<Void> isDeviceReady() {
-		Log.d("DeviceStatus", mOnDeviceReady+"");
-		return mOnDeviceReady;
-	}
-
-	public LiveData<String> getConnectionState() {
-		return mConnectionState;
-	}
-
-	public LiveData<Boolean> isConnected() {
-		return mIsConnected;
-	}
-
-	public LiveData<Boolean> getButtonState() {
-		return mButtonState;
-	}
-
-	public LiveData<Boolean> getLEDState() {
-		return mLEDState;
-	}
-
-	public LiveData<Boolean> isSupported() {
-		return mIsSupported;
-	}
-
-	public BlinkyViewModel(@NonNull final Application application) {
-		super(application);
-
-		// Initialize the manager
-		mBlinkyManager = new BlinkyManager(getApplication());
-		mBlinkyManager.setGattCallbacks(this);
-	}
-
-	/**
-	 * Connect to peripheral
-	 */
-	public void connect(final ExtendedBluetoothDevice device) {
-		final LogSession logSession = Logger.newSession(getApplication(), null, device.getAddress(), device.getName());
-		mBlinkyManager.setLogger(logSession);
-		mBlinkyManager.connect(device.getDevice());
-	}
-
-	/**
-	 * Disconnect from peripheral
-	 */
-	private void disconnect() {
-		mBlinkyManager.disconnect();
-	}
-
-//	public void toggleLED(final boolean onOff) {
-//		mBlinkyManager.send(onOff);
-//		mLEDState.setValue(onOff);
-//	}
-
-	public void startDFU() {
-		mBlinkyManager.send();
-	}
-
-	@Override
-	protected void onCleared() {
-		super.onCleared();
-		if (mBlinkyManager.isConnected()) {
-			disconnect();
-		}
-	}
-
-	@Override
-	public void onDataReceived(final boolean state) {
-		mButtonState.postValue(state);
-	}
-
-	@Override
-	public void onDataSent(final boolean state) {
-		mLEDState.postValue(state);
-	}
-
-	@Override
-	public void onDeviceConnecting(final BluetoothDevice device) {
-		//mConnectionState.postValue(getApplication().getString(R.string.state_connecting));
-	}
-
-	@Override
-	public void onDeviceConnected(final BluetoothDevice device) {
-		mIsConnected.postValue(true);
-		//mConnectionState.postValue(getApplication().getString(R.string.state_discovering_services));
-	}
-
-	@Override
-	public void onDeviceDisconnecting(final BluetoothDevice device) {
-		mIsConnected.postValue(false);
-	}
-
-	@Override
-	public void onDeviceDisconnected(final BluetoothDevice device) {
-		mIsConnected.postValue(false);
-	}
-
-	@Override
-	public void onLinklossOccur(final BluetoothDevice device) {
-		mIsConnected.postValue(false);
-	}
-
-	@Override
-	public void onServicesDiscovered(final BluetoothDevice device, final boolean optionalServicesFound) {
-//		mConnectionState.postValue(getApplication().getString(R.string.state_initializing));
-	}
-
-	@Override
-	public void onDeviceReady(final BluetoothDevice device) {
-		mIsSupported.postValue(true);
-//		mConnectionState.postValue(getApplication().getString(R.string.state_discovering_services_completed, device.getName()));
-		mOnDeviceReady.postValue(null);
-	}
-
-	@Override
-	public boolean shouldEnableBatteryLevelNotifications(final BluetoothDevice device) {
-		// Blinky doesn't have Battery Service
-		return false;
-	}
-
-	@Override
-	public void onBatteryValueReceived(final BluetoothDevice device, final int value) {
-		// Blinky doesn't have Battery Service
-	}
-
-	@Override
-	public void onBondingRequired(final BluetoothDevice device) {
-		// Blinky does not require bonding
-	}
-
-	@Override
-	public void onBonded(final BluetoothDevice device) {
-		// Blinky does not require bonding
-	}
-
-	@Override
-	public void onError(final BluetoothDevice device, final String message, final int errorCode) {
-		// TODO implement
-	}
-
-	@Override
-	public void onDeviceNotSupported(final BluetoothDevice device) {
-		mIsSupported.postValue(false);
-	}
-}
diff --git a/app/src/main/java/cc/calliope/mini/viewmodels/ScannerLiveData.java b/app/src/main/java/cc/calliope/mini/viewmodels/ScannerLiveData.java
index 0cbcb07..0b9e477 100644
--- a/app/src/main/java/cc/calliope/mini/viewmodels/ScannerLiveData.java
+++ b/app/src/main/java/cc/calliope/mini/viewmodels/ScannerLiveData.java
@@ -30,162 +30,248 @@
 
 package cc.calliope.mini.viewmodels;
 
-import android.arch.lifecycle.LiveData;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
+import static android.bluetooth.BluetoothDevice.BOND_BONDED;
+import static android.content.Context.BLUETOOTH_SERVICE;
 
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothManager;
+import android.util.Log;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.util.ArrayList;
+import java.util.Date;
 import java.util.List;
+import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import cc.calliope.mini.adapter.ExtendedBluetoothDevice;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.lifecycle.LiveData;
+
+import cc.calliope.mini.ExtendedBluetoothDevice;
+import cc.calliope.mini.dialog.pattern.PatternEnum;
+import cc.calliope.mini.utils.Utils;
 import no.nordicsemi.android.support.v18.scanner.ScanResult;
 
 /**
  * This class keeps the current list of discovered Bluetooth LE devices matching filter.
  * If a new device has been found it is added to the list and the LiveData i observers are
  * notified. If a packet from a device that's already in the list is found, the RSSI and name
- * are updated and observers are also notified. Observer may check {@link #getUpdatedDeviceIndex()}
- * to find out the index of the updated device.
+ * are updated and observers are also notified.
  */
-@SuppressWarnings("unused")
+
 public class ScannerLiveData extends LiveData<ScannerLiveData> {
-	private final List<ExtendedBluetoothDevice> mDevices = new ArrayList<>();
-	private Integer mUpdatedDeviceIndex;
-	private boolean mScanningStarted;
-	private boolean mBluetoothEnabled;
-	private boolean mLocationEnabled;
-
-	/* package */ ScannerLiveData(final boolean bluetoothEnabled, final boolean locationEnabled) {
-		mScanningStarted = false;
-		mBluetoothEnabled = bluetoothEnabled;
-		mLocationEnabled = locationEnabled;
-		postValue(this);
-	}
-
-	/* package */ void refresh() {
-		postValue(this);
-	}
-
-	/* package */ void scanningStarted() {
-		mScanningStarted = true;
-		postValue(this);
-	}
-
-	/* package */ void scanningStopped() {
-		mScanningStarted = false;
-		postValue(this);
-	}
-
-	/* package */ void bluetoothEnabled() {
-		mBluetoothEnabled = true;
-		postValue(this);
-	}
-
-	/* package */ void bluetoothDisabled() {
-		mBluetoothEnabled = false;
-		mUpdatedDeviceIndex = null;
-		mDevices.clear();
-		postValue(this);
-	}
-
-	/* package */ void setLocationEnabled(final boolean enabled) {
-		mLocationEnabled = enabled;
-		postValue(this);
-	}
-
-	/* package */ void deviceDiscovered(final ScanResult result) {
-		String deviceName = result.getScanRecord().getDeviceName();
-		if(deviceName != null){
-			System.out.println("Found Device: "+deviceName);
-
-			Pattern p = Pattern.compile("[a-zA-Z :]+\\u005b(([A-Z]){5})\\u005d");
-			Matcher m = p.matcher(deviceName.toUpperCase());
-
-			if(m.matches()) {
-
-				ExtendedBluetoothDevice device;
-
-				final int index = indexOf(result);
-				if (index == -1) {
-					device = new ExtendedBluetoothDevice(result);
-					mDevices.add(device);
-					mUpdatedDeviceIndex = null;
-				} else {
-					device = mDevices.get(index);
-					mUpdatedDeviceIndex = index;
-				}
-
-				// Update RSSI and name
-				device.setRssi(result.getRssi());
-				device.setName(result.getScanRecord().getDeviceName());
-				device.setPattern(m.group(1));
-				postValue(this);
-			}
-		}
-	}
-
-	/**
-	 * Returns the list of devices.
-	 * @return current list of devices discovered
-	 */
-	@NonNull
-	public List<ExtendedBluetoothDevice> getDevices() {
-		return mDevices;
-	}
-
-	/**
-	 * Returns null if a new device was added, or an index of the updated device.
-	 */
-	@Nullable
-	public Integer getUpdatedDeviceIndex() {
-		final Integer i = mUpdatedDeviceIndex;
-		mUpdatedDeviceIndex = null;
-		return i;
-	}
-
-	/**
-	 * Returns whether the list is empty.
-	 */
-	public boolean isEmpty() {
-		return mDevices.isEmpty();
-	}
-
-	/**
-	 * Returns whether scanning is in progress.
-	 */
-	public boolean isScanning() {
-		return mScanningStarted;
-	}
-
-	/**
-	 * Returns whether Bluetooth adapter is enabled.
-	 */
-	public boolean isBluetoothEnabled() {
-		return mBluetoothEnabled;
-	}
-
-	/**
-	 * Returns whether Location is enabled.
-	 */
-	public boolean isLocationEnabled() {
-		return mLocationEnabled;
-	}
-
-	/**
-	 * Finds the index of existing devices on the scan results list.
-	 *
-	 * @param result scan result
-	 * @return index of -1 if not found
-	 */
-	private int indexOf(final ScanResult result) {
-		int i = 0;
-		for (final ExtendedBluetoothDevice device : mDevices) {
-			if (device.matches(result))
-				return i;
-			i++;
-		}
-		return -1;
-	}
+    private final List<ExtendedBluetoothDevice> devices = new ArrayList<>();
+    private Float[] currentPattern = {0f, 0f, 0f, 0f, 0f};
+    private Integer updatedDeviceIndex;
+    private boolean scanningStarted;
+    private boolean bluetoothEnabled;
+    private boolean locationEnabled;
+
+    /* package */ ScannerLiveData(final boolean bluetoothEnabled, final boolean locationEnabled) {
+        this.scanningStarted = false;
+        this.bluetoothEnabled = bluetoothEnabled;
+        this.locationEnabled = locationEnabled;
+        postValue(this);
+    }
+
+    /* package */ void refresh() {
+        postValue(this);
+    }
+
+    /* package */ void scanningStarted() {
+        scanningStarted = true;
+        postValue(this);
+    }
+
+    /* package */ void scanningStopped() {
+        scanningStarted = false;
+        postValue(this);
+    }
+
+    /* package */ void bluetoothEnabled() {
+        bluetoothEnabled = true;
+        postValue(this);
+    }
+
+    /* package */ void bluetoothDisabled() {
+        bluetoothEnabled = false;
+        updatedDeviceIndex = null;
+        devices.clear();
+        postValue(this);
+    }
+
+    /* package */ void setLocationEnabled(final boolean enabled) {
+        locationEnabled = enabled;
+        postValue(this);
+    }
+
+    public Float[] getCurrentPattern() {
+        return currentPattern;
+    }
+
+    void setCurrentPattern(Float[] pattern) {
+        currentPattern = pattern;
+        postValue(this);
+    }
+
+    void createBond() {
+        ExtendedBluetoothDevice extendedDevice = getCurrentDevice();
+        if (extendedDevice != null) {
+            BluetoothDevice device = extendedDevice.getDevice();
+            Utils.log(Log.ASSERT, "BOUND", "Device: " + device.getName());
+            int bondState = device.getBondState();
+            Utils.log(Log.ASSERT, "BOUND", "bondState: " + bondState);
+            if (bondState == BOND_BONDED) {
+                deleteBond(device);
+            }
+            //TODO Костить
+            try {
+                Thread.sleep(1000);
+            } catch (InterruptedException e) {
+                throw new RuntimeException(e);
+            }
+            device.createBond();
+        }
+    }
+
+    private void deleteBond(BluetoothDevice device) {
+        try {
+            Method method = device.getClass().getMethod("removeBond", (Class[]) null);
+            method.invoke(device, (Object[]) null);
+        } catch (NoSuchMethodException | IllegalAccessException
+                 | InvocationTargetException e) {
+            Log.e("ERROR", e.toString());
+        }
+    }
+
+    public ExtendedBluetoothDevice getCurrentDevice() {
+        for (ExtendedBluetoothDevice device : devices) {
+            int coincide = 0;
+            for (int i = 0; i < 5; i++) {
+                char character = device.getPattern().charAt(i);
+                String patternColumn = PatternEnum.forCode(currentPattern[i]).toString();
+                if (patternColumn.contains(String.valueOf(character))) {
+                    coincide++;
+                }
+            }
+            if (coincide == 5) {
+                return device;
+            }
+        }
+        return null;
+    }
+
+    void devicesDiscovered(final List<ScanResult> results) {
+        if (results != null) {
+            devices.clear();
+            for (ScanResult result : results) {
+                deviceDiscovered(result);
+            }
+            postValue(this);
+        }
+    }
+
+    /* package */ void deviceDiscovered(final ScanResult result) {
+        if (result.getScanRecord() != null) {
+            String deviceName = result.getScanRecord().getDeviceName();
+            String address = result.getDevice().getAddress();
+
+//            Utils.log(Log.ASSERT, "SCAN", "Device name: " + deviceName + ", address: " + address);
+            if (deviceName != null) {
+//                System.out.println("Found Device: " + deviceName);
+
+                Pattern p = Pattern.compile("[a-zA-Z :]+\\u005b(([A-Z]){5})\\u005d");
+                Matcher m = p.matcher(deviceName.toUpperCase());
+
+                if (m.matches()) {
+
+                    ExtendedBluetoothDevice device;
+
+                    final int index = indexOf(result);
+                    if (index == -1) {
+                        device = new ExtendedBluetoothDevice(result);
+                        devices.add(device);
+                        updatedDeviceIndex = null;
+                    } else {
+                        device = devices.get(index);
+                        updatedDeviceIndex = index;
+                        // Update RSSI and name
+                        device.setRssi(result.getRssi());
+                        device.setName(result.getScanRecord().getDeviceName());
+                        device.setPattern(m.group(1));
+                        device.setRecentUpdate(new Date().getTime());
+                    }
+                    postValue(this);
+                }
+            }
+        }
+    }
+
+    /**
+     * Returns the list of devices.
+     *
+     * @return current list of devices discovered
+     */
+    @NonNull
+    public List<ExtendedBluetoothDevice> getDevices() {
+        return devices;
+    }
+
+    /**
+     * Returns null if a new device was added, or an index of the updated device.
+     */
+    @Nullable
+    public Integer getUpdatedDeviceIndex() {
+        final Integer i = updatedDeviceIndex;
+        updatedDeviceIndex = null;
+        return i;
+    }
+
+    /**
+     * Returns whether the list is empty.
+     */
+    public boolean isEmpty() {
+        return devices.isEmpty();
+    }
+
+    /**
+     * Returns whether scanning is in progress.
+     */
+    public boolean isScanning() {
+        return scanningStarted;
+    }
+
+    /**
+     * Returns whether Bluetooth adapter is enabled.
+     */
+    public boolean isBluetoothEnabled() {
+        return bluetoothEnabled;
+    }
+
+    /**
+     * Returns whether Location is enabled.
+     */
+    public boolean isLocationEnabled() {
+        return locationEnabled;
+    }
+
+    /**
+     * Finds the index of existing devices on the scan results list.
+     *
+     * @param result scan result
+     * @return index of -1 if not found
+     */
+    private int indexOf(final ScanResult result) {
+        int i = 0;
+        for (final ExtendedBluetoothDevice device : devices) {
+            if (device.matches(result))
+                return i;
+            i++;
+        }
+        return -1;
+    }
 }
diff --git a/app/src/main/java/cc/calliope/mini/viewmodels/ScannerViewModel.java b/app/src/main/java/cc/calliope/mini/viewmodels/ScannerViewModel.java
index 6691617..dfa8c83 100644
--- a/app/src/main/java/cc/calliope/mini/viewmodels/ScannerViewModel.java
+++ b/app/src/main/java/cc/calliope/mini/viewmodels/ScannerViewModel.java
@@ -31,163 +31,240 @@
 package cc.calliope.mini.viewmodels;
 
 import android.app.Application;
-import android.arch.lifecycle.AndroidViewModel;
 import android.bluetooth.BluetoothAdapter;
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
+import android.content.SharedPreferences;
 import android.location.LocationManager;
-import android.os.ParcelUuid;
+import android.util.Log;
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.UUID;
-import java.util.regex.Pattern;
+import java.util.Timer;
+import java.util.TimerTask;
 
-import cc.calliope.mini.profile.BlinkyManager;
+import androidx.annotation.NonNull;
+import androidx.lifecycle.AndroidViewModel;
+import androidx.preference.PreferenceManager;
+import cc.calliope.mini.App;
 import cc.calliope.mini.utils.Utils;
+import cc.calliope.mini.utils.Version;
 import no.nordicsemi.android.support.v18.scanner.BluetoothLeScannerCompat;
 import no.nordicsemi.android.support.v18.scanner.ScanCallback;
 import no.nordicsemi.android.support.v18.scanner.ScanFilter;
 import no.nordicsemi.android.support.v18.scanner.ScanResult;
 import no.nordicsemi.android.support.v18.scanner.ScanSettings;
 
-import static cc.calliope.mini.profile.BlinkyManager.LBS_UUID_SERVICE;
+import static cc.calliope.mini.App.APP_STATE_FLASHING;
 
 public class ScannerViewModel extends AndroidViewModel {
 
-	/** MutableLiveData containing the scanner state to notify MainActivity. */
-	private final ScannerLiveData mScannerLiveData;
-
-	public ScannerLiveData getScannerState() {
-		return mScannerLiveData;
-	}
-
-	public ScannerViewModel(final Application application) {
-		super(application);
-
-		mScannerLiveData = new ScannerLiveData(Utils.isBleEnabled(), Utils.isLocationEnabled(application));
-		registerBroadcastReceivers(application);
-	}
-
-	@Override
-	protected void onCleared() {
-		super.onCleared();
-		getApplication().unregisterReceiver(mBluetoothStateBroadcastReceiver);
-
-		if (Utils.isMarshmallowOrAbove()) {
-			getApplication().unregisterReceiver(mLocationProviderChangedReceiver);
-		}
-	}
-
-	public void refresh() {
-		mScannerLiveData.refresh();
-	}
-
-	/**
-	 * Start scanning for Bluetooth devices.
-	 */
-	public void startScan() {
-		if (mScannerLiveData.isScanning()) {
-			return;
-		}
-
-		// Scanning settings
-		final ScanSettings settings = new ScanSettings.Builder()
-				.setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY)
-				// Refresh the devices list every second
-				.setReportDelay(0)
-				// Hardware filtering has some issues on selected devices
-				.setUseHardwareFilteringIfSupported(false)
-				// Samsung S6 and S6 Edge report equal value of RSSI for all devices. In this app we ignore the RSSI.
-					/*.setUseHardwareBatchingIfSupported(false)*/
-				.build();
-
-		// Let's use the filter to scan only for Blinky devices
-		final ParcelUuid uuid = new ParcelUuid(LBS_UUID_SERVICE);
-		final List<ScanFilter> filters = new ArrayList<>();
+    // For checking the availability of the device.
+    // If there is no one device in the bluetooth visibility range callback not working.
+    private Timer timer;
+    private static final int REFRESH_PERIOD = 3000;
+
+    /**
+     * MutableLiveData containing the scanner state to notify MainActivity.
+     */
+    private final ScannerLiveData mScannerLiveData;
+
+    public ScannerLiveData getScannerState() {
+        return mScannerLiveData;
+    }
+
+    public ScannerViewModel(final Application application) {
+        super(application);
+
+        mScannerLiveData = new ScannerLiveData(Utils.isBluetoothEnabled(),
+                Utils.isLocationEnabled(application) || Version.VERSION_S_AND_NEWER);
+        registerBroadcastReceivers(application);
+        loadPattern();
+    }
+
+    @Override
+    protected void onCleared() {
+        super.onCleared();
+        Application application = getApplication();
+
+        application.unregisterReceiver(mBluetoothStateBroadcastReceiver);
+
+        if (Version.VERSION_M_AND_NEWER) {
+            application.unregisterReceiver(mLocationProviderChangedReceiver);
+        }
+    }
+
+    public void refresh() {
+        mScannerLiveData.refresh();
+    }
+
+    /**
+     * Start scanning for Bluetooth devices.
+     */
+    public void startScan() {
+        Log.e("SCANNER", "### " + Thread.currentThread().getId() + " # " + "startScan()");
+        boolean isFlashing = ((App) getApplication()).getAppState() == APP_STATE_FLASHING;
+        if (mScannerLiveData.isScanning() || !mScannerLiveData.isBluetoothEnabled() || isFlashing) {
+            return;
+        }
+
+        startTimer();
+
+        // Scanning settings
+        final ScanSettings settings = new ScanSettings.Builder()
+                .setScanMode(ScanSettings.SCAN_MODE_BALANCED)
+                // Refresh the devices list every 5000 ms (5 sec)
+                .setReportDelay(0)
+                // Hardware filtering has some issues on selected devices
+                .setUseHardwareFilteringIfSupported(false)
+                // Samsung S6 and S6 Edge report equal value of RSSI for all devices. In this app we ignore the RSSI.
+                /*.setUseHardwareBatchingIfSupported(false)*/
+                .build();
+
+        // Let's use the filter to scan only for Blinky devices
+//		final ParcelUuid uuid = new ParcelUuid(LBS_UUID_SERVICE);
+        final List<ScanFilter> filters = new ArrayList<>();
 //		filters.add(new ScanFilter.Builder().setServiceUuid(uuid).build());
 //		filters.add(new ScanFilter.Builder().setDeviceName(Pattern.compile("\\u005b([a-z]){5}\\u005d")).build());
 
-		final BluetoothLeScannerCompat scanner = BluetoothLeScannerCompat.getScanner();
-		scanner.startScan(filters, settings, scanCallback);
-		mScannerLiveData.scanningStarted();
-	}
-
-	/**
-	 * stop scanning for bluetooth devices.
-	 */
-	public void stopScan() {
-		final BluetoothLeScannerCompat scanner = BluetoothLeScannerCompat.getScanner();
-		scanner.stopScan(scanCallback);
-		mScannerLiveData.scanningStopped();
-	}
-
-	private final ScanCallback scanCallback = new ScanCallback() {
-		@Override
-		public void onScanResult(final int callbackType, final ScanResult result) {
-			// If the packet has been obtained while Location was disabled, mark Location as not required
-			if (Utils.isLocationRequired(getApplication()) && !Utils.isLocationEnabled(getApplication()))
-				Utils.markLocationNotRequired(getApplication());
-
-			mScannerLiveData.deviceDiscovered(result);
-		}
-
-		@Override
-		public void onBatchScanResults(final List<ScanResult> results) {
-			// Batch scan is disabled (report delay = 0)
-		}
-
-		@Override
-		public void onScanFailed(final int errorCode) {
-			// TODO This should be handled
-			mScannerLiveData.scanningStopped();
-		}
-	};
-
-	/**
-	 * Register for required broadcast receivers.
-	 */
-	private void registerBroadcastReceivers(final Application application) {
-		application.registerReceiver(mBluetoothStateBroadcastReceiver, new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED));
-		if (Utils.isMarshmallowOrAbove()) {
-			application.registerReceiver(mLocationProviderChangedReceiver, new IntentFilter(LocationManager.MODE_CHANGED_ACTION));
-		}
-	}
-
-	/**
-	 * Broadcast receiver to monitor the changes in the location provider
-	 */
-	private final BroadcastReceiver mLocationProviderChangedReceiver = new BroadcastReceiver() {
-		@Override
-		public void onReceive(final Context context, final Intent intent) {
-			final boolean enabled = Utils.isLocationEnabled(context);
-			mScannerLiveData.setLocationEnabled(enabled);
-		}
-	};
-
-	/**
-	 * Broadcast receiver to monitor the changes in the bluetooth adapter
-	 */
-	private final BroadcastReceiver mBluetoothStateBroadcastReceiver = new BroadcastReceiver() {
-		@Override
-		public void onReceive(final Context context, final Intent intent) {
-			final int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.STATE_OFF);
-			final int previousState = intent.getIntExtra(BluetoothAdapter.EXTRA_PREVIOUS_STATE, BluetoothAdapter.STATE_OFF);
-
-			switch (state) {
-				case BluetoothAdapter.STATE_ON:
-					mScannerLiveData.bluetoothEnabled();
-					break;
-				case BluetoothAdapter.STATE_TURNING_OFF:
-				case BluetoothAdapter.STATE_OFF:
-					if (previousState != BluetoothAdapter.STATE_TURNING_OFF && previousState != BluetoothAdapter.STATE_OFF) {
-						stopScan();
-						mScannerLiveData.bluetoothDisabled();
-					}
-					break;
-			}
-		}
-	};
+        final BluetoothLeScannerCompat scanner = BluetoothLeScannerCompat.getScanner();
+        scanner.startScan(filters, settings, scanCallback);
+        mScannerLiveData.scanningStarted();
+    }
+
+    /**
+     * stop scanning for bluetooth devices.
+     */
+    public void stopScan() {
+        stopTimer();
+        Log.e("SCANNER", "### " + Thread.currentThread().getId() + " # " + "stopScan()");
+        final BluetoothLeScannerCompat scanner = BluetoothLeScannerCompat.getScanner();
+        scanner.stopScan(scanCallback);
+        mScannerLiveData.scanningStopped();
+        savePattern();
+    }
+
+    private final ScanCallback scanCallback = new ScanCallback() {
+        @Override
+        public void onScanResult(final int callbackType, @NonNull final ScanResult result) {
+
+            //TODO Are we need it?
+//			if (Utils.isLocationRequired(getApplication()) && !Utils.isLocationEnabled(getApplication())) {
+//                Utils.markLocationNotRequired(getApplication());
+//            }
+
+            mScannerLiveData.deviceDiscovered(result);
+        }
+
+        @Override
+        public void onBatchScanResults(@NonNull final List<ScanResult> results) {
+            // If the packet has been obtained while Location was disabled, mark Location as not required
+//            mScannerLiveData.devicesDiscovered(results);
+        }
+
+        @Override
+        public void onScanFailed(final int errorCode) {
+            // TODO This should be handled
+            Log.e("SCANNER", "### " + Thread.currentThread().getId() + " # " + "onScanFailed(), errorCode: " + errorCode);
+            stopScan();
+//            mScannerLiveData.scanningStopped();
+        }
+    };
+
+    public void setCurrentPattern(Float[] pattern) {
+        mScannerLiveData.setCurrentPattern(pattern);
+    }
+
+    public void createBond(){
+        mScannerLiveData.createBond();
+    }
+
+    /**
+     * Register for required broadcast receivers.
+     */
+    private void registerBroadcastReceivers(final Application application) {
+        application.registerReceiver(mBluetoothStateBroadcastReceiver, new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED));
+        if (Version.VERSION_M_AND_NEWER) {
+            application.registerReceiver(mLocationProviderChangedReceiver, new IntentFilter(LocationManager.MODE_CHANGED_ACTION));
+        }
+    }
+
+    /**
+     * Broadcast receiver to monitor the changes in the location provider
+     */
+    private final BroadcastReceiver mLocationProviderChangedReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(final Context context, final Intent intent) {
+            final boolean enabled = Utils.isLocationEnabled(context);
+            mScannerLiveData.setLocationEnabled(enabled);
+        }
+    };
+
+    /**
+     * Broadcast receiver to monitor the changes in the bluetooth adapter
+     */
+    private final BroadcastReceiver mBluetoothStateBroadcastReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(final Context context, final Intent intent) {
+            final int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.STATE_OFF);
+            final int previousState = intent.getIntExtra(BluetoothAdapter.EXTRA_PREVIOUS_STATE, BluetoothAdapter.STATE_OFF);
+
+            switch (state) {
+                case BluetoothAdapter.STATE_ON:
+                    startScan();
+                    mScannerLiveData.bluetoothEnabled();
+                    break;
+                case BluetoothAdapter.STATE_TURNING_OFF:
+                case BluetoothAdapter.STATE_OFF:
+                    if (previousState != BluetoothAdapter.STATE_TURNING_OFF && previousState != BluetoothAdapter.STATE_OFF) {
+                        stopScan();
+                        mScannerLiveData.bluetoothDisabled();
+                    }
+                    break;
+            }
+        }
+    };
+
+    public void savePattern() {
+        Float[] currentPattern = mScannerLiveData.getCurrentPattern();
+        if (currentPattern != null) {
+            SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(getApplication());
+            SharedPreferences.Editor edit = sharedPreferences.edit();
+            for (int i = 0; i < 5; i++) {
+                edit.putFloat("PATTERN_" + i, currentPattern[i]);
+            }
+            edit.apply();
+        }
+    }
+
+    public void loadPattern() {
+        Float[] currentPattern = {0f, 0f, 0f, 0f, 0f};
+        SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(getApplication());
+        for (int i = 0; i < 5; i++) {
+            currentPattern[i] = preferences.getFloat("PATTERN_" + i, 0f);
+        }
+        mScannerLiveData.setCurrentPattern(currentPattern);
+    }
+
+    public void startTimer() {
+        stopTimer();
+        timer = new Timer();
+        timer.schedule(new TimerTask() {
+            @Override
+            public void run() {
+                refresh();
+//                Log.w("Timer", "### " + Thread.currentThread().getId() + " # " + "scannerViewModel.refresh()");
+            }
+        }, 0, REFRESH_PERIOD);
+        Log.d("Timer", "### " + Thread.currentThread().getId() + " # " + "timer: " + timer);
+    }
+
+    public void stopTimer() {
+        if (timer != null) {
+            timer.cancel();
+            timer.purge();
+        }
+    }
 }
diff --git a/app/src/main/java/cc/calliope/mini/viewmodels/SingleLiveEvent.java b/app/src/main/java/cc/calliope/mini/viewmodels/SingleLiveEvent.java
deleted file mode 100644
index 785fdb7..0000000
--- a/app/src/main/java/cc/calliope/mini/viewmodels/SingleLiveEvent.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- *  Copyright 2017 Google Inc.
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package cc.calliope.mini.viewmodels;
-
-import android.arch.lifecycle.LifecycleOwner;
-import android.arch.lifecycle.MutableLiveData;
-import android.arch.lifecycle.Observer;
-import android.support.annotation.MainThread;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.util.Log;
-
-import java.util.concurrent.atomic.AtomicBoolean;
-
-/**
- * A lifecycle-aware observable that sends only new updates after subscription, used for events like
- * navigation and Snackbar messages.
- * <p>
- * This avoids a common problem with events: on configuration change (like rotation) an update
- * can be emitted if the observer is active. This LiveData only calls the observable if there's an
- * explicit call to setValue() or call().
- * <p>
- * Note that only one observer is going to be notified of changes.
- */
-@SuppressWarnings("unused")
-public class SingleLiveEvent<T> extends MutableLiveData<T> {
-
-    private static final String TAG = "SingleLiveEvent";
-
-    private final AtomicBoolean mPending = new AtomicBoolean(false);
-
-    @MainThread
-    public void observe(@NonNull final LifecycleOwner owner, @NonNull final Observer<T> observer) {
-        if (hasActiveObservers()) {
-            Log.w(TAG, "Multiple observers registered but only one will be notified of changes.");
-        }
-
-        // Observe the internal MutableLiveData
-        super.observe(owner, t -> {
-			if (mPending.compareAndSet(true, false)) {
-				observer.onChanged(t);
-			}
-		});
-    }
-
-    @MainThread
-    public void setValue(@Nullable final T t) {
-        mPending.set(true);
-        super.setValue(t);
-    }
-
-    /**
-     * Used for cases where T is Void, to make calls cleaner.
-     */
-    @MainThread
-    public void call() {
-        setValue(null);
-    }
-}
diff --git a/app/src/main/java/cc/calliope/mini/views/BoardProgressBar.java b/app/src/main/java/cc/calliope/mini/views/BoardProgressBar.java
new file mode 100644
index 0000000..9f49121
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/views/BoardProgressBar.java
@@ -0,0 +1,37 @@
+package cc.calliope.mini.views;
+
+import android.content.Context;
+import android.util.AttributeSet;
+
+import androidx.annotation.Nullable;
+import cc.calliope.mini.service.DfuService;
+
+public class BoardProgressBar extends BoardView {
+
+    public BoardProgressBar(Context context) {
+        super(context);
+    }
+
+    public BoardProgressBar(Context context, @Nullable AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    public BoardProgressBar(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+    }
+
+    public void setProgress(int progress) {
+        if (progress == DfuService.PROGRESS_COMPLETED) {
+            turnedOnAllLed(true);
+//            setLed(true, 2, 3, 4, 6, 10, 17, 19);
+        } else {
+            int p = Math.max(progress, 0);
+            int max = p / 4;
+
+            for (int i = 0; i <= max; i++) {
+                turnedOnLed(true, i);
+            }
+        }
+        invalidate();
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/views/BoardView.java b/app/src/main/java/cc/calliope/mini/views/BoardView.java
new file mode 100644
index 0000000..9afd564
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/views/BoardView.java
@@ -0,0 +1,135 @@
+package cc.calliope.mini.views;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.LayerDrawable;
+import android.util.AttributeSet;
+import android.view.View;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.util.Arrays;
+
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
+import androidx.core.content.res.ResourcesCompat;
+import cc.calliope.mini.R;
+
+public class BoardView extends View {
+
+    //TODO колгосп?
+    @IntDef({
+            1,  2,  3,  4,  5,
+            6,  7,  8,  9,  10,
+            11, 12, 13, 14, 15,
+            16, 17, 18, 19, 20,
+            21, 22, 23, 24, 25
+    })
+    @Retention(RetentionPolicy.SOURCE)
+    public @interface LedRange {}
+    private int aspectRatioWidth = 1;
+    private int aspectRatioHeight = 1;
+    private Drawable drawable;
+    private final boolean[] ledArray = new boolean[26];
+
+    public BoardView(Context context) {
+        super(context);
+        init();
+    }
+
+    public BoardView(Context context, @Nullable AttributeSet attrs) {
+        super(context, attrs);
+        init();
+    }
+
+    public BoardView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+        init();
+    }
+
+    private void init() {
+        setImageResource(R.drawable.layers_board);
+        turnedOnAllLed(false);
+    }
+
+    public void setImageResource(int resId) {
+        drawable = ResourcesCompat.getDrawable(getResources(), resId, null);
+    }
+
+    public void turnedOnLed(boolean turnedOn, @LedRange int led) {
+        if (led > 0 && led < ledArray.length) {
+            ledArray[led] = turnedOn;
+        }
+    }
+
+    public void turnedOnLed(boolean turnedOn, @LedRange int... led) {
+        for (int j : led) {
+            if (j > 0 && j < ledArray.length) {
+                ledArray[j] = turnedOn;
+            }
+        }
+    }
+
+    public void turnedOnAllLed(boolean turnedOn) {
+        Arrays.fill(ledArray, turnedOn);
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        int originalWidth = MeasureSpec.getSize(widthMeasureSpec);
+        int originalHeight = MeasureSpec.getSize(heightMeasureSpec);
+        int calculatedHeight = originalWidth * aspectRatioHeight / aspectRatioWidth;
+
+        int finalWidth, finalHeight;
+        finalWidth = originalWidth;
+        finalHeight = calculatedHeight;
+        if (calculatedHeight > originalHeight) {
+            finalHeight = originalHeight;
+            finalWidth = originalHeight * aspectRatioWidth / aspectRatioHeight;
+        }
+
+        super.onMeasure(
+                MeasureSpec.makeMeasureSpec(finalWidth, MeasureSpec.EXACTLY),
+                MeasureSpec.makeMeasureSpec(finalHeight, MeasureSpec.EXACTLY)
+        );
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        if (drawable instanceof LayerDrawable) {
+            int width = getWidth();
+            int height = getHeight();
+            LayerDrawable layerDrawable = (LayerDrawable) drawable;
+
+            Drawable background = layerDrawable.findDrawableByLayerId(R.id.background);
+            background.setBounds(0, 0, width, height);
+            background.draw(canvas);
+
+            int max = Math.min(ledArray.length, layerDrawable.getNumberOfLayers());
+
+            for (int i = 1; i < max; i++) {
+                if (ledArray[i]) {
+                    Drawable layer = layerDrawable.getDrawable(i);
+                    layer.setBounds(0, 0, width, height);
+                    layer.draw(canvas);
+                }
+            }
+        }
+        super.onDraw(canvas);
+    }
+
+    public void setAspectRatio(int aspectRatioWidth, int aspectRatioHeight) {
+        this.aspectRatioWidth = aspectRatioWidth;
+        this.aspectRatioHeight = aspectRatioHeight;
+        requestLayout();
+    }
+
+    public int getAspectRatioWidth() {
+        return aspectRatioWidth;
+    }
+
+    public int getAspectRatioHeight() {
+        return aspectRatioHeight;
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/views/FobParams.java b/app/src/main/java/cc/calliope/mini/views/FobParams.java
new file mode 100644
index 0000000..b4bfb90
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/views/FobParams.java
@@ -0,0 +1,75 @@
+package cc.calliope.mini.views;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+public class FobParams implements Parcelable {
+    int w;
+    int h;
+    float x;
+    float y;
+
+    public static final Creator<FobParams> CREATOR = new Creator<FobParams>() {
+        @Override
+        public FobParams createFromParcel(Parcel in) {
+            return new FobParams(in);
+        }
+
+        @Override
+        public FobParams[] newArray(int size) {
+            return new FobParams[size];
+        }
+    };
+
+    public FobParams(int w, int h, float x, float y) {
+        this.w = w;
+        this.h = h;
+        this.x = x;
+        this.y = y;
+    }
+
+    private FobParams(Parcel in) {
+        this.w = in.readInt();
+        this.h = in.readInt();
+        this.x = in.readFloat();
+        this.y = in.readFloat();
+    }
+
+    public int getW() {
+        return w;
+    }
+
+    public int getH() {
+        return h;
+    }
+
+    public float getX() {
+        return x;
+    }
+
+    public float getY() {
+        return y;
+    }
+
+    public int getCenterX() {
+        return Math.round(x) + w / 2;
+    }
+
+    public int getCenterY() {
+        return Math.round(y) + h / 2;
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(w);
+        dest.writeInt(h);
+        dest.writeFloat(x);
+        dest.writeFloat(y);
+    }
+
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/views/MovableFloatingActionButton.java b/app/src/main/java/cc/calliope/mini/views/MovableFloatingActionButton.java
new file mode 100644
index 0000000..75c698e
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/views/MovableFloatingActionButton.java
@@ -0,0 +1,286 @@
+package cc.calliope.mini.views;
+
+import android.bluetooth.BluetoothDevice;
+import android.content.Context;
+import android.content.res.ColorStateList;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.RectF;
+import android.util.AttributeSet;
+import android.util.TypedValue;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.google.android.material.floatingactionbutton.FloatingActionButton;
+
+import androidx.annotation.NonNull;
+
+import cc.calliope.mini.ProgressCollector;
+import cc.calliope.mini.ProgressListener;
+import cc.calliope.mini.R;
+import cc.calliope.mini.utils.Utils;
+import cc.calliope.mini.utils.Version;
+
+public class MovableFloatingActionButton extends FloatingActionButton implements View.OnTouchListener, ProgressListener {
+    private final static float CLICK_DRAG_TOLERANCE = 10; // Often, there will be a slight, unintentional, drag when the user taps the FAB, so we need to account for this.
+    private float downRawX, downRawY;
+    private float dX, dY;
+    private Paint paint;
+    private RectF rectF;
+
+    private int actionBarSize;
+    private int progress = 0;
+    private Context context;
+    private ProgressCollector progressCollector;
+//    private boolean flashing;
+
+    public MovableFloatingActionButton(Context context) {
+        super(context);
+        init(context);
+    }
+
+    public MovableFloatingActionButton(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        init(context);
+    }
+
+    public MovableFloatingActionButton(Context context, AttributeSet attrs, int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+        init(context);
+    }
+
+    private void init(Context context) {
+        this.context = context;
+        progressCollector = new ProgressCollector(context);
+        progressCollector.registerOnProgressListener(this);
+        setOnTouchListener(this);
+        paint = new Paint();
+        rectF = new RectF();
+
+        TypedValue typedValue = new TypedValue();
+        if (getContext().getTheme().resolveAttribute(android.R.attr.actionBarSize, typedValue, true)) {
+            actionBarSize = TypedValue.complexToDimensionPixelSize(typedValue.data, getResources().getDisplayMetrics());
+        }
+
+        setOnSystemUiVisibilityChangeListener(this::onFullscreenStateChanged);
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+//        setProgress(0);
+        progressCollector.registerReceivers();
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+        progressCollector.unregisterReceivers();
+    }
+
+    @Override
+    public boolean onTouch(View view, MotionEvent motionEvent) {
+        ViewGroup.MarginLayoutParams layoutParams = (ViewGroup.MarginLayoutParams) view.getLayoutParams();
+
+        int action = motionEvent.getAction();
+        if (action == MotionEvent.ACTION_DOWN) {
+
+            downRawX = motionEvent.getRawX();
+            downRawY = motionEvent.getRawY();
+            dX = view.getX() - downRawX;
+            dY = view.getY() - downRawY;
+
+            return true; // Consumed
+
+        } else if (action == MotionEvent.ACTION_MOVE) {
+
+            int viewWidth = view.getWidth();
+            int viewHeight = view.getHeight();
+
+            View viewParent = (View) view.getParent();
+            int parentWidth = viewParent.getWidth();
+            int parentHeight = viewParent.getHeight();
+
+            float newX = motionEvent.getRawX() + dX;
+            newX = Math.max(layoutParams.leftMargin, newX); // Don't allow the FAB past the left hand side of the parent
+            newX = Math.min(parentWidth - viewWidth - layoutParams.rightMargin, newX); // Don't allow the FAB past the right hand side of the parent
+
+            float newY = motionEvent.getRawY() + dY;
+            newY = Math.max(layoutParams.topMargin, newY); // Don't allow the FAB past the top of the parent
+            newY = Math.min(parentHeight - viewHeight - layoutParams.bottomMargin, newY); // Don't allow the FAB past the bottom of the parent
+
+            view.animate()
+                    .x(newX)
+                    .y(newY)
+                    .setDuration(0)
+                    .start();
+
+            return true; // Consumed
+
+        } else if (action == MotionEvent.ACTION_UP) {
+
+            float upRawX = motionEvent.getRawX();
+            float upRawY = motionEvent.getRawY();
+
+            float upDX = upRawX - downRawX;
+            float upDY = upRawY - downRawY;
+
+            if (Math.abs(upDX) < CLICK_DRAG_TOLERANCE && Math.abs(upDY) < CLICK_DRAG_TOLERANCE) { // A click
+                return performClick();
+            } else { // A drag
+                return true; // Consumed
+            }
+
+        } else {
+            return super.onTouchEvent(motionEvent);
+        }
+
+    }
+
+    @Override
+    public void onDeviceConnecting() {
+        setProgress(0);
+    }
+
+    @Override
+    public void onProcessStarting() {
+        setProgress(0);
+    }
+
+    @Override
+    public void onEnablingDfuMode() {
+        setProgress(0);
+    }
+
+    @Override
+    public void onFirmwareValidating() {
+        setProgress(0);
+    }
+
+    @Override
+    public void onDeviceDisconnecting() {
+        setProgress(0);
+    }
+
+    @Override
+    public void onCompleted() {
+        setProgress(0);
+    }
+
+    @Override
+    public void onAborted() {
+        setProgress(0);
+    }
+
+    @Override
+    public void onProgressChanged(int percent) {
+        setProgress(percent);
+    }
+
+    @Override
+    public void onBonding(@NonNull BluetoothDevice device, int bondState, int previousBondState) {
+    }
+
+    @Override
+    public void onAttemptDfuMode() {
+    }
+
+    @Override
+    public void onStartDfuService(int hardwareVersion) {
+    }
+
+    @Override
+    public void onError(int code, String message) {
+        setProgress(0);
+    }
+
+    public void setProgress(int percent) {
+        this.progress = Math.max(percent, 0);
+        boolean flashing = percent > -5;
+        if (flashing) {
+            setColor(R.color.green);
+        }
+        invalidate();
+    }
+
+    public void setColor(int resId) {
+        int color;
+        if (Version.VERSION_M_AND_NEWER) {
+            color = context.getColor(resId);
+        } else {
+            color = getResources().getColor(resId);
+        }
+        setBackgroundTintList(ColorStateList.valueOf(color));
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        int strokeWidth = Utils.convertDpToPixel(getContext(), 4);
+        int width = getWidth();
+        int height = getHeight();
+        int sweepAngle = (int) (360 * (progress / 100.f));
+
+        rectF.set(strokeWidth / 2.f, strokeWidth / 2.f, width - strokeWidth / 2.f, height - strokeWidth / 2.f);
+
+        paint.setColor(Color.WHITE);
+        paint.setStrokeWidth(strokeWidth);
+        paint.setStyle(Paint.Style.STROKE);
+
+        canvas.drawArc(rectF, 270, sweepAngle, false, paint);
+
+        super.onDraw(canvas);
+    }
+
+    public void moveUp() {
+        int x = Math.round(getX());
+        int y = Math.round(getY());
+        if (y > actionBarSize && y < actionBarSize * 2) {
+            animate()
+                    .x(x)
+                    .y(y - actionBarSize)
+                    .setDuration(0)
+                    .start();
+        }
+    }
+
+    public void moveDown() {
+        int x = Math.round(getX());
+        int y = Math.round(getY());
+        if (y < actionBarSize) {
+            animate()
+                    .x(x)
+                    .y(y + actionBarSize)
+                    .setDuration(0)
+                    .start();
+        }
+    }
+
+    private void onFullscreenStateChanged(int visibility) {
+        boolean fullScreen = (visibility & View.SYSTEM_UI_FLAG_FULLSCREEN) != 0;
+        if (!fullScreen) {
+            ViewGroup.MarginLayoutParams layoutParams = (ViewGroup.MarginLayoutParams) getLayoutParams();
+            View viewParent = (View) getParent();
+            int parentWidth = viewParent.getWidth();
+            int parentHeight = viewParent.getHeight();
+            int x = Math.round(getX());
+            int y = Math.round(getY());
+
+            if (x + actionBarSize > parentWidth) {
+                animate()
+                        .x(parentWidth - actionBarSize - layoutParams.rightMargin)
+                        .y(y)
+                        .setDuration(0)
+                        .start();
+            }
+            if (y + actionBarSize > parentHeight) {
+                animate()
+                        .x(x)
+                        .y(parentHeight - actionBarSize - layoutParams.bottomMargin)
+                        .setDuration(0)
+                        .start();
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/views/SimpleDividerItemDecoration.java b/app/src/main/java/cc/calliope/mini/views/SimpleDividerItemDecoration.java
new file mode 100644
index 0000000..1570ea3
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/views/SimpleDividerItemDecoration.java
@@ -0,0 +1,38 @@
+package cc.calliope.mini.views;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.drawable.Drawable;
+import android.view.View;
+
+import androidx.annotation.NonNull;
+import androidx.core.content.ContextCompat;
+import androidx.recyclerview.widget.RecyclerView;
+import cc.calliope.mini.R;
+
+public class SimpleDividerItemDecoration extends RecyclerView.ItemDecoration {
+    private final Drawable drawable;
+ 
+    public SimpleDividerItemDecoration(Context context) {
+        drawable = ContextCompat.getDrawable(context, R.drawable.line_divider);
+    }
+ 
+    @Override
+    public void onDrawOver(@NonNull Canvas canvas, RecyclerView parent, @NonNull RecyclerView.State state) {
+        int left = Math.round(parent.getResources().getDimension(R.dimen.vertical_margin));
+        int right = parent.getWidth() - left;
+ 
+        int childCount = parent.getChildCount();
+        for (int i = 0; i < childCount; i++) {
+            View child = parent.getChildAt(i);
+ 
+            RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams();
+ 
+            int top = child.getBottom() + params.bottomMargin;
+            int bottom = top + drawable.getIntrinsicHeight();
+ 
+            drawable.setBounds(left, top, right, bottom);
+            drawable.draw(canvas);
+        }
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/cc/calliope/mini/views/SvgPatternBar.java b/app/src/main/java/cc/calliope/mini/views/SvgPatternBar.java
new file mode 100644
index 0000000..c6297c5
--- /dev/null
+++ b/app/src/main/java/cc/calliope/mini/views/SvgPatternBar.java
@@ -0,0 +1,225 @@
+package cc.calliope.mini.views;
+
+import android.annotation.SuppressLint;
+import android.app.Activity;
+import android.content.Context;
+import android.content.ContextWrapper;
+import android.content.SharedPreferences;
+import android.content.res.TypedArray;
+import android.graphics.Bitmap;
+import android.graphics.BitmapShader;
+import android.graphics.Canvas;
+import android.graphics.Shader;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.ClipDrawable;
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.LayerDrawable;
+import android.graphics.drawable.ShapeDrawable;
+import android.graphics.drawable.VectorDrawable;
+import android.graphics.drawable.shapes.RoundRectShape;
+import android.graphics.drawable.shapes.Shape;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.Gravity;
+import android.widget.RatingBar;
+
+import androidx.appcompat.graphics.drawable.DrawableWrapper;
+import androidx.appcompat.widget.AppCompatRatingBar;
+import androidx.preference.PreferenceManager;
+import androidx.vectordrawable.graphics.drawable.VectorDrawableCompat;
+
+import java.lang.reflect.Method;
+
+import cc.calliope.mini.R;
+import cc.calliope.mini.utils.Utils;
+
+public class SvgPatternBar extends AppCompatRatingBar {
+    private Bitmap sampleTile;
+    private int column;
+
+    public SvgPatternBar(Context context) {
+        this(context, null);
+    }
+
+    public SvgPatternBar(Context context, AttributeSet attrs) {
+        this(context, attrs, androidx.appcompat.R.attr.ratingBarStyle);
+    }
+
+    public SvgPatternBar(Context context, AttributeSet attrs, int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+
+        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.SvgPatternBar);
+        String methodName;
+        try {
+            column = a.getInteger(R.styleable.SvgPatternBar_column, 0); // Default value is 0
+            methodName = a.getString(R.styleable.SvgPatternBar_onChange);
+        } finally {
+            a.recycle();
+        }
+
+        if (methodName != null) {
+            setOnChangeListener(new DeclaredOnChangeListener(methodName, column));
+        }
+
+        init();
+    }
+
+    private void init() {
+        LayerDrawable drawable = (LayerDrawable) createTile(getProgressDrawable(), false);
+        setProgressDrawable(drawable);
+        setValue(loadValue());
+    }
+
+    private class DeclaredOnChangeListener implements OnRatingBarChangeListener {
+        private final String methodName;
+        private final int column;
+
+        public DeclaredOnChangeListener(String methodName, int column) {
+            this.methodName = methodName;
+            this.column = column;
+        }
+
+        @Override
+        public void onRatingChanged(RatingBar ratingBar, float value, boolean fromUser) {
+            Activity activity = getActivity();
+            if (value < 1.0f) {
+                value = 1.0f;
+                ratingBar.setRating(value);
+            }
+
+            if (activity == null) {
+                return;
+            }
+
+            try {
+                Utils.log(Log.ASSERT, "TEST", "Context: " + getContext());
+                Method method = activity.getClass().getMethod(methodName, int.class, float.class);
+                method.invoke(activity, column, value);
+                saveValue(value);
+            } catch (Exception e) {
+                throw new IllegalStateException("Could not execute non-public method " + methodName + " for onChange", e);
+            }
+        }
+    }
+
+    private Activity getActivity() {
+        Context context = getContext();
+        while (context instanceof ContextWrapper) {
+            if (context instanceof Activity) {
+                return (Activity) context;
+            }
+            context = ((ContextWrapper) context).getBaseContext();
+        }
+        return null;
+    }
+
+    public void setOnChangeListener(OnRatingBarChangeListener listener) {
+        super.setOnRatingBarChangeListener(listener);
+    }
+
+    /**
+     * Converts a drawable to a tiled version of itself. It will recursively
+     * traverse layer and state list drawables.
+     */
+    @SuppressLint("RestrictedApi")
+    private Drawable createTile(Drawable drawable, boolean clip) {
+        if (drawable instanceof DrawableWrapper) {
+            Drawable inner = ((DrawableWrapper) drawable).getWrappedDrawable();
+            if (inner != null) {
+                inner = createTile(inner, clip);
+                ((DrawableWrapper) drawable).setWrappedDrawable(inner);
+            }
+        } else if (drawable instanceof LayerDrawable) {
+            LayerDrawable background = (LayerDrawable) drawable;
+            final int n = background.getNumberOfLayers();
+            Drawable[] outDrawables = new Drawable[n];
+
+            for (int i = 0; i < n; i++) {
+                int id = background.getId(i);
+                outDrawables[i] = createTile(background.getDrawable(i),
+                        (id == android.R.id.progress || id == android.R.id.secondaryProgress));
+            }
+            LayerDrawable newBg = new LayerDrawable(outDrawables);
+
+            for (int i = 0; i < n; i++) {
+                newBg.setId(i, background.getId(i));
+            }
+
+            return newBg;
+
+        } else if (drawable instanceof BitmapDrawable) {
+            final BitmapDrawable bitmapDrawable = (BitmapDrawable) drawable;
+            final Bitmap tileBitmap = bitmapDrawable.getBitmap();
+            if (sampleTile == null) {
+                sampleTile = tileBitmap;
+            }
+
+            final ShapeDrawable shapeDrawable = new ShapeDrawable(getDrawableShape());
+            final BitmapShader bitmapShader = new BitmapShader(tileBitmap,
+                    Shader.TileMode.REPEAT, Shader.TileMode.CLAMP);
+            shapeDrawable.getPaint().setShader(bitmapShader);
+            shapeDrawable.getPaint().setColorFilter(bitmapDrawable.getPaint().getColorFilter());
+            return (clip) ? new ClipDrawable(shapeDrawable, Gravity.START,
+                    ClipDrawable.HORIZONTAL) : shapeDrawable;
+        } else if (drawable instanceof VectorDrawable) {
+            return createTile(getBitmapDrawableFromVectorDrawable(drawable), clip);
+        } else if (drawable instanceof VectorDrawableCompat) {
+            // API 19 support.
+            return createTile(getBitmapDrawableFromVectorDrawable(drawable), clip);
+        }
+        return drawable;
+    }
+
+    private BitmapDrawable getBitmapDrawableFromVectorDrawable(Drawable drawable) {
+        Bitmap bitmap = Bitmap.createBitmap(drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight(), Bitmap.Config.ARGB_8888);
+        Canvas canvas = new Canvas(bitmap);
+        drawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());
+        drawable.draw(canvas);
+        return new BitmapDrawable(getResources(), bitmap);
+    }
+
+    @Override
+    protected synchronized void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+        if (sampleTile != null) {
+            final int width = sampleTile.getWidth() * getNumStars();
+            setMeasuredDimension(resolveSizeAndState(width, widthMeasureSpec, 0),
+                    getMeasuredHeight());
+        }
+    }
+
+    private Shape getDrawableShape() {
+        final float[] roundedCorners = new float[]{5, 5, 5, 5, 5, 5, 5, 5};
+        return new RoundRectShape(roundedCorners, null, null);
+    }
+
+    public void setValue(float value) {
+        setRating(value);
+    }
+
+    public float getValue() {
+        return getRating();
+    }
+
+    public int getColumn() {
+        return column;
+    }
+
+    public void setColumn(int column) {
+        this.column = column;
+    }
+
+    //TODO Load current device and decode column = num of letter
+    public float loadValue() {
+        SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(getContext());
+        float value = sharedPreferences.getFloat("pattern_column_" + column, 1f);
+        Utils.log(Log.ASSERT, "BAR", "loadValue column: " + column + " value: " + value);
+        return value;
+    }
+
+    public void saveValue(float value) {
+        SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(getContext());
+        Utils.log(Log.ASSERT, "BAR", "saveValue column: " + column + " value: " + value);
+        sharedPreferences.edit().putFloat("pattern_column_" + column, value).apply();
+    }
+}
\ No newline at end of file
diff --git a/app/src/test/java/cc/calliope/mini/ExampleUnitTest.java b/app/src/test/java/cc/calliope/mini/ExampleUnitTest.java
new file mode 100644
index 0000000..573ddcd
--- /dev/null
+++ b/app/src/test/java/cc/calliope/mini/ExampleUnitTest.java
@@ -0,0 +1,17 @@
+package cc.calliope.mini;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * Example local unit test, which will execute on the development machine (host).
+ *
+ * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
+ */
+public class ExampleUnitTest {
+    @Test
+    public void addition_isCorrect() {
+        assertEquals(4, 2 + 2);
+    }
+}
\ No newline at end of file
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/BaseButtonlessDfuImpl.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/BaseButtonlessDfuImpl.java
new file mode 100644
index 0000000..158c7b7
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/BaseButtonlessDfuImpl.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.dfu;
+
+import android.annotation.SuppressLint;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothGatt;
+import android.bluetooth.BluetoothGattCharacteristic;
+import android.content.Intent;
+
+import androidx.annotation.NonNull;
+
+/**
+ * A base implementation of a buttonless service. The purpose of a buttonless service is to
+ * switch a device into the DFU bootloader mode.
+ */
+@SuppressLint("MissingPermission")
+/* package */ abstract class BaseButtonlessDfuImpl extends BaseDfuImpl {
+
+	private final BaseButtonlessDfuImpl.ButtonlessBluetoothCallback mBluetoothCallback = new BaseButtonlessDfuImpl.ButtonlessBluetoothCallback();
+
+	protected class ButtonlessBluetoothCallback extends BaseBluetoothGattCallback {
+		@Override
+		public void onCharacteristicChanged(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic) {
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO, "Notification received from " + characteristic.getUuid() + ", value (0x): " + parse(characteristic));
+			mReceivedData = characteristic.getValue();
+			notifyLock();
+		}
+
+		@Override
+		public void onCharacteristicWrite(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final int status) {
+			// Despite the status code the Enter bootloader request has completed.
+			mRequestCompleted = true;
+			notifyLock();
+		}
+	}
+
+	BaseButtonlessDfuImpl(@NonNull final Intent intent, @NonNull final DfuBaseService service) {
+		super(intent, service);
+	}
+
+	@Override
+	public BaseBluetoothGattCallback getGattCallback() {
+		return mBluetoothCallback;
+	}
+
+	/**
+	 * Closes the BLE connection to the device and removes bonding information if a proper flag was NOT set
+	 * in the {@link DfuServiceInitiator#setKeepBond(boolean)}.
+	 * This method will scan for a bootloader advertising with the address equal to the current or incremented by 1 and restart the service.
+	 * @param intent the intent used to start the DFU service. It contains all user flags in the bundle.
+	 * @param forceRefresh true, if cache should be cleared even for a bonded device. Usually the Service Changed indication should be used for this purpose.
+	 * @param scanForBootloader true to scan for advertising bootloader, false to keep the same address
+	 */
+	@SuppressWarnings("SameParameterValue")
+	void finalize(@NonNull final Intent intent, final boolean forceRefresh, final boolean scanForBootloader) {
+		/*
+		 * We are done with DFU. Now the service may refresh device cache and clear stored services.
+		 * For bonded device this is required only if if doesn't support Service Changed indication.
+		 * Android shouldn't cache services of non-bonded devices having Service Changed characteristic in their database, but it does, so...
+		 */
+		final boolean keepBond = intent.getBooleanExtra(DfuBaseService.EXTRA_KEEP_BOND, false);
+		mService.refreshDeviceCache(mGatt, forceRefresh || !keepBond);
+
+		// Close the device
+		mService.close(mGatt);
+
+		/*
+		 * The experimental buttonless service from SDK 12.x does not support sharing bond information
+		 * from the app to the bootloader. That means, that the DFU bootloader must advertise with advertise
+		 * with address +1 and must not be paired.
+		 */
+		logi("Restarting to bootloader mode");
+		final Intent newIntent = new Intent();
+		newIntent.fillIn(intent, Intent.FILL_IN_COMPONENT | Intent.FILL_IN_PACKAGE);
+		restartService(newIntent, scanForBootloader);
+	}
+}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/BaseCustomDfuImpl.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/BaseCustomDfuImpl.java
new file mode 100644
index 0000000..4ee3c98
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/BaseCustomDfuImpl.java
@@ -0,0 +1,526 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.dfu;
+
+import android.annotation.SuppressLint;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothGatt;
+import android.bluetooth.BluetoothGattCharacteristic;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.os.Build;
+import android.preference.PreferenceManager;
+
+import java.io.IOException;
+import java.util.UUID;
+import java.util.zip.CRC32;
+
+import androidx.annotation.NonNull;
+import no.nordicsemi.android.dfu.internal.exception.DeviceDisconnectedException;
+import no.nordicsemi.android.dfu.internal.exception.DfuException;
+import no.nordicsemi.android.dfu.internal.exception.HexFileValidationException;
+import no.nordicsemi.android.dfu.internal.exception.UploadAbortedException;
+
+@SuppressLint("MissingPermission")
+/* package */ abstract class BaseCustomDfuImpl extends BaseDfuImpl {
+	/**
+	 * Flag indicating whether the init packet has been already transferred or not.
+	 */
+	private boolean mInitPacketInProgress;
+	/**
+	 * Flag indicating whether the firmware is being transmitted or not.
+	 */
+	boolean mFirmwareUploadInProgress;
+	/**
+	 * The number of packets of firmware data to be send before receiving a new Packets
+	 * receipt notification. 0 disables the packets notifications.
+	 */
+	int mPacketsBeforeNotification;
+	/**
+	 * The number of packets sent since last notification.
+	 */
+	private int mPacketsSentSinceNotification;
+	/**
+	 * <p>
+	 * Flag set to <code>true</code> when the DFU target had send a notification with status other
+	 * than success. Setting it to <code>true</code> will abort sending firmware and
+	 * stop logging notifications (read below for explanation).
+	 * <p>
+	 * The onCharacteristicWrite(..) callback is called when Android writes the packet into the
+	 * outgoing queue, not when it physically sends the data. This means that the service will
+	 * first put up to N* packets, one by one, to the queue, while in fact the first one is transmitted.
+	 * In case the DFU target is in an invalid state it will notify Android with a notification
+	 * 10-03-02 for each packet of firmware that has been sent. After receiving the first such
+	 * notification, the DFU service will add the reset command to the outgoing queue,
+	 * but it will still be receiving such notifications until all the data packets are sent.
+	 * Those notifications should be ignored. This flag will prevent from logging
+	 * "Notification received..." more than once.
+	 * <p>
+	 * Additionally, sometimes after writing the command 6 (OP_CODE_RESET),
+	 * Android will receive a notification and update the characteristic value with 10-03-02 and
+	 * the callback for write reset command will log
+	 * "[DFU] Data written to ..., value (0x): 10-03-02" instead of "...(x0): 06".
+	 * But this does not matter for the DFU process.
+	 * <p>
+	 * N* - Value of Packet Receipt Notification, 12 by default.
+	 */
+	boolean mRemoteErrorOccurred;
+
+	class BaseCustomBluetoothCallback extends BaseBluetoothGattCallback {
+		protected void onPacketCharacteristicWrite(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final int status) {
+			// this method can be overwritten on the final class
+		}
+
+		@Override
+		public void onCharacteristicWrite(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final int status) {
+			if (status == BluetoothGatt.GATT_SUCCESS) {
+				/*
+				 * This method is called when either a CONTROL POINT or PACKET characteristic has been written.
+				 * If it is the CONTROL POINT characteristic, just set the {@link mRequestCompleted}
+				 * flag to true. The main thread will continue its task when notified.
+				 * If the PACKET characteristic was written we must:
+				 * - if the image size was written in DFU Start procedure, just set flag to true
+				 * otherwise
+				 * - send the next packet, if notification is not required at that moment, or
+				 * - do nothing, because we have to wait for the notification to confirm the data received
+				 */
+				if (characteristic.getUuid().equals(getPacketCharacteristicUUID())) {
+					if (mInitPacketInProgress) {
+						// We've got confirmation that the init packet was sent
+						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO,
+								"Data written to " + characteristic.getUuid() + ", value (0x): " + parse(characteristic));
+						mInitPacketInProgress = false;
+					} else if (mFirmwareUploadInProgress) {
+						// If the PACKET characteristic was written with image data, update counters
+						mProgressInfo.addBytesSent(characteristic.getValue().length);
+						mPacketsSentSinceNotification++;
+
+						final boolean notificationExpected = mPacketsBeforeNotification > 0 && mPacketsSentSinceNotification >= mPacketsBeforeNotification;
+						final boolean lastPacketTransferred = mProgressInfo.isComplete();
+						final boolean lastObjectPacketTransferred = mProgressInfo.isObjectComplete();
+
+						// When a Packet Receipt Notification notification is expected
+						// we must not call notifyLock() as the process will resume after notification is received.
+						if (notificationExpected)
+							return;
+
+						// In Secure DFU we (usually, depends on the page size and PRN value) do not get any notification after the object is completed,
+						// therefore the lock must be notified here to resume the main process.
+						if (lastPacketTransferred || lastObjectPacketTransferred) {
+							mFirmwareUploadInProgress = false;
+							notifyLock();
+							return;
+						}
+
+						// When neither of them is true, send the next packet
+						try {
+							waitIfPaused();
+							// The writing might have been aborted (mAborted = true), an error might have occurred.
+							// In that case stop sending.
+							if (mAborted || mError != 0 || mRemoteErrorOccurred || mResetRequestSent) {
+								mFirmwareUploadInProgress = false;
+								mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING, "Upload terminated");
+								notifyLock();
+								return;
+							}
+
+							final int available = mProgressInfo.getAvailableObjectSizeIsBytes();
+							byte[] buffer = mBuffer;
+							if (available < buffer.length)
+								buffer = new byte[available];
+							final int size = mFirmwareStream.read(buffer);
+							writePacket(gatt, characteristic, buffer, size);
+							return;
+						} catch (final HexFileValidationException e) {
+							loge("Invalid HEX file");
+							mError = DfuBaseService.ERROR_FILE_INVALID;
+						} catch (final IOException e) {
+							loge("Error while reading the input stream", e);
+							mError = DfuBaseService.ERROR_FILE_IO_EXCEPTION;
+						}
+					} else {
+						onPacketCharacteristicWrite(gatt, characteristic, status);
+					}
+				} else {
+					// If the CONTROL POINT characteristic was written just set the flag to true.
+					// The main thread will continue its task when notified.
+					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO,
+							"Data written to " + characteristic.getUuid() + ", value (0x): " + parse(characteristic));
+					mRequestCompleted = true;
+				}
+			} else {
+				/*
+				 * If a Reset (Op Code = 6) or Activate and Reset (Op Code = 5) commands are sent,
+				 * the DFU target resets and sometimes does it so quickly that does not manage to send
+				 * any ACK to the controller and error 133 is thrown here. This bug should be fixed
+				 * in SDK 8.0+ where the target would gracefully disconnect before restarting.
+				 */
+				if (mResetRequestSent)
+					mRequestCompleted = true;
+				else {
+					loge("Characteristic write error: " + status);
+					mError = DfuBaseService.ERROR_CONNECTION_MASK | status;
+				}
+			}
+			notifyLock();
+		}
+
+		void handlePacketReceiptNotification(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic) {
+			// Secure DFU:
+			// When PRN is set to be received after the object is complete we don't want to send anything. First the object needs to be executed.
+			if (!mFirmwareUploadInProgress) {
+				handleNotification(gatt, characteristic);
+				return;
+			}
+
+			final BluetoothGattCharacteristic packetCharacteristic =
+					gatt.getService(getDfuServiceUUID()).getCharacteristic(getPacketCharacteristicUUID());
+			try {
+				mPacketsSentSinceNotification = 0;
+
+				waitIfPaused();
+				// The writing might have been aborted (mAborted = true), an error might have occurred.
+				// In that case quit sending.
+				if (mAborted || mError != 0 || mRemoteErrorOccurred || mResetRequestSent) {
+					mFirmwareUploadInProgress = false;
+					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING, "Upload terminated");
+					return;
+				}
+
+				final boolean lastPacketTransferred = mProgressInfo.isComplete();
+				final boolean lastObjectPacketTransferred = mProgressInfo.isObjectComplete();
+
+				if (lastPacketTransferred || lastObjectPacketTransferred) {
+					mFirmwareUploadInProgress = false;
+					notifyLock();
+					return;
+				}
+
+				final int available = mProgressInfo.getAvailableObjectSizeIsBytes();
+				byte[] buffer = mBuffer;
+				if (available < buffer.length)
+					buffer = new byte[available];
+				final int size = mFirmwareStream.read(buffer);
+				writePacket(gatt, packetCharacteristic, buffer, size);
+			} catch (final HexFileValidationException e) {
+				loge("Invalid HEX file");
+				mError = DfuBaseService.ERROR_FILE_INVALID;
+			} catch (final IOException e) {
+				loge("Error while reading the input stream", e);
+				mError = DfuBaseService.ERROR_FILE_IO_EXCEPTION;
+			}
+		}
+
+		@SuppressWarnings("unused")
+		void handleNotification(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic) {
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO,
+					"Notification received from " + characteristic.getUuid() + ", value (0x): " + parse(characteristic));
+			mReceivedData = characteristic.getValue();
+			mFirmwareUploadInProgress = false;
+		}
+	}
+
+	@SuppressWarnings("deprecation")
+	BaseCustomDfuImpl(@NonNull final Intent intent, final DfuBaseService service) {
+		super(intent, service);
+
+		if (intent.hasExtra(DfuBaseService.EXTRA_PACKET_RECEIPT_NOTIFICATIONS_ENABLED)) {
+			// Read from intent
+			final boolean packetReceiptNotificationEnabled =
+					intent.getBooleanExtra(DfuBaseService.EXTRA_PACKET_RECEIPT_NOTIFICATIONS_ENABLED, Build.VERSION.SDK_INT < Build.VERSION_CODES.M);
+			int numberOfPackets = intent.getIntExtra(DfuBaseService.EXTRA_PACKET_RECEIPT_NOTIFICATIONS_VALUE, DfuServiceInitiator.DEFAULT_PRN_VALUE);
+			if (numberOfPackets < 0 || numberOfPackets > 0xFFFF)
+				numberOfPackets = DfuServiceInitiator.DEFAULT_PRN_VALUE;
+			if (!packetReceiptNotificationEnabled)
+				numberOfPackets = 0;
+			mPacketsBeforeNotification = numberOfPackets;
+		} else {
+			// Read preferences
+			final SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(service);
+			final boolean packetReceiptNotificationEnabled =
+					preferences.getBoolean(DfuSettingsConstants.SETTINGS_PACKET_RECEIPT_NOTIFICATION_ENABLED, Build.VERSION.SDK_INT < Build.VERSION_CODES.M);
+			String value = preferences.getString(DfuSettingsConstants.SETTINGS_NUMBER_OF_PACKETS, String.valueOf(DfuServiceInitiator.DEFAULT_PRN_VALUE));
+			int numberOfPackets;
+			try {
+				numberOfPackets = Integer.parseInt(value);
+				if (numberOfPackets < 0 || numberOfPackets > 0xFFFF)
+					numberOfPackets = DfuServiceInitiator.DEFAULT_PRN_VALUE;
+			} catch (final NumberFormatException e) {
+				numberOfPackets = DfuServiceInitiator.DEFAULT_PRN_VALUE;
+			}
+			if (!packetReceiptNotificationEnabled)
+				numberOfPackets = 0;
+			mPacketsBeforeNotification = numberOfPackets;
+		}
+	}
+
+	@SuppressWarnings("unused")
+	protected abstract UUID getControlPointCharacteristicUUID();
+
+	protected abstract UUID getPacketCharacteristicUUID();
+
+	protected abstract UUID getDfuServiceUUID();
+
+	/**
+	 * Wends the whole init packet stream to the given characteristic.
+	 *
+	 * @param characteristic the target characteristic
+	 * @param crc32          the CRC object to be updated based on the data sent
+	 * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of
+	 *                                     the transmission.
+	 * @throws DfuException                Thrown if DFU error occur.
+	 * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
+	 */
+	void writeInitData(final BluetoothGattCharacteristic characteristic, final CRC32 crc32)
+			throws DfuException, DeviceDisconnectedException, UploadAbortedException {
+		try {
+			byte[] data = mBuffer;
+			int size;
+			while ((size = mInitPacketStream.read(data, 0, data.length)) != -1) {
+				writeInitPacket(characteristic, data, size);
+				if (crc32 != null)
+					crc32.update(data, 0, size);
+			}
+		} catch (final IOException e) {
+			loge("Error while reading Init packet file", e);
+			throw new DfuException("Error while reading Init packet file", DfuBaseService.ERROR_FILE_ERROR);
+		}
+	}
+
+	/**
+	 * Writes the Init packet to the characteristic. This method is SYNCHRONOUS and wait until the
+	 * {@link android.bluetooth.BluetoothGattCallback#onCharacteristicWrite(android.bluetooth.BluetoothGatt, android.bluetooth.BluetoothGattCharacteristic, int)}
+	 * will be called or the device gets disconnected. If connection state will change,
+	 * or an error will occur, an exception will be thrown.
+	 *
+	 * @param characteristic the characteristic to write to. Should be the DFU PACKET.
+	 * @param buffer         the init packet as a byte array.
+	 * @param size           the init packet size.
+	 * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of the transmission.
+	 * @throws DfuException                Thrown if DFU error occur.
+	 * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
+	 */
+	private void writeInitPacket(final BluetoothGattCharacteristic characteristic, final byte[] buffer, final int size)
+			throws DeviceDisconnectedException, DfuException, UploadAbortedException {
+		if (mAborted)
+			throw new UploadAbortedException();
+		byte[] locBuffer = buffer;
+		if (buffer.length != size) {
+			locBuffer = new byte[size];
+			System.arraycopy(buffer, 0, locBuffer, 0, size);
+		}
+		mReceivedData = null;
+		mError = 0;
+		mInitPacketInProgress = true;
+
+		characteristic.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE);
+		characteristic.setValue(locBuffer);
+		logi("Sending init packet (Value = " + parse(locBuffer) + ")");
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Writing to characteristic " + characteristic.getUuid());
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_DEBUG, "gatt.writeCharacteristic(" + characteristic.getUuid() + ")");
+		mGatt.writeCharacteristic(characteristic);
+
+		// We have to wait for confirmation
+		try {
+			synchronized (mLock) {
+				while ((mInitPacketInProgress && mConnected && mError == 0) || mPaused)
+					mLock.wait();
+			}
+		} catch (final InterruptedException e) {
+			loge("Sleeping interrupted", e);
+		}
+		if (!mConnected)
+			throw new DeviceDisconnectedException("Unable to write Init DFU Parameters: device disconnected");
+		if (mError != 0)
+			throw new DfuException("Unable to write Init DFU Parameters", mError);
+	}
+
+	/**
+	 * Starts sending the data. This method is SYNCHRONOUS and terminates when the whole file will
+     * be uploaded or the device get disconnected. If connection state will change, or an error
+     * will occur, an exception will be thrown.
+	 *
+	 * @param packetCharacteristic the characteristic to write file content to. Must be the DFU PACKET.
+	 * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle
+     *                                     of the transmission.
+	 * @throws DfuException                Thrown if DFU error occur.
+	 * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
+	 */
+	void uploadFirmwareImage(final BluetoothGattCharacteristic packetCharacteristic)
+			throws DeviceDisconnectedException, DfuException, UploadAbortedException {
+		if (mAborted)
+			throw new UploadAbortedException();
+		mReceivedData = null;
+		mError = 0;
+		mFirmwareUploadInProgress = true;
+		mPacketsSentSinceNotification = 0;
+
+		try {
+			final int available = mProgressInfo.getAvailableObjectSizeIsBytes();
+			byte[] buffer = mBuffer;
+			if (available < buffer.length)
+				buffer = new byte[available];
+			final int size = mFirmwareStream.read(buffer);
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE,
+                    "Sending firmware to characteristic " + packetCharacteristic.getUuid() + "...");
+			writePacket(mGatt, packetCharacteristic, buffer, size);
+		} catch (final HexFileValidationException e) {
+			throw new DfuException("HEX file not valid", DfuBaseService.ERROR_FILE_INVALID);
+		} catch (final IOException e) {
+			throw new DfuException("Error while reading file", DfuBaseService.ERROR_FILE_IO_EXCEPTION);
+		}
+
+		try {
+			synchronized (mLock) {
+				while ((mFirmwareUploadInProgress && mReceivedData == null && mConnected && mError == 0) || mPaused)
+					mLock.wait();
+			}
+		} catch (final InterruptedException e) {
+			loge("Sleeping interrupted", e);
+		}
+
+		if (!mConnected)
+			throw new DeviceDisconnectedException("Uploading Firmware Image failed: device disconnected");
+		if (mError != 0)
+			throw new DfuException("Uploading Firmware Image failed", mError);
+	}
+
+	/**
+	 * Writes the buffer to the characteristic. The maximum size of the buffer is dependent on MTU.
+	 * This method is ASYNCHRONOUS and returns immediately after adding the data to TX queue.
+	 *
+	 * @param characteristic the characteristic to write to. Should be the DFU PACKET.
+	 * @param buffer         the buffer with 1-20 bytes.
+	 * @param size           the number of bytes from the buffer to send.
+	 */
+	private void writePacket(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final byte[] buffer, final int size) {
+		byte[] locBuffer = buffer;
+		if (size <= 0) // This should never happen
+			return;
+		if (buffer.length != size) {
+			locBuffer = new byte[size];
+			System.arraycopy(buffer, 0, locBuffer, 0, size);
+		}
+		characteristic.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE);
+		characteristic.setValue(locBuffer);
+		gatt.writeCharacteristic(characteristic);
+	}
+
+	/**
+	 * Closes the BLE connection to the device and removes/restores bonding, if a proper flags were
+     * set in the {@link DfuServiceInitiator}. This method will also change the DFU state to
+     * completed or restart the service to send the second part.
+	 *
+	 * @param intent       the intent used to start the DFU service.
+     *                     It contains all user flags in the bundle.
+	 * @param forceRefresh true, if cache should be cleared even for a bonded device.
+     *                     Usually the Service Changed indication should be used for this purpose.
+	 */
+	void finalize(final Intent intent, final boolean forceRefresh) {
+		/*
+		 * We are done with DFU. Now the service may refresh device cache and clear stored services.
+		 * For bonded device this is required only if if doesn't support Service Changed indication.
+		 * Android shouldn't cache services of non-bonded devices having Service Changed
+		 * characteristic in their database, but it does, so...
+		 */
+		final boolean keepBond = intent.getBooleanExtra(DfuBaseService.EXTRA_KEEP_BOND, false);
+		mService.refreshDeviceCache(mGatt, forceRefresh || !keepBond);
+
+		// Close the device
+		mService.close(mGatt);
+
+		/*
+		 * During the update the bonding information on the target device may have been removed.
+		 * To create bond with the new application set the EXTRA_RESTORE_BOND extra to true.
+		 * In case the bond information is copied to the new application the new bonding is not required.
+		 */
+		boolean alreadyWaited = false;
+		if (mGatt.getDevice().getBondState() == BluetoothDevice.BOND_BONDED) {
+			final boolean restoreBond = intent.getBooleanExtra(DfuBaseService.EXTRA_RESTORE_BOND, false);
+			if (restoreBond || !keepBond) {
+				// The bond information was lost.
+				removeBond();
+
+				// Give some time for removing the bond information. 300 ms was to short,
+                // let's set it to 2 seconds just to be sure.
+				mService.waitFor(2000);
+				alreadyWaited = true;
+			}
+
+			if (restoreBond && (mFileType & DfuBaseService.TYPE_APPLICATION) > 0) {
+				// Restore pairing when application was updated.
+				if (!createBond())
+					logw("Creating bond failed");
+				alreadyWaited = false;
+			}
+		}
+
+		/*
+		 * We need to send PROGRESS_COMPLETED message only when all files has been transmitted.
+		 * In case you want to send the Soft Device and/or Bootloader and the Application,
+		 * the service will be started twice: one to send SD+BL, and the second time to send the
+		 * Application only (using the new Bootloader).
+		 * In the first case we do not send PROGRESS_COMPLETED notification.
+		 */
+		if (mProgressInfo.isLastPart()) {
+			// Delay this event a little bit. Android needs some time to prepare for reconnection.
+			if (!alreadyWaited)
+				mService.waitFor(1400);
+			mProgressInfo.setProgress(DfuBaseService.PROGRESS_COMPLETED);
+		} else {
+			/*
+			 * In case when the SoftDevice has been upgraded, and the application should be send
+			 * in the following connection, we have to make sure that we know the address the device
+			 * is advertising with. Depending on the method used to start the DFU bootloader the first time
+			 * the new Bootloader may advertise with the same address or one incremented by 1.
+			 * When the buttonless update was used, the bootloader will use the same address as the
+			 * application. The cached list of services on the Android device should be cleared
+			 * thanks to the Service Changed characteristic (the fact that it exists if not bonded,
+			 * or the Service Changed indication on bonded one).
+			 * In case of forced DFU mode (using a button), the Bootloader does not know whether
+			 * there was the Service Changed characteristic present in the list of application's
+			 * services so it must advertise with a different address. The same situation applies
+			 * when the new Soft Device was uploaded and the old application has been removed in
+			 * this process.
+			 *
+			 * We could have save the fact of jumping as a parameter of the service but it ma be
+			 * that some Android devices must first scan a device before connecting to it.
+			 * It a device with the address+1 has never been detected before the service could have
+			 * failed on connection.
+			 */
+
+			/*
+			 * The current service instance has uploaded the Soft Device and/or Bootloader.
+			 * We need to start another instance that will try to send application only.
+			 */
+			logi("Starting service that will upload application");
+			final Intent newIntent = new Intent();
+			newIntent.fillIn(intent, Intent.FILL_IN_COMPONENT | Intent.FILL_IN_PACKAGE);
+			newIntent.putExtra(DfuBaseService.EXTRA_FILE_MIME_TYPE, DfuBaseService.MIME_TYPE_ZIP); // ensure this is set (e.g. for scripts)
+			newIntent.putExtra(DfuBaseService.EXTRA_FILE_TYPE, DfuBaseService.TYPE_APPLICATION); // set the type to application only
+			newIntent.putExtra(DfuBaseService.EXTRA_PART_CURRENT, mProgressInfo.getCurrentPart() + 1);
+			newIntent.putExtra(DfuBaseService.EXTRA_PARTS_TOTAL, mProgressInfo.getTotalParts());
+			restartService(newIntent, /* the bootloader may advertise with different address */ true);
+		}
+	}
+}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/BaseDfuImpl.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/BaseDfuImpl.java
new file mode 100644
index 0000000..901059b
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/BaseDfuImpl.java
@@ -0,0 +1,813 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.dfu;
+
+import android.annotation.SuppressLint;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothGatt;
+import android.bluetooth.BluetoothGattCharacteristic;
+import android.bluetooth.BluetoothGattDescriptor;
+import android.bluetooth.BluetoothGattService;
+import android.content.Intent;
+import android.os.Build;
+import android.util.Log;
+
+import java.io.InputStream;
+import java.lang.reflect.Method;
+import java.util.UUID;
+
+import androidx.annotation.IntRange;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RequiresApi;
+import no.nordicsemi.android.dfu.internal.ArchiveInputStream;
+import no.nordicsemi.android.dfu.internal.exception.DeviceDisconnectedException;
+import no.nordicsemi.android.dfu.internal.exception.DfuException;
+import no.nordicsemi.android.dfu.internal.exception.UploadAbortedException;
+import no.nordicsemi.android.dfu.internal.scanner.BootloaderScannerFactory;
+
+@SuppressLint("MissingPermission")
+/* package */ abstract class BaseDfuImpl implements DfuService {
+	private static final String TAG = "DfuImpl";
+
+	static final UUID GENERIC_ATTRIBUTE_SERVICE_UUID = new UUID(0x0000180100001000L, 0x800000805F9B34FBL);
+	static final UUID SERVICE_CHANGED_UUID           = new UUID(0x00002A0500001000L, 0x800000805F9B34FBL);
+	static final UUID CLIENT_CHARACTERISTIC_CONFIG   = new UUID(0x0000290200001000L, 0x800000805f9b34fbL);
+	static final int NOTIFICATIONS = 1;
+	static final int INDICATIONS = 2;
+
+	private static final char[] HEX_ARRAY = "0123456789ABCDEF".toCharArray();
+	private static final int MAX_PACKET_SIZE_DEFAULT = 20; // the default maximum number of bytes in one packet is 20.
+
+	/**
+	 * Lock used in synchronization purposes.
+	 */
+	final Object mLock = new Object();
+
+	InputStream mFirmwareStream;
+	InputStream mInitPacketStream;
+
+	/**
+	 * The target GATT device.
+	 */
+	BluetoothGatt mGatt;
+	/**
+	 * The firmware type. See TYPE_* constants.
+	 */
+	int mFileType;
+	/**
+	 * Flag set to true if sending was paused.
+	 */
+	boolean mPaused;
+	/**
+	 * Flag set to true if sending was aborted.
+	 */
+	boolean mAborted;
+	/**
+	 * Flag indicating whether the device is still connected.
+	 */
+	boolean mConnected;
+	/**
+	 * Flag indicating whether the request was completed or not
+	 */
+	boolean mRequestCompleted;
+	/**
+	 * Flag sent when a request has been sent that will cause the DFU target to reset.
+     * Often, after sending such command, Android throws a connection state error.
+     * If this flag is set the error will be ignored.
+	 */
+	boolean mResetRequestSent;
+	/**
+	 * The number of the last error that has occurred or 0 if there was no error.
+	 */
+	int mError;
+	/**
+	 * Latest data received from device using notification.
+	 */
+	byte[] mReceivedData = null;
+	byte[] mBuffer = new byte[MAX_PACKET_SIZE_DEFAULT];
+	DfuBaseService mService;
+	DfuProgressInfo mProgressInfo;
+	int mImageSizeInBytes;
+	int mInitPacketSizeInBytes;
+	private int mCurrentMtu;
+
+	protected class BaseBluetoothGattCallback extends DfuGattCallback {
+		// The Implementation object is created depending on device services, so after the device
+        // is connected and services were scanned.
+
+		// public void onConnected() { }
+
+		@Override
+		public void onDisconnected() {
+			mConnected = false;
+			notifyLock();
+		}
+
+		@Override
+		public void onCharacteristicRead(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final int status) {
+			if (status == BluetoothGatt.GATT_SUCCESS) {
+				/*
+				 * This method is called when the DFU Version characteristic has been read.
+				 */
+				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO,
+                        "Read Response received from " + characteristic.getUuid() + ", value (0x): " + parse(characteristic));
+				mReceivedData = characteristic.getValue();
+				mRequestCompleted = true;
+			} else {
+				loge("Characteristic read error: " + status);
+				mError = DfuBaseService.ERROR_CONNECTION_MASK | status;
+			}
+			notifyLock();
+		}
+
+		@Override
+		public void onDescriptorRead(final BluetoothGatt gatt, final BluetoothGattDescriptor descriptor, final int status) {
+			if (status == BluetoothGatt.GATT_SUCCESS) {
+				if (CLIENT_CHARACTERISTIC_CONFIG.equals(descriptor.getUuid())) {
+					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO,
+                            "Read Response received from descr." + descriptor.getCharacteristic().getUuid() + ", value (0x): " + parse(descriptor));
+					if (SERVICE_CHANGED_UUID.equals(descriptor.getCharacteristic().getUuid())) {
+						// We have enabled indications for the Service Changed characteristic
+						mRequestCompleted = true;
+					} else {
+						// reading other descriptor is not supported
+						loge("Unknown descriptor read"); // this have to be implemented if needed
+					}
+				}
+			} else {
+				loge("Descriptor read error: " + status);
+				mError = DfuBaseService.ERROR_CONNECTION_MASK | status;
+			}
+			notifyLock();
+		}
+
+		@Override
+		public void onDescriptorWrite(final BluetoothGatt gatt, final BluetoothGattDescriptor descriptor, final int status) {
+			if (status == BluetoothGatt.GATT_SUCCESS) {
+				if (CLIENT_CHARACTERISTIC_CONFIG.equals(descriptor.getUuid())) {
+					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO,
+                            "Data written to descr." + descriptor.getCharacteristic().getUuid() + ", value (0x): " + parse(descriptor));
+					if (SERVICE_CHANGED_UUID.equals(descriptor.getCharacteristic().getUuid())) {
+						// We have enabled indications for the Service Changed characteristic
+						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE,
+                                "Indications enabled for " + descriptor.getCharacteristic().getUuid());
+					} else {
+						// We have enabled notifications for this characteristic
+						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE,
+                                "Notifications enabled for " + descriptor.getCharacteristic().getUuid());
+					}
+				}
+			} else {
+				loge("Descriptor write error: " + status);
+				mError = DfuBaseService.ERROR_CONNECTION_MASK | status;
+			}
+			notifyLock();
+		}
+
+		@Override
+		public void onMtuChanged(final BluetoothGatt gatt, final int mtu, final int status) {
+			if (status == BluetoothGatt.GATT_SUCCESS) {
+				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO, "MTU changed to: " + mtu);
+				if (mtu - 3 > mBuffer.length)
+					mBuffer = new byte[mtu - 3]; // Maximum payload size is MTU - 3 bytes
+				logi("MTU changed to: " + mtu);
+			} else {
+				logw("Changing MTU failed: " + status + " (mtu: " + mtu + ")");
+				if (status == 4 /* Invalid PDU */ && mCurrentMtu > 23 && mCurrentMtu - 3 > mBuffer.length) {
+					mBuffer = new byte[mCurrentMtu - 3]; // Maximum payload size is MTU - 3 bytes
+					logi("MTU restored to: " + mCurrentMtu);
+				}
+			}
+			mRequestCompleted = true;
+			notifyLock();
+		}
+
+		@Override
+		public void onPhyUpdate(final BluetoothGatt gatt, final int txPhy, final int rxPhy, final int status) {
+			if (status == BluetoothGatt.GATT_SUCCESS) {
+				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO,
+                        "PHY updated (TX: " + phyToString(txPhy) + ", RX: " + phyToString(rxPhy) + ")");
+				logi("PHY updated (TX: " + phyToString(txPhy) + ", RX: " + phyToString(rxPhy) + ")");
+			} else {
+				logw("Updating PHY failed: " + status + " (txPhy: " + txPhy + ", rxPhy: " + rxPhy + ")");
+			}
+		}
+
+		protected String parse(final BluetoothGattCharacteristic characteristic) {
+			return parse(characteristic.getValue());
+		}
+
+		protected String parse(final BluetoothGattDescriptor descriptor) {
+			return parse(descriptor.getValue());
+		}
+
+		private String parse(final byte[] data) {
+			if (data == null)
+				return "";
+			final int length = data.length;
+			if (length == 0)
+				return "";
+
+			final char[] out = new char[length * 3 - 1];
+			for (int j = 0; j < length; j++) {
+				int v = data[j] & 0xFF;
+				out[j * 3] = HEX_ARRAY[v >>> 4];
+				out[j * 3 + 1] = HEX_ARRAY[v & 0x0F];
+				if (j != length - 1)
+					out[j * 3 + 2] = '-';
+			}
+			return new String(out);
+		}
+
+		private String phyToString(final int phy) {
+			switch (phy) {
+				case BluetoothDevice.PHY_LE_1M:
+					return "LE 1M";
+				case BluetoothDevice.PHY_LE_2M:
+					return "LE 2M";
+				case BluetoothDevice.PHY_LE_CODED:
+					return "LE Coded";
+				default:
+					return "UNKNOWN (" + phy + ")";
+			}
+		}
+	}
+
+    @SuppressWarnings("unused")
+    BaseDfuImpl(@NonNull final Intent intent, @NonNull final DfuBaseService service) {
+		mService = service;
+		mProgressInfo = service.mProgressInfo;
+		mConnected = true; // the device is connected when impl object it created
+	}
+
+	@Override
+	public void release() {
+		mService = null;
+	}
+
+	@Override
+	public void pause() {
+		mPaused = true;
+	}
+
+	@Override
+	public void resume() {
+		mPaused = false;
+		notifyLock();
+	}
+
+	@Override
+	public void abort() {
+		mPaused = false;
+		mAborted = true;
+		notifyLock();
+	}
+
+	@Override
+	public void onBondStateChanged(final int state) {
+		mRequestCompleted = true;
+		notifyLock();
+	}
+
+	@Override
+	public boolean initialize(@NonNull final Intent intent, @NonNull final BluetoothGatt gatt,
+                              final int fileType,
+                              @NonNull final InputStream firmwareStream,
+                              @Nullable final InputStream initPacketStream)
+            throws DfuException, DeviceDisconnectedException, UploadAbortedException {
+		mGatt = gatt;
+		mFileType = fileType;
+		mFirmwareStream = firmwareStream;
+		mInitPacketStream = initPacketStream;
+
+		final int currentPart = intent.getIntExtra(DfuBaseService.EXTRA_PART_CURRENT, 1);
+		int totalParts = intent.getIntExtra(DfuBaseService.EXTRA_PARTS_TOTAL, 1);
+		mCurrentMtu = intent.getIntExtra(DfuBaseService.EXTRA_CURRENT_MTU, 23);
+
+		// Sending App together with SD or BL is not supported. It must be spilt into two parts.
+		if (fileType > DfuBaseService.TYPE_APPLICATION) {
+			logw("DFU target does not support (SD/BL)+App update, splitting into 2 parts");
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING, "Sending system components");
+			mFileType &= ~DfuBaseService.TYPE_APPLICATION; // clear application bit
+			totalParts = 2;
+
+			// Set new content type in the ZIP Input Stream and update sizes of images
+			final ArchiveInputStream zhis = (ArchiveInputStream) mFirmwareStream;
+			zhis.setContentType(mFileType);
+		}
+
+		if (currentPart == 2) {
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING, "Sending application");
+		}
+
+		int size = 0;
+		try {
+		    if (initPacketStream != null) {
+                if (initPacketStream.markSupported()) {
+                    initPacketStream.reset();
+                }
+                size = initPacketStream.available();
+            }
+		} catch (final Exception e) {
+			// ignore
+		}
+		mInitPacketSizeInBytes = size;
+		try {
+			if (firmwareStream.markSupported()) {
+				if (firmwareStream instanceof ArchiveInputStream) {
+					((ArchiveInputStream) firmwareStream).fullReset();
+				} else {
+					firmwareStream.reset();
+				}
+			}
+			size = firmwareStream.available();
+		} catch (final Exception e) {
+			size = 0;
+			// not possible
+		}
+		mImageSizeInBytes = size;
+		mProgressInfo.init(size, currentPart, totalParts);
+
+		// If we are bonded we may want to enable Service Changed characteristic indications.
+		// Note: Sending SC indication on services change was introduced in the SDK 8.0.
+		//       Before, the cache had to be clear manually. This Android lib supports both implementations.
+		// Note: On iOS refreshing services is not available in the API. An app must have Service Change characteristic
+		//       if it intends ever to change its services. In that case on non-bonded devices services will never be cached,
+		//       and on bonded a change is indicated using Service Changed indication. Ergo - Legacy DFU will
+		//       not work by default on iOS with buttonless update on SDKs < 8 on bonded devices. The bootloader must be modified to
+		//       always send the indication when connected.
+
+		// <strike>The requirement of enabling Service Changed indications manually has been fixed on Android 6.
+		// Now the Android enables Service Changed indications automatically after bonding.</strike>
+		// This no longer works in Android 8 and 8.1:
+		// issue: https://github.com/NordicSemiconductor/Android-DFU-Library/issues/112
+		if (gatt.getDevice().getBondState() == BluetoothDevice.BOND_BONDED) {
+			final BluetoothGattService genericAttributeService = gatt.getService(GENERIC_ATTRIBUTE_SERVICE_UUID);
+			if (genericAttributeService != null) {
+				final BluetoothGattCharacteristic serviceChangedCharacteristic = genericAttributeService.getCharacteristic(SERVICE_CHANGED_UUID);
+				if (serviceChangedCharacteristic != null) {
+					// Let's read the current value of the Service Changed CCCD
+					final boolean serviceChangedIndicationsEnabled = isServiceChangedCCCDEnabled();
+
+					if (!serviceChangedIndicationsEnabled)
+						enableCCCD(serviceChangedCharacteristic, INDICATIONS);
+
+					logi("Service Changed indications enabled");
+					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Service Changed indications enabled");
+				}
+			}
+		}
+		return true;
+	}
+
+	void notifyLock() {
+		// Notify waiting thread
+		synchronized (mLock) {
+			mLock.notifyAll();
+		}
+	}
+
+	void waitIfPaused() {
+		try {
+			synchronized (mLock) {
+				while (mPaused)
+					mLock.wait();
+			}
+		} catch (final InterruptedException e) {
+			loge("Sleeping interrupted", e);
+		}
+	}
+
+	/**
+	 * Enables or disables the notifications for given characteristic.
+     * This method is SYNCHRONOUS and wait until the
+	 * {@link android.bluetooth.BluetoothGattCallback#onDescriptorWrite(android.bluetooth.BluetoothGatt, android.bluetooth.BluetoothGattDescriptor, int)}
+     * will be called or the device gets disconnected.
+	 * If connection state will change, or an error will occur, an exception will be thrown.
+	 *
+	 * @param characteristic the characteristic to enable or disable notifications for.
+	 * @param type           {@link #NOTIFICATIONS} or {@link #INDICATIONS}.
+     * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of
+     *                                     the transmission.
+     * @throws DfuException                Thrown if DFU error occur.
+     * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
+	 */
+	void enableCCCD(@NonNull final BluetoothGattCharacteristic characteristic, final int type)
+            throws DeviceDisconnectedException, DfuException, UploadAbortedException {
+		final BluetoothGatt gatt = mGatt;
+		final String debugString = type == NOTIFICATIONS ? "notifications" : "indications";
+		if (!mConnected)
+			throw new DeviceDisconnectedException("Unable to set " + debugString + " state: device disconnected");
+		if (mAborted)
+			throw new UploadAbortedException();
+
+		mReceivedData = null;
+		mError = 0;
+		final BluetoothGattDescriptor descriptor = characteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG);
+		boolean cccdEnabled = descriptor.getValue() != null && descriptor.getValue().length == 2 && descriptor.getValue()[0] > 0 && descriptor.getValue()[1] == 0;
+		if (cccdEnabled)
+			return;
+
+		logi("Enabling " + debugString + "...");
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE,
+                "Enabling " + debugString + " for " + characteristic.getUuid());
+
+		// enable notifications locally
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_DEBUG,
+                "gatt.setCharacteristicNotification(" + characteristic.getUuid() + ", true)");
+		gatt.setCharacteristicNotification(characteristic, true);
+
+		// enable notifications on the device
+		descriptor.setValue(type == NOTIFICATIONS ? BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE : BluetoothGattDescriptor.ENABLE_INDICATION_VALUE);
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_DEBUG,
+                "gatt.writeDescriptor(" + descriptor.getUuid() + (type == NOTIFICATIONS ? ", value=0x01-00)" : ", value=0x02-00)"));
+		gatt.writeDescriptor(descriptor);
+
+		// We have to wait until device receives a response or an error occur
+		try {
+			synchronized (mLock) {
+				while ((!cccdEnabled && mConnected && mError == 0) || mPaused) {
+					mLock.wait();
+					// Check the value of the CCCD
+					cccdEnabled = descriptor.getValue() != null
+							   && descriptor.getValue().length == 2
+							   && descriptor.getValue()[0] > 0
+							   && descriptor.getValue()[1] == 0;
+				}
+			}
+		} catch (final InterruptedException e) {
+			loge("Sleeping interrupted", e);
+		}
+		if (!mConnected)
+			throw new DeviceDisconnectedException("Unable to set " + debugString + " state: device disconnected");
+		if (mError != 0)
+			throw new DfuException("Unable to set " + debugString + " state", mError);
+	}
+
+	/**
+	 * Reads the value of the Service Changed Client Characteristic Configuration descriptor (CCCD).
+	 *
+	 * @return <code>true</code> if Service Changed CCCD is enabled and set to INDICATE.
+     * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of
+     *                                     the transmission.
+     * @throws DfuException                Thrown if DFU error occur.
+     * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
+	 */
+	private boolean isServiceChangedCCCDEnabled()
+            throws DeviceDisconnectedException, DfuException, UploadAbortedException {
+		if (!mConnected)
+			throw new DeviceDisconnectedException("Unable to read Service Changed CCCD: device disconnected");
+		if (mAborted)
+			throw new UploadAbortedException();
+
+		// If the Service Changed characteristic or the CCCD is not available we return false.
+		final BluetoothGatt gatt = mGatt;
+		final BluetoothGattService genericAttributeService = gatt.getService(GENERIC_ATTRIBUTE_SERVICE_UUID);
+		if (genericAttributeService == null)
+			return false;
+
+		final BluetoothGattCharacteristic serviceChangedCharacteristic = genericAttributeService.getCharacteristic(SERVICE_CHANGED_UUID);
+		if (serviceChangedCharacteristic == null)
+			return false;
+
+		final BluetoothGattDescriptor descriptor = serviceChangedCharacteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG);
+		if (descriptor == null)
+			return false;
+
+		mRequestCompleted = false;
+		mError = 0;
+
+		logi("Reading Service Changed CCCD value...");
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Reading Service Changed CCCD value...");
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_DEBUG, "gatt.readDescriptor(" + descriptor.getUuid() + ")");
+		gatt.readDescriptor(descriptor);
+
+		// We have to wait until device receives a response or an error occur
+		try {
+			synchronized (mLock) {
+				while ((!mRequestCompleted && mConnected && mError == 0) || mPaused)
+					mLock.wait();
+			}
+		} catch (final InterruptedException e) {
+			loge("Sleeping interrupted", e);
+		}
+		if (!mConnected)
+			throw new DeviceDisconnectedException("Unable to read Service Changed CCCD: device disconnected");
+		if (mError != 0)
+			throw new DfuException("Unable to read Service Changed CCCD", mError);
+
+		// Return true if the CCCD value is
+		return descriptor.getValue() != null && descriptor.getValue().length == 2
+				&& descriptor.getValue()[0] == BluetoothGattDescriptor.ENABLE_INDICATION_VALUE[0]
+				&& descriptor.getValue()[1] == BluetoothGattDescriptor.ENABLE_INDICATION_VALUE[1];
+	}
+
+	/**
+	 * Writes the operation code to the characteristic.
+     * This method is SYNCHRONOUS and wait until the
+	 * {@link android.bluetooth.BluetoothGattCallback#onCharacteristicWrite(android.bluetooth.BluetoothGatt, android.bluetooth.BluetoothGattCharacteristic, int)}
+     * will be called or the device gets disconnected.
+     * If connection state will change, or an error will occur, an exception will be thrown.
+	 *
+	 * @param characteristic the characteristic to write to. Should be the DFU CONTROL POINT
+	 * @param value          the value to write to the characteristic
+	 * @param reset          whether the command trigger restarting the device
+     * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of
+     *                                     the transmission.
+     * @throws DfuException                Thrown if DFU error occur.
+     * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
+	 */
+	void writeOpCode(@NonNull final BluetoothGattCharacteristic characteristic, @NonNull final byte[] value, final boolean reset)
+            throws DeviceDisconnectedException, DfuException, UploadAbortedException {
+		if (mAborted)
+			throw new UploadAbortedException();
+		mReceivedData = null;
+		mError = 0;
+		mRequestCompleted = false;
+		/*
+		 * Sending a command that will make the DFU target to reboot may cause an error 133
+		 * (0x85 - Gatt Error). If so, with this flag set, the error will not be shown to the user
+		 * as the peripheral is disconnected anyway.
+		 * See: mGattCallback#onCharacteristicWrite(...) method
+		 */
+		mResetRequestSent = reset;
+
+		characteristic.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT);
+		characteristic.setValue(value);
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Writing to characteristic " + characteristic.getUuid());
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_DEBUG, "gatt.writeCharacteristic(" + characteristic.getUuid() + ")");
+		mGatt.writeCharacteristic(characteristic);
+
+		// We have to wait for confirmation
+		try {
+			synchronized (mLock) {
+				while ((!mRequestCompleted && mConnected && mError == 0) || mPaused)
+					mLock.wait();
+			}
+		} catch (final InterruptedException e) {
+			loge("Sleeping interrupted", e);
+		}
+		if (!mResetRequestSent && !mConnected)
+			throw new DeviceDisconnectedException("Unable to write Op Code " + value[0] + ": device disconnected");
+		if (!mResetRequestSent && mError != 0)
+			throw new DfuException("Unable to write Op Code " + value[0], mError);
+	}
+
+	/**
+	 * Creates bond to the device. Works on all APIs since 18th (Android 4.3).
+	 * This method will only be called in this library after bond information was removed.
+	 *
+	 * @return true if bonding has started, false otherwise.
+	 */
+	@SuppressWarnings("UnusedReturnValue")
+	boolean createBond() {
+		final BluetoothDevice device = mGatt.getDevice();
+
+		boolean result;
+		mRequestCompleted = false;
+
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Starting pairing...");
+		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_DEBUG, "gatt.getDevice().createBond()");
+			result = device.createBond();
+		} else {
+			result = createBondApi18(device);
+		}
+
+		// We have to wait until device is bounded
+		try {
+			synchronized (mLock) {
+				while (result && !mRequestCompleted && !mAborted)
+					mLock.wait();
+			}
+		} catch (final InterruptedException e) {
+			loge("Sleeping interrupted", e);
+		}
+		return result;
+	}
+
+	/**
+	 * A method that creates the bond to given device on API lower than Android 5.
+	 *
+	 * @param device the target device
+	 * @return false if bonding failed (no hidden createBond() method in BluetoothDevice, or this method returned false
+	 */
+	private boolean createBondApi18(@NonNull final BluetoothDevice device) {
+		/*
+		 * There is a createBond() method in BluetoothDevice class but for now it's hidden.
+		 * We will call it using reflections. It has been revealed in KitKat (Api19)
+		 */
+		try {
+			final Method createBond = device.getClass().getMethod("createBond");
+            mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_DEBUG, "gatt.getDevice().createBond() (hidden)");
+			//noinspection ConstantConditions
+			return (Boolean) createBond.invoke(device);
+		} catch (final Exception e) {
+			Log.w(TAG, "An exception occurred while creating bond", e);
+		}
+		return false;
+	}
+
+	/**
+	 * Removes the bond information for the given device.
+	 *
+	 * @return <code>true</code> if operation succeeded, <code>false</code> otherwise
+	 */
+    @SuppressWarnings("UnusedReturnValue")
+    boolean removeBond() {
+		final BluetoothDevice device = mGatt.getDevice();
+		if (device.getBondState() == BluetoothDevice.BOND_NONE)
+			return true;
+
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Removing bond information...");
+		boolean result = false;
+		/*
+		 * There is a removeBond() method in BluetoothDevice class but for now it's hidden.
+		 * We will call it using reflections.
+		 */
+		try {
+            //noinspection JavaReflectionMemberAccess
+            final Method removeBond = device.getClass().getMethod("removeBond");
+            mRequestCompleted = false;
+            mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_DEBUG, "gatt.getDevice().removeBond() (hidden)");
+			//noinspection ConstantConditions
+			result = (Boolean) removeBond.invoke(device);
+
+            // We have to wait until device is unbounded
+            try {
+                synchronized (mLock) {
+                    while (!mRequestCompleted && !mAborted)
+                        mLock.wait();
+                }
+            } catch (final InterruptedException e) {
+                loge("Sleeping interrupted", e);
+            }
+		} catch (final Exception e) {
+			Log.w(TAG, "An exception occurred while removing bond information", e);
+		}
+		return result;
+	}
+
+	/**
+	 * Returns whether the device is bonded.
+	 *
+	 * @return true if the device is bonded, false if not bonded or in process of bonding.
+	 */
+	boolean isBonded() {
+		final BluetoothDevice device = mGatt.getDevice();
+		return device.getBondState() == BluetoothDevice.BOND_BONDED;
+	}
+
+	/**
+	 * Requests given MTU. This method is only supported on Android Lollipop or newer versions.
+	 * Only DFU from SDK 14.1 or newer supports MTU > 23.
+	 *
+	 * @param mtu new MTU to be requested.
+	 */
+	@RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
+	void requestMtu(@IntRange(from = 0, to = 517) final int mtu)
+            throws DeviceDisconnectedException, UploadAbortedException {
+		if (mAborted)
+			throw new UploadAbortedException();
+		mRequestCompleted = false;
+
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Requesting new MTU...");
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_DEBUG, "gatt.requestMtu(" + mtu + ")");
+		if (!mGatt.requestMtu(mtu))
+			return;
+
+		// We have to wait until the MTU exchange finishes
+		try {
+			synchronized (mLock) {
+				while ((!mRequestCompleted && mConnected && mError == 0) || mPaused)
+					mLock.wait();
+			}
+		} catch (final InterruptedException e) {
+			loge("Sleeping interrupted", e);
+		}
+		if (!mConnected)
+			throw new DeviceDisconnectedException("Unable to read Service Changed CCCD: device disconnected");
+	}
+
+	/**
+	 * Waits until the notification will arrive. Returns the data returned by the notification.
+     * This method will block the thread until response is not ready or the device gets disconnected.
+     * If connection state will change, or an error will occur, an exception will be thrown.
+	 *
+	 * @return the value returned by the Control Point notification
+     * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of
+     *                                     the transmission.
+     * @throws DfuException                Thrown if DFU error occur.
+     * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
+	 */
+	byte[] readNotificationResponse()
+            throws DeviceDisconnectedException, DfuException, UploadAbortedException {
+		// do not clear the mReceiveData here. The response might already be obtained. Clear it in write request instead.
+		try {
+			synchronized (mLock) {
+				while ((mReceivedData == null && mConnected && mError == 0 && !mAborted) || mPaused)
+					mLock.wait();
+			}
+		} catch (final InterruptedException e) {
+			loge("Sleeping interrupted", e);
+		}
+		if (mAborted)
+			throw new UploadAbortedException();
+		if (!mConnected)
+			throw new DeviceDisconnectedException("Unable to write Op Code: device disconnected");
+		if (mError != 0)
+			throw new DfuException("Unable to write Op Code", mError);
+		return mReceivedData;
+	}
+
+	/**
+	 * Restarts the service based on the given intent. If parameter set this method will also scan for
+	 * an advertising bootloader that has address equal or incremented by 1 to the current one.
+	 *
+	 * @param intent            the intent to be started as a service
+	 * @param scanForBootloader true to scan for advertising bootloader, false to keep the same address
+	 */
+	void restartService(@NonNull final Intent intent, final boolean scanForBootloader) {
+		String newAddress = null;
+		if (scanForBootloader) {
+			final long delay = intent.getLongExtra(DfuBaseService.EXTRA_SCAN_DELAY, 0);
+			final long timeout = intent.getLongExtra(DfuBaseService.EXTRA_SCAN_TIMEOUT, DfuServiceInitiator.DEFAULT_SCAN_TIMEOUT);
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Scanning for the DFU Bootloader... (timeout " + timeout + " ms)");
+			if (delay > 0)
+				mService.waitFor(delay);
+			newAddress = BootloaderScannerFactory.getScanner(mGatt.getDevice().getAddress()).searchUsing(mService.getDeviceSelector(), timeout);
+			logi("Scanning for new address finished with: " + newAddress);
+			if (newAddress != null)
+				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO, "DFU Bootloader found with address " + newAddress);
+			else {
+				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO, "DFU Bootloader not found. Trying the same address...");
+			}
+		}
+
+		if (newAddress != null)
+			intent.putExtra(DfuBaseService.EXTRA_DEVICE_ADDRESS, newAddress);
+
+		// Reset the DFU attempt counter
+		intent.putExtra(DfuBaseService.EXTRA_DFU_ATTEMPT, 0);
+
+		mService.startService(intent);
+	}
+
+	protected String parse(@Nullable final byte[] data) {
+		if (data == null)
+			return "";
+
+		final int length = data.length;
+		if (length == 0)
+			return "";
+
+		final char[] out = new char[length * 3 - 1];
+		for (int j = 0; j < length; j++) {
+			int v = data[j] & 0xFF;
+			out[j * 3] = HEX_ARRAY[v >>> 4];
+			out[j * 3 + 1] = HEX_ARRAY[v & 0x0F];
+			if (j != length - 1)
+				out[j * 3 + 2] = '-';
+		}
+		return new String(out);
+	}
+
+	void loge(final String message) {
+		Log.e(TAG, message);
+	}
+
+	void loge(final String message, final Throwable e) {
+		Log.e(TAG, message, e);
+	}
+
+	void logw(final String message) {
+		if (DfuBaseService.DEBUG)
+			Log.w(TAG, message);
+	}
+
+	void logi(final String message) {
+		if (DfuBaseService.DEBUG)
+			Log.i(TAG, message);
+	}
+}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/ButtonlessDfuImpl.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/ButtonlessDfuImpl.java
new file mode 100644
index 0000000..0089048
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/ButtonlessDfuImpl.java
@@ -0,0 +1,197 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.dfu;
+
+import android.bluetooth.BluetoothGatt;
+import android.bluetooth.BluetoothGattCharacteristic;
+import android.content.Intent;
+
+import java.util.Locale;
+
+import androidx.annotation.NonNull;
+import no.nordicsemi.android.dfu.internal.exception.DeviceDisconnectedException;
+import no.nordicsemi.android.dfu.internal.exception.DfuException;
+import no.nordicsemi.android.dfu.internal.exception.RemoteDfuException;
+import no.nordicsemi.android.dfu.internal.exception.UnknownResponseException;
+import no.nordicsemi.android.dfu.internal.exception.UploadAbortedException;
+import no.nordicsemi.android.error.SecureDfuError;
+
+/**
+ * A base class for buttonless service implementations made for Secure and in the future for
+ * Non-Secure DFU.
+ */
+/* package */ abstract class ButtonlessDfuImpl extends BaseButtonlessDfuImpl {
+
+	private static final int DFU_STATUS_SUCCESS = 1;
+
+	private static final int OP_CODE_ENTER_BOOTLOADER_KEY = 0x01;
+	private static final int OP_CODE_RESPONSE_CODE_KEY = 0x20;
+	private static final byte[] OP_CODE_ENTER_BOOTLOADER = new byte[]{OP_CODE_ENTER_BOOTLOADER_KEY};
+
+	ButtonlessDfuImpl(@NonNull final Intent intent, @NonNull final DfuBaseService service) {
+		super(intent, service);
+	}
+
+	/**
+	 * This method should return the type of the response received from the device after sending
+	 * Enable Dfu command. Should be one of {@link #NOTIFICATIONS} or {@link #INDICATIONS}.
+	 *
+	 * @return Response type.
+	 */
+	protected abstract int getResponseType();
+
+	/**
+	 * Returns the buttonless characteristic.
+	 *
+	 * @return The characteristic used to trigger buttonless jump to bootloader mode.
+	 */
+	protected abstract BluetoothGattCharacteristic getButtonlessDfuCharacteristic();
+
+	/**
+	 * This method should return {@code true} if the bootloader is expected to start advertising
+     * with address incremented by 1.
+	 *
+	 * @return True if the bootloader may advertise with address +1, false if it will keep
+	 * the same device address.
+	 */
+	protected abstract boolean shouldScanForBootloader();
+
+	@Override
+	public void performDfu(@NonNull final Intent intent)
+            throws DfuException, DeviceDisconnectedException, UploadAbortedException {
+		mProgressInfo.setProgress(DfuBaseService.PROGRESS_STARTING);
+
+		// Add one second delay to avoid the traffic jam before the DFU mode is enabled
+		// Related:
+		//   issue:        https://github.com/NordicSemiconductor/Android-DFU-Library/issues/10
+		//   pull request: https://github.com/NordicSemiconductor/Android-DFU-Library/pull/12
+		mService.waitFor(1000);
+		// End
+
+		final BluetoothGatt gatt = mGatt;
+
+		// The service is connected to the application, not to the bootloader
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING, "Application with buttonless update found");
+
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Jumping to the DFU Bootloader...");
+
+		final BluetoothGattCharacteristic characteristic = getButtonlessDfuCharacteristic();
+		// Enable notifications or indications
+		final int type = getResponseType();
+		enableCCCD(characteristic, getResponseType());
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, (type == INDICATIONS ? "Indications" : "Notifications") + " enabled");
+
+		// Wait a second here before going further
+		// Related:
+		//   pull request: https://github.com/NordicSemiconductor/Android-DFU-Library/pull/11
+		mService.waitFor(1000);
+		// End
+
+		try {
+			// Send 'enter bootloader command'
+			mProgressInfo.setProgress(DfuBaseService.PROGRESS_ENABLING_DFU_MODE);
+			logi("Sending Enter Bootloader (Op Code = 1)");
+			writeOpCode(characteristic, OP_CODE_ENTER_BOOTLOADER, true);
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Enter bootloader sent (Op Code = 1)");
+
+			byte[] response;
+			try {
+				// There may be a race condition here. The peripheral should send a notification
+                // and disconnect gracefully immediately after that, but the onConnectionStateChange
+                // event may be handled before this method ends. Also, sometimes the notification
+                // is not received at all.
+				response = readNotificationResponse();
+			} catch (final DeviceDisconnectedException e) {
+				// The device disconnect event was handled before the method finished,
+				// or the notification wasn't received. We behave as if we received status success.
+				response = mReceivedData;
+			}
+
+			if (response != null) {
+				/*
+				 * The response received from the DFU device contains:
+				 * +---------+--------+----------------------------------------------------+
+				 * | byte no | value  | description                                        |
+				 * +---------+--------+----------------------------------------------------+
+				 * | 0       | 0x20   | Response code                                      |
+				 * | 1       | 0x01   | The Op Code of a request that this response is for |
+				 * | 2       | STATUS | Status code                                        |
+				 * +---------+--------+----------------------------------------------------+
+				 */
+				final int status = getStatusCode(response, OP_CODE_ENTER_BOOTLOADER_KEY);
+				logi("Response received (Op Code = " + response[1] + ", Status = " + status + ")");
+				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION,
+                        "Response received (Op Code = " + response[1] + ", Status = " + status + ")");
+				if (status != DFU_STATUS_SUCCESS)
+					throw new RemoteDfuException("Device returned error after sending Enter Bootloader", status);
+				// The device will disconnect and now reset. Some devices don't disconnect gracefully,
+				// but reset instead. In that case, Android would assume disconnection after
+				// "supervision timeout" seconds, which may be 5 more seconds. If the device will
+				// use a different address in bootloader mode, there is no reason to wait for that.
+				// The library will immediately start scanning for the device advertising in
+				// bootloader mode and connect to it.
+				if (!shouldScanForBootloader()) {
+					// However, if the device is expected to use the same address, we need to wait
+					// for the disconnection. Otherwise, a new connectGatt would reconnect before
+					// disconnection and subsequent operations would fail.
+					mService.waitUntilDisconnected();
+				}
+			} else {
+				logi("Device disconnected before receiving notification");
+			}
+
+			if (!shouldScanForBootloader()) {
+				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO, "Disconnected by the remote device");
+			}
+			finalize(intent, false, shouldScanForBootloader());
+		} catch (final UnknownResponseException e) {
+			final int error = DfuBaseService.ERROR_INVALID_RESPONSE;
+			loge(e.getMessage());
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_ERROR, e.getMessage());
+			mService.terminateConnection(gatt, error);
+		} catch (final RemoteDfuException e) {
+			final int error = DfuBaseService.ERROR_REMOTE_TYPE_SECURE_BUTTONLESS | e.getErrorNumber();
+			loge(e.getMessage());
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_ERROR, String.format(Locale.US,
+                    "Remote DFU error: %s", SecureDfuError.parseButtonlessError(error)));
+			mService.terminateConnection(gatt, error | DfuBaseService.ERROR_REMOTE_MASK);
+		}
+	}
+
+	/**
+	 * Checks whether the response received is valid and returns the status code.
+	 *
+	 * @param response the response received from the DFU device.
+	 * @param request  the expected Op Code.
+	 * @return The status code.
+	 * @throws UnknownResponseException if response was not valid.
+	 */
+	@SuppressWarnings("SameParameterValue")
+	private int getStatusCode(final byte[] response, final int request) throws UnknownResponseException {
+		if (response == null || response.length < 3 || response[0] != OP_CODE_RESPONSE_CODE_KEY || response[1] != request ||
+				(response[2] != DFU_STATUS_SUCCESS && response[2] != SecureDfuError.BUTTONLESS_ERROR_OP_CODE_NOT_SUPPORTED
+                        && response[2] != SecureDfuError.BUTTONLESS_ERROR_OPERATION_FAILED))
+			throw new UnknownResponseException("Invalid response received", response, OP_CODE_RESPONSE_CODE_KEY, request);
+		return response[2];
+	}
+}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/ButtonlessDfuWithBondSharingImpl.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/ButtonlessDfuWithBondSharingImpl.java
new file mode 100644
index 0000000..3f63d43
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/ButtonlessDfuWithBondSharingImpl.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.dfu;
+
+import android.bluetooth.BluetoothGatt;
+import android.bluetooth.BluetoothGattCharacteristic;
+import android.bluetooth.BluetoothGattService;
+import android.content.Intent;
+
+import java.util.UUID;
+
+import androidx.annotation.NonNull;
+import no.nordicsemi.android.dfu.internal.exception.DeviceDisconnectedException;
+import no.nordicsemi.android.dfu.internal.exception.DfuException;
+import no.nordicsemi.android.dfu.internal.exception.UploadAbortedException;
+
+/**
+ * This implementation handles the secure buttonless DFU service that will be implemented in
+ * SDK 14 or later.
+ * <p>
+ * This service requires the device to be paired, so that only a trusted phone can switch it to
+ * bootloader mode. The bond information will be shared to the bootloader and it will use the
+ * same device address when in DFU mode and the connection will be encrypted.
+ */
+/* package */ class ButtonlessDfuWithBondSharingImpl extends ButtonlessDfuImpl {
+	/**
+	 * The UUID of the Secure DFU service from SDK 12.
+	 */
+	static final UUID DEFAULT_BUTTONLESS_DFU_SERVICE_UUID = SecureDfuImpl.DEFAULT_DFU_SERVICE_UUID;
+	/**
+	 * The UUID of the Secure Buttonless DFU characteristic with bond sharing from SDK 14 or newer.
+	 */
+	static final UUID DEFAULT_BUTTONLESS_DFU_UUID = new UUID(0x8EC90004F3154F60L, 0x9FB8838830DAEA50L);
+
+	static UUID BUTTONLESS_DFU_SERVICE_UUID = DEFAULT_BUTTONLESS_DFU_SERVICE_UUID;
+	static UUID BUTTONLESS_DFU_UUID = DEFAULT_BUTTONLESS_DFU_UUID;
+
+	private BluetoothGattCharacteristic mButtonlessDfuCharacteristic;
+
+	ButtonlessDfuWithBondSharingImpl(@NonNull final Intent intent, @NonNull final DfuBaseService service) {
+		super(intent, service);
+	}
+
+	@Override
+	public boolean isClientCompatible(@NonNull final Intent intent, @NonNull final BluetoothGatt gatt) {
+		final BluetoothGattService dfuService = gatt.getService(BUTTONLESS_DFU_SERVICE_UUID);
+		if (dfuService == null)
+			return false;
+		final BluetoothGattCharacteristic characteristic = dfuService.getCharacteristic(BUTTONLESS_DFU_UUID);
+		if (characteristic == null || characteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG) == null)
+			return false;
+		mButtonlessDfuCharacteristic = characteristic;
+		return true;
+	}
+
+	@Override
+	protected int getResponseType() {
+		return INDICATIONS;
+	}
+
+	@Override
+	protected BluetoothGattCharacteristic getButtonlessDfuCharacteristic() {
+		return mButtonlessDfuCharacteristic;
+	}
+
+	@Override
+	protected boolean shouldScanForBootloader() {
+		return false;
+	}
+
+	@Override
+	public void performDfu(@NonNull final Intent intent)
+			throws DfuException, DeviceDisconnectedException, UploadAbortedException {
+		logi("Buttonless service with bond sharing found -> SDK 14 or newer");
+		if (!isBonded()) {
+			logw("Device is not paired, cancelling DFU");
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING, "Device is not bonded");
+			mService.terminateConnection(mGatt, DfuBaseService.ERROR_DEVICE_NOT_BONDED);
+			return;
+		}
+		// In Secure DFU with Bond Sharing the bond information should not be removed
+		intent.putExtra(DfuBaseService.EXTRA_KEEP_BOND, true);
+		intent.putExtra(DfuBaseService.EXTRA_RESTORE_BOND, false);
+
+		super.performDfu(intent);
+	}
+}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/ButtonlessDfuWithoutBondSharingImpl.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/ButtonlessDfuWithoutBondSharingImpl.java
new file mode 100644
index 0000000..897dddd
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/ButtonlessDfuWithoutBondSharingImpl.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.dfu;
+
+import android.bluetooth.BluetoothGatt;
+import android.bluetooth.BluetoothGattCharacteristic;
+import android.bluetooth.BluetoothGattService;
+import android.content.Intent;
+
+import java.util.UUID;
+
+import androidx.annotation.NonNull;
+import no.nordicsemi.android.dfu.internal.exception.DeviceDisconnectedException;
+import no.nordicsemi.android.dfu.internal.exception.DfuException;
+import no.nordicsemi.android.dfu.internal.exception.UploadAbortedException;
+
+/**
+ * This implementation handles 2 services:
+ * - a non-secure buttonless DFU service introduced in SDK 13
+ * - a secure buttonless DFU service that will be implemented in some next SDK (14 or later)
+ * <p>
+ * An application that supports one of those services should have the Secure DFU Service with one
+ * of those characteristic inside.
+ * <p>
+ * The non-secure one does not share the bond information to the bootloader, and the bootloader
+ * starts advertising with address +1 after the jump. It may be used by a bonded devices
+ * (it's even recommended, as it prevents from DoS attack), but the connection with the bootloader
+ * will not be encrypted (in Secure DFU it is not an issue as the firmware itself is signed).
+ * When implemented on a non-bonded device it is important to understand, that anyone could
+ * connect to the device and switch it to DFU mode preventing the device from normal usage.
+ * <p>
+ * The secure one requires the device to be paired so that only the trusted phone can switch it
+ * to bootloader mode. The bond information will be shared to the bootloader so it will use the
+ * same device address when in DFU mode and the connection will be encrypted.
+ */
+/* package */ class ButtonlessDfuWithoutBondSharingImpl extends ButtonlessDfuImpl {
+	/** The UUID of the Secure DFU service from SDK 12. */
+	static final UUID DEFAULT_BUTTONLESS_DFU_SERVICE_UUID = SecureDfuImpl.DEFAULT_DFU_SERVICE_UUID;
+	/** The UUID of the Secure Buttonless DFU characteristic without bond sharing from SDK 13. */
+	static final UUID DEFAULT_BUTTONLESS_DFU_UUID = new UUID(0x8EC90003F3154F60L, 0x9FB8838830DAEA50L);
+
+	static UUID BUTTONLESS_DFU_SERVICE_UUID = DEFAULT_BUTTONLESS_DFU_SERVICE_UUID;
+	static UUID BUTTONLESS_DFU_UUID         = DEFAULT_BUTTONLESS_DFU_UUID;
+
+	private BluetoothGattCharacteristic mButtonlessDfuCharacteristic;
+
+	ButtonlessDfuWithoutBondSharingImpl(@NonNull final Intent intent, @NonNull final DfuBaseService service) {
+		super(intent, service);
+	}
+
+	@Override
+	public boolean isClientCompatible(@NonNull final Intent intent, @NonNull final BluetoothGatt gatt) {
+		final BluetoothGattService dfuService = gatt.getService(BUTTONLESS_DFU_SERVICE_UUID);
+		if (dfuService == null)
+			return false;
+		final BluetoothGattCharacteristic characteristic = dfuService.getCharacteristic(BUTTONLESS_DFU_UUID);
+		if (characteristic == null || characteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG) == null)
+			return false;
+		mButtonlessDfuCharacteristic = characteristic;
+		return true;
+	}
+
+	@Override
+	protected int getResponseType() {
+		return INDICATIONS;
+	}
+
+	@Override
+	protected BluetoothGattCharacteristic getButtonlessDfuCharacteristic() {
+		return mButtonlessDfuCharacteristic;
+	}
+
+	@Override
+	protected boolean shouldScanForBootloader() {
+		return true;
+	}
+
+	@Override
+	public void performDfu(@NonNull final Intent intent)
+			throws DfuException, DeviceDisconnectedException, UploadAbortedException {
+		logi("Buttonless service without bond sharing found -> SDK 13 or newer");
+		if (isBonded()) {
+			logw("Device is paired! Use Buttonless DFU with Bond Sharing instead (SDK 14 or newer)");
+		}
+
+		super.performDfu(intent);
+	}
+}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuBaseService.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuBaseService.java
new file mode 100644
index 0000000..04b2336
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuBaseService.java
@@ -0,0 +1,2060 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.dfu;
+
+import android.annotation.SuppressLint;
+import android.app.Activity;
+import android.app.IntentService;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothGatt;
+import android.bluetooth.BluetoothGattCallback;
+import android.bluetooth.BluetoothGattCharacteristic;
+import android.bluetooth.BluetoothGattDescriptor;
+import android.bluetooth.BluetoothManager;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.SharedPreferences;
+import android.database.Cursor;
+import android.graphics.Color;
+import android.net.Uri;
+import android.os.Build;
+import android.os.SystemClock;
+import android.preference.PreferenceManager;
+import android.provider.MediaStore;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.core.app.NotificationCompat;
+import androidx.localbroadcastmanager.content.LocalBroadcastManager;
+import android.util.Log;
+
+import java.io.ByteArrayInputStream;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.reflect.Method;
+import java.util.Locale;
+
+import no.nordicsemi.android.dfu.internal.ArchiveInputStream;
+import no.nordicsemi.android.dfu.internal.HexInputStream;
+import no.nordicsemi.android.dfu.internal.exception.DeviceDisconnectedException;
+import no.nordicsemi.android.dfu.internal.exception.DfuException;
+import no.nordicsemi.android.dfu.internal.exception.SizeValidationException;
+import no.nordicsemi.android.dfu.internal.exception.UploadAbortedException;
+import no.nordicsemi.android.error.GattError;
+
+/**
+ * The DFU Service provides full support for Over-the-Air (OTA) Device Firmware Update (DFU)
+ * by Nordic Semiconductor.
+ * With the Soft Device 7.0.0+ it allows to upload a new Soft Device, new Bootloader and a
+ * new Application. For older soft devices only the Application update is supported.
+ * <p>
+ * To run the service to your application extend it in your project and overwrite the missing method.
+ * Remember to add your service class to the AndroidManifest.xml file.
+ * <p>
+ * The {@link DfuServiceInitiator} object should be used to start the DFU Service.
+ * <pre>
+ * final DfuServiceInitiator starter = new DfuServiceInitiator(mSelectedDevice.getAddress())
+ * 		.setDeviceName(mSelectedDevice.getName())
+ * 		.setKeepBond(keepBond)
+ * 		.setZip(mFileStreamUri, mFilePath) // where one, URI or path, should be null
+ *		.start(this, DfuService.class);
+ * </pre>
+ * <p>
+ * You may register the progress and log listeners using the {@link DfuServiceListenerHelper}
+ * helper class. See {@link DfuProgressListener} and {@link DfuLogListener} for more information.
+ * <p>
+ * The service will show its progress on the notification bar and will send local broadcasts to the
+ * application.
+ */
+@SuppressLint("MissingPermission")
+@SuppressWarnings("deprecation")
+public abstract class DfuBaseService extends IntentService implements DfuProgressInfo.ProgressListener {
+	private static final String TAG = "DfuBaseService";
+
+	/* package */ static boolean DEBUG = false;
+
+	public static final int NOTIFICATION_ID = 283; // a random number
+	public static final String NOTIFICATION_CHANNEL_DFU = "dfu";
+
+	/**
+	 * The address of the device to update.
+	 */
+	public static final String EXTRA_DEVICE_ADDRESS = "no.nordicsemi.android.dfu.extra.EXTRA_DEVICE_ADDRESS";
+	/**
+	 * The optional device name. This name will be shown in the notification.
+	 */
+	public static final String EXTRA_DEVICE_NAME = "no.nordicsemi.android.dfu.extra.EXTRA_DEVICE_NAME";
+	/**
+	 * A boolean indicating whether to disable the progress notification in the status bar.
+	 * Defaults to false.
+	 */
+	public static final String EXTRA_DISABLE_NOTIFICATION = "no.nordicsemi.android.dfu.extra.EXTRA_DISABLE_NOTIFICATION";
+	/**
+	 * A boolean indicating whether the DFU service should be set as a foreground service.
+	 * It is recommended to have it as a background service at least on Android Oreo or newer as
+	 * the background service will be killed by the system few moments after the user closed the
+	 * foreground app.
+	 * <p>
+	 * Read more here: <a href="https://developer.android.com/about/versions/oreo/background.html">https://developer.android.com/about/versions/oreo/background.html</a>
+	 */
+	public static final String EXTRA_FOREGROUND_SERVICE = "no.nordicsemi.android.dfu.extra.EXTRA_FOREGROUND_SERVICE";
+	/**
+	 * An extra private field indicating which reconnection attempt is being performed.
+	 * In case of error 133 the service will retry to connect 2 more times.
+	 */
+	private static final String EXTRA_RECONNECTION_ATTEMPT = "no.nordicsemi.android.dfu.extra.EXTRA_RECONNECTION_ATTEMPT";
+	/**
+	 * An extra private field indicating which DFU attempt is being performed.
+	 * If the target device will disconnect for some unknown reason during DFU, the service will
+	 * retry to connect and continue. In case of Legacy DFU it will reconnect and restart process.
+	 */
+	/* package */ static final String EXTRA_DFU_ATTEMPT = "no.nordicsemi.android.dfu.extra.EXTRA_DFU_ATTEMPT";
+	/**
+	 * Maximum number of DFU attempts. Default value is 0.
+	 */
+	public static final String EXTRA_MAX_DFU_ATTEMPTS = "no.nordicsemi.android.dfu.extra.EXTRA_MAX_DFU_ATTEMPTS";
+	/**
+	 * If the new firmware (application) does not share the bond information with the old one,
+	 * the bond information is lost. Set this flag to <code>true</code> to make the service create
+	 * new bond with the new application when the upload is done (and remove the old one).
+	 * When set to <code>false</code> (default), the DFU service assumes that the LTK is shared
+	 * between them. Note: currently it is not possible to remove the old bond without creating
+	 * a new one so if your old application supported bonding while the new one does not you have
+	 * to modify the source code yourself.
+	 * <p>
+	 * In case of updating the soft device the application is always removed together with the
+	 * bond information.
+	 * <p>
+	 * Search for occurrences of EXTRA_RESTORE_BOND in this file to check the implementation and
+	 * get more details.
+	 * <p>
+	 * This flag is ignored when Secure DFU Buttonless Service is used.
+	 * It will keep or will not restore the bond depending on the Buttonless service type.
+	 */
+	public static final String EXTRA_RESTORE_BOND = "no.nordicsemi.android.dfu.extra.EXTRA_RESTORE_BOND";
+	/**
+	 * This flag indicated whether the bond information should be kept or removed after an upgrade
+	 * of the Application. If an application is being updated on a bonded device with the DFU
+	 * Bootloader that has been configured to preserve the bond information for the new application,
+	 * set it to <code>true</code>.
+	 * <p>
+	 * By default the Legacy DFU Bootloader clears the whole application's memory. It may be,
+	 * however, configured in the \Nordic\nrf51\components\libraries\bootloader_dfu\dfu_types.h
+	 * file (sdk 11, line 76: <code>#define DFU_APP_DATA_RESERVED 0x0000</code>) to preserve some pages.
+	 * The BLE_APP_HRM_DFU sample app stores the LTK and System Attributes in the first
+	 * two pages, so in order to preserve the bond information this value should be changed to
+	 * 0x0800 or more. For Secure DFU this value is by default set to 3 pages.
+	 * When those data are preserved, the new Application will notify the app with the
+	 * Service Changed indication when launched for the first time. Otherwise this service will
+	 * remove the bond information from the phone and force to refresh the device cache
+	 * (see {@link #refreshDeviceCache(android.bluetooth.BluetoothGatt, boolean)}).
+	 * <p>
+	 * In contrast to {@link #EXTRA_RESTORE_BOND} this flag will not remove the old bonding and
+	 * recreate a new one, but will keep the bond information untouched.
+	 * <p>
+	 * The default value of this flag is <code>false</code>.
+	 * <p>
+	 * This flag is ignored when Secure DFU Buttonless Service is used. It will keep or remove the
+	 * bond depending on the Buttonless service type.
+	 */
+	public static final String EXTRA_KEEP_BOND = "no.nordicsemi.android.dfu.extra.EXTRA_KEEP_BOND";
+	/**
+	 * This property must contain a boolean value.
+	 * <p>
+	 * The {@link DfuBaseService}, when connected to a DFU target will check whether it is in
+	 * application or in DFU bootloader mode. For DFU implementations from SDK 7.0 or newer
+	 * this is done by reading the value of DFU Version characteristic.
+	 * If the returned value is equal to 0x0100 (major = 0, minor = 1) it means that we are in the
+	 * application mode and jump to the bootloader mode is required.
+	 * <p>
+	 * However, for DFU implementations from older SDKs, where there was no DFU Version
+	 * characteristic, the service must guess. If this option is set to false (default) it will count
+	 * number of device's services. If the count is equal to 3 (Generic Access, Generic Attribute,
+	 * DFU Service) it will assume that it's in DFU mode. If greater than 3 - in app mode.
+	 * This guessing may not be always correct. One situation may be when the nRF chip is used to
+	 * flash update on external MCU using DFU. The DFU procedure may be implemented in the
+	 * application, which may (and usually does) have more services.
+	 * In such case set the value of this property to true.
+	 */
+	public static final String EXTRA_FORCE_DFU = "no.nordicsemi.android.dfu.extra.EXTRA_FORCE_DFU";
+
+	/**
+	 * This flag indicates whether the service should scan for bootloader in Legacy DFU after
+	 * switching using buttonless service. The default value is false.
+	 */
+	public static final String EXTRA_FORCE_SCANNING_FOR_BOOTLOADER_IN_LEGACY_DFU = "no.nordicsemi.android.dfu.extra.EXTRA_FORCE_SCANNING_FOR_BOOTLOADER_IN_LEGACY_DFU";
+	/**
+	 * This options allows to disable the resume feature in Secure DFU. When the extra value is set
+	 * to true, the DFU will send Init Packet and Data again, despite the firmware might have been
+	 * send partially before. By default, without setting this extra, or by setting it to false,
+	 * the DFU will resume the previously cancelled upload if CRC values match.
+	 * <p>
+	 * It is ignored when Legacy DFU is used.
+	 * <p>
+	 * This feature seems to help in some cases:
+	 * <a href="https://github.com/NordicSemiconductor/Android-DFU-Library/issues/71">#71</a>.
+	 */
+	public static final String EXTRA_DISABLE_RESUME = "no.nordicsemi.android.dfu.extra.EXTRA_DISABLE_RESUME";
+	/**
+	 * The MBR size.
+	 *
+	 * @see DfuServiceInitiator#setMbrSize(int)
+	 */
+	public static final String EXTRA_MBR_SIZE = "no.nordicsemi.android.dfu.extra.EXTRA_MBR_SIZE";
+	/**
+	 * This extra allows you to control the MTU that will be requested (on Lollipop or newer devices).
+	 * If the field is null, the service will not request higher MTU and will use MTU = 23
+	 * (even if it has been set to a higher value before).
+	 */
+	public static final String EXTRA_MTU = "no.nordicsemi.android.dfu.extra.EXTRA_MTU";
+	/**
+	 * This extra value will be used when MTU request returned with an error. That means, that
+	 * MTU has been requested before and may not be changed again. This value will be used instead.
+	 */
+	public static final String EXTRA_CURRENT_MTU = "no.nordicsemi.android.dfu.extra.EXTRA_CURRENT_MTU";
+	/**
+	 * Set this flag to true to enable experimental buttonless feature in Secure DFU from SDK 12.
+	 * When the experimental Buttonless DFU Service is found on a device, the service will use it to
+	 * switch the device to the bootloader mode, connect to it in that mode and proceed with DFU.
+	 * <p>
+	 * <b>Please, read the information below before setting it to true.</b>
+	 * <p>
+	 * In the SDK 12.x the Buttonless DFU feature for Secure DFU was experimental.
+	 * It is NOT recommended to use it: it was not properly tested, had implementation bugs
+	 * (e.g. https://devzone.nordicsemi.com/question/100609/sdk-12-bootloader-erased-after-programming/)
+	 * and does not require encryption and therefore may lead to DOS attack (anyone can use it
+	 * to switch the device to bootloader mode). However, as there is no other way to trigger
+	 * bootloader mode on devices without a button, this DFU Library supports this service,
+	 * but the feature must be explicitly enabled here.
+	 * Be aware, that setting this flag to false will not protect your devices from this kind of
+	 * attacks, as an attacker may use another app for that purpose. To be sure your device is
+	 * secure remove this experimental service from your device.
+	 * <p>
+	 * <b>Spec:</b><br>
+	 * Buttonless DFU Service UUID: 8E400001-F315-4F60-9FB8-838830DAEA50<br>
+	 * Buttonless DFU characteristic UUID: 8E400001-F315-4F60-9FB8-838830DAEA50 (the same)<br>
+	 * Enter Bootloader Op Code: 0x01<br>
+	 * Correct return value: 0x20-01-01 , where:<br>
+	 * 0x20 - Response Op Code<br>
+	 * 0x01 - Request Code<br>
+	 * 0x01 - Success<br>
+	 * The device should disconnect and restart in DFU mode after sending the notification.
+	 * <p>
+	 * In SDK 14 this issue was fixed by Buttonless Service With Bonds.
+	 */
+	public static final String EXTRA_UNSAFE_EXPERIMENTAL_BUTTONLESS_DFU = "no.nordicsemi.android.dfu.extra.EXTRA_UNSAFE_EXPERIMENTAL_BUTTONLESS_DFU";
+	/**
+	 * The duration of a delay that will be added before sending each data packet in Secure DFU,
+	 * in milliseconds. This defaults to 0 for backwards compatibility reason.
+	 */
+	public static final String EXTRA_DATA_OBJECT_DELAY = "no.nordicsemi.android.dfu.extra.EXTRA_DATA_OBJECT_DELAY";
+	/**
+	 * This property must contain a boolean value.
+	 * <p>
+	 * If true the Packet Receipt Notification procedure will be enabled.
+	 * See DFU documentation on http://infocenter.nordicsemi.com for more details.
+	 * The number of packets before receiving a Packet Receipt Notification is set with property
+	 * {@link #EXTRA_PACKET_RECEIPT_NOTIFICATIONS_VALUE}.
+	 * The PRNs by default are enabled on devices running Android 4.3, 4.4.x and 5.x and
+	 * disabled on 6.x and newer.
+	 *
+	 * @see #EXTRA_PACKET_RECEIPT_NOTIFICATIONS_VALUE
+	 */
+	public static final String EXTRA_PACKET_RECEIPT_NOTIFICATIONS_ENABLED = "no.nordicsemi.android.dfu.extra.EXTRA_PRN_ENABLED";
+	/**
+	 * This property must contain a positive integer value, usually from range 1-200.
+	 * <p>
+	 * The default value is {@link DfuServiceInitiator#DEFAULT_PRN_VALUE}.
+	 * Setting it to 0 will disable the Packet Receipt Notification procedure.
+	 * When sending a firmware using the DFU procedure the service will send this number of packets
+	 * before waiting for a notification. Packet Receipt Notifications are used to synchronize
+	 * the sender with receiver.
+	 * <p>
+	 * On Android, calling
+	 * {@link android.bluetooth.BluetoothGatt#writeCharacteristic(BluetoothGattCharacteristic)}
+	 * simply adds the packet to outgoing queue before returning the callback. Adding the next
+	 * packet in the callback is much faster than the real transmission (also the speed depends on
+	 * the device chip manufacturer) and the queue may reach its limit. When does, the transmission
+	 * stops and Android Bluetooth hangs (see Note below). Using PRN procedure eliminates this
+	 * problem as the notification is send when all packets were delivered the queue is empty.
+	 * <p>
+	 * Note: this bug has been fixed on Android 6.0 Marshmallow and now no notifications are required.
+	 * The onCharacteristicWrite callback will be postponed until half of the queue is empty and
+	 * upload will be resumed automatically. Disabling PRNs speeds up the upload process on those
+	 * devices.
+	 *
+	 * @see #EXTRA_PACKET_RECEIPT_NOTIFICATIONS_ENABLED
+	 */
+	public static final String EXTRA_PACKET_RECEIPT_NOTIFICATIONS_VALUE = "no.nordicsemi.android.dfu.extra.EXTRA_PRN_VALUE";
+	/**
+	 * A path to the file with the new firmware. It may point to a HEX, BIN or a ZIP file.
+	 * Some file manager applications return the path as a String while other return a Uri.
+	 * Use the {@link #EXTRA_FILE_URI} in the later case. For files included
+	 * in /res/raw resource directory please use {@link #EXTRA_FILE_RES_ID} instead.
+	 */
+	public static final String EXTRA_FILE_PATH = "no.nordicsemi.android.dfu.extra.EXTRA_FILE_PATH";
+	/**
+	 * See {@link #EXTRA_FILE_PATH} for details.
+	 */
+	public static final String EXTRA_FILE_URI = "no.nordicsemi.android.dfu.extra.EXTRA_FILE_URI";
+	/**
+	 * See {@link #EXTRA_FILE_PATH} for details.
+	 */
+	public static final String EXTRA_FILE_RES_ID = "no.nordicsemi.android.dfu.extra.EXTRA_FILE_RES_ID";
+	/**
+	 * The Init packet URI. This file is required if the Extended Init Packet is required (SDK 7.0+).
+	 * Must point to a 'dat' file corresponding with the selected firmware.
+	 * The Init packet may contain just the CRC (in case of older versions of DFU) or the
+	 * Extended Init Packet in binary format (SDK 7.0+).
+	 */
+	public static final String EXTRA_INIT_FILE_PATH = "no.nordicsemi.android.dfu.extra.EXTRA_INIT_FILE_PATH";
+	/**
+	 * The Init packet URI. This file is required if the Extended Init Packet is required (SDK 7.0+).
+	 * Must point to a 'dat' file corresponding with the selected firmware.
+	 * The Init packet may contain just the CRC (in case of older versions of DFU) or the
+	 * Extended Init Packet in binary format (SDK 7.0+).
+	 */
+	public static final String EXTRA_INIT_FILE_URI = "no.nordicsemi.android.dfu.extra.EXTRA_INIT_FILE_URI";
+	/**
+	 * The Init packet URI. This file is required if the Extended Init Packet is required (SDK 7.0+).
+	 * Must point to a 'dat' file corresponding with the selected firmware.
+	 * The Init packet may contain just the CRC (in case of older versions of DFU) or the
+	 * Extended Init Packet in binary format (SDK 7.0+).
+	 */
+	public static final String EXTRA_INIT_FILE_RES_ID = "no.nordicsemi.android.dfu.extra.EXTRA_INIT_FILE_RES_ID";
+	/**
+	 * The input file mime-type. Currently only "application/zip" (ZIP) or "application/octet-stream"
+	 * (HEX or BIN) are supported. If this parameter is empty the "application/octet-stream" is assumed.
+	 */
+	public static final String EXTRA_FILE_MIME_TYPE = "no.nordicsemi.android.dfu.extra.EXTRA_MIME_TYPE";
+	// Since the DFU Library version 0.5 both HEX and BIN files are supported.
+	// As both files have the same MIME TYPE the distinction is made based on the file extension.
+	public static final String MIME_TYPE_OCTET_STREAM = "application/octet-stream";
+	public static final String MIME_TYPE_ZIP = "application/zip";
+	/**
+	 * This optional extra parameter may contain a file type. Currently supported are:
+	 * <ul>
+	 * <li>{@link #TYPE_SOFT_DEVICE} - only Soft Device update</li>
+	 * <li>{@link #TYPE_BOOTLOADER} - only Bootloader update</li>
+	 * <li>{@link #TYPE_APPLICATION} - only application update</li>
+	 * <li>{@link #TYPE_AUTO} - the file is a ZIP file that may contain more than one HEX/BIN + DAT files.
+	 * Since SDK 8.0 the ZIP Distribution packet is a recommended way of delivering firmware files.
+	 * Please, see the DFU documentation for more details. A ZIP distribution packet may be created
+	 * using the 'nrf util' Python application, available at
+	 * <a href="https://github.com/NordicSemiconductor/pc-nrfutil">https://github.com/NordicSemiconductor/pc-nrfutil</a>.
+	 * The ZIP file MAY contain only the following files: <b>softdevice.hex/bin</b>,
+	 * <b>bootloader.hex/bin</b>, <b>application.hex/bin</b> to determine the type based on its name.
+	 * At lease one of them MUST be present.
+	 * </li>
+	 * </ul>
+	 * If this parameter is not provided the type is assumed as follows:
+	 * <ol>
+	 * <li>If the {@link #EXTRA_FILE_MIME_TYPE} field is <code>null</code> or is equal to
+	 * {@value #MIME_TYPE_OCTET_STREAM} - the {@link #TYPE_APPLICATION} is assumed.</li>
+	 * <li>If the {@link #EXTRA_FILE_MIME_TYPE} field is equal to {@value #MIME_TYPE_ZIP}
+	 * - the {@link #TYPE_AUTO} is assumed.</li>
+	 * </ol>
+	 */
+	public static final String EXTRA_FILE_TYPE = "no.nordicsemi.android.dfu.extra.EXTRA_FILE_TYPE";
+	/**
+	 * <p>
+	 * The file contains a new version of Soft Device.
+	 * <p>
+	 * Since DFU Library 7.0 all firmware may contain an Init packet. The Init packet is required
+	 * if Extended Init Packet is used by the DFU bootloader (SDK 7.0+)..
+	 * The Init packet for the bootloader must be placed in the .dat file.
+	 *
+	 * @see #EXTRA_FILE_TYPE
+	 */
+	public static final int TYPE_SOFT_DEVICE = 0x01;
+	/**
+	 * <p>
+	 * The file contains a new version of Bootloader.
+	 * <p>
+	 * Since DFU Library 7.0 all firmware may contain an Init packet. The Init packet is required
+	 * if Extended Init Packet is used by the DFU bootloader (SDK 7.0+).
+	 * The Init packet for the bootloader must be placed in the .dat file.
+	 *
+	 * @see #EXTRA_FILE_TYPE
+	 */
+	public static final int TYPE_BOOTLOADER = 0x02;
+	/**
+	 * <p>
+	 * The file contains a new version of Application.
+	 * <p>
+	 * Since DFU Library 0.5 all firmware may contain an Init packet. The Init packet is required
+	 * if Extended Init Packet is used by the DFU bootloader (SDK 7.0+).
+	 * The Init packet for the application must be placed in the .dat file.
+	 *
+	 * @see #EXTRA_FILE_TYPE
+	 */
+	public static final int TYPE_APPLICATION = 0x04;
+	/**
+	 * <p>
+	 * A ZIP file that consists of more than 1 file. Since SDK 8.0 the ZIP Distribution packet is
+	 * a recommended way of delivering firmware files. Please, see the DFU documentation for
+	 * more details. A ZIP distribution packet may be created using the 'nrf utility' command line
+	 * application, that is a part of Master Control Panel 3.8.0.
+	 * For backwards compatibility this library supports also ZIP files without the manifest file.
+	 * Instead they must follow the fixed naming convention:
+	 * The names of files in the ZIP must be: <b>softdevice.hex</b> (or .bin), <b>bootloader.hex</b>
+	 * (or .bin), <b>application.hex</b> (or .bin) in order to be read correctly. Using the
+	 * Soft Device v7.0.0+ the Soft Device and Bootloader may be updated and sent together.
+	 * In case of additional application file included, the service will try to send Soft Device,
+	 * Bootloader and Application together (which is not supported currently) and if it fails,
+	 * send first SD+BL, reconnect and send the application in the following connection.
+	 * <p>
+	 * Since the DFU Library 0.5 you may specify the Init packet, that will be send prior to the
+	 * firmware. The init packet contains some verification data, like a device type and revision,
+	 * application version or a list of supported Soft Devices. The Init packet is required if
+	 * Extended Init Packet is used by the DFU bootloader (SDK 7.0+).
+	 * In case of using the compatibility ZIP files the Init packet for the Soft Device and Bootloader
+	 * must be in the 'system.dat' file while for the application in the 'application.dat' file
+	 * (included in the ZIP). The CRC in the 'system.dat' must be a CRC of both BIN contents if
+	 * both a Soft Device and a Bootloader is present.
+	 *
+	 * @see #EXTRA_FILE_TYPE
+	 */
+	public static final int TYPE_AUTO = 0x00;
+	/**
+	 * An extra field with progress and error information used in broadcast events.
+	 */
+	public static final String EXTRA_DATA = "no.nordicsemi.android.dfu.extra.EXTRA_DATA";
+	/**
+	 * An extra field to send the progress or error information in the DFU notification.
+	 * The value may contain:
+	 * <ul>
+	 * <li>Value 0 - 100 - percentage progress value</li>
+	 * <li>One of the following status constants:
+	 * <ul>
+	 * <li>{@link #PROGRESS_CONNECTING}</li>
+	 * <li>{@link #PROGRESS_STARTING}</li>
+	 * <li>{@link #PROGRESS_ENABLING_DFU_MODE}</li>
+	 * <li>{@link #PROGRESS_VALIDATING}</li>
+	 * <li>{@link #PROGRESS_DISCONNECTING}</li>
+	 * <li>{@link #PROGRESS_COMPLETED}</li>
+	 * <li>{@link #PROGRESS_ABORTED}</li>
+	 * </ul>
+	 * </li>
+	 * <li>An error code with {@link #ERROR_MASK} if initialization error occurred</li>
+	 * <li>An error code with {@link #ERROR_REMOTE_MASK} if remote DFU target returned an error</li>
+	 * <li>An error code with {@link #ERROR_CONNECTION_MASK} if connection error occurred
+	 * (e.g. GATT error (133) or Internal GATT Error (129))</li>
+	 * </ul>
+	 * To check if error occurred use:<br>
+	 * {@code boolean error = progressValue >= DfuBaseService.ERROR_MASK;}
+	 */
+	public static final String EXTRA_PROGRESS = "no.nordicsemi.android.dfu.extra.EXTRA_PROGRESS";
+	/**
+	 * The number of currently transferred part. The SoftDevice and Bootloader may be send
+	 * together as one part. If user wants to upload them together with an application it has to be
+	 * sent in another connection as the second part.
+	 *
+	 * @see no.nordicsemi.android.dfu.DfuBaseService#EXTRA_PARTS_TOTAL
+	 */
+	public static final String EXTRA_PART_CURRENT = "no.nordicsemi.android.dfu.extra.EXTRA_PART_CURRENT";
+	/**
+	 * Number of parts in total.
+	 *
+	 * @see no.nordicsemi.android.dfu.DfuBaseService#EXTRA_PART_CURRENT
+	 */
+	public static final String EXTRA_PARTS_TOTAL = "no.nordicsemi.android.dfu.extra.EXTRA_PARTS_TOTAL";
+	/**
+	 * The current upload speed in bytes/millisecond.
+	 */
+	public static final String EXTRA_SPEED_B_PER_MS = "no.nordicsemi.android.dfu.extra.EXTRA_SPEED_B_PER_MS";
+	/**
+	 * The average upload speed in bytes/millisecond for the current part.
+	 */
+	public static final String EXTRA_AVG_SPEED_B_PER_MS = "no.nordicsemi.android.dfu.extra.EXTRA_AVG_SPEED_B_PER_MS";
+	/**
+	 * The broadcast message contains the following extras:
+	 * <ul>
+	 * <li>{@link #EXTRA_DATA} - the progress value (percentage 0-100) or:
+	 * <ul>
+	 * <li>{@link #PROGRESS_CONNECTING}</li>
+	 * <li>{@link #PROGRESS_STARTING}</li>
+	 * <li>{@link #PROGRESS_ENABLING_DFU_MODE}</li>
+	 * <li>{@link #PROGRESS_VALIDATING}</li>
+	 * <li>{@link #PROGRESS_DISCONNECTING}</li>
+	 * <li>{@link #PROGRESS_COMPLETED}</li>
+	 * <li>{@link #PROGRESS_ABORTED}</li>
+	 * </ul>
+	 * </li>
+	 * <li>{@link #EXTRA_DEVICE_ADDRESS} - the target device address</li>
+	 * <li>{@link #EXTRA_PART_CURRENT} - the number of currently transmitted part</li>
+	 * <li>{@link #EXTRA_PARTS_TOTAL} - total number of parts that are being sent, e.g. if a ZIP
+	 * file contains a Soft Device, a Bootloader and an Application, the SoftDevice and Bootloader
+	 * will be send together as one part. Then the service will disconnect and reconnect to the
+	 * new Bootloader and send the application as part number two.</li>
+	 * <li>{@link #EXTRA_SPEED_B_PER_MS} - current speed in bytes/millisecond as float</li>
+	 * <li>{@link #EXTRA_AVG_SPEED_B_PER_MS} - the average transmission speed in bytes/millisecond
+	 * as float</li>
+	 * </ul>
+	 */
+	public static final String BROADCAST_PROGRESS = "no.nordicsemi.android.dfu.broadcast.BROADCAST_PROGRESS";
+	/**
+	 * Service is connecting to the remote DFU target.
+	 */
+	public static final int PROGRESS_CONNECTING = -1;
+	/**
+	 * Service is enabling notifications and starting transmission.
+	 */
+	public static final int PROGRESS_STARTING = -2;
+	/**
+	 * Service has triggered a switch to bootloader mode. Now the service waits for the link loss
+	 * event (this may take up to several seconds) and will connect again to the same device,
+	 * now started in the bootloader mode.
+	 */
+	public static final int PROGRESS_ENABLING_DFU_MODE = -3;
+	/**
+	 * Service is sending validation request to the remote DFU target.
+	 */
+	public static final int PROGRESS_VALIDATING = -4;
+	/**
+	 * Service is disconnecting from the DFU target.
+	 */
+	public static final int PROGRESS_DISCONNECTING = -5;
+	/**
+	 * The connection is successful.
+	 */
+	public static final int PROGRESS_COMPLETED = -6;
+	/**
+	 * The upload has been aborted. Previous software version will be restored on the target.
+	 */
+	public static final int PROGRESS_ABORTED = -7;
+	/**
+	 * The broadcast error message contains the following extras:
+	 * <ul>
+	 * <li>{@link #EXTRA_DATA} - the error number. Use {@link GattError#parse(int)} to get String
+	 * representation.</li>
+	 * <li>{@link #EXTRA_DEVICE_ADDRESS} - the target device address</li>
+	 * </ul>
+	 */
+	public static final String BROADCAST_ERROR = "no.nordicsemi.android.dfu.broadcast.BROADCAST_ERROR";
+	/**
+	 * The type of the error. This extra contains information about that kind of error has occurred.
+	 * Connection state errors and other errors may share the same numbers. For example, the
+	 * {@link BluetoothGattCallback#onCharacteristicWrite(BluetoothGatt, BluetoothGattCharacteristic, int)}
+	 * method may return a status code 8 (GATT INSUF AUTHORIZATION), while the status code 8
+	 * returned by {@link BluetoothGattCallback#onConnectionStateChange(BluetoothGatt, int, int)}
+	 * is a GATT CONN TIMEOUT error.
+	 */
+	public static final String EXTRA_ERROR_TYPE = "no.nordicsemi.android.dfu.extra.EXTRA_ERROR_TYPE";
+	public static final int ERROR_TYPE_OTHER = 0;
+	public static final int ERROR_TYPE_COMMUNICATION_STATE = 1;
+	public static final int ERROR_TYPE_COMMUNICATION = 2;
+	public static final int ERROR_TYPE_DFU_REMOTE = 3;
+	/**
+	 * If this bit is set than the progress value indicates an error. Use {@link GattError#parse(int)}
+	 * to obtain error name.
+	 */
+	public static final int ERROR_MASK = 0x1000;
+	public static final int ERROR_DEVICE_DISCONNECTED = ERROR_MASK; // | 0x00;
+	public static final int ERROR_FILE_NOT_FOUND = ERROR_MASK | 0x01;
+	/**
+	 * Thrown if service was unable to open the file ({@link java.io.IOException} has been thrown).
+	 */
+	public static final int ERROR_FILE_ERROR = ERROR_MASK | 0x02;
+	/**
+	 * Thrown when input file is not a valid HEX or ZIP file.
+	 */
+	public static final int ERROR_FILE_INVALID = ERROR_MASK | 0x03;
+	/**
+	 * Thrown when {@link java.io.IOException} occurred when reading from file.
+	 */
+	public static final int ERROR_FILE_IO_EXCEPTION = ERROR_MASK | 0x04;
+	/**
+	 * Error thrown when {@code gatt.discoverServices();} returns false.
+	 */
+	public static final int ERROR_SERVICE_DISCOVERY_NOT_STARTED = ERROR_MASK | 0x05;
+	/**
+	 * Thrown when the service discovery has finished but the DFU service has not been found.
+	 * The device does not support DFU of is not in DFU mode.
+	 */
+	public static final int ERROR_SERVICE_NOT_FOUND = ERROR_MASK | 0x06;
+	/**
+	 * Thrown when unknown response has been obtained from the target. The DFU target must follow
+	 * specification.
+	 */
+	public static final int ERROR_INVALID_RESPONSE = ERROR_MASK | 0x08;
+	/**
+	 * Thrown when the the service does not support given type or mime-type.
+	 */
+	public static final int ERROR_FILE_TYPE_UNSUPPORTED = ERROR_MASK | 0x09;
+	/**
+	 * Thrown when the the Bluetooth adapter is disabled.
+	 */
+	public static final int ERROR_BLUETOOTH_DISABLED = ERROR_MASK | 0x0A;
+	/**
+	 * DFU Bootloader version 0.6+ requires sending the Init packet. If such bootloader version is
+	 * detected, but the init packet has not been set this error is thrown.
+	 */
+	public static final int ERROR_INIT_PACKET_REQUIRED = ERROR_MASK | 0x0B;
+	/**
+	 * Thrown when the firmware file is not word-aligned. The firmware size must be dividable by
+	 * 4 bytes.
+	 */
+	public static final int ERROR_FILE_SIZE_INVALID = ERROR_MASK | 0x0C;
+	/**
+	 * Thrown when the received CRC does not match with the calculated one. The service will try
+	 * 3 times to send the data, and if the CRC fails each time this error will be thrown.
+	 */
+	public static final int ERROR_CRC_ERROR = ERROR_MASK | 0x0D;
+	/**
+	 * Thrown when device had to be paired before the DFU process was started.
+	 */
+	public static final int ERROR_DEVICE_NOT_BONDED = ERROR_MASK | 0x0E;
+	/**
+	 * Thrown when the DFU library lost track of what is going on. Reported number of bytes is
+	 * not equal to the number of bytes sent and due to some other events the library cannot recover.
+	 * <p>
+	 * Check https://github.com/NordicSemiconductor/Android-DFU-Library/issues/229
+	 */
+	public static final int ERROR_PROGRESS_LOST = ERROR_MASK | 0x0F;
+	/**
+	 * Flag set when the DFU target returned a DFU error. Look for DFU specification to get error
+	 * codes. The error code is binary OR-ed with one of: {@link #ERROR_REMOTE_TYPE_LEGACY},
+	 * {@link #ERROR_REMOTE_TYPE_SECURE} or {@link #ERROR_REMOTE_TYPE_SECURE_EXTENDED}.
+	 */
+	public static final int ERROR_REMOTE_MASK = 0x2000;
+	public static final int ERROR_REMOTE_TYPE_LEGACY = 0x0100;
+	public static final int ERROR_REMOTE_TYPE_SECURE = 0x0200;
+	public static final int ERROR_REMOTE_TYPE_SECURE_EXTENDED = 0x0400;
+	public static final int ERROR_REMOTE_TYPE_SECURE_BUTTONLESS = 0x0800;
+	/**
+	 * The flag set when one of {@link android.bluetooth.BluetoothGattCallback} methods was called
+	 * with status other than {@link android.bluetooth.BluetoothGatt#GATT_SUCCESS}.
+	 */
+	public static final int ERROR_CONNECTION_MASK = 0x4000;
+	/**
+	 * The flag set when the
+	 * {@link android.bluetooth.BluetoothGattCallback#onConnectionStateChange(android.bluetooth.BluetoothGatt, int, int)}
+	 * method was called with status other than {@link android.bluetooth.BluetoothGatt#GATT_SUCCESS}.
+	 */
+	public static final int ERROR_CONNECTION_STATE_MASK = 0x8000;
+	/**
+	 * The log events are only broadcast when there is no nRF Logger installed.
+	 * The broadcast contains 2 extras:
+	 * <ul>
+	 * <li>{@link #EXTRA_LOG_LEVEL} - The log level, one of following: {@link #LOG_LEVEL_DEBUG},
+	 * {@link #LOG_LEVEL_VERBOSE}, {@link #LOG_LEVEL_INFO}, {@link #LOG_LEVEL_APPLICATION},
+	 * {@link #LOG_LEVEL_WARNING}, {@link #LOG_LEVEL_ERROR}</li>
+	 * <li>{@link #EXTRA_LOG_MESSAGE} - The log message</li>
+	 * </ul>
+	 */
+	public static final String BROADCAST_LOG = "no.nordicsemi.android.dfu.broadcast.BROADCAST_LOG";
+	public static final String EXTRA_LOG_MESSAGE = "no.nordicsemi.android.dfu.extra.EXTRA_LOG_INFO";
+	public static final String EXTRA_LOG_LEVEL = "no.nordicsemi.android.dfu.extra.EXTRA_LOG_LEVEL";
+	/*
+	 * Note:
+	 * The nRF Logger API library has been excluded from the DfuLibrary.
+	 * All log events are now being sent using local broadcasts and may be logged into nRF Logger
+	 * in the app module. This is to make the Dfu module independent from logging tool.
+	 *
+	 * The log levels below are equal to log levels in nRF Logger API library, v 2.0.
+	 * @see https://github.com/NordicSemiconductor/nRF-Logger-API
+	 */
+	/**
+	 * Level used just for debugging purposes. It has lowest level
+	 */
+	public final static int LOG_LEVEL_DEBUG = 0;
+	/**
+	 * Log entries with minor importance
+	 */
+	public final static int LOG_LEVEL_VERBOSE = 1;
+	/**
+	 * Default logging level for important entries
+	 */
+	public final static int LOG_LEVEL_INFO = 5;
+	/**
+	 * Log entries level for applications
+	 */
+	public final static int LOG_LEVEL_APPLICATION = 10;
+	/**
+	 * Log entries with high importance
+	 */
+	public final static int LOG_LEVEL_WARNING = 15;
+	/**
+	 * Log entries with very high importance, like errors
+	 */
+	public final static int LOG_LEVEL_ERROR = 20;
+	/**
+	 * Activity may broadcast this broadcast in order to pause, resume or abort DFU process.
+	 * Use {@link #EXTRA_ACTION} extra to pass the action.
+	 */
+	public static final String BROADCAST_ACTION = "no.nordicsemi.android.dfu.broadcast.BROADCAST_ACTION";
+	/**
+	 * The action extra. It may have one of the following values: {@link #ACTION_PAUSE},
+	 * {@link #ACTION_RESUME}, {@link #ACTION_ABORT}.
+	 */
+	public static final String EXTRA_ACTION = "no.nordicsemi.android.dfu.extra.EXTRA_ACTION";
+	/**
+	 * Pauses the upload. The service will wait for broadcasts with the action set to
+	 * {@link #ACTION_RESUME} or {@link #ACTION_ABORT}.
+	 */
+	public static final int ACTION_PAUSE = 0;
+	/** Resumes the upload that has been paused before using {@link #ACTION_PAUSE}. */
+	public static final int ACTION_RESUME = 1;
+	/**
+	 * Aborts the upload. The service does not need to be paused before.
+	 * After sending {@link #BROADCAST_ACTION} with extra {@link #EXTRA_ACTION} set to this value
+	 * the DFU bootloader will restore the old application (if there was already an application).
+	 * Be aware, that uploading the Soft Device will erase the application in order to make space
+	 * in the memory. In case there is no application, or the application has been removed, the
+	 * DFU bootloader will be started and user may try to send the application again.
+	 * The bootloader may advertise with the address incremented by 1 to prevent caching services.
+	 */
+	public static final int ACTION_ABORT = 2;
+
+	public static final String EXTRA_SCAN_DELAY = "no.nordicsemi.android.dfu.extra.EXTRA_SCAN_DELAY";
+	public static final String EXTRA_SCAN_TIMEOUT = "no.nordicsemi.android.dfu.extra.EXTRA_SCAN_TIMEOUT";
+
+	public static final String EXTRA_CUSTOM_UUIDS_FOR_LEGACY_DFU = "no.nordicsemi.android.dfu.extra.EXTRA_CUSTOM_UUIDS_FOR_LEGACY_DFU";
+	public static final String EXTRA_CUSTOM_UUIDS_FOR_SECURE_DFU = "no.nordicsemi.android.dfu.extra.EXTRA_CUSTOM_UUIDS_FOR_SECURE_DFU";
+	public static final String EXTRA_CUSTOM_UUIDS_FOR_EXPERIMENTAL_BUTTONLESS_DFU = "no.nordicsemi.android.dfu.extra.EXTRA_CUSTOM_UUIDS_FOR_EXPERIMENTAL_BUTTONLESS_DFU";
+	public static final String EXTRA_CUSTOM_UUIDS_FOR_BUTTONLESS_DFU_WITHOUT_BOND_SHARING = "no.nordicsemi.android.dfu.extra.EXTRA_CUSTOM_UUIDS_FOR_BUTTONLESS_DFU_WITHOUT_BOND_SHARING";
+	public static final String EXTRA_CUSTOM_UUIDS_FOR_BUTTONLESS_DFU_WITH_BOND_SHARING = "no.nordicsemi.android.dfu.extra.EXTRA_CUSTOM_UUIDS_FOR_BUTTONLESS_DFU_WITH_BOND_SHARING";
+
+	/**
+	 * Lock used in synchronization purposes
+	 */
+	private final Object mLock = new Object();
+	private BluetoothAdapter mBluetoothAdapter;
+	private String mDeviceAddress;
+	private String mDeviceName;
+	private boolean mDisableNotification;
+	/**
+	 * The current connection state. If its value is > 0 than an error has occurred.
+	 * Error number is a negative value of mConnectionState
+	 */
+	protected int mConnectionState;
+	protected final static int STATE_DISCONNECTED = 0;
+	protected final static int STATE_CONNECTING = -1;
+	protected final static int STATE_CONNECTED = -2;
+	protected final static int STATE_CONNECTED_AND_READY = -3; // indicates that services were discovered
+	protected final static int STATE_DISCONNECTING = -4;
+	protected final static int STATE_CLOSED = -5;
+	/**
+	 * The number of the last error that has occurred or 0 if there was no error
+	 */
+	private int mError;
+	/**
+	 * Stores the last progress percent. Used to prevent from sending progress notifications with
+	 * the same value.
+	 */
+	private int mLastProgress = -1;
+	/* package */ DfuProgressInfo mProgressInfo;
+	private long mLastNotificationTime;
+
+	/** Flag set to true if sending was aborted. */
+	private boolean mAborted;
+
+	private DfuCallback mDfuServiceImpl;
+	private InputStream mFirmwareInputStream, mInitFileInputStream;
+
+	private final BroadcastReceiver mDfuActionReceiver = new BroadcastReceiver() {
+		@Override
+		public void onReceive(final Context context, final Intent intent) {
+			final int action = intent.getIntExtra(EXTRA_ACTION, 0);
+
+			logi("User action received: " + action);
+			switch (action) {
+				case ACTION_PAUSE:
+					sendLogBroadcast(LOG_LEVEL_WARNING, "[Broadcast] Pause action received");
+					if (mDfuServiceImpl != null)
+						mDfuServiceImpl.pause();
+					break;
+				case ACTION_RESUME:
+					sendLogBroadcast(LOG_LEVEL_WARNING, "[Broadcast] Resume action received");
+					if (mDfuServiceImpl != null)
+						mDfuServiceImpl.resume();
+					break;
+				case ACTION_ABORT:
+					sendLogBroadcast(LOG_LEVEL_WARNING, "[Broadcast] Abort action received");
+					mAborted = true;
+					if (mDfuServiceImpl != null)
+						mDfuServiceImpl.abort();
+					break;
+			}
+		}
+	};
+
+	private final BroadcastReceiver mBluetoothStateBroadcastReceiver = new BroadcastReceiver() {
+		@Override
+		public void onReceive(final Context context, final Intent intent) {
+			final int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.STATE_OFF);
+			final int previousState = intent.getIntExtra(BluetoothAdapter.EXTRA_PREVIOUS_STATE, BluetoothAdapter.STATE_ON);
+			logw("Action received: android.bluetooth.adapter.action.STATE_CHANGED [state: " + state + ", previous state: " + previousState + "]");
+			if (previousState == BluetoothAdapter.STATE_ON
+					&& (state == BluetoothAdapter.STATE_TURNING_OFF || state == BluetoothAdapter.STATE_OFF)) {
+				sendLogBroadcast(LOG_LEVEL_WARNING, "Bluetooth adapter disabled");
+				mConnectionState = STATE_DISCONNECTED;
+				if (mDfuServiceImpl != null)
+					mDfuServiceImpl.getGattCallback().onDisconnected();
+
+				// Notify waiting thread
+				synchronized (mLock) {
+					mLock.notifyAll();
+				}
+			}
+		}
+	};
+
+	private final BroadcastReceiver mBondStateBroadcastReceiver = new BroadcastReceiver() {
+		@Override
+		public void onReceive(final Context context, final Intent intent) {
+			// Obtain the device and check if this is the one that we are connected to
+			final BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+			if (device == null || !device.getAddress().equals(mDeviceAddress))
+				return;
+
+			// Read bond state
+			final int bondState = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, -1);
+			if (bondState == BluetoothDevice.BOND_BONDING)
+				return;
+
+			if (mDfuServiceImpl != null)
+				mDfuServiceImpl.onBondStateChanged(bondState);
+		}
+	};
+
+	private final BroadcastReceiver mConnectionStateBroadcastReceiver = new BroadcastReceiver() {
+		@Override
+		public void onReceive(final Context context, final Intent intent) {
+			// Obtain the device and check it this is the one that we are connected to
+			final BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+			if (device == null || !device.getAddress().equals(mDeviceAddress))
+				return;
+
+			final String action = intent.getAction();
+
+			logi("Action received: " + action);
+			sendLogBroadcast(LOG_LEVEL_DEBUG, "[Broadcast] Action received: " + action);
+			/*
+			Handling the disconnection event here could lead to race conditions, as it also may (most probably will)
+			be delivered to onConnectionStateChange below.
+			See: https://github.com/NordicSemiconductor/Android-DFU-Library/issues/55
+
+			Note: This broadcast is now received on all 3 ACL events!
+				  Don't assume DISCONNECT here.
+
+			mConnectionState = STATE_DISCONNECTED;
+
+			if (mDfuServiceImpl != null)
+				mDfuServiceImpl.getGattCallback().onDisconnected();
+
+			// Notify waiting thread
+			synchronized (mLock) {
+				mLock.notifyAll();
+			}
+			*/
+		}
+	};
+
+	private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() {
+		@Override
+		public void onConnectionStateChange(final BluetoothGatt gatt, final int status, final int newState) {
+			// Check whether an error occurred
+			if (status == BluetoothGatt.GATT_SUCCESS) {
+				if (newState == BluetoothGatt.STATE_CONNECTED) {
+					logi("Connected to GATT server");
+					sendLogBroadcast(LOG_LEVEL_INFO, "Connected to " + mDeviceAddress);
+					mConnectionState = STATE_CONNECTED;
+
+					/*
+					 * The onConnectionStateChange callback is called just after establishing connection and before sending Encryption Request BLE event in case of a paired device.
+					 * In that case and when the Service Changed CCCD is enabled we will get the indication after initializing the encryption, about 1600 milliseconds later.
+					 * If we discover services right after connecting, the onServicesDiscovered callback will be called immediately, before receiving the indication and the following
+					 * service discovery and we may end up with old, application's services instead.
+					 *
+					 * This is to support the buttonless switch from application to bootloader mode where the DFU bootloader notifies the master about service change.
+					 * Tested on Nexus 4 (Android 4.4.4 and 5), Nexus 5 (Android 5), Samsung Note 2 (Android 4.4.2). The time after connection to end of service discovery is about 1.6s
+					 * on Samsung Note 2.
+					 *
+					 * NOTE: We are doing this to avoid the hack with calling the hidden gatt.refresh()
+					 * method, at least for bonded devices.
+					 *
+					 * IMPORTANT: BluetoothDevice.getBondState() returns true if the bond information
+					 * is present on Android, not necessarily when the link is established or even
+					 * encrypted. This is a security issue, but in here it does not matter.
+					 */
+					if (gatt.getDevice().getBondState() == BluetoothDevice.BOND_BONDED) {
+						logi("Waiting 1600 ms for a possible Service Changed indication...");
+						waitFor(1600);
+						// After 1.6s the services are already discovered so the following gatt.discoverServices() finishes almost immediately.
+
+						// NOTE: This also works with shorted waiting time. The gatt.discoverServices() must be called after the indication is received which is
+						// about 600ms after establishing connection. Values 600 - 1600ms should be OK.
+					}
+
+					// Attempts to discover services after successful connection.
+					sendLogBroadcast(LOG_LEVEL_VERBOSE, "Discovering services...");
+					sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.discoverServices()");
+					final boolean success = gatt.discoverServices();
+					logi("Attempting to start service discovery... " + (success ? "succeed" : "failed"));
+
+					if (!success) {
+						mError = ERROR_SERVICE_DISCOVERY_NOT_STARTED;
+					} else {
+						// Just return here, lock will be notified when service discovery finishes
+						return;
+					}
+				} else if (newState == BluetoothGatt.STATE_DISCONNECTED) {
+					logi("Disconnected from GATT server");
+					mConnectionState = STATE_DISCONNECTED;
+					if (mDfuServiceImpl != null)
+						mDfuServiceImpl.getGattCallback().onDisconnected();
+				}
+			} else {
+				if (status == 0x08 /* GATT CONN TIMEOUT */ || status == 0x13 /* GATT CONN TERMINATE PEER USER */)
+					logw("Target device disconnected with status: " + status);
+				else
+					loge("Connection state change error: " + status + " newState: " + newState);
+				mError = ERROR_CONNECTION_STATE_MASK | status;
+				if (newState == BluetoothGatt.STATE_DISCONNECTED) {
+					mConnectionState = STATE_DISCONNECTED;
+					if (mDfuServiceImpl != null)
+						mDfuServiceImpl.getGattCallback().onDisconnected();
+				}
+			}
+
+			// Notify waiting thread
+			synchronized (mLock) {
+				mLock.notifyAll();
+			}
+		}
+
+		@Override
+		public void onServicesDiscovered(final BluetoothGatt gatt, final int status) {
+			if (status == BluetoothGatt.GATT_SUCCESS) {
+				logi("Services discovered");
+				mConnectionState = STATE_CONNECTED_AND_READY;
+			} else {
+				loge("Service discovery error: " + status);
+				mError = ERROR_CONNECTION_MASK | status;
+			}
+
+			// Notify waiting thread
+			synchronized (mLock) {
+				mLock.notifyAll();
+			}
+		}
+
+		// Other methods just pass the parameters through
+		@Override
+		public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {
+			if (mDfuServiceImpl != null)
+				mDfuServiceImpl.getGattCallback().onCharacteristicWrite(gatt, characteristic, status);
+		}
+
+		@Override
+		public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {
+			if (mDfuServiceImpl != null)
+				mDfuServiceImpl.getGattCallback().onCharacteristicRead(gatt, characteristic, status);
+		}
+
+		@Override
+		public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {
+			if (mDfuServiceImpl != null)
+				mDfuServiceImpl.getGattCallback().onCharacteristicChanged(gatt, characteristic);
+		}
+
+		@Override
+		public void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {
+			if (mDfuServiceImpl != null)
+				mDfuServiceImpl.getGattCallback().onDescriptorWrite(gatt, descriptor, status);
+		}
+
+		@Override
+		public void onDescriptorRead(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {
+			if (mDfuServiceImpl != null)
+				mDfuServiceImpl.getGattCallback().onDescriptorRead(gatt, descriptor, status);
+		}
+
+		@SuppressLint("NewApi")
+		@Override
+		public void onMtuChanged(final BluetoothGatt gatt, final int mtu, final int status) {
+			if (mDfuServiceImpl != null)
+				mDfuServiceImpl.getGattCallback().onMtuChanged(gatt, mtu, status);
+		}
+
+		@SuppressLint("NewApi")
+		@Override
+		public void onPhyUpdate(final BluetoothGatt gatt, final int txPhy, final int rxPhy, final int status) {
+			if (mDfuServiceImpl != null)
+				mDfuServiceImpl.getGattCallback().onPhyUpdate(gatt, txPhy, rxPhy, status);
+		}
+	};
+
+	public DfuBaseService() {
+		super(TAG);
+	}
+
+	private static IntentFilter makeDfuActionIntentFilter() {
+		final IntentFilter intentFilter = new IntentFilter();
+		intentFilter.addAction(DfuBaseService.BROADCAST_ACTION);
+		return intentFilter;
+	}
+
+	@Override
+	public void onCreate() {
+		super.onCreate();
+
+		DEBUG = isDebug();
+		logi("DFU service created. Version: " + BuildConfig.VERSION_NAME);
+		initialize();
+
+		final LocalBroadcastManager manager = LocalBroadcastManager.getInstance(this);
+		final IntentFilter actionFilter = makeDfuActionIntentFilter();
+		manager.registerReceiver(mDfuActionReceiver, actionFilter);
+		registerReceiver(mDfuActionReceiver, actionFilter); // Additionally we must register this receiver as a non-local to get broadcasts from the notification actions
+
+		final IntentFilter filter = new IntentFilter();
+		// As we no longer perform any action based on this broadcast, we may log all ACL events
+		filter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
+		filter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECT_REQUESTED);
+		filter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
+		registerReceiver(mConnectionStateBroadcastReceiver, filter);
+
+		final IntentFilter bondFilter = new IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
+		registerReceiver(mBondStateBroadcastReceiver, bondFilter);
+
+		final IntentFilter stateFilter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
+		registerReceiver(mBluetoothStateBroadcastReceiver, stateFilter);
+	}
+
+	@Override
+	public void onTaskRemoved(final Intent rootIntent) {
+		super.onTaskRemoved(rootIntent);
+		// This method is called when user removed the app from Recents.
+		// By default, the service will be killed and recreated immediately after that,
+		// but we don't want it. User removed the task, so let's cancel DFU.
+		final NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
+		if (manager != null) {
+			manager.cancel(NOTIFICATION_ID);
+		}
+		stopSelf();
+	}
+
+	@Override
+	public void onDestroy() {
+		super.onDestroy();
+
+		if (mDfuServiceImpl != null)
+			mDfuServiceImpl.abort();
+
+		final LocalBroadcastManager manager = LocalBroadcastManager.getInstance(this);
+		manager.unregisterReceiver(mDfuActionReceiver);
+
+		unregisterReceiver(mDfuActionReceiver);
+		unregisterReceiver(mConnectionStateBroadcastReceiver);
+		unregisterReceiver(mBondStateBroadcastReceiver);
+		unregisterReceiver(mBluetoothStateBroadcastReceiver);
+
+		try {
+			// Ensure that input stream is always closed
+			if (mFirmwareInputStream != null)
+				mFirmwareInputStream.close();
+			if (mInitFileInputStream != null)
+				mInitFileInputStream.close();
+		} catch (final IOException e) {
+			// do nothing
+		} finally {
+			mFirmwareInputStream = null;
+			mInitFileInputStream = null;
+		}
+		logi("DFU service destroyed");
+	}
+
+	@Override
+	protected void onHandleIntent(@Nullable final Intent intent) {
+		if (intent == null)
+			return;
+		// Read input parameters
+		final String deviceAddress = intent.getStringExtra(EXTRA_DEVICE_ADDRESS);
+		final String deviceName = intent.getStringExtra(EXTRA_DEVICE_NAME);
+		final boolean disableNotification = intent.getBooleanExtra(EXTRA_DISABLE_NOTIFICATION, false);
+		final boolean foregroundService = intent.getBooleanExtra(EXTRA_FOREGROUND_SERVICE, true);
+		final String filePath = intent.getStringExtra(EXTRA_FILE_PATH);
+		final Uri fileUri = intent.getParcelableExtra(EXTRA_FILE_URI);
+		final int fileResId = intent.getIntExtra(EXTRA_FILE_RES_ID, 0);
+		final String initFilePath = intent.getStringExtra(EXTRA_INIT_FILE_PATH);
+		final Uri initFileUri = intent.getParcelableExtra(EXTRA_INIT_FILE_URI);
+		final int initFileResId = intent.getIntExtra(EXTRA_INIT_FILE_RES_ID, 0);
+		int fileType = intent.getIntExtra(EXTRA_FILE_TYPE, TYPE_AUTO);
+		if (filePath != null && fileType == TYPE_AUTO)
+			fileType = filePath.toLowerCase(Locale.US).endsWith("zip") ? TYPE_AUTO : TYPE_APPLICATION;
+		String mimeType = intent.getStringExtra(EXTRA_FILE_MIME_TYPE);
+		mimeType = mimeType != null ? mimeType : (fileType == TYPE_AUTO ? MIME_TYPE_ZIP : MIME_TYPE_OCTET_STREAM);
+
+		// Some validation
+		if (deviceAddress == null || (filePath == null && fileUri == null && fileResId == 0)) {
+			loge("Device Address of firmware location are empty. Hint: use DfuServiceInitiator to start DFU");
+			return;
+		}
+		// Check file type and mime-type
+		if ((fileType & ~(TYPE_SOFT_DEVICE | TYPE_BOOTLOADER | TYPE_APPLICATION)) > 0 || !(MIME_TYPE_ZIP.equals(mimeType) || MIME_TYPE_OCTET_STREAM.equals(mimeType))) {
+			logw("File type or file mime-type not supported");
+			sendLogBroadcast(LOG_LEVEL_WARNING, "File type or file mime-type not supported");
+			report(ERROR_FILE_TYPE_UNSUPPORTED);
+			return;
+		}
+		if (MIME_TYPE_OCTET_STREAM.equals(mimeType) && fileType != TYPE_SOFT_DEVICE && fileType != TYPE_BOOTLOADER && fileType != TYPE_APPLICATION) {
+			logw("Unable to determine file type");
+			sendLogBroadcast(LOG_LEVEL_WARNING, "Unable to determine file type");
+			report(ERROR_FILE_TYPE_UNSUPPORTED);
+			return;
+		}
+		if (!disableNotification && getNotificationTarget() == null) {
+			// This would eventually crash later...
+			throw new NullPointerException("getNotificationTarget() must not return null if notifications are enabled");
+		}
+		if (!foregroundService && Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+			logw("Foreground service disabled. Android Oreo or newer may kill a background service few moments after user closes the application.\n" +
+					"Consider enabling foreground service using DfuServiceInitiator#setForeground(boolean)");
+		}
+		UuidHelper.assignCustomUuids(intent);
+
+		if (foregroundService) {
+			logi("Starting DFU service in foreground");
+			startForeground();
+		}
+
+		mDeviceAddress = deviceAddress;
+		mDeviceName = deviceName;
+		mDisableNotification = disableNotification;
+		mConnectionState = STATE_DISCONNECTED;
+		mError = 0;
+
+		// The Soft Device starts where MBR ends (by default from the address 0x1000).
+		// Before there is a MBR section, which should not be transmitted over DFU.
+		// Applications and bootloader starts from bigger address. However, in custom DFU
+		// implementations, user may want to transmit the whole whole data, even from address 0x0000.
+		final SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(this);
+		int mbrSize = DfuServiceInitiator.DEFAULT_MBR_SIZE;
+		if (preferences.contains(DfuSettingsConstants.SETTINGS_MBR_SIZE)) {
+			final String value = preferences.getString(DfuSettingsConstants.SETTINGS_MBR_SIZE, String.valueOf(DfuServiceInitiator.DEFAULT_MBR_SIZE));
+			try {
+				mbrSize = Integer.parseInt(value);
+				if (mbrSize < 0)
+					mbrSize = 0;
+			} catch (final NumberFormatException e) {
+				// ignore, default value will be used
+			}
+		} else {
+			mbrSize = intent.getIntExtra(EXTRA_MBR_SIZE, DfuServiceInitiator.DEFAULT_MBR_SIZE);
+			if (mbrSize < 0)
+				mbrSize = 0;
+		}
+
+		sendLogBroadcast(LOG_LEVEL_VERBOSE, "DFU service started");
+
+		/*
+		 * First the service is trying to read the firmware and init packet files.
+		 */
+		InputStream is = mFirmwareInputStream;
+		InputStream initIs = mInitFileInputStream;
+		try {
+			final boolean firstRun = mFirmwareInputStream == null;
+
+			// Prepare data to send, calculate stream size
+			try {
+				if (firstRun) {
+					// The files are opened only once, when DFU service is first started.
+					// In case the service needs to be restarted (for example a buttonless service
+					// was found or to send Application in the second connection) the input stream
+					// is kept as a global service field. This is to avoid SecurityException
+					// when the URI was granted with one-time read permission.
+					// See: Intent#FLAG_GRANT_READ_URI_PERMISSION (https://developer.android.com/reference/android/content/Intent.html#FLAG_GRANT_READ_URI_PERMISSION).
+					sendLogBroadcast(LOG_LEVEL_VERBOSE, "Opening file...");
+					if (fileUri != null) {
+						is = openInputStream(fileUri, mimeType, mbrSize, fileType);
+					} else if (filePath != null) {
+						is = openInputStream(filePath, mimeType, mbrSize, fileType);
+					} else if (fileResId > 0) {
+						is = openInputStream(fileResId, mimeType, mbrSize, fileType);
+					}
+					assert is != null;
+
+					// The Init file Input Stream is kept global only in case it was provided
+					// as an argument (separate file for HEX/BIN and DAT files).
+					// If a ZIP file was given with DAT file(s) inside it will be taken from the ZIP
+					// ~20 lines below.
+					if (initFileUri != null) {
+						// Try to read the Init Packet file from URI
+						initIs = getContentResolver().openInputStream(initFileUri);
+					} else if (initFilePath != null) {
+						// Try to read the Init Packet file from path
+						initIs = new FileInputStream(initFilePath);
+					} else if (initFileResId > 0) {
+						// Try to read the Init Packet file from given resource
+						initIs = getResources().openRawResource(initFileResId);
+					}
+
+					final int imageSizeInBytes = is.available();
+					if ((imageSizeInBytes % 4) != 0)
+						throw new SizeValidationException("The new firmware is not word-aligned.");
+				}
+
+				// Update the file type bit field basing on the ZIP content
+				if (MIME_TYPE_ZIP.equals(mimeType)) {
+					final ArchiveInputStream zhis = (ArchiveInputStream) is;
+					if (fileType == TYPE_AUTO) {
+						fileType = zhis.getContentType();
+					} else {
+						fileType = zhis.setContentType(fileType);
+					}
+
+					// Validate sizes
+					if ((fileType & TYPE_APPLICATION) > 0 && (zhis.applicationImageSize() % 4) != 0)
+						throw new SizeValidationException("Application firmware is not word-aligned.");
+					if ((fileType & TYPE_BOOTLOADER) > 0 && (zhis.bootloaderImageSize() % 4) != 0)
+						throw new SizeValidationException("Bootloader firmware is not word-aligned.");
+					if ((fileType & TYPE_SOFT_DEVICE) > 0 && (zhis.softDeviceImageSize() % 4) != 0)
+						throw new SizeValidationException("Soft Device firmware is not word-aligned.");
+
+					if (fileType == TYPE_APPLICATION) {
+						if (zhis.getApplicationInit() != null)
+							initIs = new ByteArrayInputStream(zhis.getApplicationInit());
+					} else {
+						if (zhis.getSystemInit() != null)
+							initIs = new ByteArrayInputStream(zhis.getSystemInit());
+					}
+				}
+
+				// Mark the beginning of the streams. In case the service is restarted, it should
+				// re-upload again the whole file.
+				if (firstRun) {
+					// The input streams will be reset in initialize(), keep
+					is.mark(is.available());
+					if (initIs != null)
+						initIs.mark(initIs.available());
+				}
+
+				mFirmwareInputStream = is;
+				mInitFileInputStream = initIs;
+				sendLogBroadcast(LOG_LEVEL_INFO, "Firmware file opened successfully");
+			} catch (final SecurityException e) {
+				loge("A security exception occurred while opening file", e);
+				sendLogBroadcast(LOG_LEVEL_ERROR, "Opening file failed: Permission required");
+				report(ERROR_FILE_NOT_FOUND);
+				return;
+			} catch (final FileNotFoundException e) {
+				loge("An exception occurred while opening file", e);
+				sendLogBroadcast(LOG_LEVEL_ERROR, "Opening file failed: File not found");
+				report(ERROR_FILE_NOT_FOUND);
+				return;
+			} catch (final SizeValidationException e) {
+				loge("Firmware not word-aligned", e);
+				sendLogBroadcast(LOG_LEVEL_ERROR, "Opening file failed: Firmware size must be word-aligned");
+				report(ERROR_FILE_SIZE_INVALID);
+				return;
+			} catch (final IOException e) {
+				loge("An exception occurred while calculating file size", e);
+				sendLogBroadcast(LOG_LEVEL_ERROR, "Opening file failed: " + e.getLocalizedMessage());
+				report(ERROR_FILE_ERROR);
+				return;
+			} catch (final Exception e) {
+				loge("An exception occurred while opening files. Did you set the firmware file?", e);
+				sendLogBroadcast(LOG_LEVEL_ERROR, "Opening file failed: " + e.getLocalizedMessage());
+				report(ERROR_FILE_ERROR);
+				return;
+			}
+
+			if (!firstRun) {
+				// Wait a second... If we were connected before it's good to give some time before we start reconnecting.
+				waitFor(1000);
+				// Looks like a second is not enough. The ACL_DISCONNECTED broadcast sometimes comes later (on Android 7.0)
+				waitFor(1000);
+			}
+
+			mProgressInfo = new DfuProgressInfo(this);
+
+			if (mAborted) {
+				logw("Upload aborted");
+				sendLogBroadcast(LOG_LEVEL_WARNING, "Upload aborted");
+				mProgressInfo.setProgress(PROGRESS_ABORTED);
+				return;
+			}
+
+			/*
+			 * Now let's connect to the device.
+			 * All the methods below are synchronous. The mLock object is used to wait for asynchronous calls.
+			 */
+			sendLogBroadcast(LOG_LEVEL_VERBOSE, "Connecting to DFU target...");
+			mProgressInfo.setProgress(PROGRESS_CONNECTING);
+
+			final long before = SystemClock.elapsedRealtime();
+			final BluetoothGatt gatt = connect(deviceAddress);
+			final long after = SystemClock.elapsedRealtime();
+			// Are we connected?
+			if (gatt == null) {
+				loge("Bluetooth adapter disabled");
+				sendLogBroadcast(LOG_LEVEL_ERROR, "Bluetooth adapter disabled");
+				report(ERROR_BLUETOOTH_DISABLED);
+				return;
+			}
+			if (mError > 0) { // error occurred
+				if ((mError & ERROR_CONNECTION_STATE_MASK) > 0) {
+					final int error = mError & ~ERROR_CONNECTION_STATE_MASK;
+					logi("Connection error after: " + (after - before) + " ms");
+					final boolean timeout = error == 133 && after > before + 25000; // timeout is 30 sec
+					if (timeout) {
+						loge("Device not reachable. Check if the device with address " + deviceAddress + " is in range, is advertising and is connectable");
+						sendLogBroadcast(LOG_LEVEL_ERROR, "Error 133: Connection timeout");
+					} else {
+						loge("An error occurred while connecting to the device:" + error);
+						sendLogBroadcast(LOG_LEVEL_ERROR, String.format(Locale.US, "Connection failed (0x%02X): %s", error, GattError.parseConnectionError(error)));
+					}
+				} else {
+					final int error = mError & ~ERROR_CONNECTION_MASK;
+					loge("An error occurred during discovering services:" + error);
+					sendLogBroadcast(LOG_LEVEL_ERROR, String.format(Locale.US, "Connection failed (0x%02X): %s", error, GattError.parse(error)));
+				}
+				// Connection usually fails due to a 133 error (device unreachable, or.. something else went wrong).
+				// Usually trying the same for the second time works. Let's try 2 times.
+				final int attempt = intent.getIntExtra(EXTRA_RECONNECTION_ATTEMPT, 0);
+				logi("Attempt: " + (attempt + 1));
+				if (attempt < 2) {
+					sendLogBroadcast(LOG_LEVEL_WARNING, "Retrying...");
+
+					if (mConnectionState != STATE_DISCONNECTED) {
+						// Disconnect from the device
+						disconnect(gatt);
+					}
+					// Close the device
+					refreshDeviceCache(gatt, true);
+					close(gatt);
+
+					logi("Restarting the service");
+					final Intent newIntent = new Intent();
+					newIntent.fillIn(intent, Intent.FILL_IN_COMPONENT | Intent.FILL_IN_PACKAGE);
+					newIntent.putExtra(EXTRA_RECONNECTION_ATTEMPT, attempt + 1);
+					startService(newIntent);
+					return;
+				}
+				terminateConnection(gatt, mError);
+				return;
+			}
+			if (mConnectionState == STATE_DISCONNECTED) {
+				sendLogBroadcast(LOG_LEVEL_ERROR, "Disconnected");
+				terminateConnection(gatt, ERROR_DEVICE_DISCONNECTED);
+				return;
+			}
+			if (mAborted) {
+				logw("Upload aborted");
+				sendLogBroadcast(LOG_LEVEL_WARNING, "Upload aborted");
+				terminateConnection(gatt, 0);
+				mProgressInfo.setProgress(PROGRESS_ABORTED);
+				return;
+			}
+			sendLogBroadcast(LOG_LEVEL_INFO, "Services discovered");
+
+			// Reset the reconnection attempt counter
+			intent.putExtra(EXTRA_RECONNECTION_ATTEMPT, 0);
+
+			DfuService dfuService = null;
+			try {
+				/*
+				 * Device services were discovered. Based on them we may now choose the implementation.
+				 */
+				final DfuServiceProvider serviceProvider = new DfuServiceProvider();
+				mDfuServiceImpl = serviceProvider; // This is required if the provider is now able read data from the device
+				mDfuServiceImpl = dfuService = serviceProvider.getServiceImpl(intent, this, gatt);
+				if (dfuService == null) {
+					Log.w(TAG, "DFU Service not found.");
+					sendLogBroadcast(LOG_LEVEL_WARNING, "DFU Service not found");
+					terminateConnection(gatt, ERROR_SERVICE_NOT_FOUND);
+					return;
+				}
+
+				// Begin the DFU depending on the implementation
+				if (dfuService.initialize(intent, gatt, fileType, is, initIs)) {
+					dfuService.performDfu(intent);
+				}
+			} catch (final UploadAbortedException e) {
+				logw("Upload aborted");
+				sendLogBroadcast(LOG_LEVEL_WARNING, "Upload aborted");
+				terminateConnection(gatt, 0);
+				mProgressInfo.setProgress(PROGRESS_ABORTED);
+			} catch (final DeviceDisconnectedException e) {
+				sendLogBroadcast(LOG_LEVEL_ERROR, "Device has disconnected");
+				loge(e.getMessage());
+				close(gatt);
+
+				final int attempt = intent.getIntExtra(EXTRA_DFU_ATTEMPT, 0);
+				final int limit = intent.getIntExtra(EXTRA_MAX_DFU_ATTEMPTS, 0);
+				if (attempt < limit) {
+					logi("Restarting the service (" + (attempt + 1)  + " /" + limit + ")");
+					final Intent newIntent = new Intent();
+					newIntent.fillIn(intent, Intent.FILL_IN_COMPONENT | Intent.FILL_IN_PACKAGE);
+					newIntent.putExtra(EXTRA_DFU_ATTEMPT, attempt + 1);
+					startService(newIntent);
+					return;
+				}
+				report(ERROR_DEVICE_DISCONNECTED);
+			} catch (final DfuException e) {
+				int error = e.getErrorNumber();
+				// Connection state errors and other Bluetooth GATT callbacks share the same error numbers. Therefore we are using bit masks to identify the type.
+				if ((error & ERROR_CONNECTION_STATE_MASK) > 0) {
+					error &= ~ERROR_CONNECTION_STATE_MASK;
+					sendLogBroadcast(LOG_LEVEL_ERROR, String.format(Locale.US, "Error (0x%02X): %s", error, GattError.parseConnectionError(error)));
+				} else {
+					error &= ~ERROR_CONNECTION_MASK;
+					sendLogBroadcast(LOG_LEVEL_ERROR, String.format(Locale.US, "Error (0x%02X): %s", error, GattError.parse(error)));
+				}
+				loge(e.getMessage());
+				terminateConnection(gatt, e.getErrorNumber() /* we return the whole error number, including the error type mask */);
+			} finally {
+				if (dfuService != null) {
+					dfuService.release();
+				}
+			}
+		} finally {
+			if (foregroundService) {
+				// This will stop foreground state and, if the progress notifications were disabled
+				// it will also remove the notification indicating foreground service.
+				stopForeground(disableNotification);
+			}
+		}
+	}
+
+	/**
+	 * Opens the binary input stream that returns the firmware image content.
+	 * A Path to the file is given.
+	 *
+	 * @param filePath the path to the HEX, BIN or ZIP file.
+	 * @param mimeType the file type.
+	 * @param mbrSize  the size of MBR, by default 0x1000.
+	 * @param types    the content files types in ZIP.
+	 * @return The input stream with binary image content.
+	 */
+	private InputStream openInputStream(@NonNull final String filePath, final String mimeType, final int mbrSize, final int types)
+			throws IOException {
+		final InputStream is = new FileInputStream(filePath);
+		if (MIME_TYPE_ZIP.equals(mimeType))
+			return new ArchiveInputStream(is, mbrSize, types);
+		if (filePath.toLowerCase(Locale.US).endsWith("hex"))
+			return new HexInputStream(is, mbrSize);
+		return is;
+	}
+
+	/**
+	 * Opens the binary input stream. A Uri to the stream is given.
+	 *
+	 * @param stream   the Uri to the stream.
+	 * @param mimeType the file type.
+	 * @param mbrSize  the size of MBR, by default 0x1000.
+	 * @param types    the content files types in ZIP.
+	 * @return The input stream with binary image content.
+	 */
+	private InputStream openInputStream(@NonNull final Uri stream, final String mimeType, final int mbrSize, final int types)
+			throws IOException {
+		final InputStream is = stream.toString().startsWith("file:///android_asset/") ?
+				getAssets().open(stream.getPath().substring(15)) :
+				getContentResolver().openInputStream(stream);
+		assert is != null;
+		if (MIME_TYPE_ZIP.equals(mimeType))
+			return new ArchiveInputStream(is, mbrSize, types);
+
+		final String[] projection = {MediaStore.Images.Media.DISPLAY_NAME};
+		try (Cursor cursor = getContentResolver().query(stream, projection, null, null, null)) {
+			if (cursor != null && cursor.moveToNext()) {
+				final String fileName = cursor.getString(0 /* DISPLAY_NAME*/);
+
+				if (fileName.toLowerCase(Locale.US).endsWith("hex"))
+					return new HexInputStream(is, mbrSize);
+			}
+		}
+		return is;
+	}
+
+	/**
+	 * Opens the binary input stream that returns the firmware image content.
+	 * A resource id in the res/raw is given.
+	 *
+	 * @param resId the if of the resource file.
+	 * @param mimeType the file type.
+	 * @param mbrSize  the size of MBR, by default 0x1000.
+	 * @param types    the content files types in ZIP.
+	 * @return The input stream with binary image content.
+	 */
+	private InputStream openInputStream(final int resId, final String mimeType, final int mbrSize, final int types)
+			throws IOException {
+		final InputStream is = getResources().openRawResource(resId);
+		if (MIME_TYPE_ZIP.equals(mimeType))
+			return new ArchiveInputStream(is, mbrSize, types);
+		is.mark(2);
+		int firstByte = is.read();
+		is.reset();
+		if (firstByte == ':')
+			return new HexInputStream(is, mbrSize);
+		return is;
+	}
+
+	/**
+	 * Connects to the BLE device with given address. This method is SYNCHRONOUS, it wait until
+	 * the connection status change from {@link #STATE_CONNECTING} to
+	 * {@link #STATE_CONNECTED_AND_READY} or an error occurs.
+	 * This method returns <code>null</code> if Bluetooth adapter is disabled.
+	 *
+	 * @param address the device address.
+	 * @return The GATT device or <code>null</code> if Bluetooth adapter is disabled.
+	 */
+	protected BluetoothGatt connect(@NonNull final String address) {
+		if (!mBluetoothAdapter.isEnabled())
+			return null;
+
+		mConnectionState = STATE_CONNECTING;
+
+		logi("Connecting to the device...");
+		final BluetoothDevice device = mBluetoothAdapter.getRemoteDevice(address);
+		BluetoothGatt gatt;
+		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+			sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt = device.connectGatt(autoConnect = false, TRANSPORT_LE, preferredPhy = LE_1M | LE_2M)");
+			gatt = device.connectGatt(this, false, mGattCallback,
+					BluetoothDevice.TRANSPORT_LE,
+					BluetoothDevice.PHY_LE_1M_MASK | BluetoothDevice.PHY_LE_2M_MASK);
+		} else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+			sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt = device.connectGatt(autoConnect = false, TRANSPORT_LE)");
+			gatt = device.connectGatt(this, false, mGattCallback,
+					BluetoothDevice.TRANSPORT_LE);
+		} else {
+			sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt = device.connectGatt(autoConnect = false)");
+			gatt = device.connectGatt(this, false, mGattCallback);
+		}
+
+		// We have to wait until the device is connected and services are discovered
+		// Connection error may occur as well.
+		try {
+			synchronized (mLock) {
+				while ((mConnectionState == STATE_CONNECTING || mConnectionState == STATE_CONNECTED) && mError == 0 && !mAborted)
+					mLock.wait();
+			}
+		} catch (final InterruptedException e) {
+			loge("Sleeping interrupted", e);
+		}
+		return gatt;
+	}
+
+	/**
+	 * Disconnects from the device and cleans local variables in case of error.
+	 * This method is SYNCHRONOUS and wait until the disconnecting process will be completed.
+	 *
+	 * @param gatt  the GATT device to be disconnected.
+	 * @param error error number.
+	 */
+	protected void terminateConnection(@NonNull final BluetoothGatt gatt, final int error) {
+		if (mConnectionState != STATE_DISCONNECTED) {
+			// Disconnect from the device
+			disconnect(gatt);
+		}
+
+		// Close the device
+		refreshDeviceCache(gatt, false); // This should be set to true when DFU Version is 0.5 or lower
+		close(gatt);
+		waitFor(600);
+		if (error != 0)
+			report(error);
+	}
+
+	/**
+	 * Disconnects from the device. This is SYNCHRONOUS method and waits until the callback returns
+	 * new state. Terminates immediately if device is already disconnected. Do not call this method
+	 * directly, use {@link #terminateConnection(android.bluetooth.BluetoothGatt, int)} instead.
+	 *
+	 * @param gatt the GATT device that has to be disconnected.
+	 */
+	protected void disconnect(@NonNull final BluetoothGatt gatt) {
+		if (mConnectionState == STATE_DISCONNECTED)
+			return;
+
+		sendLogBroadcast(LOG_LEVEL_VERBOSE, "Disconnecting...");
+		mProgressInfo.setProgress(PROGRESS_DISCONNECTING);
+		mConnectionState = STATE_DISCONNECTING;
+
+		logi("Disconnecting from the device...");
+		sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.disconnect()");
+		gatt.disconnect();
+
+		// We have to wait until device gets disconnected or an error occur
+		waitUntilDisconnected();
+		sendLogBroadcast(LOG_LEVEL_INFO, "Disconnected");
+	}
+
+	/**
+	 * Wait until the connection state will change to {@link #STATE_DISCONNECTED} or until
+	 * an error occurs.
+	 */
+	protected void waitUntilDisconnected() {
+		try {
+			synchronized (mLock) {
+				while (mConnectionState != STATE_DISCONNECTED && mError == 0)
+					mLock.wait();
+			}
+		} catch (final InterruptedException e) {
+			loge("Sleeping interrupted", e);
+		}
+	}
+
+	/**
+	 * Wait for given number of milliseconds.
+	 *
+	 * @param millis waiting period.
+	 */
+	protected void waitFor(final long millis) {
+		synchronized (mLock) {
+			try {
+				sendLogBroadcast(DfuBaseService.LOG_LEVEL_DEBUG, "wait(" + millis + ")");
+				mLock.wait(millis);
+			} catch (final InterruptedException e) {
+				loge("Sleeping interrupted", e);
+			}
+		}
+	}
+
+	/**
+	 * Closes the GATT device and cleans up.
+	 *
+	 * @param gatt the GATT device to be closed.
+	 */
+	protected void close(@NonNull final BluetoothGatt gatt) {
+		logi("Cleaning up...");
+		// Call disconnect() to make sure all resources are released. The device should already be
+		// disconnected, but that's OK.
+		sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.disconnect()");
+		gatt.disconnect();
+		sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.close()");
+		gatt.close();
+		mConnectionState = STATE_CLOSED;
+	}
+
+	/**
+	 * Clears the device cache. After uploading new firmware the DFU target will have other
+	 * services than before.
+	 *
+	 * @param gatt  the GATT device to be refreshed.
+	 * @param force <code>true</code> to force the refresh.
+	 */
+	protected void refreshDeviceCache(@NonNull final BluetoothGatt gatt, final boolean force) {
+		/*
+		 * If the device is bonded this is up to the Service Changed characteristic to notify Android
+		 * that the services has changed. There is no need for this trick in that case.
+		 * If not bonded, the Android should not keep the services cached when the Service Changed
+		 * characteristic is present in the target device database.
+		 * However, due to the Android bug, it is keeping them anyway and the only way to clear
+		 * services is by using this hidden refresh method.
+		 */
+		if (force || gatt.getDevice().getBondState() == BluetoothDevice.BOND_NONE) {
+			sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.refresh() (hidden)");
+			/*
+			 * There is a refresh() method in BluetoothGatt class but for now it's hidden.
+			 * We will call it using reflections.
+			 */
+			try {
+				//noinspection JavaReflectionMemberAccess
+				final Method refresh = gatt.getClass().getMethod("refresh");
+				//noinspection ConstantConditions
+				final boolean success = (Boolean) refresh.invoke(gatt);
+				logi("Refreshing result: " + success);
+			} catch (final Exception e) {
+				loge("An exception occurred while refreshing device", e);
+				sendLogBroadcast(LOG_LEVEL_WARNING, "Refreshing failed");
+			}
+		}
+	}
+
+	/**
+	 * Creates or updates the notification in the Notification Manager. Sends broadcast with
+	 * given progress state to the activity.
+	 */
+	@Override
+	public void updateProgressNotification() {
+		final DfuProgressInfo info = mProgressInfo;
+		final int progress = info.getProgress();
+		if (mLastProgress == progress)
+			return;
+
+		mLastProgress = progress;
+
+		// send progress or error broadcast
+		sendProgressBroadcast(info);
+
+		if (mDisableNotification)
+			return;
+
+		// the notification may not be refreshed too quickly as the ABORT button becomes not clickable
+		// If new state is an end-state, update regardless so it will not stick around in "Disconnecting" state
+		final long now = SystemClock.elapsedRealtime();
+		if (now - mLastNotificationTime < 250 && !(PROGRESS_COMPLETED == progress || PROGRESS_ABORTED == progress))
+			return;
+		mLastNotificationTime = now;
+
+		// create or update notification:
+		final String deviceAddress = mDeviceAddress;
+		final String deviceName = mDeviceName != null ? mDeviceName : getString(R.string.dfu_unknown_name);
+
+		final NotificationCompat.Builder builder = new NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_DFU)
+				.setSmallIcon(android.R.drawable.stat_sys_upload).setOnlyAlertOnce(true);//.setLargeIcon(largeIcon);
+		// Android 5
+		builder.setColor(Color.GRAY);
+
+		switch (progress) {
+			case PROGRESS_CONNECTING:
+				builder.setOngoing(true).setContentTitle(getString(R.string.dfu_status_connecting)).setContentText(getString(R.string.dfu_status_connecting_msg, deviceName))
+						.setProgress(100, 0, true);
+				break;
+			case PROGRESS_STARTING:
+				builder.setOngoing(true).setContentTitle(getString(R.string.dfu_status_starting)).setContentText(getString(R.string.dfu_status_starting_msg))
+						.setProgress(100, 0, true);
+				break;
+			case PROGRESS_ENABLING_DFU_MODE:
+				builder.setOngoing(true).setContentTitle(getString(R.string.dfu_status_switching_to_dfu)).setContentText(getString(R.string.dfu_status_switching_to_dfu_msg))
+						.setProgress(100, 0, true);
+				break;
+			case PROGRESS_VALIDATING:
+				builder.setOngoing(true).setContentTitle(getString(R.string.dfu_status_validating)).setContentText(getString(R.string.dfu_status_validating_msg))
+						.setProgress(100, 0, true);
+				break;
+			case PROGRESS_DISCONNECTING:
+				builder.setOngoing(true).setContentTitle(getString(R.string.dfu_status_disconnecting)).setContentText(getString(R.string.dfu_status_disconnecting_msg, deviceName))
+						.setProgress(100, 0, true);
+				break;
+			case PROGRESS_COMPLETED:
+				builder.setOngoing(false).setContentTitle(getString(R.string.dfu_status_completed)).setSmallIcon(android.R.drawable.stat_sys_upload_done)
+						.setContentText(getString(R.string.dfu_status_completed_msg)).setAutoCancel(true).setColor(0xFF00B81A);
+				break;
+			case PROGRESS_ABORTED:
+				builder.setOngoing(false).setContentTitle(getString(R.string.dfu_status_aborted)).setSmallIcon(android.R.drawable.stat_sys_upload_done)
+						.setContentText(getString(R.string.dfu_status_aborted_msg)).setAutoCancel(true);
+				break;
+			default:
+				// progress is in percents
+				final String title = info.getTotalParts() == 1 ? getString(R.string.dfu_status_uploading) : getString(R.string.dfu_status_uploading_part, info.getCurrentPart(), info.getTotalParts());
+				final String text = getString(R.string.dfu_status_uploading_msg, deviceName);
+				builder.setOngoing(true).setContentTitle(title).setContentText(text)
+						.setProgress(100, progress, false);
+				break;
+		}
+
+		// update the notification
+		final Intent intent = new Intent(this, getNotificationTarget());
+		intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+		intent.putExtra(EXTRA_DEVICE_ADDRESS, deviceAddress);
+		intent.putExtra(EXTRA_DEVICE_NAME, deviceName);
+		intent.putExtra(EXTRA_PROGRESS, progress);
+
+		int flags = PendingIntent.FLAG_UPDATE_CURRENT;
+		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+			flags |= PendingIntent.FLAG_IMMUTABLE;
+		}
+		final PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, flags);
+		builder.setContentIntent(pendingIntent);
+
+		// Any additional configuration?
+		updateProgressNotification(builder, progress);
+
+		final NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
+		if (manager != null) {
+			manager.notify(NOTIFICATION_ID, builder.build());
+		}
+	}
+
+	/**
+	 * This method allows you to update the notification showing the upload progress.
+	 *
+	 * @param builder notification builder.
+	 */
+	protected void updateProgressNotification(@NonNull final NotificationCompat.Builder builder, final int progress) {
+		// Add Abort action to the notification
+		if (progress != PROGRESS_ABORTED && progress != PROGRESS_COMPLETED) {
+			final Intent abortIntent = new Intent(BROADCAST_ACTION);
+			abortIntent.putExtra(EXTRA_ACTION, ACTION_ABORT);
+
+			int flags = PendingIntent.FLAG_UPDATE_CURRENT;
+			if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+				flags |= PendingIntent.FLAG_IMMUTABLE;
+			}
+
+			final PendingIntent pendingAbortIntent = PendingIntent.getBroadcast(this, 1, abortIntent, flags);
+			builder.addAction(R.drawable.ic_action_notify_cancel, getString(R.string.dfu_action_abort), pendingAbortIntent);
+		}
+	}
+
+	/**
+	 * Creates or updates the notification in the Notification Manager. Sends broadcast with given
+	 * error number to the activity.
+	 *
+	 * @param error the error number.
+	 */
+	private void report(final int error) {
+		sendErrorBroadcast(error);
+
+		if (mDisableNotification)
+			return;
+
+		// create or update notification:
+		final String deviceAddress = mDeviceAddress;
+		final String deviceName = mDeviceName != null ? mDeviceName : getString(R.string.dfu_unknown_name);
+
+		final NotificationCompat.Builder builder = new NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_DFU)
+				.setSmallIcon(android.R.drawable.stat_sys_upload)
+				.setOnlyAlertOnce(true)
+				.setColor(Color.RED)
+				.setOngoing(false)
+				.setContentTitle(getString(R.string.dfu_status_error))
+				.setSmallIcon(android.R.drawable.stat_sys_upload_done)
+				.setContentText(getString(R.string.dfu_status_error_msg))
+				.setAutoCancel(true);
+
+		// update the notification
+		final Intent intent = new Intent(this, getNotificationTarget());
+		intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+		intent.putExtra(EXTRA_DEVICE_ADDRESS, deviceAddress);
+		intent.putExtra(EXTRA_DEVICE_NAME, deviceName);
+		intent.putExtra(EXTRA_PROGRESS, error); // this may contains ERROR_CONNECTION_MASK bit!
+
+		int flags = PendingIntent.FLAG_UPDATE_CURRENT;
+		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+			flags |= PendingIntent.FLAG_IMMUTABLE;
+		}
+
+		final PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, flags);
+		builder.setContentIntent(pendingIntent);
+
+		// Any additional configuration?
+		updateErrorNotification(builder);
+
+		final NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
+		if (manager != null) {
+			manager.notify(NOTIFICATION_ID, builder.build());
+		}
+	}
+
+	/**
+	 * This method allows you to update the notification showing an error.
+	 * @param builder error notification builder
+	 */
+	@SuppressWarnings("unused")
+	protected void updateErrorNotification(@NonNull final NotificationCompat.Builder builder) {
+		// Empty default implementation
+	}
+
+	private void startForeground() {
+		final NotificationCompat.Builder builder = new NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_DFU)
+				.setSmallIcon(android.R.drawable.stat_sys_upload)
+				.setContentTitle(getString(R.string.dfu_status_foreground_title)).setContentText(getString(R.string.dfu_status_foreground_content))
+				.setColor(Color.GRAY)
+				.setPriority(NotificationCompat.PRIORITY_LOW)
+				.setOngoing(true);
+
+		// Update the notification
+		final Class<? extends Activity> clazz = getNotificationTarget();
+		if (clazz != null) {
+			final Intent targetIntent = new Intent(this, clazz);
+			targetIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+			targetIntent.putExtra(EXTRA_DEVICE_ADDRESS, mDeviceAddress);
+			targetIntent.putExtra(EXTRA_DEVICE_NAME, mDeviceName);
+			int flags = PendingIntent.FLAG_UPDATE_CURRENT;
+			if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+				flags |= PendingIntent.FLAG_IMMUTABLE;
+			}
+			final PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, targetIntent, flags);
+			builder.setContentIntent(pendingIntent);
+		} else {
+			logw("getNotificationTarget() should not return null if the service is to be started as a foreground service");
+			// otherwise the notification will not be clickable.
+		}
+
+		// Any additional configuration?
+		updateForegroundNotification(builder);
+
+		startForeground(NOTIFICATION_ID, builder.build());
+	}
+
+	/**
+	 * This method allows you to update the notification that will be shown when the service goes to
+	 * the foreground state.
+	 *
+	 * @param builder foreground notification builder
+	 */
+	@SuppressWarnings("unused")
+	protected void updateForegroundNotification(@NonNull final NotificationCompat.Builder builder) {
+		// Empty default implementation
+	}
+
+	/**
+	 * This method must return the activity class that will be used to create the pending intent
+	 * used as a content intent in the notification showing the upload progress
+	 * or service foreground state. The activity will be launched when user click the notification.
+	 * DfuService will add {@link android.content.Intent#FLAG_ACTIVITY_NEW_TASK} flag and the following extras:
+	 * <ul>
+	 * <li>{@link #EXTRA_DEVICE_ADDRESS} - target device address</li>
+	 * <li>{@link #EXTRA_DEVICE_NAME} - target device name</li>
+	 * <li>{@link #EXTRA_PROGRESS} - the connection state (values &lt; 0)*, current progress (0-100)
+	 * 		or error number if {@link #ERROR_MASK} bit set.</li>
+	 * </ul>
+	 * <p>
+	 * The {@link #EXTRA_PROGRESS} is not set when a notification indicating a foreground service
+	 * was clicked and notifications were disabled using {@link DfuServiceInitiator#setDisableNotification(boolean)}.
+	 * <p>
+	 * If your application disabled DFU notifications by calling
+	 * {@link DfuServiceInitiator#setDisableNotification(boolean)} with parameter <code>true</code> this method
+	 * will still be called if the service was started as foreground service. To disable foreground service
+	 * call {@link DfuServiceInitiator#setForeground(boolean)} with parameter <code>false</code>.
+	 * _______________________________<br>
+	 * * - connection state constants:
+	 * <ul>
+	 * <li>{@link #PROGRESS_CONNECTING}</li>
+	 * <li>{@link #PROGRESS_DISCONNECTING}</li>
+	 * <li>{@link #PROGRESS_COMPLETED}</li>
+	 * <li>{@link #PROGRESS_ABORTED}</li>
+	 * <li>{@link #PROGRESS_STARTING}</li>
+	 * <li>{@link #PROGRESS_ENABLING_DFU_MODE}</li>
+	 * <li>{@link #PROGRESS_VALIDATING}</li>
+	 * </ul>
+	 *
+	 * @return The target activity class.
+	 */
+	@Nullable
+	protected abstract Class<? extends Activity> getNotificationTarget();
+
+	/**
+	 * This method should return the device selector, which is to be used to find the bootloader.
+	 * The default selector will look for a device with the same, or incremented device address.
+	 *
+	 * @return The device selector instance.
+	 * @since 2.1
+	 */
+	@NonNull
+	protected DfuDeviceSelector getDeviceSelector() {
+		return new DfuDefaultDeviceSelector();
+	}
+
+	/**
+	 * Override this method to enable detailed debug LogCat logs with DFU events.
+	 * <p>Recommended use:</p>
+	 * <pre>
+	 * &#64;Override
+	 * protected boolean isDebug() {
+	 *     return BuildConfig.DEBUG;
+	 * }
+	 * </pre>
+	 * @return True to enable LogCat output, false (default) if not.
+	 */
+	protected boolean isDebug() {
+		// Override this method and return true if you need more logs in LogCat
+		// Note: BuildConfig.DEBUG always returns false in library projects, so please use
+		// your app package BuildConfig
+		return false;
+	}
+
+	private void sendProgressBroadcast(final DfuProgressInfo info) {
+		final Intent broadcast = new Intent(BROADCAST_PROGRESS);
+		broadcast.putExtra(EXTRA_DATA, info.getProgress());
+		broadcast.putExtra(EXTRA_DEVICE_ADDRESS, mDeviceAddress);
+		broadcast.putExtra(EXTRA_PART_CURRENT, info.getCurrentPart());
+		broadcast.putExtra(EXTRA_PARTS_TOTAL, info.getTotalParts());
+		broadcast.putExtra(EXTRA_SPEED_B_PER_MS, info.getSpeed());
+		broadcast.putExtra(EXTRA_AVG_SPEED_B_PER_MS, info.getAverageSpeed());
+		LocalBroadcastManager.getInstance(this).sendBroadcast(broadcast);
+	}
+
+	private void sendErrorBroadcast(final int error) {
+		final Intent broadcast = new Intent(BROADCAST_ERROR);
+		if ((error & ERROR_CONNECTION_MASK) > 0) {
+			broadcast.putExtra(EXTRA_DATA, error & ~ERROR_CONNECTION_MASK);
+			broadcast.putExtra(EXTRA_ERROR_TYPE, ERROR_TYPE_COMMUNICATION);
+		} else if ((error & ERROR_CONNECTION_STATE_MASK) > 0) {
+			broadcast.putExtra(EXTRA_DATA, error & ~ERROR_CONNECTION_STATE_MASK);
+			broadcast.putExtra(EXTRA_ERROR_TYPE, ERROR_TYPE_COMMUNICATION_STATE);
+		} else if ((error & ERROR_REMOTE_MASK) > 0) {
+			broadcast.putExtra(EXTRA_DATA, error & ~ERROR_REMOTE_MASK);
+			broadcast.putExtra(EXTRA_ERROR_TYPE, ERROR_TYPE_DFU_REMOTE);
+		} else {
+			broadcast.putExtra(EXTRA_DATA, error);
+			broadcast.putExtra(EXTRA_ERROR_TYPE, ERROR_TYPE_OTHER);
+		}
+		broadcast.putExtra(EXTRA_DEVICE_ADDRESS, mDeviceAddress);
+		LocalBroadcastManager.getInstance(this).sendBroadcast(broadcast);
+	}
+
+	/* package */ void sendLogBroadcast(final int level, final String message) {
+		final String fullMessage = "[DFU] " + message;
+		final Intent broadcast = new Intent(BROADCAST_LOG);
+		broadcast.putExtra(EXTRA_LOG_MESSAGE, fullMessage);
+		broadcast.putExtra(EXTRA_LOG_LEVEL, level);
+		broadcast.putExtra(EXTRA_DEVICE_ADDRESS, mDeviceAddress);
+		LocalBroadcastManager.getInstance(this).sendBroadcast(broadcast);
+	}
+
+	/**
+	 * Initializes bluetooth adapter.
+	 *
+	 * @return <code>True</code> if initialization was successful.
+	 */
+	@SuppressWarnings("UnusedReturnValue")
+	private boolean initialize() {
+		// For API level 18 and above, get a reference to BluetoothAdapter through
+		// BluetoothManager.
+		final BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
+		if (bluetoothManager == null) {
+			loge("Unable to initialize BluetoothManager.");
+			return false;
+		}
+
+		mBluetoothAdapter = bluetoothManager.getAdapter();
+		if (mBluetoothAdapter == null) {
+			loge("Unable to obtain a BluetoothAdapter.");
+			return false;
+		}
+
+		return true;
+	}
+
+	private void loge(final String message) {
+		Log.e(TAG, message);
+	}
+
+	private void loge(final String message, final Throwable e) {
+		Log.e(TAG, message, e);
+	}
+
+	private void logw(final String message) {
+		if (DfuBaseService.DEBUG)
+			Log.w(TAG, message);
+	}
+
+	private void logi(final String message) {
+		if (DfuBaseService.DEBUG)
+			Log.i(TAG, message);
+	}
+}
diff --git a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/DfuSettingsConstants.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuCallback.java
similarity index 60%
rename from dfuLibrary/src/main/java/no/nordicsemi/android/dfu/DfuSettingsConstants.java
rename to dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuCallback.java
index c4f925b..c5dbb5d 100644
--- a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/DfuSettingsConstants.java
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuCallback.java
@@ -1,5 +1,5 @@
-/*************************************************************************************************************************************************
- * Copyright (c) 2015, Nordic Semiconductor
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
@@ -18,18 +18,29 @@
  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- ************************************************************************************************************************************************/
+ */
 
 package no.nordicsemi.android.dfu;
 
-public interface DfuSettingsConstants {
-	public static final String SETTINGS_PACKET_RECEIPT_NOTIFICATION_ENABLED = "settings_packet_receipt_notification_enabled";
-	public static final String SETTINGS_NUMBER_OF_PACKETS = "settings_number_of_packets";
-	public static final String SETTINGS_MBR_SIZE = "settings_mbr_size";
-	public static final int SETTINGS_DEFAULT_MBR_SIZE = 0x1000;
-	public static final int SETTINGS_NUMBER_OF_PACKETS_DEFAULT = 10;
-	public static final int TIME_TO_WAIT_IN_MILLISECONDS = 30*1000;
-	public static final int APP_CODE_BASE_START =0x18000;
-    public static final int APP_CODE_BASE_END =0x3BBFF;
-    //public static final int APP_CODE_BASE_END =0x2FFFF;
+import android.bluetooth.BluetoothGattCallback;
+
+/* package */ interface DfuCallback extends DfuController {
+
+	class DfuGattCallback extends BluetoothGattCallback {
+		public void onDisconnected() {
+			// empty initial implementation
+		}
+	}
+
+	/**
+	 * Returns the final BluetoothGattCallback instance, depending on the implementation.
+	 */
+	DfuGattCallback getGattCallback();
+
+	/**
+	 * Callback invoked when bond state changes to
+	 * {@link android.bluetooth.BluetoothDevice#BOND_BONDED BOND_BONDED} or
+     * {@link android.bluetooth.BluetoothDevice#BOND_NONE BOND_NONE}.
+	 */
+	void onBondStateChanged(final int state);
 }
diff --git a/app/src/main/java/cc/calliope/mini/profile/BlinkyManagerCallbacks.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuController.java
similarity index 73%
rename from app/src/main/java/cc/calliope/mini/profile/BlinkyManagerCallbacks.java
rename to dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuController.java
index e9736ca..8c34cf1 100644
--- a/app/src/main/java/cc/calliope/mini/profile/BlinkyManagerCallbacks.java
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuController.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, Nordic Semiconductor
+ * Copyright (c) 2018, Nordic Semiconductor
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
@@ -20,23 +20,24 @@
  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package cc.calliope.mini.profile;
+package no.nordicsemi.android.dfu;
 
-import no.nordicsemi.android.ble.BleManagerCallbacks;
+public interface DfuController {
 
-public interface BlinkyManagerCallbacks extends BleManagerCallbacks {
+	/**
+	 * Pauses the DFU operation. Call {@link #resume()} to resume, or {@link #abort()} to cancel.
+	 * This method does nothing if DFU operation was already paused.
+	 */
+	void pause();
 
 	/**
-	 * Called when a button was pressed or released on device
-	 *
-	 * @param state true if the button was pressed, false if released
+	 * Resumes a previously paused DFU operation.
+	 * @see #pause()
 	 */
-	void onDataReceived(final boolean state);
+	void resume();
 
 	/**
-	 * Called when the data has been sent to the connected device.
-	 *
-	 * @param state true when LED was enabled, false when disabled
+	 * Aborts the DFU operation after it has started.
 	 */
-	void onDataSent(final boolean state);
+	void abort();
 }
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuDefaultDeviceSelector.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuDefaultDeviceSelector.java
new file mode 100644
index 0000000..bc74f39
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuDefaultDeviceSelector.java
@@ -0,0 +1,25 @@
+package no.nordicsemi.android.dfu;
+
+import android.bluetooth.BluetoothDevice;
+
+import androidx.annotation.NonNull;
+
+/**
+ * The default device selector looks for a device advertising an incremented address
+ * (the original address + 1). By returning a custom selector from
+ * {@link DfuBaseService#getDeviceSelector()} the app can override this behavior.
+ *
+ * @since 2.1
+ */
+class DfuDefaultDeviceSelector implements DfuDeviceSelector {
+    @Override
+    public boolean matches(
+            @NonNull final BluetoothDevice device,
+            final int rssi,
+            @NonNull final byte[] scanRecord,
+            @NonNull final String originalAddress,
+            @NonNull final String incrementedAddress) {
+        return originalAddress.equals(device.getAddress()) || incrementedAddress.equals(device.getAddress());
+    }
+}
+
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuDeviceSelector.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuDeviceSelector.java
new file mode 100644
index 0000000..683c97b
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuDeviceSelector.java
@@ -0,0 +1,42 @@
+package no.nordicsemi.android.dfu;
+
+import android.bluetooth.BluetoothDevice;
+
+import androidx.annotation.NonNull;
+
+/**
+ * The device selector can be used to filter scan results when scanning for the device
+ * advertising in bootloader mode.
+ * <p>
+ * By default, the scanner will look for a device advertising an incremented address
+ * (the original address + 1). By returning a custom selector from
+ * {@link DfuBaseService#getDeviceSelector()} the app can override this behavior.
+ *
+ * @see DfuDefaultDeviceSelector
+ * @since 2.1
+ */
+public interface DfuDeviceSelector {
+
+	/**
+	 * This method should return true if the given device matches the expected device in bootloader
+	 * mode.
+	 * <p>
+	 * The advertising data are given as a byte array for backwards compatibility with pre-Lollipop
+	 * devices.
+	 *
+	 * @param device the scanned Bluetooth device.
+	 * @param rssi the received signal strength indicator (RSSI) value for the device.
+	 * @param scanRecord the raw scan record of the device.
+	 * @param originalAddress the MAC address of the device when first connected.
+	 * @param incrementedAddress the incremented address of the device.
+	 * @return true if the device matches the expected device in bootloader mode.
+	 * @since 2.1
+	 */
+	boolean matches(
+			@NonNull final BluetoothDevice device,
+			final int rssi,
+			final @NonNull byte[] scanRecord,
+			final @NonNull String originalAddress,
+			final @NonNull String incrementedAddress
+	);
+}
\ No newline at end of file
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuLogListener.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuLogListener.java
new file mode 100644
index 0000000..40e8bcb
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuLogListener.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.dfu;
+
+/**
+ * Listener for log events. This listener should be used instead of creating the
+ * BroadcastReceiver on your own.
+ *
+ * @see DfuServiceListenerHelper
+ */
+public interface DfuLogListener {
+	/**
+	 * Method called when a log event was sent from the DFU service.
+	 *
+	 * @param deviceAddress the target device address
+	 * @param level the log level, one of:
+	 * 		<ul>
+	 * 		    <li>{@link DfuBaseService#LOG_LEVEL_DEBUG}</li>
+	 * 		    <li>{@link DfuBaseService#LOG_LEVEL_VERBOSE}</li>
+	 * 		    <li>{@link DfuBaseService#LOG_LEVEL_INFO}</li>
+	 * 		    <li>{@link DfuBaseService#LOG_LEVEL_APPLICATION}</li>
+	 * 		    <li>{@link DfuBaseService#LOG_LEVEL_WARNING}</li>
+	 * 		    <li>{@link DfuBaseService#LOG_LEVEL_ERROR}</li>
+	 * 		</ul>
+	 * @param message the log message
+	 */
+	void onLogEvent(final String deviceAddress, final int level, final String message);
+}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuProgressInfo.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuProgressInfo.java
new file mode 100644
index 0000000..43002bf
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuProgressInfo.java
@@ -0,0 +1,145 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.dfu;
+
+import android.os.SystemClock;
+import androidx.annotation.NonNull;
+
+/* package */ class DfuProgressInfo {
+	interface ProgressListener {
+		void updateProgressNotification();
+	}
+
+	private final ProgressListener mListener;
+	private int progress;
+	private int bytesSent;
+	private int initialBytesSent;
+	private int lastBytesSent;
+	private int bytesReceived;
+	private int imageSizeInBytes;
+	private int maxObjectSizeInBytes;
+	private int currentPart;
+	private int totalParts;
+	private long timeStart, lastProgressTime;
+
+	DfuProgressInfo(final @NonNull ProgressListener listener) {
+		mListener = listener;
+	}
+
+	void init(final int imageSizeInBytes, final int currentPart, final int totalParts) {
+		this.imageSizeInBytes = imageSizeInBytes;
+		this.maxObjectSizeInBytes = Integer.MAX_VALUE; // by default the whole firmware will be sent as a single object
+		this.currentPart = currentPart;
+		this.totalParts = totalParts;
+	}
+
+	@SuppressWarnings({"UnusedReturnValue", "SameParameterValue"})
+	DfuProgressInfo setTotalPart(final int totalParts) {
+		this.totalParts = totalParts;
+		return this;
+	}
+
+	void setProgress(final int progress) {
+		this.progress = progress;
+		mListener.updateProgressNotification();
+	}
+
+	void setBytesSent(final int bytesSent) {
+		if (timeStart == 0) {
+			timeStart = SystemClock.elapsedRealtime();
+			initialBytesSent = bytesSent;
+		}
+		this.bytesSent = bytesSent;
+		this.progress = (int) (100.0f * bytesSent / imageSizeInBytes);
+		mListener.updateProgressNotification();
+	}
+
+	void addBytesSent(final int increment) {
+		setBytesSent(bytesSent + increment);
+	}
+
+	void setBytesReceived(final int bytesReceived) {
+		this.bytesReceived = bytesReceived;
+	}
+
+	void setMaxObjectSizeInBytes(final int bytes) {
+		this.maxObjectSizeInBytes = bytes;
+	}
+
+	boolean isComplete() {
+		return bytesSent == imageSizeInBytes;
+	}
+
+	boolean isObjectComplete() {
+		return (bytesSent % maxObjectSizeInBytes) == 0;
+	}
+
+	int getAvailableObjectSizeIsBytes() {
+		final int remainingBytes = imageSizeInBytes - bytesSent;
+		final int remainingChunk = maxObjectSizeInBytes - (bytesSent % maxObjectSizeInBytes);
+		return Math.min(remainingBytes, remainingChunk);
+	}
+
+	int getProgress() {
+		return progress;
+	}
+
+	int getBytesSent() {
+		return bytesSent;
+	}
+
+	@SuppressWarnings("unused")
+	int getBytesReceived() {
+		return bytesReceived;
+	}
+
+	@SuppressWarnings("unused")
+	int getImageSizeInBytes() {
+		return imageSizeInBytes;
+	}
+
+	float getSpeed() {
+		final long now = SystemClock.elapsedRealtime();
+		final float speed = now - timeStart != 0 ? (float) (bytesSent - lastBytesSent) / (float) (now - lastProgressTime) : 0.0f;
+		lastProgressTime = now;
+		lastBytesSent = bytesSent;
+		return speed;
+	}
+
+	float getAverageSpeed() {
+		final long now = SystemClock.elapsedRealtime();
+		return now - timeStart != 0 ? (float) (bytesSent - initialBytesSent) / (float) (now - timeStart) : 0.0f;
+	}
+
+	int getCurrentPart() {
+		return currentPart;
+	}
+
+	int getTotalParts() {
+		return totalParts;
+	}
+
+	boolean isLastPart() {
+		return currentPart == totalParts;
+	}
+}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuProgressListener.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuProgressListener.java
new file mode 100644
index 0000000..72e48f9
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuProgressListener.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.dfu;
+
+import androidx.annotation.NonNull;
+
+/**
+ * Listener for status, progress and error events. This listener should be used instead of
+ * creating the BroadcastReceiver on your own.
+ *
+ * @see DfuServiceListenerHelper
+ */
+public interface DfuProgressListener {
+
+	/**
+	 * Method called when the DFU service started connecting with the DFU target.
+	 *
+	 * @param deviceAddress the target device address.
+	 */
+	void onDeviceConnecting(@NonNull final String deviceAddress);
+
+	/**
+	 * Method called when the service has successfully connected, discovered services and found
+	 * DFU service on the DFU target.
+	 *
+	 * @param deviceAddress the target device address.
+	 */
+	void onDeviceConnected(@NonNull final String deviceAddress);
+
+	/**
+	 * Method called when the DFU process is starting. This includes reading the DFU Version
+	 * characteristic, sending DFU_START command as well as the Init packet, if set.
+	 *
+	 * @param deviceAddress the target device address.
+	 */
+	void onDfuProcessStarting(@NonNull final String deviceAddress);
+
+	/**
+	 * Method called when the DFU process was started and bytes about to be sent.
+	 *
+	 * @param deviceAddress the target device address
+	 */
+	void onDfuProcessStarted(@NonNull final String deviceAddress);
+
+	/**
+	 * Method called when the service discovered that the DFU target is in the application mode
+     * and must be switched to DFU mode. The switch command will be sent and the DFU process
+     * should start again. There will be no {@link #onDeviceDisconnected(String)} event following
+     * this call.
+	 *
+	 * @param deviceAddress the target device address.
+	 */
+	void onEnablingDfuMode(@NonNull final String deviceAddress);
+
+	/**
+	 * Method called during uploading the firmware. It will not be called twice with the same
+     * value of percent, however, in case of small firmware files, some values may be omitted.
+	 *
+	 * @param deviceAddress the target device address.
+	 * @param percent       the current status of upload (0-99).
+	 * @param speed         the current speed in bytes per millisecond.
+	 * @param avgSpeed      the average speed in bytes per millisecond
+	 * @param currentPart   the number pf part being sent. In case the ZIP file contains a Soft Device
+     *                      and/or a Bootloader together with the application the SD+BL are sent as part 1,
+	 *                      then the service starts again and send the application as part 2.
+	 * @param partsTotal    total number of parts.
+	 */
+	void onProgressChanged(@NonNull final String deviceAddress, final int percent,
+                           final float speed, final float avgSpeed,
+                           final int currentPart, final int partsTotal);
+
+	/**
+	 * Method called when the new firmware is being validated on the target device.
+	 *
+	 * @param deviceAddress the target device address.
+	 */
+	void onFirmwareValidating(@NonNull final String deviceAddress);
+
+	/**
+	 * Method called when the service started to disconnect from the target device.
+	 *
+	 * @param deviceAddress the target device address.
+	 */
+	void onDeviceDisconnecting(final String deviceAddress);
+
+	/**
+	 * Method called when the service disconnected from the device. The device has been reset.
+	 *
+	 * @param deviceAddress the target device address.
+	 */
+	void onDeviceDisconnected(@NonNull final String deviceAddress);
+
+	/**
+	 * Method called when the DFU process succeeded.
+	 *
+	 * @param deviceAddress the target device address.
+	 */
+	void onDfuCompleted(@NonNull final String deviceAddress);
+
+	/**
+	 * Method called when the DFU process has been aborted.
+	 *
+	 * @param deviceAddress the target device address.
+	 */
+	void onDfuAborted(@NonNull final String deviceAddress);
+
+	/**
+	 * Method called when an error occur.
+	 *
+	 * @param deviceAddress the target device address.
+	 * @param error         error number.
+	 * @param errorType     the error type, one of
+     *                      {@link DfuBaseService#ERROR_TYPE_COMMUNICATION_STATE},
+     *                      {@link DfuBaseService#ERROR_TYPE_COMMUNICATION},
+	 *                      {@link DfuBaseService#ERROR_TYPE_DFU_REMOTE},
+     *                      {@link DfuBaseService#ERROR_TYPE_OTHER}.
+	 * @param message       the error message.
+	 */
+	void onError(@NonNull final String deviceAddress,
+                 final int error, final int errorType, final String message);
+}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuProgressListenerAdapter.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuProgressListenerAdapter.java
new file mode 100644
index 0000000..2cb76da
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuProgressListenerAdapter.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.dfu;
+
+import androidx.annotation.NonNull;
+
+public class DfuProgressListenerAdapter implements DfuProgressListener {
+
+	@Override
+	public void onDeviceConnecting(@NonNull final String deviceAddress) {
+		// empty default implementation
+	}
+
+	@Override
+	public void onDeviceConnected(@NonNull final String deviceAddress) {
+		// empty default implementation
+	}
+
+	@Override
+	public void onDfuProcessStarting(@NonNull final String deviceAddress) {
+		// empty default implementation
+	}
+
+	@Override
+	public void onDfuProcessStarted(@NonNull final String deviceAddress) {
+		// empty default implementation
+	}
+
+	@Override
+	public void onEnablingDfuMode(@NonNull final String deviceAddress) {
+		// empty default implementation
+	}
+
+	@Override
+	public void onProgressChanged(@NonNull final String deviceAddress, final int percent,
+								  final float speed, final float avgSpeed,
+								  final int currentPart, final int partsTotal) {
+		// empty default implementation
+	}
+
+	@Override
+	public void onFirmwareValidating(@NonNull final String deviceAddress) {
+		// empty default implementation
+	}
+
+	@Override
+	public void onDeviceDisconnecting(final String deviceAddress) {
+		// empty default implementation
+	}
+
+	@Override
+	public void onDeviceDisconnected(@NonNull final String deviceAddress) {
+		// empty default implementation
+	}
+
+	@Override
+	public void onDfuCompleted(@NonNull final String deviceAddress) {
+		// empty default implementation
+	}
+
+	@Override
+	public void onDfuAborted(@NonNull final String deviceAddress) {
+		// empty default implementation
+	}
+
+	@Override
+	public void onError(@NonNull final String deviceAddress,
+						final int error, final int errorType, final String message) {
+		// empty default implementation
+	}
+}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuScope.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuScope.java
new file mode 100644
index 0000000..b8c116b
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuScope.java
@@ -0,0 +1,15 @@
+package no.nordicsemi.android.dfu;
+
+import androidx.annotation.IntDef;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+@SuppressWarnings("WeakerAccess")
+@Retention(RetentionPolicy.SOURCE)
+@IntDef(value = {
+            DfuServiceInitiator.SCOPE_SYSTEM_COMPONENTS,
+            DfuServiceInitiator.SCOPE_APPLICATION
+        },
+        flag = true)
+public @interface DfuScope {}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuService.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuService.java
new file mode 100644
index 0000000..17735f4
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuService.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.dfu;
+
+import android.bluetooth.BluetoothGatt;
+import android.content.Intent;
+
+import java.io.InputStream;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import no.nordicsemi.android.dfu.internal.exception.DeviceDisconnectedException;
+import no.nordicsemi.android.dfu.internal.exception.DfuException;
+import no.nordicsemi.android.dfu.internal.exception.UploadAbortedException;
+
+/* package */ interface DfuService extends DfuCallback {
+
+	/**
+	 * This method must return true if the device is compatible with this DFU implementation,
+	 * false otherwise.
+     *
+     * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of
+     *                                     the transmission.
+     * @throws DfuException                Thrown if DFU error occur.
+     * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
+	 */
+	boolean isClientCompatible(@NonNull final Intent intent, @NonNull final BluetoothGatt gatt)
+			throws DfuException, DeviceDisconnectedException, UploadAbortedException;
+
+	/**
+	 * Initializes the DFU implementation and does some initial setting up.
+	 *
+	 * @return True if initialization was successful and the DFU process may begin,
+	 * false to finish teh DFU service.
+	 * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of
+	 *                                     the transmission.
+	 * @throws DfuException                Thrown if DFU error occur.
+	 * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
+	 */
+	boolean initialize(@NonNull final Intent intent, @NonNull final BluetoothGatt gatt,
+					   @FileType final int fileType,
+					   @NonNull final InputStream firmwareStream,
+                       @Nullable final InputStream initPacketStream)
+			throws DfuException, DeviceDisconnectedException, UploadAbortedException;
+
+	/**
+	 * Performs the DFU process.
+	 *
+	 * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of
+	 *                                     the transmission.
+	 * @throws DfuException                Thrown if DFU error occur.
+	 * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
+	 */
+	void performDfu(@NonNull final Intent intent)
+			throws DfuException, DeviceDisconnectedException, UploadAbortedException;
+
+	/**
+	 * Releases the service.
+	 */
+	void release();
+}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuServiceController.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuServiceController.java
new file mode 100644
index 0000000..fa9c7b2
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuServiceController.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.dfu;
+
+import android.content.Context;
+import android.content.Intent;
+
+import androidx.annotation.NonNull;
+import androidx.localbroadcastmanager.content.LocalBroadcastManager;
+
+/**
+ * A controller class allows you to pause, resume or abort the DFU operation in a easy way.
+ * <p>
+ * Keep in mind that there may be only one DFU operation at a time, and other instances of
+ * a DfuServiceController (for example obtained with a previous DFU) will work for all DFU processes,
+ * but the {@link #isPaused()} and {@link #isAborted()} methods may report incorrect values.
+ * <p>
+ * Added in DFU Library version 1.0.2.
+ */
+@SuppressWarnings({"WeakerAccess", "unused"})
+public class DfuServiceController implements DfuController {
+	@SuppressWarnings("deprecation")
+	private final LocalBroadcastManager mBroadcastManager;
+	private boolean mPaused;
+	private boolean mAborted;
+
+	/* package */ DfuServiceController(@NonNull final Context context) {
+		//noinspection deprecation
+		mBroadcastManager = LocalBroadcastManager.getInstance(context);
+	}
+
+	@Override
+	public void pause() {
+		if (!mAborted && !mPaused) {
+			mPaused = true;
+			final Intent pauseAction = new Intent(DfuBaseService.BROADCAST_ACTION);
+			pauseAction.putExtra(DfuBaseService.EXTRA_ACTION, DfuBaseService.ACTION_PAUSE);
+			mBroadcastManager.sendBroadcast(pauseAction);
+		}
+	}
+
+	@Override
+	public void resume() {
+		if (!mAborted && mPaused) {
+			mPaused = false;
+			final Intent pauseAction = new Intent(DfuBaseService.BROADCAST_ACTION);
+			pauseAction.putExtra(DfuBaseService.EXTRA_ACTION, DfuBaseService.ACTION_RESUME);
+			mBroadcastManager.sendBroadcast(pauseAction);
+		}
+	}
+
+	@Override
+	public void abort() {
+		if (!mAborted) {
+			mAborted = true;
+			mPaused = false;
+			final Intent pauseAction = new Intent(DfuBaseService.BROADCAST_ACTION);
+			pauseAction.putExtra(DfuBaseService.EXTRA_ACTION, DfuBaseService.ACTION_ABORT);
+			mBroadcastManager.sendBroadcast(pauseAction);
+		}
+	}
+
+	/**
+	 * Returns true if the DFU operation was paused.
+	 * It can be now resumed using {@link #resume()}.
+	 */
+	public boolean isPaused() {
+		return mPaused;
+	}
+
+	/**
+	 * Returns true if DFU was aborted.
+	 */
+	public boolean isAborted() {
+		return mAborted;
+	}
+}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuServiceInitiator.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuServiceInitiator.java
new file mode 100644
index 0000000..994a8ad
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuServiceInitiator.java
@@ -0,0 +1,929 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.dfu;
+
+import android.app.Notification;
+import android.app.NotificationChannel;
+import android.app.NotificationManager;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothGatt;
+import android.content.Context;
+import android.content.Intent;
+import android.net.Uri;
+import android.os.Build;
+import android.os.ParcelUuid;
+import android.os.Parcelable;
+
+import java.security.InvalidParameterException;
+import java.util.UUID;
+
+import androidx.annotation.IntRange;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RawRes;
+import androidx.annotation.RequiresApi;
+
+/**
+ * Starting the DfuService service requires a knowledge of some EXTRA_* constants used to pass
+ * parameters to the service. The DfuServiceInitiator class may be used to make this process easier.
+ * It provides simple API that covers all low lever operations.
+ */
+@SuppressWarnings({"WeakerAccess", "unused", "deprecation"})
+public final class DfuServiceInitiator {
+	public static final int DEFAULT_PRN_VALUE = 12;
+	public static final int DEFAULT_MBR_SIZE = 0x1000;
+	public static final long DEFAULT_SCAN_TIMEOUT = 5000; // ms
+
+	/** Constant used to narrow the scope of the update to system components (SD+BL) only. */
+	public static final int SCOPE_SYSTEM_COMPONENTS = 1;
+	/** Constant used to narrow the scope of the update to application only. */
+	public static final int SCOPE_APPLICATION = 2;
+
+	private final String deviceAddress;
+	private String deviceName;
+
+	private boolean disableNotification = false;
+	private boolean startAsForegroundService = true;
+
+	private Uri fileUri;
+	private String filePath;
+	private int fileResId;
+
+	private Uri initFileUri;
+	private String initFilePath;
+	private int initFileResId;
+
+	private String mimeType;
+	private int fileType = -1;
+
+	private boolean keepBond;
+	private boolean restoreBond;
+	private boolean forceDfu = false;
+	private boolean forceScanningForNewAddressInLegacyDfu = false;
+	private boolean enableUnsafeExperimentalButtonlessDfu = false;
+	private boolean disableResume = false;
+	private int numberOfRetries = 0; // 0 to be backwards compatible
+	private int mbrSize = DEFAULT_MBR_SIZE;
+	private long dataObjectDelay = 0; // initially disabled
+	private long rebootTime = 0; // ms
+	private long scanTimeout = DEFAULT_SCAN_TIMEOUT; // ms
+
+	private Boolean packetReceiptNotificationsEnabled;
+	private int numberOfPackets = 12;
+
+	private int mtu = 517;
+	private int currentMtu = 23;
+
+	private Parcelable[] legacyDfuUuids;
+	private Parcelable[] secureDfuUuids;
+	private Parcelable[] experimentalButtonlessDfuUuids;
+	private Parcelable[] buttonlessDfuWithoutBondSharingUuids;
+	private Parcelable[] buttonlessDfuWithBondSharingUuids;
+
+	/**
+	 * Creates the builder. Use setZip(...), or setBinOrHex(...) methods to specify the file you
+	 * want to upload. In the latter case an init file may also be set using the setInitFile(...)
+	 * method. Init files are required by DFU Bootloader version 0.5 or newer (SDK 7.0.0+).
+	 *
+	 * @param deviceAddress the target device device address
+	 */
+	public DfuServiceInitiator(@NonNull final String deviceAddress) {
+		this.deviceAddress = deviceAddress;
+	}
+
+	/**
+	 * Sets the device name. The device name is not required. It's written in the notification
+	 * during the DFU process. If not set the
+	 * {@link no.nordicsemi.android.dfu.R.string#dfu_unknown_name R.string.dfu_unknown_name}
+	 * value will be used.
+	 *
+	 * @param name the device name (optional)
+	 * @return the builder
+	 */
+	public DfuServiceInitiator setDeviceName(@Nullable final String name) {
+		this.deviceName = name;
+		return this;
+	}
+
+	/**
+	 * Sets whether the progress notification in the status bar should be disabled.
+	 * Defaults to false.
+	 *
+	 * @param disableNotification whether to disable the notification
+	 * @return the builder
+	 */
+	public DfuServiceInitiator setDisableNotification(final boolean disableNotification) {
+		this.disableNotification = disableNotification;
+		return this;
+	}
+
+	/**
+	 * Sets whether the DFU service should be started as a foreground service. By default it's
+	 * <i>true</i>. According to
+	 * <a href="https://developer.android.com/about/versions/oreo/background.html">
+	 * https://developer.android.com/about/versions/oreo/background.html</a>
+	 * the background service may be killed by the system on Android Oreo after user quits the
+	 * application so it is recommended to keep it as a foreground service (default) at least on
+	 * Android Oreo+.
+	 *
+	 * @param foreground whether the service should be started in foreground state.
+	 * @return the builder
+	 */
+	public DfuServiceInitiator setForeground(final boolean foreground) {
+		this.startAsForegroundService = foreground;
+		return this;
+	}
+
+	/**
+	 * Sets whether the bond information should be preserver after flashing new application.
+	 * This feature requires Legacy DFU Bootloader version 0.6 or newer (SDK 8.0.0+).
+	 * Please see the {@link DfuBaseService#EXTRA_KEEP_BOND} for more information regarding
+	 * requirements.
+	 * <p>
+	 * This flag is ignored when Secure DFU Buttonless Service is used. It will keep or remove the
+	 * bond depending on the Buttonless service type.
+	 * <p>
+	 * <b>Important:</b> The flag does not ensure that the DFU is performed on an encrypted link.
+	 * If the bond information is present only on Android side, but not on the peripheral side,
+	 * Android (version 4.3-10) will connect without encryption. On those versions it is not possible
+	 * to ensure the link is truly encrypted, as {@link BluetoothDevice#getBondState()} returns
+	 * {@link BluetoothDevice#BOND_BONDED} also if bonding isn't used.
+	 *
+	 * @param keepBond whether the bond information should be preserved in the new application.
+	 * @return the builder
+	 */
+	public DfuServiceInitiator setKeepBond(final boolean keepBond) {
+		this.keepBond = keepBond;
+		return this;
+	}
+
+	/**
+	 * Sets whether a new bond should be created after the DFU is complete. The old bond
+	 * information will be removed before.
+	 * Please see the {@link DfuBaseService#EXTRA_RESTORE_BOND} for more information regarding
+	 * requirements.
+	 * <p>
+	 * This flag is ignored when Secure DFU Buttonless Service is used. It will keep or will not
+	 * restore the bond depending on the Buttonless service type.
+	 *
+	 * @param restoreBond whether the bond should be created after the DFU is complete.
+	 * @return the builder
+	 */
+	public DfuServiceInitiator setRestoreBond(final boolean restoreBond) {
+		this.restoreBond = restoreBond;
+		return this;
+	}
+
+	/**
+	 * This method sets the duration of a delay, that the service will wait before sending each
+	 * data object in Secure DFU. The delay will be done after a data object is created, and before
+	 * any data byte is sent. The default value is 0, which disables this feature.
+	 * <p>
+	 * It has been found, that a delay of at least 300ms reduces the risk of packet lose (the
+	 * bootloader needs some time to prepare flash memory) on DFU bootloader from SDK 15 and 16.
+	 * The delay does not have to be longer than 400 ms, as according to performed tests, such delay
+	 * is sufficient.
+	 * <p>
+	 * The longer the delay, the more time DFU will take to complete (delay will be repeated for
+	 * each data object (4096 bytes)). However, with too small delay a packet lose may occur,
+	 * causing the service to enable PRN and set them to 1 making DFU process very, very slow
+	 * (but reliable).
+	 *
+	 * @param delay the initial delay that the service will wait before sending each data object.
+	 * @since 1.10
+	 * @return the builder
+	 */
+	public DfuServiceInitiator setPrepareDataObjectDelay(final long delay) {
+		this.dataObjectDelay = delay;
+		return this;
+	}
+
+	/**
+	 * Enables or disables the Packet Receipt Notification (PRN) procedure.
+	 * <p>
+	 * By default the PRNs are disabled on devices with Android Marshmallow or newer and enabled on
+	 * older ones.
+	 *
+	 * @param enabled true to enabled PRNs, false to disable
+	 * @return the builder
+	 * @see DfuSettingsConstants#SETTINGS_PACKET_RECEIPT_NOTIFICATION_ENABLED
+	 */
+	public DfuServiceInitiator setPacketsReceiptNotificationsEnabled(final boolean enabled) {
+		this.packetReceiptNotificationsEnabled = enabled;
+		return this;
+	}
+
+	/**
+	 * If Packet Receipt Notification procedure is enabled, this method sets number of packets to
+	 * be sent before receiving a PRN. A PRN is used to synchronize the transmitter and receiver.
+	 * <p>
+	 * If the value given is equal to 0, the {@link #DEFAULT_PRN_VALUE} will be used instead.
+	 * <p>
+	 * To disable PRNs use {@link #setPacketsReceiptNotificationsEnabled(boolean)}.
+	 *
+	 * @param number number of packets to be sent before receiving a PRN. Defaulted when set to 0.
+	 * @return the builder
+	 * @see #setPacketsReceiptNotificationsEnabled(boolean)
+	 * @see DfuSettingsConstants#SETTINGS_NUMBER_OF_PACKETS
+	 */
+	public DfuServiceInitiator setPacketsReceiptNotificationsValue(@IntRange(from = 0) final int number) {
+		this.numberOfPackets = number > 0 ? number : DEFAULT_PRN_VALUE;
+		return this;
+	}
+
+	/**
+	 * Setting force DFU to true will prevent from jumping to the DFU Bootloader
+	 * mode in case there is no DFU Version characteristic (Legacy DFU only!).
+	 * Use it if the DFU operation can be handled by your device running in the application mode.
+	 * <p>
+	 * If the DFU Version characteristic exists, the
+	 * information whether to begin DFU operation, or jump to bootloader, is taken from that
+	 * characteristic's value. The value returned equal to 0x0100 (read as: minor=1, major=0, or
+	 * version 0.1) means that the device is in the application mode and buttonless jump to
+	 * DFU Bootloader is supported.
+	 * <p>
+	 * However, if there is no DFU Version characteristic, a device
+	 * may support only Application update (version from SDK 4.3.0), may support Soft Device,
+	 * Bootloader and Application update but without buttonless jump to bootloader (SDK 6.0.0)
+	 * or with buttonless jump (SDK 6.1.0).
+	 * <p>
+	 * In the last case, the DFU Library determines whether the device is in application mode or in
+	 * DFU Bootloader mode by counting number of services: if no DFU Service found - device is in
+	 * app mode and does not support buttonless jump, if the DFU Service is the only service found
+	 * (except General Access and General Attribute services) - it assumes it is in DFU Bootloader
+	 * mode and may start DFU immediately, if there is at least one service except DFU Service -
+	 * the device is in application mode and supports buttonless jump. In the last case, if you
+	 * want to perform DFU operation without jumping - call the this method with parameter equal
+	 * to true.
+	 * <p>
+	 * This method is ignored in Secure DFU.
+	 *
+	 * @param force true to ensure the DFU will start if there is no DFU Version characteristic
+	 *              (Legacy DFU only)
+	 * @return the builder
+	 * @see DfuSettingsConstants#SETTINGS_ASSUME_DFU_NODE
+	 */
+	public DfuServiceInitiator setForceDfu(final boolean force) {
+		this.forceDfu = force;
+		return this;
+	}
+
+	/**
+	 * Sets the time required by the device to reboot. The library will wait for this time before
+	 * scanning for the device in bootloader mode.
+	 *
+	 * @param rebootTime the reboot time in milliseconds, default 0.
+	 * @return the builder
+	 * @since 2.1
+	 */
+	public DfuServiceInitiator setRebootTime(final long rebootTime) {
+		this.rebootTime = rebootTime;
+		return this;
+	}
+
+	/**
+	 * Sets the scan duration (in milliseconds) when scanning for DFU Bootloader.
+	 *
+	 * @param scanTimeout the scan duration in milliseconds, default {@value #DEFAULT_SCAN_TIMEOUT} ms.
+	 * @return the builder
+	 * @since 2.1
+	 */
+	public DfuServiceInitiator setScanTimeout(final long scanTimeout) {
+		this.scanTimeout = scanTimeout;
+		return this;
+	}
+
+	/**
+	 * When this is set to true, the Legacy Buttonless Service will scan for the device advertising
+	 * with an incremented MAC address, instead of trying to reconnect to the same device.
+	 * <p>
+	 * Setting this to true requires modifying the buttonless service on the device not to share the
+	 * peer data with the bootloader, or modifying the bootloader to always advertise with MAC+1.
+	 * Setting it to true with a default implementation of the buttonless service should work, but
+	 * is pointless.
+	 * <p>
+	 * This is a feature equivalent to
+	 * <a href="https://github.com/NordicSemiconductor/IOS-Pods-DFU-Library/pull/374">PR #374</a>
+	 * in DFU library for iOS.
+	 * @param force set to true when your bootloader is advertising with an incremented MAC address.
+	 *              By default, in Legacy DFU, the bootloader uses the same MAC address and is
+	 *              advertising directly. This does not seen to work on some phones (Samsung) with
+	 *              recent Android versions.
+	 * @return the builder
+	 */
+	public DfuServiceInitiator setForceScanningForNewAddressInLegacyDfu(final boolean force) {
+		this.forceScanningForNewAddressInLegacyDfu = force;
+		return this;
+	}
+
+	/**
+	 * This options allows to disable the resume feature in Secure DFU. When the extra value is set
+	 * to true, the DFU will send Init Packet and Data again, despite the firmware might have been
+	 * send partially before. By default, without setting this extra, or by setting it to false,
+	 * the DFU will resume the previously cancelled upload if CRC values match.
+	 * <p>
+	 * It is ignored when Legacy DFU is used.
+	 * <p>
+	 * This feature seems to help in some cases:
+	 * <a href="https://github.com/NordicSemiconductor/Android-DFU-Library/issues/71">#71</a>.
+	 *
+	 * @return the builder
+	 */
+	public DfuServiceInitiator disableResume() {
+		this.disableResume = true;
+		return this;
+	}
+
+	/**
+	 * Sets the number of retries that the DFU service will use to complete DFU. The default
+	 * value is 0, for backwards compatibility reason.
+	 * <p>
+	 * If the given value is greater than 0, the service will restart itself at most {@code max}
+	 * times in case of an undesired disconnection during DFU operation. This attempt counter
+	 * is independent from another counter, for reconnection attempts, which is equal to 3.
+	 * The latter one will be used when connection will fail with an error (possible packet
+	 * collision or any other reason). After successful connection, the reconnection counter is
+	 * reset, while the retry counter is cleared after a DFU finishes with success.
+	 * <p>
+	 * The service will not try to retry DFU in case of any other error, for instance an error
+	 * sent from the target device.
+	 *
+	 * @param max Maximum number of retires to complete DFU. Usually around 2.
+	 * @return the builder
+	 */
+	public DfuServiceInitiator setNumberOfRetries(@IntRange(from = 0) final int max) {
+		this.numberOfRetries = max;
+		return this;
+	}
+
+	/**
+	 * Sets the Maximum Transfer Unit (MTU) value that the Secure DFU service will try to request
+	 * before performing DFU. By default, value 517 will be used, which is the highest supported
+	 * by Android. However, as the highest supported MTU by the Secure DFU from SDK 15
+	 * (first which supports higher MTU) is 247, the sides will agree on using MTU = 247 instead
+	 * if the phone supports it (Lollipop or newer device).
+	 * <p>
+	 * The higher the MTU, the faster the data may be sent.
+	 * <p>
+	 * If you encounter problems with high MTU, you may lower the required value using this method.
+	 * See: https://github.com/NordicSemiconductor/Android-DFU-Library/issues/111
+	 * <p>
+	 * To disable requesting MTU, use value 0, or {@link #disableMtuRequest()}.
+	 * <p>
+	 * Note: Higher (that is greater then 23) MTUs are supported on Lollipop or newer Android
+	 * devices, and on DFU bootloader from SDK 15 or newer (Secure DFU only).
+	 *
+	 * @param mtu the MTU that wil be requested, 0 to disable MTU request.
+	 * @return the builder
+	 */
+	public DfuServiceInitiator setMtu(@IntRange(from = 23, to = 517) final int mtu) {
+		this.mtu = mtu;
+		return this;
+	}
+
+	/**
+	 * Sets the current MTU value. This method should be used only if the device is already
+	 * connected and MTU has been requested before DFU service is started.
+	 * The SoftDevice allows to change MTU only once, while the following requests fail with
+	 * Invalid PDU error. In case this error is received, the MTU will be set to the value
+	 * specified using this method. There is no verification of this value. If it's set to
+	 * too high value, some of the packets will not be sent and DFU will not succeed.
+	 * <p>
+	 * By default value 23 is used for compatibility reasons.
+	 * <p>
+	 * Higher MTU values were supported since SDK 15.0.
+	 *
+	 * @param mtu the MTU value received in
+	 *            {@link android.bluetooth.BluetoothGattCallback#onMtuChanged(BluetoothGatt, int, int)} or
+	 *            {@link android.bluetooth.BluetoothGattServerCallback#onMtuChanged(BluetoothDevice, int)}.
+	 * @return the builder
+	 */
+	public DfuServiceInitiator setCurrentMtu(@IntRange(from = 23, to = 517) final int mtu) {
+		this.currentMtu = mtu;
+		return this;
+	}
+
+	/**
+	 * Disables MTU request.
+	 *
+	 * @return the builder
+	 * @see #setMtu(int)
+	 */
+	public DfuServiceInitiator disableMtuRequest() {
+		this.mtu = 0;
+		return this;
+	}
+
+	/**
+	 * This method allows to narrow the update to selected parts from the ZIP, for example
+	 * to allow only application update from a ZIP file that has SD+BL+App. System components scope
+	 * include the Softdevice and/or the Bootloader (they can't be separated as they are packed in
+	 * a single bin file and the library does not know whether it contains only the softdevice,
+	 * the bootloader or both) Application scope includes the application only.
+	 *
+	 * @param scope the update scope, one of {@link #SCOPE_SYSTEM_COMPONENTS} or
+	 *              {@link #SCOPE_APPLICATION}.
+	 * @return the builder
+	 */
+	public DfuServiceInitiator setScope(@DfuScope final int scope) {
+		if (!DfuBaseService.MIME_TYPE_ZIP.equals(mimeType))
+			throw new UnsupportedOperationException("Scope can be set only for a ZIP file");
+		if (scope == SCOPE_APPLICATION)
+			fileType = DfuBaseService.TYPE_APPLICATION;
+		else if (scope == SCOPE_SYSTEM_COMPONENTS)
+			fileType = DfuBaseService.TYPE_SOFT_DEVICE | DfuBaseService.TYPE_BOOTLOADER;
+		else if (scope == (SCOPE_APPLICATION | SCOPE_SYSTEM_COMPONENTS))
+			fileType = DfuBaseService.TYPE_AUTO;
+		else throw new UnsupportedOperationException("Unknown scope");
+		return this;
+	}
+
+	/**
+	 * This method sets the size of an MBR (Master Boot Record). It should be used only
+	 * when updating a file from a HEX file. If you use BIN or ZIP, value set here will
+	 * be ignored.
+	 * <p>
+	 * The MBR size is important for the HEX parser, which has to cut it from the Soft Device's
+	 * HEX before sending it to the DFU target. The MBR can't be updated using DFU, and the
+	 * bootloader expects only the Soft Device bytes. Usually, the Soft Device HEX provided
+	 * by Nordic contains an MBR at addresses 0x0000 to 0x1000.
+	 * 0x1000 is the default size of MBR which will be used.
+	 * <p>
+	 * If you have a HEX file which address start from 0 and want to send the whole BIN content
+	 * from it, you have to set the MBR size to 0, otherwise first 4096 bytes will be cut off.
+	 * <p>
+	 * The value set here will not be used if the {@link DfuSettingsConstants#SETTINGS_MBR_SIZE}
+	 * is set in Shared Preferences.
+	 *
+	 * @param mbrSize the MBR size in bytes. Defaults to 4096 (0x1000) bytes.
+	 * @return the builder
+	 * @see DfuSettingsConstants#SETTINGS_MBR_SIZE
+	 */
+	public DfuServiceInitiator setMbrSize(@IntRange(from = 0) final int mbrSize) {
+		this.mbrSize = mbrSize;
+		return this;
+	}
+
+	/**
+	 * Set this flag to true to enable experimental buttonless feature in Secure DFU. When the
+	 * experimental Buttonless DFU Service is found on a device, the service will use it to
+	 * switch the device to the bootloader mode, connect to it in that mode and proceed with DFU.
+	 * <p>
+	 * <b>Please, read the information below before setting it to true.</b>
+	 * <p>
+	 * In the SDK 12.x the Buttonless DFU feature for Secure DFU was experimental.
+	 * It is NOT recommended to use it: it was not properly tested, had implementation bugs (e.g.
+	 * <a href="https://devzone.nordicsemi.com/question/100609/sdk-12-bootloader-erased-after-programming/">link</a>)
+	 * and does not required encryption and therefore may lead to DOS attack (anyone can use it to
+	 * switch the device to bootloader mode). However, as there is no other way to trigger
+	 * bootloader mode on devices without a button, this DFU Library supports this service, but the
+	 * feature must be explicitly enabled here. Be aware, that setting this flag to false will no
+	 * protect your devices from this kind of attacks, as an attacker may use another app for that
+	 * purpose. To be sure your device is secure remove this experimental service from your device.
+	 * <p>
+	 * <b>Spec:</b><br>
+	 * Buttonless DFU Service UUID: 8E400001-F315-4F60-9FB8-838830DAEA50<br>
+	 * Buttonless DFU characteristic UUID: 8E400001-F315-4F60-9FB8-838830DAEA50 (the same)<br>
+	 * Enter Bootloader Op Code: 0x01<br>
+	 * Correct return value: 0x20-01-01 , where:<br>
+	 * 0x20 - Response Op Code<br>
+	 * 0x01 - Request Code<br>
+	 * 0x01 - Success<br>
+	 * The device should disconnect and restart in DFU mode after sending the notification.
+	 * <p>
+	 * The Buttonless service has changed in SDK 13 and later. Indications are used instead of
+	 * notifications. Also, Buttonless service for bonded devices has been added.
+	 * It is recommended to use any of the new services instead.
+	 *
+	 * @return the builder
+	 */
+	public DfuServiceInitiator setUnsafeExperimentalButtonlessServiceInSecureDfuEnabled(final boolean enable) {
+		this.enableUnsafeExperimentalButtonlessDfu = enable;
+		return this;
+	}
+
+	/**
+	 * Sets custom UUIDs for Legacy DFU and Legacy Buttonless DFU. Use this method if your DFU
+	 * implementation uses different UUID for at least one of the given UUIDs.
+	 * Parameter set to <code>null</code> will reset the UUID to the default value.
+	 *
+	 * @param dfuServiceUuid      custom Legacy DFU service UUID or null, if default is to be used
+	 * @param dfuControlPointUuid custom Legacy DFU Control Point characteristic UUID or null,
+	 *                            if default is to be used
+	 * @param dfuPacketUuid       custom Legacy DFU Packet characteristic UUID or null, if default is
+	 *                            to be used
+	 * @param dfuVersionUuid      custom Legacy DFU Version characteristic UUID or null,
+	 *                            if default is to be used (SDK 7.0 - 11.0 only, set null for earlier SDKs)
+	 * @return the builder
+	 */
+	public DfuServiceInitiator setCustomUuidsForLegacyDfu(@Nullable final UUID dfuServiceUuid,
+														  @Nullable final UUID dfuControlPointUuid,
+														  @Nullable final UUID dfuPacketUuid,
+														  @Nullable final UUID dfuVersionUuid) {
+		final ParcelUuid[] uuids = new ParcelUuid[4];
+		uuids[0] = dfuServiceUuid      != null ? new ParcelUuid(dfuServiceUuid)      : null;
+		uuids[1] = dfuControlPointUuid != null ? new ParcelUuid(dfuControlPointUuid) : null;
+		uuids[2] = dfuPacketUuid       != null ? new ParcelUuid(dfuPacketUuid)       : null;
+		uuids[3] = dfuVersionUuid      != null ? new ParcelUuid(dfuVersionUuid)      : null;
+		legacyDfuUuids = uuids;
+		return this;
+	}
+
+	/**
+	 * Sets custom UUIDs for Secure DFU. Use this method if your DFU implementation uses different
+	 * UUID for at least one of the given UUIDs. Parameter set to <code>null</code> will reset
+	 * the UUID to the default value.
+	 *
+	 * @param dfuServiceUuid      custom Secure DFU service UUID or null, if default is to be used
+	 * @param dfuControlPointUuid custom Secure DFU Control Point characteristic UUID or null,
+	 *                            if default is to be used
+	 * @param dfuPacketUuid       custom Secure DFU Packet characteristic UUID or null, if default
+	 *                            is to be used
+	 * @return the builder
+	 */
+	public DfuServiceInitiator setCustomUuidsForSecureDfu(@Nullable final UUID dfuServiceUuid,
+														  @Nullable final UUID dfuControlPointUuid,
+														  @Nullable final UUID dfuPacketUuid) {
+		final ParcelUuid[] uuids = new ParcelUuid[3];
+		uuids[0] = dfuServiceUuid      != null ? new ParcelUuid(dfuServiceUuid)      : null;
+		uuids[1] = dfuControlPointUuid != null ? new ParcelUuid(dfuControlPointUuid) : null;
+		uuids[2] = dfuPacketUuid       != null ? new ParcelUuid(dfuPacketUuid)       : null;
+		secureDfuUuids = uuids;
+		return this;
+	}
+
+	/**
+	 * Sets custom UUIDs for the experimental Buttonless DFU Service from SDK 12.x. Use this method
+	 * if your DFU implementation uses different UUID for at least one of the given UUIDs.
+	 * Parameter set to <code>null</code> will reset the UUID to the default value.
+	 * <p>
+	 * Remember to call {@link #setUnsafeExperimentalButtonlessServiceInSecureDfuEnabled(boolean)}
+	 * with parameter <code>true</code> if you intent to use this service.
+	 *
+	 * @param buttonlessDfuServiceUuid      custom Buttonless DFU service UUID or null, if default
+	 *                                      is to be used
+	 * @param buttonlessDfuControlPointUuid custom Buttonless DFU characteristic UUID or null,
+	 *                                      if default is to be used
+	 * @return the builder
+	 */
+	public DfuServiceInitiator setCustomUuidsForExperimentalButtonlessDfu(@Nullable final UUID buttonlessDfuServiceUuid,
+																		  @Nullable final UUID buttonlessDfuControlPointUuid) {
+		final ParcelUuid[] uuids = new ParcelUuid[2];
+		uuids[0] = buttonlessDfuServiceUuid      != null ? new ParcelUuid(buttonlessDfuServiceUuid)      : null;
+		uuids[1] = buttonlessDfuControlPointUuid != null ? new ParcelUuid(buttonlessDfuControlPointUuid) : null;
+		experimentalButtonlessDfuUuids = uuids;
+		return this;
+	}
+
+	/**
+	 * Sets custom UUIDs for the Buttonless DFU Service from SDK 14 (or later).
+	 * Use this method if your DFU implementation uses different UUID for at least one of the given
+	 * UUIDs. Parameter set to <code>null</code> will reset the UUID to the default value.
+	 *
+	 * @param buttonlessDfuServiceUuid      custom Buttonless DFU service UUID or null, if default
+	 *                                      is to be used
+	 * @param buttonlessDfuControlPointUuid custom Buttonless DFU characteristic UUID or null,
+	 *                                      if default is to be used
+	 * @return the builder
+	 */
+	public DfuServiceInitiator setCustomUuidsForButtonlessDfuWithBondSharing(@Nullable final UUID buttonlessDfuServiceUuid,
+																			 @Nullable final UUID buttonlessDfuControlPointUuid) {
+		final ParcelUuid[] uuids = new ParcelUuid[2];
+		uuids[0] = buttonlessDfuServiceUuid      != null ? new ParcelUuid(buttonlessDfuServiceUuid)      : null;
+		uuids[1] = buttonlessDfuControlPointUuid != null ? new ParcelUuid(buttonlessDfuControlPointUuid) : null;
+		buttonlessDfuWithBondSharingUuids = uuids;
+		return this;
+	}
+
+	/**
+	 * Sets custom UUIDs for the Buttonless DFU Service from SDK 13. Use this method if your DFU
+	 * implementation uses different UUID for at least one of the given UUIDs.
+	 * Parameter set to <code>null</code> will reset the UUID to the default value.
+	 *
+	 * @param buttonlessDfuServiceUuid      custom Buttonless DFU service UUID or null, if default
+	 *                                      is to be used
+	 * @param buttonlessDfuControlPointUuid custom Buttonless DFU characteristic UUID or null,
+	 *                                      if default is to be used
+	 * @return the builder
+	 */
+	public DfuServiceInitiator setCustomUuidsForButtonlessDfuWithoutBondSharing(@Nullable final UUID buttonlessDfuServiceUuid,
+																				@Nullable final UUID buttonlessDfuControlPointUuid) {
+		final ParcelUuid[] uuids = new ParcelUuid[2];
+		uuids[0] = buttonlessDfuServiceUuid      != null ? new ParcelUuid(buttonlessDfuServiceUuid)      : null;
+		uuids[1] = buttonlessDfuControlPointUuid != null ? new ParcelUuid(buttonlessDfuControlPointUuid) : null;
+		buttonlessDfuWithoutBondSharingUuids = uuids;
+		return this;
+	}
+
+	/**
+	 * Sets the URI to the Distribution packet (ZIP) or to a ZIP file matching the deprecated naming
+	 * convention.
+	 *
+	 * @param uri the URI of the file
+	 * @return the builder
+	 * @see #setZip(String)
+	 * @see #setZip(int)
+	 */
+	public DfuServiceInitiator setZip(@NonNull final Uri uri) {
+		return init(uri, null, 0, DfuBaseService.TYPE_AUTO, DfuBaseService.MIME_TYPE_ZIP);
+	}
+
+	/**
+	 * Sets the path to the Distribution packet (ZIP) or the a ZIP file matching the deprecated naming
+	 * convention.
+	 *
+	 * @param path path to the file
+	 * @return the builder
+	 * @see #setZip(Uri)
+	 * @see #setZip(int)
+	 */
+	public DfuServiceInitiator setZip(@NonNull final String path) {
+		return init(null, path, 0, DfuBaseService.TYPE_AUTO, DfuBaseService.MIME_TYPE_ZIP);
+	}
+
+	/**
+	 * Sets the resource ID of the Distribution packet (ZIP) or the a ZIP file matching the
+	 * deprecated naming convention. The file should be in the /res/raw folder.
+	 *
+	 * @param rawResId file's resource ID
+	 * @return the builder
+	 * @see #setZip(Uri)
+	 * @see #setZip(String)
+	 */
+	public DfuServiceInitiator setZip(@RawRes final int rawResId) {
+		return init(null, null, rawResId, DfuBaseService.TYPE_AUTO, DfuBaseService.MIME_TYPE_ZIP);
+	}
+
+	/**
+	 * Sets the URI or path of the ZIP file.
+	 * At least one of the parameters must not be null.
+	 * If the URI and path are not null the URI will be used.
+	 *
+	 * @param uri  the URI of the file
+	 * @param path the path of the file
+	 * @return the builder
+	 */
+	public DfuServiceInitiator setZip(@Nullable final Uri uri, @Nullable final String path) {
+		return init(uri, path, 0, DfuBaseService.TYPE_AUTO, DfuBaseService.MIME_TYPE_ZIP);
+	}
+
+	/**
+	 * Sets the URI of the BIN or HEX file containing the new firmware.
+	 * For DFU Bootloader version 0.5 or newer the init file must be specified using one of
+	 * {@link #setInitFile(Uri)} methods.
+	 *
+	 * @param fileType the file type, a bit field created from:
+	 *                 <ul>
+	 *                 <li>{@link DfuBaseService#TYPE_APPLICATION} - the Application will be sent</li>
+	 *                 <li>{@link DfuBaseService#TYPE_SOFT_DEVICE} - he Soft Device will be sent</li>
+	 *                 <li>{@link DfuBaseService#TYPE_BOOTLOADER} - the Bootloader will be sent</li>
+	 *                 </ul>
+	 * @param uri      the URI of the file
+	 * @return the builder
+	 */
+	@Deprecated
+	public DfuServiceInitiator setBinOrHex(@FileType final int fileType, @NonNull final Uri uri) {
+		if (fileType == DfuBaseService.TYPE_AUTO)
+			throw new UnsupportedOperationException("You must specify the file type");
+		return init(uri, null, 0, fileType, DfuBaseService.MIME_TYPE_OCTET_STREAM);
+	}
+
+	/**
+	 * Sets the URI of the BIN or HEX file containing the new firmware.
+	 * For DFU Bootloader version 0.5 or newer the init file must be specified using one of
+	 * {@link #setInitFile(String)} methods.
+	 *
+	 * @param fileType see {@link #setBinOrHex(int, Uri)} for details
+	 * @param path     path to the file
+	 * @return the builder
+	 */
+	@Deprecated
+	public DfuServiceInitiator setBinOrHex(@FileType final int fileType, @NonNull final String path) {
+		if (fileType == DfuBaseService.TYPE_AUTO)
+			throw new UnsupportedOperationException("You must specify the file type");
+		return init(null, path, 0, fileType, DfuBaseService.MIME_TYPE_OCTET_STREAM);
+	}
+
+	/**
+	 * Sets the URI or path to the BIN or HEX file containing the new firmware.
+	 * For DFU Bootloader version 0.5 or newer the init file must be specified using one of
+	 * {@link #setInitFile(String)} methods.
+	 *
+	 * @param fileType see {@link #setBinOrHex(int, Uri)} for details
+	 * @param uri      the URI of the file
+	 * @param path     path to the file
+	 * @return the builder
+	 * @deprecated The Distribution packet (ZIP) should be used for DFU Bootloader version 0.5 or newer
+	 */
+	@Deprecated
+	public DfuServiceInitiator setBinOrHex(@FileType final int fileType, @Nullable final Uri uri, @Nullable final String path) {
+		if (fileType == DfuBaseService.TYPE_AUTO)
+			throw new UnsupportedOperationException("You must specify the file type");
+		return init(uri, path, 0, fileType, DfuBaseService.MIME_TYPE_OCTET_STREAM);
+	}
+
+	/**
+	 * Sets the resource ID pointing the BIN or HEX file containing the new firmware.
+	 * The file should be in the /res/raw folder. For DFU Bootloader version 0.5 or newer the init
+	 * file must be specified using one of {@link #setInitFile(int)} methods.
+	 *
+	 * @param fileType see {@link #setBinOrHex(int, Uri)} for details
+	 * @param rawResId resource ID
+	 * @return the builder
+	 */
+	@Deprecated
+	public DfuServiceInitiator setBinOrHex(@FileType final int fileType, @RawRes final int rawResId) {
+		if (fileType == DfuBaseService.TYPE_AUTO)
+			throw new UnsupportedOperationException("You must specify the file type");
+		return init(null, null, rawResId, fileType, DfuBaseService.MIME_TYPE_OCTET_STREAM);
+	}
+
+	/**
+	 * Sets the URI of the Init file. The init file for DFU Bootloader version pre-0.5
+	 * (SDK 4.3, 6.0, 6.1) contains only the CRC-16 of the firmware.
+	 * Bootloader version 0.5 or newer requires the Extended Init Packet.
+	 *
+	 * @param initFileUri the URI of the init file
+	 * @return the builder
+	 */
+	@Deprecated
+	public DfuServiceInitiator setInitFile(@NonNull final Uri initFileUri) {
+		return init(initFileUri, null, 0);
+	}
+
+	/**
+	 * Sets the path to the Init file. The init file for DFU Bootloader version pre-0.5
+	 * (SDK 4.3, 6.0, 6.1) contains only the CRC-16 of the firmware.
+	 * Bootloader version 0.5 or newer requires the Extended Init Packet.
+	 *
+	 * @param initFilePath the path to the init file
+	 * @return the builder
+	 */
+	@Deprecated
+	public DfuServiceInitiator setInitFile(@Nullable final String initFilePath) {
+		return init(null, initFilePath, 0);
+	}
+
+	/**
+	 * Sets the resource ID of the Init file. The init file for DFU Bootloader version pre-0.5
+	 * (SDK 4.3, 6.0, 6.1) contains only the CRC-16 of the firmware.
+	 * Bootloader version 0.5 or newer requires the Extended Init Packet.
+	 *
+	 * @param initFileResId the resource ID of the init file
+	 * @return the builder
+	 */
+	@Deprecated
+	public DfuServiceInitiator setInitFile(@RawRes final int initFileResId) {
+		return init(null, null, initFileResId);
+	}
+
+	/**
+	 * Sets the URI or path to the Init file. The init file for DFU Bootloader version pre-0.5
+	 * (SDK 4.3, 6.0, 6.1) contains only the CRC-16 of the firmware. Bootloader version 0.5 or newer
+	 * requires the Extended Init Packet. If the URI and path are not null the URI will be used.
+	 *
+	 * @param initFileUri  the URI of the init file
+	 * @param initFilePath the path of the init file
+	 * @return the builder
+	 */
+	@Deprecated
+	public DfuServiceInitiator setInitFile(@Nullable final Uri initFileUri, @Nullable final String initFilePath) {
+		return init(initFileUri, initFilePath, 0);
+	}
+
+	/**
+	 * Starts the DFU service.
+	 *
+	 * @param context the application context
+	 * @param service the class derived from the BaseDfuService
+	 */
+	public DfuServiceController start(@NonNull final Context context, @NonNull final Class<? extends DfuBaseService> service) {
+		if (fileType == -1)
+			throw new UnsupportedOperationException("You must specify the firmware file before starting the service");
+
+		final Intent intent = new Intent(context, service);
+
+		intent.putExtra(DfuBaseService.EXTRA_DEVICE_ADDRESS, deviceAddress);
+		intent.putExtra(DfuBaseService.EXTRA_DEVICE_NAME, deviceName);
+		intent.putExtra(DfuBaseService.EXTRA_DISABLE_NOTIFICATION, disableNotification);
+		intent.putExtra(DfuBaseService.EXTRA_FOREGROUND_SERVICE, startAsForegroundService);
+		intent.putExtra(DfuBaseService.EXTRA_FILE_MIME_TYPE, mimeType);
+		intent.putExtra(DfuBaseService.EXTRA_FILE_TYPE, fileType);
+		intent.putExtra(DfuBaseService.EXTRA_FILE_URI, fileUri);
+		intent.putExtra(DfuBaseService.EXTRA_FILE_PATH, filePath);
+		intent.putExtra(DfuBaseService.EXTRA_FILE_RES_ID, fileResId);
+		intent.putExtra(DfuBaseService.EXTRA_INIT_FILE_URI, initFileUri);
+		intent.putExtra(DfuBaseService.EXTRA_INIT_FILE_PATH, initFilePath);
+		intent.putExtra(DfuBaseService.EXTRA_INIT_FILE_RES_ID, initFileResId);
+		intent.putExtra(DfuBaseService.EXTRA_KEEP_BOND, keepBond);
+		intent.putExtra(DfuBaseService.EXTRA_RESTORE_BOND, restoreBond);
+		intent.putExtra(DfuBaseService.EXTRA_FORCE_DFU, forceDfu);
+		intent.putExtra(DfuBaseService.EXTRA_FORCE_SCANNING_FOR_BOOTLOADER_IN_LEGACY_DFU, forceScanningForNewAddressInLegacyDfu);
+		intent.putExtra(DfuBaseService.EXTRA_DISABLE_RESUME, disableResume);
+		intent.putExtra(DfuBaseService.EXTRA_MAX_DFU_ATTEMPTS, numberOfRetries);
+		intent.putExtra(DfuBaseService.EXTRA_MBR_SIZE, mbrSize);
+		intent.putExtra(DfuBaseService.EXTRA_DATA_OBJECT_DELAY, dataObjectDelay);
+		intent.putExtra(DfuBaseService.EXTRA_SCAN_TIMEOUT, scanTimeout);
+		intent.putExtra(DfuBaseService.EXTRA_SCAN_DELAY, rebootTime);
+		if (mtu > 0)
+			intent.putExtra(DfuBaseService.EXTRA_MTU, mtu);
+		intent.putExtra(DfuBaseService.EXTRA_CURRENT_MTU, currentMtu);
+		intent.putExtra(DfuBaseService.EXTRA_UNSAFE_EXPERIMENTAL_BUTTONLESS_DFU, enableUnsafeExperimentalButtonlessDfu);
+		//noinspection StatementWithEmptyBody
+		if (packetReceiptNotificationsEnabled != null) {
+			intent.putExtra(DfuBaseService.EXTRA_PACKET_RECEIPT_NOTIFICATIONS_ENABLED, packetReceiptNotificationsEnabled);
+			intent.putExtra(DfuBaseService.EXTRA_PACKET_RECEIPT_NOTIFICATIONS_VALUE, numberOfPackets);
+		} else {
+			// For backwards compatibility:
+			// If the setPacketsReceiptNotificationsEnabled(boolean) has not been called, the PRN state and value are taken from
+			// SharedPreferences the way they were read in DFU Library in 1.0.3 and before, or set to default values.
+			// Default values: PRNs enabled on Android 4.3 - 5.1 and disabled starting from Android 6.0. Default PRN value is 12.
+		}
+		if (legacyDfuUuids != null)
+			intent.putExtra(DfuBaseService.EXTRA_CUSTOM_UUIDS_FOR_LEGACY_DFU, legacyDfuUuids);
+		if (secureDfuUuids != null)
+			intent.putExtra(DfuBaseService.EXTRA_CUSTOM_UUIDS_FOR_SECURE_DFU, secureDfuUuids);
+		if (experimentalButtonlessDfuUuids != null)
+			intent.putExtra(DfuBaseService.EXTRA_CUSTOM_UUIDS_FOR_EXPERIMENTAL_BUTTONLESS_DFU, experimentalButtonlessDfuUuids);
+		if (buttonlessDfuWithoutBondSharingUuids != null)
+			intent.putExtra(DfuBaseService.EXTRA_CUSTOM_UUIDS_FOR_BUTTONLESS_DFU_WITHOUT_BOND_SHARING, buttonlessDfuWithoutBondSharingUuids);
+		if (buttonlessDfuWithBondSharingUuids != null)
+			intent.putExtra(DfuBaseService.EXTRA_CUSTOM_UUIDS_FOR_BUTTONLESS_DFU_WITH_BOND_SHARING, buttonlessDfuWithBondSharingUuids);
+
+		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O && startAsForegroundService) {
+			// On Android Oreo and above the service must be started as a foreground service to make it accessible from
+			// a killed application.
+			context.startForegroundService(intent);
+		} else {
+			context.startService(intent);
+		}
+		return new DfuServiceController(context);
+	}
+
+	private DfuServiceInitiator init(@Nullable final Uri initFileUri,
+									 @Nullable final String initFilePath,
+									 @RawRes final int initFileResId) {
+		if (DfuBaseService.MIME_TYPE_ZIP.equals(mimeType))
+			throw new InvalidParameterException("Init file must be located inside the ZIP");
+
+		this.initFileUri = initFileUri;
+		this.initFilePath = initFilePath;
+		this.initFileResId = initFileResId;
+		return this;
+	}
+
+	private DfuServiceInitiator init(@Nullable final Uri fileUri,
+									 @Nullable final String filePath,
+									 @RawRes final int fileResId,
+									 final int fileType,
+									 @NonNull final String mimeType) {
+		this.fileUri = fileUri;
+		this.filePath = filePath;
+		this.fileResId = fileResId;
+		this.fileType = fileType;
+		this.mimeType = mimeType;
+
+		// If the MIME TYPE implies it's a ZIP file then the init file must be included in the file.
+		if (DfuBaseService.MIME_TYPE_ZIP.equals(mimeType)) {
+			this.initFileUri = null;
+			this.initFilePath = null;
+			this.initFileResId = 0;
+		}
+		return this;
+	}
+
+	@RequiresApi(api = Build.VERSION_CODES.O)
+	public static void createDfuNotificationChannel(@NonNull final Context context) {
+		final NotificationChannel channel =
+				new NotificationChannel(DfuBaseService.NOTIFICATION_CHANNEL_DFU, context.getString(R.string.dfu_channel_name), NotificationManager.IMPORTANCE_LOW);
+		channel.setDescription(context.getString(R.string.dfu_channel_description));
+		channel.setShowBadge(false);
+		channel.setLockscreenVisibility(Notification.VISIBILITY_PUBLIC);
+
+		final NotificationManager notificationManager =
+				(NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
+		if (notificationManager != null) {
+			notificationManager.createNotificationChannel(channel);
+		}
+	}
+}
\ No newline at end of file
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuServiceListenerHelper.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuServiceListenerHelper.java
new file mode 100644
index 0000000..4006e2d
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuServiceListenerHelper.java
@@ -0,0 +1,395 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.dfu;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import androidx.annotation.NonNull;
+import androidx.localbroadcastmanager.content.LocalBroadcastManager;
+import no.nordicsemi.android.dfu.internal.scanner.BootloaderScannerFactory;
+import no.nordicsemi.android.error.GattError;
+
+/**
+ * A helper class that should be used to register listeners for DFU Service broadcast events.
+ * The {@link DfuProgressListener} should be registered to listen for DFU status updates and errors,
+ * while the {@link DfuLogListener} listener receives the log updates.
+ * Listeners may be registered for a specified device (given with device address) or for any device.
+ * Keep in mind, that while updating the SoftDevice using the buttonless update the device may
+ * change its address in the bootloader mode.
+ * <p>
+ * Use {@link #registerProgressListener(Context, DfuProgressListener)} or
+ * {@link #registerLogListener(Context, DfuLogListener)} to register your listeners.
+ * Remember about unregistering them when your context is destroyed.
+ */
+@SuppressWarnings({"WeakerAccess", "unused"})
+public class DfuServiceListenerHelper {
+	private static LogBroadcastReceiver mLogBroadcastReceiver;
+	private static ProgressBroadcastsReceiver mProgressBroadcastReceiver;
+
+	private static class LogBroadcastReceiver extends BroadcastReceiver {
+		private final Map<String, DfuLogListener> mListeners = new HashMap<>();
+		private DfuLogListener mGlobalLogListener;
+
+		private void setLogListener(final DfuLogListener globalLogListener) {
+			this.mGlobalLogListener = globalLogListener;
+		}
+
+		private void setLogListener(final String deviceAddress, final DfuLogListener listener) {
+			// When using the buttonless update and updating the SoftDevice the application will
+			// be removed to make space for the new SoftDevice.
+			// The new bootloader will afterwards advertise with the address incremented by 1.
+			// We need to make sure that the listener will receive also events from this device.
+			mListeners.put(deviceAddress, listener);
+			mListeners.put(BootloaderScannerFactory.getIncrementedAddress(deviceAddress), listener); // assuming the address is a valid BLE address
+		}
+
+		private boolean removeLogListener(final DfuLogListener listener) {
+			if (mGlobalLogListener == listener)
+				mGlobalLogListener = null;
+
+			// We do it 2 times as the listener was added for 2 addresses
+			for (final Map.Entry<String, DfuLogListener> entry : mListeners.entrySet()) {
+				if (entry.getValue() == listener) {
+					mListeners.remove(entry.getKey());
+					break;
+				}
+			}
+			for (final Map.Entry<String, DfuLogListener> entry : mListeners.entrySet()) {
+				if (entry.getValue() == listener) {
+					mListeners.remove(entry.getKey());
+					break;
+				}
+			}
+
+			return mGlobalLogListener == null && mListeners.isEmpty();
+		}
+
+		@Override
+		public void onReceive(final Context context, final Intent intent) {
+			final String address = intent.getStringExtra(DfuBaseService.EXTRA_DEVICE_ADDRESS);
+
+			// Find proper listeners
+			final DfuLogListener globalListener = mGlobalLogListener;
+			final DfuLogListener deviceListener = mListeners.get(address);
+
+			if (globalListener == null && deviceListener == null)
+				return;
+
+			final int level = intent.getIntExtra(DfuBaseService.EXTRA_LOG_LEVEL, 0);
+			final String message = intent.getStringExtra(DfuBaseService.EXTRA_LOG_MESSAGE);
+
+			if (globalListener != null)
+				globalListener.onLogEvent(address, level, message);
+			if (deviceListener != null)
+				deviceListener.onLogEvent(address, level, message);
+		}
+	}
+
+	private static class ProgressBroadcastsReceiver extends BroadcastReceiver {
+		private final Map<String, DfuProgressListener> mListeners = new HashMap<>();
+		private DfuProgressListener mGlobalProgressListener;
+
+		private void setProgressListener(final DfuProgressListener globalProgressListener) {
+			this.mGlobalProgressListener = globalProgressListener;
+		}
+
+		private void setProgressListener(final String deviceAddress, final DfuProgressListener listener) {
+			// When using the buttonless update and updating the SoftDevice the application will be removed to make space for the new SoftDevice.
+			// The new bootloader will afterwards advertise with the address incremented by 1. We need to make sure that the listener will receive also events from this device.
+			mListeners.put(deviceAddress, listener);
+			mListeners.put(BootloaderScannerFactory.getIncrementedAddress(deviceAddress), listener); // assuming the address is a valid BLE address
+		}
+
+		private boolean removeProgressListener(final DfuProgressListener listener) {
+			if (mGlobalProgressListener == listener)
+				mGlobalProgressListener = null;
+
+			// We do it 2 times as the listener was added for 2 addresses
+			for (final Map.Entry<String, DfuProgressListener> entry : mListeners.entrySet()) {
+				if (entry.getValue() == listener) {
+					mListeners.remove(entry.getKey());
+					break;
+				}
+			}
+			for (final Map.Entry<String, DfuProgressListener> entry : mListeners.entrySet()) {
+				if (entry.getValue() == listener) {
+					mListeners.remove(entry.getKey());
+					break;
+				}
+			}
+
+			return mGlobalProgressListener == null && mListeners.isEmpty();
+		}
+
+		@Override
+		public void onReceive(final Context context, final Intent intent) {
+			final String address = intent.getStringExtra(DfuBaseService.EXTRA_DEVICE_ADDRESS);
+			if (address == null)
+				return;
+
+			// Find proper listeners
+			final DfuProgressListener globalListener = mGlobalProgressListener;
+			final DfuProgressListener deviceListener = mListeners.get(address);
+
+			if (globalListener == null && deviceListener == null)
+				return;
+
+			final String action = intent.getAction();
+			if (action == null)
+				return;
+
+			switch (action) {
+				case DfuBaseService.BROADCAST_PROGRESS: {
+					final int progress = intent.getIntExtra(DfuBaseService.EXTRA_DATA, 0);
+					final float speed = intent.getFloatExtra(DfuBaseService.EXTRA_SPEED_B_PER_MS, 0.0f);
+					final float avgSpeed = intent.getFloatExtra(DfuBaseService.EXTRA_AVG_SPEED_B_PER_MS, 0.0f);
+					final int currentPart = intent.getIntExtra(DfuBaseService.EXTRA_PART_CURRENT, 0);
+					final int partsTotal = intent.getIntExtra(DfuBaseService.EXTRA_PARTS_TOTAL, 0);
+
+					switch (progress) {
+						case DfuBaseService.PROGRESS_CONNECTING:
+							if (globalListener != null)
+								globalListener.onDeviceConnecting(address);
+							if (deviceListener != null)
+								deviceListener.onDeviceConnecting(address);
+							break;
+						case DfuBaseService.PROGRESS_STARTING:
+							if (globalListener != null) {
+								globalListener.onDeviceConnected(address);
+								globalListener.onDfuProcessStarting(address);
+							}
+							if (deviceListener != null) {
+								deviceListener.onDeviceConnected(address);
+								deviceListener.onDfuProcessStarting(address);
+							}
+							break;
+						case DfuBaseService.PROGRESS_ENABLING_DFU_MODE:
+							if (globalListener != null)
+								globalListener.onEnablingDfuMode(address);
+							if (deviceListener != null)
+								deviceListener.onEnablingDfuMode(address);
+							break;
+						case DfuBaseService.PROGRESS_VALIDATING:
+							if (globalListener != null)
+								globalListener.onFirmwareValidating(address);
+							if (deviceListener != null)
+								deviceListener.onFirmwareValidating(address);
+							break;
+						case DfuBaseService.PROGRESS_DISCONNECTING:
+							if (globalListener != null)
+								globalListener.onDeviceDisconnecting(address);
+							if (deviceListener != null)
+								deviceListener.onDeviceDisconnecting(address);
+							break;
+						case DfuBaseService.PROGRESS_COMPLETED:
+							if (globalListener != null) {
+								globalListener.onDeviceDisconnected(address);
+								globalListener.onDfuCompleted(address);
+							}
+							if (deviceListener != null) {
+								deviceListener.onDeviceDisconnected(address);
+								deviceListener.onDfuCompleted(address);
+							}
+							break;
+						case DfuBaseService.PROGRESS_ABORTED:
+							if (globalListener != null) {
+								globalListener.onDeviceDisconnected(address);
+								globalListener.onDfuAborted(address);
+							}
+							if (deviceListener != null) {
+								deviceListener.onDeviceDisconnected(address);
+								deviceListener.onDfuAborted(address);
+							}
+							break;
+						default:
+							if (progress == 0) {
+								if (globalListener != null)
+									globalListener.onDfuProcessStarted(address);
+								if (deviceListener != null)
+									deviceListener.onDfuProcessStarted(address);
+							}
+							if (globalListener != null)
+								globalListener.onProgressChanged(address, progress, speed, avgSpeed, currentPart, partsTotal);
+							if (deviceListener != null)
+								deviceListener.onProgressChanged(address, progress, speed, avgSpeed, currentPart, partsTotal);
+							break;
+					}
+
+					break;
+				}
+				case DfuBaseService.BROADCAST_ERROR: {
+					final int error = intent.getIntExtra(DfuBaseService.EXTRA_DATA, 0);
+					final int errorType = intent.getIntExtra(DfuBaseService.EXTRA_ERROR_TYPE, 0);
+
+					if (globalListener != null)
+						globalListener.onDeviceDisconnected(address);
+					if (deviceListener != null)
+						deviceListener.onDeviceDisconnected(address);
+					switch (errorType) {
+						case DfuBaseService.ERROR_TYPE_COMMUNICATION_STATE:
+							if (globalListener != null)
+								globalListener.onError(address, error, errorType, GattError.parseConnectionError(error));
+							if (deviceListener != null)
+								deviceListener.onError(address, error, errorType, GattError.parseConnectionError(error));
+							break;
+						case DfuBaseService.ERROR_TYPE_DFU_REMOTE:
+							if (globalListener != null)
+								globalListener.onError(address, error, errorType, GattError.parseDfuRemoteError(error));
+							if (deviceListener != null)
+								deviceListener.onError(address, error, errorType, GattError.parseDfuRemoteError(error));
+							break;
+						default:
+							if (globalListener != null)
+								globalListener.onError(address, error, errorType, GattError.parse(error));
+							if (deviceListener != null)
+								deviceListener.onError(address, error, errorType, GattError.parse(error));
+							break;
+					}
+				}
+			}
+		}
+	}
+
+	/**
+	 * Registers the {@link DfuProgressListener}.
+     * Registered listener will receive the progress events from the DFU service.
+	 *
+	 * @param context  the application context.
+	 * @param listener the listener to register.
+	 */
+	public static void registerProgressListener(@NonNull final Context context, @NonNull final DfuProgressListener listener) {
+		if (mProgressBroadcastReceiver == null) {
+			mProgressBroadcastReceiver = new ProgressBroadcastsReceiver();
+
+			final IntentFilter filter = new IntentFilter();
+			filter.addAction(DfuBaseService.BROADCAST_PROGRESS);
+			filter.addAction(DfuBaseService.BROADCAST_ERROR);
+			//noinspection deprecation
+			LocalBroadcastManager.getInstance(context).registerReceiver(mProgressBroadcastReceiver, filter);
+		}
+		mProgressBroadcastReceiver.setProgressListener(listener);
+	}
+
+	/**
+	 * Registers the {@link DfuProgressListener}. Registered listener will receive the progress
+     * events from the DFU service.
+	 *
+	 * @param context       the application context.
+	 * @param listener      the listener to register.
+	 * @param deviceAddress the address of the device to receive updates from (or null if any device).
+	 */
+	public static void registerProgressListener(@NonNull final Context context,
+                                                @NonNull final DfuProgressListener listener, @NonNull final String deviceAddress) {
+		if (mProgressBroadcastReceiver == null) {
+			mProgressBroadcastReceiver = new ProgressBroadcastsReceiver();
+
+			final IntentFilter filter = new IntentFilter();
+			filter.addAction(DfuBaseService.BROADCAST_PROGRESS);
+			filter.addAction(DfuBaseService.BROADCAST_ERROR);
+			//noinspection deprecation
+			LocalBroadcastManager.getInstance(context).registerReceiver(mProgressBroadcastReceiver, filter);
+		}
+		mProgressBroadcastReceiver.setProgressListener(deviceAddress, listener);
+	}
+
+	/**
+	 * Unregisters the previously registered progress listener.
+	 *
+	 * @param context  the application context.
+	 * @param listener the listener to unregister.
+	 */
+	public static void unregisterProgressListener(@NonNull final Context context, @NonNull final DfuProgressListener listener) {
+		if (mProgressBroadcastReceiver != null) {
+			final boolean empty = mProgressBroadcastReceiver.removeProgressListener(listener);
+
+			if (empty) {
+				//noinspection deprecation
+				LocalBroadcastManager.getInstance(context).unregisterReceiver(mProgressBroadcastReceiver);
+				mProgressBroadcastReceiver = null;
+			}
+		}
+	}
+
+	/**
+	 * Registers the {@link DfuLogListener}. Registered listener will receive the log events from the DFU service.
+	 *
+	 * @param context  the application context.
+	 * @param listener the listener to register.
+	 */
+	public static void registerLogListener(@NonNull final Context context, @NonNull final DfuLogListener listener) {
+		if (mLogBroadcastReceiver == null) {
+			mLogBroadcastReceiver = new LogBroadcastReceiver();
+
+			final IntentFilter filter = new IntentFilter();
+			filter.addAction(DfuBaseService.BROADCAST_LOG);
+			//noinspection deprecation
+			LocalBroadcastManager.getInstance(context).registerReceiver(mLogBroadcastReceiver, filter);
+		}
+		mLogBroadcastReceiver.setLogListener(listener);
+	}
+
+	/**
+	 * Registers the {@link DfuLogListener}. Registered listener will receive the log events from
+     * the DFU service.
+	 *
+	 * @param context       the application context.
+	 * @param listener      the listener to register.
+	 * @param deviceAddress the address of the device to receive updates from (or null if any device).
+	 */
+	public static void registerLogListener(@NonNull final Context context,
+                                           @NonNull final DfuLogListener listener, @NonNull final String deviceAddress) {
+		if (mLogBroadcastReceiver == null) {
+			mLogBroadcastReceiver = new LogBroadcastReceiver();
+
+			final IntentFilter filter = new IntentFilter();
+			filter.addAction(DfuBaseService.BROADCAST_LOG);
+			//noinspection deprecation
+			LocalBroadcastManager.getInstance(context).registerReceiver(mLogBroadcastReceiver, filter);
+		}
+		mLogBroadcastReceiver.setLogListener(deviceAddress, listener);
+	}
+
+	/**
+	 * Unregisters the previously registered log listener.
+	 *
+	 * @param context  the application context.
+	 * @param listener the listener to unregister.
+	 */
+	public static void unregisterLogListener(@NonNull final Context context, @NonNull final DfuLogListener listener) {
+		if (mLogBroadcastReceiver != null) {
+			final boolean empty = mLogBroadcastReceiver.removeLogListener(listener);
+
+			if (empty) {
+				//noinspection deprecation
+				LocalBroadcastManager.getInstance(context).unregisterReceiver(mLogBroadcastReceiver);
+				mLogBroadcastReceiver = null;
+			}
+		}
+	}
+}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuServiceProvider.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuServiceProvider.java
new file mode 100644
index 0000000..7278f76
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuServiceProvider.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.dfu;
+
+import android.bluetooth.BluetoothGatt;
+import android.content.Intent;
+
+import androidx.annotation.NonNull;
+import no.nordicsemi.android.dfu.internal.exception.DeviceDisconnectedException;
+import no.nordicsemi.android.dfu.internal.exception.DfuException;
+import no.nordicsemi.android.dfu.internal.exception.UploadAbortedException;
+
+/* package */ class DfuServiceProvider implements DfuCallback {
+	private BaseDfuImpl mImpl;
+	private boolean mPaused;
+	private boolean mAborted;
+
+	DfuService getServiceImpl(@NonNull final Intent intent, @NonNull final DfuBaseService service, @NonNull final BluetoothGatt gatt)
+			throws DfuException, DeviceDisconnectedException, UploadAbortedException {
+		try {
+			mImpl = new ButtonlessDfuWithBondSharingImpl(intent, service);
+			if (mImpl.isClientCompatible(intent, gatt))
+				return mImpl;
+
+			mImpl = new ButtonlessDfuWithoutBondSharingImpl(intent, service);
+			if (mImpl.isClientCompatible(intent, gatt))
+				return mImpl;
+
+			mImpl = new SecureDfuImpl(intent, service);
+			if (mImpl.isClientCompatible(intent, gatt))
+				return mImpl;
+
+			mImpl = new LegacyButtonlessDfuImpl(intent, service); // This will read the DFU Version char...
+			if (mImpl.isClientCompatible(intent, gatt))
+				return mImpl;
+
+			mImpl = new LegacyDfuImpl(intent, service);           // ...that this impl will then use.
+			if (mImpl.isClientCompatible(intent, gatt))
+				return mImpl;
+
+			// Support for experimental Buttonless DFU Service from SDK 12.
+			// This feature must be explicitly enabled in the initiator.
+			final boolean enableUnsafeExperimentalButtonlessDfuService = intent.getBooleanExtra(DfuBaseService.EXTRA_UNSAFE_EXPERIMENTAL_BUTTONLESS_DFU, false);
+			if (enableUnsafeExperimentalButtonlessDfuService) {
+				mImpl = new ExperimentalButtonlessDfuImpl(intent, service);
+				if (mImpl.isClientCompatible(intent, gatt))
+					return mImpl;
+			}
+			// No implementation found
+			return null;
+		} finally {
+			// Call pause() or abort() only on the chosen implementation
+			if (mImpl != null) {
+				if (mPaused)
+					mImpl.pause();
+				if (mAborted)
+					mImpl.abort();
+			}
+		}
+	}
+
+	@Override
+	public DfuGattCallback getGattCallback() {
+		return mImpl != null ? mImpl.getGattCallback() : null;
+	}
+
+	@Override
+	public void onBondStateChanged(final int state) {
+		if (mImpl != null)
+			mImpl.onBondStateChanged(state);
+	}
+
+	@Override
+	public void pause() {
+		mPaused = true;
+	}
+
+	@Override
+	public void resume() {
+		mPaused = false;
+	}
+
+	@Override
+	public void abort() {
+		mAborted = true;
+		if (mImpl != null)
+			mImpl.abort();
+	}
+}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuSettingsConstants.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuSettingsConstants.java
new file mode 100644
index 0000000..84f7bc7
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuSettingsConstants.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.dfu;
+
+import android.bluetooth.BluetoothGattCharacteristic;
+
+/**
+ * A collection of constants used for reading DFU constants from
+ * {@link android.preference.PreferenceManager} in previous versions of DFU Library.
+ *
+ * @deprecated Use {@link DfuServiceInitiator} methods instead.
+ */
+@SuppressWarnings("DeprecatedIsStillUsed")
+@Deprecated
+public interface DfuSettingsConstants {
+	/**
+	 * This property must contain a boolean value.
+	 * <p>
+	 * If true (default) the Packet Receipt Notification procedure will be enabled.
+	 * See DFU documentation on
+	 * <a href="https://infocenter.nordicsemi.com/topic/sdk_nrf5_v17.0.0/lib_dfu_transport.html?cp=7_1_3_5_2">Infocenter</a>
+	 * for more details. The number of packets before receiving a Packet Receipt Notification
+	 * is set with property {@link #SETTINGS_NUMBER_OF_PACKETS}.
+	 *
+	 * @deprecated Use {@link DfuServiceInitiator#setPacketsReceiptNotificationsEnabled(boolean)} to set it.
+	 */
+	@Deprecated
+	String SETTINGS_PACKET_RECEIPT_NOTIFICATION_ENABLED = "settings_packet_receipt_notification_enabled";
+
+	/**
+	 * This property must contain a positive integer value, usually from range 1-200.
+	 * <p>The default value is {@value #SETTINGS_NUMBER_OF_PACKETS_DEFAULT}. Setting it to 0 will
+	 * disable the Packet Receipt Notification procedure. When sending a firmware using the
+	 * DFU procedure the service will send this number of packets before waiting for a notification.
+	 * Packet Receipt Notifications are used to synchronize the sender with receiver.
+	 * On Android, calling {@link android.bluetooth.BluetoothGatt#writeCharacteristic(BluetoothGattCharacteristic)}
+	 * will simply add the packet to outgoing queue before returning the callback. Adding the
+	 * next packet in the callback is much faster than the real transmission (also the speed depends on
+	 * the device chip manufacturer) and the queue may reach its limit. When does, the transmission
+	 * stops and Android Bluetooth hangs. Using PRN procedure eliminates this problem as
+	 * the notification is send when all packets were delivered the queue is empty.
+	 * <p>
+	 * Note: this bug has been fixed on Android 6.0 Marshmallow and now no notifications are required.
+	 * The onCharacteristicWrite callback will be postponed until half of the queue is empty.
+	 *
+	 * @deprecated Use {@link DfuServiceInitiator#setPacketsReceiptNotificationsValue(int)} to set it.
+	 */
+	@Deprecated
+	String SETTINGS_NUMBER_OF_PACKETS = "settings_number_of_packets";
+
+	/**
+	 * The default value of {@link #SETTINGS_NUMBER_OF_PACKETS} property.
+	 * Different phones sent a different number of packets each connection interval.
+	 * The values are (for tested phones):
+	 * <ul>
+	 *     <li>1 packet - Nexus 4 and Nexus 7 and others</li>
+	 *     <li>4 packets - Nexus 5 and Nexus 6 and others</li>
+	 *     <li>6 packets - LG F60 and others</li>
+	 * </ul>
+	 * The least common multiplier is 12 which is reasonably small. You may try other values,
+	 * like 24 etc. Values higher than ~300 may cause the Bluetooth outgoing queue overflow
+	 * error on Android versions before Marshmallow.
+	 *
+	 * @deprecated Use {@link DfuServiceInitiator#setPacketsReceiptNotificationsValue(int)} to set it.
+	 */
+	@Deprecated
+	int SETTINGS_NUMBER_OF_PACKETS_DEFAULT = DfuServiceInitiator.DEFAULT_PRN_VALUE;
+
+	/**
+	 * This property must contain an integer value.
+	 * <p>
+	 * Size of the MBR (Master Boot Record) for the target chip. This applies only if you are
+	 * using HEX files. The HEX_to_BIN parser included in the library will skip the addresses
+	 * from 0 to this value. By default for nRF51 and the SoftDevice S110 this value is equal
+	 * 4096 (0x1000 HEX) and for nRF52 has to be changed to 12288 (0x3000). If you want to send
+	 * a firmware in HEX onto another MCU via nRF chip, set this value to 0.
+	 * <p>
+	 * If you are using the PC nrf util tool to create a ZIP Distribution Packet with the
+	 * firmware and Init Packet this option does not apply as the nrf tool will convert
+	 * HEX to BIN itself.
+	 *
+	 * @deprecated Use {@link DfuServiceInitiator#setMbrSize(int)} instead.
+	 */
+	@Deprecated
+	String SETTINGS_MBR_SIZE = "settings_mbr_size";
+
+	/**
+	 * This property must contain a boolean value.
+	 * <p>
+	 * The {@link DfuBaseService}, when connected to a DFU target will check whether it is
+	 * in application or in DFU bootloader mode. For DFU implementations from SDK 7.0 or newer
+	 * this is done by reading the value of DFU Version characteristic. If the returned value
+	 * is equal to 0x0100 (major = 0, minor = 1) it means that we are in the application mode and
+	 * jump to the bootloader mode is required.
+	 * <p>
+	 * However, for DFU implementations from older SDKs, where there was no DFU Version
+	 * characteristic, the service must guess. If this option is set to false (default) it will count
+	 * number of device's services. If the count is equal to 3 (Generic Access, Generic Attribute,
+	 * DFU Service) it will assume that it's in DFU mode. If greater than 3 - in app mode.
+	 * This guessing may not be always correct. One situation may be when the nRF chip is used
+	 * to flash update on external MCU using DFU. The DFU procedure may be implemented in the
+	 * application, which may (and usually does) have more services. In such case set the
+	 * value of this property to true.
+	 *
+	 * @deprecated Use {@link DfuServiceInitiator#setForceDfu(boolean)} instead.
+	 */
+	@Deprecated
+	String SETTINGS_ASSUME_DFU_NODE = "settings_assume_dfu_mode";
+}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/ExperimentalButtonlessDfuImpl.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/ExperimentalButtonlessDfuImpl.java
new file mode 100644
index 0000000..67390d3
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/ExperimentalButtonlessDfuImpl.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.dfu;
+
+import android.bluetooth.BluetoothGatt;
+import android.bluetooth.BluetoothGattCharacteristic;
+import android.bluetooth.BluetoothGattService;
+import android.content.Intent;
+
+import java.util.UUID;
+
+import androidx.annotation.NonNull;
+import no.nordicsemi.android.dfu.internal.exception.DeviceDisconnectedException;
+import no.nordicsemi.android.dfu.internal.exception.DfuException;
+import no.nordicsemi.android.dfu.internal.exception.UploadAbortedException;
+
+/**
+ * The implementation of the experimental buttonless service that was
+ * implemented in SDK 12.x. The original implementation had bugs and must be enabled using this method:
+ * (see {@link DfuServiceInitiator#setUnsafeExperimentalButtonlessServiceInSecureDfuEnabled(boolean)}).
+ * Read this method documentation for more details.
+ */
+/* package */ class ExperimentalButtonlessDfuImpl extends ButtonlessDfuImpl {
+	/** The UUID of the experimental Buttonless DFU service from SDK 12.x. */
+	static final UUID DEFAULT_EXPERIMENTAL_BUTTONLESS_DFU_SERVICE_UUID = new UUID(0x8E400001F3154F60L, 0x9FB8838830DAEA50L);
+	/** The UUID of the experimental Buttonless DFU characteristic from SDK 12.x. */
+	static final UUID DEFAULT_EXPERIMENTAL_BUTTONLESS_DFU_UUID         = new UUID(0x8E400001F3154F60L, 0x9FB8838830DAEA50L); // the same as service
+
+	static UUID EXPERIMENTAL_BUTTONLESS_DFU_SERVICE_UUID = DEFAULT_EXPERIMENTAL_BUTTONLESS_DFU_SERVICE_UUID;
+	static UUID EXPERIMENTAL_BUTTONLESS_DFU_UUID         = DEFAULT_EXPERIMENTAL_BUTTONLESS_DFU_UUID;
+
+	private BluetoothGattCharacteristic mButtonlessDfuCharacteristic;
+
+	ExperimentalButtonlessDfuImpl(@NonNull final Intent intent, @NonNull final DfuBaseService service) {
+		super(intent, service);
+	}
+
+	@Override
+	public boolean isClientCompatible(@NonNull final Intent intent, @NonNull final BluetoothGatt gatt) {
+		final BluetoothGattService dfuService = gatt.getService(EXPERIMENTAL_BUTTONLESS_DFU_SERVICE_UUID);
+		if (dfuService == null)
+			return false;
+		final BluetoothGattCharacteristic characteristic = dfuService.getCharacteristic(EXPERIMENTAL_BUTTONLESS_DFU_UUID);
+		if (characteristic == null || characteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG) == null)
+			return false;
+		mButtonlessDfuCharacteristic = characteristic;
+		return true;
+	}
+
+	@Override
+	protected int getResponseType() {
+		return NOTIFICATIONS;
+	}
+
+	@Override
+	protected BluetoothGattCharacteristic getButtonlessDfuCharacteristic() {
+		return mButtonlessDfuCharacteristic;
+	}
+
+	@Override
+	protected boolean shouldScanForBootloader() {
+		return true;
+	}
+
+	@Override
+	public void performDfu(@NonNull final Intent intent) throws DfuException, DeviceDisconnectedException, UploadAbortedException {
+		logi("Experimental buttonless service found -> SDK 12.x");
+		super.performDfu(intent);
+	}
+}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/FileType.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/FileType.java
new file mode 100644
index 0000000..b9d70b2
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/FileType.java
@@ -0,0 +1,17 @@
+package no.nordicsemi.android.dfu;
+
+import androidx.annotation.IntDef;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+@SuppressWarnings("WeakerAccess")
+@Retention(RetentionPolicy.SOURCE)
+@IntDef(value = {
+            DfuBaseService.TYPE_SOFT_DEVICE,
+            DfuBaseService.TYPE_BOOTLOADER,
+            DfuBaseService.TYPE_APPLICATION
+        },
+        flag = true)
+public @interface FileType {}
+
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/LegacyButtonlessDfuImpl.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/LegacyButtonlessDfuImpl.java
new file mode 100644
index 0000000..99d50f2
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/LegacyButtonlessDfuImpl.java
@@ -0,0 +1,286 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.dfu;
+
+import android.annotation.SuppressLint;
+import android.bluetooth.BluetoothGatt;
+import android.bluetooth.BluetoothGattCharacteristic;
+import android.bluetooth.BluetoothGattService;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.os.Build;
+import android.preference.PreferenceManager;
+
+import java.util.UUID;
+
+import androidx.annotation.NonNull;
+import no.nordicsemi.android.dfu.internal.exception.DeviceDisconnectedException;
+import no.nordicsemi.android.dfu.internal.exception.DfuException;
+import no.nordicsemi.android.dfu.internal.exception.UploadAbortedException;
+
+/**
+ * Implementations of the legacy buttonless service introduced in SDK 6.1.
+ */
+@SuppressLint("MissingPermission")
+/* package */ class LegacyButtonlessDfuImpl extends BaseButtonlessDfuImpl {
+	// UUIDs used by the DFU
+	static UUID DFU_SERVICE_UUID = LegacyDfuImpl.DEFAULT_DFU_SERVICE_UUID;
+	static UUID DFU_CONTROL_POINT_UUID = LegacyDfuImpl.DEFAULT_DFU_CONTROL_POINT_UUID;
+	static UUID DFU_VERSION_UUID = LegacyDfuImpl.DEFAULT_DFU_VERSION_UUID;
+
+	private static final byte[] OP_CODE_ENTER_BOOTLOADER = new byte[]{0x01, 0x04};
+
+	private BluetoothGattCharacteristic mControlPointCharacteristic;
+	private int mVersion;
+
+	LegacyButtonlessDfuImpl(@NonNull final Intent intent, @NonNull final DfuBaseService service) {
+		super(intent, service);
+	}
+
+	@SuppressWarnings("deprecation")
+	@Override
+	public boolean isClientCompatible(@NonNull final Intent intent, @NonNull final BluetoothGatt gatt)
+			throws DfuException, DeviceDisconnectedException, UploadAbortedException {
+		final BluetoothGattService dfuService = gatt.getService(DFU_SERVICE_UUID);
+		if (dfuService == null)
+			return false;
+		final BluetoothGattCharacteristic characteristic = dfuService.getCharacteristic(DFU_CONTROL_POINT_UUID);
+		if (characteristic == null || characteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG) == null)
+			return false;
+		mControlPointCharacteristic = characteristic;
+
+		mProgressInfo.setProgress(DfuBaseService.PROGRESS_STARTING);
+
+		// Add one second delay to avoid the traffic jam before the DFU mode is enabled
+		// Related:
+		//   issue:        https://github.com/NordicSemiconductor/Android-DFU-Library/issues/10
+		//   pull request: https://github.com/NordicSemiconductor/Android-DFU-Library/pull/12
+		mService.waitFor(1000);
+		// End
+
+		/*
+		 * Read the version number if available.
+		 * The DFU Version characteristic has been added in SDK 7.0.
+		 * The version number consists of 2 bytes: major and minor. Therefore e.g. the version 5 (00-05) can be read as 0.5.
+		 *
+		 * Currently supported versions are:
+		 *  * no DFU Version characteristic - we may be either in the bootloader mode or in the app mode. The DFU Bootloader from SDK 6.1 did not have this characteristic,
+		 *                                    but it also supported the buttonless update. Usually, the application must have had some additional services (like Heart Rate, etc)
+		 *                                    so if the number of services greater is than 3 (Generic Access, Generic Attribute, DFU Service) we can also assume we are in
+		 *                                    the application mode and jump is required.
+		 *
+		 *  * version = 1 (major = 0, minor = 1) - Application with DFU buttonless update supported. A jump to DFU mode is required.
+		 *
+		 *  * version = 5 (major = 0, minor = 5) - Since version 5 the Extended Init Packet is required. Keep in mind that if we are in the app mode the DFU Version characteristic
+		 *  								  still returns version = 1, as it is independent from the DFU Bootloader. The version = 5 is reported only after successful jump to
+		 *  								  the DFU mode. In version = 5 the bond information is always lost. Released in SDK 7.0.0.
+		 *
+		 *  * version = 6 (major = 0, minor = 6) - The DFU Bootloader may be configured to keep the bond information after application update. Please, see the {@link #EXTRA_KEEP_BOND}
+		 *  								  documentation for more information about how to enable the feature (disabled by default). A change in the DFU bootloader source and
+		 *  								  setting the {@link DfuServiceInitiator#setKeepBond} to true is required. Released in SDK 8.0.0.
+		 *
+		 *  * version = 7 (major = 0, minor = 7) - The SHA-256 firmware hash is used in the Extended Init Packet instead of CRC-16. This feature is transparent for the DFU Service.
+		 *
+		 *  * version = 8 (major = 0, minor = 8) - The Extended Init Packet is signed using the private key. The bootloader, using the public key, is able to verify the content.
+		 *  								  Released in SDK 9.0.0 as experimental feature.
+		 *  								  Caution! The firmware type (Application, Bootloader, SoftDevice or SoftDevice+Bootloader) is not encrypted as it is not a part of the
+		 *  								  Extended Init Packet. Use Secure DFU instead for better security.
+		 */
+		int version = 0;
+		final BluetoothGattCharacteristic versionCharacteristic = dfuService.getCharacteristic(DFU_VERSION_UUID); // this may be null for older versions of the Bootloader
+		if (versionCharacteristic != null) {
+			version = mVersion = readVersion(gatt, versionCharacteristic);
+			final int minor = (version & 0x0F);
+			final int major = (version >> 8);
+			logi("Version number read: " + major + "." + minor + " -> " + getVersionFeatures(version));
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Version number read: " + major + "." + minor);
+		} else {
+			logi("No DFU Version characteristic found -> " + getVersionFeatures(version));
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "DFU Version characteristic not found");
+		}
+
+		/*
+		 * In case of old DFU bootloader versions, where there was no DFU Version characteristic, the service was unable to determine whether it was in the application mode, or in
+		 * bootloader mode. In that case, if the following boolean value is set to false (default) the bootloader will count number of services on the device. In case of 3 service
+		 * it will start the DFU procedure (Generic Access, Generic Attribute, DFU Service). If more services will be found, it assumes that a jump to the DFU bootloader is required.
+		 *
+		 * However, in some cases, the DFU bootloader is used to flash firmware on other chip via nRF5x. In that case the application may support DFU operation without switching
+		 * to the bootloader mode itself.
+		 *
+		 * For newer implementations of DFU in such case the DFU Version should return value other than 0x0100 (major 0, minor 1) which means that the application does not support
+		 * DFU process itself but rather support jump to the bootloader mode.
+		 */
+		final SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(mService);
+		boolean assumeDfuMode = preferences.getBoolean(DfuSettingsConstants.SETTINGS_ASSUME_DFU_NODE, false);
+		if (intent.hasExtra(DfuBaseService.EXTRA_FORCE_DFU))
+			assumeDfuMode = intent.getBooleanExtra(DfuBaseService.EXTRA_FORCE_DFU, false);
+
+		final boolean moreServicesFound = gatt.getServices().size() > 3; // More services than Generic Access, Generic Attribute, DFU Service
+		if (version == 0 && moreServicesFound)
+			logi("Additional services found -> Bootloader from SDK 6.1. Updating SD and BL supported, extended init packet not supported");
+		return version == 1 || (!assumeDfuMode && version == 0 && moreServicesFound);
+	}
+
+	@Override
+	public void performDfu(@NonNull final Intent intent) throws DfuException, DeviceDisconnectedException, UploadAbortedException {
+		logw("Application with legacy buttonless update found");
+
+		// The service is connected to the application, not to the bootloader
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING, "Application with buttonless update found");
+
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Jumping to the DFU Bootloader...");
+
+		// Let's request the MTU requested by the user. It may be that a lower MTU will be used.
+		if (intent.hasExtra(DfuBaseService.EXTRA_MTU) && Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+			final int requiredMtu = intent.getIntExtra(DfuBaseService.EXTRA_MTU, 517);
+			logi("Requesting MTU = " + requiredMtu);
+			requestMtu(requiredMtu);
+		}
+
+		// Enable notifications
+		enableCCCD(mControlPointCharacteristic, NOTIFICATIONS);
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Notifications enabled");
+
+		// Wait a second here before going further
+		// Related:
+		//   pull request: https://github.com/NordicSemiconductor/Android-DFU-Library/pull/11
+		mService.waitFor(1000);
+		// End
+
+		// Send 'jump to bootloader command' (Start DFU)
+		mProgressInfo.setProgress(DfuBaseService.PROGRESS_ENABLING_DFU_MODE);
+		logi("Sending Start DFU command (Op Code = 1, Upload Mode = 4)");
+		writeOpCode(mControlPointCharacteristic, OP_CODE_ENTER_BOOTLOADER, true);
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Jump to bootloader sent (Op Code = 1, Upload Mode = 4)");
+
+		// The device will disconnect and now reset. Some devices don't disconnect gracefully,
+		// but reset instead. In that case, Android would assume disconnection after
+		// "supervision timeout" seconds, which may be 5 more seconds. If the device will
+		// use a different address in bootloader mode, there is no reason to wait for that.
+		// The library will immediately start scanning for the device advertising in
+		// bootloader mode and connect to it.
+		final boolean forceScanning = intent.getBooleanExtra(DfuBaseService.EXTRA_FORCE_SCANNING_FOR_BOOTLOADER_IN_LEGACY_DFU, false);
+		if (/* Bootloader from SDK 6.1 may use incremented address, see Pull request #45 */ !forceScanning && mVersion > 0) {
+			mService.waitUntilDisconnected();
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO, "Disconnected by the remote device");
+		}
+
+		/*
+		 * We would like to avoid using the hack with refreshing the device (refresh method is not in the public API). The refresh method clears the cached services and causes a
+		 * service discovery afterwards (when connected). Android, however, does it itself when receive the Service Changed indication when bonded.
+		 * In case of unpaired device we may either refresh the services manually (using the hack), or include the Service Changed characteristic.
+		 *
+		 * According to Bluetooth Core 4.0 (and 4.1) specification:
+		 *
+		 * [Vol. 3, Part G, 2.5.2 - Attribute Caching]
+		 * Note: Clients without a trusted relationship must perform service discovery on each connection if the server supports the Services Changed characteristic.
+		 *
+		 * However, as up to Android 7 the system does NOT respect this requirement and servers are cached for every device, even if Service Changed is enabled -> Android BUG?
+		 * For bonded devices Android performs service re-discovery when SC indication is received.
+		 *
+		 * Android 8 and 9 never cache services of not bonded devices.
+		 */
+		final BluetoothGatt gatt = mGatt;
+		final BluetoothGattService gas = gatt.getService(GENERIC_ATTRIBUTE_SERVICE_UUID);
+		final boolean hasServiceChanged = gas != null && gas.getCharacteristic(SERVICE_CHANGED_UUID) != null;
+		mService.refreshDeviceCache(gatt, !hasServiceChanged);
+
+		// Close the device
+		mService.close(gatt);
+
+		logi("Starting service that will connect to the DFU bootloader");
+		final Intent newIntent = new Intent();
+		newIntent.fillIn(intent, Intent.FILL_IN_COMPONENT | Intent.FILL_IN_PACKAGE);
+		restartService(newIntent, /* scan only for SDK 6.1, see Pull request #45 */ forceScanning || mVersion == 0);
+	}
+
+	/**
+	 * Reads the DFU Version characteristic if such exists. Otherwise it returns 0.
+	 *
+	 * @param gatt           the GATT device.
+	 * @param characteristic the characteristic to read.
+	 * @return a version number or 0 if not present on the bootloader.
+	 * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of
+	 *                                     the transmission.
+	 * @throws DfuException                Thrown if DFU error occur.
+	 * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
+	 */
+	private int readVersion(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic)
+            throws DeviceDisconnectedException, DfuException, UploadAbortedException {
+		if (!mConnected)
+			throw new DeviceDisconnectedException("Unable to read version number: device disconnected");
+		if (mAborted)
+			throw new UploadAbortedException();
+		// If the DFU Version characteristic is not available we return 0.
+		if (characteristic == null)
+			return 0;
+
+		mReceivedData = null;
+		mError = 0;
+
+		logi("Reading DFU version number...");
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Reading DFU version number...");
+
+		characteristic.setValue((byte[]) null);
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_DEBUG, "gatt.readCharacteristic(" + characteristic.getUuid() + ")");
+		gatt.readCharacteristic(characteristic);
+
+		// We have to wait until device receives a response or an error occur
+		try {
+			synchronized (mLock) {
+				while (((!mRequestCompleted || characteristic.getValue() == null) && mConnected && mError == 0 && !mAborted) || mPaused) {
+					mRequestCompleted = false;
+					mLock.wait();
+				}
+			}
+		} catch (final InterruptedException e) {
+			loge("Sleeping interrupted", e);
+		}
+		if (!mConnected)
+			throw new DeviceDisconnectedException("Unable to read version number: device disconnected");
+		if (mError != 0)
+			throw new DfuException("Unable to read version number", mError);
+
+		// The version is a 16-bit unsigned int
+		return characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT16, 0);
+	}
+
+	private String getVersionFeatures(final int version) {
+		switch (version) {
+			case 0:
+				return "Bootloader from SDK 6.1 or older";
+			case 1:
+				return "Application with Legacy buttonless update from SDK 7.0 or newer";
+			case 5:
+				return "Bootloader from SDK 7.0 or newer. No bond sharing";
+			case 6:
+				return "Bootloader from SDK 8.0 or newer. Bond sharing supported";
+			case 7:
+				return "Bootloader from SDK 8.0 or newer. SHA-256 used instead of CRC-16 in the Init Packet";
+			case 8:
+				return "Bootloader from SDK 9.0 or newer. Signature supported";
+			default:
+				return "Unknown version";
+		}
+	}
+}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/LegacyDfuImpl.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/LegacyDfuImpl.java
new file mode 100644
index 0000000..bb5941d
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/LegacyDfuImpl.java
@@ -0,0 +1,755 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.dfu;
+
+import android.annotation.SuppressLint;
+import android.bluetooth.BluetoothGatt;
+import android.bluetooth.BluetoothGattCharacteristic;
+import android.bluetooth.BluetoothGattService;
+import android.content.Intent;
+import android.os.Build;
+import android.os.SystemClock;
+
+import java.util.Locale;
+import java.util.UUID;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import no.nordicsemi.android.dfu.internal.ArchiveInputStream;
+import no.nordicsemi.android.dfu.internal.exception.DeviceDisconnectedException;
+import no.nordicsemi.android.dfu.internal.exception.DfuException;
+import no.nordicsemi.android.dfu.internal.exception.RemoteDfuException;
+import no.nordicsemi.android.dfu.internal.exception.UnknownResponseException;
+import no.nordicsemi.android.dfu.internal.exception.UploadAbortedException;
+import no.nordicsemi.android.error.LegacyDfuError;
+
+@SuppressLint("MissingPermission")
+/* package */ class LegacyDfuImpl extends BaseCustomDfuImpl {
+	// UUIDs used by the DFU
+	static final UUID DEFAULT_DFU_SERVICE_UUID       = new UUID(0x000015301212EFDEL, 0x1523785FEABCD123L);
+	static final UUID DEFAULT_DFU_CONTROL_POINT_UUID = new UUID(0x000015311212EFDEL, 0x1523785FEABCD123L);
+	static final UUID DEFAULT_DFU_PACKET_UUID        = new UUID(0x000015321212EFDEL, 0x1523785FEABCD123L);
+	static final UUID DEFAULT_DFU_VERSION_UUID       = new UUID(0x000015341212EFDEL, 0x1523785FEABCD123L);
+
+	static UUID DFU_SERVICE_UUID       = DEFAULT_DFU_SERVICE_UUID;
+	static UUID DFU_CONTROL_POINT_UUID = DEFAULT_DFU_CONTROL_POINT_UUID;
+	static UUID DFU_PACKET_UUID        = DEFAULT_DFU_PACKET_UUID;
+	static UUID DFU_VERSION_UUID       = DEFAULT_DFU_VERSION_UUID;
+
+	private static final int DFU_STATUS_SUCCESS = 1;
+	// Operation codes and packets
+	private static final int OP_CODE_START_DFU_KEY = 0x01; // 1
+	private static final int OP_CODE_INIT_DFU_PARAMS_KEY = 0x02; // 2
+	private static final int OP_CODE_RECEIVE_FIRMWARE_IMAGE_KEY = 0x03; // 3
+	private static final int OP_CODE_VALIDATE_KEY = 0x04; // 4
+	private static final int OP_CODE_ACTIVATE_AND_RESET_KEY = 0x05; // 5
+	private static final int OP_CODE_RESET_KEY = 0x06; // 6
+	//private static final int OP_CODE_PACKET_REPORT_RECEIVED_IMAGE_SIZE_KEY = 0x07; // 7
+	private static final int OP_CODE_PACKET_RECEIPT_NOTIF_REQ_KEY = 0x08; // 8
+	private static final int OP_CODE_RESPONSE_CODE_KEY = 0x10; // 16
+	private static final int OP_CODE_PACKET_RECEIPT_NOTIF_KEY = 0x11; // 11
+	private static final byte[] OP_CODE_START_DFU = new byte[]{OP_CODE_START_DFU_KEY, 0x00};
+	private static final byte[] OP_CODE_START_DFU_V1 = new byte[]{OP_CODE_START_DFU_KEY};
+	private static final byte[] OP_CODE_INIT_DFU_PARAMS = new byte[]{OP_CODE_INIT_DFU_PARAMS_KEY}; // SDK 6.0.0 or older
+	private static final byte[] OP_CODE_INIT_DFU_PARAMS_START = new byte[]{OP_CODE_INIT_DFU_PARAMS_KEY, 0x00};
+	private static final byte[] OP_CODE_INIT_DFU_PARAMS_COMPLETE = new byte[]{OP_CODE_INIT_DFU_PARAMS_KEY, 0x01};
+	private static final byte[] OP_CODE_RECEIVE_FIRMWARE_IMAGE = new byte[]{OP_CODE_RECEIVE_FIRMWARE_IMAGE_KEY};
+	private static final byte[] OP_CODE_VALIDATE = new byte[]{OP_CODE_VALIDATE_KEY};
+	private static final byte[] OP_CODE_ACTIVATE_AND_RESET = new byte[]{OP_CODE_ACTIVATE_AND_RESET_KEY};
+	private static final byte[] OP_CODE_RESET = new byte[]{OP_CODE_RESET_KEY};
+	//private static final byte[] OP_CODE_REPORT_RECEIVED_IMAGE_SIZE = new byte[] { OP_CODE_PACKET_REPORT_RECEIVED_IMAGE_SIZE_KEY };
+	private static final byte[] OP_CODE_PACKET_RECEIPT_NOTIF_REQ = new byte[]{OP_CODE_PACKET_RECEIPT_NOTIF_REQ_KEY, 0x00, 0x00};
+
+	private BluetoothGattCharacteristic mControlPointCharacteristic;
+	private BluetoothGattCharacteristic mPacketCharacteristic;
+
+	/**
+	 * Flag indicating whether the image size has been already transferred or not.
+	 */
+	private boolean mImageSizeInProgress;
+
+	private final LegacyBluetoothCallback mBluetoothCallback = new LegacyBluetoothCallback();
+
+	protected class LegacyBluetoothCallback extends BaseCustomBluetoothCallback {
+		@Override
+		protected void onPacketCharacteristicWrite(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final int status) {
+			if (mImageSizeInProgress) {
+				// We've got confirmation that the image size was sent
+				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO, "Data written to " + characteristic.getUuid() + ", value (0x): " + parse(characteristic));
+				mImageSizeInProgress = false;
+			}
+		}
+
+		@Override
+		public void onCharacteristicChanged(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic) {
+			final int responseType = characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT8, 0);
+
+			switch (responseType) {
+				case OP_CODE_PACKET_RECEIPT_NOTIF_KEY:
+					mProgressInfo.setBytesReceived(characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT32, 1));
+					handlePacketReceiptNotification(gatt, characteristic);
+					break;
+				case OP_CODE_RESPONSE_CODE_KEY:
+				default:
+					/*
+					 * If the DFU target device is in invalid state (f.e. the Init Packet is required but has not been selected), the target will send DFU_STATUS_INVALID_STATE error
+					 * for each firmware packet that was send. We are interested may ignore all but the first one.
+					 * After obtaining a remote DFU error the OP_CODE_RESET_KEY will be sent.
+					 */
+					if (mRemoteErrorOccurred)
+						break;
+					final int status = characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT8, 2);
+					if (status != DFU_STATUS_SUCCESS)
+						mRemoteErrorOccurred = true;
+
+					handleNotification(gatt, characteristic);
+					break;
+			}
+			notifyLock();
+		}
+	}
+
+	/* package */ LegacyDfuImpl(@NonNull final Intent intent, @NonNull final DfuBaseService service) {
+		super(intent, service);
+	}
+
+	@Override
+	public boolean isClientCompatible(@NonNull final Intent intent, @NonNull final BluetoothGatt gatt) {
+		final BluetoothGattService dfuService = gatt.getService(DFU_SERVICE_UUID);
+		if (dfuService == null)
+			return false;
+		final BluetoothGattCharacteristic characteristic = dfuService.getCharacteristic(DFU_CONTROL_POINT_UUID);
+		if (characteristic == null || characteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG) == null)
+			return false;
+		mControlPointCharacteristic = characteristic;
+		mPacketCharacteristic = dfuService.getCharacteristic(DFU_PACKET_UUID);
+		return mPacketCharacteristic != null;
+	}
+
+	@Override
+	public BaseCustomBluetoothCallback getGattCallback() {
+		return mBluetoothCallback;
+	}
+
+	@Override
+	protected UUID getControlPointCharacteristicUUID() {
+		return DFU_CONTROL_POINT_UUID;
+	}
+
+	@Override
+	protected UUID getPacketCharacteristicUUID() {
+		return DFU_PACKET_UUID;
+	}
+
+	@Override
+	protected UUID getDfuServiceUUID() {
+		return DFU_SERVICE_UUID;
+	}
+
+	@Override
+	public void performDfu(@NonNull final Intent intent)
+			throws DfuException, DeviceDisconnectedException, UploadAbortedException {
+		logw("Legacy DFU bootloader found");
+		mProgressInfo.setProgress(DfuBaseService.PROGRESS_STARTING);
+
+		// Let's request the MTU requested by the user. It may be that a lower MTU will be used.
+		if (intent.hasExtra(DfuBaseService.EXTRA_MTU) && Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+			final int requiredMtu = intent.getIntExtra(DfuBaseService.EXTRA_MTU, 517);
+			logi("Requesting MTU = " + requiredMtu);
+			requestMtu(requiredMtu);
+		}
+
+		// Add one second delay to avoid the traffic jam before the DFU mode is enabled
+		// Related:
+		//   issue:        https://github.com/NordicSemiconductor/Android-DFU-Library/issues/10
+		//   pull request: https://github.com/NordicSemiconductor/Android-DFU-Library/pull/12
+		mService.waitFor(1000);
+		// End
+
+		final BluetoothGatt gatt = mGatt;
+
+		/*
+		 * DFU Version characteristic has been read by the LegacyButtonlessDfuImpl#isClientCompatible(...) while determining implementation.
+		 * No need to read it again.
+		 */
+		final BluetoothGattCharacteristic versionCharacteristic = gatt.getService(DFU_SERVICE_UUID).getCharacteristic(DFU_VERSION_UUID); // this may be null for older versions of the Bootloader
+		final int version = readVersion(versionCharacteristic);
+
+		/*
+		 * If the DFU Version characteristic is present and the version returned from it is greater or equal to 0.5, the Extended Init Packet is required.
+		 * If the InputStream with init packet is null we may safely abort sending and reset the device as it would happen eventually in few moments.
+		 * The DFU target would send DFU INVALID STATE error if the init packet would not be sent before starting file transmission.
+		 */
+		if (version >= 5 && mInitPacketStream == null) {
+			logw("Init packet not set for the DFU Bootloader version " + version);
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_ERROR, "The Init packet is required by this version DFU Bootloader");
+			mService.terminateConnection(gatt, DfuBaseService.ERROR_INIT_PACKET_REQUIRED);
+			return;
+		}
+
+		try {
+			// Enable notifications
+			enableCCCD(mControlPointCharacteristic, NOTIFICATIONS);
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Notifications enabled");
+
+			// Wait a second here before going further
+			// Related:
+			//   pull request: https://github.com/NordicSemiconductor/Android-DFU-Library/pull/11
+			mService.waitFor(1000);
+			// End
+
+			// Set up the temporary variable that will hold the responses
+			byte[] response;
+			int status;
+
+			/*
+			 * The first version of DFU supported only an Application update.
+			 * Initializing procedure:
+			 * [DFU Start (0x01)] -> DFU Control Point
+			 * [App size in bytes (UINT32)] -> DFU Packet
+			 * ---------------------------------------------------------------------
+			 * Since SDK 6.0 and Soft Device 7.0+ the DFU supports upgrading Soft Device, Bootloader and Application.
+			 * Initializing procedure:
+			 * [DFU Start (0x01), <Update Mode>] -> DFU Control Point
+			 * [SD size in bytes (UINT32), Bootloader size in bytes (UINT32), Application size in bytes (UINT32)] -> DFU Packet
+			 * where <Upload Mode> is a bit mask:
+			 * 0x01 - Soft Device update
+			 * 0x02 - Bootloader update
+			 * 0x04 - Application update
+			 * so that
+			 * 0x03 - Soft Device and Bootloader update
+			 * If <Upload Mode> equals 5, 6 or 7 DFU target may return OPERATION_NOT_SUPPORTED [10, 01, 03]. In that case service will try to send
+			 * Soft Device and/or Bootloader first, reconnect to the new Bootloader and send the Application in the second connection.
+			 * --------------------------------------------------------------------
+			 * If DFU target supports only the old DFU, a response [10, 01, 03] will be send as a notification on DFU Control Point characteristic, where:
+			 * 10 - Response for...
+			 * 01 - DFU Start command
+			 * 03 - Operation Not Supported
+			 * (see table below)
+			 * In that case:
+			 * 1. If this is application update - service will try to upload using the old DFU protocol.
+			 * 2. In case of SD or BL update an error is returned.
+			 */
+
+			// Obtain size of image(s)
+			int fileType = mFileType;
+			int softDeviceImageSize = (fileType & DfuBaseService.TYPE_SOFT_DEVICE) > 0 ? mImageSizeInBytes : 0;
+			int bootloaderImageSize = (fileType & DfuBaseService.TYPE_BOOTLOADER) > 0 ? mImageSizeInBytes : 0;
+			int appImageSize = (fileType & DfuBaseService.TYPE_APPLICATION) > 0 ? mImageSizeInBytes : 0;
+			// The sizes above may be overwritten if a ZIP file was passed
+			if (mFirmwareStream instanceof ArchiveInputStream) {
+				final ArchiveInputStream zhis = (ArchiveInputStream) mFirmwareStream;
+				if (zhis.isSecureDfuRequired()) {
+					loge("Secure DFU is required to upload selected firmware");
+					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_ERROR, "The device does not support given firmware.");
+					logi("Sending Reset command (Op Code = 6)");
+					writeOpCode(mControlPointCharacteristic, OP_CODE_RESET);
+					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Reset request sent");
+					mService.terminateConnection(gatt, DfuBaseService.ERROR_FILE_INVALID);
+					return;
+				}
+				softDeviceImageSize = zhis.softDeviceImageSize();
+				bootloaderImageSize = zhis.bootloaderImageSize();
+				appImageSize = zhis.applicationImageSize();
+			}
+
+			boolean extendedInitPacketSupported = true;
+			try {
+				OP_CODE_START_DFU[1] = (byte) fileType;
+
+				// Send Start DFU command to Control Point
+				logi("Sending Start DFU command (Op Code = 1, Upload Mode = " + fileType + ")");
+				writeOpCode(mControlPointCharacteristic, OP_CODE_START_DFU);
+				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "DFU Start sent (Op Code = 1, Upload Mode = " + fileType + ")");
+
+				// Send image size in bytes to DFU Packet
+				logi("Sending image size array to DFU Packet (" + softDeviceImageSize + "b, " + bootloaderImageSize + "b, " + appImageSize + "b)");
+				writeImageSize(mPacketCharacteristic, softDeviceImageSize, bootloaderImageSize, appImageSize);
+				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Firmware image size sent (" + softDeviceImageSize + "b, " + bootloaderImageSize + "b, " + appImageSize + "b)");
+
+				// A notification will come with confirmation. Let's wait for it a bit
+				response = readNotificationResponse();
+
+				/*
+				 * The response received from the DFU device contains:
+				 * +---------+--------+----------------------------------------------------+
+				 * | byte no | value  | description                                        |
+				 * +---------+--------+----------------------------------------------------+
+				 * | 0       | 16     | Response code                                      |
+				 * | 1       | 1      | The Op Code of a request that this response is for |
+				 * | 2       | STATUS | Status code                                        |
+				 * +---------+--------+----------------------------------------------------+
+				 */
+				status = getStatusCode(response, OP_CODE_START_DFU_KEY);
+				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Response received (Op Code = " + response[1] + " Status = " + status + ")");
+
+				// If upload was not completed in the previous connection the INVALID_STATE status will be reported.
+				// Theoretically, the connection could be resumed from that point, but there is no guarantee, that the same firmware
+				// is to be uploaded now. It's safer to reset the device and start DFU again.
+				if (status == LegacyDfuError.INVALID_STATE) {
+					resetAndRestart(gatt, intent);
+					return;
+				}
+				if (status != DFU_STATUS_SUCCESS)
+					throw new RemoteDfuException("Starting DFU failed", status);
+			} catch (final RemoteDfuException e) {
+				try {
+					if (e.getErrorNumber() != LegacyDfuError.NOT_SUPPORTED)
+						throw e;
+
+					// If user wants to send the Soft Device and/or the Bootloader + Application we may try to send the Soft Device/Bootloader files first,
+					// and then reconnect and send the application in the second connection.
+					if ((fileType & DfuBaseService.TYPE_APPLICATION) > 0 && (fileType & (DfuBaseService.TYPE_SOFT_DEVICE | DfuBaseService.TYPE_BOOTLOADER)) > 0) {
+						// Clear the remote error flag
+						mRemoteErrorOccurred = false;
+
+						logw("DFU target does not support (SD/BL)+App update");
+						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING, "DFU target does not support (SD/BL)+App update");
+
+						fileType &= ~DfuBaseService.TYPE_APPLICATION; // clear application bit
+						mFileType = fileType;
+						OP_CODE_START_DFU[1] = (byte) fileType;
+						mProgressInfo.setTotalPart(2);
+
+						// Set new content type in the ZIP Input Stream and update sizes of images
+						final ArchiveInputStream zhis = (ArchiveInputStream) mFirmwareStream;
+						zhis.setContentType(fileType);
+						appImageSize = 0;
+
+						// Send Start DFU command to Control Point
+						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Sending only SD/BL");
+						logi("Resending Start DFU command (Op Code = 1, Upload Mode = " + fileType + ")");
+						writeOpCode(mControlPointCharacteristic, OP_CODE_START_DFU);
+						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "DFU Start sent (Op Code = 1, Upload Mode = " + fileType + ")");
+
+						// Send image size in bytes to DFU Packet
+						logi("Sending image size array to DFU Packet: [" + softDeviceImageSize + "b, " + bootloaderImageSize + "b, " + appImageSize + "b]");
+						writeImageSize(mPacketCharacteristic, softDeviceImageSize, bootloaderImageSize, appImageSize);
+						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Firmware image size sent [" + softDeviceImageSize + "b, " + bootloaderImageSize + "b, " + appImageSize + "b]");
+
+						// A notification will come with confirmation. Let's wait for it a bit
+						response = readNotificationResponse();
+						status = getStatusCode(response, OP_CODE_START_DFU_KEY);
+						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Response received (Op Code = " + response[1] + " Status = " + status + ")");
+
+						// If upload was not completed in the previous connection the INVALID_STATE status will be reported.
+						// Theoretically, the connection could be resumed from that point, but there is no guarantee, that the same firmware
+						// is to be uploaded now. It's safer to reset the device and start DFU again.
+						if (status == LegacyDfuError.INVALID_STATE) {
+							resetAndRestart(gatt, intent);
+							return;
+						}
+						if (status != DFU_STATUS_SUCCESS)
+							throw new RemoteDfuException("Starting DFU failed", status);
+					} else
+						throw e;
+				} catch (final RemoteDfuException e1) {
+					if (e1.getErrorNumber() != LegacyDfuError.NOT_SUPPORTED)
+						throw e1;
+
+					// If operation is not supported by DFU target we may try to upload application with legacy mode, using the old DFU protocol
+					if (fileType == DfuBaseService.TYPE_APPLICATION) {
+						// Clear the remote error flag
+						mRemoteErrorOccurred = false;
+						extendedInitPacketSupported = false;
+
+						// The DFU target does not support DFU v.2 protocol
+						logw("DFU target does not support DFU v.2");
+						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING, "DFU target does not support DFU v.2");
+
+						// Send Start DFU command to Control Point
+						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Switching to DFU v.1");
+						logi("Resending Start DFU command (Op Code = 1)");
+						writeOpCode(mControlPointCharacteristic, OP_CODE_START_DFU_V1);
+						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "DFU Start sent (Op Code = 1)");
+
+						// Send image size in bytes to DFU Packet
+						logi("Sending application image size to DFU Packet: " + mImageSizeInBytes + " bytes");
+						writeImageSize(mPacketCharacteristic, mImageSizeInBytes);
+						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Firmware image size sent (" + mImageSizeInBytes + " bytes)");
+
+						// A notification will come with confirmation. Let's wait for it a bit
+						response = readNotificationResponse();
+						status = getStatusCode(response, OP_CODE_START_DFU_KEY);
+						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Response received (Op Code = " + response[1] + ", Status = " + status + ")");
+
+						// If upload was not completed in the previous connection the INVALID_STATE status will be reported.
+						// Theoretically, the connection could be resumed from that point, but there is no guarantee, that the same firmware
+						// is to be uploaded now. It's safer to reset the device and start DFU again.
+						if (status == LegacyDfuError.INVALID_STATE) {
+							resetAndRestart(gatt, intent);
+							return;
+						}
+						if (status != DFU_STATUS_SUCCESS)
+							throw new RemoteDfuException("Starting DFU failed", status);
+					} else
+						throw e1;
+				}
+			}
+
+			/*
+			 * If the DFU Version characteristic is present and the version returned from it is greater or equal to 0.5, the Extended Init Packet is required.
+			 * For older versions, or if the DFU Version characteristic is not present (pre SDK 7.0.0), the Init Packet (which could have contained only the firmware CRC) was optional.
+			 * Deprecated: To calculate the CRC (CRC-CCTII-16 0xFFFF) the following application may be used: http://www.lammertbies.nl/comm/software/index.html -> CRC library.
+			 * New: To calculate the CRC (CRC-CCTII-16 0xFFFF) the 'nrf utility' may be used (see below).
+			 *
+			 * The Init Packet is read from the *.dat file as a binary file. This service you allows to specify the init packet file in two ways.
+			 * Since SDK 8.0 and the DFU Library v0.6 using the Distribution packet (ZIP) is recommended. The distribution packet can be created using the
+			 * *nrf utility* tool, available together with Master Control Panel v 3.8.0+. See the DFU documentation at http://developer.nordicsemi.com for more details.
+			 * An init file may be also provided as a separate file using the {@link #EXTRA_INIT_FILE_PATH} or {@link #EXTRA_INIT_FILE_URI} or in the ZIP file
+			 * with the deprecated fixed naming convention:
+			 *
+			 *    a) If the ZIP file contain a softdevice.hex (or .bin) and/or bootloader.hex (or .bin) the 'system.dat' must also be included.
+			 *       In case when both files are present the CRC should be calculated from the two BIN contents merged together.
+			 *       This means: if there are softdevice.hex and bootloader.hex files in the ZIP file you have to convert them to BIN
+			 *       (e.g. using: http://hex2bin.sourceforge.net/ application), copy them into a single file where the soft device is placed as the first one and calculate
+			 *       the CRC for the whole file.
+			 *
+			 *    b) If the ZIP file contains a application.hex (or .bin) file the 'application.dat' file must be included and contain the Init packet for the application.
+			 */
+			// Send DFU Init Packet
+			if (mInitPacketStream != null) {
+				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Writing Initialize DFU Parameters...");
+
+				if (extendedInitPacketSupported) {
+					logi("Sending the Initialize DFU Parameters START (Op Code = 2, Value = 0)");
+					writeOpCode(mControlPointCharacteristic, OP_CODE_INIT_DFU_PARAMS_START);
+
+					logi("Sending " + mInitPacketSizeInBytes + " bytes of init packet");
+					writeInitData(mPacketCharacteristic, null);
+
+					logi("Sending the Initialize DFU Parameters COMPLETE (Op Code = 2, Value = 1)");
+					writeOpCode(mControlPointCharacteristic, OP_CODE_INIT_DFU_PARAMS_COMPLETE);
+					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Initialize DFU Parameters completed");
+				} else {
+					// In SDK 4.3 - 6.0.0 the Init Packet could have had only 2 bytes - the CRC16. START-STOP commands were not supported,
+					// instead there was just a single command 0x02, followed by a write to DFU Packet after which the device was sending a response.
+					logi("Sending the Initialize DFU Parameters (Op Code = 2)");
+					writeOpCode(mControlPointCharacteristic, OP_CODE_INIT_DFU_PARAMS);
+
+					logi("Sending " + mInitPacketSizeInBytes + " bytes of init packet");
+					writeInitData(mPacketCharacteristic, null);
+				}
+
+				// A notification will come with confirmation. Let's wait for it a bit
+				response = readNotificationResponse();
+				status = getStatusCode(response, OP_CODE_INIT_DFU_PARAMS_KEY);
+				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Response received (Op Code = " + response[1] + ", Status = " + status + ")");
+				if (status != DFU_STATUS_SUCCESS)
+					throw new RemoteDfuException("Device returned error after sending init packet", status);
+			}
+
+			// Send the number of packets of firmware before receiving a receipt notification
+			// Note: DFU bootloaders from SDK 6.0.0 or older were unable to save incoming data to the flash memory with the same speed
+			//       as they are being sent from modern devices, therefore the PRNs are here force-enabled for them.
+			//       It has been tested that PRN = 10 may be the highest supported value.
+			final int numberOfPacketsBeforeNotification = extendedInitPacketSupported || (mPacketsBeforeNotification > 0 && mPacketsBeforeNotification <= 10) ? mPacketsBeforeNotification : 10;
+			if (numberOfPacketsBeforeNotification > 0) {
+				mPacketsBeforeNotification = numberOfPacketsBeforeNotification;
+				logi("Sending the number of packets before notifications (Op Code = 8, Value = " + numberOfPacketsBeforeNotification + ")");
+				setNumberOfPackets(OP_CODE_PACKET_RECEIPT_NOTIF_REQ, numberOfPacketsBeforeNotification);
+				writeOpCode(mControlPointCharacteristic, OP_CODE_PACKET_RECEIPT_NOTIF_REQ);
+				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Packet Receipt Notif Req (Op Code = 8) sent (Value = " + numberOfPacketsBeforeNotification + ")");
+			}
+
+			// Initialize firmware upload
+			logi("Sending Receive Firmware Image request (Op Code = 3)");
+			writeOpCode(mControlPointCharacteristic, OP_CODE_RECEIVE_FIRMWARE_IMAGE);
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Receive Firmware Image request sent");
+
+			// Send the firmware. The method below sends the first packet and waits until the whole firmware is sent.
+			final long startTime = SystemClock.elapsedRealtime();
+			mProgressInfo.setBytesSent(0);
+			try {
+				logi("Uploading firmware...");
+				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Uploading firmware...");
+				uploadFirmwareImage(mPacketCharacteristic);
+			} catch (final DeviceDisconnectedException e) {
+				loge("Disconnected while sending data");
+				throw e;
+			}
+			final long endTime = SystemClock.elapsedRealtime();
+
+			// Check the result of the operation
+			response = readNotificationResponse();
+			status = getStatusCode(response, OP_CODE_RECEIVE_FIRMWARE_IMAGE_KEY);
+			logi("Response received (Op Code = " + response[0] + ", Req Op Code = " + response[1] + ", Status = " + response[2] + ")");
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Response received (Op Code = " + response[1] + ", Status = " + status + ")");
+			if (status != DFU_STATUS_SUCCESS)
+				throw new RemoteDfuException("Device returned error after sending file", status);
+
+			logi("Transfer of " + mProgressInfo.getBytesSent() + " bytes has taken " + (endTime - startTime) + " ms");
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Upload completed in " + (endTime - startTime) + " ms");
+
+			// Send Validate request
+			logi("Sending Validate request (Op Code = 4)");
+			writeOpCode(mControlPointCharacteristic, OP_CODE_VALIDATE);
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Validate request sent");
+
+			// A notification will come with status code. Let's wait for it a bit.
+			response = readNotificationResponse();
+			status = getStatusCode(response, OP_CODE_VALIDATE_KEY);
+			logi("Response received (Op Code = " + response[0] + ", Req Op Code = " + response[1] + ", Status = " + response[2] + ")");
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Response received (Op Code = " + response[1] + ", Status = " + status + ")");
+			if (status != DFU_STATUS_SUCCESS)
+				throw new RemoteDfuException("Device returned validation error", status);
+
+			// Send Activate and Reset signal.
+			mProgressInfo.setProgress(DfuBaseService.PROGRESS_DISCONNECTING);
+			logi("Sending Activate and Reset request (Op Code = 5)");
+			writeOpCode(mControlPointCharacteristic, OP_CODE_ACTIVATE_AND_RESET);
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Activate and Reset request sent");
+
+			// The device will reset so we don't have to send Disconnect signal.
+			mService.waitUntilDisconnected();
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO, "Disconnected by the remote device");
+
+			// We are ready with DFU, the device is disconnected, let's close it and finalize the operation.
+
+			// In the DFU version 0.5, in case the device is bonded, the target device does not send the Service Changed indication after
+			// a jump from bootloader mode to app mode. This issue has been fixed in DFU version 0.6 (SDK 8.0). If the DFU bootloader has been
+			// configured to preserve the bond information we do not need to enforce refreshing services, as it will notify the phone using the
+			// Service Changed indication.
+			finalize(intent, version == 5);
+		} catch (final UploadAbortedException e) {
+			logi("Sending Reset command (Op Code = 6)");
+			mAborted = false; // clear the flag, otherwise the writeOpCode method will not wait until the device disconnects
+			writeOpCode(mControlPointCharacteristic, OP_CODE_RESET);
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Reset request sent");
+			// The connection will be terminated in the DfuBaseService
+			throw e;
+		} catch (final UnknownResponseException e) {
+			final int error = DfuBaseService.ERROR_INVALID_RESPONSE;
+			loge(e.getMessage());
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_ERROR, e.getMessage());
+
+			logi("Sending Reset command (Op Code = 6)");
+			writeOpCode(mControlPointCharacteristic, OP_CODE_RESET);
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Reset request sent");
+			mService.terminateConnection(gatt, error);
+		} catch (final RemoteDfuException e) {
+			final int error = DfuBaseService.ERROR_REMOTE_TYPE_LEGACY | e.getErrorNumber();
+			loge(e.getMessage() + ": " + LegacyDfuError.parse(error));
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_ERROR, String.format(Locale.US, "Remote DFU error: %s", LegacyDfuError.parse(error)));
+
+			logi("Sending Reset command (Op Code = 6)");
+			writeOpCode(mControlPointCharacteristic, OP_CODE_RESET);
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Reset request sent");
+			mService.terminateConnection(gatt, error | DfuBaseService.ERROR_REMOTE_MASK);
+		}
+	}
+
+	/**
+	 * Sets number of data packets that will be send before the notification will be received.
+	 *
+	 * @param data  control point data packet.
+	 * @param value number of packets before receiving notification.
+	 *              If this value is 0, then the notification of packet receipt will be disabled
+	 *              by the DFU target.
+	 */
+	@SuppressWarnings("SameParameterValue")
+	private void setNumberOfPackets(@NonNull final byte[] data, final int value) {
+		data[1] = (byte) (value & 0xFF);
+		data[2] = (byte) ((value >> 8) & 0xFF);
+	}
+
+	/**
+	 * Checks whether the response received is valid and returns the status code.
+	 *
+	 * @param response the response received from the DFU device.
+	 * @param request  the expected Op Code.
+	 * @return The status code.
+	 * @throws UnknownResponseException if response was not valid.
+	 */
+	private int getStatusCode(@Nullable final byte[] response, final int request)
+			throws UnknownResponseException {
+		if (response == null || response.length != 3 || response[0] != OP_CODE_RESPONSE_CODE_KEY ||
+				response[1] != request || response[2] < 1 || response[2] > 6)
+			throw new UnknownResponseException("Invalid response received", response, OP_CODE_RESPONSE_CODE_KEY, request);
+		return response[2];
+	}
+
+	/**
+	 * Returns the DFU Version characteristic if such exists. Otherwise it returns 0.
+	 *
+	 * @param characteristic the characteristic to read.
+	 * @return a version number or 0 if not present on the bootloader.
+	 */
+	private int readVersion(@Nullable final BluetoothGattCharacteristic characteristic) {
+		// The value of this characteristic has been read before by LegacyButtonlessDfuImpl
+		return characteristic != null ? characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT16, 0) : 0;
+	}
+
+	/**
+	 * Writes the operation code to the characteristic. This method is SYNCHRONOUS and wait until the
+	 * {@link android.bluetooth.BluetoothGattCallback#onCharacteristicWrite(android.bluetooth.BluetoothGatt, android.bluetooth.BluetoothGattCharacteristic, int)}
+	 * will be called or the device gets disconnected.
+	 * If connection state will change, or an error will occur, an exception will be thrown.
+	 *
+	 * @param characteristic the characteristic to write to. Should be the DFU CONTROL POINT.
+	 * @param value          the value to write to the characteristic.
+	 * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of
+	 *                                     the transmission.
+	 * @throws DfuException                Thrown if DFU error occur.
+	 * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
+	 */
+	private void writeOpCode(@NonNull final BluetoothGattCharacteristic characteristic, @NonNull final byte[] value)
+			throws DeviceDisconnectedException, DfuException, UploadAbortedException {
+		final boolean reset = value[0] == OP_CODE_RESET_KEY || value[0] == OP_CODE_ACTIVATE_AND_RESET_KEY;
+		writeOpCode(characteristic, value, reset);
+	}
+
+	/**
+	 * Writes the image size to the characteristic. This method is SYNCHRONOUS and wait until the
+	 * {@link android.bluetooth.BluetoothGattCallback#onCharacteristicWrite(android.bluetooth.BluetoothGatt, android.bluetooth.BluetoothGattCharacteristic, int)}
+	 * will be called or the device gets disconnected. If connection state will change, or an
+	 * error will occur, an exception will be thrown.
+	 *
+	 * @param characteristic the characteristic to write to. Should be the DFU PACKET.
+	 * @param imageSize      the image size in bytes.
+	 * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of
+	 *                                     the transmission.
+	 * @throws DfuException                Thrown if DFU error occur.
+	 * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
+	 */
+	private void writeImageSize(@NonNull final BluetoothGattCharacteristic characteristic, final int imageSize)
+			throws DeviceDisconnectedException, DfuException,
+			UploadAbortedException {
+		mReceivedData = null;
+		mError = 0;
+		mImageSizeInProgress = true;
+
+		characteristic.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE);
+		characteristic.setValue(new byte[4]);
+		characteristic.setValue(imageSize, BluetoothGattCharacteristic.FORMAT_UINT32, 0);
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Writing to characteristic " + characteristic.getUuid());
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_DEBUG, "gatt.writeCharacteristic(" + characteristic.getUuid() + ")");
+		mGatt.writeCharacteristic(characteristic);
+
+		// We have to wait for confirmation
+		try {
+			synchronized (mLock) {
+				while ((mImageSizeInProgress && mConnected && mError == 0 && !mAborted) || mPaused)
+					mLock.wait();
+			}
+		} catch (final InterruptedException e) {
+			loge("Sleeping interrupted", e);
+		}
+		if (mAborted)
+			throw new UploadAbortedException();
+		if (!mConnected)
+			throw new DeviceDisconnectedException("Unable to write Image Size: device disconnected");
+		if (mError != 0)
+			throw new DfuException("Unable to write Image Size", mError);
+	}
+
+	/**
+	 * <p>
+	 * Writes the Soft Device, Bootloader and Application image sizes to the characteristic.
+	 * Soft Device and Bootloader update is supported since Soft Device s110 v7.0.0.
+	 * Sizes of SD, BL and App are uploaded as 3x UINT32 even though some of them may be 0s.
+	 * E.g. if only App is being updated the data will be <0x00000000, 0x00000000, [App size]>
+	 * <p>
+	 * This method is SYNCHRONOUS and wait until the
+	 * {@link android.bluetooth.BluetoothGattCallback#onCharacteristicWrite(android.bluetooth.BluetoothGatt, android.bluetooth.BluetoothGattCharacteristic, int)}
+	 * will be called or the device gets disconnected. If connection state will change, or an
+	 * error will occur, an exception will be thrown.
+	 *
+	 * @param characteristic      the characteristic to write to. Should be the DFU PACKET.
+	 * @param softDeviceImageSize the Soft Device image size in bytes.
+	 * @param bootloaderImageSize the Bootloader image size in bytes.
+	 * @param appImageSize        the Application image size in bytes.
+	 * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of
+	 *                                     the transmission.
+	 * @throws DfuException                Thrown if DFU error occur.
+	 * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
+	 */
+	private void writeImageSize(@NonNull final BluetoothGattCharacteristic characteristic,
+								final int softDeviceImageSize, final int bootloaderImageSize, final int appImageSize)
+			throws DeviceDisconnectedException, DfuException, UploadAbortedException {
+		mReceivedData = null;
+		mError = 0;
+		mImageSizeInProgress = true;
+
+		characteristic.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE);
+		characteristic.setValue(new byte[12]);
+		characteristic.setValue(softDeviceImageSize, BluetoothGattCharacteristic.FORMAT_UINT32, 0);
+		characteristic.setValue(bootloaderImageSize, BluetoothGattCharacteristic.FORMAT_UINT32, 4);
+		characteristic.setValue(appImageSize, BluetoothGattCharacteristic.FORMAT_UINT32, 8);
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Writing to characteristic " + characteristic.getUuid());
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_DEBUG, "gatt.writeCharacteristic(" + characteristic.getUuid() + ")");
+		mGatt.writeCharacteristic(characteristic);
+
+		// We have to wait for confirmation
+		try {
+			synchronized (mLock) {
+				while ((mImageSizeInProgress && mConnected && mError == 0 && !mAborted) || mPaused)
+					mLock.wait();
+			}
+		} catch (final InterruptedException e) {
+			loge("Sleeping interrupted", e);
+		}
+		if (mAborted)
+			throw new UploadAbortedException();
+		if (!mConnected)
+			throw new DeviceDisconnectedException("Unable to write Image Sizes: device disconnected");
+		if (mError != 0)
+			throw new DfuException("Unable to write Image Sizes", mError);
+	}
+
+	/**
+	 * Sends Reset command to the target device to reset its state and restarts the DFU Service that will start again.
+	 *
+	 * @param gatt the GATT device.
+	 * @param intent intent used to start the service.
+	 * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of
+	 *                                     the transmission.
+	 * @throws DfuException                Thrown if DFU error occur.
+	 * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
+	 */
+	private void resetAndRestart(@NonNull final BluetoothGatt gatt, @NonNull final Intent intent)
+			throws DfuException, DeviceDisconnectedException, UploadAbortedException {
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING, "Last upload interrupted. Restarting device...");
+		// Send 'jump to bootloader command' (Start DFU)
+		mProgressInfo.setProgress(DfuBaseService.PROGRESS_DISCONNECTING);
+		logi("Sending Reset command (Op Code = 6)");
+		writeOpCode(mControlPointCharacteristic, OP_CODE_RESET);
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Reset request sent");
+
+		// The device will reset so we don't have to send Disconnect signal.
+		mService.waitUntilDisconnected();
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO, "Disconnected by the remote device");
+
+		final BluetoothGattService gas = gatt.getService(GENERIC_ATTRIBUTE_SERVICE_UUID);
+		final boolean hasServiceChanged = gas != null && gas.getCharacteristic(SERVICE_CHANGED_UUID) != null;
+		mService.refreshDeviceCache(gatt, !hasServiceChanged);
+
+		// Close the device
+		mService.close(gatt);
+
+		logi("Restarting the service");
+		final Intent newIntent = new Intent();
+		newIntent.fillIn(intent, Intent.FILL_IN_COMPONENT | Intent.FILL_IN_PACKAGE);
+		restartService(newIntent, false);
+	}
+}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/SecureDfuImpl.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/SecureDfuImpl.java
new file mode 100644
index 0000000..fb57e75
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/SecureDfuImpl.java
@@ -0,0 +1,1012 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.dfu;
+
+import android.bluetooth.BluetoothGatt;
+import android.bluetooth.BluetoothGattCharacteristic;
+import android.bluetooth.BluetoothGattService;
+import android.content.Intent;
+import android.os.Build;
+import android.os.SystemClock;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Locale;
+import java.util.UUID;
+import java.util.zip.CRC32;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import no.nordicsemi.android.dfu.internal.ArchiveInputStream;
+import no.nordicsemi.android.dfu.internal.exception.DeviceDisconnectedException;
+import no.nordicsemi.android.dfu.internal.exception.DfuException;
+import no.nordicsemi.android.dfu.internal.exception.RemoteDfuException;
+import no.nordicsemi.android.dfu.internal.exception.RemoteDfuExtendedErrorException;
+import no.nordicsemi.android.dfu.internal.exception.UnknownResponseException;
+import no.nordicsemi.android.dfu.internal.exception.UploadAbortedException;
+import no.nordicsemi.android.error.SecureDfuError;
+
+/* package */
+@SuppressWarnings("JavaDoc")
+class SecureDfuImpl extends BaseCustomDfuImpl {
+	// UUIDs used by the DFU
+	static final UUID DEFAULT_DFU_SERVICE_UUID       = new UUID(0x0000FE5900001000L, 0x800000805F9B34FBL); // 16-bit UUID assigned by Bluetooth SIG
+	static final UUID DEFAULT_DFU_CONTROL_POINT_UUID = new UUID(0x8EC90001F3154F60L, 0x9FB8838830DAEA50L);
+	static final UUID DEFAULT_DFU_PACKET_UUID        = new UUID(0x8EC90002F3154F60L, 0x9FB8838830DAEA50L);
+
+	static UUID DFU_SERVICE_UUID       = DEFAULT_DFU_SERVICE_UUID;
+	static UUID DFU_CONTROL_POINT_UUID = DEFAULT_DFU_CONTROL_POINT_UUID;
+	static UUID DFU_PACKET_UUID        = DEFAULT_DFU_PACKET_UUID;
+
+	private static final int DFU_STATUS_SUCCESS = 1;
+	private static final int MAX_ATTEMPTS = 3;
+
+	// Object types
+	private static final int OBJECT_COMMAND = 0x01;
+	private static final int OBJECT_DATA = 0x02;
+	// Operation codes and packets
+	private static final int OP_CODE_CREATE_KEY = 0x01;
+	private static final int OP_CODE_PACKET_RECEIPT_NOTIF_REQ_KEY = 0x02;
+	private static final int OP_CODE_CALCULATE_CHECKSUM_KEY = 0x03;
+	private static final int OP_CODE_EXECUTE_KEY = 0x04;
+	private static final int OP_CODE_SELECT_OBJECT_KEY = 0x06;
+	private static final int OP_CODE_RESPONSE_CODE_KEY = 0x60;
+	private static final byte[] OP_CODE_CREATE_COMMAND = new byte[]{OP_CODE_CREATE_KEY, OBJECT_COMMAND, 0x00, 0x00, 0x00, 0x00 };
+	private static final byte[] OP_CODE_CREATE_DATA = new byte[]{OP_CODE_CREATE_KEY, OBJECT_DATA, 0x00, 0x00, 0x00, 0x00};
+	private static final byte[] OP_CODE_PACKET_RECEIPT_NOTIF_REQ = new byte[]{OP_CODE_PACKET_RECEIPT_NOTIF_REQ_KEY, 0x00, 0x00 /* param PRN uint16 in Little Endian */};
+	private static final byte[] OP_CODE_CALCULATE_CHECKSUM = new byte[]{OP_CODE_CALCULATE_CHECKSUM_KEY};
+	private static final byte[] OP_CODE_EXECUTE = new byte[]{OP_CODE_EXECUTE_KEY};
+	private static final byte[] OP_CODE_SELECT_OBJECT = new byte[]{OP_CODE_SELECT_OBJECT_KEY, 0x00 /* type */};
+
+	private BluetoothGattCharacteristic mControlPointCharacteristic;
+	private BluetoothGattCharacteristic mPacketCharacteristic;
+
+	private long prepareObjectDelay;
+
+	private final SecureBluetoothCallback mBluetoothCallback = new SecureBluetoothCallback();
+
+	protected class SecureBluetoothCallback extends BaseCustomBluetoothCallback {
+
+		@Override
+		public void onCharacteristicChanged(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic) {
+			if (characteristic.getValue() == null || characteristic.getValue().length < 3) {
+				loge("Empty response: " + parse(characteristic));
+				mError = DfuBaseService.ERROR_INVALID_RESPONSE;
+				notifyLock();
+				return;
+			}
+
+			final int responseType = characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT8, 0);
+
+			// The first byte should always be the response code
+			if (responseType == OP_CODE_RESPONSE_CODE_KEY) {
+				final int requestType = characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT8, 1);
+
+				//noinspection SwitchStatementWithTooFewBranches
+				switch (requestType) {
+					case OP_CODE_CALCULATE_CHECKSUM_KEY: {
+						final int offset = characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT32, 3);
+						final int remoteCrc = characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT32, 3 + 4);
+						final int localCrc = (int) (((ArchiveInputStream) mFirmwareStream).getCrc32() & 0xFFFFFFFFL);
+						// Check whether local and remote CRC match
+						if (localCrc == remoteCrc) {
+							// If so, update the number of bytes received
+							mProgressInfo.setBytesReceived(offset);
+						} else {
+							// Else, and only in case it was a PRN received, not the response for
+                            // Calculate Checksum Request, stop sending data
+							if (mFirmwareUploadInProgress) {
+								mFirmwareUploadInProgress = false;
+								notifyLock();
+								return;
+							} // else will be handled by sendFirmware(gatt) below
+						}
+						handlePacketReceiptNotification(gatt, characteristic);
+						break;
+					}
+					default: {
+						/*
+						 * If the DFU target device is in invalid state (e.g. the Init Packet is
+						 * required but has not been selected), the target will send
+						 * DFU_STATUS_INVALID_STATE error for each firmware packet that was send.
+						 * We are interested may ignore all but the first one.
+						 */
+						if (mRemoteErrorOccurred)
+							break;
+						final int status = characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT8, 2);
+						if (status != DFU_STATUS_SUCCESS)
+							mRemoteErrorOccurred = true;
+
+						handleNotification(gatt, characteristic);
+						break;
+					}
+				}
+			} else {
+				loge("Invalid response: " + parse(characteristic));
+				mError = DfuBaseService.ERROR_INVALID_RESPONSE;
+			}
+			notifyLock();
+		}
+	}
+
+	SecureDfuImpl(@NonNull final Intent intent, @NonNull final DfuBaseService service) {
+		super(intent, service);
+	}
+
+	@Override
+	public boolean isClientCompatible(@NonNull final Intent intent, @NonNull final BluetoothGatt gatt) {
+		final BluetoothGattService dfuService = gatt.getService(DFU_SERVICE_UUID);
+		if (dfuService == null)
+			return false;
+		final BluetoothGattCharacteristic characteristic = dfuService.getCharacteristic(DFU_CONTROL_POINT_UUID);
+		if (characteristic == null || characteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG) == null)
+			return false;
+		mControlPointCharacteristic = characteristic;
+		mPacketCharacteristic = dfuService.getCharacteristic(DFU_PACKET_UUID);
+		return mPacketCharacteristic != null;
+	}
+
+	@Override
+	public boolean initialize(@NonNull final Intent intent, @NonNull final BluetoothGatt gatt,
+							  @FileType final int fileType,
+							  @NonNull final InputStream firmwareStream,
+							  @Nullable final InputStream initPacketStream)
+			throws DfuException, DeviceDisconnectedException, UploadAbortedException {
+		if (initPacketStream == null) {
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_ERROR,
+                    "The Init packet is required by this version DFU Bootloader");
+			mService.terminateConnection(gatt, DfuBaseService.ERROR_INIT_PACKET_REQUIRED);
+			return false;
+		}
+
+		return super.initialize(intent, gatt, fileType, firmwareStream, initPacketStream);
+	}
+
+	@Override
+	public BaseBluetoothGattCallback getGattCallback() {
+		return mBluetoothCallback;
+	}
+
+	@Override
+	protected UUID getControlPointCharacteristicUUID() {
+		return DFU_CONTROL_POINT_UUID;
+	}
+
+	@Override
+	protected UUID getPacketCharacteristicUUID() {
+		return DFU_PACKET_UUID;
+	}
+
+	@Override
+	protected UUID getDfuServiceUUID() {
+		return DFU_SERVICE_UUID;
+	}
+
+	@Override
+	public void performDfu(@NonNull final Intent intent)
+			throws DfuException, DeviceDisconnectedException, UploadAbortedException {
+		logw("Secure DFU bootloader found");
+		mProgressInfo.setProgress(DfuBaseService.PROGRESS_STARTING);
+
+		// Add one second delay to avoid the traffic jam before the DFU mode is enabled
+		// Related:
+		//   issue:        https://github.com/NordicSemiconductor/Android-DFU-Library/issues/10
+		//   pull request: https://github.com/NordicSemiconductor/Android-DFU-Library/pull/12
+		mService.waitFor(1000);
+		// End
+
+		final BluetoothGatt gatt = mGatt;
+
+		// Secure DFU since SDK 15 supports higher MTUs.
+		// Let's request the MTU requested by the user. It may be that a lower MTU will be used.
+		if (intent.hasExtra(DfuBaseService.EXTRA_MTU) && Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+			final int requiredMtu = intent.getIntExtra(DfuBaseService.EXTRA_MTU, 517);
+			logi("Requesting MTU = " + requiredMtu);
+			requestMtu(requiredMtu);
+		}
+
+		prepareObjectDelay = intent.getLongExtra(DfuBaseService.EXTRA_DATA_OBJECT_DELAY, 0);
+
+		try {
+			// Enable notifications
+			enableCCCD(mControlPointCharacteristic, NOTIFICATIONS);
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION,
+                    "Notifications enabled");
+
+			// Wait a second here before going further
+			// Related:
+			//   pull request: https://github.com/NordicSemiconductor/Android-DFU-Library/pull/11
+			mService.waitFor(1000);
+			// End
+
+			final boolean allowResume = !intent.hasExtra(DfuBaseService.EXTRA_DISABLE_RESUME)
+					|| !intent.getBooleanExtra(DfuBaseService.EXTRA_DISABLE_RESUME, false);
+			if (!allowResume)
+				logi("Resume feature disabled. Performing fresh DFU");
+			try {
+				sendInitPacket(gatt, allowResume);
+			} catch (final RemoteDfuException e) {
+				// If the SD+BL upload failed, we may still be able to upload the App.
+				// The SD+BL might have been updated before.
+				if (!mProgressInfo.isLastPart()) {
+					mRemoteErrorOccurred = false;
+
+					logw("Sending SD+BL failed. Trying to send App only");
+					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING,
+                            "Invalid system components. Trying to send application");
+					mFileType = DfuBaseService.TYPE_APPLICATION;
+
+					// Set new content type in the ZIP Input Stream and update sizes of images
+					final ArchiveInputStream zhis = (ArchiveInputStream) mFirmwareStream;
+					zhis.setContentType(mFileType);
+					final byte[] applicationInit = zhis.getApplicationInit();
+					mInitPacketStream = new ByteArrayInputStream(applicationInit);
+					mInitPacketSizeInBytes = applicationInit.length;
+					mImageSizeInBytes = zhis.applicationImageSize();
+					mProgressInfo.init(mImageSizeInBytes, 2, 2);
+
+					sendInitPacket(gatt, false);
+				} else {
+					// There's noting we could do about it.
+					throw e;
+				}
+			}
+			sendFirmware(gatt);
+
+			// The device will reset so we don't have to send Disconnect signal.
+			mProgressInfo.setProgress(DfuBaseService.PROGRESS_DISCONNECTING);
+			mService.waitUntilDisconnected();
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO, "Disconnected by the remote device");
+
+			// We are ready with DFU, the device is disconnected, let's close it and finalize the operation.
+			finalize(intent, false);
+		} catch (@SuppressWarnings("CaughtExceptionImmediatelyRethrown") final UploadAbortedException e) {
+			// In secure DFU there is currently not possible to reset the device to application mode, so... do nothing
+			// The connection will be terminated in the DfuBaseService
+			throw e;
+		} catch (final UnknownResponseException e) {
+			final int error = DfuBaseService.ERROR_INVALID_RESPONSE;
+			loge(e.getMessage());
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_ERROR, e.getMessage());
+			mService.terminateConnection(gatt, error);
+		} catch (final RemoteDfuException e) {
+			final int error = DfuBaseService.ERROR_REMOTE_TYPE_SECURE | e.getErrorNumber();
+			loge(e.getMessage() + ": " + SecureDfuError.parse(error));
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_ERROR, String.format(Locale.US,
+                    "Remote DFU error: %s", SecureDfuError.parse(error)));
+
+			// For the Extended Error more details can be obtained on some devices.
+			if (e instanceof RemoteDfuExtendedErrorException) {
+				final RemoteDfuExtendedErrorException ee = (RemoteDfuExtendedErrorException) e;
+				final int extendedError = DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED | ee.getExtendedErrorNumber();
+				loge("Extended Error details: " + SecureDfuError.parseExtendedError(extendedError));
+				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_ERROR,
+                        "Details: " + SecureDfuError.parseExtendedError(extendedError) + " (Code = " + ee.getExtendedErrorNumber() + ")");
+				mService.terminateConnection(gatt, extendedError | DfuBaseService.ERROR_REMOTE_MASK);
+			} else {
+				mService.terminateConnection(gatt, error | DfuBaseService.ERROR_REMOTE_MASK);
+			}
+		}
+	}
+
+	/**
+	 * This method does the following:
+	 * <ol>
+	 *     <li>Selects the Command object - this Op Code returns the maximum acceptable size of a
+     *     command object, and the offset and CRC32 of the command that is already stored in the
+     *     device (in case the DFU was started in a previous connection and disconnected before
+     *     it has finished).</li>
+	 *     <li>If the offset received is greater than 0 and less or equal to the size of the
+     *     Init file that is to be sent, it will compare the
+	 *     received CRC with the local one and, if they match:
+	 *     	<ul>
+	 *     	    <li>If offset < init file size - it will continue sending the Init file from the
+     *     	    point it stopped before,</li>
+	 *     	    <li>If offset == init file size - it will send Execute command to execute the
+     *     	    Init file, as it may have not been executed before.</li>
+	 *     	</ul>
+	 *     </li>
+	 *     <li>If the CRC don't match, or the received offset is greater then init file size,
+     *     it creates the Command Object and sends the whole Init file as the previous one was
+     *     different.</li>
+	 * </ol>
+	 * Sending of the Init packet is done without using PRNs (Packet Receipt Notifications),
+     * so they are disabled prior to sending the data.
+	 *
+	 * @param gatt        the target GATT device.
+	 * @param allowResume true to allow resuming sending Init Packet. If false, it will be started
+     *                    again.
+	 * @throws RemoteDfuException
+	 * @throws DeviceDisconnectedException
+	 * @throws DfuException
+	 * @throws UploadAbortedException
+	 * @throws UnknownResponseException
+	 */
+	private void sendInitPacket(@NonNull final BluetoothGatt gatt, final boolean allowResume)
+			throws RemoteDfuException, DeviceDisconnectedException, DfuException, UploadAbortedException, UnknownResponseException {
+		final CRC32 crc32 = new CRC32(); // Used to calculate CRC32 of the Init packet
+		ObjectChecksum checksum;
+
+		// First, select the Command Object. As a response the maximum command size and information whether there is already
+		// a command saved from a previous connection is returned.
+		logi("Setting object to Command (Op Code = 6, Type = 1)");
+		final ObjectInfo info = selectObject(OBJECT_COMMAND);
+		logi(String.format(Locale.US, "Command object info received (Max size = %d, Offset = %d, CRC = %08X)", info.maxSize, info.offset, info.CRC32));
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, String.format(Locale.US, "Command object info received (Max size = %d, Offset = %d, CRC = %08X)", info.maxSize, info.offset, info.CRC32));
+		//noinspection StatementWithEmptyBody
+		if (mInitPacketSizeInBytes > info.maxSize) {
+			// Ignore this here. Later, after sending the 'Create object' command, DFU target will send an error if init packet is too large
+		}
+
+		// Can we resume? If the offset obtained from the device is greater then zero we can compare it with the local init packet CRC
+		// and resume sending the init packet, or even skip sending it if the whole file was sent before.
+		boolean skipSendingInitPacket = false;
+		boolean resumeSendingInitPacket = false;
+		if (allowResume && info.offset > 0 && info.offset <= mInitPacketSizeInBytes) {
+			try {
+				// Read the same number of bytes from the current init packet to calculate local CRC32
+				final byte[] buffer = new byte[info.offset];
+				//noinspection ResultOfMethodCallIgnored
+				mInitPacketStream.read(buffer);
+				// Calculate the CRC32
+				crc32.update(buffer);
+				final int crc = (int) (crc32.getValue() & 0xFFFFFFFFL);
+
+				if (info.CRC32 == crc) {
+					logi("Init packet CRC is the same");
+					if (info.offset ==  mInitPacketSizeInBytes) {
+						// The whole init packet was sent and it is equal to one we try to send now.
+						// There is no need to send it again. We may try to resume sending data.
+						logi("-> Whole Init packet was sent before");
+						skipSendingInitPacket = true;
+						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Received CRC match Init packet");
+					} else {
+						logi("-> " + info.offset + " bytes of Init packet were sent before");
+						resumeSendingInitPacket = true;
+						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Resuming sending Init packet...");
+					}
+				} else {
+					// A different Init packet was sent before, or the error occurred while sending.
+					// We have to send the whole Init packet again.
+					mInitPacketStream.reset();
+					crc32.reset();
+					info.offset = 0;
+				}
+			} catch (final IOException e) {
+				loge("Error while reading " + info.offset + " bytes from the init packet stream", e);
+				try {
+					// Go back to the beginning of the stream, we will send the whole init packet
+					mInitPacketStream.reset();
+					crc32.reset();
+					info.offset = 0;
+				} catch (final IOException e1) {
+					loge("Error while resetting the init packet stream", e1);
+					mService.terminateConnection(gatt, DfuBaseService.ERROR_FILE_IO_EXCEPTION);
+					return;
+				}
+			}
+		}
+
+		if (!skipSendingInitPacket) {
+			// The Init packet is sent different way in this implementation than the firmware, and receiving PRNs is not implemented.
+			// This value might have been stored on the device, so we have to explicitly disable PRNs.
+			setPacketReceiptNotifications(0);
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Packet Receipt Notif disabled (Op Code = 2, Value = 0)");
+
+			for (int attempt = 1; attempt <= MAX_ATTEMPTS;) {
+				if (!resumeSendingInitPacket) {
+					// Create the Init object
+					logi("Creating Init packet object (Op Code = 1, Type = 1, Size = " + mInitPacketSizeInBytes + ")");
+					writeCreateRequest(OBJECT_COMMAND, mInitPacketSizeInBytes);
+					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Command object created");
+				}
+				// Write Init data to the Packet Characteristic
+				try {
+					logi("Sending " + (mInitPacketSizeInBytes - info.offset) + " bytes of init packet...");
+					writeInitData(mPacketCharacteristic, crc32);
+				} catch (final DeviceDisconnectedException e) {
+					loge("Disconnected while sending init packet");
+					throw e;
+				}
+				final int crc = (int) (crc32.getValue() & 0xFFFFFFFFL);
+				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, String.format(Locale.US, "Command object sent (CRC = %08X)", crc));
+
+				// Calculate Checksum
+				logi("Sending Calculate Checksum command (Op Code = 3)");
+				checksum = readChecksum();
+				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, String.format(Locale.US, "Checksum received (Offset = %d, CRC = %08X)", checksum.offset, checksum.CRC32));
+				logi(String.format(Locale.US, "Checksum received (Offset = %d, CRC = %08X)", checksum.offset, checksum.CRC32));
+
+				if (crc == checksum.CRC32) {
+					// Everything is OK, we can proceed
+					break;
+				} else {
+					if (attempt < MAX_ATTEMPTS) {
+						attempt++;
+						logi("CRC does not match! Retrying...(" + attempt + "/" + MAX_ATTEMPTS + ")");
+						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING, "CRC does not match! Retrying...(" + attempt + "/" + MAX_ATTEMPTS + ")");
+						try {
+							// Go back to the beginning, we will send the whole Init packet again
+							resumeSendingInitPacket = false;
+							info.offset = 0;
+							info.CRC32 = 0;
+							mInitPacketStream.reset();
+							crc32.reset();
+						} catch (final IOException e) {
+							loge("Error while resetting the init packet stream", e);
+							mService.terminateConnection(gatt, DfuBaseService.ERROR_FILE_IO_EXCEPTION);
+							return;
+						}
+					} else {
+						loge("CRC does not match!");
+						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_ERROR, "CRC does not match!");
+						mService.terminateConnection(gatt, DfuBaseService.ERROR_CRC_ERROR);
+						return;
+					}
+				}
+			}
+		}
+
+		// Execute Init packet. It's better to execute it twice than not execute at all...
+		logi("Executing init packet (Op Code = 4)");
+		writeExecute();
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Command object executed");
+	}
+
+	/**
+	 * This method does the following:
+	 * <ol>
+	 *     <li>Sets the Packet Receipt Notification to a value specified in the settings.</li>
+	 *     <li>Selects the Data object - this returns maximum single object size and the offset
+     *     and CRC of the data already saved.</li>
+	 *     <li>If the offset received is greater than 0 it will calculate the CRC of the same
+     *     number of bytes of the firmware to be sent. If the CRC match it will continue sending data.
+     *     Otherwise, it will go back to the beginning of the last chunk, or to the beginning
+	 *     of the previous chunk assuming the last one was not executed before, and continue
+     *     sending data from there.</li>
+	 *     <li>If the CRC and offset received match and the offset is equal to the firmware size,
+     *     it will only send the Execute command.</li>
+	 * </ol>
+	 * @param gatt the target GATT device.
+	 * @throws RemoteDfuException
+	 * @throws DeviceDisconnectedException
+	 * @throws DfuException
+	 * @throws UploadAbortedException
+	 * @throws UnknownResponseException
+	 */
+	private void sendFirmware(final BluetoothGatt gatt) throws RemoteDfuException,
+            DeviceDisconnectedException, DfuException, UploadAbortedException, UnknownResponseException {
+		// Send the number of packets of firmware before receiving a receipt notification
+		int numberOfPacketsBeforeNotification = mPacketsBeforeNotification;
+		if (numberOfPacketsBeforeNotification > 0) {
+			setPacketReceiptNotifications(numberOfPacketsBeforeNotification);
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION,
+					"Packet Receipt Notif Req (Op Code = 2) sent (Value = " + numberOfPacketsBeforeNotification + ")");
+		}
+
+		// We are ready to start sending the new firmware.
+
+		logi("Setting object to Data (Op Code = 6, Type = 2)");
+		final ObjectInfo info = selectObject(OBJECT_DATA);
+		logi(String.format(Locale.US,
+				"Data object info received (Max size = %d, Offset = %d, CRC = %08X)", info.maxSize, info.offset, info.CRC32));
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, String.format(Locale.US,
+				"Data object info received (Max size = %d, Offset = %d, CRC = %08X)", info.maxSize, info.offset, info.CRC32));
+		mProgressInfo.setMaxObjectSizeInBytes(info.maxSize);
+
+		// Number of chunks in which the data will be sent
+		final int chunkCount = (mImageSizeInBytes + info.maxSize - 1) / info.maxSize;
+		int currentChunk = 0;
+		boolean resumeSendingData = false;
+
+		// Can we resume? If the offset obtained from the device is greater then zero we can compare it with the local CRC
+		// and resume sending the data.
+		if (info.offset > 0) {
+			try {
+				currentChunk = info.offset / info.maxSize;
+				int bytesSentAndExecuted = info.maxSize * currentChunk;
+				int bytesSentNotExecuted = info.offset - bytesSentAndExecuted;
+
+				// If the offset is dividable by maxSize, assume that the last page was not executed
+				if (bytesSentNotExecuted == 0) {
+					bytesSentAndExecuted -= info.maxSize;
+					bytesSentNotExecuted = info.maxSize;
+				}
+
+				// Read the same number of bytes from the current init packet to calculate local CRC32
+				if (bytesSentAndExecuted > 0) {
+					//noinspection ResultOfMethodCallIgnored
+					mFirmwareStream.read(new byte[bytesSentAndExecuted]); // Read executed bytes
+					mFirmwareStream.mark(info.maxSize); // Mark here
+				}
+				// Here the bytesSentNotExecuted is for sure greater then 0
+				//noinspection ResultOfMethodCallIgnored
+				mFirmwareStream.read(new byte[bytesSentNotExecuted]); // Read the rest
+
+				// Calculate the CRC32
+				final int crc = (int) (((ArchiveInputStream) mFirmwareStream).getCrc32() & 0xFFFFFFFFL);
+
+				if (crc == info.CRC32) {
+					logi(info.offset + " bytes of data sent before, CRC match");
+					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION,
+							info.offset + " bytes of data sent before, CRC match");
+					mProgressInfo.setBytesSent(info.offset);
+					mProgressInfo.setBytesReceived(info.offset);
+
+					// If the whole page was sent and CRC match, we have to make sure it was executed
+					if (bytesSentNotExecuted == info.maxSize && info.offset < mImageSizeInBytes) {
+						logi("Executing data object (Op Code = 4)");
+						try {
+							writeExecute();
+							mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Data object executed");
+						} catch (final RemoteDfuException e) {
+							// In DFU bootloader from SDK 15.x, 16 and 17 there's a bug, which
+							// prevents executing an object that has already been executed.
+							// See: https://github.com/NordicSemiconductor/Android-DFU-Library/issues/252
+							if (e.getErrorNumber() != SecureDfuError.OPERATION_NOT_PERMITTED) {
+								throw e;
+							}
+							mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Data object already executed");
+							// At this point, the error flag should be cleared, and the subsequent process can be executed normally.
+							mRemoteErrorOccurred = false;
+						}
+					} else {
+						resumeSendingData = true;
+					}
+				} else {
+					logi(info.offset + " bytes sent before, CRC does not match");
+					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING,
+							info.offset + " bytes sent before, CRC does not match");
+					// The CRC of the current object is not correct. If there was another Data object sent before, its CRC must have been correct,
+					// as it has been executed. Either way, we have to create the current object again.
+					mProgressInfo.setBytesSent(bytesSentAndExecuted);
+					mProgressInfo.setBytesReceived(bytesSentAndExecuted);
+					info.offset -= bytesSentNotExecuted;
+					info.CRC32 = 0; // invalidate
+					mFirmwareStream.reset();
+					logi("Resuming from byte " + info.offset + "...");
+					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION,
+							"Resuming from byte " + info.offset + "...");
+				}
+			} catch (final IOException e) {
+				loge("Error while reading firmware stream", e);
+				mService.terminateConnection(gatt, DfuBaseService.ERROR_FILE_IO_EXCEPTION);
+				return;
+			}
+		} else {
+			// Initialize the timer used to calculate the transfer speed
+			mProgressInfo.setBytesSent(0);
+		}
+
+		final long startTime = SystemClock.elapsedRealtime();
+
+		if (info.offset < mImageSizeInBytes) {
+			int attempt = 1;
+			// Each page will be sent in MAX_ATTEMPTS
+			while (mProgressInfo.getAvailableObjectSizeIsBytes() > 0) {
+				if (!resumeSendingData) {
+					// Create the Data object
+					final int availableObjectSizeInBytes = mProgressInfo.getAvailableObjectSizeIsBytes();
+					logi("Creating Data object (Op Code = 1, Type = 2, Size = " + availableObjectSizeInBytes + ") (" + (currentChunk + 1) + "/" + chunkCount + ")");
+					writeCreateRequest(OBJECT_DATA, availableObjectSizeInBytes);
+					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION,
+                            "Data object (" + (currentChunk + 1) + "/" + chunkCount + ") created");
+					// Waiting until the device is ready to receive the data object.
+					// If prepare data object delay was set in the initiator, the delay will be used
+					// for all data objects.
+					if (prepareObjectDelay > 0 || chunkCount == 0) {
+						mService.waitFor(prepareObjectDelay > 0 ? prepareObjectDelay : 400);
+					}
+					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION,
+                            "Uploading firmware...");
+				} else {
+					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION,
+                            "Resuming uploading firmware...");
+					resumeSendingData = false;
+				}
+
+				// Send the current object part
+				try {
+					logi("Uploading firmware...");
+					uploadFirmwareImage(mPacketCharacteristic);
+				} catch (final DeviceDisconnectedException e) {
+					loge("Disconnected while sending data");
+					throw e;
+				}
+
+				// Calculate Checksum
+				logi("Sending Calculate Checksum command (Op Code = 3)");
+				final ObjectChecksum checksum = readChecksum();
+				logi(String.format(Locale.US, "Checksum received (Offset = %d, CRC = %08X)", checksum.offset, checksum.CRC32));
+				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, String.format(Locale.US,
+                        "Checksum received (Offset = %d, CRC = %08X)", checksum.offset, checksum.CRC32));
+
+				// It may happen, that not all bytes that were sent were received by the remote device
+				final int bytesLost = mProgressInfo.getBytesSent() - checksum.offset;
+				if (bytesLost > 0) {
+					logw(bytesLost + " bytes were lost!");
+					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING,
+                            bytesLost + " bytes were lost");
+
+					try {
+						// We have to reset the stream and read 'offset' number of bytes to recalculate the CRC
+						mFirmwareStream.reset(); // Resets to the beginning of current object
+						//noinspection ResultOfMethodCallIgnored
+						mFirmwareStream.read(new byte[info.maxSize - bytesLost]); // Reads additional bytes that were sent and received in this object
+						mProgressInfo.setBytesSent(checksum.offset);
+					} catch (final IOException e) {
+						loge("Error while reading firmware stream", e);
+						mService.terminateConnection(gatt, DfuBaseService.ERROR_FILE_IO_EXCEPTION);
+						return;
+					} catch (final Throwable tr) {
+						// crash fix
+						// Check https://github.com/NordicSemiconductor/Android-DFU-Library/issues/229
+						loge("Progress lost. Bytes sent: " + mProgressInfo.getBytesSent(), tr);
+						mService.terminateConnection(gatt, DfuBaseService.ERROR_PROGRESS_LOST);
+						return;
+					}
+					// To decrease the chance of loosing data next time let's set PRN to 1.
+					// This will make the update very long, but perhaps it will succeed.
+					final int newPrn = 1;
+					if (mPacketsBeforeNotification == 0 || mPacketsBeforeNotification > newPrn) {
+						numberOfPacketsBeforeNotification = mPacketsBeforeNotification = newPrn;
+						setPacketReceiptNotifications(numberOfPacketsBeforeNotification);
+						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION,
+								"Packet Receipt Notif Req (Op Code = 2) sent (Value = " + newPrn + ")");
+					}
+				}
+
+				// Calculate the CRC32
+				final int crc = (int) (((ArchiveInputStream) mFirmwareStream).getCrc32() & 0xFFFFFFFFL);
+				if (crc == checksum.CRC32) {
+					if (bytesLost > 0) {
+						resumeSendingData = true;
+						continue;
+					}
+					// Execute Init packet
+					logi("Executing data object (Op Code = 4)");
+					writeExecute(mProgressInfo.isComplete());
+					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Data object executed");
+
+					// Increment iterator
+					currentChunk++;
+					attempt = 1;
+					//Mark this location after completion of successful transfer.  In the event of a CRC retry on the next packet we will restart from this point.
+					mFirmwareStream.mark(0);
+				} else {
+					String crcFailMessage = String.format(Locale.US, "CRC does not match! Expected %08X but found %08X.", crc, checksum.CRC32);
+					if (attempt < MAX_ATTEMPTS) {
+						attempt++;
+						crcFailMessage += String.format(Locale.US, " Retrying...(%d/%d)", attempt, MAX_ATTEMPTS);
+						logi(crcFailMessage);
+						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING, crcFailMessage);
+						try {
+							// Reset the CRC and file pointer back to the previous mark() point after completion of the last successful packet.
+							mFirmwareStream.reset();
+							mProgressInfo.setBytesSent(((ArchiveInputStream) mFirmwareStream).getBytesRead());
+						} catch (final IOException e) {
+							loge("Error while resetting the firmware stream", e);
+							mService.terminateConnection(gatt, DfuBaseService.ERROR_FILE_IO_EXCEPTION);
+							return;
+						}
+					} else {
+						loge(crcFailMessage);
+						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_ERROR, crcFailMessage);
+						mService.terminateConnection(gatt, DfuBaseService.ERROR_CRC_ERROR);
+						return;
+					}
+				}
+			}
+		} else {
+			// Looks as if the whole file was sent correctly but has not been executed
+			logi("Executing data object (Op Code = 4)");
+			writeExecute(true);
+			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Data object executed");
+		}
+
+		final long endTime = SystemClock.elapsedRealtime();
+		logi("Transfer of " + (mProgressInfo.getBytesSent() - info.offset) + " bytes has taken " + (endTime - startTime) + " ms");
+		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Upload completed in " + (endTime - startTime) + " ms");
+	}
+
+	/**
+	 * Checks whether the response received is valid and returns the status code.
+	 *
+	 * @param response the response received from the DFU device.
+	 * @param request  the expected Op Code
+	 * @return the status code
+	 * @throws UnknownResponseException if response was not valid
+	 */
+	private int getStatusCode(final byte[] response, final int request) throws UnknownResponseException {
+		if (response == null || response.length < 3 || response[0] != OP_CODE_RESPONSE_CODE_KEY || response[1] != request ||
+				(response[2] != DFU_STATUS_SUCCESS &&
+						response[2] != SecureDfuError.OP_CODE_NOT_SUPPORTED &&
+						response[2] != SecureDfuError.INVALID_PARAM &&
+						response[2] != SecureDfuError.INSUFFICIENT_RESOURCES &&
+						response[2] != SecureDfuError.INVALID_OBJECT &&
+						response[2] != SecureDfuError.UNSUPPORTED_TYPE &&
+						response[2] != SecureDfuError.OPERATION_NOT_PERMITTED &&
+						response[2] != SecureDfuError.OPERATION_FAILED &&
+						response[2] != SecureDfuError.EXTENDED_ERROR))
+			throw new UnknownResponseException("Invalid response received", response, OP_CODE_RESPONSE_CODE_KEY, request);
+		return response[2];
+	}
+
+	/**
+	 * Sets number of data packets that will be send before the notification will be received.
+	 *
+	 * @param data  control point data packet
+	 * @param value number of packets before receiving notification. If this value is 0, then the
+     *              notification of packet receipt will be disabled by the DFU target.
+	 */
+	private void setNumberOfPackets(@SuppressWarnings("SameParameterValue") @NonNull final byte[] data, final int value) {
+		data[1] = (byte) (value & 0xFF);
+		data[2] = (byte) ((value >> 8) & 0xFF);
+	}
+
+	/**
+	 * Sets the object size in correct position of the data array.
+	 *
+	 * @param data  control point data packet
+	 * @param value Object size in bytes.
+	 */
+	private void setObjectSize(@NonNull final byte[] data, final int value) {
+		data[2] = (byte) (value & 0xFF);
+		data[3] = (byte) ((value >> 8) & 0xFF);
+		data[4] = (byte) ((value >> 16) & 0xFF);
+		data[5] = (byte) ((value >> 24) & 0xFF);
+	}
+
+	/**
+	 * Sets the number of packets that needs to be sent to receive the Packet Receipt Notification.
+	 * Value 0 disables PRNs. By default this is disabled. The PRNs may be used to send both the
+	 * Data and Command object, but this Secure DFU implementation can handle them only during Data transfer.
+	 * <p>
+	 * The intention of having PRNs is to make sure the outgoing BLE buffer is not getting overflown.
+	 * The PRN will be sent after sending all packets from the queue.
+	 *
+	 * @param number number of packets required before receiving a Packet Receipt Notification.
+	 * @throws DfuException
+	 * @throws DeviceDisconnectedException
+	 * @throws UploadAbortedException
+	 * @throws UnknownResponseException
+	 * @throws RemoteDfuException thrown when the returned status code is not equal to {@link #DFU_STATUS_SUCCESS}
+	 */
+	private void setPacketReceiptNotifications(final int number)
+			throws DfuException, DeviceDisconnectedException, UploadAbortedException,
+			UnknownResponseException, RemoteDfuException {
+		if (!mConnected)
+			throw new DeviceDisconnectedException("Unable to read Checksum: device disconnected");
+
+		// Send the number of packets of firmware before receiving a receipt notification
+		logi("Sending the number of packets before notifications (Op Code = 2, Value = " + number + ")");
+		setNumberOfPackets(OP_CODE_PACKET_RECEIPT_NOTIF_REQ, number);
+		writeOpCode(mControlPointCharacteristic, OP_CODE_PACKET_RECEIPT_NOTIF_REQ);
+
+		// Read response
+		final byte[] response = readNotificationResponse();
+		final int status = getStatusCode(response, OP_CODE_PACKET_RECEIPT_NOTIF_REQ_KEY);
+		if (status == SecureDfuError.EXTENDED_ERROR)
+			throw new RemoteDfuExtendedErrorException("Sending the number of packets failed", response[3]);
+		if (status != DFU_STATUS_SUCCESS)
+			throw new RemoteDfuException("Sending the number of packets failed", status);
+	}
+
+	/**
+	 * Writes the operation code to the characteristic. This method is SYNCHRONOUS and wait until the
+	 * {@link android.bluetooth.BluetoothGattCallback#onCharacteristicWrite(android.bluetooth.BluetoothGatt, android.bluetooth.BluetoothGattCharacteristic, int)}
+	 * will be called or the device gets disconnected.
+	 * If connection state will change, or an error will occur, an exception will be thrown.
+	 *
+	 * @param characteristic the characteristic to write to. Should be the DFU CONTROL POINT.
+	 * @param value          the value to write to the characteristic.
+	 * @throws DeviceDisconnectedException
+	 * @throws DfuException
+	 * @throws UploadAbortedException
+	 */
+	private void writeOpCode(@NonNull final BluetoothGattCharacteristic characteristic, @NonNull final byte[] value)
+			throws DeviceDisconnectedException, DfuException, UploadAbortedException {
+		writeOpCode(characteristic, value, false);
+	}
+
+	/**
+	 * Writes Create Object request providing the type and size of the object.
+	 *
+	 * @param type {@link #OBJECT_COMMAND} or {@link #OBJECT_DATA}.
+	 * @param size size of the object or current part of the object.
+	 * @throws DeviceDisconnectedException
+	 * @throws DfuException
+	 * @throws UploadAbortedException
+	 * @throws RemoteDfuException thrown when the returned status code is not equal to {@link #DFU_STATUS_SUCCESS}
+	 * @throws UnknownResponseException
+	 */
+	private void writeCreateRequest(final int type, final int size)
+			throws DeviceDisconnectedException, DfuException, UploadAbortedException, RemoteDfuException,
+			UnknownResponseException {
+		if (!mConnected)
+			throw new DeviceDisconnectedException("Unable to create object: device disconnected");
+
+		final byte[] data = (type == OBJECT_COMMAND) ? OP_CODE_CREATE_COMMAND : OP_CODE_CREATE_DATA;
+		setObjectSize(data, size);
+		writeOpCode(mControlPointCharacteristic, data);
+
+		final byte[] response = readNotificationResponse();
+		final int status = getStatusCode(response, OP_CODE_CREATE_KEY);
+		if (status == SecureDfuError.EXTENDED_ERROR)
+			throw new RemoteDfuExtendedErrorException("Creating Command object failed", response[3]);
+		if (status != DFU_STATUS_SUCCESS)
+			throw new RemoteDfuException("Creating Command object failed", status);
+	}
+
+	/**
+	 * Selects the current object and reads its metadata. The object info contains the max object
+	 * size, and the offset and CRC32 of the whole object until now.
+	 *
+	 * @return object info.
+	 * @throws DeviceDisconnectedException
+	 * @throws DfuException
+	 * @throws UploadAbortedException
+	 * @throws RemoteDfuException thrown when the returned status code is not equal to
+	 * {@link #DFU_STATUS_SUCCESS}.
+	 */
+	private ObjectInfo selectObject(final int type)
+			throws DeviceDisconnectedException, DfuException, UploadAbortedException,
+			RemoteDfuException, UnknownResponseException {
+		if (!mConnected)
+			throw new DeviceDisconnectedException("Unable to read object info: device disconnected");
+
+		OP_CODE_SELECT_OBJECT[1] = (byte) type;
+		writeOpCode(mControlPointCharacteristic, OP_CODE_SELECT_OBJECT);
+
+		final byte[] response = readNotificationResponse();
+		final int status = getStatusCode(response, OP_CODE_SELECT_OBJECT_KEY);
+		if (status == SecureDfuError.EXTENDED_ERROR)
+			throw new RemoteDfuExtendedErrorException("Selecting object failed", response[3]);
+		if (status != DFU_STATUS_SUCCESS)
+			throw new RemoteDfuException("Selecting object failed", status);
+
+		final ObjectInfo info = new ObjectInfo();
+		info.maxSize = unsignedBytesToInt(response, 3);
+		info.offset = unsignedBytesToInt(response, 3 + 4);
+		info.CRC32  = unsignedBytesToInt(response, 3 + 8);
+		return info;
+	}
+
+	/**
+	 * Sends the Calculate Checksum request. As a response a notification will be sent with current
+     * offset and CRC32 of the current object.
+	 *
+	 * @return requested object info.
+	 * @throws DeviceDisconnectedException
+	 * @throws DfuException
+	 * @throws UploadAbortedException
+	 * @throws RemoteDfuException thrown when the returned status code is not equal to
+     * {@link #DFU_STATUS_SUCCESS}.
+	 */
+	private ObjectChecksum readChecksum() throws DeviceDisconnectedException, DfuException,
+            UploadAbortedException, RemoteDfuException, UnknownResponseException {
+		if (!mConnected)
+			throw new DeviceDisconnectedException("Unable to read Checksum: device disconnected");
+
+		writeOpCode(mControlPointCharacteristic, OP_CODE_CALCULATE_CHECKSUM);
+
+		final byte[] response = readNotificationResponse();
+		final int status = getStatusCode(response, OP_CODE_CALCULATE_CHECKSUM_KEY);
+		if (status == SecureDfuError.EXTENDED_ERROR)
+			throw new RemoteDfuExtendedErrorException("Receiving Checksum failed", response[3]);
+		if (status != DFU_STATUS_SUCCESS)
+			throw new RemoteDfuException("Receiving Checksum failed", status);
+
+		final ObjectChecksum checksum = new ObjectChecksum();
+		checksum.offset = unsignedBytesToInt(response, 3);
+		checksum.CRC32  = unsignedBytesToInt(response, 3 + 4);
+		return checksum;
+	}
+
+	private int unsignedBytesToInt(@NonNull final byte[] array, final int offset) {
+		return (array[offset] & 0xFF) + ((array[offset + 1] & 0xFF) << 8)
+			+ ((array[offset + 2] & 0xFF) << 16) + ((array[offset + 3] & 0xFF) << 24);
+	}
+
+	/**
+	 * Sends the Execute operation code and awaits for a return notification containing status code.
+	 * The Execute command will confirm the last chunk of data or the last command that was sent.
+	 * Creating the same object again, instead of executing it allows to retransmitting it in case
+     * of a CRC error.
+	 *
+	 * @throws DfuException
+	 * @throws DeviceDisconnectedException
+	 * @throws UploadAbortedException
+	 * @throws UnknownResponseException
+	 * @throws RemoteDfuException thrown when the returned status code is not equal to
+     * {@link #DFU_STATUS_SUCCESS}.
+	 */
+	private void writeExecute() throws DfuException, DeviceDisconnectedException,
+            UploadAbortedException, UnknownResponseException, RemoteDfuException {
+		if (!mConnected)
+			throw new DeviceDisconnectedException("Unable to read Checksum: device disconnected");
+
+		writeOpCode(mControlPointCharacteristic, OP_CODE_EXECUTE);
+
+		final byte[] response = readNotificationResponse();
+		final int status = getStatusCode(response, OP_CODE_EXECUTE_KEY);
+		if (status == SecureDfuError.EXTENDED_ERROR)
+			throw new RemoteDfuExtendedErrorException("Executing object failed", response[3]);
+		if (status != DFU_STATUS_SUCCESS)
+			throw new RemoteDfuException("Executing object failed", status);
+	}
+
+	/**
+	 * After the whole firmware image was sent, the last command Execute will cause erasing memory
+	 * and flashing the new firmware. This may result in INVALID_OBJECT error in 2 cases:
+	 * <ol>
+	 *     <li>The SoftDevice (which is responsible for allowing writing) was busy and the bootloader
+	 *         tried to erase the memory N times without a success. Then we can resend the Execute here.</li>
+	 *     <li>The firmware sent contained only SoftDevice (no Bootloader) and the Major version has
+	 *         changed comparing to the previous one. The old bootloader would not work with this new SD
+	 *         so such update is forbidden as it would brick the device.</li>
+	 * </ol>
+	 * See: <a href="https://github.com/NordicSemiconductor/Android-DFU-Library/issues/86">https://github.com/NordicSemiconductor/Android-DFU-Library/issues/86</a>
+     *
+	 * @param allowRetry if true service will retry to send the execute command in case of
+     *                   INVALID_OBJECT error.
+	 * @throws DfuException
+	 * @throws DeviceDisconnectedException
+	 * @throws UploadAbortedException
+	 * @throws UnknownResponseException
+	 * @throws RemoteDfuException thrown when the returned status code is not equal to
+     * {@link #DFU_STATUS_SUCCESS}.
+	 */
+	private void writeExecute(final boolean allowRetry)
+            throws DfuException, DeviceDisconnectedException, UploadAbortedException,
+            UnknownResponseException, RemoteDfuException {
+		try {
+			writeExecute();
+		} catch (final RemoteDfuException e) {
+			if (allowRetry && e.getErrorNumber() == SecureDfuError.INVALID_OBJECT) {
+				logw(e.getMessage() + ": " + SecureDfuError.parse(DfuBaseService.ERROR_REMOTE_TYPE_SECURE | SecureDfuError.INVALID_OBJECT));
+				if (mFileType == DfuBaseService.TYPE_SOFT_DEVICE) {
+					logw("Are you sure your new SoftDevice is API compatible with the updated one? If not, update the bootloader as well");
+					// API compatible = both SoftDevices have the same Major version
+				}
+				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING, String.format(Locale.US, "Remote DFU error: %s. SD busy? Retrying...",
+						SecureDfuError.parse(DfuBaseService.ERROR_REMOTE_TYPE_SECURE | SecureDfuError.INVALID_OBJECT)));
+				logi("SD busy? Retrying...");
+				logi("Executing data object (Op Code = 4)");
+				writeExecute();
+			} else {
+				throw e;
+			}
+		}
+	}
+
+	private static class ObjectInfo extends ObjectChecksum {
+		int maxSize;
+	}
+
+	private static class ObjectChecksum {
+		int offset;
+		int CRC32;
+	}
+}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/UuidHelper.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/UuidHelper.java
new file mode 100644
index 0000000..e208b3b
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/UuidHelper.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.dfu;
+
+import android.content.Intent;
+import android.os.ParcelUuid;
+import android.os.Parcelable;
+
+import androidx.annotation.NonNull;
+
+/* package */ class UuidHelper {
+
+	/* package */ static void assignCustomUuids(@NonNull final Intent intent) {
+		// Added in SDK 4.3.0. Legacy DFU and Legacy bootloader share the same UUIDs.
+		Parcelable[] uuids = intent.getParcelableArrayExtra(DfuBaseService.EXTRA_CUSTOM_UUIDS_FOR_LEGACY_DFU);
+		if (uuids != null && uuids.length == 4) {
+			LegacyDfuImpl.DFU_SERVICE_UUID       = uuids[0] != null ? ((ParcelUuid) uuids[0]).getUuid() : LegacyDfuImpl.DEFAULT_DFU_SERVICE_UUID;
+			LegacyDfuImpl.DFU_CONTROL_POINT_UUID = uuids[1] != null ? ((ParcelUuid) uuids[1]).getUuid() : LegacyDfuImpl.DEFAULT_DFU_CONTROL_POINT_UUID;
+			LegacyDfuImpl.DFU_PACKET_UUID        = uuids[2] != null ? ((ParcelUuid) uuids[2]).getUuid() : LegacyDfuImpl.DEFAULT_DFU_PACKET_UUID;
+			LegacyDfuImpl.DFU_VERSION_UUID       = uuids[3] != null ? ((ParcelUuid) uuids[3]).getUuid() : LegacyDfuImpl.DEFAULT_DFU_VERSION_UUID;
+
+			LegacyButtonlessDfuImpl.DFU_SERVICE_UUID       = LegacyDfuImpl.DFU_SERVICE_UUID;
+			LegacyButtonlessDfuImpl.DFU_CONTROL_POINT_UUID = LegacyDfuImpl.DFU_CONTROL_POINT_UUID;
+			// No need for DFU Packet in buttonless DFU
+			LegacyButtonlessDfuImpl.DFU_VERSION_UUID       = LegacyDfuImpl.DFU_VERSION_UUID;
+		} else {
+			LegacyDfuImpl.DFU_SERVICE_UUID       = LegacyDfuImpl.DEFAULT_DFU_SERVICE_UUID;
+			LegacyDfuImpl.DFU_CONTROL_POINT_UUID = LegacyDfuImpl.DEFAULT_DFU_CONTROL_POINT_UUID;
+			LegacyDfuImpl.DFU_PACKET_UUID        = LegacyDfuImpl.DEFAULT_DFU_PACKET_UUID;
+			LegacyDfuImpl.DFU_VERSION_UUID       = LegacyDfuImpl.DEFAULT_DFU_VERSION_UUID;
+
+			LegacyButtonlessDfuImpl.DFU_SERVICE_UUID       = LegacyDfuImpl.DEFAULT_DFU_SERVICE_UUID;
+			LegacyButtonlessDfuImpl.DFU_CONTROL_POINT_UUID = LegacyDfuImpl.DEFAULT_DFU_CONTROL_POINT_UUID;
+			LegacyButtonlessDfuImpl.DFU_VERSION_UUID       = LegacyDfuImpl.DEFAULT_DFU_VERSION_UUID;
+		}
+
+		// Added in SDK 12
+		uuids = intent.getParcelableArrayExtra(DfuBaseService.EXTRA_CUSTOM_UUIDS_FOR_SECURE_DFU);
+		if (uuids != null && uuids.length == 3) {
+			SecureDfuImpl.DFU_SERVICE_UUID       = uuids[0] != null ? ((ParcelUuid) uuids[0]).getUuid() : SecureDfuImpl.DEFAULT_DFU_SERVICE_UUID;
+			SecureDfuImpl.DFU_CONTROL_POINT_UUID = uuids[1] != null ? ((ParcelUuid) uuids[1]).getUuid() : SecureDfuImpl.DEFAULT_DFU_CONTROL_POINT_UUID;
+			SecureDfuImpl.DFU_PACKET_UUID        = uuids[2] != null ? ((ParcelUuid) uuids[2]).getUuid() : SecureDfuImpl.DEFAULT_DFU_PACKET_UUID;
+		} else {
+			SecureDfuImpl.DFU_SERVICE_UUID       = SecureDfuImpl.DEFAULT_DFU_SERVICE_UUID;
+			SecureDfuImpl.DFU_CONTROL_POINT_UUID = SecureDfuImpl.DEFAULT_DFU_CONTROL_POINT_UUID;
+			SecureDfuImpl.DFU_PACKET_UUID        = SecureDfuImpl.DEFAULT_DFU_PACKET_UUID;
+		}
+
+		uuids = intent.getParcelableArrayExtra(DfuBaseService.EXTRA_CUSTOM_UUIDS_FOR_EXPERIMENTAL_BUTTONLESS_DFU);
+		if (uuids != null && uuids.length == 2) {
+			ExperimentalButtonlessDfuImpl.EXPERIMENTAL_BUTTONLESS_DFU_SERVICE_UUID = uuids[0] != null ? ((ParcelUuid) uuids[0]).getUuid() : ExperimentalButtonlessDfuImpl.DEFAULT_EXPERIMENTAL_BUTTONLESS_DFU_SERVICE_UUID;
+			ExperimentalButtonlessDfuImpl.EXPERIMENTAL_BUTTONLESS_DFU_UUID         = uuids[1] != null ? ((ParcelUuid) uuids[1]).getUuid() : ExperimentalButtonlessDfuImpl.DEFAULT_EXPERIMENTAL_BUTTONLESS_DFU_UUID;
+		} else {
+			ExperimentalButtonlessDfuImpl.EXPERIMENTAL_BUTTONLESS_DFU_SERVICE_UUID = ExperimentalButtonlessDfuImpl.DEFAULT_EXPERIMENTAL_BUTTONLESS_DFU_SERVICE_UUID;
+			ExperimentalButtonlessDfuImpl.EXPERIMENTAL_BUTTONLESS_DFU_UUID         = ExperimentalButtonlessDfuImpl.DEFAULT_EXPERIMENTAL_BUTTONLESS_DFU_UUID;
+		}
+
+		// Added in SDK 13
+		uuids = intent.getParcelableArrayExtra(DfuBaseService.EXTRA_CUSTOM_UUIDS_FOR_BUTTONLESS_DFU_WITHOUT_BOND_SHARING);
+		if (uuids != null && uuids.length == 2) {
+			ButtonlessDfuWithoutBondSharingImpl.BUTTONLESS_DFU_SERVICE_UUID = uuids[0] != null ? ((ParcelUuid) uuids[0]).getUuid() : ButtonlessDfuWithoutBondSharingImpl.DEFAULT_BUTTONLESS_DFU_SERVICE_UUID;
+			ButtonlessDfuWithoutBondSharingImpl.BUTTONLESS_DFU_UUID         = uuids[1] != null ? ((ParcelUuid) uuids[1]).getUuid() : ButtonlessDfuWithoutBondSharingImpl.DEFAULT_BUTTONLESS_DFU_UUID;
+		} else {
+			ButtonlessDfuWithoutBondSharingImpl.BUTTONLESS_DFU_SERVICE_UUID = ButtonlessDfuWithoutBondSharingImpl.DEFAULT_BUTTONLESS_DFU_SERVICE_UUID;
+			ButtonlessDfuWithoutBondSharingImpl.BUTTONLESS_DFU_UUID         = ButtonlessDfuWithoutBondSharingImpl.DEFAULT_BUTTONLESS_DFU_UUID;
+		}
+
+		// Added in SDK 14 (or later)
+		uuids = intent.getParcelableArrayExtra(DfuBaseService.EXTRA_CUSTOM_UUIDS_FOR_BUTTONLESS_DFU_WITH_BOND_SHARING);
+		if (uuids != null && uuids.length == 2) {
+			ButtonlessDfuWithBondSharingImpl.BUTTONLESS_DFU_SERVICE_UUID = uuids[0] != null ? ((ParcelUuid) uuids[0]).getUuid() : ButtonlessDfuWithBondSharingImpl.DEFAULT_BUTTONLESS_DFU_SERVICE_UUID;
+			ButtonlessDfuWithBondSharingImpl.BUTTONLESS_DFU_UUID         = uuids[1] != null ? ((ParcelUuid) uuids[1]).getUuid() : ButtonlessDfuWithBondSharingImpl.DEFAULT_BUTTONLESS_DFU_UUID;
+		} else {
+			ButtonlessDfuWithBondSharingImpl.BUTTONLESS_DFU_SERVICE_UUID = ButtonlessDfuWithBondSharingImpl.DEFAULT_BUTTONLESS_DFU_SERVICE_UUID;
+			ButtonlessDfuWithBondSharingImpl.BUTTONLESS_DFU_UUID         = ButtonlessDfuWithBondSharingImpl.DEFAULT_BUTTONLESS_DFU_UUID;
+		}
+	}
+}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/ArchiveInputStream.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/ArchiveInputStream.java
new file mode 100644
index 0000000..a0cdbcf
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/ArchiveInputStream.java
@@ -0,0 +1,665 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.dfu.internal;
+
+import android.os.Build;
+import android.util.Log;
+
+import com.google.gson.Gson;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.charset.StandardCharsets;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+import java.util.zip.CRC32;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipInputStream;
+
+import androidx.annotation.NonNull;
+import no.nordicsemi.android.dfu.DfuBaseService;
+import no.nordicsemi.android.dfu.internal.manifest.FileInfo;
+import no.nordicsemi.android.dfu.internal.manifest.Manifest;
+import no.nordicsemi.android.dfu.internal.manifest.ManifestFile;
+import no.nordicsemi.android.dfu.internal.manifest.SoftDeviceBootloaderFileInfo;
+
+/**
+ * <p>
+ * Reads the firmware files from the a ZIP file. The ZIP file must be either created using the
+ * <a href="https://github.com/NordicSemiconductor/pc-nrfutil"><b>nrf util</b></a>,
+ * or follow the backward compatibility syntax: must contain only files with names:
+ * application.hex/bin, softdevice.hex/dat or bootloader.hex/bin, optionally also application.dat
+ * and/or system.dat with init packets.
+ * <p>
+ * The ArchiveInputStream will read only files with types specified by <b>types</b> parameter of
+ * the constructor.
+ */
+public class ArchiveInputStream extends InputStream {
+	private static final String TAG = "DfuArchiveInputStream";
+
+	/**
+	 * The name of the manifest file is fixed.
+	 */
+	private static final String MANIFEST = "manifest.json";
+	// Those file names are for backwards compatibility mode
+	private static final String SOFTDEVICE_HEX = "softdevice.hex";
+	private static final String SOFTDEVICE_BIN = "softdevice.bin";
+	private static final String BOOTLOADER_HEX = "bootloader.hex";
+	private static final String BOOTLOADER_BIN = "bootloader.bin";
+	private static final String APPLICATION_HEX = "application.hex";
+	private static final String APPLICATION_BIN = "application.bin";
+	private static final String SYSTEM_INIT = "system.dat";
+	private static final String APPLICATION_INIT = "application.dat";
+
+	private final ZipInputStream zipInputStream;
+
+	/**
+	 * Contains bytes arrays with BIN files. HEX files are converted to BIN before being
+     * added to this map.
+	 */
+	private final Map<String, byte[]> entries;
+	private final CRC32 crc32;
+	private Manifest manifest;
+
+	private byte[] applicationBytes;
+	private byte[] softDeviceBytes;
+	private byte[] bootloaderBytes;
+	private byte[] softDeviceAndBootloaderBytes;
+	private byte[] systemInitBytes;
+	private byte[] applicationInitBytes;
+	private byte[] currentSource;
+	private int type;
+	private int bytesReadFromCurrentSource;
+	private int softDeviceSize;
+	private int bootloaderSize;
+	private int applicationSize;
+	private int bytesRead;
+
+	private byte[] markedSource;
+	private int bytesReadFromMarkedSource;
+
+	/**
+	 * <p>
+	 * The ArchiveInputStream read HEX or BIN files from the Zip stream. It may skip some of them,
+     * depending on the value of the types parameter. This is useful if the DFU service wants to
+     * send the Soft Device and Bootloader only, and then the Application in the following connection,
+     * despite the ZIP file contains all 3 HEX/BIN files.
+	 * When types is equal to {@link DfuBaseService#TYPE_AUTO} all present files are read.
+	 * <p>
+     * Use bit combination of the following types:
+	 * <ul>
+	 * <li>{@link DfuBaseService#TYPE_SOFT_DEVICE}</li>
+	 * <li>{@link DfuBaseService#TYPE_BOOTLOADER}</li>
+	 * <li>{@link DfuBaseService#TYPE_APPLICATION}</li>
+	 * <li>{@link DfuBaseService#TYPE_AUTO}</li>
+	 * </ul>
+	 *
+	 * @param stream  the Zip Input Stream
+	 * @param mbrSize The size of the MRB segment (Master Boot Record) on the device.
+     *                The parser will cut data from addresses below that number from all HEX files.
+	 * @param types   File types that are to be read from the ZIP. Use
+     *                {@link DfuBaseService#TYPE_APPLICATION} etc.
+	 * @throws java.io.IOException Thrown in case of an invalid ZIP file.
+	 */
+	public ArchiveInputStream(final InputStream stream, final int mbrSize, final int types)
+            throws IOException {
+		this.zipInputStream = new ZipInputStream(stream);
+
+		this.crc32 = new CRC32();
+		this.entries = new HashMap<>();
+		this.bytesRead = 0;
+		this.bytesReadFromCurrentSource = 0;
+
+		try {
+			/*
+			 * This method reads all entries from the ZIP file and puts them to entries map.
+			 * The 'manifest.json' file, if exists, is converted to the manifestData String.
+			 */
+			parseZip(mbrSize);
+
+			/*
+			 * Let's read and parse the 'manifest.json' file.
+			 */
+			if (manifest != null) {
+				boolean valid = false;
+
+				// Read the application
+				if (manifest.getApplicationInfo() != null && (types == DfuBaseService.TYPE_AUTO || (types & DfuBaseService.TYPE_APPLICATION) > 0)) {
+					final FileInfo application = manifest.getApplicationInfo();
+					applicationBytes = entries.get(application.getBinFileName());
+					applicationInitBytes = entries.get(application.getDatFileName());
+
+					if (applicationBytes == null)
+						throw new IOException("Application file " + application.getBinFileName() + " not found.");
+					applicationSize = applicationBytes.length;
+					currentSource = applicationBytes;
+					valid = true;
+				}
+
+				// Read the Bootloader
+				if (manifest.getBootloaderInfo() != null && (types == DfuBaseService.TYPE_AUTO || (types & DfuBaseService.TYPE_BOOTLOADER) > 0)) {
+					if (systemInitBytes != null)
+						throw new IOException("Manifest: softdevice and bootloader specified. Use softdevice_bootloader instead.");
+
+					final FileInfo bootloader = manifest.getBootloaderInfo();
+					bootloaderBytes = entries.get(bootloader.getBinFileName());
+					systemInitBytes = entries.get(bootloader.getDatFileName());
+
+					if (bootloaderBytes == null)
+						throw new IOException("Bootloader file " + bootloader.getBinFileName() + " not found.");
+					bootloaderSize = bootloaderBytes.length;
+					currentSource = bootloaderBytes;
+					valid = true;
+				}
+
+				// Read the Soft Device
+				if (manifest.getSoftdeviceInfo() != null && (types == DfuBaseService.TYPE_AUTO || (types & DfuBaseService.TYPE_SOFT_DEVICE) > 0)) {
+					final FileInfo softdevice = manifest.getSoftdeviceInfo();
+					softDeviceBytes = entries.get(softdevice.getBinFileName());
+					systemInitBytes = entries.get(softdevice.getDatFileName());
+
+					if (softDeviceBytes == null)
+						throw new IOException("SoftDevice file " + softdevice.getBinFileName() + " not found.");
+					softDeviceSize = softDeviceBytes.length;
+					currentSource = softDeviceBytes;
+					valid = true;
+				}
+
+				// Read the combined Soft Device and Bootloader
+				if (manifest.getSoftdeviceBootloaderInfo() != null && (types == DfuBaseService.TYPE_AUTO ||
+						((types & DfuBaseService.TYPE_SOFT_DEVICE) > 0) && (types & DfuBaseService.TYPE_BOOTLOADER) > 0)) {
+					if (systemInitBytes != null)
+						throw new IOException("Manifest: The softdevice_bootloader may not be used together with softdevice or bootloader.");
+
+					final SoftDeviceBootloaderFileInfo system = manifest.getSoftdeviceBootloaderInfo();
+					softDeviceAndBootloaderBytes = entries.get(system.getBinFileName());
+					systemInitBytes = entries.get(system.getDatFileName());
+
+					if (softDeviceAndBootloaderBytes == null)
+						throw new IOException("File " + system.getBinFileName() + " not found.");
+					softDeviceSize = system.getSoftdeviceSize();
+					bootloaderSize = system.getBootloaderSize();
+					currentSource = softDeviceAndBootloaderBytes;
+					valid = true;
+				}
+
+				if (!valid) {
+					throw new IOException("Manifest file must specify at least one file.");
+				}
+			} else {
+				/*
+				 * Compatibility mode. The 'manifest.json' file does not exist.
+				 *
+				 * In that case the ZIP file must contain one or more of the following files:
+				 *
+				 * - application.hex/dat
+				 *     + application.dat
+				 * - softdevice.hex/dat
+				 * - bootloader.hex/dat
+				 *     + system.dat
+				 */
+				boolean valid = false;
+				// Search for the application
+				if (types == DfuBaseService.TYPE_AUTO || (types & DfuBaseService.TYPE_APPLICATION) > 0) {
+					applicationBytes = entries.get(APPLICATION_HEX); // the entry bytes has already been converted to BIN, just the name remained.
+					if (applicationBytes == null)
+						applicationBytes = entries.get(APPLICATION_BIN);
+					if (applicationBytes != null) {
+						applicationSize = applicationBytes.length;
+						applicationInitBytes = entries.get(APPLICATION_INIT);
+						currentSource = applicationBytes;
+						valid = true;
+					}
+				}
+
+				// Search for theBootloader
+				if (types == DfuBaseService.TYPE_AUTO || (types & DfuBaseService.TYPE_BOOTLOADER) > 0) {
+					bootloaderBytes = entries.get(BOOTLOADER_HEX); // the entry bytes has already been converted to BIN, just the name remained.
+					if (bootloaderBytes == null)
+						bootloaderBytes = entries.get(BOOTLOADER_BIN);
+					if (bootloaderBytes != null) {
+						bootloaderSize = bootloaderBytes.length;
+						systemInitBytes = entries.get(SYSTEM_INIT);
+						currentSource = bootloaderBytes;
+						valid = true;
+					}
+				}
+
+				// Search for the Soft Device
+				if (types == DfuBaseService.TYPE_AUTO || (types & DfuBaseService.TYPE_SOFT_DEVICE) > 0) {
+					softDeviceBytes = entries.get(SOFTDEVICE_HEX); // the entry bytes has already been converted to BIN, just the name remained.
+					if (softDeviceBytes == null)
+						softDeviceBytes = entries.get(SOFTDEVICE_BIN);
+					if (softDeviceBytes != null) {
+						softDeviceSize = softDeviceBytes.length;
+						systemInitBytes = entries.get(SYSTEM_INIT);
+						currentSource = softDeviceBytes;
+						valid = true;
+					}
+				}
+
+				if (!valid) {
+					throw new IOException("The ZIP file must contain an Application, a Soft Device and/or a Bootloader.");
+				}
+			}
+			mark(0);
+		} finally {
+			type = getContentType();
+			zipInputStream.close();
+		}
+	}
+
+	/**
+	 * Validates the path (not the content) of the zip file to prevent path traversal issues.
+	 *
+	 * <p> When unzipping an archive, always validate the compressed files' paths and reject any path
+	 * that has a path traversal (such as ../..). Simply looking for .. characters in the compressed
+	 * file's path may not be enough to prevent path traversal issues. The code validates the name of
+	 * the entry before extracting the entry. If the name is invalid, the entire extraction is aborted.
+	 * <p>
+	 *
+	 * @param filename The path to the file.
+	 * @param intendedDir The intended directory where the zip should be.
+	 * @return The validated path to the file.
+	 * @throws java.io.IOException Thrown in case of path traversal issues.
+	 */
+	@SuppressWarnings("SameParameterValue")
+	private String validateFilename(@NonNull final String filename,
+									@NonNull final String intendedDir)
+			throws java.io.IOException {
+		File f = new File(filename);
+		String canonicalPath = f.getCanonicalPath();
+
+		File iD = new File(intendedDir);
+		String canonicalID = iD.getCanonicalPath();
+
+		if (canonicalPath.startsWith(canonicalID)) {
+			return canonicalPath.substring(1); // remove leading "/"
+		} else {
+			throw new IllegalStateException("File is outside extraction target directory.");
+		}
+	}
+
+	/**
+	 * Reads all files into byte arrays.
+	 * Here we don't know whether the ZIP file is valid.
+	 * <p>
+	 * The ZIP file is valid when contains a 'manifest.json' file and all BIN and DAT files that
+     * are specified in the manifest.
+	 * <p>
+	 * For backwards compatibility ArchiveInputStream supports also ZIP archives without
+     * 'manifest.json' file but than it MUST include at least one of the following files:
+     * softdevice.bin/hex, bootloader.bin/hex, application.bin/hex.
+	 * To support the init packet such ZIP file should contain also application.dat and/or system.dat
+     * (with the CRC16 of a SD, BL or SD+BL together).
+	 */
+	private void parseZip(final int mbrSize) throws IOException {
+		final byte[] buffer = new byte[1024];
+		String manifestData = null;
+
+		ZipEntry ze;
+		while ((ze = zipInputStream.getNextEntry()) != null) {
+			final String filename = validateFilename(ze.getName(), ".");
+
+			if (ze.isDirectory()) {
+				Log.w(TAG, "A directory found in the ZIP: " + filename + "!");
+				continue;
+			}
+
+			// Read file content to byte array
+			final ByteArrayOutputStream baos = new ByteArrayOutputStream();
+			int count;
+			while ((count = zipInputStream.read(buffer)) != -1) {
+				baos.write(buffer, 0, count);
+			}
+			byte[] source = baos.toByteArray();
+
+			// In case of HEX file convert it to BIN
+			if (filename.toLowerCase(Locale.US).endsWith("hex")) {
+				final HexInputStream is = new HexInputStream(source, mbrSize);
+				source = new byte[is.available()];
+				is.read(source);
+				is.close();
+			}
+
+			// Save the file content either as a manifest data or by adding it to entries
+			if (MANIFEST.equals(filename))
+				if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
+					manifestData = new String(source, StandardCharsets.UTF_8);
+				} else {
+					//noinspection CharsetObjectCanBeUsed
+					manifestData = new String(source, "UTF-8");
+				}
+			else
+				entries.put(filename, source);
+		}
+
+		// Some validation
+		if (entries.isEmpty()) {
+			throw new FileNotFoundException("No files found in the ZIP. Check if the URI provided is " +
+                    "valid and the ZIP contains required files on root level, not in a directory.");
+		}
+
+		if (manifestData != null) {
+			final ManifestFile manifestFile = new Gson().fromJson(manifestData, ManifestFile.class);
+			manifest = manifestFile.getManifest();
+			if (manifest == null) {
+				Log.w(TAG, "Manifest failed to be parsed. Did you add \n" +
+						"-keep class no.nordicsemi.android.dfu.** { *; }\n" +
+						"to your proguard rules?");
+			}
+		} else {
+			Log.w(TAG, "Manifest not found in the ZIP. It is recommended to use a distribution " +
+                    "file created with: https://github.com/NordicSemiconductor/pc-nrfutil/ (for Legacy DFU use version 0.5.x)");
+		}
+	}
+
+	@Override
+	public void close() throws IOException {
+		softDeviceBytes = null;
+		bootloaderBytes = null;
+		applicationBytes = null;
+		softDeviceAndBootloaderBytes = null;
+		softDeviceSize = bootloaderSize = applicationSize = 0;
+		currentSource = null;
+		bytesRead = bytesReadFromCurrentSource = 0;
+		zipInputStream.close();
+	}
+
+	@Override
+	public long skip(final long n) {
+		return 0;
+	}
+
+	@Override
+	public int read() {
+		final byte[] buffer = new byte[1];
+		if (read(buffer) == -1) {
+			return -1;
+		} else {
+			return buffer[0] & 0xFF;
+		}
+	}
+
+	@Override
+	public int read(@NonNull final byte[] buffer) {
+		return read(buffer, 0, buffer.length);
+	}
+
+	@Override
+	public int read(@NonNull final byte[] buffer, final int offset, final int length) {
+		final int size = rawRead(buffer, offset, length);
+		if (length > size && startNextFile() != null) {
+			return size + rawRead(buffer, offset + size, length - size);
+		}
+		return size;
+	}
+
+	private int rawRead(@NonNull final byte[] buffer, final int offset, final int length) {
+		final int maxSize = currentSource.length - bytesReadFromCurrentSource;
+		final int size = Math.min(length, maxSize);
+		System.arraycopy(currentSource, bytesReadFromCurrentSource, buffer, offset, size);
+		bytesReadFromCurrentSource += size;
+		bytesRead += size;
+		crc32.update(buffer, offset, size);
+		return size;
+	}
+
+	@Override
+	public boolean markSupported() {
+		return true;
+	}
+
+	/**
+	 * Marks the current position in the stream. The parameter is ignored.
+	 *
+	 * @param readlimit this parameter is ignored, can be anything
+	 */
+	@Override
+	public void mark(final int readlimit) {
+		markedSource = currentSource;
+		bytesReadFromMarkedSource = bytesReadFromCurrentSource;
+	}
+
+	@Override
+	public void reset() {
+		currentSource = markedSource;
+		bytesRead = bytesReadFromCurrentSource = bytesReadFromMarkedSource;
+
+		// Restore the CRC to the value is was on mark.
+		crc32.reset();
+		if (currentSource == bootloaderBytes && softDeviceBytes != null) {
+			crc32.update(softDeviceBytes);
+			bytesRead += softDeviceSize;
+		}
+		crc32.update(currentSource, 0, bytesReadFromCurrentSource);
+	}
+
+	/**
+	 * Resets to the beginning of current stream.
+	 * If SD and BL were updated, the stream will be reset to the beginning.
+	 * If SD and BL were already sent and the current stream was changed to application,
+	 * this method will reset to the beginning of the application stream.
+	 */
+	public void fullReset() {
+		// Reset stream to SoftDevice if SD and BL firmware were given separately
+		if (softDeviceBytes != null && bootloaderBytes != null && currentSource == bootloaderBytes) {
+			currentSource = softDeviceBytes;
+		}
+		// Reset the bytes count to 0
+		bytesReadFromCurrentSource = 0;
+		mark(0);
+		reset();
+	}
+
+	/**
+	 * Returns number of bytes read until now.
+	 */
+	public int getBytesRead() {
+		return bytesRead;
+	}
+
+	/**
+	 * Returns the CRC32 of the part of the firmware that was already read.
+	 *
+	 * @return the CRC
+	 */
+	public long getCrc32() {
+		return crc32.getValue();
+	}
+
+	/**
+	 * Returns the content type based on the content of the ZIP file. The content type may be
+     * truncated using {@link #setContentType(int)}.
+	 *
+	 * @return A bit field of {@link DfuBaseService#TYPE_SOFT_DEVICE TYPE_SOFT_DEVICE},
+     * {@link DfuBaseService#TYPE_BOOTLOADER TYPE_BOOTLOADER} and
+     * {@link DfuBaseService#TYPE_APPLICATION TYPE_APPLICATION}
+	 */
+	public int getContentType() {
+		type = 0;
+		// In Secure DFU the softDeviceSize and bootloaderSize may be 0 if both are in the ZIP file.
+        // The size of each part is embedded in the Init packet.
+		if (softDeviceAndBootloaderBytes != null)
+			type |= DfuBaseService.TYPE_SOFT_DEVICE | DfuBaseService.TYPE_BOOTLOADER;
+		// In Legacy DFU the size of each of these parts was given in the manifest file.
+		if (softDeviceSize > 0)
+			type |= DfuBaseService.TYPE_SOFT_DEVICE;
+		if (bootloaderSize > 0)
+			type |= DfuBaseService.TYPE_BOOTLOADER;
+		if (applicationSize > 0)
+			type |= DfuBaseService.TYPE_APPLICATION;
+		return type;
+	}
+
+	/**
+	 * Truncates the current content type. May be used to hide some files, e.g. to send Soft Device
+     * and Bootloader without Application or only the Application.
+	 *
+	 * @param type the new type.
+	 * @return The final type after truncating.
+	 */
+	public int setContentType(final int type) {
+		this.type = type;
+		// If the new type has Application, but there is no application fw, remove this type bit
+		if ((type & DfuBaseService.TYPE_APPLICATION) > 0 && applicationBytes == null)
+			this.type &= ~DfuBaseService.TYPE_APPLICATION;
+		// If the new type has SD+BL
+		if ((type & (DfuBaseService.TYPE_SOFT_DEVICE | DfuBaseService.TYPE_BOOTLOADER)) == (DfuBaseService.TYPE_SOFT_DEVICE | DfuBaseService.TYPE_BOOTLOADER)) {
+			// but there is no SD, remove the softdevice type bit
+			if (softDeviceBytes == null && softDeviceAndBootloaderBytes == null)
+				this.type &= ~DfuBaseService.TYPE_SOFT_DEVICE;
+			// or there is no BL, remove the bootloader type bit
+			if (bootloaderBytes == null && softDeviceAndBootloaderBytes == null)
+				this.type &= ~DfuBaseService.TYPE_SOFT_DEVICE;
+		} else {
+			// If at least one of SD or B: bit is cleared, but the SD+BL file is set, remove both bits.
+			if (softDeviceAndBootloaderBytes != null)
+				this.type &= ~(DfuBaseService.TYPE_SOFT_DEVICE | DfuBaseService.TYPE_BOOTLOADER);
+		}
+
+		if ((type & (DfuBaseService.TYPE_SOFT_DEVICE | DfuBaseService.TYPE_BOOTLOADER)) > 0 && softDeviceAndBootloaderBytes != null)
+			currentSource = softDeviceAndBootloaderBytes;
+		else if ((type & DfuBaseService.TYPE_SOFT_DEVICE) > 0)
+			currentSource = softDeviceBytes;
+		else if ((type & DfuBaseService.TYPE_BOOTLOADER) > 0)
+			currentSource = bootloaderBytes;
+		else if ((type & DfuBaseService.TYPE_APPLICATION) > 0)
+			currentSource = applicationBytes;
+		bytesReadFromCurrentSource = 0;
+		mark(0);
+		reset();
+		return this.type;
+	}
+
+	/**
+	 * Sets the currentSource to the new file or to <code>null</code> if the last file has been
+     * transmitted.
+	 *
+	 * @return The new source, the same as {@link #currentSource}.
+	 */
+	private byte[] startNextFile() {
+		byte[] ret;
+		if (currentSource == softDeviceBytes && bootloaderBytes != null && (type & DfuBaseService.TYPE_BOOTLOADER) > 0) {
+			ret = currentSource = bootloaderBytes;
+		} else if (currentSource != applicationBytes && applicationBytes != null && (type & DfuBaseService.TYPE_APPLICATION) > 0) {
+			ret = currentSource = applicationBytes;
+		} else {
+			ret = currentSource = null;
+		}
+		bytesReadFromCurrentSource = 0;
+		return ret;
+	}
+
+	/**
+	 * Returns the number of bytes that has not been read yet. This value includes only
+     * firmwares matching the content type set by the constructor or the
+     * {@link #setContentType(int)} method.
+	 */
+	@Override
+	public int available() {
+		// In Secure DFU softdevice and bootloader sizes are not provided in the Init file
+        // (they are encoded inside the Init file instead). The service doesn't send those sizes,
+        // not the whole size of the firmware separately, like it was done in the Legacy DFU.
+		// This method then is just used to log file size.
+
+		// In case of SD+BL in Secure DFU:
+		if (softDeviceAndBootloaderBytes != null && softDeviceSize == 0 && bootloaderSize == 0
+				&& (type & (DfuBaseService.TYPE_SOFT_DEVICE | DfuBaseService.TYPE_BOOTLOADER)) > 0)
+			return softDeviceAndBootloaderBytes.length + applicationImageSize() - bytesRead;
+
+		// Otherwise:
+		return softDeviceImageSize() + bootloaderImageSize() + applicationImageSize() - bytesRead;
+	}
+
+	/**
+	 * Returns the total size of the SoftDevice firmware. In case the firmware was given as a HEX,
+     * this method returns the size of the BIN content of the file.
+	 *
+	 * @return The size of the SoftDevice firmware (BIN part).
+	 */
+	public int softDeviceImageSize() {
+		return (type & DfuBaseService.TYPE_SOFT_DEVICE) > 0 ? softDeviceSize : 0;
+	}
+
+	/**
+	 * Returns the total size of the Bootloader firmware. In case the firmware was given as a HEX,
+     * this method returns the size of the BIN content of the file.
+	 *
+	 * @return The size of the Bootloader firmware (BIN part).
+	 */
+	public int bootloaderImageSize() {
+		return (type & DfuBaseService.TYPE_BOOTLOADER) > 0 ? bootloaderSize : 0;
+	}
+
+	/**
+	 * Returns the total size of the Application firmware. In case the firmware was given as a HEX,
+     * this method returns the size of the BIN content of the file.
+	 *
+	 * @return The size of the Application firmware (BIN part).
+	 */
+	public int applicationImageSize() {
+		return (type & DfuBaseService.TYPE_APPLICATION) > 0 ? applicationSize : 0;
+	}
+
+	/**
+	 * Returns the content of the init file for SoftDevice and/or Bootloader. When both SoftDevice
+     * and Bootloader are present in the ZIP file (as two files using the compatibility mode
+	 * or as one file using the new Distribution packet) the system init contains validation data
+     * for those two files combined (e.g. the CRC value). This method may return
+	 * <code>null</code> if there is no SoftDevice nor Bootloader in the ZIP or the DAT file is
+     * not present there.
+	 *
+	 * @return The content of the init packet for SoftDevice and/or Bootloader.
+	 */
+	public byte[] getSystemInit() {
+		return systemInitBytes;
+	}
+
+	/**
+	 * Returns the content of the init file for the Application or <code>null</code> if no
+     * application file in the ZIP, or the DAT file is not provided.
+	 *
+	 * @return The content of the init packet for Application.
+	 */
+	public byte[] getApplicationInit() {
+		return applicationInitBytes;
+	}
+
+	/**
+	 * This method returns true if the content of the ZIP file may be sent only using Secure DFU.
+	 * The reason may be that the ZIP contains a single bin file with SD and/or BL together with
+     * App, which has to be sent in a single connection.
+	 * Sizes of each component are not given explicitly in the Manifest (even if they are,
+     * they are ignored). They are hidden in the Init Packet instead.
+	 *
+	 * @return True if the content of this ZIP may only be sent using Secure DFU.
+	 */
+	public boolean isSecureDfuRequired() {
+		return manifest != null && manifest.isSecureDfuRequired();
+	}
+}
diff --git a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/HexInputStream.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/HexInputStream.java
similarity index 52%
rename from dfuLibrary/src/main/java/no/nordicsemi/android/dfu/HexInputStream.java
rename to dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/HexInputStream.java
index 9b23654..808f7be 100644
--- a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/HexInputStream.java
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/HexInputStream.java
@@ -1,5 +1,5 @@
-/*************************************************************************************************************************************************
- * Copyright (c) 2015, Nordic Semiconductor
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
@@ -18,11 +18,11 @@
  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- ************************************************************************************************************************************************/
+ */
 
-package no.nordicsemi.android.dfu;
+package no.nordicsemi.android.dfu.internal;
 
-import android.util.Log;
+import androidx.annotation.NonNull;
 
 import java.io.BufferedInputStream;
 import java.io.ByteArrayInputStream;
@@ -30,64 +30,70 @@ import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 
-import no.nordicsemi.android.dfu.exception.HexFileValidationException;
+import no.nordicsemi.android.dfu.DfuSettingsConstants;
+import no.nordicsemi.android.dfu.internal.exception.HexFileValidationException;
 
 /**
- * Reads the binary content from the HEX file using IntelHex standard: http://www.interlog.com/~speff/usefulinfo/Hexfrmt.pdf.
+ * Reads the binary content from the HEX file using IntelHex standard:
+ * http://www.interlog.com/~speff/usefulinfo/Hexfrmt.pdf.
  * Truncates the HEX file from all meta data and returns only the BIN content.
  * <p>
- * In nRF51 chips memory a SoftDevice starts at address 0x1000. From 0x0000 to 0x1000 there is MBR sector (since SoftDevice 7.0.0) which should not be transmitted using DFU. Therefore this class skips
- * all data from addresses below 0x1000.
- * </p>
+ * In nRF51 chips memory a SoftDevice starts at address 0x1000. From 0x0000 to 0x1000 there is
+ * MBR sector (since SoftDevice 7.0.0) which should not be transmitted using DFU. Therefore this
+ * class skips all data from addresses below 0x1000.
  */
+@SuppressWarnings({"WeakerAccess", "unused"})
 public class HexInputStream extends FilterInputStream {
 	private final int LINE_LENGTH = 128;
 
 	private final byte[] localBuf;
+	private final int available;
 	private int localPos;
 	private int pos;
 	private int size;
 	private int lastAddress;
-	private int available, bytesRead;
+	private int bytesRead;
 	private final int MBRSize;
 
+    public static final int APP_CODE_BASE_START = 0x18000;
+    public static final int APP_CODE_BASE_END = 0x3BBFF;
 
-    protected HexInputStream(final InputStream in) throws HexFileValidationException, IOException {
-        super(new BufferedInputStream(in));
-        this.localBuf = new byte[LINE_LENGTH];
-        this.localPos = LINE_LENGTH; // we are at the end of the local buffer, new one must be obtained
-        this.size = localBuf.length;
-        this.lastAddress = 0;
-        this.MBRSize = -1;
-        this.available = calculateBinSizeAlternative();
-        Log.d("HexInputStrem", "calculateBinSizeAlternative = " + this.available/1024 + "Kb");
-    }
+	/**
+	 * Creates the HEX Input Stream. The constructor calculates the size of the BIN content which
+	 * is available through {@link #sizeInBytes()}. If HEX file is invalid then the bin size is 0.
+	 *
+	 * @param in      the input stream to read from.
+	 * @param mbrSize the MBR (Master Boot Record) size in bytes. Data with addresses below than
+	 *                number will be trimmed and not transferred to DFU target.
+	 * @throws HexFileValidationException if HEX file is invalid, e.g. there is no semicolon (':')
+	 *                                    on the beginning of each line.
+	 * @throws IOException                if the stream is closed or another IOException occurs.
+	 */
+	public HexInputStream(@NonNull final InputStream in, final int mbrSize)
+			throws HexFileValidationException, IOException {
+		super(new BufferedInputStream(in));
+		this.localBuf = new byte[LINE_LENGTH];
+		this.localPos = LINE_LENGTH; // we are at the end of the local buffer, new one must be obtained
+		this.size = localBuf.length;
+		this.lastAddress = 0;
+		this.MBRSize = mbrSize;
 
-    /**
-     * Creates the HEX Input Stream. The constructor calculates the size of the BIN content which is available through {@link #sizeInBytes()}. If HEX file is invalid then the bin size is 0.
-     *
-     * @param in
-     *            the input stream to read from
-     * @param mbrSize
-     *            The MBR (Master Boot Record) size in bytes. Data with addresses below than number will be trimmed and not transferred to DFU target.
-     * @throws HexFileValidationException
-     *             if HEX file is invalid. F.e. there is no semicolon (':') on the beginning of each line.
-     * @throws java.io.IOException
-     *             if the stream is closed or another IOException occurs.
-     */
-    protected HexInputStream(final InputStream in, final int mbrSize) throws HexFileValidationException, IOException {
-        super(new BufferedInputStream(in));
-        this.localBuf = new byte[LINE_LENGTH];
-        this.localPos = LINE_LENGTH; // we are at the end of the local buffer, new one must be obtained
-        this.size = localBuf.length;
-        this.lastAddress = 0;
-        this.MBRSize = mbrSize;
-
-        this.available = calculateBinSize(mbrSize);
-        Log.d("HexInputStrem", "calculateBinSize = " + this.available/1024 + "Kb");
-    }
+		this.available = calculateBinSizeAlternative();
+	}
 
-	protected HexInputStream(final byte[] data, final int mbrSize) throws HexFileValidationException, IOException {
+	/**
+	 * Creates the HEX Input Stream. The constructor calculates the size of the BIN content which
+	 * is available through {@link #sizeInBytes()}. If HEX file is invalid then the bin size is 0.
+	 *
+	 * @param data    the input stream to read from.
+	 * @param mbrSize the MBR (Master Boot Record) size in bytes. Data with addresses below than
+	 * 	 *                number will be trimmed and not transferred to DFU target.
+	 * @throws HexFileValidationException if HEX file is invalid, e.g. there is no semicolon (':')
+	 *                                    on the beginning of each line.
+	 * @throws IOException                if the stream is closed or another IOException occurs.
+	 */
+	public HexInputStream(@NonNull final byte[] data, final int mbrSize)
+			throws HexFileValidationException, IOException {
 		super(new ByteArrayInputStream(data));
 		this.localBuf = new byte[LINE_LENGTH];
 		this.localPos = LINE_LENGTH; // we are at the end of the local buffer, new one must be obtained
@@ -95,8 +101,77 @@ public class HexInputStream extends FilterInputStream {
 		this.lastAddress = 0;
 		this.MBRSize = mbrSize;
 
-		this.available = calculateBinSize(mbrSize);
-        Log.d("HexInputStrem", "calculateBinSize = " + this.available/1024 + "Kb");
+		this.available = calculateBinSizeAlternative();
+	}
+
+	@SuppressWarnings("DuplicateThrows")
+	private int calculateBinSize(final int mbrSize) throws HexFileValidationException, IOException {
+		int binSize = 0;
+		final InputStream in = this.in;
+		in.mark(in.available());
+
+		int b, lineSize, offset, type;
+		int lastBaseAddress = 0; // last Base Address, default 0 
+		int lastAddress;
+		try {
+			b = in.read();
+			while (true) {
+				checkComma(b);
+
+				lineSize = readByte(in); // reading the length of the data in this line
+				offset = readAddress(in);// reading the offset
+				type = readByte(in); // reading the line type
+				switch (type) {
+					case 0x01:
+						// end of file
+						return binSize;
+					case 0x04: {
+						// extended linear address record
+						/*
+						 * The HEX file may contain jump to different addresses.
+						 * The MSB of LBA (Linear Base Address) is given using the line type 4.
+						 * We only support files where bytes are located together, no jumps are
+						 * allowed. Therefore the newULBA may be only lastULBA + 1 (or any,
+						 * if this is the first line of the HEX)
+						 */
+						final int newULBA = readAddress(in);
+						if (binSize > 0 && newULBA != (lastBaseAddress >> 16) + 1)
+							return binSize;
+						lastBaseAddress = newULBA << 16;
+						skip(in, 2 /* check sum */);
+						break;
+					}
+					case 0x02: {
+						// extended segment address record
+						final int newSBA = readAddress(in) << 4;
+						if (binSize > 0 && (newSBA >> 16) != (lastBaseAddress >> 16) + 1)
+							return binSize;
+						lastBaseAddress = newSBA;
+						skip(in, 2 /* check sum */);
+						break;
+					}
+					case 0x00:
+						// data type line
+						lastAddress = lastBaseAddress + offset;
+						// we must skip all data from below last MBR address (default 0x1000)
+						// as those are the MBR. The Soft Device starts at the end of MBR (0x1000),
+						// the app and bootloader farther more
+						if (lastAddress >= mbrSize)
+							binSize += lineSize;
+						// no break!
+					default:
+						final long toBeSkipped = lineSize * 2L /* 2 hex per one byte */ + 2 /* check sum */;
+						skip(in, toBeSkipped);
+						break;
+				}
+				// skip end of line
+				do {
+					b = in.read();
+				} while (b == '\n' || b == '\r');
+			}
+		} finally {
+			in.reset();
+		}
 	}
 
     private int calculateBinSizeAlternative() throws IOException {
@@ -121,15 +196,15 @@ public class HexInputStream extends FilterInputStream {
                         return binSize;
                     case 0x04: {
                         // extended linear address record
-					/*
-					 * The HEX file may contain jump to different addresses. The MSB of LBA (Linear Base Address) is given using the line type 4.
-					 * We only support files where bytes are located together, no jumps are allowed. Therefore the newULBA may be only lastULBA + 1 (or any, if this is the first line of the HEX)
-					 */
+                        /*
+                         * The HEX file may contain jump to different addresses. The MSB of LBA (Linear Base Address) is given using the line type 4.
+                         * We only support files where bytes are located together, no jumps are allowed. Therefore the newULBA may be only lastULBA + 1 (or any, if this is the first line of the HEX)
+                         */
                         final int newULBA = readAddress(in);
                         if (binSize > 0 && newULBA != (lastBaseAddress >> 16) + 1)
                             return binSize;
                         lastBaseAddress = newULBA << 16;
-						skip(in, 2 /* check sum */);
+                        skip(in, 2 /* check sum */);
                         break;
                     }
                     case 0x02: {
@@ -144,106 +219,26 @@ public class HexInputStream extends FilterInputStream {
                     case 0x00:
                         // data type line
                         lastAddress = lastBaseAddress + offset;
-                        if (lastAddress >= DfuSettingsConstants.APP_CODE_BASE_START && lastAddress < DfuSettingsConstants.APP_CODE_BASE_END)
+                        if (lastAddress >= APP_CODE_BASE_START && lastAddress < APP_CODE_BASE_END)
                         {
                             //Log.d("HexInputStrem", "Found FOTA Start address");
                             binSize += lineSize;
                         }
                         // no break!
                     default:
-                        skip(in, lineSize * 2 /* 2 hex per one byte */+ 2 /* check sum */);
+                        skip(in, lineSize * 2L /* 2 hex per one byte */+ 2 /* check sum */);
                         break;
                 }
                 // skip end of line
-                while (true) {
+                do {
                     b = in.read();
-
-                    if (b != '\n' && b != '\r') {
-                        break;
-                    }
-                }
+                } while (b == '\n' || b == '\r');
             }
         } finally {
             in.reset();
         }
     }
 
-    private int calculateBinSize(final int mbrSize) throws IOException {
-		int binSize = 0;
-		final InputStream in = this.in;
-		in.mark(in.available());
-
-		int b, lineSize, offset, type;
-		int lastBaseAddress = 0; // last Base Address, default 0 
-		int lastAddress;
-		try {
-			b = in.read();
-			while (true) {
-				checkComma(b);
-
-				lineSize = readByte(in); // reading the length of the data in this line
-				offset = readAddress(in);// reading the offset
-				type = readByte(in); // reading the line type
-				switch (type) {
-				case 0x01:
-					// end of file
-					return binSize;
-				case 0x04: {
-					// extended linear address record
-					/*
-					 * The HEX file may contain jump to different addresses. The MSB of LBA (Linear Base Address) is given using the line type 4.
-					 * We only support files where bytes are located together, no jumps are allowed. Therefore the newULBA may be only lastULBA + 1 (or any, if this is the first line of the HEX)
-					 */
-					final int newULBA = readAddress(in);
-					if (binSize > 0 && newULBA != (lastBaseAddress >> 16) + 1)
-						return binSize;
-					lastBaseAddress = newULBA << 16;
-					skip(in, 2 /* check sum */);
-					break;
-				}
-				case 0x02: {
-					// extended segment address record
-					final int newSBA = readAddress(in) << 4;
-					if (binSize > 0 && (newSBA >> 16) != (lastBaseAddress >> 16) + 1)
-						return binSize;
-					lastBaseAddress = newSBA;
-					skip(in, 2 /* check sum */);
-					break;
-				}
-				case 0x00:
-					// data type line
- 					lastAddress = lastBaseAddress + offset;
-					if (lastAddress >= mbrSize) // we must skip all data from below last MBR address (default 0x1000) as those are the MBR. The Soft Device starts at the end of MBR (0x1000), the app and bootloader farther more
-						binSize += lineSize;
-					// no break!
-				default:
-					skip(in, lineSize * 2 /* 2 hex per one byte */ + 2 /* check sum */);
-					break;
-				}
-				// skip end of line
-				while (true) {
-					b = in.read();
-
-					if (b != '\n' && b != '\r') {
-						break;
-					}
-				}
-			}
-		} finally {
-			in.reset();
-		}
-	}
-
-    private long skip(final InputStream in, final long offset) throws IOException {
-        long skipped = in.skip(offset);
-		int attempts = 10;
-        // try to skip 10 times as skip(..) method does not guarantee to skip exactly given number of bytes
-        while (skipped < offset && attempts > 0) {
-			skipped += in.skip(offset - skipped);
-			attempts--;
-		}
-        return skipped;
-    }
 
 	@Override
 	public int available() {
@@ -252,11 +247,11 @@ public class HexInputStream extends FilterInputStream {
 
 	/**
 	 * Fills the buffer with next bytes from the stream.
-	 * 
+	 *
+	 * @param buffer buffer to be filled
 	 * @return the size of the buffer
-	 * @throws java.io.IOException
 	 */
-	public int readPacket(byte[] buffer) throws HexFileValidationException, IOException {
+	public int readPacket(@NonNull byte[] buffer) throws IOException {
 		int i = 0;
 		while (i < buffer.length) {
 			if (localPos < size) {
@@ -272,23 +267,23 @@ public class HexInputStream extends FilterInputStream {
 	}
 
 	@Override
-	public int read() throws IOException {
+	public int read() {
 		throw new UnsupportedOperationException("Please, use readPacket() method instead");
 	}
 
 	@Override
-	public int read(byte[] buffer) throws IOException {
+	public int read(@NonNull byte[] buffer) throws IOException {
 		return readPacket(buffer);
 	}
 
 	@Override
-	public int read(byte[] buffer, int offset, int count) throws IOException {
+	public int read(@NonNull byte[] buffer, int offset, int count) {
 		throw new UnsupportedOperationException("Please, use readPacket() method instead");
 	}
 
 	/**
 	 * Returns the total number of bytes.
-	 * 
+	 *
 	 * @return total number of bytes available
 	 */
 	public int sizeInBytes() {
@@ -296,25 +291,24 @@ public class HexInputStream extends FilterInputStream {
 	}
 
 	/**
-	 * Returns the total number of packets with given size that are needed to get all available data
-	 * 
-	 * @param packetSize
-	 *            the maximum packet size
+	 * Returns the total number of packets with given size that are needed to get all
+	 * available data.
+	 *
+	 * @param packetSize the maximum packet size
 	 * @return the number of packets needed to get all the content
-	 * @throws java.io.IOException
 	 */
-	public int sizeInPackets(final int packetSize) throws IOException {
+	public int sizeInPackets(final int packetSize) {
 		final int sizeInBytes = sizeInBytes();
 
 		return sizeInBytes / packetSize + ((sizeInBytes % packetSize) > 0 ? 1 : 0);
 	}
 
 	/**
-	 * Reads new line from the input stream. Input stream must be a HEX file. The first line is always skipped.
-	 * 
+	 * Reads new line from the input stream. Input stream must be a HEX file.
+	 * The first line is always skipped.
+	 *
 	 * @return the number of data bytes in the new line. 0 if end of file.
-	 * @throws java.io.IOException
-	 *             if this stream is closed or another IOException occurs.
+	 * @throws java.io.IOException if this stream is closed or another IOException occurs.
 	 */
 	private int readLine() throws IOException {
 		// end of file reached
@@ -328,23 +322,21 @@ public class HexInputStream extends FilterInputStream {
 		int lineSize, type, offset;
 		do {
 			// skip end of line
-			while (true) {
+			do {
 				b = in.read();
 				pos++;
-
-				if (b != '\n' && b != '\r') {
-					break;
-				}
-			}
+			} while (b == '\n' || b == '\r');
 
 			/*
 			 * Each line starts with comma (':')
 			 * Data is written in HEX, so each 2 ASCII letters give one byte.
-			 * After the comma there is one byte (2 HEX signs) with line length (normally 10 -> 0x10 -> 16 bytes -> 32 HEX characters)
+			 * After the comma there is one byte (2 HEX signs) with line length
+			 * (normally 10 -> 0x10 -> 16 bytes -> 32 HEX characters)
 			 * After that there is a 4 byte of an address. This part may be skipped.
-			 * There is a packet type after the address (1 byte = 2 HEX characters). 00 is the valid data. Other values can be skipped when
-			 * converting to BIN file.
-			 * Then goes n bytes of data followed by 1 byte (2 HEX chars) of checksum, which is also skipped in BIN file.
+			 * There is a packet type after the address (1 byte = 2 HEX characters).
+			 * 00 is the valid data. Other values can be skipped when converting to BIN file.
+			 * Then goes n bytes of data followed by 1 byte (2 HEX chars) of checksum,
+			 * which is also skipped in BIN file.
 			 */
 			checkComma(b); // checking the comma at the beginning
 			lineSize = readByte(in); // reading the length of the data in this line
@@ -356,49 +348,41 @@ public class HexInputStream extends FilterInputStream {
 
 			// if the line type is no longer data type (0x00), we've reached the end of the file
 			switch (type) {
-			case 0x00:
-				// data type
-                if (MBRSize == -1){ //This is for fixed address case
-                    int fullAddress = lastAddress + offset ;
-                    if (fullAddress < DfuSettingsConstants.APP_CODE_BASE_START || fullAddress >= DfuSettingsConstants.APP_CODE_BASE_END){ //Skip Non Fota
-                        type = -1; // some other than 0
-                        pos += skip(in, lineSize * 2 /* 2 hex per one byte */ + 2 /* check sum */);
-                    }
-
-                } else {
-                    if (lastAddress + offset < MBRSize) { // skip MBR
-                        type = -1; // some other than 0
-                        pos += skip(in, lineSize * 2 /* 2 hex per one byte */ + 2 /* check sum */);
-                    }
-                }
-				break;
-			case 0x01:
-				// end of file
-				pos = -1;
-				return 0;
-			case 0x02: {
-				// extended segment address
-				final int address = readAddress(in) << 4;
-				pos += 4;
-				if (bytesRead > 0 && (address >> 16) != (lastAddress >> 16) + 1)
-					return 0;
-				lastAddress = address;
-				pos += skip(in, 2 /* check sum */);
-				break;
-			}
-			case 0x04: {
-				// extended linear address
-				final int address = readAddress(in);
-				pos += 4;
-				if (bytesRead > 0 && address != (lastAddress >> 16) + 1)
+				case 0x00:
+					// data type
+					if (lastAddress + offset < MBRSize) { // skip MBR
+						type = -1; // some other than 0
+						pos += skip(in, lineSize * 2L /* 2 hex per one byte */ + 2 /* check sum */);
+					}
+					break;
+				case 0x01:
+					// end of file
+					pos = -1;
 					return 0;
-				lastAddress = address << 16;
-				pos += skip(in, 2 /* check sum */);
-				break;
-			}
-			default:
-				pos += skip(in, lineSize * 2 /* 2 hex per one byte */ + 2 /* check sum */);
-				break;
+				case 0x02: {
+					// extended segment address
+					final int address = readAddress(in) << 4;
+					pos += 4;
+					if (bytesRead > 0 && (address >> 16) != (lastAddress >> 16) + 1)
+						return 0;
+					lastAddress = address;
+					pos += skip(in, 2 /* check sum */);
+					break;
+				}
+				case 0x04: {
+					// extended linear address
+					final int address = readAddress(in);
+					pos += 4;
+					if (bytesRead > 0 && address != (lastAddress >> 16) + 1)
+						return 0;
+					lastAddress = address << 16;
+					pos += skip(in, 2 /* check sum */);
+					break;
+				}
+				default:
+					final long toBeSkipped = lineSize * 2L /* 2 hex per one byte */ + 2 /* check sum */;
+					pos += skip(in, toBeSkipped);
+					break;
 			}
 		} while (type != 0);
 
@@ -414,13 +398,22 @@ public class HexInputStream extends FilterInputStream {
 		return lineSize;
 	}
 
+	@Override
+	public synchronized void mark(final int readlimit) {
+		try {
+			super.mark(in.available());
+		} catch (final IOException e) {
+			// ignore
+		}
+	}
+
 	@Override
 	public synchronized void reset() throws IOException {
 		super.reset();
 
 		pos = 0;
 		bytesRead = 0;
-		localPos = 0;
+		localPos = LINE_LENGTH; // we are at the end of the local buffer, new one must be obtained
 	}
 
 	private void checkComma(final int comma) throws HexFileValidationException {
@@ -428,14 +421,23 @@ public class HexInputStream extends FilterInputStream {
 			throw new HexFileValidationException("Not a HEX file");
 	}
 
-	private int readByte(final InputStream in) throws IOException {
+	private long skip(@NonNull final InputStream in, final long offset) throws IOException {
+		long skipped = in.skip(offset);
+		// try to skip 2 times as skip(..) method does not guarantee to skip exactly
+		// given number of bytes
+		if (skipped < offset)
+			skipped += in.skip(offset - skipped);
+		return skipped;
+	}
+
+	private int readByte(@NonNull final InputStream in) throws IOException {
 		final int first = asciiToInt(in.read());
 		final int second = asciiToInt(in.read());
 
 		return first << 4 | second;
 	}
 
-	private int readAddress(final InputStream in) throws IOException {
+	private int readAddress(@NonNull final InputStream in) throws IOException {
 		return readByte(in) << 8 | readByte(in);
 	}
 
diff --git a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/exception/DeviceDisconnectedException.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/DeviceDisconnectedException.java
similarity index 71%
rename from dfuLibrary/src/main/java/no/nordicsemi/android/dfu/exception/DeviceDisconnectedException.java
rename to dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/DeviceDisconnectedException.java
index 628f228..b4f5426 100644
--- a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/exception/DeviceDisconnectedException.java
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/DeviceDisconnectedException.java
@@ -1,5 +1,5 @@
-/*************************************************************************************************************************************************
- * Copyright (c) 2015, Nordic Semiconductor
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
@@ -18,9 +18,9 @@
  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- ************************************************************************************************************************************************/
+ */
 
-package no.nordicsemi.android.dfu.exception;
+package no.nordicsemi.android.dfu.internal.exception;
 
 /**
  * Device has disconnected.
@@ -28,20 +28,7 @@ package no.nordicsemi.android.dfu.exception;
 public class DeviceDisconnectedException extends Exception {
 	private static final long serialVersionUID = -6901728550661937942L;
 
-	private final int mState;
-
-	public DeviceDisconnectedException(final String message, final int state) {
+	public DeviceDisconnectedException(final String message) {
 		super(message);
-
-		mState = state;
-	}
-
-	public int getConnectionState() {
-		return mState;
-	}
-
-	@Override
-	public String getMessage() {
-		return super.getMessage() + " (connection state: " + mState + ")";
 	}
 }
diff --git a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/exception/DfuException.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/DfuException.java
similarity index 84%
rename from dfuLibrary/src/main/java/no/nordicsemi/android/dfu/exception/DfuException.java
rename to dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/DfuException.java
index c8ba777..322c522 100644
--- a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/exception/DfuException.java
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/DfuException.java
@@ -1,5 +1,5 @@
-/*************************************************************************************************************************************************
- * Copyright (c) 2015, Nordic Semiconductor
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
@@ -18,9 +18,9 @@
  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- ************************************************************************************************************************************************/
+ */
 
-package no.nordicsemi.android.dfu.exception;
+package no.nordicsemi.android.dfu.internal.exception;
 
 import no.nordicsemi.android.dfu.DfuBaseService;
 
diff --git a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/exception/HexFileValidationException.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/HexFileValidationException.java
similarity index 82%
rename from dfuLibrary/src/main/java/no/nordicsemi/android/dfu/exception/HexFileValidationException.java
rename to dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/HexFileValidationException.java
index 3253894..008cb9c 100644
--- a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/exception/HexFileValidationException.java
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/HexFileValidationException.java
@@ -1,5 +1,5 @@
-/*************************************************************************************************************************************************
- * Copyright (c) 2015, Nordic Semiconductor
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
@@ -18,9 +18,9 @@
  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- ************************************************************************************************************************************************/
+ */
 
-package no.nordicsemi.android.dfu.exception;
+package no.nordicsemi.android.dfu.internal.exception;
 
 import java.io.IOException;
 
diff --git a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/exception/RemoteDfuException.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/RemoteDfuException.java
similarity index 83%
rename from dfuLibrary/src/main/java/no/nordicsemi/android/dfu/exception/RemoteDfuException.java
rename to dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/RemoteDfuException.java
index 88d1001..59b6496 100644
--- a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/exception/RemoteDfuException.java
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/RemoteDfuException.java
@@ -1,5 +1,5 @@
-/*************************************************************************************************************************************************
- * Copyright (c) 2015, Nordic Semiconductor
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
@@ -18,9 +18,9 @@
  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- ************************************************************************************************************************************************/
+ */
 
-package no.nordicsemi.android.dfu.exception;
+package no.nordicsemi.android.dfu.internal.exception;
 
 /**
  * A DFU error occurred on the remote DFU target.
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/RemoteDfuExtendedErrorException.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/RemoteDfuExtendedErrorException.java
new file mode 100644
index 0000000..d7d0a35
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/RemoteDfuExtendedErrorException.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.dfu.internal.exception;
+
+import no.nordicsemi.android.error.SecureDfuError;
+
+/**
+ * A DFU error occurred on the remote DFU target.
+ */
+public class RemoteDfuExtendedErrorException extends RemoteDfuException {
+	private static final long serialVersionUID = -6901728550661937942L;
+
+	private final int mError;
+
+	public RemoteDfuExtendedErrorException(final String message, final int extendedError) {
+		super(message, SecureDfuError.EXTENDED_ERROR);
+
+		mError = extendedError;
+	}
+
+	public int getExtendedErrorNumber() {
+		return mError;
+	}
+
+	@Override
+	public String getMessage() {
+		return super.getMessage() + " (extended error " + mError + ")";
+	}
+}
diff --git a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/manifest/Manifest.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/SizeValidationException.java
similarity index 69%
rename from dfuLibrary/src/main/java/no/nordicsemi/android/dfu/manifest/Manifest.java
rename to dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/SizeValidationException.java
index 17b133c..1961b5a 100644
--- a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/manifest/Manifest.java
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/SizeValidationException.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, Nordic Semiconductor
+ * Copyright (c) 2018, Nordic Semiconductor
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
@@ -20,29 +20,18 @@
  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package no.nordicsemi.android.dfu.manifest;
+package no.nordicsemi.android.dfu.internal.exception;
 
-import com.google.gson.annotations.SerializedName;
+import java.io.IOException;
 
-public class Manifest {
-	protected FileInfo application;
-	protected FileInfo bootloader;
-	protected FileInfo softdevice;
-	@SerializedName("softdevice_bootloader") protected SoftDeviceBootloaderFileInfo softdeviceBootloader;
-
-	public FileInfo getApplicationInfo() {
-		return application;
-	}
-
-	public FileInfo getBootloaderInfo() {
-		return bootloader;
-	}
-
-	public FileInfo getSoftdeviceInfo() {
-		return softdevice;
-	}
+/**
+ * This exception is thrown when the firmware size is not word-aligned (number of bytes does not divide by 4).
+ * This is the requirement for the DFU Bootloader.
+ */
+public class SizeValidationException extends IOException {
+	private static final long serialVersionUID = -6467104024030837875L;
 
-	public SoftDeviceBootloaderFileInfo getSoftdeviceBootloaderInfo() {
-		return softdeviceBootloader;
+	public SizeValidationException(final String message) {
+		super(message);
 	}
 }
diff --git a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/exception/UnknownResponseException.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/UnknownResponseException.java
similarity index 81%
rename from dfuLibrary/src/main/java/no/nordicsemi/android/dfu/exception/UnknownResponseException.java
rename to dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/UnknownResponseException.java
index 813db50..cb67a13 100644
--- a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/exception/UnknownResponseException.java
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/UnknownResponseException.java
@@ -1,5 +1,5 @@
-/*************************************************************************************************************************************************
- * Copyright (c) 2015, Nordic Semiconductor
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
@@ -18,27 +18,31 @@
  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- ************************************************************************************************************************************************/
+ */
 
-package no.nordicsemi.android.dfu.exception;
+package no.nordicsemi.android.dfu.internal.exception;
+
+import java.util.Locale;
 
 public class UnknownResponseException extends Exception {
 	private static final long serialVersionUID = -8716125467309979289L;
 	private static final char[] HEX_ARRAY = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
 
 	private final byte[] mResponse;
+	private final int mExpectedReturnCode;
 	private final int mExpectedOpCode;
 
-	public UnknownResponseException(final String message, final byte[] response, final int expectedOpCode) {
+	public UnknownResponseException(final String message, final byte[] response, final int expectedReturnCode, final int expectedOpCode) {
 		super(message);
 
 		mResponse = response != null ? response : new byte[0];
+		mExpectedReturnCode = expectedReturnCode;
 		mExpectedOpCode = expectedOpCode;
 	}
 
 	@Override
 	public String getMessage() {
-		return String.format("%s (response: %s, expected: 0x10%02X..)", super.getMessage(), bytesToHex(mResponse, 0, mResponse.length), mExpectedOpCode);
+		return String.format(Locale.US, "%s (response: %s, expected: 0x%02X%02X..)", super.getMessage(), bytesToHex(mResponse, 0, mResponse.length), mExpectedReturnCode, mExpectedOpCode);
 	}
 
 	public static String bytesToHex(final byte[] bytes, final int start, final int length) {
diff --git a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/exception/UploadAbortedException.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/UploadAbortedException.java
similarity index 81%
rename from dfuLibrary/src/main/java/no/nordicsemi/android/dfu/exception/UploadAbortedException.java
rename to dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/UploadAbortedException.java
index 8f3a02b..d4cb540 100644
--- a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/exception/UploadAbortedException.java
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/UploadAbortedException.java
@@ -1,5 +1,5 @@
-/*************************************************************************************************************************************************
- * Copyright (c) 2015, Nordic Semiconductor
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
@@ -18,9 +18,9 @@
  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- ************************************************************************************************************************************************/
+ */
 
-package no.nordicsemi.android.dfu.exception;
+package no.nordicsemi.android.dfu.internal.exception;
 
 public class UploadAbortedException extends Exception {
 	private static final long serialVersionUID = -6901728550661937942L;
diff --git a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/manifest/FileInfo.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/manifest/FileInfo.java
similarity index 82%
rename from dfuLibrary/src/main/java/no/nordicsemi/android/dfu/manifest/FileInfo.java
rename to dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/manifest/FileInfo.java
index 26916c2..0fad05b 100644
--- a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/manifest/FileInfo.java
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/manifest/FileInfo.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, Nordic Semiconductor
+ * Copyright (c) 2018, Nordic Semiconductor
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
@@ -20,14 +20,13 @@
  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package no.nordicsemi.android.dfu.manifest;
+package no.nordicsemi.android.dfu.internal.manifest;
 
 import com.google.gson.annotations.SerializedName;
 
 public class FileInfo {
-	@SerializedName("bin_file") protected String binFile;
-	@SerializedName("dat_file") protected String datFile;
-	@SerializedName("init_packet_data") protected InitPacketData initPacketData;
+	@SerializedName("bin_file") private String binFile;
+	@SerializedName("dat_file") private String datFile;
 
 	public String getBinFileName() {
 		return binFile;
@@ -36,8 +35,4 @@ public class FileInfo {
 	public String getDatFileName() {
 		return datFile;
 	}
-
-	public InitPacketData getInitPacketData() {
-		return initPacketData;
-	}
 }
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/manifest/Manifest.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/manifest/Manifest.java
new file mode 100644
index 0000000..fa17deb
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/manifest/Manifest.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.dfu.internal.manifest;
+
+import com.google.gson.annotations.SerializedName;
+
+@SuppressWarnings("unused")
+public class Manifest {
+	private FileInfo application;
+	private FileInfo bootloader;
+	private FileInfo softdevice;
+	@SerializedName("softdevice_bootloader")
+	private SoftDeviceBootloaderFileInfo softdeviceBootloader;
+
+	// The following options are available only in some implementations of Secure DFU and will be sent as application (in a single connection).
+	// The service is not aware of sizes of each component in the bin file. This information is hidden in the Init Packet.
+	@SerializedName("bootloader_application")
+	private FileInfo bootloaderApplication;
+	@SerializedName("softdevice_application")
+	private FileInfo softdeviceApplication;
+	@SerializedName("softdevice_bootloader_application")
+	private FileInfo softdeviceBootloaderApplication;
+
+	public FileInfo getApplicationInfo() {
+		if (application != null)
+			return application;
+		// The other parts will be sent together with application, so they may be returned here.
+		if (softdeviceApplication != null)
+			return softdeviceApplication;
+		if (bootloaderApplication != null)
+			return bootloaderApplication;
+		return softdeviceBootloaderApplication;
+	}
+
+	public FileInfo getBootloaderInfo() {
+		return bootloader;
+	}
+
+	public FileInfo getSoftdeviceInfo() {
+		return softdevice;
+	}
+
+	public SoftDeviceBootloaderFileInfo getSoftdeviceBootloaderInfo() {
+		return softdeviceBootloader;
+	}
+
+	public boolean isSecureDfuRequired() {
+		// Legacy DFU requires sending firmware type together with Start DFU command.
+		// The following options were not supported by the legacy bootloader,
+		// but in some implementations they are supported in Secure DFU.
+		// In Secure DFU the fw type is provided in the Init packet.
+		return bootloaderApplication != null || softdeviceApplication != null || softdeviceBootloaderApplication != null;
+	}
+}
diff --git a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/manifest/ManifestFile.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/manifest/ManifestFile.java
similarity index 91%
rename from dfuLibrary/src/main/java/no/nordicsemi/android/dfu/manifest/ManifestFile.java
rename to dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/manifest/ManifestFile.java
index 991c347..8961b7b 100644
--- a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/manifest/ManifestFile.java
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/manifest/ManifestFile.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, Nordic Semiconductor
+ * Copyright (c) 2018, Nordic Semiconductor
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
@@ -20,10 +20,11 @@
  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package no.nordicsemi.android.dfu.manifest;
+package no.nordicsemi.android.dfu.internal.manifest;
 
+@SuppressWarnings("unused")
 public class ManifestFile {
-	protected Manifest manifest;
+	private Manifest manifest;
 
 	public Manifest getManifest() {
 		return manifest;
diff --git a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/manifest/SoftDeviceBootloaderFileInfo.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/manifest/SoftDeviceBootloaderFileInfo.java
similarity index 89%
rename from dfuLibrary/src/main/java/no/nordicsemi/android/dfu/manifest/SoftDeviceBootloaderFileInfo.java
rename to dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/manifest/SoftDeviceBootloaderFileInfo.java
index 7543106..969d6c5 100644
--- a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/manifest/SoftDeviceBootloaderFileInfo.java
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/manifest/SoftDeviceBootloaderFileInfo.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, Nordic Semiconductor
+ * Copyright (c) 2018, Nordic Semiconductor
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
@@ -20,13 +20,13 @@
  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package no.nordicsemi.android.dfu.manifest;
+package no.nordicsemi.android.dfu.internal.manifest;
 
 import com.google.gson.annotations.SerializedName;
 
 public class SoftDeviceBootloaderFileInfo extends FileInfo {
-	@SerializedName("bl_size") protected int bootloaderSize;
-	@SerializedName("sd_size") protected int softdeviceSize;
+	@SerializedName("bl_size") private int bootloaderSize;
+	@SerializedName("sd_size") private int softdeviceSize;
 
 	public int getSoftdeviceSize() {
 		return softdeviceSize;
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/scanner/BootloaderScanner.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/scanner/BootloaderScanner.java
new file mode 100644
index 0000000..9f27ff0
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/scanner/BootloaderScanner.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.dfu.internal.scanner;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import no.nordicsemi.android.dfu.DfuDeviceSelector;
+
+/**
+ * <p>
+ * The DFU Bootloader may advertise with the same address as an application or one incremented by 1.
+ * This depends on the bootloader configuration. If buttonless service is used and the device is
+ * bonded, the address is usually preserved, otherwise it is incremented by 1.
+ * Check out <code>NRF_DFU_BLE_REQUIRES_BONDS</code> define in the sdk_config.
+ * Also, when the SD is updated, the bootloader will use the incremented address, as bond info
+ * were erased together with the old application.
+ * <p>
+ * The DFU service always connects to the address given as a parameter. However, when flashing
+ * SD+BL+App it will first send the SD+BL as part one followed by the App in the second connection.
+ * As the service does not know which address was used in the first connection (normal,
+ * when buttonless update, or +1 when with-button update) we have to scan for the advertising
+ * device after SD+BL part is completed.
+ */
+public interface BootloaderScanner {
+	/**
+	 * Searches for the advertising bootloader. The bootloader may advertise with the same device
+	 * address or one with the last byte incremented by 1.
+	 * This method is a blocking one and ends when such device is found. There are two
+	 * implementations of this interface - one for Androids 4.3 and 4.4.x and one for the
+	 * Android 5+ devices.
+	 *
+	 * @param selector the device selector
+	 * @param timeout the scanning timeout, in milliseconds
+	 * @return the address of the advertising DFU bootloader. It may be the same as the application
+	 * address or one with the last byte incremented by 1 (AA:BB:CC:DD:EE:45/FF -&gt; AA:BB:CC:DD:EE:46/00).
+	 * Null is returned when Bluetooth is off or the device has not been found.
+	 */
+	@Nullable
+	String searchUsing(final @NonNull DfuDeviceSelector selector, final long timeout);
+}
diff --git a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/manifest/InitPacketData.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/scanner/BootloaderScannerFactory.java
similarity index 50%
rename from dfuLibrary/src/main/java/no/nordicsemi/android/dfu/manifest/InitPacketData.java
rename to dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/scanner/BootloaderScannerFactory.java
index c6f67f3..0dbfba8 100644
--- a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/manifest/InitPacketData.java
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/scanner/BootloaderScannerFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, Nordic Semiconductor
+ * Copyright (c) 2018, Nordic Semiconductor
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
@@ -20,51 +20,44 @@
  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package no.nordicsemi.android.dfu.manifest;
+package no.nordicsemi.android.dfu.internal.scanner;
 
-import com.google.gson.annotations.SerializedName;
+import android.os.Build;
 
-import java.util.List;
+import java.util.Locale;
 
-public class InitPacketData {
-	@SerializedName("packet_version") protected int packetVersion;
-	@SerializedName("compression_type") protected int compressionType;
-	@SerializedName("application_version") protected long applicationVersion;
-	@SerializedName("device_revision") protected int deviceRevision;
-	@SerializedName("device_type") protected int deviceType;
-	@SerializedName("firmware_crc16") protected int firmwareCRC16;
-	@SerializedName("firmware_hash") protected String firmwareHash;
-	@SerializedName("softdevice_req") protected List<Integer> softdeviceReq;
+import androidx.annotation.NonNull;
 
-	public int getPacketVersion() {
-		return packetVersion;
-	}
-
-	public int getCompressionType() {
-		return compressionType;
-	}
-
-	public long getApplicationVersion() {
-		return applicationVersion;
-	}
-
-	public int getDeviceRevision() {
-		return deviceRevision;
-	}
-
-	public int getDeviceType() {
-		return deviceType;
-	}
-
-	public int getFirmwareCRC16() {
-		return firmwareCRC16;
-	}
-
-	public String getFirmwareHash() {
-		return firmwareHash;
-	}
-
-	public List<Integer> getSoftdeviceReq() {
-		return softdeviceReq;
+/**
+ * The factory should be used to create the {@link BootloaderScanner} instance appropriate
+ * for the Android version.
+ */
+public final class BootloaderScannerFactory {
+	/**
+	 * The bootloader may advertise with the same address or one with the last byte incremented
+	 * by this value. I.e. 00:11:22:33:44:55 -&gt; 00:11:22:33:44:56. FF changes to 00.
+	 */
+	private final static int ADDRESS_DIFF = 1;
+
+	private BootloaderScannerFactory() {}
+
+	public static String getIncrementedAddress(@NonNull final String deviceAddress) {
+		final String firstBytes = deviceAddress.substring(0, 15);
+		final String lastByte = deviceAddress.substring(15); // assuming that the device address is correct
+		final String lastByteIncremented = String.format(Locale.US, "%02X", (Integer.valueOf(lastByte, 16) + ADDRESS_DIFF) & 0xFF);
+		return firstBytes + lastByteIncremented;
+	}
+
+	/**
+	 * Returns the scanner implementation.
+	 *
+	 * @return the bootloader scanner
+	 */
+	public static BootloaderScanner getScanner(@NonNull final String deviceAddress) {
+		final String deviceAddressIncremented = getIncrementedAddress(deviceAddress);
+
+		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)
+			return new BootloaderScannerLollipop(deviceAddress, deviceAddressIncremented);
+		return new BootloaderScannerJB(deviceAddress, deviceAddressIncremented);
 	}
 }
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/scanner/BootloaderScannerJB.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/scanner/BootloaderScannerJB.java
new file mode 100644
index 0000000..99e4742
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/scanner/BootloaderScannerJB.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.dfu.internal.scanner;
+
+import android.annotation.SuppressLint;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import no.nordicsemi.android.dfu.DfuDeviceSelector;
+
+/**
+ * @see BootloaderScanner
+ */
+@SuppressLint("MissingPermission")
+public class BootloaderScannerJB implements BootloaderScanner, BluetoothAdapter.LeScanCallback {
+	private final Object mLock = new Object();
+	private final String mDeviceAddress;
+	private final String mDeviceAddressIncremented;
+	private DfuDeviceSelector mSelector;
+	private String mBootloaderAddress;
+	private boolean mFound;
+
+	BootloaderScannerJB(final String deviceAddress, final String deviceAddressIncremented) {
+		mDeviceAddress = deviceAddress;
+		mDeviceAddressIncremented = deviceAddressIncremented;
+	}
+
+	@Nullable
+	@Override
+	public String searchUsing(@NonNull DfuDeviceSelector selector, long timeout) {
+		mSelector = selector;
+		mBootloaderAddress = null;
+		mFound = false;
+
+		// Add timeout
+		new Thread(() -> {
+			try {
+				Thread.sleep(timeout);
+			} catch (final InterruptedException e) {
+				// do nothing
+			}
+
+			if (mFound)
+				return;
+
+			mBootloaderAddress = null;
+			mFound = true;
+
+			// Notify the waiting thread
+			synchronized (mLock) {
+				mLock.notifyAll();
+			}
+		}, "Scanner timer").start();
+
+		final BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
+		if (adapter == null || adapter.getState() != BluetoothAdapter.STATE_ON)
+			return null;
+		adapter.startLeScan(this);
+
+		try {
+			synchronized (mLock) {
+				while (!mFound)
+					mLock.wait();
+			}
+		} catch (final InterruptedException e) {
+			// do nothing
+		}
+
+		adapter.stopLeScan(this);
+		return mBootloaderAddress;
+	}
+
+	@Override
+	public void onLeScan(@NonNull final BluetoothDevice device, final int rssi, final byte[] scanRecord) {
+		final String address = device.getAddress();
+
+		if (!mFound && mSelector.matches(
+				device, rssi,
+				scanRecord,
+				mDeviceAddress, mDeviceAddressIncremented
+		)) {
+			mBootloaderAddress = address;
+			mFound = true;
+
+			// Notify the waiting thread
+			synchronized (mLock) {
+				mLock.notifyAll();
+			}
+		}
+	}
+
+}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/scanner/BootloaderScannerLollipop.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/scanner/BootloaderScannerLollipop.java
new file mode 100644
index 0000000..cc46588
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/scanner/BootloaderScannerLollipop.java
@@ -0,0 +1,144 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.dfu.internal.scanner;
+
+import android.annotation.SuppressLint;
+import android.annotation.TargetApi;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.le.BluetoothLeScanner;
+import android.bluetooth.le.ScanCallback;
+import android.bluetooth.le.ScanFilter;
+import android.bluetooth.le.ScanResult;
+import android.bluetooth.le.ScanSettings;
+import android.os.Build;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import no.nordicsemi.android.dfu.DfuDeviceSelector;
+
+/**
+ * @see BootloaderScanner
+ */
+@SuppressLint("MissingPermission")
+@TargetApi(Build.VERSION_CODES.LOLLIPOP)
+class BootloaderScannerLollipop extends ScanCallback implements BootloaderScanner {
+    private final Object mLock = new Object();
+    private final String mDeviceAddress;
+    private final String mDeviceAddressIncremented;
+    private DfuDeviceSelector mSelector;
+    private String mBootloaderAddress;
+    private boolean mFound;
+
+    BootloaderScannerLollipop(final String deviceAddress, final String deviceAddressIncremented) {
+        mDeviceAddress = deviceAddress;
+        mDeviceAddressIncremented = deviceAddressIncremented;
+    }
+
+    @Nullable
+    @Override
+    public String searchUsing(@NonNull DfuDeviceSelector selector, long timeout) {
+        mSelector = selector;
+        mBootloaderAddress = null;
+        mFound = false;
+
+        // Add timeout
+        new Thread(() -> {
+            try {
+                Thread.sleep(timeout);
+            } catch (final InterruptedException e) {
+                // do nothing
+            }
+
+            if (mFound)
+                return;
+
+            mBootloaderAddress = null;
+            mFound = true;
+
+            // Notify the waiting thread
+            synchronized (mLock) {
+                mLock.notifyAll();
+            }
+        }, "Scanner timer").start();
+
+        final BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
+        if (adapter == null || adapter.getState() != BluetoothAdapter.STATE_ON)
+            return null;
+        final BluetoothLeScanner scanner = adapter.getBluetoothLeScanner();
+        if (scanner == null)
+            return null;
+        /*
+         * Android 8.1 onwards, stops unfiltered BLE scanning on screen off. Therefore we must add a filter to
+         * get scan results in case the device screen is turned off as this may affect users wanting scan/connect to the device in background.
+         * See https://android.googlesource.com/platform/packages/apps/Bluetooth/+/319aeae6f4ebd13678b4f77375d1804978c4a1e1
+         */
+        final ScanSettings settings = new ScanSettings.Builder().setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY).build();
+        if (adapter.isOffloadedFilteringSupported() && Build.VERSION.SDK_INT >= Build.VERSION_CODES.O_MR1) {
+            final List<ScanFilter> filters = new ArrayList<>();
+            // Some Android devices fail to scan with offloaded address filters.
+            // Instead, we will add an empty filter, just to allow background scanning, and will
+            // filter below using the device selector.
+            scanner.startScan(filters, settings, this);
+        } else {
+            /*
+             * Scanning with filters does not work on Nexus 9 (Android 5.1). No devices are found and scanner terminates on timeout.
+             * We will match the device address in the callback method instead. It's not like it should be, but at least it works.
+             */
+            scanner.startScan(null, settings, this);
+        }
+
+        try {
+            synchronized (mLock) {
+                while (!mFound)
+                    mLock.wait();
+            }
+        } catch (final InterruptedException e) {
+            // do nothing
+        }
+
+        scanner.stopScan(this);
+        return mBootloaderAddress;
+    }
+
+    @Override
+    public void onScanResult(final int callbackType, final ScanResult result) {
+        final String address = result.getDevice().getAddress();
+
+        if (!mFound && mSelector.matches(
+                result.getDevice(), result.getRssi(),
+                result.getScanRecord().getBytes(),
+                mDeviceAddress, mDeviceAddressIncremented
+        )) {
+            mBootloaderAddress = address;
+            mFound = true;
+
+            // Notify the waiting thread
+            synchronized (mLock) {
+                mLock.notifyAll();
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/dfuLibrary/src/main/java/no/nordicsemi/android/error/GattError.java b/dfu-lib/src/main/java/no/nordicsemi/android/error/GattError.java
similarity index 75%
rename from dfuLibrary/src/main/java/no/nordicsemi/android/error/GattError.java
rename to dfu-lib/src/main/java/no/nordicsemi/android/error/GattError.java
index f207ea1..9f2817b 100644
--- a/dfuLibrary/src/main/java/no/nordicsemi/android/error/GattError.java
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/error/GattError.java
@@ -1,5 +1,5 @@
-/*************************************************************************************************************************************************
- * Copyright (c) 2015, Nordic Semiconductor
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
@@ -18,7 +18,7 @@
  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- ************************************************************************************************************************************************/
+ */
 
 package no.nordicsemi.android.error;
 
@@ -29,9 +29,9 @@ import no.nordicsemi.android.dfu.DfuBaseService;
 /**
  * Parses the error numbers according to the <b>gatt_api.h</b> file from bluedroid stack.
  * See: https://android.googlesource.com/platform/external/bluetooth/bluedroid/+/android-5.1.0_r1/stack/include/gatt_api.h (and other versions) for details.
+ * See also: https://android.googlesource.com/platform/external/libnfc-nci/+/master/src/include/hcidefs.h#447 for other possible HCI errors.
  */
 public class GattError {
-
 	// Starts at line 106 of gatt_api.h file
 	/**
 	 * Converts the connection status given by the {@link android.bluetooth.BluetoothGattCallback#onConnectionStateChange(android.bluetooth.BluetoothGatt, int, int)} to error name.
@@ -42,31 +42,22 @@ public class GattError {
 		switch (error) {
 			case BluetoothGatt.GATT_SUCCESS:
 				return "SUCCESS";
-
 			case 0x01:
 				return "GATT CONN L2C FAILURE";
-
 			case 0x08:
 				return "GATT CONN TIMEOUT";
-
 			case 0x13:
 				return "GATT CONN TERMINATE PEER USER";
-
 			case 0x16:
 				return "GATT CONN TERMINATE LOCAL HOST";
-
 			case 0x3E:
 				return "GATT CONN FAIL ESTABLISH";
-
 			case 0x22:
 				return "GATT CONN LMP TIMEOUT";
-
 			case 0x0100:
 				return "GATT CONN CANCEL ";
-
 			case 0x0085:
 				return "GATT ERROR"; // Device not reachable
-
 			default:
 				return "UNKNOWN (" + error + ")";
 		}
@@ -82,154 +73,134 @@ public class GattError {
 		switch (error) {
 			case 0x0001:
 				return "GATT INVALID HANDLE";
-
 			case 0x0002:
 				return "GATT READ NOT PERMIT";
-
 			case 0x0003:
 				return "GATT WRITE NOT PERMIT";
-
 			case 0x0004:
 				return "GATT INVALID PDU";
-
 			case 0x0005:
 				return "GATT INSUF AUTHENTICATION";
-
 			case 0x0006:
 				return "GATT REQ NOT SUPPORTED";
-
 			case 0x0007:
 				return "GATT INVALID OFFSET";
-
 			case 0x0008:
 				return "GATT INSUF AUTHORIZATION";
-
 			case 0x0009:
 				return "GATT PREPARE Q FULL";
-
 			case 0x000a:
 				return "GATT NOT FOUND";
-
 			case 0x000b:
 				return "GATT NOT LONG";
-
 			case 0x000c:
 				return "GATT INSUF KEY SIZE";
-
 			case 0x000d:
 				return "GATT INVALID ATTR LEN";
-
 			case 0x000e:
 				return "GATT ERR UNLIKELY";
-
 			case 0x000f:
 				return "GATT INSUF ENCRYPTION";
-
 			case 0x0010:
 				return "GATT UNSUPPORT GRP TYPE";
-
 			case 0x0011:
 				return "GATT INSUF RESOURCE";
-
+			case 0x001A:
+				return "HCI ERROR UNSUPPORTED REMOTE FEATURE";
+			case 0x001E:
+				return "HCI ERROR INVALID LMP PARAM";
+			case 0x0022:
+				return "GATT CONN LMP TIMEOUT";
+			case 0x002A:
+				return "HCI ERROR DIFF TRANSACTION COLLISION";
+			case 0x003A:
+				return "GATT CONTROLLER BUSY";
+			case 0x003B:
+				return "GATT UNACCEPT CONN INTERVAL";
 			case 0x0087:
 				return "GATT ILLEGAL PARAMETER";
-
 			case 0x0080:
 				return "GATT NO RESOURCES";
-
 			case 0x0081:
 				return "GATT INTERNAL ERROR";
-
 			case 0x0082:
 				return "GATT WRONG STATE";
-
 			case 0x0083:
 				return "GATT DB FULL";
-
 			case 0x0084:
 				return "GATT BUSY";
-
 			case 0x0085:
 				return "GATT ERROR";
-
 			case 0x0086:
 				return "GATT CMD STARTED";
-
 			case 0x0088:
 				return "GATT PENDING";
-
 			case 0x0089:
 				return "GATT AUTH FAIL";
-
 			case 0x008a:
 				return "GATT MORE";
-
 			case 0x008b:
 				return "GATT INVALID CFG";
-
 			case 0x008c:
 				return "GATT SERVICE STARTED";
-
 			case 0x008d:
 				return "GATT ENCRYPTED NO MITM";
-
 			case 0x008e:
 				return "GATT NOT ENCRYPTED";
-
-			case 0x01FF:
+			case 0x008f:
+				return "GATT CONGESTED";
+			case 0x00FD:
+				return "GATT CCCD CFG ERROR";
+			case 0x00FE:
+				return "GATT PROCEDURE IN PROGRESS";
+			case 0x00FF:
 				return "GATT VALUE OUT OF RANGE";
-
 			case 0x0101:
 				return "TOO MANY OPEN CONNECTIONS";
-
-			case 0x00FF:
-				return "DFU SERVICE DISCOVERY NOT STARTED";
-
 			case DfuBaseService.ERROR_DEVICE_DISCONNECTED:
 				return "DFU DEVICE DISCONNECTED";
-
+			case DfuBaseService.ERROR_FILE_NOT_FOUND:
+				return "DFU FILE NOT FOUND";
 			case DfuBaseService.ERROR_FILE_ERROR:
 				return "DFU FILE ERROR";
-
 			case DfuBaseService.ERROR_FILE_INVALID:
 				return "DFU NOT A VALID HEX FILE";
-
 			case DfuBaseService.ERROR_FILE_IO_EXCEPTION:
 				return "DFU IO EXCEPTION";
-
-			case DfuBaseService.ERROR_FILE_NOT_FOUND:
-				return "DFU FILE NOT FOUND";
-
 			case DfuBaseService.ERROR_SERVICE_DISCOVERY_NOT_STARTED:
-				return "DFU ERROR WHILE SERVICE DISCOVERY";
-
+				return "DFU SERVICE DISCOVERY NOT STARTED";
 			case DfuBaseService.ERROR_SERVICE_NOT_FOUND:
-				return "DFU SERVICE NOT FOUND";
-
-			case DfuBaseService.ERROR_CHARACTERISTICS_NOT_FOUND:
 				return "DFU CHARACTERISTICS NOT FOUND";
-
+			case DfuBaseService.ERROR_INVALID_RESPONSE:
+				return "DFU INVALID RESPONSE";
 			case DfuBaseService.ERROR_FILE_TYPE_UNSUPPORTED:
 				return "DFU FILE TYPE NOT SUPPORTED";
-
 			case DfuBaseService.ERROR_BLUETOOTH_DISABLED:
 				return "BLUETOOTH ADAPTER DISABLED";
+			case DfuBaseService.ERROR_INIT_PACKET_REQUIRED:
+				return "DFU INIT PACKET REQUIRED";
+			case DfuBaseService.ERROR_FILE_SIZE_INVALID:
+				return "DFU INIT PACKET REQUIRED";
+			case DfuBaseService.ERROR_CRC_ERROR:
+				return "DFU CRC ERROR";
+			case DfuBaseService.ERROR_DEVICE_NOT_BONDED:
+				return "DFU DEVICE NOT BONDED";
+			default:
+				return "UNKNOWN (" + error + ")";
+		}
+	}
 
+	public static String parseDfuRemoteError(final int error) {
+		switch (error & (DfuBaseService.ERROR_REMOTE_TYPE_LEGACY | DfuBaseService.ERROR_REMOTE_TYPE_SECURE | DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED | DfuBaseService.ERROR_REMOTE_TYPE_SECURE_BUTTONLESS)) {
+			case DfuBaseService.ERROR_REMOTE_TYPE_LEGACY:
+				return LegacyDfuError.parse(error);
+			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE:
+				return SecureDfuError.parse(error);
+			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED:
+				return SecureDfuError.parseExtendedError(error);
+			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_BUTTONLESS:
+				return SecureDfuError.parseButtonlessError(error);
 			default:
-				if ((DfuBaseService.ERROR_REMOTE_MASK & error) > 0) {
-					switch (error & (~DfuBaseService.ERROR_REMOTE_MASK)) {
-						case DfuBaseService.DFU_STATUS_INVALID_STATE:
-							return "REMOTE DFU INVALID STATE";
-						case DfuBaseService.DFU_STATUS_NOT_SUPPORTED:
-							return "REMOTE DFU NOT SUPPORTED";
-						case DfuBaseService.DFU_STATUS_DATA_SIZE_EXCEEDS_LIMIT:
-							return "REMOTE DFU DATA SIZE EXCEEDS LIMIT";
-						case DfuBaseService.DFU_STATUS_CRC_ERROR:
-							return "REMOTE DFU INVALID CRC ERROR";
-						case DfuBaseService.DFU_STATUS_OPERATION_FAILED:
-							return "REMOTE DFU OPERATION FAILED";
-					}
-				}
 				return "UNKNOWN (" + error + ")";
 		}
 	}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/error/LegacyDfuError.java b/dfu-lib/src/main/java/no/nordicsemi/android/error/LegacyDfuError.java
new file mode 100644
index 0000000..258e8dd
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/error/LegacyDfuError.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.error;
+
+import no.nordicsemi.android.dfu.DfuBaseService;
+
+public final class LegacyDfuError {
+	// DFU status values
+	// public static final int SUCCESS = 1; // that's not an error
+	public static final int INVALID_STATE = 2;
+	public static final int NOT_SUPPORTED = 3;
+	public static final int DATA_SIZE_EXCEEDS_LIMIT = 4;
+	public static final int CRC_ERROR = 5;
+	public static final int OPERATION_FAILED = 6;
+
+	public static String parse(final int error) {
+		switch (error) {
+			case DfuBaseService.ERROR_REMOTE_TYPE_LEGACY | INVALID_STATE:				return "INVALID STATE";
+			case DfuBaseService.ERROR_REMOTE_TYPE_LEGACY | NOT_SUPPORTED:				return "NOT SUPPORTED";
+			case DfuBaseService.ERROR_REMOTE_TYPE_LEGACY | DATA_SIZE_EXCEEDS_LIMIT:		return "DATA SIZE EXCEEDS LIMIT";
+			case DfuBaseService.ERROR_REMOTE_TYPE_LEGACY | CRC_ERROR:					return "INVALID CRC ERROR";
+			case DfuBaseService.ERROR_REMOTE_TYPE_LEGACY | OPERATION_FAILED:			return "OPERATION FAILED";
+			default:
+				return "UNKNOWN (" + error + ")";
+		}
+	}
+}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/error/SecureDfuError.java b/dfu-lib/src/main/java/no/nordicsemi/android/error/SecureDfuError.java
new file mode 100644
index 0000000..944700a
--- /dev/null
+++ b/dfu-lib/src/main/java/no/nordicsemi/android/error/SecureDfuError.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (c) 2018, Nordic Semiconductor
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.nordicsemi.android.error;
+
+import no.nordicsemi.android.dfu.DfuBaseService;
+
+public final class SecureDfuError {
+	// DFU status values
+	// public static final int SUCCESS = 1; // that's not an error
+	public static final int OP_CODE_NOT_SUPPORTED = 2;
+	public static final int INVALID_PARAM = 3;
+	public static final int INSUFFICIENT_RESOURCES = 4;
+	public static final int INVALID_OBJECT = 5;
+	public static final int UNSUPPORTED_TYPE = 7;
+	public static final int OPERATION_NOT_PERMITTED = 8;
+	public static final int OPERATION_FAILED = 10; // 0xA
+	public static final int EXTENDED_ERROR = 11; // 0xB
+
+	// public static final int EXT_ERROR_NO_ERROR = 0x00; // that's not an error
+	public static final int EXT_ERROR_WRONG_COMMAND_FORMAT = 0x02;
+	public static final int EXT_ERROR_UNKNOWN_COMMAND = 0x03;
+	public static final int EXT_ERROR_INIT_COMMAND_INVALID = 0x04;
+	public static final int EXT_ERROR_FW_VERSION_FAILURE = 0x05;
+	public static final int EXT_ERROR_HW_VERSION_FAILURE = 0x06;
+	public static final int EXT_ERROR_SD_VERSION_FAILURE = 0x07;
+	public static final int EXT_ERROR_SIGNATURE_MISSING = 0x08;
+	public static final int EXT_ERROR_WRONG_HASH_TYPE = 0x09;
+	public static final int EXT_ERROR_HASH_FAILED = 0x0A;
+	public static final int EXT_ERROR_WRONG_SIGNATURE_TYPE = 0x0B;
+	public static final int EXT_ERROR_VERIFICATION_FAILED = 0x0C;
+	public static final int EXT_ERROR_INSUFFICIENT_SPACE = 0x0D;
+
+	// public static final int BUTTONLESS_SUCCESS = 1;
+	public static final int BUTTONLESS_ERROR_OP_CODE_NOT_SUPPORTED = 2;
+	public static final int BUTTONLESS_ERROR_OPERATION_FAILED = 4;
+
+	public static String parse(final int error) {
+		switch (error) {
+			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE | OP_CODE_NOT_SUPPORTED:		return "OP CODE NOT SUPPORTED";
+			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE | INVALID_PARAM:				return "INVALID PARAM";
+			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE | INSUFFICIENT_RESOURCES:		return "INSUFFICIENT RESOURCES";
+			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE | INVALID_OBJECT:				return "INVALID OBJECT";
+			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE | UNSUPPORTED_TYPE:			return "UNSUPPORTED TYPE";
+			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE | OPERATION_NOT_PERMITTED:		return "OPERATION NOT PERMITTED";
+			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE | OPERATION_FAILED:			return "OPERATION FAILED";
+			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE | EXTENDED_ERROR:				return "EXTENDED ERROR";
+			default:
+				return "UNKNOWN (" + error + ")";
+		}
+	}
+
+	public static String parseExtendedError(final int error) {
+		switch (error) {
+			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED | EXT_ERROR_WRONG_COMMAND_FORMAT: return "Wrong command format";
+			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED | EXT_ERROR_UNKNOWN_COMMAND:		return "Unknown command";
+			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED | EXT_ERROR_INIT_COMMAND_INVALID: return "Init command invalid";
+			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED | EXT_ERROR_FW_VERSION_FAILURE:	return "FW version failure";
+			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED | EXT_ERROR_HW_VERSION_FAILURE:	return "HW version failure";
+			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED | EXT_ERROR_SD_VERSION_FAILURE:	return "SD version failure";
+			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED | EXT_ERROR_SIGNATURE_MISSING :	return "Signature mismatch";
+			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED | EXT_ERROR_WRONG_HASH_TYPE:		return "Wrong hash type";
+			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED | EXT_ERROR_HASH_FAILED:			return "Hash failed";
+			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED | EXT_ERROR_WRONG_SIGNATURE_TYPE: return "Wrong signature type";
+			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED | EXT_ERROR_VERIFICATION_FAILED:	return "Verification failed";
+			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED | EXT_ERROR_INSUFFICIENT_SPACE:	return "Insufficient space";
+			default:
+				return "Reserved for future use";
+		}
+	}
+
+	public static String parseButtonlessError(final int error) {
+		switch (error) {
+			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_BUTTONLESS | BUTTONLESS_ERROR_OP_CODE_NOT_SUPPORTED:	return "OP CODE NOT SUPPORTED";
+			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_BUTTONLESS | BUTTONLESS_ERROR_OPERATION_FAILED:		return "OPERATION FAILED";
+			default:
+				return "UNKNOWN (" + error + ")";
+		}
+	}
+}
diff --git a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/ArchiveInputStream.java b/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/ArchiveInputStream.java
deleted file mode 100644
index ba80838..0000000
--- a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/ArchiveInputStream.java
+++ /dev/null
@@ -1,466 +0,0 @@
-/*************************************************************************************************************************************************
- * Copyright (c) 2015, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- ************************************************************************************************************************************************/
-
-package no.nordicsemi.android.dfu;
-
-import com.google.gson.Gson;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.HashMap;
-import java.util.Locale;
-import java.util.Map;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipInputStream;
-
-import no.nordicsemi.android.dfu.manifest.FileInfo;
-import no.nordicsemi.android.dfu.manifest.Manifest;
-import no.nordicsemi.android.dfu.manifest.ManifestFile;
-import no.nordicsemi.android.dfu.manifest.SoftDeviceBootloaderFileInfo;
-
-/**
- * <p>Reads the firmware files from the a ZIP file. The ZIP file must be either created using the <b>nrf utility</b> tool, available together with Master Control Panel v3.8.0+,
- * or follow the backward compatibility syntax: must contain only files with names: application.hex/bin, softdevice.hex/dat or bootloader.hex/bin, optionally also application.dat
- * and/or system.dat with init packets.</p>
- * <p>The ArchiveInputStream will read only files with types specified by <b>types</b> parameter of the constructor.</p>
- */
-public class ArchiveInputStream extends ZipInputStream {
-	/** The name of the manifest file is fixed. */
-	private static final String MANIFEST = "manifest.json";
-	// Those file names are for backwards compatibility mode
-	private static final String SOFTDEVICE_HEX = "softdevice.hex";
-	private static final String SOFTDEVICE_BIN = "softdevice.bin";
-	private static final String BOOTLOADER_HEX = "bootloader.hex";
-	private static final String BOOTLOADER_BIN = "bootloader.bin";
-	private static final String APPLICATION_HEX = "application.hex";
-	private static final String APPLICATION_BIN = "application.bin";
-	private static final String SYSTEM_INIT = "system.dat";
-	private static final String APPLICATION_INIT = "application.dat";
-
-	/** Contains bytes arrays with BIN files. HEX files are converted to BIN before being added to this map. */
-	private Map<String, byte[]> entries;
-	private Manifest manifest;
-
-	private byte[] applicationBytes;
-	private byte[] softDeviceBytes;
-	private byte[] bootloaderBytes;
-	private byte[] softDeviceAndBootloaderBytes;
-	private byte[] systemInitBytes;
-	private byte[] applicationInitBytes;
-	private byte[] currentSource;
-	private int bytesReadFromCurrentSource;
-	private int softDeviceSize;
-	private int bootloaderSize;
-	private int applicationSize;
-	private int bytesRead;
-
-	/**
-	 * <p>
-	 * The ArchiveInputStream read HEX or BIN files from the Zip stream. It may skip some of them, depending on the value of the types parameter.
-	 * This is useful if the DFU service wants to send the Soft Device and Bootloader only, and then the Application in the following connection, despite
-	 * the ZIP file contains all 3 HEX/BIN files.
-	 * When types is equal to {@link DfuBaseService#TYPE_AUTO} all present files are read.
-	 * </p>
-	 * <p>
-	 * Use bit combination of the following types:
-	 * <ul>
-	 * <li>{@link DfuBaseService#TYPE_SOFT_DEVICE}</li>
-	 * <li>{@link DfuBaseService#TYPE_BOOTLOADER}</li>
-	 * <li>{@link DfuBaseService#TYPE_APPLICATION}</li>
-	 * <li>{@link DfuBaseService#TYPE_AUTO}</li>
-	 * </ul>
-	 * </p>
-	 * 
-	 * @param stream
-	 *            the Zip Input Stream
-	 * @param mbrSize
-	 *            The size of the MRB segment (Master Boot Record) on the device. The parser will cut data from addresses below that number from all HEX files.
-	 * @param types
-	 *            File types that are to be read from the ZIP. Use {@link DfuBaseService#TYPE_APPLICATION} etc.
-	 * @throws java.io.IOException
-	 */
-	public ArchiveInputStream(final InputStream stream, final int mbrSize, final int types) throws IOException {
-		super(stream);
-
-		this.entries = new HashMap<>();
-		this.bytesRead = 0;
-		this.bytesReadFromCurrentSource = 0;
-
-		try {
-			/*
-			 * This method reads all entries from the ZIP file and puts them to entries map.
-			 * The 'manifest.json' file, if exists, is converted to the manifestData String.
-			 */
-			parseZip(mbrSize);
-
-			/*
-			 * Let's read and parse the 'manifest.json' file.
-			 */
-			if (manifest != null) {
-				boolean valid = false;
-
-				// Read the application
-				if (manifest.getApplicationInfo() != null && (types == DfuBaseService.TYPE_AUTO || (types & DfuBaseService.TYPE_APPLICATION) > 0)) {
-					final FileInfo application = manifest.getApplicationInfo();
-					applicationBytes = entries.get(application.getBinFileName());
-					applicationInitBytes = entries.get(application.getDatFileName());
-
-					if (applicationBytes == null)
-						throw new IOException("Application file " + application.getBinFileName() + " not found.");
-
-					applicationSize = applicationBytes.length;
-					currentSource = applicationBytes;
-					valid = true;
-				}
-
-				// Read the Bootloader
-				if (manifest.getBootloaderInfo() != null && (types == DfuBaseService.TYPE_AUTO || (types & DfuBaseService.TYPE_BOOTLOADER) > 0)) {
-					if (systemInitBytes != null)
-						throw new IOException("Manifest: softdevice and bootloader specified. Use softdevice_bootloader instead.");
-
-					final FileInfo bootloader = manifest.getBootloaderInfo();
-					bootloaderBytes = entries.get(bootloader.getBinFileName());
-					systemInitBytes = entries.get(bootloader.getDatFileName());
-
-					if (bootloaderBytes == null)
-						throw new IOException("Bootloader file " + bootloader.getBinFileName() + " not found.");
-
-					bootloaderSize = bootloaderBytes.length;
-					currentSource = bootloaderBytes;
-					valid = true;
-				}
-
-				// Read the Soft Device
-				if (manifest.getSoftdeviceInfo() != null && (types == DfuBaseService.TYPE_AUTO || (types & DfuBaseService.TYPE_SOFT_DEVICE) > 0)) {
-					final FileInfo softdevice = manifest.getSoftdeviceInfo();
-					softDeviceBytes = entries.get(softdevice.getBinFileName());
-					systemInitBytes = entries.get(softdevice.getDatFileName());
-
-					if (softDeviceBytes == null)
-						throw new IOException("SoftDevice file " + softdevice.getBinFileName() + " not found.");
-
-					softDeviceSize = softDeviceBytes.length;
-					currentSource = softDeviceBytes;
-					valid = true;
-				}
-
-				// Read the combined Soft Device and Bootloader
-				if (manifest.getSoftdeviceBootloaderInfo() != null && (types == DfuBaseService.TYPE_AUTO ||
-						((types & DfuBaseService.TYPE_SOFT_DEVICE) > 0) && (types & DfuBaseService.TYPE_BOOTLOADER) > 0)) {
-
-					if (systemInitBytes != null)
-						throw new IOException("Manifest: The softdevice_bootloader may not be used together with softdevice or bootloader.");
-
-					final SoftDeviceBootloaderFileInfo system = manifest.getSoftdeviceBootloaderInfo();
-					softDeviceAndBootloaderBytes = entries.get(system.getBinFileName());
-					systemInitBytes = entries.get(system.getDatFileName());
-
-					if (softDeviceAndBootloaderBytes == null)
-						throw new IOException("File " + system.getBinFileName() + " not found.");
-
-					softDeviceSize = system.getSoftdeviceSize();
-					bootloaderSize = system.getBootloaderSize();
-					currentSource = softDeviceAndBootloaderBytes;
-					valid = true;
-				}
-
-				if (!valid) {
-					throw new IOException("Manifest file must specify at least one file.");
-				}
-			} else {
-				/*
-				 * Compatibility mode. The 'manifest.json' file does not exist.
-				 *
-				 * In that case the ZIP file must contain one or more of the following files:
-				 *
-				 * - application.hex/dat
-				 *     + application.dat
-				 * - softdevice.hex/dat
-				 * - bootloader.hex/dat
-				 *     + system.dat
-				 */
-				boolean valid = false;
-				// Search for the application
-				if (types == DfuBaseService.TYPE_AUTO || (types & DfuBaseService.TYPE_APPLICATION) > 0) {
-					applicationBytes = entries.get(APPLICATION_HEX); // the entry bytes has already been converted to BIN, just the name remained.
-					if (applicationBytes == null)
-						applicationBytes = entries.get(APPLICATION_BIN);
-
-					if (applicationBytes != null) {
-						applicationSize = applicationBytes.length;
-						applicationInitBytes = entries.get(APPLICATION_INIT);
-						currentSource = applicationBytes;
-						valid = true;
-					}
-				}
-
-				// Search for theBootloader
-				if (types == DfuBaseService.TYPE_AUTO || (types & DfuBaseService.TYPE_BOOTLOADER) > 0) {
-					bootloaderBytes = entries.get(BOOTLOADER_HEX); // the entry bytes has already been converted to BIN, just the name remained.
-					if (bootloaderBytes == null)
-						bootloaderBytes = entries.get(BOOTLOADER_BIN);
-
-					if (bootloaderBytes != null) {
-						bootloaderSize = bootloaderBytes.length;
-						systemInitBytes = entries.get(SYSTEM_INIT);
-						currentSource = bootloaderBytes;
-						valid = true;
-					}
-				}
-
-				// Search for the Soft Device
-				if (types == DfuBaseService.TYPE_AUTO || (types & DfuBaseService.TYPE_SOFT_DEVICE) > 0) {
-					softDeviceBytes = entries.get(SOFTDEVICE_HEX); // the entry bytes has already been converted to BIN, just the name remained.
-					if (softDeviceBytes == null)
-						softDeviceBytes = entries.get(SOFTDEVICE_BIN);
-
-					if (softDeviceBytes != null) {
-						softDeviceSize = softDeviceBytes.length;
-						systemInitBytes = entries.get(SYSTEM_INIT);
-						currentSource = softDeviceBytes;
-						valid = true;
-					}
-				}
-
-				if (!valid) {
-					throw new IOException("The ZIP file must contain an Application, a Soft Device and/or a Bootloader.");
-				}
-			}
-		} finally {
-			super.close();
-		}
-	}
-
-	/**
-	 * Reads all files into byte arrays.
-	 * Here we don't know whether the ZIP file is valid.
-	 *
-	 * The ZIP file is valid when contains a 'manifest.json' file and all BIN and DAT files that are specified in the manifest.
-	 *
-	 * For backwards compatibility ArchiveInputStream supports also ZIP archives without 'manifest.json' file
-	 * but than it MUST include at least one of the following files: softdevice.bin/hex, bootloader.bin/hex, application.bin/hex.
-	 * To support the init packet such ZIP file should contain also application.dat and/or system.dat (with the CRC16 of a SD, BL or SD+BL together).
-	 */
-	private void parseZip(int mbrSize) throws IOException {
-		final byte[] buffer = new byte[1024];
-		String manifestData = null;
-
-		ZipEntry ze;
-		while ((ze = getNextEntry()) != null) {
-			final String filename = ze.getName();
-
-			// Read file content to byte array
-			final ByteArrayOutputStream baos = new ByteArrayOutputStream();
-			int count;
-			while ((count = super.read(buffer)) != -1) {
-				baos.write(buffer, 0, count);
-			}
-			byte[] source = baos.toByteArray();
-
-			// In case of HEX file convert it to BIN
-			if (filename.toLowerCase(Locale.US).endsWith("hex")) {
-				final HexInputStream is = new HexInputStream(source, mbrSize);
-				source = new byte[is.available()];
-				is.read(source);
-				is.close();
-			}
-
-			// Save the file content either as a manifest data or by adding it to entries
-			if (MANIFEST.equals(filename))
-				manifestData = new String(source, "UTF-8");
-			else
-				entries.put(filename, source);
-		}
-
-		if (manifestData != null) {
-			final ManifestFile manifestFile = new Gson().fromJson(manifestData, ManifestFile.class);
-			manifest = manifestFile.getManifest();
-		}
-	}
-
-	@Override
-	public void close() throws IOException {
-		softDeviceBytes = null;
-		bootloaderBytes = null;
-		softDeviceBytes = null;
-		softDeviceAndBootloaderBytes = null;
-		softDeviceSize = bootloaderSize = applicationSize = 0;
-		currentSource = null;
-		bytesRead = bytesReadFromCurrentSource = 0;
-		super.close();
-	}
-
-	@Override
-	public int read(final byte[] buffer) throws IOException {
-		int maxSize = currentSource.length - bytesReadFromCurrentSource;
-		int size = buffer.length <= maxSize ? buffer.length : maxSize;
-		System.arraycopy(currentSource, bytesReadFromCurrentSource, buffer, 0, size);
-		bytesReadFromCurrentSource += size;
-		if (buffer.length > size) {
-			if (startNextFile() == null) {
-				bytesRead += size;
-				return size;
-			}
-
-			maxSize = currentSource.length;
-			final int nextSize = buffer.length - size <= maxSize ? buffer.length - size : maxSize;
-			System.arraycopy(currentSource, 0, buffer, size, nextSize);
-			bytesReadFromCurrentSource += nextSize;
-			size += nextSize;
-		}
-		bytesRead += size;
-		return size;
-	}
-
-	/**
-	 * Returns the manifest object if it was specified in the ZIP file.
-	 * @return the manifest object
-	 */
-	public Manifest getManifest() {
-		return manifest;
-	}
-
-	/**
-	 * Returns the content type based on the content of the ZIP file. The content type may be truncated using {@link #setContentType(int)}.
-	 * 
-	 * @return a bit field of {@link DfuBaseService#TYPE_SOFT_DEVICE TYPE_SOFT_DEVICE}, {@link DfuBaseService#TYPE_BOOTLOADER TYPE_BOOTLOADER} and {@link DfuBaseService#TYPE_APPLICATION
-	 *         TYPE_APPLICATION}
-	 */
-	public int getContentType() {
-		byte b = 0;
-		if (softDeviceSize > 0)
-			b |= DfuBaseService.TYPE_SOFT_DEVICE;
-
-		if (bootloaderSize > 0)
-			b |= DfuBaseService.TYPE_BOOTLOADER;
-
-		if (applicationSize > 0)
-			b |= DfuBaseService.TYPE_APPLICATION;
-
-		return b;
-	}
-
-	/**
-	 * Truncates the current content type. May be used to hide some files, f.e. to send Soft Device and Bootloader without Application or only the Application.
-	 * 
-	 * @param type
-	 *            the new type
-	 * @return the final type after truncating
-	 */
-	public int setContentType(final int type) {
-		if (bytesRead > 0)
-			throw new UnsupportedOperationException("Content type must not be change after reading content");
-
-		final int t = getContentType() & type;
-
-		if ((t & DfuBaseService.TYPE_SOFT_DEVICE) == 0) {
-			softDeviceBytes = null;
-			if (softDeviceAndBootloaderBytes != null) {
-				softDeviceAndBootloaderBytes = null;
-				bootloaderSize = 0;
-			}
-			softDeviceSize = 0;
-		}
-		if ((t & DfuBaseService.TYPE_BOOTLOADER) == 0) {
-			bootloaderBytes = null;
-			if (softDeviceAndBootloaderBytes != null) {
-				softDeviceAndBootloaderBytes = null;
-				softDeviceSize = 0;
-			}
-			bootloaderSize = 0;
-		}
-		if ((t & DfuBaseService.TYPE_APPLICATION) == 0) {
-			applicationBytes = null;
-			applicationSize = 0;
-		}
-		return t;
-	}
-
-	/**
-	 * Sets the currentSource to the new file or to <code>null</code> if the last file has been transmitted.
-	 * 
-	 * @return the new source, the same as {@link #currentSource}
-	 */
-	private byte[] startNextFile() {
-		byte[] ret;
-		if (currentSource == softDeviceBytes && bootloaderBytes != null) {
-			ret = currentSource = bootloaderBytes;
-		} else if (currentSource != applicationBytes && applicationBytes != null) {
-			ret = currentSource = applicationBytes;
-		} else {
-			ret = currentSource = null;
-		}
-		bytesReadFromCurrentSource = 0;
-		return ret;
-	}
-
-	@Override
-	/**
-	 * Returns the number of bytes that has not been read yet. This value includes only firmwares matching the content type set by the construcotor or the {@link #setContentType(int)} method.
-	 */
-	public int available() {
-		return softDeviceSize + bootloaderSize + applicationSize - bytesRead;
-	}
-
-	/**
-	 * Returns the total size of the SoftDevice firmware. In case the firmware was given as a HEX, this method returns the size of the BIN content of the file.
-	 * @return the size of the SoftDevice firmware (BIN part)
-	 */
-	public int softDeviceImageSize() {
-		return softDeviceSize;
-	}
-
-	/**
-	 * Returns the total size of the Bootloader firmware. In case the firmware was given as a HEX, this method returns the size of the BIN content of the file.
-	 * @return the size of the Bootloader firmware (BIN part)
-	 */
-	public int bootloaderImageSize() {
-		return bootloaderSize;
-	}
-
-	/**
-	 * Returns the total size of the Application firmware. In case the firmware was given as a HEX, this method returns the size of the BIN content of the file.
-	 * @return the size of the Application firmware (BIN part)
-	 */
-	public int applicationImageSize() {
-		return applicationSize;
-	}
-
-	/**
-	 * Returns the content of the init file for SoftDevice and/or Bootloader. When both SoftDevice and Bootloader are present in the ZIP file (as two files using the compatibility mode
-	 * or as one file using the new Distribution packet) the system init contains validation data for those two files combined (e.g. the CRC value). This method may return
-	 * <code>null</code> if there is no SoftDevice nor Bootloader in the ZIP or the DAT file is not present there.
-	 * @return the content of the init packet for SoftDevice and/or Bootloader
-	 */
-	public byte[] getSystemInit() {
-		return systemInitBytes;
-	}
-
-	/**
-	 * Returns the content of the init file for the Application or <code>null</code> if no application file in the ZIP, or the DAT file is not provided.
-	 * @return the content of the init packet for Application
-	 */
-	public byte[] getApplicationInit() {
-		return applicationInitBytes;
-	}
-}
diff --git a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/DfuBaseService.java b/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/DfuBaseService.java
deleted file mode 100644
index 1702b43..0000000
--- a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/DfuBaseService.java
+++ /dev/null
@@ -1,3268 +0,0 @@
-/**
- * **********************************************************************************************************************************************
- * Copyright (c) 2015, Nordic Semiconductor
- * All rights reserved.
- * <p/>
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- * <p/>
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- * <p/>
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- * <p/>
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- * <p/>
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * **********************************************************************************************************************************************
- */
-
-package no.nordicsemi.android.dfu;
-
-import android.annotation.SuppressLint;
-import android.app.Activity;
-import android.app.IntentService;
-import android.bluetooth.BluetoothAdapter;
-import android.bluetooth.BluetoothDevice;
-import android.bluetooth.BluetoothGatt;
-import android.bluetooth.BluetoothGattCallback;
-import android.bluetooth.BluetoothGattCharacteristic;
-import android.bluetooth.BluetoothGattDescriptor;
-import android.bluetooth.BluetoothGattService;
-import android.bluetooth.BluetoothManager;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.SharedPreferences;
-import android.database.Cursor;
-import android.net.Uri;
-import android.os.Build;
-import android.os.ResultReceiver;
-import android.os.SystemClock;
-import android.preference.PreferenceManager;
-import android.provider.MediaStore;
-import android.support.v4.content.LocalBroadcastManager;
-import android.util.Log;
-
-import java.io.ByteArrayInputStream;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.lang.reflect.Method;
-import java.util.Locale;
-import java.util.UUID;
-
-import no.nordicsemi.android.dfu.exception.DeviceDisconnectedException;
-import no.nordicsemi.android.dfu.exception.DfuException;
-import no.nordicsemi.android.dfu.exception.HexFileValidationException;
-import no.nordicsemi.android.dfu.exception.RemoteDfuException;
-import no.nordicsemi.android.dfu.exception.UnknownResponseException;
-import no.nordicsemi.android.dfu.exception.UploadAbortedException;
-import no.nordicsemi.android.error.GattError;
-
-/**
- * The DFU Service provides full support for Over-the-Air (OTA) Device Firmware Update (DFU) by Nordic Semiconductor.
- * With the Soft Device 7.0.0+ it allows to upload a new Soft Device, new Bootloader and a new Application. For older soft devices only the Application update is supported.
- * <p>
- * To run the service to your application extend it in your project and overwrite the missing method. Remember to add your class to the AndroidManifest.xml file.
- * </p>
- * <p>
- * Start the service with the following parameters:
- * <p/>
- * <pre>
- * final Intent service = new Intent(this, YourDfuService.class);
- * service.putExtra(DfuService.EXTRA_DEVICE_ADDRESS, mSelectedDevice.getAddress()); // Target device address
- * service.putExtra(DfuService.EXTRA_DEVICE_NAME, mSelectedDevice.getName()); // This name will be shown on the notification
- * service.putExtra(DfuService.EXTRA_FILE_MIME_TYPE, mFileType == DfuService.TYPE_AUTO ? YourDfuService.MIME_TYPE_ZIP : YourDfuService.MIME_TYPE_OCTET_STREAM);
- * service.putExtra(DfuService.EXTRA_FILE_TYPE, mFileType);
- * service.putExtra(DfuService.EXTRA_FILE_PATH, mFilePath);
- * service.putExtra(DfuService.EXTRA_FILE_URI, mFileStreamUri);
- * // optionally
- * service.putExtra(DfuService.EXTRA_INIT_FILE_PATH, mInitFilePath);
- * service.putExtra(DfuService.EXTRA_INIT_FILE_URI, mInitFileStreamUri);
- * service.putExtra(DfuService.EXTRA_RESTORE_BOND, mRestoreBond);
- * startService(service);
- * </pre>
- * <p/>
- * The {@link #EXTRA_FILE_MIME_TYPE} and {@link #EXTRA_FILE_TYPE} parameters are optional. If not provided the application upload from HEX/BIN file is assumed.
- * The service API is compatible with previous versions.
- * </p>
- * <p>
- * The service will show its progress on the notification bar and will send local broadcasts to the application.
- * </p>
- */
-public abstract class DfuBaseService extends IntentService {
-
-    private static final String TAG = "DfuBaseService";
-    //private static final boolean DEBUG = BuildConfig.DEBUG;
-    private static final boolean DEBUG = true;
-
-    public static final String INTENT_RESULT_RECEIVER = "com.samsung.resultReceiver";
-    public static final String INTENT_REQUESTED_PHASE = "com.samsung.runonly.phase";
-
-    /**
-     * The address of the device to update.
-     */
-    public static final String EXTRA_DEVICE_ADDRESS = "no.nordicsemi.android.dfu.extra.EXTRA_DEVICE_ADDRESS";
-
-    /**
-     * The optional device name. This name will be shown in the notification.
-     */
-    public static final String EXTRA_DEVICE_NAME = "no.nordicsemi.android.dfu.extra.EXTRA_DEVICE_NAME";
-
-    public static final String EXTRA_DEVICE_PAIR_CODE = "no.nordicsemi.android.dfu.extra.EXTRA_DEVICE_PAIR_CODE";
-    /**
-     * <p>
-     * If the new firmware (application) does not share the bond information with the old one, the bond information is lost. Set this flag to <code>true</code>
-     * to make the service create new bond with the new application when the upload is done (and remove the old one). When set to <code>false</code> (default),
-     * the DFU service assumes that the LTK is shared between them. Note: currently it is not possible to remove the old bond without creating a new one so if
-     * your old application supported bonding while the new one does not you have to modify the source code yourself.
-     * </p>
-     * <p>
-     * In case of updating the soft device the application is always removed together with the bond information.
-     * </p>
-     * <p>
-     * Search for occurrences of EXTRA_RESTORE_BOND in this file to check the implementation and get more details.
-     * </p>
-     */
-    public static final String EXTRA_RESTORE_BOND = "no.nordicsemi.android.dfu.extra.EXTRA_RESTORE_BOND";
-
-    /**
-     * <p>This flag indicated whether the bond information should be kept or removed after an upgrade of the Application.
-     * If an application is being updated on a bonded device with the DFU Bootloader that has been configured to preserve the bond information for the new application,
-     * set it to <code>true</code>.</p>
-     * <p/>
-     * <p>By default the DFU Bootloader clears the whole application's memory. It may be however configured in the \Nordic\nrf51\components\libraries\bootloader_dfu\dfu_types.h
-     * file (line 56: <code>#define DFU_APP_DATA_RESERVED 0x0000</code>) to preserve some pages. The BLE_APP_HRM_DFU sample app stores the LTK and System Attributes in the first
-     * two pages, so in order to preserve the bond information this value should be changed to 0x0800 or more.
-     * When those data are preserved, the new Application will notify the app with the Service Changed indication when launched for the first time. Otherwise this
-     * service will remove the bond information from the phone and force to refresh the device cache (see {@link #refreshDeviceCache(android.bluetooth.BluetoothGatt, boolean)}).</p>
-     * <p/>
-     * <p>In contrast to {@link #EXTRA_RESTORE_BOND} this flag will not remove the old bonding and recreate a new one, but will keep the bond information untouched.</p>
-     * <p>The default value of this flag is <code>false</code></p>
-     */
-    public static final String EXTRA_KEEP_BOND = "no.nordicsemi.android.dfu.extra.EXTRA_KEEP_BOND";
-
-    /**
-     * A path to the file with the new firmware. It may point to a HEX, BIN or a ZIP file.
-     * Some file manager applications return the path as a String while other return a Uri. Use the {@link #EXTRA_FILE_URI} in the later case.
-     */
-    public static final String EXTRA_FILE_PATH = "no.nordicsemi.android.dfu.extra.EXTRA_FILE_PATH";
-
-    /**
-     * See {@link #EXTRA_FILE_PATH} for details.
-     */
-    public static final String EXTRA_FILE_URI = "no.nordicsemi.android.dfu.extra.EXTRA_FILE_URI";
-    /**
-     * The Init packet URI. This file is required if the Extended Init Packet is required (SDK 7.0+). Must point to a 'dat' file corresponding with the selected firmware.
-     * The Init packet may contain just the CRC (in case of older versions of DFU) or the Extended Init Packet in binary format (SDK 7.0+).
-     */
-    public static final String EXTRA_INIT_FILE_PATH = "no.nordicsemi.android.dfu.extra.EXTRA_INIT_FILE_PATH";
-
-    /**
-     * The Init packet URI. This file is required if the Extended Init Packet is required (SDK 7.0+). Must point to a 'dat' file corresponding with the selected firmware.
-     * The Init packet may contain just the CRC (in case of older versions of DFU) or the Extended Init Packet in binary format (SDK 7.0+).
-     */
-    public static final String EXTRA_INIT_FILE_URI = "no.nordicsemi.android.dfu.extra.EXTRA_INIT_FILE_URI";
-
-    /**
-     * The input file mime-type. Currently only "application/zip" (ZIP) or "application/octet-stream" (HEX or BIN) are supported. If this parameter is
-     * empty the "application/octet-stream" is assumed.
-     */
-    public static final String EXTRA_FILE_MIME_TYPE = "no.nordicsemi.android.dfu.extra.EXTRA_MIME_TYPE";
-
-    // Since the DFU Library version 0.5 both HEX and BIN files are supported. As both files have the same MIME TYPE the distinction is made based on the file extension.
-    public static final String MIME_TYPE_OCTET_STREAM = "application/octet-stream";
-    public static final String MIME_TYPE_ZIP = "application/zip";
-
-    public static final String EXTRA_WAIT_FOR_INIT_DEVICE_FIRMWARE = "com.samsung.microbit.WAIT_FOR_INIT";
-
-    /**
-     * This optional extra parameter may contain a file type. Currently supported are:
-     * <ul>
-     * <li>{@link #TYPE_SOFT_DEVICE} - only Soft Device update</li>
-     * <li>{@link #TYPE_BOOTLOADER} - only Bootloader update</li>
-     * <li>{@link #TYPE_APPLICATION} - only application update</li>
-     * <li>{@link #TYPE_AUTO} - the file is a ZIP file that may contain more than one HEX/BIN + DAT files. Since SDK 8.0 the ZIP Distribution packet is a recommended
-     * way of delivering firmware files. Please, see the DFU documentation for more details. A ZIP distribution packet may be created using the 'nrf utility'
-     * command line application, that is a part of Master Control Panel 3.8.0.The ZIP file MAY contain only the following files:
-     * <b>softdevice.hex/bin</b>, <b>bootloader.hex/bin</b>, <b>application.hex/bin</b> to determine the type based on its name. At lease one of them MUST be present.
-     * </li>
-     * </ul>
-     * If this parameter is not provided the type is assumed as follows:
-     * <ol>
-     * <li>If the {@link #EXTRA_FILE_MIME_TYPE} field is <code>null</code> or is equal to {@value #MIME_TYPE_OCTET_STREAM} - the {@link #TYPE_APPLICATION} is assumed.</li>
-     * <li>If the {@link #EXTRA_FILE_MIME_TYPE} field is equal to {@value #MIME_TYPE_ZIP} - the {@link #TYPE_AUTO} is assumed.</li>
-     * </ol>
-     */
-    public static final String EXTRA_FILE_TYPE = "no.nordicsemi.android.dfu.extra.EXTRA_FILE_TYPE";
-
-    /**
-     * <p>
-     * The file contains a new version of Soft Device.
-     * </p>
-     * <p>
-     * Since DFU Library 7.0 all firmware may contain an Init packet. The Init packet is required if Extended Init Packet is used by the DFU bootloader (SDK 7.0+)..
-     * The Init packet for the bootloader must be placed in the .dat file.
-     * </p>
-     *
-     * @see #EXTRA_FILE_TYPE
-     */
-    public static final int TYPE_SOFT_DEVICE = 0x01;
-
-    /**
-     * <p>
-     * The file contains a new version of Bootloader.
-     * </p>
-     * <p>
-     * Since DFU Library 7.0 all firmware may contain an Init packet. The Init packet is required if Extended Init Packet is used by the DFU bootloader (SDK 7.0+).
-     * The Init packet for the bootloader must be placed in the .dat file.
-     * </p>
-     *
-     * @see #EXTRA_FILE_TYPE
-     */
-    public static final int TYPE_BOOTLOADER = 0x02;
-
-    /**
-     * <p>
-     * The file contains a new version of Application.
-     * </p>
-     * <p>
-     * Since DFU Library 0.5 all firmware may contain an Init packet. The Init packet is required if Extended Init Packet is used by the DFU bootloader (SDK 7.0+).
-     * The Init packet for the application must be placed in the .dat file.
-     * </p>
-     *
-     * @see #EXTRA_FILE_TYPE
-     */
-    public static final int TYPE_APPLICATION = 0x04;
-
-    /**
-     * <p>
-     * A ZIP file that consists of more than 1 file. Since SDK 8.0 the ZIP Distribution packet is a recommended way of delivering firmware files. Please, see the DFU documentation for
-     * more details. A ZIP distribution packet may be created using the 'nrf utility' command line application, that is a part of Master Control Panel 3.8.0.
-     * For backwards compatibility this library supports also ZIP files without the manifest file. Instead they must follow the fixed naming convention:
-     * The names of files in the ZIP must be: <b>softdevice.hex</b> (or .bin), <b>bootloader.hex</b> (or .bin), <b>application.hex</b> (or .bin) in order
-     * to be read correctly. Using the Soft Device v7.0.0+ the Soft Device and Bootloader may be updated and sent together. In case of additional application file included,
-     * the service will try to send Soft Device, Bootloader and Application together (which is not supported currently) and if it fails, send first SD+BL, reconnect and send the application
-     * in the following connection.
-     * </p>
-     * <p>
-     * Since the DFU Library 0.5 you may specify the Init packet, that will be send prior to the firmware. The init packet contains some verification data, like a device type and
-     * revision, application version or a list of supported Soft Devices. The Init packet is required if Extended Init Packet is used by the DFU bootloader (SDK 7.0+).
-     * In case of using the compatibility ZIP files the Init packet for the Soft Device and Bootloader must be in the 'system.dat' file while for the application
-     * in the 'application.dat' file (included in the ZIP). The CRC in the 'system.dat' must be a CRC of both BIN contents if both a Soft Device and a Bootloader is present.
-     * </p>
-     *
-     * @see #EXTRA_FILE_TYPE
-     */
-    public static final int TYPE_AUTO = 0x00;
-
-    /**
-     * An extra field with progress and error information used in broadcast events.
-     */
-    public static final String EXTRA_DATA = "no.nordicsemi.android.dfu.extra.EXTRA_DATA";
-
-    /**
-     * An extra field to send the progress or error information in the DFU notification. The value may contain:
-     * <ul>
-     * <li>Value 0 - 100 - percentage progress value</li>
-     * <li>One of the following status constants:
-     * <ul>
-     * <li>{@link #PROGRESS_CONNECTING}</li>
-     * <li>{@link #PROGRESS_STARTING}</li>
-     * <li>{@link #PROGRESS_ENABLING_DFU_MODE}</li>
-     * <li>{@link #PROGRESS_VALIDATING}</li>
-     * <li>{@link #PROGRESS_DISCONNECTING}</li>
-     * <li>{@link #PROGRESS_COMPLETED}</li>
-     * <li>{@link #PROGRESS_ABORTED}</li>
-     * </ul>
-     * </li>
-     * <li>An error code with {@link #ERROR_MASK} if initialization error occurred</li>
-     * <li>An error code with {@link #ERROR_REMOTE_MASK} if remote DFU target returned an error</li>
-     * <li>An error code with {@link #ERROR_CONNECTION_MASK} if connection error occurred (f.e. GATT error (133) or Internal GATT Error (129))</li>
-     * </ul>
-     * To check if error occurred use:<br />
-     * {@code boolean error = progressValue >= DfuBaseService.ERROR_MASK;}
-     */
-    public static final String EXTRA_PROGRESS = "no.nordicsemi.android.dfu.extra.EXTRA_PROGRESS";
-
-    /**
-     * The number of currently transferred part. The SoftDevice and Bootloader may be send together as one part. If user wants to upload them together with an application it has to be sent
-     * in another connection as the second part.
-     *
-     * @see no.nordicsemi.android.dfu.DfuBaseService#EXTRA_PARTS_TOTAL
-     */
-    public static final String EXTRA_PART_CURRENT = "no.nordicsemi.android.dfu.extra.EXTRA_PART_CURRENT";
-
-    /**
-     * Number of parts in total.
-     *
-     * @see no.nordicsemi.android.dfu.DfuBaseService#EXTRA_PART_CURRENT
-     */
-    public static final String EXTRA_PARTS_TOTAL = "no.nordicsemi.android.dfu.extra.EXTRA_PARTS_TOTAL";
-
-    /**
-     * The current upload speed in bytes/millisecond.
-     */
-    public static final String EXTRA_SPEED_B_PER_MS = "no.nordicsemi.android.dfu.extra.EXTRA_SPEED_B_PER_MS";
-
-    /**
-     * The average upload speed in bytes/millisecond for the current part.
-     */
-    public static final String EXTRA_AVG_SPEED_B_PER_MS = "no.nordicsemi.android.dfu.extra.EXTRA_AVG_SPEED_B_PER_MS";
-    /**
-     * The broadcast message contains the following extras:
-     * <ul>
-     * <li>{@link #EXTRA_DATA} - the progress value (percentage 0-100) or:
-     * <ul>
-     * <li>{@link #PROGRESS_CONNECTING}</li>
-     * <li>{@link #PROGRESS_STARTING}</li>
-     * <li>{@link #PROGRESS_ENABLING_DFU_MODE}</li>
-     * <li>{@link #PROGRESS_VALIDATING}</li>
-     * <li>{@link #PROGRESS_DISCONNECTING}</li>
-     * <li>{@link #PROGRESS_COMPLETED}</li>
-     * <li>{@link #PROGRESS_ABORTED}</li>
-     * </ul>
-     * </li>
-     * <li>{@link #EXTRA_DEVICE_ADDRESS} - the target device address</li>
-     * <li>{@link #EXTRA_PART_CURRENT} - the number of currently transmitted part</li>
-     * <li>{@link #EXTRA_PARTS_TOTAL} - total number of parts that are being sent, f.e. if a ZIP file contains a Soft Device, a Bootloader and an Application,
-     * the SoftDevice and Bootloader will be send together as one part. Then the service will disconnect and reconnect to the new Bootloader and send the
-     * application as part number two.</li>
-     * <li>{@link #EXTRA_SPEED_B_PER_MS} - current speed in bytes/millisecond as float</li>
-     * <li>{@link #EXTRA_AVG_SPEED_B_PER_MS} - the average transmission speed in bytes/millisecond as float</li>
-     * </ul>
-     */
-    public static final String BROADCAST_PROGRESS = "no.nordicsemi.android.dfu.broadcast.BROADCAST_PROGRESS";
-
-    /**
-     * Service is connecting to the remote DFU target.
-     */
-    public static final int PROGRESS_CONNECTING = -1;
-
-    /**
-     * Service is enabling notifications and starting transmission.
-     */
-    public static final int PROGRESS_STARTING = -2;
-
-    /**
-     * Service has triggered a switch to bootloader mode. Now the service waits for the link loss event (this may take up to several seconds) and will connect again
-     * to the same device, now started in the bootloader mode.
-     */
-    public static final int PROGRESS_ENABLING_DFU_MODE = -3;
-
-    /**
-     * Service is sending validation request to the remote DFU target.
-     */
-    public static final int PROGRESS_VALIDATING = -4;
-
-    /**
-     * Service is disconnecting from the DFU target.
-     */
-    public static final int PROGRESS_DISCONNECTING = -5;
-
-    /**
-     * The connection is successful.
-     */
-    public static final int PROGRESS_COMPLETED = -6;
-
-    /**
-     * The upload has been aborted. Previous software version will be restored on the target.
-     */
-    public static final int PROGRESS_ABORTED = -7;
-
-    public static final int PROGRESS_SERVICE_NOT_FOUND = -10;
-
-
-    public static final int PROGRESS_VALIDATION_FAILED = -8;
-
-
-    public static final int PROGRESS_WAITING_REBOOT = -9;
-    /**
-     * The broadcast error message contains the following extras:
-     * <ul>
-     * <li>{@link #EXTRA_DATA} - the error number. Use {@link GattError#parse(int)} to get String representation</li>
-     * <li>{@link #EXTRA_DEVICE_ADDRESS} - the target device address</li>
-     * </ul>
-     */
-    public static final String BROADCAST_ERROR = "no.nordicsemi.android.dfu.broadcast.BROADCAST_ERROR";
-
-    /**
-     * The type of the error. This extra contains information about that kind of error has occurred. Connection state errors and other errors may share the same numbers.
-     * For example, the {@link BluetoothGattCallback#onCharacteristicWrite(BluetoothGatt, BluetoothGattCharacteristic, int)} method may return a status code 8 (GATT INSUF AUTHORIZATION),
-     * while the status code 8 returned by {@link BluetoothGattCallback#onConnectionStateChange(BluetoothGatt, int, int)} is a GATT CONN TIMEOUT error.
-     */
-    public static final String EXTRA_ERROR_TYPE = "no.nordicsemi.android.dfu.extra.EXTRA_ERROR_TYPE";
-    public static final int ERROR_TYPE_OTHER = 0;
-    public static final int ERROR_TYPE_COMMUNICATION_STATE = 1;
-    public static final int ERROR_TYPE_COMMUNICATION = 2;
-    public static final int ERROR_TYPE_DFU_REMOTE = 3;
-
-    /**
-     * If this bit is set than the progress value indicates an error. Use {@link GattError#parse(int)} to obtain error name.
-     */
-    public static final int ERROR_MASK = 0x1000;
-    public static final int ERROR_DEVICE_DISCONNECTED = ERROR_MASK; // | 0x00;
-    public static final int ERROR_FILE_NOT_FOUND = ERROR_MASK | 0x01;
-
-    /**
-     * Thrown if service was unable to open the file ({@link java.io.IOException} has been thrown).
-     */
-    public static final int ERROR_FILE_ERROR = ERROR_MASK | 0x02;
-
-    /**
-     * Thrown then input file is not a valid HEX or ZIP file.
-     */
-    public static final int ERROR_FILE_INVALID = ERROR_MASK | 0x03;
-
-    /**
-     * Thrown when {@link java.io.IOException} occurred when reading from file.
-     */
-    public static final int ERROR_FILE_IO_EXCEPTION = ERROR_MASK | 0x04;
-
-    /**
-     * Error thrown then {@code gatt.discoverServices();} returns false.
-     */
-    public static final int ERROR_SERVICE_DISCOVERY_NOT_STARTED = ERROR_MASK | 0x05;
-
-    /**
-     * Thrown when the service discovery has finished but the DFU service has not been found. The device does not support DFU of is not in DFU mode.
-     */
-    public static final int ERROR_SERVICE_NOT_FOUND = ERROR_MASK | 0x06;
-
-    /**
-     * Thrown when the required DFU service has been found but at least one of the DFU characteristics is absent.
-     */
-    public static final int ERROR_CHARACTERISTICS_NOT_FOUND = ERROR_MASK | 0x07;
-
-    /**
-     * Thrown when unknown response has been obtained from the target. The DFU target must follow specification.
-     */
-    public static final int ERROR_INVALID_RESPONSE = ERROR_MASK | 0x08;
-
-    /**
-     * Thrown when the the service does not support given type or mime-type.
-     */
-    public static final int ERROR_FILE_TYPE_UNSUPPORTED = ERROR_MASK | 0x09;
-
-    /**
-     * Thrown when the the Bluetooth adapter is disabled.
-     */
-    public static final int ERROR_BLUETOOTH_DISABLED = ERROR_MASK | 0x0A;
-    /**
-     * DFU Bootloader version 0.6+ requires sending the Init packet. If such bootloader version is detected, but the init packet has not been set this error is thrown.
-     */
-    public static final int ERROR_INIT_PACKET_REQUIRED = ERROR_MASK | 0x0B;
-    /**
-     * Thrown when the firmware file is not word-aligned. The firmware size must be dividable by 4 bytes.
-     */
-    public static final int ERROR_FILE_SIZE_INVALID = ERROR_MASK | 0x0C;
-    /**
-     * Flag set then the DFU target returned a DFU error. Look for DFU specification to get error codes.
-     */
-    public static final int ERROR_REMOTE_MASK = 0x2000;
-
-    /**
-     * The flag set when one of {@link android.bluetooth.BluetoothGattCallback} methods was called with status other than {@link android.bluetooth.BluetoothGatt#GATT_SUCCESS}.
-     */
-    public static final int ERROR_CONNECTION_MASK = 0x4000;
-
-    /**
-     * The flag set when the {@link android.bluetooth.BluetoothGattCallback#onConnectionStateChange(android.bluetooth.BluetoothGatt, int, int)} method was called with
-     * status other than {@link android.bluetooth.BluetoothGatt#GATT_SUCCESS}.
-     */
-    public static final int ERROR_CONNECTION_STATE_MASK = 0x8000;
-
-    /**
-     * The log events are only broadcast when there is no nRF Logger installed. The broadcast contains 2 extras:
-     * <ul>
-     * <li>{@link #EXTRA_LOG_LEVEL} - The log level, one of following: {@link #LOG_LEVEL_DEBUG}, {@link #LOG_LEVEL_VERBOSE}, {@link #LOG_LEVEL_INFO},
-     * {@link #LOG_LEVEL_APPLICATION}, {@link #LOG_LEVEL_WARNING}, {@link #LOG_LEVEL_ERROR}</li>
-     * <li>{@link #EXTRA_LOG_MESSAGE}</li> - The log message
-     * </ul>
-     */
-    public static final String BROADCAST_LOG = "no.nordicsemi.android.dfu.broadcast.BROADCAST_LOG";
-    public static final String EXTRA_LOG_MESSAGE = "no.nordicsemi.android.dfu.extra.EXTRA_LOG_INFO";
-    public static final String EXTRA_LOG_LEVEL = "no.nordicsemi.android.dfu.extra.EXTRA_LOG_LEVEL";
-
-	/*
-     * Note:
-	 * The nRF Logger API library has been excluded from the DfuLibrary.
-	 * All log events are now being sent using local broadcasts and may be logged into nRF Logger in the app module.
-	 * This is to make the Dfu module independent from logging tool.
-	 *
-	 * The log levels below are equal to log levels in nRF Logger API library, v 2.0.
-	 * @see https://github.com/NordicSemiconductor/nRF-Logger-API
-	 */
-    /**
-     * Level used just for debugging purposes. It has lowest level
-     */
-    public final static int LOG_LEVEL_DEBUG = 0;
-
-    /**
-     * Log entries with minor importance
-     */
-    public final static int LOG_LEVEL_VERBOSE = 1;
-
-    /**
-     * Default logging level for important entries
-     */
-    public final static int LOG_LEVEL_INFO = 5;
-
-    /**
-     * Log entries level for applications
-     */
-    public final static int LOG_LEVEL_APPLICATION = 10;
-
-    /**
-     * Log entries with high importance
-     */
-    public final static int LOG_LEVEL_WARNING = 15;
-
-    /**
-     * Log entries with very high importance, like errors
-     */
-    public final static int LOG_LEVEL_ERROR = 20;
-
-    public final static int LOG_LEVEL_BINARY_SIZE = 21;
-    public final static int LOG_LEVEL_HEX_SIZE = 22;
-    public final static int LOG_LEVEL_FIRMWARE = 23;
-
-    /**
-     * Activity may broadcast this broadcast in order to pause, resume or abort DFU process.
-     * Use {@link #EXTRA_ACTION} extra to pass the action.
-     */
-    public static final String BROADCAST_ACTION = "no.nordicsemi.android.dfu.broadcast.BROADCAST_ACTION";
-
-    /**
-     * The action extra. It may have one of the following values: {@link #ACTION_PAUSE}, {@link #ACTION_RESUME}, {@link #ACTION_ABORT}.
-     */
-    public static final String EXTRA_ACTION = "no.nordicsemi.android.dfu.extra.EXTRA_ACTION";
-
-    /**
-     * Pauses the upload. The service will wait for broadcasts with the action set to {@link #ACTION_RESUME} or {@link #ACTION_ABORT}.
-     */
-    public static final int ACTION_PAUSE = 0;
-
-    /**
-     * Resumes the upload that has been paused before using {@link #ACTION_PAUSE}.
-     */
-    public static final int ACTION_RESUME = 1;
-
-    /**
-     * Aborts the upload. The service does not need to be paused before.
-     * After sending {@link #BROADCAST_ACTION} with extra {@link #EXTRA_ACTION} set to this value the DFU bootloader will restore the old application
-     * (if there was already an application). Be aware that uploading the Soft Device will erase the application in order to make space in the memory.
-     * In case there is no application, or the application has been removed, the DFU bootloader will be started and user may try to send the application again.
-     * The bootloader may advertise with the address incremented by 1 to prevent caching services.
-     */
-    public static final int ACTION_ABORT = 2;
-
-    // DFU status values
-    public static final int DFU_STATUS_SUCCESS = 1;
-    public static final int DFU_STATUS_INVALID_STATE = 2;
-    public static final int DFU_STATUS_NOT_SUPPORTED = 3;
-    public static final int DFU_STATUS_DATA_SIZE_EXCEEDS_LIMIT = 4;
-    public static final int DFU_STATUS_CRC_ERROR = 5;
-    public static final int DFU_STATUS_OPERATION_FAILED = 6;
-
-    // Operation codes and packets
-    private static final int OP_CODE_START_DFU_KEY = 0x01; // 1
-    private static final int OP_CODE_INIT_DFU_PARAMS_KEY = 0x02; // 2
-    private static final int OP_CODE_RECEIVE_FIRMWARE_IMAGE_KEY = 0x03; // 3
-    private static final int OP_CODE_VALIDATE_KEY = 0x04; // 4
-    private static final int OP_CODE_ACTIVATE_AND_RESET_KEY = 0x05; // 5
-    private static final int OP_CODE_RESET_KEY = 0x06; // 6
-
-    //private static final int OP_CODE_PACKET_REPORT_RECEIVED_IMAGE_SIZE_KEY = 0x07; // 7
-    private static final int OP_CODE_PACKET_RECEIPT_NOTIF_REQ_KEY = 0x08; // 8
-    private static final int OP_CODE_RESPONSE_CODE_KEY = 0x10; // 16
-    private static final int OP_CODE_PACKET_RECEIPT_NOTIF_KEY = 0x11; // 11
-    private static final byte[] OP_CODE_START_DFU = new byte[]{OP_CODE_START_DFU_KEY, 0x00};
-    private static final byte[] OP_CODE_INIT_DFU_PARAMS_START = new byte[]{OP_CODE_INIT_DFU_PARAMS_KEY, 0x00};
-    private static final byte[] OP_CODE_INIT_DFU_PARAMS_COMPLETE = new byte[]{OP_CODE_INIT_DFU_PARAMS_KEY, 0x01};
-    private static final byte[] OP_CODE_RECEIVE_FIRMWARE_IMAGE = new byte[]{OP_CODE_RECEIVE_FIRMWARE_IMAGE_KEY};
-    private static final byte[] OP_CODE_VALIDATE = new byte[]{OP_CODE_VALIDATE_KEY};
-    private static final byte[] OP_CODE_ACTIVATE_AND_RESET = new byte[]{OP_CODE_ACTIVATE_AND_RESET_KEY};
-    private static final byte[] OP_CODE_RESET = new byte[]{OP_CODE_RESET_KEY};
-
-    //private static final byte[] OP_CODE_REPORT_RECEIVED_IMAGE_SIZE = new byte[] { OP_CODE_PACKET_REPORT_RECEIVED_IMAGE_SIZE_KEY };
-    private static final byte[] OP_CODE_PACKET_RECEIPT_NOTIF_REQ = new byte[]{OP_CODE_PACKET_RECEIPT_NOTIF_REQ_KEY, 0x00, 0x00};
-
-    private static final UUID DEVICE_INFORMATION_SERVICE_UUID = new UUID(0x0000180A00001000l, 0x800000805F9B34FBl);
-    private static final UUID FIRMWARE_REVISION_UUID = new UUID(0x00002A2600001000l, 0x800000805F9B34FBl);
-
-
-    // UUIDs used by the DFU
-    private static final UUID GENERIC_ATTRIBUTE_SERVICE_UUID = new UUID(0x0000180100001000l, 0x800000805F9B34FBl);
-    private static final UUID SERVICE_CHANGED_UUID = new UUID(0x00002A0500001000l, 0x800000805F9B34FBl);
-
-    private static final UUID DFU_SERVICE_UUID = new UUID(0x000015301212EFDEl, 0x1523785FEABCD123l);
-    private static final UUID DFU_CONTROL_POINT_UUID = new UUID(0x000015311212EFDEl, 0x1523785FEABCD123l);
-    private static final UUID DFU_PACKET_UUID = new UUID(0x000015321212EFDEl, 0x1523785FEABCD123l);
-
-    private static final UUID DFU_VERSION = new UUID(0x000015341212EFDEl, 0x1523785FEABCD123l);
-    private static final UUID CLIENT_CHARACTERISTIC_CONFIG = new UUID(0x0000290200001000l, 0x800000805f9b34fbl);
-
-    private static final UUID MINI_FLASH_SERVICE_UUID = UUID.fromString("E95D93B0-251D-470A-A062-FA1922DFA9A8");
-    private static final UUID MINI_FLASH_SERVICE_CONTROL_CHARACTERISTIC_UUID = UUID.fromString("E95D93B1-251D-470A-A062-FA1922DFA9A8");
-
-    private static final UUID CLIENT_CHARACTERISTIC_CONFIGURATION_DESCRIPTOR = UUID.fromString("00002902-0000-1000-8000-00805f9b34fb");
-
-    public static final int FLASHING_WITH_PAIR_CODE = 0x02;
-
-    public static final int NOTIFICATION_ID = 283; // a random number
-    private static final int NOTIFICATIONS = 1;
-    private static final int INDICATIONS = 2;
-    private static final char[] HEX_ARRAY = "0123456789ABCDEF".toCharArray();
-    private static final int MAX_PACKET_SIZE = 20; // the maximum number of bytes in one packet is 20. May be less.
-    private final byte[] mBuffer = new byte[MAX_PACKET_SIZE];
-
-    /**
-     * Lock used in synchronization purposes
-     */
-    private final Object mLock = new Object();
-    private BluetoothAdapter mBluetoothAdapter;
-    private InputStream mInputStream;
-    private String mDeviceAddress;
-    private String mDeviceName;
-
-    /**
-     * The current connection state. If its value is > 0 than an error has occurred. Error number is a negative value of mConnectionState
-     */
-    private volatile int mConnectionState;
-    private final static int STATE_DISCONNECTED = 0;
-    private final static int STATE_CONNECTING = -1;
-    private final static int STATE_CONNECTED = -2;
-    private final static int STATE_CONNECTED_AND_READY = -3; // indicates that services were discovered
-    private final static int STATE_DISCONNECTING = -4;
-    private final static int STATE_CLOSED = -5;
-
-    /**
-     * The number of the last error that has occurred or 0 if there was no error
-     */
-    private volatile int mError = 0;
-
-    /**
-     * Flag set when we got confirmation from the device that notifications are enabled.
-     */
-    private boolean mNotificationsEnabled;
-
-    /**
-     * Flag set when we got confirmation from the device that Service Changed indications are enabled.
-     */
-    private boolean mServiceChangedIndicationsEnabled;
-
-    /**
-     * The number of packets of firmware data to be send before receiving a new Packets receipt notification. 0 disables the packets notifications
-     */
-    private int mPacketsBeforeNotification = 10;
-
-    /**
-     * Size of BIN content of all hex files that are going to be transmitted.
-     */
-    private int mImageSizeInBytes;
-
-    /**
-     * Number of bytes transmitted.
-     */
-    private int mBytesSent;
-
-    /**
-     * Number of bytes confirmed by the notification.
-     */
-    @SuppressWarnings("unused")
-    private int mBytesConfirmed;
-    private int mPacketsSentSinceNotification;
-
-    /**
-     * This value is used to calculate the current transfer speed.
-     */
-    private int mLastBytesSent;
-
-    /**
-     * Firmware update may require two connections: one for Soft Device and/or Bootloader upload and second for Application. This fields contains the current part number.
-     */
-    private int mPartCurrent;
-
-    /**
-     * Total number of parts.
-     */
-    private int mPartsTotal;
-    private int mFileType;
-    private long mLastProgressTime, mStartTime;
-
-    /**
-     * Flag sent when a request has been sent that will cause the DFU target to reset. Often, after sending such command, Android throws a connection state error. If this flag is set the error will be
-     * ignored.
-     */
-    private boolean mResetRequestSent;
-
-    /**
-     * Flag indicating whether the image size has been already transferred or not
-     */
-    private boolean mImageSizeSent;
-
-    /**
-     * Flag indicating whether the init packet has been already transferred or not
-     */
-    private boolean mInitPacketSent;
-
-    /**
-     * Flag indicating whether the request was completed or not
-     */
-    private boolean mRequestCompleted;
-
-    /**
-     * <p>
-     * Flag set to <code>true</code> when the DFU target had send any notification with status other than {@link #DFU_STATUS_SUCCESS}. Setting it to <code>true</code> will abort sending firmware and
-     * stop logging notifications (read below for explanation).
-     * </p>
-     * <p>
-     * The onCharacteristicWrite(..) callback is written when Android puts the packet to the outgoing queue, not when it physically send the data. Therefore, in case of invalid state of the DFU
-     * target, Android will first put up to N* packets, one by one, while in fact the first will be transmitted. In case the DFU target is in an invalid state it will notify Android with a
-     * notification 10-03-02 for each packet of firmware that has been sent. However, just after receiving the first one this service will try to send the reset command while still getting more
-     * 10-03-02 notifications. This flag will prevent from logging "Notification received..." more than once.
-     * </p>
-     * <p>
-     * Additionally, sometimes after writing the command 6 ({@link #OP_CODE_RESET}), Android will receive a notification and update the characteristic value with 10-03-02 and the callback for write
-     * reset command will log "[DFU] Data written to ..., value (0x): 10-03-02" instead of "...(x0): 06". But this does not matter for the DFU process.
-     * </p>
-     * <p>
-     * N* - Value of Packet Receipt Notification, 10 by default.
-     * </p>
-     */
-    private boolean mRemoteErrorOccurred;
-    private boolean mPaused;
-    private boolean mAborted;
-
-    private long delayForInitDeviceFirmware;
-
-    private volatile BluetoothGatt gatt = null;
-    private volatile BluetoothDevice device = null;
-
-    /**
-     * Latest data received from device using notification.
-     */
-    private byte[] mReceivedData = null;
-
-    //static NotificationCompat.Builder builder=null;
-    private final BroadcastReceiver mConnectionStateBroadcastReceiver = new BroadcastReceiver() {
-
-        @Override
-        public void onReceive(final Context context, final Intent intent) {
-            // Obtain the device and check it this is the one that we are connected to
-            final BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
-            if (!device.getAddress().equals(mDeviceAddress))
-                return;
-
-            final String action = intent.getAction();
-
-            logi("Action received: " + action);
-            mConnectionState = STATE_DISCONNECTED;
-
-            // Notify waiting thread
-            synchronized (mLock) {
-                mLock.notifyAll();
-            }
-        }
-    };
-
-    private final BroadcastReceiver mDfuActionReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(final Context context, final Intent intent) {
-            final int action = intent.getIntExtra(EXTRA_ACTION, 0);
-
-            switch (action) {
-                case ACTION_PAUSE:
-                    mPaused = true;
-                    break;
-
-                case ACTION_RESUME:
-                    mPaused = false;
-
-                    // Notify waiting thread
-                    synchronized (mLock) {
-                        mLock.notifyAll();
-                    }
-                    break;
-
-                case ACTION_ABORT:
-                    mPaused = false;
-                    mAborted = true;
-
-                    // Notify waiting thread
-                    synchronized (mLock) {
-                        mLock.notifyAll();
-                    }
-                    break;
-            }
-        }
-    };
-
-    private final BroadcastReceiver mBondStateBroadcastReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(final Context context, final Intent intent) {
-            // Obtain the device and check it this is the one that we are connected to
-            final BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
-            if (!device.getAddress().equals(mDeviceAddress))
-                return;
-
-            // Read bond state
-            final int bondState = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, -1);
-            if (bondState == BluetoothDevice.BOND_BONDING)
-                return;
-
-            mRequestCompleted = true;
-
-            // Notify waiting thread
-            synchronized (mLock) {
-                mLock.notifyAll();
-            }
-        }
-    };
-
-    private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() {
-        @Override
-        public void onConnectionStateChange(final BluetoothGatt gatt, final int status, final int newState) {
-            // Check whether an error occurred
-            logi("onConnectionStateChange() :: Start");
-            if (status == BluetoothGatt.GATT_SUCCESS) {
-                if (newState == BluetoothGatt.STATE_CONNECTED) {
-                    logi("onConnectionStateChange() :: Connected to GATT server");
-                    mConnectionState = STATE_CONNECTED;
-
-					/*
-                     *  The onConnectionStateChange callback is called just after establishing connection and before sending Encryption Request BLE event in case of a paired device.
-					 *  In that case and when the Service Changed CCCD is enabled we will get the indication after initializing the encryption, about 1600 milliseconds later. 
-					 *  If we discover services right after connecting, the onServicesDiscovered callback will be called immediately, before receiving the indication and the following 
-					 *  service discovery and we may end up with old, application's services instead.
-					 *  
-					 *  This is to support the buttonless switch from application to bootloader mode where the DFU bootloader notifies the master about service change.
-					 *  Tested on Nexus 4 (Android 4.4.4 and 5), Nexus 5 (Android 5), Samsung Note 2 (Android 4.4.2). The time after connection to end of service discovery is about 1.6s 
-					 *  on Samsung Note 2.
-					 *  
-					 *  NOTE: We are doing this to avoid the hack with calling the hidden gatt.refresh() method, at least for bonded devices.
-					 */
-                    if (gatt.getDevice().getBondState() == BluetoothDevice.BOND_BONDED) {
-                        try {
-                            synchronized (this) {
-                                logd("onConnectionStateChange() :: Waiting 1600 ms for a possible Service Changed indication...");
-                                wait(1600);
-
-                                // After 1.6s the services are already discovered so the following gatt.discoverServices() finishes almost immediately.
-
-                                // NOTE: This also works with shorted waiting time. The gatt.discoverServices() must be called after the indication is received which is
-                                // about 600ms after establishing connection. Values 600 - 1600ms should be OK.
-                            }
-                        } catch (InterruptedException e) {
-                            Log.e(TAG, e.toString());
-                            // Do nothing
-                        }
-                    }
-
-                    // Attempts to discover services after successful connection.
-                    final boolean success = gatt.discoverServices();
-                    logi("onConnectionStateChange() :: Attempting to start service discovery... " + (success ? "succeed" : "failed"));
-
-                    if (!success) {
-                        mError = ERROR_SERVICE_DISCOVERY_NOT_STARTED;
-                    } else {
-                        // Just return here, lock will be notified when service discovery finishes
-                        return;
-                    }
-                } else if (newState == BluetoothGatt.STATE_DISCONNECTED) {
-                    logi("onConnectionStateChange() :: Disconnected from GATT server");
-                    mPaused = false;
-                    mConnectionState = STATE_DISCONNECTED;
-                }
-            } else {
-                loge("Connection state change error: " + status + " newState: " + newState);
-/*				if (newState == BluetoothGatt.STATE_DISCONNECTED) {
-                    mConnectionState = STATE_DISCONNECTED;
-                    if (mServicePhase == PAIRING_REQUEST ){
-                        mServicePhase = PAIRING_FAILED ;
-                        updateProgressNotification(status);
-                    }
-                }*/
-                mPaused = false;
-                mError = ERROR_CONNECTION_STATE_MASK | status;
-            }
-
-            // Notify waiting thread
-            synchronized (mLock) {
-                mLock.notifyAll();
-            }
-        }
-
-        @Override
-        public void onServicesDiscovered(final BluetoothGatt gatt, final int status) {
-            // Notify waiting thread
-            logi("onServicesDiscovered() :: Start");
-            if (status == BluetoothGatt.GATT_SUCCESS) {
-                logi("onServicesDiscovered() :: Services discovered");
-                mConnectionState = STATE_CONNECTED_AND_READY;
-            } else {
-                loge("onServicesDiscovered() :: Service discovery error: " + status);
-                mError = ERROR_CONNECTION_MASK | status;
-            }
-            synchronized (mLock) {
-                mLock.notifyAll();
-            }
-        }
-
-        @Override
-        public void onDescriptorRead(final BluetoothGatt gatt, final BluetoothGattDescriptor descriptor, final int status) {
-            if (status == BluetoothGatt.GATT_SUCCESS) {
-                if (CLIENT_CHARACTERISTIC_CONFIG.equals(descriptor.getUuid())) {
-                    if (SERVICE_CHANGED_UUID.equals(descriptor.getCharacteristic().getUuid())) {
-                        // We have enabled indications for the Service Changed characteristic
-                        mServiceChangedIndicationsEnabled = descriptor.getValue()[0] == 2;
-                        mRequestCompleted = true;
-                    }
-                }
-            } else {
-                loge("Descriptor read error: " + status);
-                mError = ERROR_CONNECTION_MASK | status;
-            }
-            // Notify waiting thread
-            synchronized (mLock) {
-                mLock.notifyAll();
-            }
-        }
-
-        @Override
-        public void onDescriptorWrite(final BluetoothGatt gatt, final BluetoothGattDescriptor descriptor, final int status) {
-
-            if (status == BluetoothGatt.GATT_SUCCESS) {
-                if (CLIENT_CHARACTERISTIC_CONFIG.equals(descriptor.getUuid())) {
-                    if (SERVICE_CHANGED_UUID.equals(descriptor.getCharacteristic().getUuid())) {
-                        // We have enabled indications for the Service Changed characteristic
-                        mServiceChangedIndicationsEnabled = descriptor.getValue()[0] == 2;
-                    } else {
-                        // We have enabled notifications for this characteristic
-                        mNotificationsEnabled = descriptor.getValue()[0] == 1;
-                    }
-                }
-            } else {
-                loge("Descriptor write error: " + status);
-                mError = ERROR_CONNECTION_MASK | status;
-            }
-            // Notify waiting thread
-            synchronized (mLock) {
-                mLock.notifyAll();
-            }
-        }
-
-        @Override
-        public void onCharacteristicWrite(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final int status) {
-            if (status == BluetoothGatt.GATT_SUCCESS) {
-				/*
-				 * This method is called when either a CONTROL POINT or PACKET characteristic has been written.
-				 * If it is the CONTROL POINT characteristic, just set the {@link mRequestCompleted} flag to true. The main thread will continue its task when notified.
-				 * If the PACKET characteristic was written we must:
-				 * - if the image size was written in DFU Start procedure, just set flag to true
-				 * otherwise
-				 * - send the next packet, if notification is not required at that moment, or
-				 * - do nothing, because we have to wait for the notification to confirm the data received
-				 */
-                if (DFU_PACKET_UUID.equals(characteristic.getUuid())) {
-                    if (mImageSizeSent && mInitPacketSent) {
-                        // If the PACKET characteristic was written with image data, update counters
-                        mBytesSent += characteristic.getValue().length;
-                        mPacketsSentSinceNotification++;
-
-                        // If a packet receipt notification is expected, or the last packet was sent, do nothing. There onCharacteristicChanged listener will catch either
-                        // a packet confirmation (if there are more bytes to send) or the image received notification (it upload process was completed)
-                        final boolean notificationExpected = mPacketsBeforeNotification > 0 && mPacketsSentSinceNotification == mPacketsBeforeNotification;
-                        final boolean lastPacketTransferred = mBytesSent == mImageSizeInBytes;
-
-                        if (notificationExpected || lastPacketTransferred)
-                            return;
-
-                        // When neither of them is true, send the next packet
-                        try {
-                            waitIfPaused();
-                            // The writing might have been aborted (mAborted = true), an error might have occurred.
-                            // In that case stop sending.
-                            if (mAborted || mError != 0 || mRemoteErrorOccurred || mResetRequestSent) {
-                                // notify waiting thread
-                                synchronized (mLock) {
-                                    sendLogBroadcast(LOG_LEVEL_WARNING, "Upload terminated");
-                                    mLock.notifyAll();
-                                    return;
-                                }
-                            }
-
-                            final byte[] buffer = mBuffer;
-                            final int size = mInputStream.read(buffer);
-                            writePacket(gatt, characteristic, buffer, size);
-                            updateProgressNotification();
-                            return;
-                        } catch (final HexFileValidationException e) {
-                            loge("Invalid HEX file");
-                            mError = ERROR_FILE_INVALID;
-                        } catch (final IOException e) {
-                            loge("Error while reading the input stream", e);
-                            mError = ERROR_FILE_IO_EXCEPTION;
-                        }
-                    } else if (!mImageSizeSent) {
-                        // We've got confirmation that the image size was sent
-                        sendLogBroadcast(LOG_LEVEL_INFO, "Data written to " + characteristic.getUuid() + ", value (0x): " + parse(characteristic));
-                        mImageSizeSent = true;
-                    } else {
-                        // We've got confirmation that the init packet was sent
-                        sendLogBroadcast(LOG_LEVEL_INFO, "Data written to " + characteristic.getUuid() + ", value (0x): " + parse(characteristic));
-                        mInitPacketSent = true;
-                    }
-                } else {
-                    // If the CONTROL POINT characteristic was written just set the flag to true. The main thread will continue its task when notified.
-                    sendLogBroadcast(LOG_LEVEL_INFO, "Data written to " + characteristic.getUuid() + ", value (0x): " + parse(characteristic));
-                    mRequestCompleted = true;
-                }
-            } else {
-				/*
-				 * If a Reset (Op Code = 6) or Activate and Reset (Op Code = 5) commands are sent, the DFU target resets and sometimes does it so quickly that does not manage to send
-				 * any ACK to the controller and error 133 is thrown here. This bug should be fixed in SDK 8.0+ where the target would gracefully disconnect before restarting.
-				 */
-                if (mResetRequestSent)
-                    mRequestCompleted = true;
-                else {
-                    loge("Characteristic write error: " + status);
-                    mError = ERROR_CONNECTION_MASK | status;
-                }
-            }
-
-            // Notify waiting thread
-            synchronized (mLock) {
-                mLock.notifyAll();
-            }
-        }
-
-        @Override
-        public void onCharacteristicRead(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final int status) {
-            if (status == BluetoothGatt.GATT_SUCCESS) {
-				/*
-				 * This method is called when the DFU Version characteristic has been read.
-				 */
-                sendLogBroadcast(LOG_LEVEL_INFO, "Read Response received from " + characteristic.getUuid() + ", value (0x): " + parse(characteristic));
-                mReceivedData = characteristic.getValue();
-                mRequestCompleted = true;
-            } else {
-                loge("Characteristic read error: " + status);
-                mError = ERROR_CONNECTION_MASK | status;
-            }
-
-            // Notify waiting thread
-            synchronized (mLock) {
-                mLock.notifyAll();
-            }
-        }
-
-        @Override
-        public void onCharacteristicChanged(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic) {
-            final int responseType = characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT8, 0);
-            switch (responseType) {
-                case OP_CODE_PACKET_RECEIPT_NOTIF_KEY:
-                    final BluetoothGattCharacteristic packetCharacteristic = gatt.getService(DFU_SERVICE_UUID).getCharacteristic(DFU_PACKET_UUID);
-
-                    try {
-                        mBytesConfirmed = characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT32, 1);
-                        mPacketsSentSinceNotification = 0;
-
-                        waitIfPaused();
-                        // The writing might have been aborted (mAborted = true), an error might have occurred.
-                        // In that case quit sending.
-                        if (mAborted || mError != 0 || mRemoteErrorOccurred || mResetRequestSent) {
-                            sendLogBroadcast(LOG_LEVEL_WARNING, "Upload terminated");
-                            break;
-                        }
-
-                        final byte[] buffer = mBuffer;
-                        final int size = mInputStream.read(buffer);
-                        writePacket(gatt, packetCharacteristic, buffer, size);
-                        updateProgressNotification();
-                        return;
-                    } catch (final HexFileValidationException e) {
-                        loge("Invalid HEX file");
-                        mError = ERROR_FILE_INVALID;
-                    } catch (final IOException e) {
-                        loge("Error while reading the input stream", e);
-                        mError = ERROR_FILE_IO_EXCEPTION;
-                    }
-                    break;
-
-                case OP_CODE_RESPONSE_CODE_KEY:
-                default:
-				/*
-				 * If the DFU target device is in invalid state (f.e. the Init Packet is required but has not been selected), the target will send DFU_STATUS_INVALID_STATE error
-				 * for each firmware packet that was send. We are interested may ignore all but the first one.
-				 * After obtaining a remote DFU error the OP_CODE_RESET_KEY will be sent.
-				 */
-                    if (mRemoteErrorOccurred)
-                        break;
-                    final int status = characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT8, 2);
-                    if (status != DFU_STATUS_SUCCESS)
-                        mRemoteErrorOccurred = true;
-
-                    sendLogBroadcast(LOG_LEVEL_INFO, "Notification received from " + characteristic.getUuid() + ", value (0x): " + parse(characteristic));
-                    mReceivedData = characteristic.getValue();
-                    break;
-            }
-
-            // Notify waiting thread
-            synchronized (mLock) {
-                mLock.notifyAll();
-            }
-        }
-
-        // This method is repeated here and in the service class for performance matters.
-        private String parse(final BluetoothGattCharacteristic characteristic) {
-            final byte[] data = characteristic.getValue();
-            if (data == null)
-                return "";
-            final int length = data.length;
-            if (length == 0)
-                return "";
-
-            final char[] out = new char[length * 3 - 1];
-            for (int j = 0; j < length; j++) {
-                int v = data[j] & 0xFF;
-                out[j * 3] = HEX_ARRAY[v >>> 4];
-                out[j * 3 + 1] = HEX_ARRAY[v & 0x0F];
-                if (j != length - 1)
-                    out[j * 3 + 2] = '-';
-            }
-            return new String(out);
-        }
-    };
-
-    /**
-     * Stores the last progress percent. Used to prevent from sending progress notifications with the same value.
-     *
-     * @see #updateProgressNotification(int)
-     */
-    private int mLastProgress = -1;
-
-    public DfuBaseService() {
-        super(TAG);
-    }
-
-    private static IntentFilter makeDfuActionIntentFilter() {
-        final IntentFilter intentFilter = new IntentFilter();
-        intentFilter.addAction(DfuBaseService.BROADCAST_ACTION);
-        return intentFilter;
-    }
-
-    @Override
-    public void onCreate() {
-        super.onCreate();
-
-        initialize();
-
-        final LocalBroadcastManager manager = LocalBroadcastManager.getInstance(this);
-        final IntentFilter actionFilter = makeDfuActionIntentFilter();
-        manager.registerReceiver(mDfuActionReceiver, actionFilter);
-        registerReceiver(mDfuActionReceiver, actionFilter); // Additionally we must register this receiver as a non-local to get broadcasts from the notification actions
-
-        final IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_ACL_DISCONNECTED);
-        registerReceiver(mConnectionStateBroadcastReceiver, filter);
-
-        final IntentFilter bondFilter = new IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
-        registerReceiver(mBondStateBroadcastReceiver, bondFilter);
-    }
-
-    @Override
-    public void onDestroy() {
-        super.onDestroy();
-        logi("DfuService onDestroy");
-        final LocalBroadcastManager manager = LocalBroadcastManager.getInstance(this);
-        manager.unregisterReceiver(mDfuActionReceiver);
-
-        unregisterReceiver(mDfuActionReceiver);
-        unregisterReceiver(mConnectionStateBroadcastReceiver);
-        unregisterReceiver(mBondStateBroadcastReceiver);
-
-    }
-
-    ResultReceiver resultReceiver;
-
-    private int mServicePhase = 0;
-
-    @Override
-    protected void onHandleIntent(final Intent intent) {
-
-
-        int phase = intent.getIntExtra(INTENT_REQUESTED_PHASE, 0) & 0x03;
-        resultReceiver = (ResultReceiver) intent.getParcelableExtra(INTENT_RESULT_RECEIVER);
-        delayForInitDeviceFirmware = intent.getLongExtra(EXTRA_WAIT_FOR_INIT_DEVICE_FIRMWARE, 0);
-
-        int rc = 0;
-
-        logi("DFUBaseService onHandleIntent phase = " + phase);
-        mServicePhase = 0;
-
-        if ((phase & FLASHING_WITH_PAIR_CODE) != 0) {
-            mServicePhase = FLASHING_WITH_PAIR_CODE;
-
-            rc = flashingWithPairCode(intent);
-        }
-
-        if (resultReceiver != null) {
-            rc <<= 8;
-            resultReceiver.send(rc | phase, null);
-        }
-    }
-
-    private boolean makeGattConnection(String deviceAddress) {
-
-        gatt = null;
-        sendLogBroadcast(LOG_LEVEL_VERBOSE, "makeGattConnection to target..." + deviceAddress);
-        updateProgressNotification(PROGRESS_CONNECTING);
-
-        if (delayForInitDeviceFirmware != 0) {
-            try {
-                synchronized (mLock) {
-                    mLock.wait(delayForInitDeviceFirmware);
-                }
-            } catch (InterruptedException e) {
-                Log.e(TAG, e.toString());
-            }
-            delayForInitDeviceFirmware = 0;
-        }
-
-        mConnectionState = STATE_DISCONNECTED;
-        mBytesSent = 0;
-        mBytesConfirmed = 0;
-        mPacketsSentSinceNotification = 0;
-        mError = 0;
-        mLastProgressTime = 0;
-        mAborted = false;
-        mPaused = false;
-        mNotificationsEnabled = false;
-        mResetRequestSent = false;
-        mRequestCompleted = false;
-        mImageSizeSent = false;
-        mRemoteErrorOccurred = false;
-
-        connect(deviceAddress);
-
-        // Are we connected?
-        if (gatt == null) {
-            loge("Bluetooth adapter disabled");
-            sendLogBroadcast(LOG_LEVEL_ERROR, "Bluetooth adapter disabled");
-            updateProgressNotification(ERROR_BLUETOOTH_DISABLED);
-            return false;
-        }
-
-        if (mError > 0) { // error occurred
-            final int error = mError & ~ERROR_CONNECTION_STATE_MASK;
-            loge("An error occurred while connecting to the device:" + error);
-            sendLogBroadcast(LOG_LEVEL_ERROR, String.format("Connection failed (0x%02X): %s", error, GattError.parseConnectionError(error)));
-            terminateConnection(gatt, mError);
-            return false;
-        }
-
-        if (mAborted) {
-            logi("Upload aborted");
-            sendLogBroadcast(LOG_LEVEL_WARNING, "Upload aborted");
-            terminateConnection(gatt, PROGRESS_ABORTED);
-            return false;
-        }
-
-        return true;
-    }
-
-    private int flashingWithPairCode(Intent intent) {
-
-        mDeviceAddress = intent.getStringExtra(EXTRA_DEVICE_ADDRESS);
-        mDeviceName = intent.getStringExtra(EXTRA_DEVICE_NAME);
-
-        sendLogBroadcast(LOG_LEVEL_VERBOSE, "Connecting to DFU target 2...");
-        if (!makeGattConnection(mDeviceAddress))
-            return 5;
-
-        logi("Phase2 s");
-
-        updateProgressNotification(PROGRESS_VALIDATING);
-
-        //For Stats purpose only
-        {
-            BluetoothGattService deviceService = gatt.getService(DEVICE_INFORMATION_SERVICE_UUID);
-            if (deviceService != null) {
-                BluetoothGattCharacteristic firmwareCharacteristic = deviceService.getCharacteristic(FIRMWARE_REVISION_UUID);
-                if (firmwareCharacteristic != null) {
-                    String firmware = null;
-                    firmware = readCharacteristicNoFailure(gatt, firmwareCharacteristic);
-                    logi("Firmware version String = " + firmware);
-                    sendStatsMiniFirmware(firmware);
-                } else {
-                    logi("Error Cannot find FIRMWARE_REVISION_UUID");
-                }
-            } else {
-                logi("Error Cannot find DEVICE_INFORMATION_SERVICE_UUID");
-            }
-        }//For Stats purpose only Ends
-        int rc = 1;
-
-        BluetoothGattService fps = gatt.getService(MINI_FLASH_SERVICE_UUID);
-        if (fps == null) {
-            logi("Error Cannot find MINI_FLASH_SERVICE_UUID");
-            sendLogBroadcast(LOG_LEVEL_WARNING, "Upload aborted");
-            terminateConnection(gatt, PROGRESS_SERVICE_NOT_FOUND);
-            return 6;
-        }
-
-        final BluetoothGattCharacteristic sfpc1 = fps.getCharacteristic(MINI_FLASH_SERVICE_CONTROL_CHARACTERISTIC_UUID);
-        if (sfpc1 == null) {
-            logi("Error Cannot find MINI_FLASH_SERVICE_CONTROL_CHARACTERISTIC_UUID");
-            sendLogBroadcast(LOG_LEVEL_WARNING, "Upload aborted");
-            terminateConnection(gatt, PROGRESS_SERVICE_NOT_FOUND);
-            return 6;
-        }
-
-        sfpc1.setValue(1, BluetoothGattCharacteristic.FORMAT_UINT8, 0);
-        try {
-            logi("Writing Flash Command ....");
-            writeCharacteristic(gatt, sfpc1);
-            rc = 0;
-        } catch (Exception e) {
-            e.printStackTrace();
-            Log.e(TAG, e.toString());
-        }
-
-        if (rc == 0) {
-            sendProgressBroadcast(PROGRESS_WAITING_REBOOT);
-            //Wait for the device to reboot.
-            waitUntilDisconnected();
-            waitUntilConnected();
-            logi("Refreshing the cache before discoverServices() for Android version " + Build.VERSION.SDK_INT);
-            refreshDeviceCache(gatt, true);
-            do {
-                logi("Calling phase 3");
-                mError = 0;
-                intent = phase3(intent);
-                resultReceiver = null;
-                gatt.disconnect();
-                waitUntilDisconnected();
-                if (mConnectionState != STATE_CLOSED) {
-                    close(gatt);
-                }
-                gatt = null;
-                logi("End phase 3");
-            } while (intent != null);
-        }
-
-        logi("Phase2 e");
-        return rc;
-    }
-
-    private Intent phase3(Intent intent) {
-        Log.i("OWN", "Phase 3 is fine");
-        final SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(this);
-
-        logi("Phase3 s");
-        // Read input parameters
-        final String deviceAddress = intent.getStringExtra(EXTRA_DEVICE_ADDRESS);
-        final String deviceName = intent.getStringExtra(EXTRA_DEVICE_NAME);
-        final String filePath = intent.getStringExtra(EXTRA_FILE_PATH);
-        final Uri fileUri = intent.getParcelableExtra(EXTRA_FILE_URI);
-        final String initFilePath = intent.getStringExtra(EXTRA_INIT_FILE_PATH);
-        final Uri initFileUri = intent.getParcelableExtra(EXTRA_INIT_FILE_URI);
-        int fileType = intent.getIntExtra(EXTRA_FILE_TYPE, TYPE_AUTO);
-        if (filePath != null && fileType == TYPE_AUTO)
-            fileType = filePath.toLowerCase(Locale.US).endsWith("zip") ? TYPE_AUTO : TYPE_APPLICATION;
-
-        String mimeType = intent.getStringExtra(EXTRA_FILE_MIME_TYPE);
-        mimeType = mimeType != null ? mimeType : (fileType == TYPE_AUTO ? MIME_TYPE_ZIP : MIME_TYPE_OCTET_STREAM);
-        mPartCurrent = intent.getIntExtra(EXTRA_PART_CURRENT, 1);
-        mPartsTotal = intent.getIntExtra(EXTRA_PARTS_TOTAL, 1);
-
-        mDeviceAddress = deviceAddress;
-        mDeviceName = deviceName;
-
-        // Read preferences
-        final boolean packetReceiptNotificationEnabled = preferences.getBoolean(DfuSettingsConstants.SETTINGS_PACKET_RECEIPT_NOTIFICATION_ENABLED, true);
-        String value = preferences.getString(DfuSettingsConstants.SETTINGS_NUMBER_OF_PACKETS, String.valueOf(DfuSettingsConstants.SETTINGS_NUMBER_OF_PACKETS_DEFAULT));
-        int numberOfPackets;
-        try {
-            numberOfPackets = Integer.parseInt(value);
-            if (numberOfPackets < 0 || numberOfPackets > 0xFFFF)
-                numberOfPackets = DfuSettingsConstants.SETTINGS_NUMBER_OF_PACKETS_DEFAULT;
-        } catch (final NumberFormatException e) {
-            numberOfPackets = DfuSettingsConstants.SETTINGS_NUMBER_OF_PACKETS_DEFAULT;
-            Log.e(TAG, e.toString());
-        }
-
-        if (!packetReceiptNotificationEnabled)
-            numberOfPackets = 0;
-
-        mPacketsBeforeNotification = numberOfPackets;
-        // The Soft Device starts where MBR ends (by default from the address 0x1000). Before there is a MBR section, which should not be transmitted over DFU.
-        // Applications and bootloader starts from bigger address. However, in custom DFU implementations, user may want to transmit the whole whole data, even from address 0x0000.
-        value = preferences.getString(DfuSettingsConstants.SETTINGS_MBR_SIZE, String.valueOf(DfuSettingsConstants.SETTINGS_DEFAULT_MBR_SIZE));
-        int mbrSize;
-        try {
-            mbrSize = Integer.parseInt(value);
-            if (mbrSize < 0)
-                mbrSize = 0;
-        } catch (final NumberFormatException e) {
-            mbrSize = DfuSettingsConstants.SETTINGS_DEFAULT_MBR_SIZE;
-            Log.e(TAG, e.toString());
-        }
-
-        sendLogBroadcast(LOG_LEVEL_VERBOSE, "Starting DFU service");
-
-		/*
-		 * First the service is trying to read the firmware and init packet files.
-		 */
-        InputStream is = null;
-        InputStream initIs = null;
-        int imageSizeInBytes;
-        try {
-            // Prepare data to send, calculate stream size
-            try {
-                sendLogBroadcast(LOG_LEVEL_VERBOSE, "Opening file...");
-                if (fileUri != null) {
-                    is = openInputStream(fileUri, mimeType, mbrSize, fileType);
-                } else {
-                    is = openInputStream(filePath, mimeType, mbrSize, fileType);
-                }
-
-                if (initFileUri != null) {
-                    // Try to read the Init Packet file from URI
-                    initIs = getContentResolver().openInputStream(initFileUri);
-                } else if (initFilePath != null) {
-                    // Try to read the Init Packet file from path
-                    initIs = new FileInputStream(initFilePath);
-                }
-
-                mInputStream = is;
-                imageSizeInBytes = mImageSizeInBytes = is.available();
-                // Update the file type bit field basing on the ZIP content
-                if (fileType == TYPE_AUTO && MIME_TYPE_ZIP.equals(mimeType)) {
-                    final ArchiveInputStream zhis = (ArchiveInputStream) is;
-                    fileType = zhis.getContentType();
-                }
-
-                mFileType = fileType;
-                // Set the Init packet stream in case of a ZIP file
-                if (MIME_TYPE_ZIP.equals(mimeType)) {
-                    final ArchiveInputStream zhis = (ArchiveInputStream) is;
-                    if (fileType == TYPE_APPLICATION) {
-                        if (zhis.getApplicationInit() != null)
-                            initIs = new ByteArrayInputStream(zhis.getApplicationInit());
-                    } else {
-                        if (zhis.getSystemInit() != null)
-                            initIs = new ByteArrayInputStream(zhis.getSystemInit());
-                    }
-                }
-
-                sendLogBroadcast(LOG_LEVEL_INFO, "Image file opened (" + mImageSizeInBytes + " bytes in total)");
-            } catch (final SecurityException e) {
-                loge("A security exception occurred while opening file", e);
-                updateProgressNotification(ERROR_FILE_NOT_FOUND);
-                return null;
-            } catch (final FileNotFoundException e) {
-                loge("An exception occurred while opening file", e);
-                updateProgressNotification(ERROR_FILE_NOT_FOUND);
-                return null;
-            } catch (final HexFileValidationException e) {
-                loge("HexFileValidationException - ", e);
-                updateProgressNotification(ERROR_FILE_INVALID);
-                return null;
-            } catch (final IOException e) {
-                loge("An exception occurred while calculating file size", e);
-                updateProgressNotification(ERROR_FILE_ERROR);
-                return null;
-            }
-
-			/*
-			 * Now let's connect to the device.
-			 * All the methods below are synchronous. The mLock object is used to wait for asynchronous calls.
-			 */
-
-            // Are we connected?
-            if (gatt != null) {
-                gatt.disconnect();
-                gatt.close();
-                gatt = null;
-            }
-
-            sendLogBroadcast(LOG_LEVEL_VERBOSE, "Connecting to DFU target 3...");
-            makeGattConnection(deviceAddress);
-            if (gatt == null) {
-
-                loge("Bluetooth adapter disabled");
-                sendLogBroadcast(LOG_LEVEL_ERROR, "Bluetooth adapter disabled");
-                updateProgressNotification(ERROR_BLUETOOTH_DISABLED);
-                return null;
-            }
-
-            if (mError > 0) { // error occurred
-                final int error = mError & ~ERROR_CONNECTION_STATE_MASK;
-                loge("An error occurred while connecting to the device:" + error);
-                sendLogBroadcast(LOG_LEVEL_ERROR, String.format("Connection failed (0x%02X): %s", error, GattError.parseConnectionError(error)));
-                terminateConnection(gatt, mError);
-                return null;
-            }
-
-            if (mAborted) {
-                logi("Upload aborted");
-                sendLogBroadcast(LOG_LEVEL_WARNING, "Upload aborted");
-                terminateConnection(gatt, PROGRESS_ABORTED);
-                return null;
-            }
-
-            // We have connected to DFU device and services are discoverer
-            BluetoothGattService dfuService = null;
-
-            dfuService = gatt.getService(DFU_SERVICE_UUID);
-
-            if (dfuService == null) {
-                disconnect(gatt);
-                logi("Refreshing the cache ");
-                refreshDeviceCache(gatt, true);
-                gattConnect(gatt); //TODO What if there is any error here
-                dfuService = gatt.getService(DFU_SERVICE_UUID); //Check again
-            }
-            if (dfuService == null) {
-                loge("DFU service does not exists on the device");
-                sendLogBroadcast(LOG_LEVEL_WARNING, "Connected. DFU Service not found");
-                terminateConnection(gatt, ERROR_SERVICE_NOT_FOUND);
-                return null;
-            }
-
-            final BluetoothGattCharacteristic controlPointCharacteristic = dfuService.getCharacteristic(DFU_CONTROL_POINT_UUID);
-            final BluetoothGattCharacteristic packetCharacteristic = dfuService.getCharacteristic(DFU_PACKET_UUID);
-            if (controlPointCharacteristic == null || packetCharacteristic == null) {
-                loge("DFU characteristics not found in the DFU service");
-                sendLogBroadcast(LOG_LEVEL_WARNING, "Connected. DFU Characteristics not found");
-                terminateConnection(gatt, ERROR_CHARACTERISTICS_NOT_FOUND);
-                return null;
-            }
-
-			/*
-			 * The DFU Version characteristic has been added in SDK 7.0.
-			 *
-			 * It may return version number in 2 bytes (f.e. 0x05-00), where the first one is the minor version and the second one is the major version.
-			 * In case of 0x05-00 the DFU has the version 0.5.
-			 *
-			 * Currently the following version numbers are supported:
-			 *
-			 *   - 0.1 (0x01-00) - The service is connected to the device in application mode, not to the DFU Bootloader. The application supports Long Term Key (LTK)
-			 *                     sharing and buttonless update. Enable notifications on the DFU Control Point characteristic and write 0x01-04 into it to jump to the Bootloader.
-			 *                     Check the Bootloader version again for more info about the Bootloader version.
-			 *
-			 *   - 0.5 (0x05-00) - The device is in the OTA-DFU Bootloader mode. The Bootloader supports LTK sharing and requires the Extended Init Packet. It supports
-			 *                     a SoftDevice, Bootloader or an Application update. SoftDevice and a Bootloader may be sent together.
-			 *
-			 *   - 0.6 (0x06-00) - The device is in the OTA-DFU Bootloader mode. The DFU Bootloader is from SDK 8.0 and has the same features as version 0.5. It also
-			 *                     supports also sending Service Changed notification in application mode after successful or aborted upload so no refreshing services is required.
-			 */
-            final BluetoothGattCharacteristic versionCharacteristic = dfuService.getCharacteristic(DFU_VERSION); // this may be null for older versions of the Bootloader
-
-            sendLogBroadcast(LOG_LEVEL_INFO, "Connected. Services discovered");
-            try {
-                updateProgressNotification(PROGRESS_STARTING);
-
-                // Read the version number if available. The version number consists of 2 bytes: major and minor. Therefore f.e. the version 5 (00-05) can be read as 0.5.
-                int version = 0;
-                if (versionCharacteristic != null) {
-                    version = readVersion(gatt, versionCharacteristic);
-                    final int minor = (version & 0x0F);
-                    final int major = (version >> 8);
-                    logi("Version number read: " + major + "." + minor);
-                    sendLogBroadcast(LOG_LEVEL_APPLICATION, "Version number read: " + major + "." + minor);
-                }
-
-				/*
-				 *  Check if we are in the DFU Bootloader or in the Application that supports the buttonless update.
-				 *
-				 *  In the DFU from SDK 6.1, which was also supporting the buttonless update, there was no DFU Version characteristic. In that case we may find out whether
-				 *  we are in the bootloader or application by simply checking the number of characteristics.
-				 */
-                if (version == 1 || (version == 0 && gatt.getServices().size() > 3 /* No DFU Version char but more services than Generic Access, Generic Attribute, DFU Service */)) {
-                    // The service is connected to the application, not to the bootloader
-                    logw("Application with buttonless update found");
-                    sendLogBroadcast(LOG_LEVEL_WARNING, "Application with buttonless update found");
-
-                    // If we are bonded we may want to enable Service Changed characteristic indications.
-                    // Note: This feature will be introduced in the SDK 8.0 as this is the proper way to refresh attribute list on the phone.
-                    boolean hasServiceChanged = false;
-                    if (gatt.getDevice().getBondState() == BluetoothDevice.BOND_BONDED) {
-                        final BluetoothGattService genericAttributeService = gatt.getService(GENERIC_ATTRIBUTE_SERVICE_UUID);
-                        if (genericAttributeService != null) {
-                            final BluetoothGattCharacteristic serviceChangedCharacteristic = genericAttributeService.getCharacteristic(SERVICE_CHANGED_UUID);
-                            if (serviceChangedCharacteristic != null) {
-                                // Let's read the current value of the Service Changed CCCD
-                                final boolean serviceChangedIndicationsEnabled = isServiceChangedCCCDEnabled(gatt, serviceChangedCharacteristic);
-
-                                if (!serviceChangedIndicationsEnabled) {
-                                    enableCCCD(gatt, serviceChangedCharacteristic, INDICATIONS);
-                                    sendLogBroadcast(LOG_LEVEL_APPLICATION, "Service Changed indications enabled");
-
-									/*
-									 * NOTE: The DFU Bootloader from SDK 8.0 (v0.6 and 0.5) has the following issue:
-									 *
-									 * When the central device (phone) connects to a bonded device (or connects and bonds) which supports the Service Changed characteristic,
-									 * but does not have the Service Changed indications enabled, the phone must enable them, disconnect and reconnect before starting the
-									 * DFU operation. This is because the current version of the Soft Device saves the ATT table on the DISCONNECTED event.
-									 * Sending the "jump to Bootloader" command (0x01-04) will cause the disconnect followed be a reset. The Soft Device does not
-									 * have time to store the ATT table on Flash memory before the reset.
-									 *
-									 * This applies only if:
-									 * - the device was bonded before an upgrade,
-									 * - the Application or the Bootloader is upgraded (upgrade of the Soft Device will erase the bond information anyway),
-									 *     - Application:
-									  *        if the DFU Bootloader has been modified and compiled to preserve the LTK and the ATT table after application upgrade (at least 2 pages)
-									 *         See: \Nordic\nrf51\components\libraries\bootloader_dfu\dfu_types.h, line 56:
-									 *          #define DFU_APP_DATA_RESERVED           0x0000  ->  0x0800+   //< Size of Application Data that must be preserved between application updates...
-									 *     - Bootloader:
-									 *         The Application memory should not be removed when the Bootloader is upgraded, so the Bootloader configuration does not matter.
-									 *
-									 * If the bond information is not to be preserved between the old and new applications, we may skip this disconnect/reconnect process.
-									 * The DFU Bootloader will send the SD indication anyway when we will just continue here, as the information whether it should send it or not it is not being
-									 * read from the application's ATT table, but rather passed as an argument of the "reboot to bootloader" method.
-									 */
-                                    final boolean keepBond = intent.getBooleanExtra(EXTRA_KEEP_BOND, false);
-                                    if (keepBond && (fileType & TYPE_SOFT_DEVICE) == 0) {
-                                        sendLogBroadcast(LOG_LEVEL_VERBOSE, "Restarting service...");
-
-                                        updateProgressNotification(PROGRESS_DISCONNECTING);
-                                        sendLogBroadcast(LOG_LEVEL_VERBOSE, "Disconnecting...");
-                                        gatt.disconnect();
-                                        waitUntilDisconnected();
-                                        sendLogBroadcast(LOG_LEVEL_INFO, "Disconnected");
-
-                                        // Close the device
-                                        close(gatt);
-                                        gatt = null;
-
-                                        logi("Restarting service");
-                                        final Intent newIntent = new Intent();
-                                        newIntent.fillIn(intent, Intent.FILL_IN_COMPONENT | Intent.FILL_IN_PACKAGE);
-                                        //startService(newIntent);
-                                        return newIntent;
-                                    }
-                                } else {
-                                    sendLogBroadcast(LOG_LEVEL_APPLICATION, "Service Changed indications enabled");
-                                }
-                                hasServiceChanged = true;
-                            }
-                        }
-                    }
-
-                    sendLogBroadcast(LOG_LEVEL_VERBOSE, "Jumping to the DFU Bootloader...");
-
-                    // Enable notifications
-                    enableCCCD(gatt, controlPointCharacteristic, NOTIFICATIONS);
-                    sendLogBroadcast(LOG_LEVEL_APPLICATION, "Notifications enabled");
-
-                    // Send 'jump to bootloader command' (Start DFU)
-                    updateProgressNotification(PROGRESS_ENABLING_DFU_MODE);
-                    OP_CODE_START_DFU[1] = 0x04;
-                    logi("Sending Start DFU command (Op Code = 1, Upload Mode = 4)");
-                    writeOpCode(gatt, controlPointCharacteristic, OP_CODE_START_DFU, true);
-                    sendLogBroadcast(LOG_LEVEL_APPLICATION, "Jump to bootloader sent (Op Code = 1, Upload Mode = 4)");
-
-                    // The device will reset so we don't have to send Disconnect signal.
-                    waitUntilDisconnected();
-                    sendLogBroadcast(LOG_LEVEL_INFO, "Disconnected by the remote device");
-
-					/*
-					 * We would like to avoid using the hack with refreshing the device (refresh method is not in the public API). The refresh method clears the cached services and causes a
-					 * service discovery afterwards (when connected). Android, however, does it itself when receive the Service Changed indication when bonded.
-					 * In case of unpaired device we may either refresh the services manually (usinrefreshDeviceCacheg the hack), or include the Service Changed characteristic.
-					 *
-					 * According to Bluetooth Core 4.0 (and 4.1) specification:
-					 *
-					 * [Vol. 3, Part G, 2.5.2 - Attribute Caching]
-					 * Note: Clients without a trusted relationship must perform service discovery on each connection if the server supports the Services Changed characteristic.
-					 *
-					 * However, as up to Android 5 the system does NOT respect this requirement and servers are cached for every device, even if Service Changed is enabled -> Android BUG?
-					 * For bonded devices Android performs service re-discovery when SC indication is received.
-					 */
-                    refreshDeviceCache(gatt, !hasServiceChanged);
-
-                    // Close the device
-                    close(gatt);
-                    gatt = null;
-
-                    logi("Starting service that will connect to the DFU bootloader");
-                    final Intent newIntent = new Intent();
-                    newIntent.fillIn(intent, Intent.FILL_IN_COMPONENT | Intent.FILL_IN_PACKAGE);
-                    startService(newIntent);
-                    return newIntent;
-                }
-
-                // Enable notifications
-                enableCCCD(gatt, controlPointCharacteristic, NOTIFICATIONS);
-                sendLogBroadcast(LOG_LEVEL_APPLICATION, "Notifications enabled");
-
-                try {
-                    // Set up the temporary variable that will hold the responses
-                    byte[] response;
-                    int status;
-
-					/*
-					 * The first version of DFU supported only an Application update.
-					 * Initializing procedure:
-					 * [DFU Start (0x01)] -> DFU Control Point
-					 * [App size in bytes (UINT32)] -> DFU Packet
-					 * ---------------------------------------------------------------------
-					 * Since SDK 6.0 and Soft Device 7.0+ the DFU supports upgrading Soft Device, Bootloader and Application.
-					 * Initializing procedure:
-					 * [DFU Start (0x01), <Update Mode>] -> DFU Control Point
-					 * [SD size in bytes (UINT32), Bootloader size in bytes (UINT32), Application size in bytes (UINT32)] -> DFU Packet
-					 * where <Upload Mode> is a bit mask:
-					 * 0x01 - Soft Device update
-					 * 0x02 - Bootloader update
-					 * 0x04 - Application update
-					 * so that
-					 * 0x03 - Soft Device and Bootloader update
-					 * If <Upload Mode> equals 5, 6 or 7 DFU target may return OPERATION_NOT_SUPPORTED [10, 01, 03]. In that case service will try to send
-					 * Soft Device and/or Bootloader first, reconnect to the new Bootloader and send the Application in the second connection.
-					 * --------------------------------------------------------------------
-					 * If DFU target supports only the old DFU, a response [10, 01, 03] will be send as a notification on DFU Control Point characteristic, where:
-					 * 10 - Response for...
-					 * 01 - DFU Start command
-					 * 03 - Operation Not Supported
-					 * (see table below)
-					 * In that case:
-					 * 1. If this is application update - service will try to upload using the old DFU protocol.
-					 * 2. In case of SD or BL update an error is returned.
-					 */
-
-                    // Obtain size of image(s)
-                    int softDeviceImageSize = (fileType & TYPE_SOFT_DEVICE) > 0 ? imageSizeInBytes : 0;
-                    int bootloaderImageSize = (fileType & TYPE_BOOTLOADER) > 0 ? imageSizeInBytes : 0;
-                    int appImageSize = (fileType & TYPE_APPLICATION) > 0 ? imageSizeInBytes : 0;
-                    // The sizes above may be overwritten if a ZIP file was passed
-                    if (MIME_TYPE_ZIP.equals(mimeType)) {
-                        final ArchiveInputStream zhis = (ArchiveInputStream) is;
-                        softDeviceImageSize = zhis.softDeviceImageSize();
-                        bootloaderImageSize = zhis.bootloaderImageSize();
-                        appImageSize = zhis.applicationImageSize();
-                    }
-
-                    try {
-                        OP_CODE_START_DFU[1] = (byte) fileType;
-
-                        // Send Start DFU command to Control Point
-                        logi("Sending Start DFU command (Op Code = 1, Upload Mode = " + fileType + ")");
-                        writeOpCode(gatt, controlPointCharacteristic, OP_CODE_START_DFU);
-                        sendLogBroadcast(LOG_LEVEL_APPLICATION, "DFU Start sent (Op Code = 1, Upload Mode = " + fileType + ")");
-
-                        // Send image size in bytes to DFU Packet
-                        logi("Sending image size array to DFU Packet (" + softDeviceImageSize + "b, " + bootloaderImageSize + "b, " + appImageSize + "b)");
-                        writeImageSize(gatt, packetCharacteristic, softDeviceImageSize, bootloaderImageSize, appImageSize);
-                        sendLogBroadcast(LOG_LEVEL_APPLICATION, "Firmware image size sent (" + softDeviceImageSize + "b, " + bootloaderImageSize + "b, " + appImageSize + "b)");
-                        sendStatsBinFileSize(appImageSize);
-
-                        // A notification will come with confirmation. Let's wait for it a bit
-                        response = readNotificationResponse();
-
-						/*
-						 * The response received from the DFU device contains:
-						 * +---------+--------+----------------------------------------------------+
-						 * | byte no | value  | description                                        |
-						 * +---------+--------+----------------------------------------------------+
-						 * | 0       | 16     | Response code                                      |
-						 * | 1       | 1      | The Op Code of a request that this response is for |
-						 * | 2       | STATUS | See DFU_STATUS_* for status codes                  |
-						 * +---------+--------+----------------------------------------------------+
-						 */
-                        status = getStatusCode(response, OP_CODE_START_DFU_KEY);
-                        sendLogBroadcast(LOG_LEVEL_APPLICATION, "Response received (Op Code = " + response[1] + " Status = " + status + ")");
-                        if (status != DFU_STATUS_SUCCESS)
-                            throw new RemoteDfuException("Starting DFU failed", status);
-                    } catch (final RemoteDfuException e) {
-                        try {
-                            Log.e(TAG, e.toString());
-
-                            if (e.getErrorNumber() != DFU_STATUS_NOT_SUPPORTED)
-                                throw e;
-
-                            // If user wants to send the Soft Device and/or the Bootloader + Application we may try to send the Soft Device/Bootloader files first,
-                            // and then reconnect and send the application in the second connection.
-                            if ((fileType & TYPE_APPLICATION) > 0 && (fileType & (TYPE_SOFT_DEVICE | TYPE_BOOTLOADER)) > 0) {
-                                // Clear the remote error flag
-                                mRemoteErrorOccurred = false;
-
-                                logw("DFU target does not support (SD/BL)+App update");
-                                sendLogBroadcast(LOG_LEVEL_WARNING, "DFU target does not support (SD/BL)+App update");
-
-                                fileType &= ~TYPE_APPLICATION; // clear application bit
-                                mFileType = fileType;
-                                OP_CODE_START_DFU[1] = (byte) fileType;
-                                mPartsTotal = 2;
-
-                                // Set new content type in the ZIP Input Stream and update sizes of images
-                                final ArchiveInputStream zhis = (ArchiveInputStream) is;
-                                zhis.setContentType(fileType);
-                                try {
-                                    appImageSize = 0;
-                                    mImageSizeInBytes = is.available();
-                                } catch (final IOException e1) {
-                                    Log.e(TAG, e.toString());
-                                    // never happen
-                                }
-
-                                // Send Start DFU command to Control Point
-                                sendLogBroadcast(LOG_LEVEL_VERBOSE, "Sending only SD/BL");
-                                logi("Resending Start DFU command (Op Code = 1, Upload Mode = " + fileType + ")");
-                                writeOpCode(gatt, controlPointCharacteristic, OP_CODE_START_DFU);
-                                sendLogBroadcast(LOG_LEVEL_APPLICATION, "DFU Start sent (Op Code = 1, Upload Mode = " + fileType + ")");
-
-                                // Send image size in bytes to DFU Packet
-                                logi("Sending image size array to DFU Packet: [" + softDeviceImageSize + "b, " + bootloaderImageSize + "b, " + appImageSize + "b]");
-                                writeImageSize(gatt, packetCharacteristic, softDeviceImageSize, bootloaderImageSize, appImageSize);
-                                sendLogBroadcast(LOG_LEVEL_APPLICATION, "Firmware image size sent [" + softDeviceImageSize + "b, " + bootloaderImageSize + "b, " + appImageSize + "b]");
-                                sendStatsBinFileSize(appImageSize);
-
-                                // A notification will come with confirmation. Let's wait for it a bit
-                                response = readNotificationResponse();
-                                status = getStatusCode(response, OP_CODE_START_DFU_KEY);
-                                sendLogBroadcast(LOG_LEVEL_APPLICATION, "Response received (Op Code = " + response[1] + " Status = " + status + ")");
-                                if (status != DFU_STATUS_SUCCESS)
-                                    throw new RemoteDfuException("Starting DFU failed", status);
-                            } else
-                                throw e;
-                        } catch (final RemoteDfuException e1) {
-                            Log.e(TAG, e1.toString());
-
-                            if (e1.getErrorNumber() != DFU_STATUS_NOT_SUPPORTED)
-                                throw e1;
-
-                            // If operation is not supported by DFU target we may try to upload application with legacy mode, using the old DFU protocol
-                            if (fileType == TYPE_APPLICATION) {
-                                // Clear the remote error flag
-                                mRemoteErrorOccurred = false;
-
-                                // The DFU target does not support DFU v.2 protocol
-                                logw("DFU target does not support DFU v.2");
-                                sendLogBroadcast(LOG_LEVEL_WARNING, "DFU target does not support DFU v.2");
-
-                                // Send Start DFU command to Control Point
-                                sendLogBroadcast(LOG_LEVEL_VERBOSE, "Switching to DFU v.1");
-                                logi("Resending Start DFU command (Op Code = 1)");
-                                writeOpCode(gatt, controlPointCharacteristic, OP_CODE_START_DFU); // If has 2 bytes, but the second one is ignored
-                                sendLogBroadcast(LOG_LEVEL_APPLICATION, "DFU Start sent (Op Code = 1)");
-
-                                // Send image size in bytes to DFU Packet
-                                logi("Sending application image size to DFU Packet: " + imageSizeInBytes + " bytes");
-                                writeImageSize(gatt, packetCharacteristic, mImageSizeInBytes);
-                                sendLogBroadcast(LOG_LEVEL_APPLICATION, "Firmware image size sent (" + imageSizeInBytes + " bytes)");
-                                sendStatsBinFileSize(imageSizeInBytes);
-
-                                // A notification will come with confirmation. Let's wait for it a bit
-                                response = readNotificationResponse();
-                                status = getStatusCode(response, OP_CODE_START_DFU_KEY);
-                                sendLogBroadcast(LOG_LEVEL_APPLICATION, "Response received (Op Code = " + response[1] + ", Status = " + status + ")");
-                                if (status != DFU_STATUS_SUCCESS)
-                                    throw new RemoteDfuException("Starting DFU failed", status);
-                            } else
-                                throw e1;
-                        }
-                    }
-
-                    // Since SDK 6.1 this delay is no longer required as the Receive Start DFU notification is postponed until the memory is clear.
-
-                    //		if ((fileType & TYPE_SOFT_DEVICE) > 0) {
-                    //			// In the experimental version of bootloader (SDK 6.0.0) we must wait some time until we can proceed with Soft Device update. Bootloader must prepare the RAM for the new firmware.
-                    //			// Most likely this step will not be needed in the future as the notification received a moment before will be postponed until Bootloader is ready.
-                    //			synchronized (this) {
-                    //				try {
-                    //					wait(6000);
-                    //				} catch (final InterruptedException e) {
-                    //					// do nothing
-                    //				}
-                    //			}
-                    //		}
-
-					/*
-					 * If the DFU Version characteristic is present and the version returned from it is greater or equal to 0.5, the Extended Init Packet is required.
-					 * For older versions, or if the DFU Version characteristic is not present (pre SDK 7.0.0), the Init Packet (which could have contained only the firmware CRC) was optional.
-					 * To calculate the CRC (CRC-CCTII-16 0xFFFF) the following application may be used: http://www.lammertbies.nl/comm/software/index.html -> CRC library.
-					 *
-					 * The Init Packet is read from the *.dat file as a binary file. This service you allows to specify the init packet file in two ways.
-					 * Since SDK 8.0 and the DFU Library v0.6 using the Distribution packet (ZIP) is recommended. The distribution packet can be created using the
-					 * *nrf utility* tool, available together with Master Control Panel v 3.8.0. See the DFU documentation at http://developer.nordicsemi.com for more details.
-					 * An init file may be also provided as a separate file using the {@link #EXTRA_INIT_FILE_PATH} or {@link #EXTRA_INIT_FILE_URI} or in the ZIP file
-					 * with the deprecated fixed naming convention:
-					 *
-					 *    a) If the ZIP file contain a softdevice.hex (or .bin) and/or bootloader.hex (or .bin) the 'system.dat' must also be included.
-					 *       In case when both files are present the CRC should be calculated from the two BIN contents merged together.
-					 *       This means: if there are softdevice.hex and bootloader.hex files in the ZIP file you have to convert them to BIN
-					 *       (e.g. using: http://hex2bin.sourceforge.net/ application), copy them into a single file where the soft device is placed as the first one and calculate
-					 *       the CRC for the whole file.
-					 *
-					 *    b) If the ZIP file contains a application.hex (or .bin) file the 'application.dat' file must be included and contain the Init packet for the application.
-					 */
-                    // Send DFU Init Packet
-                    if (initIs != null) {
-                        sendLogBroadcast(LOG_LEVEL_APPLICATION, "Writing Initialize DFU Parameters...");
-
-                        logi("Sending the Initialize DFU Parameters START (Op Code = 2, Value = 0)");
-                        writeOpCode(gatt, controlPointCharacteristic, OP_CODE_INIT_DFU_PARAMS_START);
-
-                        try {
-                            byte[] data = new byte[20];
-                            int size;
-                            while ((size = initIs.read(data, 0, data.length)) != -1) {
-                                writeInitPacket(gatt, packetCharacteristic, data, size);
-                            }
-                        } catch (final IOException e) {
-                            loge("Error while reading Init packet file");
-                            throw new DfuException("Error while reading Init packet file", ERROR_FILE_ERROR);
-                        }
-
-                        logi("Sending the Initialize DFU Parameters COMPLETE (Op Code = 2, Value = 1)");
-                        writeOpCode(gatt, controlPointCharacteristic, OP_CODE_INIT_DFU_PARAMS_COMPLETE);
-                        sendLogBroadcast(LOG_LEVEL_APPLICATION, "Initialize DFU Parameters completed");
-
-                        // A notification will come with confirmation. Let's wait for it a bit
-                        response = readNotificationResponse();
-                        status = getStatusCode(response, OP_CODE_INIT_DFU_PARAMS_KEY);
-                        sendLogBroadcast(LOG_LEVEL_APPLICATION, "Response received (Op Code = " + response[1] + ", Status = " + status + ")");
-                        if (status != DFU_STATUS_SUCCESS)
-                            throw new RemoteDfuException("Device returned error after sending init packet", status);
-                    } else
-                        mInitPacketSent = true;
-
-                    // Send the number of packets of firmware before receiving a receipt notification
-                    final int numberOfPacketsBeforeNotification = mPacketsBeforeNotification;
-                    if (numberOfPacketsBeforeNotification > 0) {
-                        logi("Sending the number of packets before notifications (Op Code = 8, Value = " + numberOfPacketsBeforeNotification + ")");
-                        setNumberOfPackets(OP_CODE_PACKET_RECEIPT_NOTIF_REQ, numberOfPacketsBeforeNotification);
-                        writeOpCode(gatt, controlPointCharacteristic, OP_CODE_PACKET_RECEIPT_NOTIF_REQ);
-                        sendLogBroadcast(LOG_LEVEL_APPLICATION, "Packet Receipt Notif Req (Op Code = 8) sent (Value = " + numberOfPacketsBeforeNotification + ")");
-                    }
-
-                    // Initialize firmware upload
-                    logi("Sending Receive Firmware Image request (Op Code = 3)");
-                    writeOpCode(gatt, controlPointCharacteristic, OP_CODE_RECEIVE_FIRMWARE_IMAGE);
-                    sendLogBroadcast(LOG_LEVEL_APPLICATION, "Receive Firmware Image request sent");
-
-                    // Send the firmware. The method below sends the first packet and waits until the whole firmware is sent.
-                    final long startTime = mLastProgressTime = mStartTime = SystemClock.elapsedRealtime();
-                    updateProgressNotification();
-                    try {
-                        logi("Uploading firmware...");
-                        sendLogBroadcast(LOG_LEVEL_APPLICATION, "Uploading firmware...");
-                        response = uploadFirmwareImage(gatt, packetCharacteristic, is);
-                    } catch (final DeviceDisconnectedException e) {
-                        loge("Disconnected while sending data");
-                        throw e;
-                        // TODO reconnect?
-                    }
-
-                    final long endTime = SystemClock.elapsedRealtime();
-
-                    // Check the result of the operation
-                    status = getStatusCode(response, OP_CODE_RECEIVE_FIRMWARE_IMAGE_KEY);
-                    logi("Response received. Op Code: " + response[0] + " Req Op Code = " + response[1] + ", Status = " + response[2]);
-                    sendLogBroadcast(LOG_LEVEL_APPLICATION, "Response received (Op Code = " + response[1] + ", Status = " + status + ")");
-                    if (status != DFU_STATUS_SUCCESS)
-                        throw new RemoteDfuException("Device returned error after sending file", status);
-
-                    logi("Transfer of " + mBytesSent + " bytes has taken " + (endTime - startTime) + " ms");
-                    sendLogBroadcast(LOG_LEVEL_APPLICATION, "Upload completed in " + (endTime - startTime) + " ms");
-
-                    // Send Validate request
-                    logi("Sending Validate request (Op Code = 4)");
-                    writeOpCode(gatt, controlPointCharacteristic, OP_CODE_VALIDATE);
-                    sendLogBroadcast(LOG_LEVEL_APPLICATION, "Validate request sent");
-
-                    // A notification will come with status code. Let's wait for it a bit.
-                    response = readNotificationResponse();
-                    status = getStatusCode(response, OP_CODE_VALIDATE_KEY);
-                    logi("Response received. Op Code: " + response[0] + " Req Op Code = " + response[1] + ", Status = " + response[2]);
-                    sendLogBroadcast(LOG_LEVEL_APPLICATION, "Response received (Op Code = " + response[1] + ", Status = " + status + ")");
-                    if (status != DFU_STATUS_SUCCESS)
-                        throw new RemoteDfuException("Device returned validation error", status);
-
-                    // Send Activate and Reset signal.
-                    updateProgressNotification(PROGRESS_DISCONNECTING);
-                    logi("Sending Activate and Reset request (Op Code = 5)");
-                    writeOpCode(gatt, controlPointCharacteristic, OP_CODE_ACTIVATE_AND_RESET);
-                    sendLogBroadcast(LOG_LEVEL_APPLICATION, "Activate and Reset request sent");
-
-                    // The device will reset so we don't have to send Disconnect signal.
-                    waitUntilDisconnected();
-                    sendLogBroadcast(LOG_LEVEL_INFO, "Disconnected by the remote device");
-
-                    // In the DFU version 0.5, in case the device is bonded, the target device does not send the Service Changed indication after
-                    // a jump from bootloader mode to app mode. This issue has been fixed in DFU version 0.6 (SDK 8.0). If the DFU bootloader has been
-                    // configured to preserve the bond information we do not need to enforce refreshing services, as it will notify the phone using the
-                    // Service Changed indication.
-                    final boolean keepBond = intent.getBooleanExtra(EXTRA_KEEP_BOND, false);
-                    refreshDeviceCache(gatt, version == 5 || !keepBond);
-
-                    // Close the device
-                    close(gatt);
-
-                    // During the update the bonding information on the target device may have been removed.
-                    // To create bond with the new application set the EXTRA_RESTORE_BOND extra to true.
-                    // In case the bond information is copied to the new application the new bonding is not required.
-					/*if (gatt.getDevice().getBondState() == BluetoothDevice.BOND_BONDED) {
-						final boolean restoreBond = intent.getBooleanExtra(EXTRA_RESTORE_BOND, false);
-
-						if (restoreBond || !keepBond || (fileType & TYPE_SOFT_DEVICE) > 0) {
-							// The bond information was lost.
-							removeBond(gatt.getDevice());
-
-							// Give some time for removing the bond information. 300ms was to short, let's set it to 2 seconds just to be sure.
-							synchronized (this) {
-								try {
-									wait(2000);
-								} catch (InterruptedException e) {
-									// do nothing
-								}
-							}
-						}
-
-						if (restoreBond && (fileType & TYPE_APPLICATION) > 0) {
-							// Restore pairing when application was updated.
-							createBond(gatt.getDevice());
-						}
-					}*/
-
-					/*
-					 * We need to send PROGRESS_COMPLETED message only when all files has been transmitted.
-					 * In case you want to send the Soft Device and/or Bootloader and the Application, the service will be started twice: one to send SD+BL, and the
-					 * second time to send the Application only (using the new Bootloader). In the first case we do not send PROGRESS_COMPLETED notification.
-					 */
-                    if (mPartCurrent == mPartsTotal) {
-                        // Delay this event a little bit. Android needs some time to prepare for reconnection.
-                        synchronized (mLock) {
-                            try {
-                                mLock.wait(1400);
-                            } catch (final InterruptedException e) {
-                                Log.e(TAG, e.toString());
-                                // do nothing
-                            }
-                        }
-
-                        updateProgressNotification(PROGRESS_COMPLETED);
-                        logi("phase 3 complete");
-                        return null;
-                    } else {
-						/*
-						 * The current service handle will try to upload Soft Device and/or Bootloader.
-						 * We need to enqueue another Intent that will try to send application only.
-						 */
-                        logi("Starting service that will upload application");
-                        final Intent newIntent = new Intent();
-                        newIntent.fillIn(intent, Intent.FILL_IN_COMPONENT | Intent.FILL_IN_PACKAGE);
-                        newIntent.putExtra(EXTRA_FILE_MIME_TYPE, MIME_TYPE_ZIP); // ensure this is set (f.e. for scripts)
-                        newIntent.putExtra(EXTRA_FILE_TYPE, TYPE_APPLICATION); // set the type to application only
-                        newIntent.putExtra(EXTRA_PART_CURRENT, mPartCurrent + 1);
-                        newIntent.putExtra(EXTRA_PARTS_TOTAL, mPartsTotal);
-                        //startService(newIntent);
-
-                        close(gatt);
-                        gatt = null;
-                        return newIntent;
-                    }
-                } catch (final UnknownResponseException e) {
-                    final int error = ERROR_INVALID_RESPONSE;
-                    loge(e.getMessage());
-                    sendLogBroadcast(LOG_LEVEL_ERROR, e.getMessage());
-
-                    logi("Sending Reset command (Op Code = 6)");
-                    writeOpCode(gatt, controlPointCharacteristic, OP_CODE_RESET);
-                    sendLogBroadcast(LOG_LEVEL_APPLICATION, "Reset request sent");
-                    terminateConnection(gatt, error);
-                } catch (final RemoteDfuException e) {
-                    final int error = ERROR_REMOTE_MASK | e.getErrorNumber();
-                    loge(e.getMessage());
-                    sendLogBroadcast(LOG_LEVEL_ERROR, String.format("Remote DFU error: %s", GattError.parse(error)));
-
-                    logi("Sending Reset command (Op Code = 6)");
-                    writeOpCode(gatt, controlPointCharacteristic, OP_CODE_RESET);
-                    sendLogBroadcast(LOG_LEVEL_APPLICATION, "Reset request sent");
-                    terminateConnection(gatt, error);
-                }
-            } catch (final UploadAbortedException e) {
-                logi("Upload aborted");
-                sendLogBroadcast(LOG_LEVEL_WARNING, "Upload aborted");
-                if (mConnectionState == STATE_CONNECTED_AND_READY)
-                    try {
-                        mAborted = false;
-                        logi("Sending Reset command (Op Code = 6)");
-                        writeOpCode(gatt, controlPointCharacteristic, OP_CODE_RESET);
-                        sendLogBroadcast(LOG_LEVEL_APPLICATION, "Reset request sent");
-                    } catch (final Exception e1) {
-                        Log.e(TAG, e1.toString());
-                        // do nothing
-                    }
-
-                terminateConnection(gatt, PROGRESS_ABORTED);
-            } catch (final DeviceDisconnectedException e) {
-                sendLogBroadcast(LOG_LEVEL_ERROR, "Device has disconnected");
-                // TODO reconnect n times?
-                loge(e.getMessage());
-                close(gatt);
-                updateProgressNotification(ERROR_DEVICE_DISCONNECTED);
-            } catch (final DfuException e) {
-                int error = e.getErrorNumber();
-                // Connection state errors and other Bluetooth GATT callbacks share the same error numbers. Therefore we are using bit masks to identify the type.
-                if ((error & ERROR_CONNECTION_STATE_MASK) > 0) {
-                    error &= ~ERROR_CONNECTION_STATE_MASK;
-                    sendLogBroadcast(LOG_LEVEL_ERROR, String.format("Error (0x%02X): %s", error, GattError.parseConnectionError(error)));
-                } else {
-                    error &= ~ERROR_CONNECTION_MASK;
-                    sendLogBroadcast(LOG_LEVEL_ERROR, String.format("Error (0x%02X): %s", error, GattError.parse(error)));
-                }
-
-                loge(e.getMessage());
-                if (mConnectionState == STATE_CONNECTED_AND_READY)
-                    try {
-                        logi("Sending Reset command (Op Code = 6)");
-                        writeOpCode(gatt, controlPointCharacteristic, OP_CODE_RESET);
-                        sendLogBroadcast(LOG_LEVEL_APPLICATION, "Reset request sent");
-                    } catch (final Exception e1) {
-                        Log.e(TAG, e1.toString());
-                        // do nothing
-                    }
-
-                terminateConnection(gatt, e.getErrorNumber() /* we return the whole error number, including the error type mask */);
-            }
-        } finally {
-            try {
-                // Ensure that input stream is always closed
-                mInputStream = null;
-                if (is != null)
-                    is.close();
-
-            } catch (final IOException e) {
-                Log.e(TAG, e.toString());
-                // do nothing
-            }
-        }
-
-        return null;
-    }
-
-    /**
-     * Sets number of data packets that will be send before the notification will be received.
-     *
-     * @param data  control point data packet
-     * @param value number of packets before receiving notification. If this value is 0, then the notification of packet receipt will be disabled by the DFU target.
-     */
-    private void setNumberOfPackets(final byte[] data, final int value) {
-        data[1] = (byte) (value & 0xFF);
-        data[2] = (byte) ((value >> 8) & 0xFF);
-    }
-
-    /**
-     * Opens the binary input stream that returns the firmware image content. A Path to the file is given.
-     *
-     * @param filePath the path to the HEX or BIN file
-     * @param mimeType the file type
-     * @param mbrSize  the size of MBR, by default 0x1000
-     * @param types    the content files types in ZIP
-     * @return the input stream with binary image content
-     */
-    private InputStream openInputStream(final String filePath, final String mimeType, final int mbrSize, final int types) throws IOException {
-        final InputStream is = new FileInputStream(filePath);
-        if (MIME_TYPE_ZIP.equals(mimeType))
-            return new ArchiveInputStream(is, mbrSize, types);
-
-        if (filePath.toLowerCase(Locale.US).endsWith("hex")) {
-            //return new HexInputStream(is, mbrSize);
-            return new HexInputStream(is);
-        }
-
-        return is;
-    }
-
-    /**
-     * Opens the binary input stream. A Uri to the stream is given.
-     *
-     * @param stream   the Uri to the stream
-     * @param mimeType the file type
-     * @param mbrSize  the size of MBR, by default 0x1000
-     * @param types    the content files types in ZIP
-     * @return the input stream with binary image content
-     */
-    private InputStream openInputStream(final Uri stream, final String mimeType, final int mbrSize, final int types) throws IOException {
-        final InputStream is = getContentResolver().openInputStream(stream);
-        if (MIME_TYPE_ZIP.equals(mimeType))
-            return new ArchiveInputStream(is, mbrSize, types);
-
-        final String[] projection = {MediaStore.Images.Media.DISPLAY_NAME};
-        final Cursor cursor = getContentResolver().query(stream, projection, null, null, null);
-        try {
-            if (cursor.moveToNext()) {
-                final String fileName = cursor.getString(0 /* DISPLAY_NAME*/);
-
-                if (fileName.toLowerCase(Locale.US).endsWith("hex")) {
-                    //return new HexInputStream(is, mbrSize);
-                    return new HexInputStream(is);
-                }
-            }
-        } finally {
-            cursor.close();
-        }
-
-        return is;
-    }
-
-    /**
-     * Connects to the BLE device with given address. This method is SYNCHRONOUS, it wait until the connection status change from {@link #STATE_CONNECTING} to {@link #STATE_CONNECTED_AND_READY} or an
-     * error occurs. This method returns <code>null</code> if Bluetooth adapter is disabled.
-     *
-     * @param address the device address
-     * @return the GATT device or <code>null</code> if Bluetooth adapter is disabled.
-     */
-    private BluetoothGatt connect(final String address) {
-        if (!mBluetoothAdapter.isEnabled())
-            return null;
-
-        logi("Connecting to the device...");
-        if (device == null) {
-            device = mBluetoothAdapter.getRemoteDevice(address);
-        }
-
-        gatt = device.connectGatt(this, false, mGattCallback);
-
-        // We have to wait until the device is connected and services are discovered
-        // Connection error may occur as well.
-        try {
-            mConnectionState = STATE_CONNECTING;
-            synchronized (mLock) {
-                while (((mConnectionState == STATE_CONNECTING || mConnectionState == STATE_CONNECTED) && mError == 0 && !mAborted) || mPaused)
-                    mLock.wait();
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-
-        return gatt;
-    }
-
-    private void cancelPairing(final BluetoothGatt gatt) {
-        logi("----> cancelPairing");
-        if (mConnectionState != STATE_DISCONNECTED) {
-            // Disconnect from the device
-            mConnectionState = STATE_DISCONNECTED;
-            logi("Disconnecting from the device...");
-            gatt.disconnect();
-            sendLogBroadcast(LOG_LEVEL_INFO, "Disconnected");
-        }
-        // Close the device
-        refreshDeviceCache(gatt, false); // This should be set to true when DFU Version is 0.5 or lower
-        close(gatt);
-    }
-
-    /**
-     * Disconnects from the device and cleans local variables in case of error. This method is SYNCHRONOUS and wait until the disconnecting process will be completed.
-     *
-     * @param gatt  the GATT device to be disconnected
-     * @param error error number
-     */
-    private void terminateConnection(final BluetoothGatt gatt, final int error) {
-        if (mConnectionState != STATE_DISCONNECTED) {
-            updateProgressNotification(PROGRESS_DISCONNECTING);
-            // Disconnect from the device
-            disconnect(gatt);
-            sendLogBroadcast(LOG_LEVEL_INFO, "Disconnected");
-        }
-        // Close the device
-        refreshDeviceCache(gatt, false); // This should be set to true when DFU Version is 0.5 or lower
-        close(gatt);
-        updateProgressNotification(error);
-    }
-
-    /**
-     * Disconnects from the device. This is SYNCHRONOUS method and waits until the callback returns new state. Terminates immediately if device is already disconnected. Do not call this method
-     * directly, use {@link #terminateConnection(android.bluetooth.BluetoothGatt, int)} instead.
-     *
-     * @param gatt the GATT device that has to be disconnected
-     */
-    private void disconnect(final BluetoothGatt gatt) {
-        if (mConnectionState == STATE_DISCONNECTED)
-            return;
-
-        mConnectionState = STATE_DISCONNECTING;
-        logi("Disconnecting from the device...");
-        gatt.disconnect();
-
-        // We have to wait until device gets disconnected or an error occur
-        waitUntilDisconnected();
-    }
-
-    private void waitUntilDisconnectedTimed() {
-        logi("waitUntilDisconnectedTimed");
-        try {
-            synchronized (mLock) {
-                if (mConnectionState != STATE_DISCONNECTED && mError == 0) {
-                    logi("waitUntilDisconnectedTimed : waiting");
-                    mLock.wait(DfuSettingsConstants.TIME_TO_WAIT_IN_MILLISECONDS);
-                    logi("waitUntilDisconnectedTimed : wait done");
-                }
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-    }
-
-    /**
-     * Wait until the connection state will change to {@link #STATE_DISCONNECTED} or until an error occurs.
-     */
-    private void waitUntilDisconnected() {
-        logi("waitUntilDisconnected");
-        try {
-            synchronized (mLock) {
-                while ((mConnectionState != STATE_DISCONNECTED) && (mConnectionState != STATE_CLOSED) && mError == 0) {
-                    logi("waitUntilDisconnected : waiting");
-                    mLock.wait();
-                    logi("waitUntilDisconnected : wait done");
-                }
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-    }
-
-    private void waitUntilConnected() {
-        logi("waitUntilConnected");
-        try {
-            synchronized (mLock) {
-                if (mConnectionState != STATE_CONNECTED && mError == 0) {
-                    logi("waitUntilConnected : waiting");
-                    mLock.wait();
-                    logi("waitUntilConnected : wait:done");
-                }
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-    }
-
-    private void waitUntilConnected(long timeout) {
-        logi("waitUntilConnected");
-        try {
-            synchronized (mLock) {
-                if (mConnectionState != STATE_CONNECTED && mError == 0) {
-                    logi("waitUntilConnected : waiting");
-                    mLock.wait(timeout);
-                    logi("waitUntilConnected : wait:done");
-                }
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-    }
-
-    private void gattConnect(final BluetoothGatt gatt) {
-        try {
-            if (gatt.connect()) {
-                synchronized (mLock) {
-                    while (mConnectionState != STATE_CONNECTED_AND_READY && mError == 0) {
-                        mLock.wait(30 * 1000); //Wait only 30 seconds. TODO Check this again
-                    }
-                }
-            }
-        } catch (final InterruptedException e) {
-            e.printStackTrace();
-            loge("Sleeping interrupted", e);
-        }
-
-    }
-
-    /**
-     * Closes the GATT device and cleans up.
-     *
-     * @param gatt the GATT device to be closed
-     */
-    private void close(final BluetoothGatt gatt) {
-        logi("Cleaning up...");
-        sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.close()");
-        gatt.disconnect();
-        gatt.close();
-        mConnectionState = STATE_CLOSED;
-    }
-
-    /**
-     * Clears the device cache. After uploading new firmware the DFU target will have other services than before.
-     *
-     * @param gatt  the GATT device to be refreshed
-     * @param force <code>true</code> to force the refresh
-     */
-    private void refreshDeviceCache(final BluetoothGatt gatt, final boolean force) {
-		/*
-		 * If the device is bonded this is up to the Service Changed characteristic to notify Android that the services has changed.
-		 * There is no need for this trick in that case.
-		 * If not bonded, the Android should not keep the services cached when the Service Changed characteristic is present in the target device database.
-		 * However, due to the Android bug (still exists in Android 5.0.1), it is keeping them anyway and the only way to clear services is by using this hidden refresh method.
-		 */
-        if (force || gatt.getDevice().getBondState() == BluetoothDevice.BOND_NONE) {
-            sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.refresh()");
-			/*
-			 * There is a refresh() method in BluetoothGatt class but for now it's hidden. We will call it using reflections.
-			 */
-            try {
-                final Method refresh = gatt.getClass().getMethod("refresh");
-                if (refresh != null) {
-                    final boolean success = (Boolean) refresh.invoke(gatt);
-                    logi("Refreshing result: " + success);
-                }
-            } catch (Exception e) {
-                loge("An exception occurred while refreshing device", e);
-                sendLogBroadcast(LOG_LEVEL_WARNING, "Refreshing failed");
-            }
-        }
-    }
-
-    /**
-     * Checks whether the response received is valid and returns the status code.
-     *
-     * @param response the response received from the DFU device.
-     * @param request  the expected Op Code
-     * @return the status code
-     * @throws UnknownResponseException if response was not valid
-     */
-    private int getStatusCode(final byte[] response, final int request) throws UnknownResponseException {
-        if (response == null || response.length != 3 || response[0] != OP_CODE_RESPONSE_CODE_KEY || response[1] != request || response[2] < 1 || response[2] > 6)
-            throw new UnknownResponseException("Invalid response received", response, request);
-        return response[2];
-    }
-
-    private String readCharacteristicNoFailure(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic) {
-        if (mConnectionState != STATE_CONNECTED_AND_READY)
-            return "not_ready";
-        if (characteristic == null)
-            return "unknown";
-        logi("readCharacteristicNoFailure");
-        gatt.readCharacteristic(characteristic);
-        try {
-            synchronized (mLock) {
-                while ((!mRequestCompleted && mConnectionState == STATE_CONNECTED_AND_READY && mError == 0 && !mAborted) || mPaused)
-                    mLock.wait();
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-
-        if (mAborted)
-            return "unknown";
-
-        if (mError != 0)
-            return "unknown";
-
-        if (mConnectionState != STATE_CONNECTED_AND_READY)
-            return "unknown";
-        return characteristic.getStringValue(0);
-    }
-
-    /**
-     * Reads the DFU Version characteristic if such exists. Otherwise it returns 0.
-     *
-     * @param gatt           the GATT device
-     * @param characteristic the characteristic to read
-     * @return a version number or 0 if not present on the bootloader
-     * @throws DeviceDisconnectedException
-     * @throws DfuException
-     * @throws UploadAbortedException
-     */
-    private int readVersion(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic) throws DeviceDisconnectedException, DfuException, UploadAbortedException {
-        if (mConnectionState != STATE_CONNECTED_AND_READY)
-            throw new DeviceDisconnectedException("Unable to read version number", mConnectionState);
-        // If the DFU Version characteristic is not available we return 0.
-        if (characteristic == null)
-            return 0;
-
-        mReceivedData = null;
-        mError = 0;
-
-        logi("Reading DFU version number...");
-        sendLogBroadcast(LOG_LEVEL_VERBOSE, "Reading DFU version number...");
-
-        gatt.readCharacteristic(characteristic);
-
-        // We have to wait until device receives a response or an error occur
-        try {
-            synchronized (mLock) {
-                while ((!mRequestCompleted && mConnectionState == STATE_CONNECTED_AND_READY && mError == 0 && !mAborted) || mPaused)
-                    mLock.wait();
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-
-        if (mAborted)
-            throw new UploadAbortedException();
-
-        if (mError != 0)
-            throw new DfuException("Unable to read version number", mError);
-
-        if (mConnectionState != STATE_CONNECTED_AND_READY)
-            throw new DeviceDisconnectedException("Unable to read version number", mConnectionState);
-
-        // The version is a 16-bit unsigned int
-        return characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT16, 0);
-    }
-
-    /**
-     * Enables or disables the notifications for given characteristic. This method is SYNCHRONOUS and wait until the
-     * {@link android.bluetooth.BluetoothGattCallback#onDescriptorWrite(android.bluetooth.BluetoothGatt, android.bluetooth.BluetoothGattDescriptor, int)} will be called or the connection state will change from {@link #STATE_CONNECTED_AND_READY}. If
-     * connection state will change, or an error will occur, an exception will be thrown.
-     *
-     * @param gatt           the GATT device
-     * @param characteristic the characteristic to enable or disable notifications for
-     * @param type           {@link #NOTIFICATIONS} or {@link #INDICATIONS}
-     * @throws DfuException
-     * @throws UploadAbortedException
-     */
-    private void enableCCCD(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final int type) throws DeviceDisconnectedException, DfuException, UploadAbortedException {
-        final String debugString = type == NOTIFICATIONS ? "notifications" : "indications";
-        if (mConnectionState != STATE_CONNECTED_AND_READY)
-            throw new DeviceDisconnectedException("Unable to set " + debugString + " state", mConnectionState);
-
-        mReceivedData = null;
-        mError = 0;
-        if ((type == NOTIFICATIONS && mNotificationsEnabled) || (type == INDICATIONS && mServiceChangedIndicationsEnabled))
-            return;
-
-        logi("Enabling " + debugString + "...");
-        sendLogBroadcast(LOG_LEVEL_VERBOSE, "Enabling " + debugString + " for " + characteristic.getUuid());
-
-        // enable notifications locally
-        gatt.setCharacteristicNotification(characteristic, true);
-
-        // enable notifications on the device
-        final BluetoothGattDescriptor descriptor = characteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG);
-        descriptor.setValue(type == NOTIFICATIONS ? BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE : BluetoothGattDescriptor.ENABLE_INDICATION_VALUE);
-        sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.writeDescriptor(" + descriptor.getUuid() + (type == NOTIFICATIONS ? ", value=0x01-00)" : ", value=0x02-00)"));
-        gatt.writeDescriptor(descriptor);
-
-        // We have to wait until device receives a response or an error occur
-        try {
-            synchronized (mLock) {
-                while ((((type == NOTIFICATIONS && !mNotificationsEnabled) || (type == INDICATIONS && !mServiceChangedIndicationsEnabled))
-                        && mConnectionState == STATE_CONNECTED_AND_READY && mError == 0 && !mAborted) || mPaused)
-                    mLock.wait();
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-
-        if (mAborted)
-            throw new UploadAbortedException();
-
-        if (mError != 0)
-            throw new DfuException("Unable to set " + debugString + " state", mError);
-
-        if (mConnectionState != STATE_CONNECTED_AND_READY)
-            throw new DeviceDisconnectedException("Unable to set " + debugString + " state", mConnectionState);
-    }
-
-    /**
-     * Reads the value of the Service Changed Client Characteristic Configuration descriptor (CCCD).
-     *
-     * @param gatt           the GATT device
-     * @param characteristic the Service Changed characteristic
-     * @return <code>true</code> if Service Changed CCCD is enabled ans set to INDICATE
-     * @throws DeviceDisconnectedException
-     * @throws DfuException
-     * @throws UploadAbortedException
-     */
-    private boolean isServiceChangedCCCDEnabled(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic) throws DeviceDisconnectedException, DfuException, UploadAbortedException {
-        if (mConnectionState != STATE_CONNECTED_AND_READY)
-            throw new DeviceDisconnectedException("Unable to read Service Changed CCCD", mConnectionState);
-        // If the Service Changed characteristic or the CCCD is not available we return false.
-        if (characteristic == null)
-            return false;
-
-        final BluetoothGattDescriptor descriptor = characteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG);
-        if (descriptor == null)
-            return false;
-
-        mRequestCompleted = false;
-        mError = 0;
-
-        logi("Reading Service Changed CCCD value...");
-        sendLogBroadcast(LOG_LEVEL_VERBOSE, "Reading Service Changed CCCD value...");
-
-        gatt.readDescriptor(descriptor);
-
-        // We have to wait until device receives a response or an error occur
-        try {
-            synchronized (mLock) {
-                while ((!mRequestCompleted && mConnectionState == STATE_CONNECTED_AND_READY && mError == 0 && !mAborted) || mPaused)
-                    mLock.wait();
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-
-        if (mAborted)
-            throw new UploadAbortedException();
-
-        if (mError != 0)
-            throw new DfuException("Unable to read Service Changed CCCD", mError);
-
-        if (mConnectionState != STATE_CONNECTED_AND_READY)
-            throw new DeviceDisconnectedException("Unable to read Service Changed CCCD", mConnectionState);
-
-        return mServiceChangedIndicationsEnabled;
-    }
-
-    /**
-     * Writes the operation code to the characteristic. This method is SYNCHRONOUS and wait until the
-     * {@link android.bluetooth.BluetoothGattCallback#onCharacteristicWrite(android.bluetooth.BluetoothGatt, android.bluetooth.BluetoothGattCharacteristic, int)} will be called or the connection state will change from {@link #STATE_CONNECTED_AND_READY}.
-     * If connection state will change, or an error will occur, an exception will be thrown.
-     *
-     * @param gatt           the GATT device
-     * @param characteristic the characteristic to write to. Should be the DFU CONTROL POINT
-     * @param value          the value to write to the characteristic
-     * @throws DeviceDisconnectedException
-     * @throws DfuException
-     * @throws UploadAbortedException
-     */
-    private void writeOpCode(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final byte[] value) throws DeviceDisconnectedException, DfuException, UploadAbortedException {
-        final boolean reset = value[0] == OP_CODE_RESET_KEY || value[0] == OP_CODE_ACTIVATE_AND_RESET_KEY;
-        writeOpCode(gatt, characteristic, value, reset);
-    }
-
-    /**
-     * Writes the operation code to the characteristic. This method is SYNCHRONOUS and wait until the
-     * {@link android.bluetooth.BluetoothGattCallback#onCharacteristicWrite(android.bluetooth.BluetoothGatt, android.bluetooth.BluetoothGattCharacteristic, int)} will be called or the connection state will change from {@link #STATE_CONNECTED_AND_READY}.
-     * If connection state will change, or an error will occur, an exception will be thrown.
-     *
-     * @param gatt           the GATT device
-     * @param characteristic the characteristic to write to. Should be the DFU CONTROL POINT
-     * @param value          the value to write to the characteristic
-     * @param reset          whether the command trigger restarting the device
-     * @throws DeviceDisconnectedException
-     * @throws DfuException
-     * @throws UploadAbortedException
-     */
-    private void writeOpCode(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final byte[] value, final boolean reset) throws DeviceDisconnectedException, DfuException,
-            UploadAbortedException {
-        mReceivedData = null;
-        mError = 0;
-        mRequestCompleted = false;
-		/*
-		 * Sending a command that will make the DFU target to reboot may cause an error 133 (0x85 - Gatt Error). If so, with this flag set, the error will not be shown to the user
-		 * as the peripheral is disconnected anyway. See: mGattCallback#onCharacteristicWrite(...) method
-		 */
-        mResetRequestSent = reset;
-
-        characteristic.setValue(value);
-        sendLogBroadcast(LOG_LEVEL_VERBOSE, "Writing to characteristic " + characteristic.getUuid());
-        sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.writeCharacteristic(" + characteristic.getUuid() + ")");
-        gatt.writeCharacteristic(characteristic);
-
-        // We have to wait for confirmation
-        try {
-            synchronized (mLock) {
-                while ((!mRequestCompleted && mConnectionState == STATE_CONNECTED_AND_READY && mError == 0 && !mAborted) || mPaused)
-                    mLock.wait();
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-
-        if (mAborted)
-            throw new UploadAbortedException();
-
-        if (!mResetRequestSent && mError != 0)
-            throw new DfuException("Unable to write Op Code " + value[0], mError);
-
-        if (!mResetRequestSent && mConnectionState != STATE_CONNECTED_AND_READY)
-            throw new DeviceDisconnectedException("Unable to write Op Code " + value[0], mConnectionState);
-    }
-
-    private void writeCharacteristic(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic) throws DeviceDisconnectedException, DfuException,
-            UploadAbortedException {
-
-        gatt.writeCharacteristic(characteristic);
-
-        // We have to wait for confirmation
-        try {
-            synchronized (mLock) {
-                while ((!mRequestCompleted && mConnectionState == STATE_CONNECTED_AND_READY && mError == 0 && !mAborted) || mPaused) {
-                    mLock.wait();
-                }
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-
-        if (mAborted) {
-            throw new UploadAbortedException();
-        }
-    }
-
-    /**
-     * Writes the image size to the characteristic. This method is SYNCHRONOUS and wait until the {@link android.bluetooth.BluetoothGattCallback#onCharacteristicWrite(android.bluetooth.BluetoothGatt, android.bluetooth.BluetoothGattCharacteristic, int)}
-     * will be called or the connection state will change from {@link #STATE_CONNECTED_AND_READY}. If connection state will change, or an error will occur, an exception will be thrown.
-     *
-     * @param gatt           the GATT device
-     * @param characteristic the characteristic to write to. Should be the DFU PACKET
-     * @param imageSize      the image size in bytes
-     * @throws DeviceDisconnectedException
-     * @throws DfuException
-     * @throws UploadAbortedException
-     */
-    private void writeImageSize(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final int imageSize) throws DeviceDisconnectedException, DfuException,
-            UploadAbortedException {
-        mReceivedData = null;
-        mError = 0;
-        mImageSizeSent = false;
-
-        characteristic.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE);
-        characteristic.setValue(new byte[4]);
-        characteristic.setValue(imageSize, BluetoothGattCharacteristic.FORMAT_UINT32, 0);
-        sendLogBroadcast(LOG_LEVEL_VERBOSE, "Writing to characteristic " + characteristic.getUuid());
-        sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.writeCharacteristic(" + characteristic.getUuid() + ")");
-        gatt.writeCharacteristic(characteristic);
-
-        // We have to wait for confirmation
-        try {
-            synchronized (mLock) {
-                while ((!mImageSizeSent && mConnectionState == STATE_CONNECTED_AND_READY && mError == 0 && !mAborted) || mPaused)
-                    mLock.wait();
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-
-        if (mAborted)
-            throw new UploadAbortedException();
-
-        if (mError != 0)
-            throw new DfuException("Unable to write Image Size", mError);
-
-        if (mConnectionState != STATE_CONNECTED_AND_READY)
-            throw new DeviceDisconnectedException("Unable to write Image Size", mConnectionState);
-    }
-
-    /**
-     * <p>
-     * Writes the Soft Device, Bootloader and Application image sizes to the characteristic. Soft Device and Bootloader update is supported since Soft Device s110 v7.0.0.
-     * Sizes of SD, BL and App are uploaded as 3x UINT32 even though some of them may be 0s. F.e. if only App is being updated the data will be <0x00000000, 0x00000000, [App size]>
-     * </p>
-     * <p>
-     * This method is SYNCHRONOUS and wait until the {@link android.bluetooth.BluetoothGattCallback#onCharacteristicWrite(android.bluetooth.BluetoothGatt, android.bluetooth.BluetoothGattCharacteristic, int)} will be called or the connection state will
-     * change from {@link #STATE_CONNECTED_AND_READY}. If connection state will change, or an error will occur, an exception will be thrown.
-     * </p>
-     *
-     * @param gatt                the GATT device
-     * @param characteristic      the characteristic to write to. Should be the DFU PACKET
-     * @param softDeviceImageSize the Soft Device image size in bytes
-     * @param bootloaderImageSize the Bootloader image size in bytes
-     * @param appImageSize        the Application image size in bytes
-     * @throws DeviceDisconnectedException
-     * @throws DfuException
-     * @throws UploadAbortedException
-     */
-    private void writeImageSize(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final int softDeviceImageSize,
-                                final int bootloaderImageSize, final int appImageSize) throws DeviceDisconnectedException, DfuException, UploadAbortedException {
-
-        mReceivedData = null;
-        mError = 0;
-        mImageSizeSent = false;
-
-        characteristic.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE);
-        characteristic.setValue(new byte[12]);
-        characteristic.setValue(softDeviceImageSize, BluetoothGattCharacteristic.FORMAT_UINT32, 0);
-        characteristic.setValue(bootloaderImageSize, BluetoothGattCharacteristic.FORMAT_UINT32, 4);
-        characteristic.setValue(appImageSize, BluetoothGattCharacteristic.FORMAT_UINT32, 8);
-        sendLogBroadcast(LOG_LEVEL_VERBOSE, "Writing to characteristic " + characteristic.getUuid());
-        sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.writeCharacteristic(" + characteristic.getUuid() + ")");
-        gatt.writeCharacteristic(characteristic);
-
-        // We have to wait for confirmation
-        try {
-            synchronized (mLock) {
-                while ((!mImageSizeSent && mConnectionState == STATE_CONNECTED_AND_READY && mError == 0 && !mAborted) || mPaused)
-                    mLock.wait();
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-
-        if (mAborted)
-            throw new UploadAbortedException();
-
-        if (mError != 0)
-            throw new DfuException("Unable to write Image Sizes", mError);
-
-        if (mConnectionState != STATE_CONNECTED_AND_READY)
-            throw new DeviceDisconnectedException("Unable to write Image Sizes", mConnectionState);
-    }
-
-    /**
-     * Writes the Init packet to the characteristic. This method is SYNCHRONOUS and wait until the {@link android.bluetooth.BluetoothGattCallback#onCharacteristicWrite(android.bluetooth.BluetoothGatt, android.bluetooth.BluetoothGattCharacteristic, int)}
-     * will be called or the connection state will change from {@link #STATE_CONNECTED_AND_READY}. If connection state will change, or an error will occur, an exception will be thrown.
-     *
-     * @param gatt           the GATT device
-     * @param characteristic the characteristic to write to. Should be the DFU PACKET
-     * @param buffer         the init packet as a byte array. This must be shorter or equal to 20 bytes (TODO check this restriction).
-     * @param size           the init packet size
-     * @throws DeviceDisconnectedException
-     * @throws DfuException
-     * @throws UploadAbortedException
-     */
-    private void writeInitPacket(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final byte[] buffer, final int size) throws DeviceDisconnectedException, DfuException,
-            UploadAbortedException {
-        byte[] locBuffer = buffer;
-        if (buffer.length != size) {
-            locBuffer = new byte[size];
-            System.arraycopy(buffer, 0, locBuffer, 0, size);
-        }
-
-        mReceivedData = null;
-        mError = 0;
-        mInitPacketSent = false;
-
-        characteristic.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE);
-        characteristic.setValue(locBuffer);
-        logi("Sending init packet (Value = " + parse(locBuffer) + ")");
-        sendLogBroadcast(LOG_LEVEL_VERBOSE, "Writing to characteristic " + characteristic.getUuid());
-        sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.writeCharacteristic(" + characteristic.getUuid() + ")");
-        gatt.writeCharacteristic(characteristic);
-
-        // We have to wait for confirmation
-        try {
-            synchronized (mLock) {
-                while ((!mInitPacketSent && mConnectionState == STATE_CONNECTED_AND_READY && mError == 0 && !mAborted) || mPaused)
-                    mLock.wait();
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-
-        if (mAborted)
-            throw new UploadAbortedException();
-
-        if (mError != 0)
-            throw new DfuException("Unable to write Init DFU Parameters", mError);
-
-        if (mConnectionState != STATE_CONNECTED_AND_READY)
-            throw new DeviceDisconnectedException("Unable to write Init DFU Parameters", mConnectionState);
-    }
-
-    /**
-     * Starts sending the data. This method is SYNCHRONOUS and terminates when the whole file will be uploaded or the connection status will change from {@link #STATE_CONNECTED_AND_READY}. If
-     * connection state will change, or an error will occur, an exception will be thrown.
-     *
-     * @param gatt                 the GATT device (DFU target)
-     * @param packetCharacteristic the characteristic to write file content to. Must be the DFU PACKET
-     * @return The response value received from notification with Op Code = 3 when all bytes will be uploaded successfully.
-     * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of the transmission. The error core will be saved in {@link #mConnectionState}.
-     * @throws DfuException                Thrown if DFU error occur
-     * @throws UploadAbortedException
-     */
-    private byte[] uploadFirmwareImage(final BluetoothGatt gatt, final BluetoothGattCharacteristic packetCharacteristic, final InputStream inputStream) throws DeviceDisconnectedException,
-            DfuException, UploadAbortedException {
-        mReceivedData = null;
-        mError = 0;
-
-        final byte[] buffer = mBuffer;
-        try {
-            final int size = inputStream.read(buffer);
-            sendLogBroadcast(LOG_LEVEL_VERBOSE, "Sending firmware to characteristic " + packetCharacteristic.getUuid() + "...");
-            writePacket(gatt, packetCharacteristic, buffer, size);
-        } catch (final HexFileValidationException e) {
-            throw new DfuException("HEX file not valid", ERROR_FILE_INVALID);
-        } catch (final IOException e) {
-            throw new DfuException("Error while reading file", ERROR_FILE_IO_EXCEPTION);
-        }
-
-        try {
-            synchronized (mLock) {
-                while ((mReceivedData == null && mConnectionState == STATE_CONNECTED_AND_READY && mError == 0 && !mAborted) || mPaused)
-                    mLock.wait();
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-
-        if (mAborted)
-            throw new UploadAbortedException();
-
-        if (mError != 0)
-            throw new DfuException("Uploading Firmware Image failed", mError);
-
-        if (mConnectionState != STATE_CONNECTED_AND_READY)
-            throw new DeviceDisconnectedException("Uploading Firmware Image failed: device disconnected", mConnectionState);
-
-        return mReceivedData;
-    }
-
-    //Duplicate of String parse(final byte[] data)
-    //TODO Remove this
-    public static String bytesToHex(byte[] bytes) {
-        char[] hexChars = new char[bytes.length * 2];
-        for (int j = 0; j < bytes.length; j++) {
-            int v = bytes[j] & 0xFF;
-            hexChars[j * 2] = HEX_ARRAY[v >> 4];
-            hexChars[j * 2 + 1] = HEX_ARRAY[v & 0x0F];
-        }
-        return new String(hexChars);
-    }
-
-    /**
-     * Writes the buffer to the characteristic. The maximum size of the buffer is 20 bytes. This method is ASYNCHRONOUS and returns immediately after adding the data to TX queue.
-     *
-     * @param gatt           the GATT device
-     * @param characteristic the characteristic to write to. Should be the DFU PACKET
-     * @param buffer         the buffer with 1-20 bytes
-     * @param size           the number of bytes from the buffer to send
-     */
-    private void writePacket(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final byte[] buffer, final int size) {
-        byte[] locBuffer = buffer;
-        if (buffer.length != size) {
-            locBuffer = new byte[size];
-            System.arraycopy(buffer, 0, locBuffer, 0, size);
-        }
-
-        //logi("Sending Packet - " + bytesToHex(locBuffer));
-        characteristic.setValue(locBuffer);
-        gatt.writeCharacteristic(characteristic);
-        // FIXME BLE buffer overflow
-        // after writing to the device with WRITE_NO_RESPONSE property the onCharacteristicWrite callback is received immediately after writing data to a buffer.
-        // The real sending is much slower than adding to the buffer. This method does not return false if writing didn't succeed.. just the callback is not invoked.
-        //
-        // More info: this works fine on Nexus 5 (Android 4.4) (4.3 seconds) and on Samsung S4 (Android 4.3) (20 seconds) so this is a driver issue.
-        // Nexus 4 and 7 uses Qualcomm chip, Nexus 5 and Samsung uses Broadcom chips.
-    }
-
-    private void waitIfPaused() {
-        synchronized (mLock) {
-            try {
-                while (mPaused)
-                    mLock.wait();
-            } catch (final InterruptedException e) {
-                loge("Sleeping interrupted", e);
-            }
-        }
-    }
-
-
-    @SuppressLint("NewApi")
-    private boolean createBond(final BluetoothDevice device) {
-        if (device.getBondState() == BluetoothDevice.BOND_BONDED)
-            return true;
-
-        boolean result;
-        mRequestCompleted = false;
-
-        sendLogBroadcast(LOG_LEVEL_VERBOSE, "Starting pairing...");
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
-            sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.getDevice().createBond()");
-            result = device.createBond();
-        } else {
-            result = createBondApi18(device);
-        }
-
-        // We have to wait until device is bounded
-        try {
-            synchronized (mLock) {
-                while (!mRequestCompleted && !mAborted)
-                    mLock.wait();
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-
-        return result;
-    }
-
-    private boolean createBondApi18(final BluetoothDevice device) {
-		/*
-		 * There is a createBond() method in BluetoothDevice class but for now it's hidden. We will call it using reflections. It has been revealed in KitKat (Api19)
-		 */
-        try {
-            final Method createBond = device.getClass().getMethod("createBond");
-            if (createBond != null) {
-                sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.getDevice().createBond() (hidden)");
-                return (Boolean) createBond.invoke(device);
-            }
-        } catch (final Exception e) {
-            Log.w(TAG, "An exception occurred while creating bond", e);
-            Log.e(TAG, e.toString());
-        }
-
-        return false;
-    }
-
-    /**
-     * Removes the bond information for the given device.
-     *
-     * @param device the device to unbound
-     * @return <code>true</code> if operation succeeded, <code>false</code> otherwise
-     */
-    private boolean removeBond(final BluetoothDevice device) {
-        if (device.getBondState() == BluetoothDevice.BOND_NONE)
-            return true;
-
-        sendLogBroadcast(LOG_LEVEL_VERBOSE, "Removing bond information...");
-        boolean result = false;
-		/*
-		 * There is a removeBond() method in BluetoothDevice class but for now it's hidden. We will call it using reflections.
-		 */
-        try {
-            final Method removeBond = device.getClass().getMethod("removeBond");
-            if (removeBond != null) {
-                mRequestCompleted = false;
-                sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.getDevice().removeBond() (hidden)");
-                result = (Boolean) removeBond.invoke(device);
-
-                // We have to wait until device is unbounded
-                try {
-                    synchronized (mLock) {
-                        while (!mRequestCompleted && !mAborted)
-                            mLock.wait();
-                    }
-                } catch (final InterruptedException e) {
-                    loge("Sleeping interrupted", e);
-                }
-            }
-
-            result = true;
-        } catch (final Exception e) {
-            Log.w(TAG, "An exception occurred while removing bond information", e);
-            Log.e(TAG, e.toString());
-        }
-
-        return result;
-    }
-
-    /**
-     * Waits until the notification will arrive. Returns the data returned by the notification. This method will block the thread if response is not ready or connection state will change from
-     * {@link #STATE_CONNECTED_AND_READY}. If connection state will change, or an error will occur, an exception will be thrown.
-     *
-     * @return the value returned by the Control Point notification
-     * @throws DeviceDisconnectedException
-     * @throws DfuException
-     * @throws UploadAbortedException
-     */
-    private byte[] readNotificationResponse() throws DeviceDisconnectedException, DfuException, UploadAbortedException {
-        // do not clear the mReceiveData here. The response might already be obtained. Clear it in write request instead.
-        mError = 0;
-        try {
-            synchronized (mLock) {
-                while ((mReceivedData == null && mConnectionState == STATE_CONNECTED_AND_READY && mError == 0 && !mAborted) || mPaused)
-                    mLock.wait();
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-
-        if (mAborted)
-            throw new UploadAbortedException();
-
-        if (mError != 0)
-            throw new DfuException("Unable to write Op Code", mError);
-
-        if (mConnectionState != STATE_CONNECTED_AND_READY)
-            throw new DeviceDisconnectedException("Unable to write Op Code", mConnectionState);
-
-        return mReceivedData;
-    }
-
-    /**
-     * Creates or updates the notification in the Notification Manager. Sends broadcast with current progress to the activity.
-     */
-    private void updateProgressNotification() {
-        final int progress = (int) (100.0f * mBytesSent / mImageSizeInBytes);
-        if (mLastProgress == progress)
-            return;
-
-        mLastProgress = progress;
-        updateProgressNotification(progress);
-    }
-
-    /**
-     * Creates or updates the notification in the Notification Manager. Sends broadcast with given progress or error state to the activity.
-     *
-     * @param progress the current progress state or an error number, can be one of {@link #PROGRESS_CONNECTING}, {@link #PROGRESS_STARTING}, {@link #PROGRESS_ENABLING_DFU_MODE},
-     *                 {@link #PROGRESS_VALIDATING}, {@link #PROGRESS_DISCONNECTING}, {@link #PROGRESS_COMPLETED} or {@link #ERROR_FILE_ERROR}, {@link #ERROR_FILE_INVALID} , etc
-     */
-    private void updateProgressNotification(final int progress) {
-        // send progress or error broadcast
-        if (progress < ERROR_MASK)
-            sendProgressBroadcast(progress);
-        else
-            sendErrorBroadcast(progress);
-    }
-
-    /**
-     * This method must return the activity class that will be used to create the pending intent used as a content intent in the notification showing the upload progress.
-     * The activity will be launched when user click the notification. DfuService will add {@link android.content.Intent#FLAG_ACTIVITY_NEW_TASK} flag and the following extras:
-     * <ul>
-     * <li>{@link #EXTRA_DEVICE_ADDRESS} - target device address</li>
-     * <li>{@link #EXTRA_DEVICE_NAME} - target device name</li>
-     * <li>{@link #EXTRA_PROGRESS} - the connection state (values < 0)*, current progress (0-100) or error number if {@link #ERROR_MASK} bit set.</li>
-     * </ul>
-     * <p>
-     * __________<br />
-     * * - connection state constants:
-     * <ul>
-     * <li>{@link #PROGRESS_CONNECTING}</li>
-     * <li>{@link #PROGRESS_DISCONNECTING}</li>
-     * <li>{@link #PROGRESS_COMPLETED}</li>
-     * <li>{@link #PROGRESS_ABORTED}</li>
-     * <li>{@link #PROGRESS_STARTING}</li>
-     * <li>{@link #PROGRESS_ENABLING_DFU_MODE}</li>
-     * <li>{@link #PROGRESS_VALIDATING}</li>
-     * </ul>
-     * </p>
-     *
-     * @return the target activity class
-     */
-    protected abstract Class<? extends Activity> getNotificationTarget();
-
-    private void sendProgressBroadcast(final int progress) {
-
-        final long now = SystemClock.elapsedRealtime();
-        final float speed = now - mLastProgressTime != 0 ? (float) (mBytesSent - mLastBytesSent) / (float) (now - mLastProgressTime) : 0.0f;
-        final float avgSpeed = now - mStartTime != 0 ? (float) mBytesSent / (float) (now - mStartTime) : 0.0f;
-        mLastProgressTime = now;
-        mLastBytesSent = mBytesSent;
-
-        final Intent broadcast = new Intent(BROADCAST_PROGRESS);
-        broadcast.putExtra(EXTRA_DATA, progress);
-        broadcast.putExtra(EXTRA_DEVICE_ADDRESS, mDeviceAddress);
-        broadcast.putExtra(EXTRA_PART_CURRENT, mPartCurrent);
-        broadcast.putExtra(EXTRA_PARTS_TOTAL, mPartsTotal);
-        broadcast.putExtra(EXTRA_SPEED_B_PER_MS, speed);
-        broadcast.putExtra(EXTRA_AVG_SPEED_B_PER_MS, avgSpeed);
-        LocalBroadcastManager.getInstance(this).sendBroadcast(broadcast);
-    }
-
-    private void sendErrorBroadcast(final int error) {
-
-        final Intent broadcast = new Intent(BROADCAST_ERROR);
-        if ((error & ERROR_CONNECTION_MASK) > 0) {
-            broadcast.putExtra(EXTRA_DATA, error & ~ERROR_CONNECTION_MASK);
-            broadcast.putExtra(EXTRA_ERROR_TYPE, ERROR_TYPE_COMMUNICATION);
-        } else if ((error & ERROR_CONNECTION_STATE_MASK) > 0) {
-            broadcast.putExtra(EXTRA_DATA, error & ~ERROR_CONNECTION_STATE_MASK);
-            broadcast.putExtra(EXTRA_ERROR_TYPE, ERROR_TYPE_COMMUNICATION_STATE);
-        } else if ((error & ERROR_REMOTE_MASK) > 0) {
-            broadcast.putExtra(EXTRA_DATA, error);
-            broadcast.putExtra(EXTRA_ERROR_TYPE, ERROR_TYPE_DFU_REMOTE);
-        } else {
-            broadcast.putExtra(EXTRA_DATA, error);
-            broadcast.putExtra(EXTRA_ERROR_TYPE, ERROR_TYPE_OTHER);
-        }
-
-        broadcast.putExtra(EXTRA_DEVICE_ADDRESS, mDeviceAddress);
-        LocalBroadcastManager.getInstance(this).sendBroadcast(broadcast);
-    }
-
-    private void sendLogBroadcast(final int level, final String message) {
-        final String fullMessage = "[DFU] " + message;
-        final Intent broadcast = new Intent(BROADCAST_LOG);
-        logi("Dfu update " + fullMessage);
-        broadcast.putExtra(EXTRA_LOG_MESSAGE, fullMessage);
-        broadcast.putExtra(EXTRA_LOG_LEVEL, level);
-        broadcast.putExtra(EXTRA_DEVICE_ADDRESS, mDeviceAddress);
-        LocalBroadcastManager.getInstance(this).sendBroadcast(broadcast);
-    }
-
-    private void sendStatsBinFileSize(final int size) {
-        final Intent broadcast = new Intent(BROADCAST_LOG);
-        broadcast.putExtra(EXTRA_LOG_LEVEL, LOG_LEVEL_BINARY_SIZE);
-        broadcast.putExtra(EXTRA_DATA, Integer.toString(size));
-
-
-        LocalBroadcastManager.getInstance(this).sendBroadcast(broadcast);
-    }
-
-    private void sendStatsMiniFirmware(final String firmware) {
-        final Intent broadcast = new Intent(BROADCAST_LOG);
-        broadcast.putExtra(EXTRA_LOG_LEVEL, LOG_LEVEL_FIRMWARE);
-        broadcast.putExtra(EXTRA_DATA, firmware);
-        LocalBroadcastManager.getInstance(this).sendBroadcast(broadcast);
-    }
-
-    /**
-     * Initializes bluetooth adapter
-     *
-     * @return <code>true</code> if initialization was successful
-     */
-    private boolean initialize() {
-        // For API level 18 and above, get a reference to BluetoothAdapter through
-        // BluetoothManager.
-        final BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
-        if (bluetoothManager == null) {
-            loge("Unable to initialize BluetoothManager.");
-            return false;
-        }
-
-        mBluetoothAdapter = bluetoothManager.getAdapter();
-        if (mBluetoothAdapter == null) {
-            loge("Unable to obtain a BluetoothAdapter.");
-            return false;
-        }
-
-        return true;
-    }
-
-    private void loge(final String message) {
-        if (DEBUG) {
-            Log.e(TAG, "### " + Thread.currentThread().getId() + " # " + message);
-        }
-    }
-
-    private void loge(final String message, final Throwable e) {
-        if (DEBUG) {
-            Log.e(TAG, "### " + Thread.currentThread().getId() + " # " + message, e);
-        }
-    }
-
-    private void logw(final String message) {
-        if (DEBUG) {
-            Log.w(TAG, "### " + Thread.currentThread().getId() + " # " + message);
-        }
-    }
-
-    private void logi(final String message) {
-        if (DEBUG) {
-            Log.i(TAG, "### " + Thread.currentThread().getId() + " # " + message);
-        }
-    }
-
-    private void logd(final String message) {
-        if (DEBUG) {
-            Log.d(TAG, "### " + Thread.currentThread().getId() + " # " + message);
-        }
-    }
-
-    private String parse(final byte[] data) {
-        if (data == null)
-            return "";
-
-        final int length = data.length;
-        if (length == 0)
-            return "";
-
-        final char[] out = new char[length * 3 - 1];
-        for (int j = 0; j < length; j++) {
-            int v = data[j] & 0xFF;
-            out[j * 3] = HEX_ARRAY[v >>> 4];
-            out[j * 3 + 1] = HEX_ARRAY[v & 0x0F];
-            if (j != length - 1)
-                out[j * 3 + 2] = '-';
-        }
-
-        return new String(out);
-    }
-}
diff --git a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/DfuBaseServiceTwo.java b/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/DfuBaseServiceTwo.java
deleted file mode 100644
index d7178a9..0000000
--- a/dfuLibrary/src/main/java/no/nordicsemi/android/dfu/DfuBaseServiceTwo.java
+++ /dev/null
@@ -1,3267 +0,0 @@
-/**
- * **********************************************************************************************************************************************
- * Copyright (c) 2015, Nordic Semiconductor
- * All rights reserved.
- * <p/>
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- * <p/>
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- * <p/>
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- * <p/>
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- * <p/>
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * **********************************************************************************************************************************************
- */
-
-package no.nordicsemi.android.dfu;
-
-import android.annotation.SuppressLint;
-import android.app.Activity;
-import android.app.IntentService;
-import android.bluetooth.BluetoothAdapter;
-import android.bluetooth.BluetoothDevice;
-import android.bluetooth.BluetoothGatt;
-import android.bluetooth.BluetoothGattCallback;
-import android.bluetooth.BluetoothGattCharacteristic;
-import android.bluetooth.BluetoothGattDescriptor;
-import android.bluetooth.BluetoothGattService;
-import android.bluetooth.BluetoothManager;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.SharedPreferences;
-import android.database.Cursor;
-import android.net.Uri;
-import android.os.Build;
-import android.os.ResultReceiver;
-import android.os.SystemClock;
-import android.preference.PreferenceManager;
-import android.provider.MediaStore;
-import android.support.v4.content.LocalBroadcastManager;
-import android.util.Log;
-
-import java.io.ByteArrayInputStream;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.lang.reflect.Method;
-import java.util.Locale;
-import java.util.UUID;
-
-import no.nordicsemi.android.dfu.exception.DeviceDisconnectedException;
-import no.nordicsemi.android.dfu.exception.DfuException;
-import no.nordicsemi.android.dfu.exception.HexFileValidationException;
-import no.nordicsemi.android.dfu.exception.RemoteDfuException;
-import no.nordicsemi.android.dfu.exception.UnknownResponseException;
-import no.nordicsemi.android.dfu.exception.UploadAbortedException;
-import no.nordicsemi.android.error.GattError;
-
-/**
- * The DFU Service provides full support for Over-the-Air (OTA) Device Firmware Update (DFU) by Nordic Semiconductor.
- * With the Soft Device 7.0.0+ it allows to upload a new Soft Device, new Bootloader and a new Application. For older soft devices only the Application update is supported.
- * <p>
- * To run the service to your application extend it in your project and overwrite the missing method. Remember to add your class to the AndroidManifest.xml file.
- * </p>
- * <p>
- * Start the service with the following parameters:
- * <p/>
- * <pre>
- * final Intent service = new Intent(this, YourDfuService.class);
- * service.putExtra(DfuService.EXTRA_DEVICE_ADDRESS, mSelectedDevice.getAddress()); // Target device address
- * service.putExtra(DfuService.EXTRA_DEVICE_NAME, mSelectedDevice.getName()); // This name will be shown on the notification
- * service.putExtra(DfuService.EXTRA_FILE_MIME_TYPE, mFileType == DfuService.TYPE_AUTO ? YourDfuService.MIME_TYPE_ZIP : YourDfuService.MIME_TYPE_OCTET_STREAM);
- * service.putExtra(DfuService.EXTRA_FILE_TYPE, mFileType);
- * service.putExtra(DfuService.EXTRA_FILE_PATH, mFilePath);
- * service.putExtra(DfuService.EXTRA_FILE_URI, mFileStreamUri);
- * // optionally
- * service.putExtra(DfuService.EXTRA_INIT_FILE_PATH, mInitFilePath);
- * service.putExtra(DfuService.EXTRA_INIT_FILE_URI, mInitFileStreamUri);
- * service.putExtra(DfuService.EXTRA_RESTORE_BOND, mRestoreBond);
- * startService(service);
- * </pre>
- * <p/>
- * The {@link #EXTRA_FILE_MIME_TYPE} and {@link #EXTRA_FILE_TYPE} parameters are optional. If not provided the application upload from HEX/BIN file is assumed.
- * The service API is compatible with previous versions.
- * </p>
- * <p>
- * The service will show its progress on the notification bar and will send local broadcasts to the application.
- * </p>
- */
-public abstract class DfuBaseServiceTwo extends IntentService {
-
-    private static final String TAG = "DfuBaseService";
-    //private static final boolean DEBUG = BuildConfig.DEBUG;
-    private static final boolean DEBUG = true;
-
-    public static final String INTENT_RESULT_RECEIVER = "com.samsung.resultReceiver";
-    public static final String INTENT_REQUESTED_PHASE = "com.samsung.runonly.phase";
-
-    /**
-     * The address of the device to update.
-     */
-    public static final String EXTRA_DEVICE_ADDRESS = "no.nordicsemi.android.dfu.extra.EXTRA_DEVICE_ADDRESS";
-
-    /**
-     * The optional device name. This name will be shown in the notification.
-     */
-    public static final String EXTRA_DEVICE_NAME = "no.nordicsemi.android.dfu.extra.EXTRA_DEVICE_NAME";
-
-    public static final String EXTRA_DEVICE_PAIR_CODE = "no.nordicsemi.android.dfu.extra.EXTRA_DEVICE_PAIR_CODE";
-    /**
-     * <p>
-     * If the new firmware (application) does not share the bond information with the old one, the bond information is lost. Set this flag to <code>true</code>
-     * to make the service create new bond with the new application when the upload is done (and remove the old one). When set to <code>false</code> (default),
-     * the DFU service assumes that the LTK is shared between them. Note: currently it is not possible to remove the old bond without creating a new one so if
-     * your old application supported bonding while the new one does not you have to modify the source code yourself.
-     * </p>
-     * <p>
-     * In case of updating the soft device the application is always removed together with the bond information.
-     * </p>
-     * <p>
-     * Search for occurrences of EXTRA_RESTORE_BOND in this file to check the implementation and get more details.
-     * </p>
-     */
-    public static final String EXTRA_RESTORE_BOND = "no.nordicsemi.android.dfu.extra.EXTRA_RESTORE_BOND";
-
-    /**
-     * <p>This flag indicated whether the bond information should be kept or removed after an upgrade of the Application.
-     * If an application is being updated on a bonded device with the DFU Bootloader that has been configured to preserve the bond information for the new application,
-     * set it to <code>true</code>.</p>
-     * <p/>
-     * <p>By default the DFU Bootloader clears the whole application's memory. It may be however configured in the \Nordic\nrf51\components\libraries\bootloader_dfu\dfu_types.h
-     * file (line 56: <code>#define DFU_APP_DATA_RESERVED 0x0000</code>) to preserve some pages. The BLE_APP_HRM_DFU sample app stores the LTK and System Attributes in the first
-     * two pages, so in order to preserve the bond information this value should be changed to 0x0800 or more.
-     * When those data are preserved, the new Application will notify the app with the Service Changed indication when launched for the first time. Otherwise this
-     * service will remove the bond information from the phone and force to refresh the device cache (see {@link #refreshDeviceCache(android.bluetooth.BluetoothGatt, boolean)}).</p>
-     * <p/>
-     * <p>In contrast to {@link #EXTRA_RESTORE_BOND} this flag will not remove the old bonding and recreate a new one, but will keep the bond information untouched.</p>
-     * <p>The default value of this flag is <code>false</code></p>
-     */
-    public static final String EXTRA_KEEP_BOND = "no.nordicsemi.android.dfu.extra.EXTRA_KEEP_BOND";
-
-    /**
-     * A path to the file with the new firmware. It may point to a HEX, BIN or a ZIP file.
-     * Some file manager applications return the path as a String while other return a Uri. Use the {@link #EXTRA_FILE_URI} in the later case.
-     */
-    public static final String EXTRA_FILE_PATH = "no.nordicsemi.android.dfu.extra.EXTRA_FILE_PATH";
-
-    /**
-     * See {@link #EXTRA_FILE_PATH} for details.
-     */
-    public static final String EXTRA_FILE_URI = "no.nordicsemi.android.dfu.extra.EXTRA_FILE_URI";
-    /**
-     * The Init packet URI. This file is required if the Extended Init Packet is required (SDK 7.0+). Must point to a 'dat' file corresponding with the selected firmware.
-     * The Init packet may contain just the CRC (in case of older versions of DFU) or the Extended Init Packet in binary format (SDK 7.0+).
-     */
-    public static final String EXTRA_INIT_FILE_PATH = "no.nordicsemi.android.dfu.extra.EXTRA_INIT_FILE_PATH";
-
-    /**
-     * The Init packet URI. This file is required if the Extended Init Packet is required (SDK 7.0+). Must point to a 'dat' file corresponding with the selected firmware.
-     * The Init packet may contain just the CRC (in case of older versions of DFU) or the Extended Init Packet in binary format (SDK 7.0+).
-     */
-    public static final String EXTRA_INIT_FILE_URI = "no.nordicsemi.android.dfu.extra.EXTRA_INIT_FILE_URI";
-
-    /**
-     * The input file mime-type. Currently only "application/zip" (ZIP) or "application/octet-stream" (HEX or BIN) are supported. If this parameter is
-     * empty the "application/octet-stream" is assumed.
-     */
-    public static final String EXTRA_FILE_MIME_TYPE = "no.nordicsemi.android.dfu.extra.EXTRA_MIME_TYPE";
-
-    // Since the DFU Library version 0.5 both HEX and BIN files are supported. As both files have the same MIME TYPE the distinction is made based on the file extension.
-    public static final String MIME_TYPE_OCTET_STREAM = "application/octet-stream";
-    public static final String MIME_TYPE_ZIP = "application/zip";
-
-    public static final String EXTRA_WAIT_FOR_INIT_DEVICE_FIRMWARE = "com.samsung.microbit.WAIT_FOR_INIT";
-
-    /**
-     * This optional extra parameter may contain a file type. Currently supported are:
-     * <ul>
-     * <li>{@link #TYPE_SOFT_DEVICE} - only Soft Device update</li>
-     * <li>{@link #TYPE_BOOTLOADER} - only Bootloader update</li>
-     * <li>{@link #TYPE_APPLICATION} - only application update</li>
-     * <li>{@link #TYPE_AUTO} - the file is a ZIP file that may contain more than one HEX/BIN + DAT files. Since SDK 8.0 the ZIP Distribution packet is a recommended
-     * way of delivering firmware files. Please, see the DFU documentation for more details. A ZIP distribution packet may be created using the 'nrf utility'
-     * command line application, that is a part of Master Control Panel 3.8.0.The ZIP file MAY contain only the following files:
-     * <b>softdevice.hex/bin</b>, <b>bootloader.hex/bin</b>, <b>application.hex/bin</b> to determine the type based on its name. At lease one of them MUST be present.
-     * </li>
-     * </ul>
-     * If this parameter is not provided the type is assumed as follows:
-     * <ol>
-     * <li>If the {@link #EXTRA_FILE_MIME_TYPE} field is <code>null</code> or is equal to {@value #MIME_TYPE_OCTET_STREAM} - the {@link #TYPE_APPLICATION} is assumed.</li>
-     * <li>If the {@link #EXTRA_FILE_MIME_TYPE} field is equal to {@value #MIME_TYPE_ZIP} - the {@link #TYPE_AUTO} is assumed.</li>
-     * </ol>
-     */
-    public static final String EXTRA_FILE_TYPE = "no.nordicsemi.android.dfu.extra.EXTRA_FILE_TYPE";
-
-    /**
-     * <p>
-     * The file contains a new version of Soft Device.
-     * </p>
-     * <p>
-     * Since DFU Library 7.0 all firmware may contain an Init packet. The Init packet is required if Extended Init Packet is used by the DFU bootloader (SDK 7.0+)..
-     * The Init packet for the bootloader must be placed in the .dat file.
-     * </p>
-     *
-     * @see #EXTRA_FILE_TYPE
-     */
-    public static final int TYPE_SOFT_DEVICE = 0x01;
-
-    /**
-     * <p>
-     * The file contains a new version of Bootloader.
-     * </p>
-     * <p>
-     * Since DFU Library 7.0 all firmware may contain an Init packet. The Init packet is required if Extended Init Packet is used by the DFU bootloader (SDK 7.0+).
-     * The Init packet for the bootloader must be placed in the .dat file.
-     * </p>
-     *
-     * @see #EXTRA_FILE_TYPE
-     */
-    public static final int TYPE_BOOTLOADER = 0x02;
-
-    /**
-     * <p>
-     * The file contains a new version of Application.
-     * </p>
-     * <p>
-     * Since DFU Library 0.5 all firmware may contain an Init packet. The Init packet is required if Extended Init Packet is used by the DFU bootloader (SDK 7.0+).
-     * The Init packet for the application must be placed in the .dat file.
-     * </p>
-     *
-     * @see #EXTRA_FILE_TYPE
-     */
-    public static final int TYPE_APPLICATION = 0x04;
-
-    /**
-     * <p>
-     * A ZIP file that consists of more than 1 file. Since SDK 8.0 the ZIP Distribution packet is a recommended way of delivering firmware files. Please, see the DFU documentation for
-     * more details. A ZIP distribution packet may be created using the 'nrf utility' command line application, that is a part of Master Control Panel 3.8.0.
-     * For backwards compatibility this library supports also ZIP files without the manifest file. Instead they must follow the fixed naming convention:
-     * The names of files in the ZIP must be: <b>softdevice.hex</b> (or .bin), <b>bootloader.hex</b> (or .bin), <b>application.hex</b> (or .bin) in order
-     * to be read correctly. Using the Soft Device v7.0.0+ the Soft Device and Bootloader may be updated and sent together. In case of additional application file included,
-     * the service will try to send Soft Device, Bootloader and Application together (which is not supported currently) and if it fails, send first SD+BL, reconnect and send the application
-     * in the following connection.
-     * </p>
-     * <p>
-     * Since the DFU Library 0.5 you may specify the Init packet, that will be send prior to the firmware. The init packet contains some verification data, like a device type and
-     * revision, application version or a list of supported Soft Devices. The Init packet is required if Extended Init Packet is used by the DFU bootloader (SDK 7.0+).
-     * In case of using the compatibility ZIP files the Init packet for the Soft Device and Bootloader must be in the 'system.dat' file while for the application
-     * in the 'application.dat' file (included in the ZIP). The CRC in the 'system.dat' must be a CRC of both BIN contents if both a Soft Device and a Bootloader is present.
-     * </p>
-     *
-     * @see #EXTRA_FILE_TYPE
-     */
-    public static final int TYPE_AUTO = 0x00;
-
-    /**
-     * An extra field with progress and error information used in broadcast events.
-     */
-    public static final String EXTRA_DATA = "no.nordicsemi.android.dfu.extra.EXTRA_DATA";
-
-    /**
-     * An extra field to send the progress or error information in the DFU notification. The value may contain:
-     * <ul>
-     * <li>Value 0 - 100 - percentage progress value</li>
-     * <li>One of the following status constants:
-     * <ul>
-     * <li>{@link #PROGRESS_CONNECTING}</li>
-     * <li>{@link #PROGRESS_STARTING}</li>
-     * <li>{@link #PROGRESS_ENABLING_DFU_MODE}</li>
-     * <li>{@link #PROGRESS_VALIDATING}</li>
-     * <li>{@link #PROGRESS_DISCONNECTING}</li>
-     * <li>{@link #PROGRESS_COMPLETED}</li>
-     * <li>{@link #PROGRESS_ABORTED}</li>
-     * </ul>
-     * </li>
-     * <li>An error code with {@link #ERROR_MASK} if initialization error occurred</li>
-     * <li>An error code with {@link #ERROR_REMOTE_MASK} if remote DFU target returned an error</li>
-     * <li>An error code with {@link #ERROR_CONNECTION_MASK} if connection error occurred (f.e. GATT error (133) or Internal GATT Error (129))</li>
-     * </ul>
-     * To check if error occurred use:<br />
-     * {@code boolean error = progressValue >= DfuBaseService.ERROR_MASK;}
-     */
-    public static final String EXTRA_PROGRESS = "no.nordicsemi.android.dfu.extra.EXTRA_PROGRESS";
-
-    /**
-     * The number of currently transferred part. The SoftDevice and Bootloader may be send together as one part. If user wants to upload them together with an application it has to be sent
-     * in another connection as the second part.
-     *
-     * @see no.nordicsemi.android.dfu.DfuBaseService#EXTRA_PARTS_TOTAL
-     */
-    public static final String EXTRA_PART_CURRENT = "no.nordicsemi.android.dfu.extra.EXTRA_PART_CURRENT";
-
-    /**
-     * Number of parts in total.
-     *
-     * @see no.nordicsemi.android.dfu.DfuBaseService#EXTRA_PART_CURRENT
-     */
-    public static final String EXTRA_PARTS_TOTAL = "no.nordicsemi.android.dfu.extra.EXTRA_PARTS_TOTAL";
-
-    /**
-     * The current upload speed in bytes/millisecond.
-     */
-    public static final String EXTRA_SPEED_B_PER_MS = "no.nordicsemi.android.dfu.extra.EXTRA_SPEED_B_PER_MS";
-
-    /**
-     * The average upload speed in bytes/millisecond for the current part.
-     */
-    public static final String EXTRA_AVG_SPEED_B_PER_MS = "no.nordicsemi.android.dfu.extra.EXTRA_AVG_SPEED_B_PER_MS";
-    /**
-     * The broadcast message contains the following extras:
-     * <ul>
-     * <li>{@link #EXTRA_DATA} - the progress value (percentage 0-100) or:
-     * <ul>
-     * <li>{@link #PROGRESS_CONNECTING}</li>
-     * <li>{@link #PROGRESS_STARTING}</li>
-     * <li>{@link #PROGRESS_ENABLING_DFU_MODE}</li>
-     * <li>{@link #PROGRESS_VALIDATING}</li>
-     * <li>{@link #PROGRESS_DISCONNECTING}</li>
-     * <li>{@link #PROGRESS_COMPLETED}</li>
-     * <li>{@link #PROGRESS_ABORTED}</li>
-     * </ul>
-     * </li>
-     * <li>{@link #EXTRA_DEVICE_ADDRESS} - the target device address</li>
-     * <li>{@link #EXTRA_PART_CURRENT} - the number of currently transmitted part</li>
-     * <li>{@link #EXTRA_PARTS_TOTAL} - total number of parts that are being sent, f.e. if a ZIP file contains a Soft Device, a Bootloader and an Application,
-     * the SoftDevice and Bootloader will be send together as one part. Then the service will disconnect and reconnect to the new Bootloader and send the
-     * application as part number two.</li>
-     * <li>{@link #EXTRA_SPEED_B_PER_MS} - current speed in bytes/millisecond as float</li>
-     * <li>{@link #EXTRA_AVG_SPEED_B_PER_MS} - the average transmission speed in bytes/millisecond as float</li>
-     * </ul>
-     */
-    public static final String BROADCAST_PROGRESS = "no.nordicsemi.android.dfu.broadcast.BROADCAST_PROGRESS";
-
-    /**
-     * Service is connecting to the remote DFU target.
-     */
-    public static final int PROGRESS_CONNECTING = -1;
-
-    /**
-     * Service is enabling notifications and starting transmission.
-     */
-    public static final int PROGRESS_STARTING = -2;
-
-    /**
-     * Service has triggered a switch to bootloader mode. Now the service waits for the link loss event (this may take up to several seconds) and will connect again
-     * to the same device, now started in the bootloader mode.
-     */
-    public static final int PROGRESS_ENABLING_DFU_MODE = -3;
-
-    /**
-     * Service is sending validation request to the remote DFU target.
-     */
-    public static final int PROGRESS_VALIDATING = -4;
-
-    /**
-     * Service is disconnecting from the DFU target.
-     */
-    public static final int PROGRESS_DISCONNECTING = -5;
-
-    /**
-     * The connection is successful.
-     */
-    public static final int PROGRESS_COMPLETED = -6;
-
-    /**
-     * The upload has been aborted. Previous software version will be restored on the target.
-     */
-    public static final int PROGRESS_ABORTED = -7;
-
-    public static final int PROGRESS_SERVICE_NOT_FOUND = -10;
-
-
-    public static final int PROGRESS_VALIDATION_FAILED = -8;
-
-
-    public static final int PROGRESS_WAITING_REBOOT = -9;
-    /**
-     * The broadcast error message contains the following extras:
-     * <ul>
-     * <li>{@link #EXTRA_DATA} - the error number. Use {@link GattError#parse(int)} to get String representation</li>
-     * <li>{@link #EXTRA_DEVICE_ADDRESS} - the target device address</li>
-     * </ul>
-     */
-    public static final String BROADCAST_ERROR = "no.nordicsemi.android.dfu.broadcast.BROADCAST_ERROR";
-
-    /**
-     * The type of the error. This extra contains information about that kind of error has occurred. Connection state errors and other errors may share the same numbers.
-     * For example, the {@link BluetoothGattCallback#onCharacteristicWrite(BluetoothGatt, BluetoothGattCharacteristic, int)} method may return a status code 8 (GATT INSUF AUTHORIZATION),
-     * while the status code 8 returned by {@link BluetoothGattCallback#onConnectionStateChange(BluetoothGatt, int, int)} is a GATT CONN TIMEOUT error.
-     */
-    public static final String EXTRA_ERROR_TYPE = "no.nordicsemi.android.dfu.extra.EXTRA_ERROR_TYPE";
-    public static final int ERROR_TYPE_OTHER = 0;
-    public static final int ERROR_TYPE_COMMUNICATION_STATE = 1;
-    public static final int ERROR_TYPE_COMMUNICATION = 2;
-    public static final int ERROR_TYPE_DFU_REMOTE = 3;
-
-    /**
-     * If this bit is set than the progress value indicates an error. Use {@link GattError#parse(int)} to obtain error name.
-     */
-    public static final int ERROR_MASK = 0x1000;
-    public static final int ERROR_DEVICE_DISCONNECTED = ERROR_MASK; // | 0x00;
-    public static final int ERROR_FILE_NOT_FOUND = ERROR_MASK | 0x01;
-
-    /**
-     * Thrown if service was unable to open the file ({@link java.io.IOException} has been thrown).
-     */
-    public static final int ERROR_FILE_ERROR = ERROR_MASK | 0x02;
-
-    /**
-     * Thrown then input file is not a valid HEX or ZIP file.
-     */
-    public static final int ERROR_FILE_INVALID = ERROR_MASK | 0x03;
-
-    /**
-     * Thrown when {@link java.io.IOException} occurred when reading from file.
-     */
-    public static final int ERROR_FILE_IO_EXCEPTION = ERROR_MASK | 0x04;
-
-    /**
-     * Error thrown then {@code gatt.discoverServices();} returns false.
-     */
-    public static final int ERROR_SERVICE_DISCOVERY_NOT_STARTED = ERROR_MASK | 0x05;
-
-    /**
-     * Thrown when the service discovery has finished but the DFU service has not been found. The device does not support DFU of is not in DFU mode.
-     */
-    public static final int ERROR_SERVICE_NOT_FOUND = ERROR_MASK | 0x06;
-
-    /**
-     * Thrown when the required DFU service has been found but at least one of the DFU characteristics is absent.
-     */
-    public static final int ERROR_CHARACTERISTICS_NOT_FOUND = ERROR_MASK | 0x07;
-
-    /**
-     * Thrown when unknown response has been obtained from the target. The DFU target must follow specification.
-     */
-    public static final int ERROR_INVALID_RESPONSE = ERROR_MASK | 0x08;
-
-    /**
-     * Thrown when the the service does not support given type or mime-type.
-     */
-    public static final int ERROR_FILE_TYPE_UNSUPPORTED = ERROR_MASK | 0x09;
-
-    /**
-     * Thrown when the the Bluetooth adapter is disabled.
-     */
-    public static final int ERROR_BLUETOOTH_DISABLED = ERROR_MASK | 0x0A;
-    /**
-     * DFU Bootloader version 0.6+ requires sending the Init packet. If such bootloader version is detected, but the init packet has not been set this error is thrown.
-     */
-    public static final int ERROR_INIT_PACKET_REQUIRED = ERROR_MASK | 0x0B;
-    /**
-     * Thrown when the firmware file is not word-aligned. The firmware size must be dividable by 4 bytes.
-     */
-    public static final int ERROR_FILE_SIZE_INVALID = ERROR_MASK | 0x0C;
-    /**
-     * Flag set then the DFU target returned a DFU error. Look for DFU specification to get error codes.
-     */
-    public static final int ERROR_REMOTE_MASK = 0x2000;
-
-    /**
-     * The flag set when one of {@link android.bluetooth.BluetoothGattCallback} methods was called with status other than {@link android.bluetooth.BluetoothGatt#GATT_SUCCESS}.
-     */
-    public static final int ERROR_CONNECTION_MASK = 0x4000;
-
-    /**
-     * The flag set when the {@link android.bluetooth.BluetoothGattCallback#onConnectionStateChange(android.bluetooth.BluetoothGatt, int, int)} method was called with
-     * status other than {@link android.bluetooth.BluetoothGatt#GATT_SUCCESS}.
-     */
-    public static final int ERROR_CONNECTION_STATE_MASK = 0x8000;
-
-    /**
-     * The log events are only broadcast when there is no nRF Logger installed. The broadcast contains 2 extras:
-     * <ul>
-     * <li>{@link #EXTRA_LOG_LEVEL} - The log level, one of following: {@link #LOG_LEVEL_DEBUG}, {@link #LOG_LEVEL_VERBOSE}, {@link #LOG_LEVEL_INFO},
-     * {@link #LOG_LEVEL_APPLICATION}, {@link #LOG_LEVEL_WARNING}, {@link #LOG_LEVEL_ERROR}</li>
-     * <li>{@link #EXTRA_LOG_MESSAGE}</li> - The log message
-     * </ul>
-     */
-    public static final String BROADCAST_LOG = "no.nordicsemi.android.dfu.broadcast.BROADCAST_LOG";
-    public static final String EXTRA_LOG_MESSAGE = "no.nordicsemi.android.dfu.extra.EXTRA_LOG_INFO";
-    public static final String EXTRA_LOG_LEVEL = "no.nordicsemi.android.dfu.extra.EXTRA_LOG_LEVEL";
-
-	/*
-     * Note:
-	 * The nRF Logger API library has been excluded from the DfuLibrary.
-	 * All log events are now being sent using local broadcasts and may be logged into nRF Logger in the app module.
-	 * This is to make the Dfu module independent from logging tool.
-	 *
-	 * The log levels below are equal to log levels in nRF Logger API library, v 2.0.
-	 * @see https://github.com/NordicSemiconductor/nRF-Logger-API
-	 */
-    /**
-     * Level used just for debugging purposes. It has lowest level
-     */
-    public final static int LOG_LEVEL_DEBUG = 0;
-
-    /**
-     * Log entries with minor importance
-     */
-    public final static int LOG_LEVEL_VERBOSE = 1;
-
-    /**
-     * Default logging level for important entries
-     */
-    public final static int LOG_LEVEL_INFO = 5;
-
-    /**
-     * Log entries level for applications
-     */
-    public final static int LOG_LEVEL_APPLICATION = 10;
-
-    /**
-     * Log entries with high importance
-     */
-    public final static int LOG_LEVEL_WARNING = 15;
-
-    /**
-     * Log entries with very high importance, like errors
-     */
-    public final static int LOG_LEVEL_ERROR = 20;
-
-    public final static int LOG_LEVEL_BINARY_SIZE = 21;
-    public final static int LOG_LEVEL_HEX_SIZE = 22;
-    public final static int LOG_LEVEL_FIRMWARE = 23;
-
-    /**
-     * Activity may broadcast this broadcast in order to pause, resume or abort DFU process.
-     * Use {@link #EXTRA_ACTION} extra to pass the action.
-     */
-    public static final String BROADCAST_ACTION = "no.nordicsemi.android.dfu.broadcast.BROADCAST_ACTION";
-
-    /**
-     * The action extra. It may have one of the following values: {@link #ACTION_PAUSE}, {@link #ACTION_RESUME}, {@link #ACTION_ABORT}.
-     */
-    public static final String EXTRA_ACTION = "no.nordicsemi.android.dfu.extra.EXTRA_ACTION";
-
-    /**
-     * Pauses the upload. The service will wait for broadcasts with the action set to {@link #ACTION_RESUME} or {@link #ACTION_ABORT}.
-     */
-    public static final int ACTION_PAUSE = 0;
-
-    /**
-     * Resumes the upload that has been paused before using {@link #ACTION_PAUSE}.
-     */
-    public static final int ACTION_RESUME = 1;
-
-    /**
-     * Aborts the upload. The service does not need to be paused before.
-     * After sending {@link #BROADCAST_ACTION} with extra {@link #EXTRA_ACTION} set to this value the DFU bootloader will restore the old application
-     * (if there was already an application). Be aware that uploading the Soft Device will erase the application in order to make space in the memory.
-     * In case there is no application, or the application has been removed, the DFU bootloader will be started and user may try to send the application again.
-     * The bootloader may advertise with the address incremented by 1 to prevent caching services.
-     */
-    public static final int ACTION_ABORT = 2;
-
-    // DFU status values
-    public static final int DFU_STATUS_SUCCESS = 1;
-    public static final int DFU_STATUS_INVALID_STATE = 2;
-    public static final int DFU_STATUS_NOT_SUPPORTED = 3;
-    public static final int DFU_STATUS_DATA_SIZE_EXCEEDS_LIMIT = 4;
-    public static final int DFU_STATUS_CRC_ERROR = 5;
-    public static final int DFU_STATUS_OPERATION_FAILED = 6;
-
-    // Operation codes and packets
-    private static final int OP_CODE_START_DFU_KEY = 0x01; // 1
-    private static final int OP_CODE_INIT_DFU_PARAMS_KEY = 0x02; // 2
-    private static final int OP_CODE_RECEIVE_FIRMWARE_IMAGE_KEY = 0x03; // 3
-    private static final int OP_CODE_VALIDATE_KEY = 0x04; // 4
-    private static final int OP_CODE_ACTIVATE_AND_RESET_KEY = 0x05; // 5
-    private static final int OP_CODE_RESET_KEY = 0x06; // 6
-
-    //private static final int OP_CODE_PACKET_REPORT_RECEIVED_IMAGE_SIZE_KEY = 0x07; // 7
-    private static final int OP_CODE_PACKET_RECEIPT_NOTIF_REQ_KEY = 0x08; // 8
-    private static final int OP_CODE_RESPONSE_CODE_KEY = 0x10; // 16
-    private static final int OP_CODE_PACKET_RECEIPT_NOTIF_KEY = 0x11; // 11
-    private static final byte[] OP_CODE_START_DFU = new byte[]{OP_CODE_START_DFU_KEY, 0x00};
-    private static final byte[] OP_CODE_INIT_DFU_PARAMS_START = new byte[]{OP_CODE_INIT_DFU_PARAMS_KEY, 0x00};
-    private static final byte[] OP_CODE_INIT_DFU_PARAMS_COMPLETE = new byte[]{OP_CODE_INIT_DFU_PARAMS_KEY, 0x01};
-    private static final byte[] OP_CODE_RECEIVE_FIRMWARE_IMAGE = new byte[]{OP_CODE_RECEIVE_FIRMWARE_IMAGE_KEY};
-    private static final byte[] OP_CODE_VALIDATE = new byte[]{OP_CODE_VALIDATE_KEY};
-    private static final byte[] OP_CODE_ACTIVATE_AND_RESET = new byte[]{OP_CODE_ACTIVATE_AND_RESET_KEY};
-    private static final byte[] OP_CODE_RESET = new byte[]{OP_CODE_RESET_KEY};
-
-    //private static final byte[] OP_CODE_REPORT_RECEIVED_IMAGE_SIZE = new byte[] { OP_CODE_PACKET_REPORT_RECEIVED_IMAGE_SIZE_KEY };
-    private static final byte[] OP_CODE_PACKET_RECEIPT_NOTIF_REQ = new byte[]{OP_CODE_PACKET_RECEIPT_NOTIF_REQ_KEY, 0x00, 0x00};
-
-    private static final UUID DEVICE_INFORMATION_SERVICE_UUID = new UUID(0x0000180A00001000l, 0x800000805F9B34FBl);
-    private static final UUID FIRMWARE_REVISION_UUID = new UUID(0x00002A2600001000l, 0x800000805F9B34FBl);
-
-
-    // UUIDs used by the DFU
-    private static final UUID GENERIC_ATTRIBUTE_SERVICE_UUID = new UUID(0x0000180100001000l, 0x800000805F9B34FBl);
-    private static final UUID SERVICE_CHANGED_UUID = new UUID(0x00002A0500001000l, 0x800000805F9B34FBl);
-
-    private static final UUID DFU_SERVICE_UUID = new UUID(0x000015301212EFDEl, 0x1523785FEABCD123l);
-    private static final UUID DFU_CONTROL_POINT_UUID = new UUID(0x000015311212EFDEl, 0x1523785FEABCD123l);
-    private static final UUID DFU_PACKET_UUID = new UUID(0x000015321212EFDEl, 0x1523785FEABCD123l);
-
-    private static final UUID DFU_VERSION = new UUID(0x000015341212EFDEl, 0x1523785FEABCD123l);
-    private static final UUID CLIENT_CHARACTERISTIC_CONFIG = new UUID(0x0000290200001000l, 0x800000805f9b34fbl);
-
-    private static final UUID MINI_FLASH_SERVICE_UUID = UUID.fromString("E95D93B0-251D-470A-A062-FA1922DFA9A8");
-    private static final UUID MINI_FLASH_SERVICE_CONTROL_CHARACTERISTIC_UUID = UUID.fromString("E95D93B1-251D-470A-A062-FA1922DFA9A8");
-
-    private static final UUID CLIENT_CHARACTERISTIC_CONFIGURATION_DESCRIPTOR = UUID.fromString("00002902-0000-1000-8000-00805f9b34fb");
-
-    public static final int FLASHING_WITH_PAIR_CODE = 0x02;
-
-    public static final int NOTIFICATION_ID = 283; // a random number
-    private static final int NOTIFICATIONS = 1;
-    private static final int INDICATIONS = 2;
-    private static final char[] HEX_ARRAY = "0123456789ABCDEF".toCharArray();
-    private static final int MAX_PACKET_SIZE = 20; // the maximum number of bytes in one packet is 20. May be less.
-    private final byte[] mBuffer = new byte[MAX_PACKET_SIZE];
-
-    /**
-     * Lock used in synchronization purposes
-     */
-    private final Object mLock = new Object();
-    private BluetoothAdapter mBluetoothAdapter;
-    private InputStream mInputStream;
-    private String mDeviceAddress;
-    private String mDeviceName;
-
-    /**
-     * The current connection state. If its value is > 0 than an error has occurred. Error number is a negative value of mConnectionState
-     */
-    private volatile int mConnectionState;
-    private final static int STATE_DISCONNECTED = 0;
-    private final static int STATE_CONNECTING = -1;
-    private final static int STATE_CONNECTED = -2;
-    private final static int STATE_CONNECTED_AND_READY = -3; // indicates that services were discovered
-    private final static int STATE_DISCONNECTING = -4;
-    private final static int STATE_CLOSED = -5;
-
-    /**
-     * The number of the last error that has occurred or 0 if there was no error
-     */
-    private volatile int mError = 0;
-
-    /**
-     * Flag set when we got confirmation from the device that notifications are enabled.
-     */
-    private boolean mNotificationsEnabled;
-
-    /**
-     * Flag set when we got confirmation from the device that Service Changed indications are enabled.
-     */
-    private boolean mServiceChangedIndicationsEnabled;
-
-    /**
-     * The number of packets of firmware data to be send before receiving a new Packets receipt notification. 0 disables the packets notifications
-     */
-    private int mPacketsBeforeNotification = 10;
-
-    /**
-     * Size of BIN content of all hex files that are going to be transmitted.
-     */
-    private int mImageSizeInBytes;
-
-    /**
-     * Number of bytes transmitted.
-     */
-    private int mBytesSent;
-
-    /**
-     * Number of bytes confirmed by the notification.
-     */
-    @SuppressWarnings("unused")
-    private int mBytesConfirmed;
-    private int mPacketsSentSinceNotification;
-
-    /**
-     * This value is used to calculate the current transfer speed.
-     */
-    private int mLastBytesSent;
-
-    /**
-     * Firmware update may require two connections: one for Soft Device and/or Bootloader upload and second for Application. This fields contains the current part number.
-     */
-    private int mPartCurrent;
-
-    /**
-     * Total number of parts.
-     */
-    private int mPartsTotal;
-    private int mFileType;
-    private long mLastProgressTime, mStartTime;
-
-    /**
-     * Flag sent when a request has been sent that will cause the DFU target to reset. Often, after sending such command, Android throws a connection state error. If this flag is set the error will be
-     * ignored.
-     */
-    private boolean mResetRequestSent;
-
-    /**
-     * Flag indicating whether the image size has been already transferred or not
-     */
-    private boolean mImageSizeSent;
-
-    /**
-     * Flag indicating whether the init packet has been already transferred or not
-     */
-    private boolean mInitPacketSent;
-
-    /**
-     * Flag indicating whether the request was completed or not
-     */
-    private boolean mRequestCompleted;
-
-    /**
-     * <p>
-     * Flag set to <code>true</code> when the DFU target had send any notification with status other than {@link #DFU_STATUS_SUCCESS}. Setting it to <code>true</code> will abort sending firmware and
-     * stop logging notifications (read below for explanation).
-     * </p>
-     * <p>
-     * The onCharacteristicWrite(..) callback is written when Android puts the packet to the outgoing queue, not when it physically send the data. Therefore, in case of invalid state of the DFU
-     * target, Android will first put up to N* packets, one by one, while in fact the first will be transmitted. In case the DFU target is in an invalid state it will notify Android with a
-     * notification 10-03-02 for each packet of firmware that has been sent. However, just after receiving the first one this service will try to send the reset command while still getting more
-     * 10-03-02 notifications. This flag will prevent from logging "Notification received..." more than once.
-     * </p>
-     * <p>
-     * Additionally, sometimes after writing the command 6 ({@link #OP_CODE_RESET}), Android will receive a notification and update the characteristic value with 10-03-02 and the callback for write
-     * reset command will log "[DFU] Data written to ..., value (0x): 10-03-02" instead of "...(x0): 06". But this does not matter for the DFU process.
-     * </p>
-     * <p>
-     * N* - Value of Packet Receipt Notification, 10 by default.
-     * </p>
-     */
-    private boolean mRemoteErrorOccurred;
-    private boolean mPaused;
-    private boolean mAborted;
-
-    private long delayForInitDeviceFirmware;
-
-    private volatile BluetoothGatt gatt = null;
-    private volatile BluetoothDevice device = null;
-
-    /**
-     * Latest data received from device using notification.
-     */
-    private byte[] mReceivedData = null;
-
-    //static NotificationCompat.Builder builder=null;
-    private final BroadcastReceiver mConnectionStateBroadcastReceiver = new BroadcastReceiver() {
-
-        @Override
-        public void onReceive(final Context context, final Intent intent) {
-            // Obtain the device and check it this is the one that we are connected to
-            final BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
-            if (!device.getAddress().equals(mDeviceAddress))
-                return;
-
-            final String action = intent.getAction();
-
-            logi("Action received: " + action);
-            mConnectionState = STATE_DISCONNECTED;
-
-            // Notify waiting thread
-            synchronized (mLock) {
-                mLock.notifyAll();
-            }
-        }
-    };
-
-    private final BroadcastReceiver mDfuActionReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(final Context context, final Intent intent) {
-            final int action = intent.getIntExtra(EXTRA_ACTION, 0);
-
-            switch (action) {
-                case ACTION_PAUSE:
-                    mPaused = true;
-                    break;
-
-                case ACTION_RESUME:
-                    mPaused = false;
-
-                    // Notify waiting thread
-                    synchronized (mLock) {
-                        mLock.notifyAll();
-                    }
-                    break;
-
-                case ACTION_ABORT:
-                    mPaused = false;
-                    mAborted = true;
-
-                    // Notify waiting thread
-                    synchronized (mLock) {
-                        mLock.notifyAll();
-                    }
-                    break;
-            }
-        }
-    };
-
-    private final BroadcastReceiver mBondStateBroadcastReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(final Context context, final Intent intent) {
-            // Obtain the device and check it this is the one that we are connected to
-            final BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
-            if (!device.getAddress().equals(mDeviceAddress))
-                return;
-
-            // Read bond state
-            final int bondState = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, -1);
-            if (bondState == BluetoothDevice.BOND_BONDING)
-                return;
-
-            mRequestCompleted = true;
-
-            // Notify waiting thread
-            synchronized (mLock) {
-                mLock.notifyAll();
-            }
-        }
-    };
-
-    private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() {
-        @Override
-        public void onConnectionStateChange(final BluetoothGatt gatt, final int status, final int newState) {
-            // Check whether an error occurred
-            logi("onConnectionStateChange() :: Start");
-            if (status == BluetoothGatt.GATT_SUCCESS) {
-                if (newState == BluetoothGatt.STATE_CONNECTED) {
-                    logi("onConnectionStateChange() :: Connected to GATT server");
-                    mConnectionState = STATE_CONNECTED;
-
-					/*
-                     *  The onConnectionStateChange callback is called just after establishing connection and before sending Encryption Request BLE event in case of a paired device.
-					 *  In that case and when the Service Changed CCCD is enabled we will get the indication after initializing the encryption, about 1600 milliseconds later. 
-					 *  If we discover services right after connecting, the onServicesDiscovered callback will be called immediately, before receiving the indication and the following 
-					 *  service discovery and we may end up with old, application's services instead.
-					 *  
-					 *  This is to support the buttonless switch from application to bootloader mode where the DFU bootloader notifies the master about service change.
-					 *  Tested on Nexus 4 (Android 4.4.4 and 5), Nexus 5 (Android 5), Samsung Note 2 (Android 4.4.2). The time after connection to end of service discovery is about 1.6s 
-					 *  on Samsung Note 2.
-					 *  
-					 *  NOTE: We are doing this to avoid the hack with calling the hidden gatt.refresh() method, at least for bonded devices.
-					 */
-                    if (gatt.getDevice().getBondState() == BluetoothDevice.BOND_BONDED) {
-                        try {
-                            synchronized (this) {
-                                logd("onConnectionStateChange() :: Waiting 1600 ms for a possible Service Changed indication...");
-                                wait(1600);
-
-                                // After 1.6s the services are already discovered so the following gatt.discoverServices() finishes almost immediately.
-
-                                // NOTE: This also works with shorted waiting time. The gatt.discoverServices() must be called after the indication is received which is
-                                // about 600ms after establishing connection. Values 600 - 1600ms should be OK.
-                            }
-                        } catch (InterruptedException e) {
-                            Log.e(TAG, e.toString());
-                            // Do nothing
-                        }
-                    }
-
-                    // Attempts to discover services after successful connection.
-                    final boolean success = gatt.discoverServices();
-                    logi("onConnectionStateChange() :: Attempting to start service discovery... " + (success ? "succeed" : "failed"));
-
-                    if (!success) {
-                        mError = ERROR_SERVICE_DISCOVERY_NOT_STARTED;
-                    } else {
-                        // Just return here, lock will be notified when service discovery finishes
-                        return;
-                    }
-                } else if (newState == BluetoothGatt.STATE_DISCONNECTED) {
-                    logi("onConnectionStateChange() :: Disconnected from GATT server");
-                    mPaused = false;
-                    mConnectionState = STATE_DISCONNECTED;
-                }
-            } else {
-                loge("Connection state change error: " + status + " newState: " + newState);
-/*				if (newState == BluetoothGatt.STATE_DISCONNECTED) {
-                    mConnectionState = STATE_DISCONNECTED;
-                    if (mServicePhase == PAIRING_REQUEST ){
-                        mServicePhase = PAIRING_FAILED ;
-                        updateProgressNotification(status);
-                    }
-                }*/
-                mPaused = false;
-                mError = ERROR_CONNECTION_STATE_MASK | status;
-            }
-
-            // Notify waiting thread
-            synchronized (mLock) {
-                mLock.notifyAll();
-            }
-        }
-
-        @Override
-        public void onServicesDiscovered(final BluetoothGatt gatt, final int status) {
-            // Notify waiting thread
-            logi("onServicesDiscovered() :: Start");
-            if (status == BluetoothGatt.GATT_SUCCESS) {
-                logi("onServicesDiscovered() :: Services discovered");
-                mConnectionState = STATE_CONNECTED_AND_READY;
-            } else {
-                loge("onServicesDiscovered() :: Service discovery error: " + status);
-                mError = ERROR_CONNECTION_MASK | status;
-            }
-            synchronized (mLock) {
-                mLock.notifyAll();
-            }
-        }
-
-        @Override
-        public void onDescriptorRead(final BluetoothGatt gatt, final BluetoothGattDescriptor descriptor, final int status) {
-            if (status == BluetoothGatt.GATT_SUCCESS) {
-                if (CLIENT_CHARACTERISTIC_CONFIG.equals(descriptor.getUuid())) {
-                    if (SERVICE_CHANGED_UUID.equals(descriptor.getCharacteristic().getUuid())) {
-                        // We have enabled indications for the Service Changed characteristic
-                        mServiceChangedIndicationsEnabled = descriptor.getValue()[0] == 2;
-                        mRequestCompleted = true;
-                    }
-                }
-            } else {
-                loge("Descriptor read error: " + status);
-                mError = ERROR_CONNECTION_MASK | status;
-            }
-            // Notify waiting thread
-            synchronized (mLock) {
-                mLock.notifyAll();
-            }
-        }
-
-        @Override
-        public void onDescriptorWrite(final BluetoothGatt gatt, final BluetoothGattDescriptor descriptor, final int status) {
-
-            if (status == BluetoothGatt.GATT_SUCCESS) {
-                if (CLIENT_CHARACTERISTIC_CONFIG.equals(descriptor.getUuid())) {
-                    if (SERVICE_CHANGED_UUID.equals(descriptor.getCharacteristic().getUuid())) {
-                        // We have enabled indications for the Service Changed characteristic
-                        mServiceChangedIndicationsEnabled = descriptor.getValue()[0] == 2;
-                    } else {
-                        // We have enabled notifications for this characteristic
-                        mNotificationsEnabled = descriptor.getValue()[0] == 1;
-                    }
-                }
-            } else {
-                loge("Descriptor write error: " + status);
-                mError = ERROR_CONNECTION_MASK | status;
-            }
-            // Notify waiting thread
-            synchronized (mLock) {
-                mLock.notifyAll();
-            }
-        }
-
-        @Override
-        public void onCharacteristicWrite(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final int status) {
-            if (status == BluetoothGatt.GATT_SUCCESS) {
-				/*
-				 * This method is called when either a CONTROL POINT or PACKET characteristic has been written.
-				 * If it is the CONTROL POINT characteristic, just set the {@link mRequestCompleted} flag to true. The main thread will continue its task when notified.
-				 * If the PACKET characteristic was written we must:
-				 * - if the image size was written in DFU Start procedure, just set flag to true
-				 * otherwise
-				 * - send the next packet, if notification is not required at that moment, or
-				 * - do nothing, because we have to wait for the notification to confirm the data received
-				 */
-                if (DFU_PACKET_UUID.equals(characteristic.getUuid())) {
-                    if (mImageSizeSent && mInitPacketSent) {
-                        // If the PACKET characteristic was written with image data, update counters
-                        mBytesSent += characteristic.getValue().length;
-                        mPacketsSentSinceNotification++;
-
-                        // If a packet receipt notification is expected, or the last packet was sent, do nothing. There onCharacteristicChanged listener will catch either
-                        // a packet confirmation (if there are more bytes to send) or the image received notification (it upload process was completed)
-                        final boolean notificationExpected = mPacketsBeforeNotification > 0 && mPacketsSentSinceNotification == mPacketsBeforeNotification;
-                        final boolean lastPacketTransferred = mBytesSent == mImageSizeInBytes;
-
-                        if (notificationExpected || lastPacketTransferred)
-                            return;
-
-                        // When neither of them is true, send the next packet
-                        try {
-                            waitIfPaused();
-                            // The writing might have been aborted (mAborted = true), an error might have occurred.
-                            // In that case stop sending.
-                            if (mAborted || mError != 0 || mRemoteErrorOccurred || mResetRequestSent) {
-                                // notify waiting thread
-                                synchronized (mLock) {
-                                    sendLogBroadcast(LOG_LEVEL_WARNING, "Upload terminated");
-                                    mLock.notifyAll();
-                                    return;
-                                }
-                            }
-
-                            final byte[] buffer = mBuffer;
-                            final int size = mInputStream.read(buffer);
-                            writePacket(gatt, characteristic, buffer, size);
-                            updateProgressNotification();
-                            return;
-                        } catch (final HexFileValidationException e) {
-                            loge("Invalid HEX file");
-                            mError = ERROR_FILE_INVALID;
-                        } catch (final IOException e) {
-                            loge("Error while reading the input stream", e);
-                            mError = ERROR_FILE_IO_EXCEPTION;
-                        }
-                    } else if (!mImageSizeSent) {
-                        // We've got confirmation that the image size was sent
-                        sendLogBroadcast(LOG_LEVEL_INFO, "Data written to " + characteristic.getUuid() + ", value (0x): " + parse(characteristic));
-                        mImageSizeSent = true;
-                    } else {
-                        // We've got confirmation that the init packet was sent
-                        sendLogBroadcast(LOG_LEVEL_INFO, "Data written to " + characteristic.getUuid() + ", value (0x): " + parse(characteristic));
-                        mInitPacketSent = true;
-                    }
-                } else {
-                    // If the CONTROL POINT characteristic was written just set the flag to true. The main thread will continue its task when notified.
-                    sendLogBroadcast(LOG_LEVEL_INFO, "Data written to " + characteristic.getUuid() + ", value (0x): " + parse(characteristic));
-                    mRequestCompleted = true;
-                }
-            } else {
-				/*
-				 * If a Reset (Op Code = 6) or Activate and Reset (Op Code = 5) commands are sent, the DFU target resets and sometimes does it so quickly that does not manage to send
-				 * any ACK to the controller and error 133 is thrown here. This bug should be fixed in SDK 8.0+ where the target would gracefully disconnect before restarting.
-				 */
-                if (mResetRequestSent)
-                    mRequestCompleted = true;
-                else {
-                    loge("Characteristic write error: " + status);
-                    mError = ERROR_CONNECTION_MASK | status;
-                }
-            }
-
-            // Notify waiting thread
-            synchronized (mLock) {
-                mLock.notifyAll();
-            }
-        }
-
-        @Override
-        public void onCharacteristicRead(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final int status) {
-            if (status == BluetoothGatt.GATT_SUCCESS) {
-				/*
-				 * This method is called when the DFU Version characteristic has been read.
-				 */
-                sendLogBroadcast(LOG_LEVEL_INFO, "Read Response received from " + characteristic.getUuid() + ", value (0x): " + parse(characteristic));
-                mReceivedData = characteristic.getValue();
-                mRequestCompleted = true;
-            } else {
-                loge("Characteristic read error: " + status);
-                mError = ERROR_CONNECTION_MASK | status;
-            }
-
-            // Notify waiting thread
-            synchronized (mLock) {
-                mLock.notifyAll();
-            }
-        }
-
-        @Override
-        public void onCharacteristicChanged(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic) {
-            final int responseType = characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT8, 0);
-            switch (responseType) {
-                case OP_CODE_PACKET_RECEIPT_NOTIF_KEY:
-                    final BluetoothGattCharacteristic packetCharacteristic = gatt.getService(DFU_SERVICE_UUID).getCharacteristic(DFU_PACKET_UUID);
-
-                    try {
-                        mBytesConfirmed = characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT32, 1);
-                        mPacketsSentSinceNotification = 0;
-
-                        waitIfPaused();
-                        // The writing might have been aborted (mAborted = true), an error might have occurred.
-                        // In that case quit sending.
-                        if (mAborted || mError != 0 || mRemoteErrorOccurred || mResetRequestSent) {
-                            sendLogBroadcast(LOG_LEVEL_WARNING, "Upload terminated");
-                            break;
-                        }
-
-                        final byte[] buffer = mBuffer;
-                        final int size = mInputStream.read(buffer);
-                        writePacket(gatt, packetCharacteristic, buffer, size);
-                        updateProgressNotification();
-                        return;
-                    } catch (final HexFileValidationException e) {
-                        loge("Invalid HEX file");
-                        mError = ERROR_FILE_INVALID;
-                    } catch (final IOException e) {
-                        loge("Error while reading the input stream", e);
-                        mError = ERROR_FILE_IO_EXCEPTION;
-                    }
-                    break;
-
-                case OP_CODE_RESPONSE_CODE_KEY:
-                default:
-				/*
-				 * If the DFU target device is in invalid state (f.e. the Init Packet is required but has not been selected), the target will send DFU_STATUS_INVALID_STATE error
-				 * for each firmware packet that was send. We are interested may ignore all but the first one.
-				 * After obtaining a remote DFU error the OP_CODE_RESET_KEY will be sent.
-				 */
-                    if (mRemoteErrorOccurred)
-                        break;
-                    final int status = characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT8, 2);
-                    if (status != DFU_STATUS_SUCCESS)
-                        mRemoteErrorOccurred = true;
-
-                    sendLogBroadcast(LOG_LEVEL_INFO, "Notification received from " + characteristic.getUuid() + ", value (0x): " + parse(characteristic));
-                    mReceivedData = characteristic.getValue();
-                    break;
-            }
-
-            // Notify waiting thread
-            synchronized (mLock) {
-                mLock.notifyAll();
-            }
-        }
-
-        // This method is repeated here and in the service class for performance matters.
-        private String parse(final BluetoothGattCharacteristic characteristic) {
-            final byte[] data = characteristic.getValue();
-            if (data == null)
-                return "";
-            final int length = data.length;
-            if (length == 0)
-                return "";
-
-            final char[] out = new char[length * 3 - 1];
-            for (int j = 0; j < length; j++) {
-                int v = data[j] & 0xFF;
-                out[j * 3] = HEX_ARRAY[v >>> 4];
-                out[j * 3 + 1] = HEX_ARRAY[v & 0x0F];
-                if (j != length - 1)
-                    out[j * 3 + 2] = '-';
-            }
-            return new String(out);
-        }
-    };
-
-    /**
-     * Stores the last progress percent. Used to prevent from sending progress notifications with the same value.
-     *
-     * @see #updateProgressNotification(int)
-     */
-    private int mLastProgress = -1;
-
-    public DfuBaseServiceTwo() {
-        super(TAG);
-    }
-
-    private static IntentFilter makeDfuActionIntentFilter() {
-        final IntentFilter intentFilter = new IntentFilter();
-        intentFilter.addAction(DfuBaseService.BROADCAST_ACTION);
-        return intentFilter;
-    }
-
-    @Override
-    public void onCreate() {
-        super.onCreate();
-
-        initialize();
-
-        final LocalBroadcastManager manager = LocalBroadcastManager.getInstance(this);
-        final IntentFilter actionFilter = makeDfuActionIntentFilter();
-        manager.registerReceiver(mDfuActionReceiver, actionFilter);
-        registerReceiver(mDfuActionReceiver, actionFilter); // Additionally we must register this receiver as a non-local to get broadcasts from the notification actions
-
-        final IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_ACL_DISCONNECTED);
-        registerReceiver(mConnectionStateBroadcastReceiver, filter);
-
-        final IntentFilter bondFilter = new IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
-        registerReceiver(mBondStateBroadcastReceiver, bondFilter);
-    }
-
-    @Override
-    public void onDestroy() {
-        super.onDestroy();
-        logi("DfuService onDestroy");
-        final LocalBroadcastManager manager = LocalBroadcastManager.getInstance(this);
-        manager.unregisterReceiver(mDfuActionReceiver);
-
-        unregisterReceiver(mDfuActionReceiver);
-        unregisterReceiver(mConnectionStateBroadcastReceiver);
-        unregisterReceiver(mBondStateBroadcastReceiver);
-    }
-
-    ResultReceiver resultReceiver;
-
-    private int mServicePhase = 0;
-
-    @Override
-    protected void onHandleIntent(final Intent intent) {
-
-
-        int phase = intent.getIntExtra(INTENT_REQUESTED_PHASE, 0) & 0x03;
-        resultReceiver = (ResultReceiver) intent.getParcelableExtra(INTENT_RESULT_RECEIVER);
-        delayForInitDeviceFirmware = intent.getLongExtra(EXTRA_WAIT_FOR_INIT_DEVICE_FIRMWARE, 0);
-
-        int rc = 0;
-
-        logi("DFUBaseService onHandleIntent phase = " + phase);
-        mServicePhase = 0;
-
-        if ((phase & FLASHING_WITH_PAIR_CODE) != 0) {
-            mServicePhase = FLASHING_WITH_PAIR_CODE;
-
-            rc = flashingWithPairCode(intent);
-        }
-
-        if (resultReceiver != null) {
-            rc <<= 8;
-            resultReceiver.send(rc | phase, null);
-        }
-    }
-
-    private boolean makeGattConnection(String deviceAddress) {
-
-        gatt = null;
-        sendLogBroadcast(LOG_LEVEL_VERBOSE, "makeGattConnection to target..." + deviceAddress);
-        updateProgressNotification(PROGRESS_CONNECTING);
-
-        if (delayForInitDeviceFirmware != 0) {
-            try {
-                synchronized (mLock) {
-                    mLock.wait(delayForInitDeviceFirmware);
-                }
-            } catch (InterruptedException e) {
-                Log.e(TAG, e.toString());
-            }
-            delayForInitDeviceFirmware = 0;
-        }
-
-        mConnectionState = STATE_DISCONNECTED;
-        mBytesSent = 0;
-        mBytesConfirmed = 0;
-        mPacketsSentSinceNotification = 0;
-        mError = 0;
-        mLastProgressTime = 0;
-        mAborted = false;
-        mPaused = false;
-        mNotificationsEnabled = false;
-        mResetRequestSent = false;
-        mRequestCompleted = false;
-        mImageSizeSent = false;
-        mRemoteErrorOccurred = false;
-
-        connect(deviceAddress);
-
-        // Are we connected?
-        if (gatt == null) {
-            loge("Bluetooth adapter disabled");
-            sendLogBroadcast(LOG_LEVEL_ERROR, "Bluetooth adapter disabled");
-            updateProgressNotification(ERROR_BLUETOOTH_DISABLED);
-            return false;
-        }
-
-        if (mError > 0) { // error occurred
-            final int error = mError & ~ERROR_CONNECTION_STATE_MASK;
-            loge("An error occurred while connecting to the device:" + error);
-            sendLogBroadcast(LOG_LEVEL_ERROR, String.format("Connection failed (0x%02X): %s", error, GattError.parseConnectionError(error)));
-            terminateConnection(gatt, mError);
-            return false;
-        }
-
-        if (mAborted) {
-            logi("Upload aborted");
-            sendLogBroadcast(LOG_LEVEL_WARNING, "Upload aborted");
-            terminateConnection(gatt, PROGRESS_ABORTED);
-            return false;
-        }
-
-        return true;
-    }
-
-    private int flashingWithPairCode(Intent intent) {
-
-        mDeviceAddress = intent.getStringExtra(EXTRA_DEVICE_ADDRESS);
-        mDeviceName = intent.getStringExtra(EXTRA_DEVICE_NAME);
-
-        sendLogBroadcast(LOG_LEVEL_VERBOSE, "Connecting to DFU target 2...");
-        if (!makeGattConnection(mDeviceAddress))
-            return 5;
-
-        logi("Phase2 s");
-
-        updateProgressNotification(PROGRESS_VALIDATING);
-
-        //For Stats purpose only
-        {
-            BluetoothGattService deviceService = gatt.getService(DEVICE_INFORMATION_SERVICE_UUID);
-            if (deviceService != null) {
-                BluetoothGattCharacteristic firmwareCharacteristic = deviceService.getCharacteristic(FIRMWARE_REVISION_UUID);
-                if (firmwareCharacteristic != null) {
-                    String firmware = null;
-                    firmware = readCharacteristicNoFailure(gatt, firmwareCharacteristic);
-                    logi("Micro:bit firmware version String = " + firmware);
-                    sendStatsMicroBitFirmware(firmware);
-                } else {
-                    logi("Error Cannot find FIRMWARE_REVISION_UUID");
-                }
-            } else {
-                logi("Error Cannot find DEVICE_INFORMATION_SERVICE_UUID");
-            }
-        }//For Stats purpose only Ends
-        int rc = 1;
-
-        BluetoothGattService fps = gatt.getService(MINI_FLASH_SERVICE_UUID);
-        if (fps == null) {
-            logi("Error Cannot find MINI_FLASH_SERVICE_UUID");
-            sendLogBroadcast(LOG_LEVEL_WARNING, "Upload aborted");
-            terminateConnection(gatt, PROGRESS_SERVICE_NOT_FOUND);
-            return 6;
-        }
-
-        final BluetoothGattCharacteristic sfpc1 = fps.getCharacteristic(MINI_FLASH_SERVICE_CONTROL_CHARACTERISTIC_UUID);
-        if (sfpc1 == null) {
-            logi("Error Cannot find MINI_FLASH_SERVICE_CONTROL_CHARACTERISTIC_UUID");
-            sendLogBroadcast(LOG_LEVEL_WARNING, "Upload aborted");
-            terminateConnection(gatt, PROGRESS_SERVICE_NOT_FOUND);
-            return 6;
-        }
-
-        sfpc1.setValue(1, BluetoothGattCharacteristic.FORMAT_UINT8, 0);
-        try {
-            logi("Writing Flash Command ....");
-            writeCharacteristic(gatt, sfpc1);
-            rc = 0;
-        } catch (Exception e) {
-            e.printStackTrace();
-            Log.e(TAG, e.toString());
-        }
-
-        if (rc == 0) {
-            sendProgressBroadcast(PROGRESS_WAITING_REBOOT);
-            //Wait for the device to reboot.
-            waitUntilDisconnected();
-            waitUntilConnected();
-            logi("Refreshing the cache before discoverServices() for Android version " + Build.VERSION.SDK_INT);
-            refreshDeviceCache(gatt, true);
-            do {
-                logi("Calling phase 3");
-                mError = 0;
-                intent = phase3(intent);
-                resultReceiver = null;
-                gatt.disconnect();
-                waitUntilDisconnected();
-                if (mConnectionState != STATE_CLOSED) {
-                    close(gatt);
-                }
-                gatt = null;
-                logi("End phase 3");
-            } while (intent != null);
-        }
-
-        logi("Phase2 e");
-        return rc;
-    }
-
-    private Intent phase3(Intent intent) {
-        Log.i("OWN", "Phase 3 is fine");
-        final SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(this);
-
-        logi("Phase3 s");
-        // Read input parameters
-        final String deviceAddress = intent.getStringExtra(EXTRA_DEVICE_ADDRESS);
-        final String deviceName = intent.getStringExtra(EXTRA_DEVICE_NAME);
-        final String filePath = intent.getStringExtra(EXTRA_FILE_PATH);
-        final Uri fileUri = intent.getParcelableExtra(EXTRA_FILE_URI);
-        final String initFilePath = intent.getStringExtra(EXTRA_INIT_FILE_PATH);
-        final Uri initFileUri = intent.getParcelableExtra(EXTRA_INIT_FILE_URI);
-        int fileType = intent.getIntExtra(EXTRA_FILE_TYPE, TYPE_AUTO);
-        if (filePath != null && fileType == TYPE_AUTO)
-            fileType = filePath.toLowerCase(Locale.US).endsWith("zip") ? TYPE_AUTO : TYPE_APPLICATION;
-
-        String mimeType = intent.getStringExtra(EXTRA_FILE_MIME_TYPE);
-        mimeType = mimeType != null ? mimeType : (fileType == TYPE_AUTO ? MIME_TYPE_ZIP : MIME_TYPE_OCTET_STREAM);
-        mPartCurrent = intent.getIntExtra(EXTRA_PART_CURRENT, 1);
-        mPartsTotal = intent.getIntExtra(EXTRA_PARTS_TOTAL, 1);
-
-        mDeviceAddress = deviceAddress;
-        mDeviceName = deviceName;
-
-        // Read preferences
-        final boolean packetReceiptNotificationEnabled = preferences.getBoolean(DfuSettingsConstants.SETTINGS_PACKET_RECEIPT_NOTIFICATION_ENABLED, true);
-        String value = preferences.getString(DfuSettingsConstants.SETTINGS_NUMBER_OF_PACKETS, String.valueOf(DfuSettingsConstants.SETTINGS_NUMBER_OF_PACKETS_DEFAULT));
-        int numberOfPackets;
-        try {
-            numberOfPackets = Integer.parseInt(value);
-            if (numberOfPackets < 0 || numberOfPackets > 0xFFFF)
-                numberOfPackets = DfuSettingsConstants.SETTINGS_NUMBER_OF_PACKETS_DEFAULT;
-        } catch (final NumberFormatException e) {
-            numberOfPackets = DfuSettingsConstants.SETTINGS_NUMBER_OF_PACKETS_DEFAULT;
-            Log.e(TAG, e.toString());
-        }
-
-        if (!packetReceiptNotificationEnabled)
-            numberOfPackets = 0;
-
-        mPacketsBeforeNotification = numberOfPackets;
-        // The Soft Device starts where MBR ends (by default from the address 0x1000). Before there is a MBR section, which should not be transmitted over DFU.
-        // Applications and bootloader starts from bigger address. However, in custom DFU implementations, user may want to transmit the whole whole data, even from address 0x0000.
-        value = preferences.getString(DfuSettingsConstants.SETTINGS_MBR_SIZE, String.valueOf(DfuSettingsConstants.SETTINGS_DEFAULT_MBR_SIZE));
-        int mbrSize;
-        try {
-            mbrSize = Integer.parseInt(value);
-            if (mbrSize < 0)
-                mbrSize = 0;
-        } catch (final NumberFormatException e) {
-            mbrSize = DfuSettingsConstants.SETTINGS_DEFAULT_MBR_SIZE;
-            Log.e(TAG, e.toString());
-        }
-
-        sendLogBroadcast(LOG_LEVEL_VERBOSE, "Starting DFU service");
-
-		/*
-		 * First the service is trying to read the firmware and init packet files.
-		 */
-        InputStream is = null;
-        InputStream initIs = null;
-        int imageSizeInBytes;
-        try {
-            // Prepare data to send, calculate stream size
-            try {
-                sendLogBroadcast(LOG_LEVEL_VERBOSE, "Opening file...");
-                if (fileUri != null) {
-                    is = openInputStream(fileUri, mimeType, mbrSize, fileType);
-                } else {
-                    is = openInputStream(filePath, mimeType, mbrSize, fileType);
-                }
-
-                if (initFileUri != null) {
-                    // Try to read the Init Packet file from URI
-                    initIs = getContentResolver().openInputStream(initFileUri);
-                } else if (initFilePath != null) {
-                    // Try to read the Init Packet file from path
-                    initIs = new FileInputStream(initFilePath);
-                }
-
-                mInputStream = is;
-                imageSizeInBytes = mImageSizeInBytes = is.available();
-                // Update the file type bit field basing on the ZIP content
-                if (fileType == TYPE_AUTO && MIME_TYPE_ZIP.equals(mimeType)) {
-                    final ArchiveInputStream zhis = (ArchiveInputStream) is;
-                    fileType = zhis.getContentType();
-                }
-
-                mFileType = fileType;
-                // Set the Init packet stream in case of a ZIP file
-                if (MIME_TYPE_ZIP.equals(mimeType)) {
-                    final ArchiveInputStream zhis = (ArchiveInputStream) is;
-                    if (fileType == TYPE_APPLICATION) {
-                        if (zhis.getApplicationInit() != null)
-                            initIs = new ByteArrayInputStream(zhis.getApplicationInit());
-                    } else {
-                        if (zhis.getSystemInit() != null)
-                            initIs = new ByteArrayInputStream(zhis.getSystemInit());
-                    }
-                }
-
-                sendLogBroadcast(LOG_LEVEL_INFO, "Image file opened (" + mImageSizeInBytes + " bytes in total)");
-            } catch (final SecurityException e) {
-                loge("A security exception occurred while opening file", e);
-                updateProgressNotification(ERROR_FILE_NOT_FOUND);
-                return null;
-            } catch (final FileNotFoundException e) {
-                loge("An exception occurred while opening file", e);
-                updateProgressNotification(ERROR_FILE_NOT_FOUND);
-                return null;
-            } catch (final HexFileValidationException e) {
-                loge("HexFileValidationException - ", e);
-                updateProgressNotification(ERROR_FILE_INVALID);
-                return null;
-            } catch (final IOException e) {
-                loge("An exception occurred while calculating file size", e);
-                updateProgressNotification(ERROR_FILE_ERROR);
-                return null;
-            }
-
-			/*
-			 * Now let's connect to the device.
-			 * All the methods below are synchronous. The mLock object is used to wait for asynchronous calls.
-			 */
-
-            // Are we connected?
-            if (gatt != null) {
-                gatt.disconnect();
-                gatt.close();
-                gatt = null;
-            }
-
-            sendLogBroadcast(LOG_LEVEL_VERBOSE, "Connecting to DFU target 3...");
-            makeGattConnection(deviceAddress);
-            if (gatt == null) {
-
-                loge("Bluetooth adapter disabled");
-                sendLogBroadcast(LOG_LEVEL_ERROR, "Bluetooth adapter disabled");
-                updateProgressNotification(ERROR_BLUETOOTH_DISABLED);
-                return null;
-            }
-
-            if (mError > 0) { // error occurred
-                final int error = mError & ~ERROR_CONNECTION_STATE_MASK;
-                loge("An error occurred while connecting to the device:" + error);
-                sendLogBroadcast(LOG_LEVEL_ERROR, String.format("Connection failed (0x%02X): %s", error, GattError.parseConnectionError(error)));
-                terminateConnection(gatt, mError);
-                return null;
-            }
-
-            if (mAborted) {
-                logi("Upload aborted");
-                sendLogBroadcast(LOG_LEVEL_WARNING, "Upload aborted");
-                terminateConnection(gatt, PROGRESS_ABORTED);
-                return null;
-            }
-
-            // We have connected to DFU device and services are discoverer
-            BluetoothGattService dfuService = null;
-
-            dfuService = gatt.getService(DFU_SERVICE_UUID);
-
-            if (dfuService == null) {
-                disconnect(gatt);
-                logi("Refreshing the cache ");
-                refreshDeviceCache(gatt, true);
-                gattConnect(gatt); //TODO What if there is any error here
-                dfuService = gatt.getService(DFU_SERVICE_UUID); //Check again
-            }
-            if (dfuService == null) {
-                loge("DFU service does not exists on the device");
-                sendLogBroadcast(LOG_LEVEL_WARNING, "Connected. DFU Service not found");
-                terminateConnection(gatt, ERROR_SERVICE_NOT_FOUND);
-                return null;
-            }
-
-            final BluetoothGattCharacteristic controlPointCharacteristic = dfuService.getCharacteristic(DFU_CONTROL_POINT_UUID);
-            final BluetoothGattCharacteristic packetCharacteristic = dfuService.getCharacteristic(DFU_PACKET_UUID);
-            if (controlPointCharacteristic == null || packetCharacteristic == null) {
-                loge("DFU characteristics not found in the DFU service");
-                sendLogBroadcast(LOG_LEVEL_WARNING, "Connected. DFU Characteristics not found");
-                terminateConnection(gatt, ERROR_CHARACTERISTICS_NOT_FOUND);
-                return null;
-            }
-
-			/*
-			 * The DFU Version characteristic has been added in SDK 7.0.
-			 *
-			 * It may return version number in 2 bytes (f.e. 0x05-00), where the first one is the minor version and the second one is the major version.
-			 * In case of 0x05-00 the DFU has the version 0.5.
-			 *
-			 * Currently the following version numbers are supported:
-			 *
-			 *   - 0.1 (0x01-00) - The service is connected to the device in application mode, not to the DFU Bootloader. The application supports Long Term Key (LTK)
-			 *                     sharing and buttonless update. Enable notifications on the DFU Control Point characteristic and write 0x01-04 into it to jump to the Bootloader.
-			 *                     Check the Bootloader version again for more info about the Bootloader version.
-			 *
-			 *   - 0.5 (0x05-00) - The device is in the OTA-DFU Bootloader mode. The Bootloader supports LTK sharing and requires the Extended Init Packet. It supports
-			 *                     a SoftDevice, Bootloader or an Application update. SoftDevice and a Bootloader may be sent together.
-			 *
-			 *   - 0.6 (0x06-00) - The device is in the OTA-DFU Bootloader mode. The DFU Bootloader is from SDK 8.0 and has the same features as version 0.5. It also
-			 *                     supports also sending Service Changed notification in application mode after successful or aborted upload so no refreshing services is required.
-			 */
-            final BluetoothGattCharacteristic versionCharacteristic = dfuService.getCharacteristic(DFU_VERSION); // this may be null for older versions of the Bootloader
-
-            sendLogBroadcast(LOG_LEVEL_INFO, "Connected. Services discovered");
-            try {
-                updateProgressNotification(PROGRESS_STARTING);
-
-                // Read the version number if available. The version number consists of 2 bytes: major and minor. Therefore f.e. the version 5 (00-05) can be read as 0.5.
-                int version = 0;
-                if (versionCharacteristic != null) {
-                    version = readVersion(gatt, versionCharacteristic);
-                    final int minor = (version & 0x0F);
-                    final int major = (version >> 8);
-                    logi("Version number read: " + major + "." + minor);
-                    sendLogBroadcast(LOG_LEVEL_APPLICATION, "Version number read: " + major + "." + minor);
-                }
-
-				/*
-				 *  Check if we are in the DFU Bootloader or in the Application that supports the buttonless update.
-				 *
-				 *  In the DFU from SDK 6.1, which was also supporting the buttonless update, there was no DFU Version characteristic. In that case we may find out whether
-				 *  we are in the bootloader or application by simply checking the number of characteristics.
-				 */
-                if (version == 1 || (version == 0 && gatt.getServices().size() > 3 /* No DFU Version char but more services than Generic Access, Generic Attribute, DFU Service */)) {
-                    // The service is connected to the application, not to the bootloader
-                    logw("Application with buttonless update found");
-                    sendLogBroadcast(LOG_LEVEL_WARNING, "Application with buttonless update found");
-
-                    // If we are bonded we may want to enable Service Changed characteristic indications.
-                    // Note: This feature will be introduced in the SDK 8.0 as this is the proper way to refresh attribute list on the phone.
-                    boolean hasServiceChanged = false;
-                    if (gatt.getDevice().getBondState() == BluetoothDevice.BOND_BONDED) {
-                        final BluetoothGattService genericAttributeService = gatt.getService(GENERIC_ATTRIBUTE_SERVICE_UUID);
-                        if (genericAttributeService != null) {
-                            final BluetoothGattCharacteristic serviceChangedCharacteristic = genericAttributeService.getCharacteristic(SERVICE_CHANGED_UUID);
-                            if (serviceChangedCharacteristic != null) {
-                                // Let's read the current value of the Service Changed CCCD
-                                final boolean serviceChangedIndicationsEnabled = isServiceChangedCCCDEnabled(gatt, serviceChangedCharacteristic);
-
-                                if (!serviceChangedIndicationsEnabled) {
-                                    enableCCCD(gatt, serviceChangedCharacteristic, INDICATIONS);
-                                    sendLogBroadcast(LOG_LEVEL_APPLICATION, "Service Changed indications enabled");
-
-									/*
-									 * NOTE: The DFU Bootloader from SDK 8.0 (v0.6 and 0.5) has the following issue:
-									 *
-									 * When the central device (phone) connects to a bonded device (or connects and bonds) which supports the Service Changed characteristic,
-									 * but does not have the Service Changed indications enabled, the phone must enable them, disconnect and reconnect before starting the
-									 * DFU operation. This is because the current version of the Soft Device saves the ATT table on the DISCONNECTED event.
-									 * Sending the "jump to Bootloader" command (0x01-04) will cause the disconnect followed be a reset. The Soft Device does not
-									 * have time to store the ATT table on Flash memory before the reset.
-									 *
-									 * This applies only if:
-									 * - the device was bonded before an upgrade,
-									 * - the Application or the Bootloader is upgraded (upgrade of the Soft Device will erase the bond information anyway),
-									 *     - Application:
-									  *        if the DFU Bootloader has been modified and compiled to preserve the LTK and the ATT table after application upgrade (at least 2 pages)
-									 *         See: \Nordic\nrf51\components\libraries\bootloader_dfu\dfu_types.h, line 56:
-									 *          #define DFU_APP_DATA_RESERVED           0x0000  ->  0x0800+   //< Size of Application Data that must be preserved between application updates...
-									 *     - Bootloader:
-									 *         The Application memory should not be removed when the Bootloader is upgraded, so the Bootloader configuration does not matter.
-									 *
-									 * If the bond information is not to be preserved between the old and new applications, we may skip this disconnect/reconnect process.
-									 * The DFU Bootloader will send the SD indication anyway when we will just continue here, as the information whether it should send it or not it is not being
-									 * read from the application's ATT table, but rather passed as an argument of the "reboot to bootloader" method.
-									 */
-                                    final boolean keepBond = intent.getBooleanExtra(EXTRA_KEEP_BOND, false);
-                                    if (keepBond && (fileType & TYPE_SOFT_DEVICE) == 0) {
-                                        sendLogBroadcast(LOG_LEVEL_VERBOSE, "Restarting service...");
-
-                                        updateProgressNotification(PROGRESS_DISCONNECTING);
-                                        sendLogBroadcast(LOG_LEVEL_VERBOSE, "Disconnecting...");
-                                        gatt.disconnect();
-                                        waitUntilDisconnected();
-                                        sendLogBroadcast(LOG_LEVEL_INFO, "Disconnected");
-
-                                        // Close the device
-                                        close(gatt);
-                                        gatt = null;
-
-                                        logi("Restarting service");
-                                        final Intent newIntent = new Intent();
-                                        newIntent.fillIn(intent, Intent.FILL_IN_COMPONENT | Intent.FILL_IN_PACKAGE);
-                                        //startService(newIntent);
-                                        return newIntent;
-                                    }
-                                } else {
-                                    sendLogBroadcast(LOG_LEVEL_APPLICATION, "Service Changed indications enabled");
-                                }
-                                hasServiceChanged = true;
-                            }
-                        }
-                    }
-
-                    sendLogBroadcast(LOG_LEVEL_VERBOSE, "Jumping to the DFU Bootloader...");
-
-                    // Enable notifications
-                    enableCCCD(gatt, controlPointCharacteristic, NOTIFICATIONS);
-                    sendLogBroadcast(LOG_LEVEL_APPLICATION, "Notifications enabled");
-
-                    // Send 'jump to bootloader command' (Start DFU)
-                    updateProgressNotification(PROGRESS_ENABLING_DFU_MODE);
-                    OP_CODE_START_DFU[1] = 0x04;
-                    logi("Sending Start DFU command (Op Code = 1, Upload Mode = 4)");
-                    writeOpCode(gatt, controlPointCharacteristic, OP_CODE_START_DFU, true);
-                    sendLogBroadcast(LOG_LEVEL_APPLICATION, "Jump to bootloader sent (Op Code = 1, Upload Mode = 4)");
-
-                    // The device will reset so we don't have to send Disconnect signal.
-                    waitUntilDisconnected();
-                    sendLogBroadcast(LOG_LEVEL_INFO, "Disconnected by the remote device");
-
-					/*
-					 * We would like to avoid using the hack with refreshing the device (refresh method is not in the public API). The refresh method clears the cached services and causes a
-					 * service discovery afterwards (when connected). Android, however, does it itself when receive the Service Changed indication when bonded.
-					 * In case of unpaired device we may either refresh the services manually (usinrefreshDeviceCacheg the hack), or include the Service Changed characteristic.
-					 *
-					 * According to Bluetooth Core 4.0 (and 4.1) specification:
-					 *
-					 * [Vol. 3, Part G, 2.5.2 - Attribute Caching]
-					 * Note: Clients without a trusted relationship must perform service discovery on each connection if the server supports the Services Changed characteristic.
-					 *
-					 * However, as up to Android 5 the system does NOT respect this requirement and servers are cached for every device, even if Service Changed is enabled -> Android BUG?
-					 * For bonded devices Android performs service re-discovery when SC indication is received.
-					 */
-                    refreshDeviceCache(gatt, !hasServiceChanged);
-
-                    // Close the device
-                    close(gatt);
-                    gatt = null;
-
-                    logi("Starting service that will connect to the DFU bootloader");
-                    final Intent newIntent = new Intent();
-                    newIntent.fillIn(intent, Intent.FILL_IN_COMPONENT | Intent.FILL_IN_PACKAGE);
-                    startService(newIntent);
-                    return newIntent;
-                }
-
-                // Enable notifications
-                enableCCCD(gatt, controlPointCharacteristic, NOTIFICATIONS);
-                sendLogBroadcast(LOG_LEVEL_APPLICATION, "Notifications enabled");
-
-                try {
-                    // Set up the temporary variable that will hold the responses
-                    byte[] response;
-                    int status;
-
-					/*
-					 * The first version of DFU supported only an Application update.
-					 * Initializing procedure:
-					 * [DFU Start (0x01)] -> DFU Control Point
-					 * [App size in bytes (UINT32)] -> DFU Packet
-					 * ---------------------------------------------------------------------
-					 * Since SDK 6.0 and Soft Device 7.0+ the DFU supports upgrading Soft Device, Bootloader and Application.
-					 * Initializing procedure:
-					 * [DFU Start (0x01), <Update Mode>] -> DFU Control Point
-					 * [SD size in bytes (UINT32), Bootloader size in bytes (UINT32), Application size in bytes (UINT32)] -> DFU Packet
-					 * where <Upload Mode> is a bit mask:
-					 * 0x01 - Soft Device update
-					 * 0x02 - Bootloader update
-					 * 0x04 - Application update
-					 * so that
-					 * 0x03 - Soft Device and Bootloader update
-					 * If <Upload Mode> equals 5, 6 or 7 DFU target may return OPERATION_NOT_SUPPORTED [10, 01, 03]. In that case service will try to send
-					 * Soft Device and/or Bootloader first, reconnect to the new Bootloader and send the Application in the second connection.
-					 * --------------------------------------------------------------------
-					 * If DFU target supports only the old DFU, a response [10, 01, 03] will be send as a notification on DFU Control Point characteristic, where:
-					 * 10 - Response for...
-					 * 01 - DFU Start command
-					 * 03 - Operation Not Supported
-					 * (see table below)
-					 * In that case:
-					 * 1. If this is application update - service will try to upload using the old DFU protocol.
-					 * 2. In case of SD or BL update an error is returned.
-					 */
-
-                    // Obtain size of image(s)
-                    int softDeviceImageSize = (fileType & TYPE_SOFT_DEVICE) > 0 ? imageSizeInBytes : 0;
-                    int bootloaderImageSize = (fileType & TYPE_BOOTLOADER) > 0 ? imageSizeInBytes : 0;
-                    int appImageSize = (fileType & TYPE_APPLICATION) > 0 ? imageSizeInBytes : 0;
-                    // The sizes above may be overwritten if a ZIP file was passed
-                    if (MIME_TYPE_ZIP.equals(mimeType)) {
-                        final ArchiveInputStream zhis = (ArchiveInputStream) is;
-                        softDeviceImageSize = zhis.softDeviceImageSize();
-                        bootloaderImageSize = zhis.bootloaderImageSize();
-                        appImageSize = zhis.applicationImageSize();
-                    }
-
-                    try {
-                        OP_CODE_START_DFU[1] = (byte) fileType;
-
-                        // Send Start DFU command to Control Point
-                        logi("Sending Start DFU command (Op Code = 1, Upload Mode = " + fileType + ")");
-                        writeOpCode(gatt, controlPointCharacteristic, OP_CODE_START_DFU);
-                        sendLogBroadcast(LOG_LEVEL_APPLICATION, "DFU Start sent (Op Code = 1, Upload Mode = " + fileType + ")");
-
-                        // Send image size in bytes to DFU Packet
-                        logi("Sending image size array to DFU Packet (" + softDeviceImageSize + "b, " + bootloaderImageSize + "b, " + appImageSize + "b)");
-                        writeImageSize(gatt, packetCharacteristic, softDeviceImageSize, bootloaderImageSize, appImageSize);
-                        sendLogBroadcast(LOG_LEVEL_APPLICATION, "Firmware image size sent (" + softDeviceImageSize + "b, " + bootloaderImageSize + "b, " + appImageSize + "b)");
-                        sendStatsBinFileSize(appImageSize);
-
-                        // A notification will come with confirmation. Let's wait for it a bit
-                        response = readNotificationResponse();
-
-						/*
-						 * The response received from the DFU device contains:
-						 * +---------+--------+----------------------------------------------------+
-						 * | byte no | value  | description                                        |
-						 * +---------+--------+----------------------------------------------------+
-						 * | 0       | 16     | Response code                                      |
-						 * | 1       | 1      | The Op Code of a request that this response is for |
-						 * | 2       | STATUS | See DFU_STATUS_* for status codes                  |
-						 * +---------+--------+----------------------------------------------------+
-						 */
-                        status = getStatusCode(response, OP_CODE_START_DFU_KEY);
-                        sendLogBroadcast(LOG_LEVEL_APPLICATION, "Response received (Op Code = " + response[1] + " Status = " + status + ")");
-                        if (status != DFU_STATUS_SUCCESS)
-                            throw new RemoteDfuException("Starting DFU failed", status);
-                    } catch (final RemoteDfuException e) {
-                        try {
-                            Log.e(TAG, e.toString());
-
-                            if (e.getErrorNumber() != DFU_STATUS_NOT_SUPPORTED)
-                                throw e;
-
-                            // If user wants to send the Soft Device and/or the Bootloader + Application we may try to send the Soft Device/Bootloader files first,
-                            // and then reconnect and send the application in the second connection.
-                            if ((fileType & TYPE_APPLICATION) > 0 && (fileType & (TYPE_SOFT_DEVICE | TYPE_BOOTLOADER)) > 0) {
-                                // Clear the remote error flag
-                                mRemoteErrorOccurred = false;
-
-                                logw("DFU target does not support (SD/BL)+App update");
-                                sendLogBroadcast(LOG_LEVEL_WARNING, "DFU target does not support (SD/BL)+App update");
-
-                                fileType &= ~TYPE_APPLICATION; // clear application bit
-                                mFileType = fileType;
-                                OP_CODE_START_DFU[1] = (byte) fileType;
-                                mPartsTotal = 2;
-
-                                // Set new content type in the ZIP Input Stream and update sizes of images
-                                final ArchiveInputStream zhis = (ArchiveInputStream) is;
-                                zhis.setContentType(fileType);
-                                try {
-                                    appImageSize = 0;
-                                    mImageSizeInBytes = is.available();
-                                } catch (final IOException e1) {
-                                    Log.e(TAG, e.toString());
-                                    // never happen
-                                }
-
-                                // Send Start DFU command to Control Point
-                                sendLogBroadcast(LOG_LEVEL_VERBOSE, "Sending only SD/BL");
-                                logi("Resending Start DFU command (Op Code = 1, Upload Mode = " + fileType + ")");
-                                writeOpCode(gatt, controlPointCharacteristic, OP_CODE_START_DFU);
-                                sendLogBroadcast(LOG_LEVEL_APPLICATION, "DFU Start sent (Op Code = 1, Upload Mode = " + fileType + ")");
-
-                                // Send image size in bytes to DFU Packet
-                                logi("Sending image size array to DFU Packet: [" + softDeviceImageSize + "b, " + bootloaderImageSize + "b, " + appImageSize + "b]");
-                                writeImageSize(gatt, packetCharacteristic, softDeviceImageSize, bootloaderImageSize, appImageSize);
-                                sendLogBroadcast(LOG_LEVEL_APPLICATION, "Firmware image size sent [" + softDeviceImageSize + "b, " + bootloaderImageSize + "b, " + appImageSize + "b]");
-                                sendStatsBinFileSize(appImageSize);
-
-                                // A notification will come with confirmation. Let's wait for it a bit
-                                response = readNotificationResponse();
-                                status = getStatusCode(response, OP_CODE_START_DFU_KEY);
-                                sendLogBroadcast(LOG_LEVEL_APPLICATION, "Response received (Op Code = " + response[1] + " Status = " + status + ")");
-                                if (status != DFU_STATUS_SUCCESS)
-                                    throw new RemoteDfuException("Starting DFU failed", status);
-                            } else
-                                throw e;
-                        } catch (final RemoteDfuException e1) {
-                            Log.e(TAG, e1.toString());
-
-                            if (e1.getErrorNumber() != DFU_STATUS_NOT_SUPPORTED)
-                                throw e1;
-
-                            // If operation is not supported by DFU target we may try to upload application with legacy mode, using the old DFU protocol
-                            if (fileType == TYPE_APPLICATION) {
-                                // Clear the remote error flag
-                                mRemoteErrorOccurred = false;
-
-                                // The DFU target does not support DFU v.2 protocol
-                                logw("DFU target does not support DFU v.2");
-                                sendLogBroadcast(LOG_LEVEL_WARNING, "DFU target does not support DFU v.2");
-
-                                // Send Start DFU command to Control Point
-                                sendLogBroadcast(LOG_LEVEL_VERBOSE, "Switching to DFU v.1");
-                                logi("Resending Start DFU command (Op Code = 1)");
-                                writeOpCode(gatt, controlPointCharacteristic, OP_CODE_START_DFU); // If has 2 bytes, but the second one is ignored
-                                sendLogBroadcast(LOG_LEVEL_APPLICATION, "DFU Start sent (Op Code = 1)");
-
-                                // Send image size in bytes to DFU Packet
-                                logi("Sending application image size to DFU Packet: " + imageSizeInBytes + " bytes");
-                                writeImageSize(gatt, packetCharacteristic, mImageSizeInBytes);
-                                sendLogBroadcast(LOG_LEVEL_APPLICATION, "Firmware image size sent (" + imageSizeInBytes + " bytes)");
-                                sendStatsBinFileSize(imageSizeInBytes);
-
-                                // A notification will come with confirmation. Let's wait for it a bit
-                                response = readNotificationResponse();
-                                status = getStatusCode(response, OP_CODE_START_DFU_KEY);
-                                sendLogBroadcast(LOG_LEVEL_APPLICATION, "Response received (Op Code = " + response[1] + ", Status = " + status + ")");
-                                if (status != DFU_STATUS_SUCCESS)
-                                    throw new RemoteDfuException("Starting DFU failed", status);
-                            } else
-                                throw e1;
-                        }
-                    }
-
-                    // Since SDK 6.1 this delay is no longer required as the Receive Start DFU notification is postponed until the memory is clear.
-
-                    //		if ((fileType & TYPE_SOFT_DEVICE) > 0) {
-                    //			// In the experimental version of bootloader (SDK 6.0.0) we must wait some time until we can proceed with Soft Device update. Bootloader must prepare the RAM for the new firmware.
-                    //			// Most likely this step will not be needed in the future as the notification received a moment before will be postponed until Bootloader is ready.
-                    //			synchronized (this) {
-                    //				try {
-                    //					wait(6000);
-                    //				} catch (final InterruptedException e) {
-                    //					// do nothing
-                    //				}
-                    //			}
-                    //		}
-
-					/*
-					 * If the DFU Version characteristic is present and the version returned from it is greater or equal to 0.5, the Extended Init Packet is required.
-					 * For older versions, or if the DFU Version characteristic is not present (pre SDK 7.0.0), the Init Packet (which could have contained only the firmware CRC) was optional.
-					 * To calculate the CRC (CRC-CCTII-16 0xFFFF) the following application may be used: http://www.lammertbies.nl/comm/software/index.html -> CRC library.
-					 *
-					 * The Init Packet is read from the *.dat file as a binary file. This service you allows to specify the init packet file in two ways.
-					 * Since SDK 8.0 and the DFU Library v0.6 using the Distribution packet (ZIP) is recommended. The distribution packet can be created using the
-					 * *nrf utility* tool, available together with Master Control Panel v 3.8.0. See the DFU documentation at http://developer.nordicsemi.com for more details.
-					 * An init file may be also provided as a separate file using the {@link #EXTRA_INIT_FILE_PATH} or {@link #EXTRA_INIT_FILE_URI} or in the ZIP file
-					 * with the deprecated fixed naming convention:
-					 *
-					 *    a) If the ZIP file contain a softdevice.hex (or .bin) and/or bootloader.hex (or .bin) the 'system.dat' must also be included.
-					 *       In case when both files are present the CRC should be calculated from the two BIN contents merged together.
-					 *       This means: if there are softdevice.hex and bootloader.hex files in the ZIP file you have to convert them to BIN
-					 *       (e.g. using: http://hex2bin.sourceforge.net/ application), copy them into a single file where the soft device is placed as the first one and calculate
-					 *       the CRC for the whole file.
-					 *
-					 *    b) If the ZIP file contains a application.hex (or .bin) file the 'application.dat' file must be included and contain the Init packet for the application.
-					 */
-                    // Send DFU Init Packet
-                    if (initIs != null) {
-                        sendLogBroadcast(LOG_LEVEL_APPLICATION, "Writing Initialize DFU Parameters...");
-
-                        logi("Sending the Initialize DFU Parameters START (Op Code = 2, Value = 0)");
-                        writeOpCode(gatt, controlPointCharacteristic, OP_CODE_INIT_DFU_PARAMS_START);
-
-                        try {
-                            byte[] data = new byte[20];
-                            int size;
-                            while ((size = initIs.read(data, 0, data.length)) != -1) {
-                                writeInitPacket(gatt, packetCharacteristic, data, size);
-                            }
-                        } catch (final IOException e) {
-                            loge("Error while reading Init packet file");
-                            throw new DfuException("Error while reading Init packet file", ERROR_FILE_ERROR);
-                        }
-
-                        logi("Sending the Initialize DFU Parameters COMPLETE (Op Code = 2, Value = 1)");
-                        writeOpCode(gatt, controlPointCharacteristic, OP_CODE_INIT_DFU_PARAMS_COMPLETE);
-                        sendLogBroadcast(LOG_LEVEL_APPLICATION, "Initialize DFU Parameters completed");
-
-                        // A notification will come with confirmation. Let's wait for it a bit
-                        response = readNotificationResponse();
-                        status = getStatusCode(response, OP_CODE_INIT_DFU_PARAMS_KEY);
-                        sendLogBroadcast(LOG_LEVEL_APPLICATION, "Response received (Op Code = " + response[1] + ", Status = " + status + ")");
-                        if (status != DFU_STATUS_SUCCESS)
-                            throw new RemoteDfuException("Device returned error after sending init packet", status);
-                    } else
-                        mInitPacketSent = true;
-
-                    // Send the number of packets of firmware before receiving a receipt notification
-                    final int numberOfPacketsBeforeNotification = mPacketsBeforeNotification;
-                    if (numberOfPacketsBeforeNotification > 0) {
-                        logi("Sending the number of packets before notifications (Op Code = 8, Value = " + numberOfPacketsBeforeNotification + ")");
-                        setNumberOfPackets(OP_CODE_PACKET_RECEIPT_NOTIF_REQ, numberOfPacketsBeforeNotification);
-                        writeOpCode(gatt, controlPointCharacteristic, OP_CODE_PACKET_RECEIPT_NOTIF_REQ);
-                        sendLogBroadcast(LOG_LEVEL_APPLICATION, "Packet Receipt Notif Req (Op Code = 8) sent (Value = " + numberOfPacketsBeforeNotification + ")");
-                    }
-
-                    // Initialize firmware upload
-                    logi("Sending Receive Firmware Image request (Op Code = 3)");
-                    writeOpCode(gatt, controlPointCharacteristic, OP_CODE_RECEIVE_FIRMWARE_IMAGE);
-                    sendLogBroadcast(LOG_LEVEL_APPLICATION, "Receive Firmware Image request sent");
-
-                    // Send the firmware. The method below sends the first packet and waits until the whole firmware is sent.
-                    final long startTime = mLastProgressTime = mStartTime = SystemClock.elapsedRealtime();
-                    updateProgressNotification();
-                    try {
-                        logi("Uploading firmware...");
-                        sendLogBroadcast(LOG_LEVEL_APPLICATION, "Uploading firmware...");
-                        response = uploadFirmwareImage(gatt, packetCharacteristic, is);
-                    } catch (final DeviceDisconnectedException e) {
-                        loge("Disconnected while sending data");
-                        throw e;
-                        // TODO reconnect?
-                    }
-
-                    final long endTime = SystemClock.elapsedRealtime();
-
-                    // Check the result of the operation
-                    status = getStatusCode(response, OP_CODE_RECEIVE_FIRMWARE_IMAGE_KEY);
-                    logi("Response received. Op Code: " + response[0] + " Req Op Code = " + response[1] + ", Status = " + response[2]);
-                    sendLogBroadcast(LOG_LEVEL_APPLICATION, "Response received (Op Code = " + response[1] + ", Status = " + status + ")");
-                    if (status != DFU_STATUS_SUCCESS)
-                        throw new RemoteDfuException("Device returned error after sending file", status);
-
-                    logi("Transfer of " + mBytesSent + " bytes has taken " + (endTime - startTime) + " ms");
-                    sendLogBroadcast(LOG_LEVEL_APPLICATION, "Upload completed in " + (endTime - startTime) + " ms");
-
-                    // Send Validate request
-                    logi("Sending Validate request (Op Code = 4)");
-                    writeOpCode(gatt, controlPointCharacteristic, OP_CODE_VALIDATE);
-                    sendLogBroadcast(LOG_LEVEL_APPLICATION, "Validate request sent");
-
-                    // A notification will come with status code. Let's wait for it a bit.
-                    response = readNotificationResponse();
-                    status = getStatusCode(response, OP_CODE_VALIDATE_KEY);
-                    logi("Response received. Op Code: " + response[0] + " Req Op Code = " + response[1] + ", Status = " + response[2]);
-                    sendLogBroadcast(LOG_LEVEL_APPLICATION, "Response received (Op Code = " + response[1] + ", Status = " + status + ")");
-                    if (status != DFU_STATUS_SUCCESS)
-                        throw new RemoteDfuException("Device returned validation error", status);
-
-                    // Send Activate and Reset signal.
-                    updateProgressNotification(PROGRESS_DISCONNECTING);
-                    logi("Sending Activate and Reset request (Op Code = 5)");
-                    writeOpCode(gatt, controlPointCharacteristic, OP_CODE_ACTIVATE_AND_RESET);
-                    sendLogBroadcast(LOG_LEVEL_APPLICATION, "Activate and Reset request sent");
-
-                    // The device will reset so we don't have to send Disconnect signal.
-                    waitUntilDisconnected();
-                    sendLogBroadcast(LOG_LEVEL_INFO, "Disconnected by the remote device");
-
-                    // In the DFU version 0.5, in case the device is bonded, the target device does not send the Service Changed indication after
-                    // a jump from bootloader mode to app mode. This issue has been fixed in DFU version 0.6 (SDK 8.0). If the DFU bootloader has been
-                    // configured to preserve the bond information we do not need to enforce refreshing services, as it will notify the phone using the
-                    // Service Changed indication.
-                    final boolean keepBond = intent.getBooleanExtra(EXTRA_KEEP_BOND, false);
-                    refreshDeviceCache(gatt, version == 5 || !keepBond);
-
-                    // Close the device
-                    close(gatt);
-
-                    // During the update the bonding information on the target device may have been removed.
-                    // To create bond with the new application set the EXTRA_RESTORE_BOND extra to true.
-                    // In case the bond information is copied to the new application the new bonding is not required.
-					/*if (gatt.getDevice().getBondState() == BluetoothDevice.BOND_BONDED) {
-						final boolean restoreBond = intent.getBooleanExtra(EXTRA_RESTORE_BOND, false);
-
-						if (restoreBond || !keepBond || (fileType & TYPE_SOFT_DEVICE) > 0) {
-							// The bond information was lost.
-							removeBond(gatt.getDevice());
-
-							// Give some time for removing the bond information. 300ms was to short, let's set it to 2 seconds just to be sure.
-							synchronized (this) {
-								try {
-									wait(2000);
-								} catch (InterruptedException e) {
-									// do nothing
-								}
-							}
-						}
-
-						if (restoreBond && (fileType & TYPE_APPLICATION) > 0) {
-							// Restore pairing when application was updated.
-							createBond(gatt.getDevice());
-						}
-					}*/
-
-					/*
-					 * We need to send PROGRESS_COMPLETED message only when all files has been transmitted.
-					 * In case you want to send the Soft Device and/or Bootloader and the Application, the service will be started twice: one to send SD+BL, and the
-					 * second time to send the Application only (using the new Bootloader). In the first case we do not send PROGRESS_COMPLETED notification.
-					 */
-                    if (mPartCurrent == mPartsTotal) {
-                        // Delay this event a little bit. Android needs some time to prepare for reconnection.
-                        synchronized (mLock) {
-                            try {
-                                mLock.wait(1400);
-                            } catch (final InterruptedException e) {
-                                Log.e(TAG, e.toString());
-                                // do nothing
-                            }
-                        }
-
-                        updateProgressNotification(PROGRESS_COMPLETED);
-                        logi("phase 3 complete");
-                        return null;
-                    } else {
-						/*
-						 * The current service handle will try to upload Soft Device and/or Bootloader.
-						 * We need to enqueue another Intent that will try to send application only.
-						 */
-                        logi("Starting service that will upload application");
-                        final Intent newIntent = new Intent();
-                        newIntent.fillIn(intent, Intent.FILL_IN_COMPONENT | Intent.FILL_IN_PACKAGE);
-                        newIntent.putExtra(EXTRA_FILE_MIME_TYPE, MIME_TYPE_ZIP); // ensure this is set (f.e. for scripts)
-                        newIntent.putExtra(EXTRA_FILE_TYPE, TYPE_APPLICATION); // set the type to application only
-                        newIntent.putExtra(EXTRA_PART_CURRENT, mPartCurrent + 1);
-                        newIntent.putExtra(EXTRA_PARTS_TOTAL, mPartsTotal);
-                        //startService(newIntent);
-
-                        close(gatt);
-                        gatt = null;
-                        return newIntent;
-                    }
-                } catch (final UnknownResponseException e) {
-                    final int error = ERROR_INVALID_RESPONSE;
-                    loge(e.getMessage());
-                    sendLogBroadcast(LOG_LEVEL_ERROR, e.getMessage());
-
-                    logi("Sending Reset command (Op Code = 6)");
-                    writeOpCode(gatt, controlPointCharacteristic, OP_CODE_RESET);
-                    sendLogBroadcast(LOG_LEVEL_APPLICATION, "Reset request sent");
-                    terminateConnection(gatt, error);
-                } catch (final RemoteDfuException e) {
-                    final int error = ERROR_REMOTE_MASK | e.getErrorNumber();
-                    loge(e.getMessage());
-                    sendLogBroadcast(LOG_LEVEL_ERROR, String.format("Remote DFU error: %s", GattError.parse(error)));
-
-                    logi("Sending Reset command (Op Code = 6)");
-                    writeOpCode(gatt, controlPointCharacteristic, OP_CODE_RESET);
-                    sendLogBroadcast(LOG_LEVEL_APPLICATION, "Reset request sent");
-                    terminateConnection(gatt, error);
-                }
-            } catch (final UploadAbortedException e) {
-                logi("Upload aborted");
-                sendLogBroadcast(LOG_LEVEL_WARNING, "Upload aborted");
-                if (mConnectionState == STATE_CONNECTED_AND_READY)
-                    try {
-                        mAborted = false;
-                        logi("Sending Reset command (Op Code = 6)");
-                        writeOpCode(gatt, controlPointCharacteristic, OP_CODE_RESET);
-                        sendLogBroadcast(LOG_LEVEL_APPLICATION, "Reset request sent");
-                    } catch (final Exception e1) {
-                        Log.e(TAG, e1.toString());
-                        // do nothing
-                    }
-
-                terminateConnection(gatt, PROGRESS_ABORTED);
-            } catch (final DeviceDisconnectedException e) {
-                sendLogBroadcast(LOG_LEVEL_ERROR, "Device has disconnected");
-                // TODO reconnect n times?
-                loge(e.getMessage());
-                close(gatt);
-                updateProgressNotification(ERROR_DEVICE_DISCONNECTED);
-            } catch (final DfuException e) {
-                int error = e.getErrorNumber();
-                // Connection state errors and other Bluetooth GATT callbacks share the same error numbers. Therefore we are using bit masks to identify the type.
-                if ((error & ERROR_CONNECTION_STATE_MASK) > 0) {
-                    error &= ~ERROR_CONNECTION_STATE_MASK;
-                    sendLogBroadcast(LOG_LEVEL_ERROR, String.format("Error (0x%02X): %s", error, GattError.parseConnectionError(error)));
-                } else {
-                    error &= ~ERROR_CONNECTION_MASK;
-                    sendLogBroadcast(LOG_LEVEL_ERROR, String.format("Error (0x%02X): %s", error, GattError.parse(error)));
-                }
-
-                loge(e.getMessage());
-                if (mConnectionState == STATE_CONNECTED_AND_READY)
-                    try {
-                        logi("Sending Reset command (Op Code = 6)");
-                        writeOpCode(gatt, controlPointCharacteristic, OP_CODE_RESET);
-                        sendLogBroadcast(LOG_LEVEL_APPLICATION, "Reset request sent");
-                    } catch (final Exception e1) {
-                        Log.e(TAG, e1.toString());
-                        // do nothing
-                    }
-
-                terminateConnection(gatt, e.getErrorNumber() /* we return the whole error number, including the error type mask */);
-            }
-        } finally {
-            try {
-                // Ensure that input stream is always closed
-                mInputStream = null;
-                if (is != null)
-                    is.close();
-
-            } catch (final IOException e) {
-                Log.e(TAG, e.toString());
-                // do nothing
-            }
-        }
-
-        return null;
-    }
-
-    /**
-     * Sets number of data packets that will be send before the notification will be received.
-     *
-     * @param data  control point data packet
-     * @param value number of packets before receiving notification. If this value is 0, then the notification of packet receipt will be disabled by the DFU target.
-     */
-    private void setNumberOfPackets(final byte[] data, final int value) {
-        data[1] = (byte) (value & 0xFF);
-        data[2] = (byte) ((value >> 8) & 0xFF);
-    }
-
-    /**
-     * Opens the binary input stream that returns the firmware image content. A Path to the file is given.
-     *
-     * @param filePath the path to the HEX or BIN file
-     * @param mimeType the file type
-     * @param mbrSize  the size of MBR, by default 0x1000
-     * @param types    the content files types in ZIP
-     * @return the input stream with binary image content
-     */
-    private InputStream openInputStream(final String filePath, final String mimeType, final int mbrSize, final int types) throws IOException {
-        final InputStream is = new FileInputStream(filePath);
-        if (MIME_TYPE_ZIP.equals(mimeType))
-            return new ArchiveInputStream(is, mbrSize, types);
-
-        if (filePath.toLowerCase(Locale.US).endsWith("hex")) {
-            //return new HexInputStream(is, mbrSize);
-            return new HexInputStream(is);
-        }
-
-        return is;
-    }
-
-    /**
-     * Opens the binary input stream. A Uri to the stream is given.
-     *
-     * @param stream   the Uri to the stream
-     * @param mimeType the file type
-     * @param mbrSize  the size of MBR, by default 0x1000
-     * @param types    the content files types in ZIP
-     * @return the input stream with binary image content
-     */
-    private InputStream openInputStream(final Uri stream, final String mimeType, final int mbrSize, final int types) throws IOException {
-        final InputStream is = getContentResolver().openInputStream(stream);
-        if (MIME_TYPE_ZIP.equals(mimeType))
-            return new ArchiveInputStream(is, mbrSize, types);
-
-        final String[] projection = {MediaStore.Images.Media.DISPLAY_NAME};
-        final Cursor cursor = getContentResolver().query(stream, projection, null, null, null);
-        try {
-            if (cursor.moveToNext()) {
-                final String fileName = cursor.getString(0 /* DISPLAY_NAME*/);
-
-                if (fileName.toLowerCase(Locale.US).endsWith("hex")) {
-                    //return new HexInputStream(is, mbrSize);
-                    return new HexInputStream(is);
-                }
-            }
-        } finally {
-            cursor.close();
-        }
-
-        return is;
-    }
-
-    /**
-     * Connects to the BLE device with given address. This method is SYNCHRONOUS, it wait until the connection status change from {@link #STATE_CONNECTING} to {@link #STATE_CONNECTED_AND_READY} or an
-     * error occurs. This method returns <code>null</code> if Bluetooth adapter is disabled.
-     *
-     * @param address the device address
-     * @return the GATT device or <code>null</code> if Bluetooth adapter is disabled.
-     */
-    private BluetoothGatt connect(final String address) {
-        if (!mBluetoothAdapter.isEnabled())
-            return null;
-
-        logi("Connecting to the device...");
-        if (device == null) {
-            device = mBluetoothAdapter.getRemoteDevice(address);
-        }
-
-        gatt = device.connectGatt(this, false, mGattCallback);
-
-        // We have to wait until the device is connected and services are discovered
-        // Connection error may occur as well.
-        try {
-            mConnectionState = STATE_CONNECTING;
-            synchronized (mLock) {
-                while (((mConnectionState == STATE_CONNECTING || mConnectionState == STATE_CONNECTED) && mError == 0 && !mAborted) || mPaused)
-                    mLock.wait();
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-
-        return gatt;
-    }
-
-    private void cancelPairing(final BluetoothGatt gatt) {
-        logi("----> cancelPairing");
-        if (mConnectionState != STATE_DISCONNECTED) {
-            // Disconnect from the device
-            mConnectionState = STATE_DISCONNECTED;
-            logi("Disconnecting from the device...");
-            gatt.disconnect();
-            sendLogBroadcast(LOG_LEVEL_INFO, "Disconnected");
-        }
-        // Close the device
-        refreshDeviceCache(gatt, false); // This should be set to true when DFU Version is 0.5 or lower
-        close(gatt);
-    }
-
-    /**
-     * Disconnects from the device and cleans local variables in case of error. This method is SYNCHRONOUS and wait until the disconnecting process will be completed.
-     *
-     * @param gatt  the GATT device to be disconnected
-     * @param error error number
-     */
-    private void terminateConnection(final BluetoothGatt gatt, final int error) {
-        if (mConnectionState != STATE_DISCONNECTED) {
-            updateProgressNotification(PROGRESS_DISCONNECTING);
-            // Disconnect from the device
-            disconnect(gatt);
-            sendLogBroadcast(LOG_LEVEL_INFO, "Disconnected");
-        }
-        // Close the device
-        refreshDeviceCache(gatt, false); // This should be set to true when DFU Version is 0.5 or lower
-        close(gatt);
-        updateProgressNotification(error);
-    }
-
-    /**
-     * Disconnects from the device. This is SYNCHRONOUS method and waits until the callback returns new state. Terminates immediately if device is already disconnected. Do not call this method
-     * directly, use {@link #terminateConnection(android.bluetooth.BluetoothGatt, int)} instead.
-     *
-     * @param gatt the GATT device that has to be disconnected
-     */
-    private void disconnect(final BluetoothGatt gatt) {
-        if (mConnectionState == STATE_DISCONNECTED)
-            return;
-
-        mConnectionState = STATE_DISCONNECTING;
-        logi("Disconnecting from the device...");
-        gatt.disconnect();
-
-        // We have to wait until device gets disconnected or an error occur
-        waitUntilDisconnected();
-    }
-
-    private void waitUntilDisconnectedTimed() {
-        logi("waitUntilDisconnectedTimed");
-        try {
-            synchronized (mLock) {
-                if (mConnectionState != STATE_DISCONNECTED && mError == 0) {
-                    logi("waitUntilDisconnectedTimed : waiting");
-                    mLock.wait(DfuSettingsConstants.TIME_TO_WAIT_IN_MILLISECONDS);
-                    logi("waitUntilDisconnectedTimed : wait done");
-                }
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-    }
-
-    /**
-     * Wait until the connection state will change to {@link #STATE_DISCONNECTED} or until an error occurs.
-     */
-    private void waitUntilDisconnected() {
-        logi("waitUntilDisconnected");
-        try {
-            synchronized (mLock) {
-                while ((mConnectionState != STATE_DISCONNECTED) && (mConnectionState != STATE_CLOSED) && mError == 0) {
-                    logi("waitUntilDisconnected : waiting");
-                    mLock.wait();
-                    logi("waitUntilDisconnected : wait done");
-                }
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-    }
-
-    private void waitUntilConnected() {
-        logi("waitUntilConnected");
-        try {
-            synchronized (mLock) {
-                if (mConnectionState != STATE_CONNECTED && mError == 0) {
-                    logi("waitUntilConnected : waiting");
-                    mLock.wait();
-                    logi("waitUntilConnected : wait:done");
-                }
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-    }
-
-    private void waitUntilConnected(long timeout) {
-        logi("waitUntilConnected");
-        try {
-            synchronized (mLock) {
-                if (mConnectionState != STATE_CONNECTED && mError == 0) {
-                    logi("waitUntilConnected : waiting");
-                    mLock.wait(timeout);
-                    logi("waitUntilConnected : wait:done");
-                }
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-    }
-
-    private void gattConnect(final BluetoothGatt gatt) {
-        try {
-            if (gatt.connect()) {
-                synchronized (mLock) {
-                    while (mConnectionState != STATE_CONNECTED_AND_READY && mError == 0) {
-                        mLock.wait(30 * 1000); //Wait only 30 seconds. TODO Check this again
-                    }
-                }
-            }
-        } catch (final InterruptedException e) {
-            e.printStackTrace();
-            loge("Sleeping interrupted", e);
-        }
-
-    }
-
-    /**
-     * Closes the GATT device and cleans up.
-     *
-     * @param gatt the GATT device to be closed
-     */
-    private void close(final BluetoothGatt gatt) {
-        logi("Cleaning up...");
-        sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.close()");
-        gatt.disconnect();
-        gatt.close();
-        mConnectionState = STATE_CLOSED;
-    }
-
-    /**
-     * Clears the device cache. After uploading new firmware the DFU target will have other services than before.
-     *
-     * @param gatt  the GATT device to be refreshed
-     * @param force <code>true</code> to force the refresh
-     */
-    private void refreshDeviceCache(final BluetoothGatt gatt, final boolean force) {
-		/*
-		 * If the device is bonded this is up to the Service Changed characteristic to notify Android that the services has changed.
-		 * There is no need for this trick in that case.
-		 * If not bonded, the Android should not keep the services cached when the Service Changed characteristic is present in the target device database.
-		 * However, due to the Android bug (still exists in Android 5.0.1), it is keeping them anyway and the only way to clear services is by using this hidden refresh method.
-		 */
-        if (force || gatt.getDevice().getBondState() == BluetoothDevice.BOND_NONE) {
-            sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.refresh()");
-			/*
-			 * There is a refresh() method in BluetoothGatt class but for now it's hidden. We will call it using reflections.
-			 */
-            try {
-                final Method refresh = gatt.getClass().getMethod("refresh");
-                if (refresh != null) {
-                    final boolean success = (Boolean) refresh.invoke(gatt);
-                    logi("Refreshing result: " + success);
-                }
-            } catch (Exception e) {
-                loge("An exception occurred while refreshing device", e);
-                sendLogBroadcast(LOG_LEVEL_WARNING, "Refreshing failed");
-            }
-        }
-    }
-
-    /**
-     * Checks whether the response received is valid and returns the status code.
-     *
-     * @param response the response received from the DFU device.
-     * @param request  the expected Op Code
-     * @return the status code
-     * @throws UnknownResponseException if response was not valid
-     */
-    private int getStatusCode(final byte[] response, final int request) throws UnknownResponseException {
-        if (response == null || response.length != 3 || response[0] != OP_CODE_RESPONSE_CODE_KEY || response[1] != request || response[2] < 1 || response[2] > 6)
-            throw new UnknownResponseException("Invalid response received", response, request);
-        return response[2];
-    }
-
-    private String readCharacteristicNoFailure(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic) {
-        if (mConnectionState != STATE_CONNECTED_AND_READY)
-            return "not_ready";
-        if (characteristic == null)
-            return "unknown";
-        logi("readCharacteristicNoFailure");
-        gatt.readCharacteristic(characteristic);
-        try {
-            synchronized (mLock) {
-                while ((!mRequestCompleted && mConnectionState == STATE_CONNECTED_AND_READY && mError == 0 && !mAborted) || mPaused)
-                    mLock.wait();
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-
-        if (mAborted)
-            return "unknown";
-
-        if (mError != 0)
-            return "unknown";
-
-        if (mConnectionState != STATE_CONNECTED_AND_READY)
-            return "unknown";
-        return characteristic.getStringValue(0);
-    }
-
-    /**
-     * Reads the DFU Version characteristic if such exists. Otherwise it returns 0.
-     *
-     * @param gatt           the GATT device
-     * @param characteristic the characteristic to read
-     * @return a version number or 0 if not present on the bootloader
-     * @throws DeviceDisconnectedException
-     * @throws DfuException
-     * @throws UploadAbortedException
-     */
-    private int readVersion(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic) throws DeviceDisconnectedException, DfuException, UploadAbortedException {
-        if (mConnectionState != STATE_CONNECTED_AND_READY)
-            throw new DeviceDisconnectedException("Unable to read version number", mConnectionState);
-        // If the DFU Version characteristic is not available we return 0.
-        if (characteristic == null)
-            return 0;
-
-        mReceivedData = null;
-        mError = 0;
-
-        logi("Reading DFU version number...");
-        sendLogBroadcast(LOG_LEVEL_VERBOSE, "Reading DFU version number...");
-
-        gatt.readCharacteristic(characteristic);
-
-        // We have to wait until device receives a response or an error occur
-        try {
-            synchronized (mLock) {
-                while ((!mRequestCompleted && mConnectionState == STATE_CONNECTED_AND_READY && mError == 0 && !mAborted) || mPaused)
-                    mLock.wait();
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-
-        if (mAborted)
-            throw new UploadAbortedException();
-
-        if (mError != 0)
-            throw new DfuException("Unable to read version number", mError);
-
-        if (mConnectionState != STATE_CONNECTED_AND_READY)
-            throw new DeviceDisconnectedException("Unable to read version number", mConnectionState);
-
-        // The version is a 16-bit unsigned int
-        return characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT16, 0);
-    }
-
-    /**
-     * Enables or disables the notifications for given characteristic. This method is SYNCHRONOUS and wait until the
-     * {@link android.bluetooth.BluetoothGattCallback#onDescriptorWrite(android.bluetooth.BluetoothGatt, android.bluetooth.BluetoothGattDescriptor, int)} will be called or the connection state will change from {@link #STATE_CONNECTED_AND_READY}. If
-     * connection state will change, or an error will occur, an exception will be thrown.
-     *
-     * @param gatt           the GATT device
-     * @param characteristic the characteristic to enable or disable notifications for
-     * @param type           {@link #NOTIFICATIONS} or {@link #INDICATIONS}
-     * @throws DfuException
-     * @throws UploadAbortedException
-     */
-    private void enableCCCD(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final int type) throws DeviceDisconnectedException, DfuException, UploadAbortedException {
-        final String debugString = type == NOTIFICATIONS ? "notifications" : "indications";
-        if (mConnectionState != STATE_CONNECTED_AND_READY)
-            throw new DeviceDisconnectedException("Unable to set " + debugString + " state", mConnectionState);
-
-        mReceivedData = null;
-        mError = 0;
-        if ((type == NOTIFICATIONS && mNotificationsEnabled) || (type == INDICATIONS && mServiceChangedIndicationsEnabled))
-            return;
-
-        logi("Enabling " + debugString + "...");
-        sendLogBroadcast(LOG_LEVEL_VERBOSE, "Enabling " + debugString + " for " + characteristic.getUuid());
-
-        // enable notifications locally
-        gatt.setCharacteristicNotification(characteristic, true);
-
-        // enable notifications on the device
-        final BluetoothGattDescriptor descriptor = characteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG);
-        descriptor.setValue(type == NOTIFICATIONS ? BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE : BluetoothGattDescriptor.ENABLE_INDICATION_VALUE);
-        sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.writeDescriptor(" + descriptor.getUuid() + (type == NOTIFICATIONS ? ", value=0x01-00)" : ", value=0x02-00)"));
-        gatt.writeDescriptor(descriptor);
-
-        // We have to wait until device receives a response or an error occur
-        try {
-            synchronized (mLock) {
-                while ((((type == NOTIFICATIONS && !mNotificationsEnabled) || (type == INDICATIONS && !mServiceChangedIndicationsEnabled))
-                        && mConnectionState == STATE_CONNECTED_AND_READY && mError == 0 && !mAborted) || mPaused)
-                    mLock.wait();
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-
-        if (mAborted)
-            throw new UploadAbortedException();
-
-        if (mError != 0)
-            throw new DfuException("Unable to set " + debugString + " state", mError);
-
-        if (mConnectionState != STATE_CONNECTED_AND_READY)
-            throw new DeviceDisconnectedException("Unable to set " + debugString + " state", mConnectionState);
-    }
-
-    /**
-     * Reads the value of the Service Changed Client Characteristic Configuration descriptor (CCCD).
-     *
-     * @param gatt           the GATT device
-     * @param characteristic the Service Changed characteristic
-     * @return <code>true</code> if Service Changed CCCD is enabled ans set to INDICATE
-     * @throws DeviceDisconnectedException
-     * @throws DfuException
-     * @throws UploadAbortedException
-     */
-    private boolean isServiceChangedCCCDEnabled(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic) throws DeviceDisconnectedException, DfuException, UploadAbortedException {
-        if (mConnectionState != STATE_CONNECTED_AND_READY)
-            throw new DeviceDisconnectedException("Unable to read Service Changed CCCD", mConnectionState);
-        // If the Service Changed characteristic or the CCCD is not available we return false.
-        if (characteristic == null)
-            return false;
-
-        final BluetoothGattDescriptor descriptor = characteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG);
-        if (descriptor == null)
-            return false;
-
-        mRequestCompleted = false;
-        mError = 0;
-
-        logi("Reading Service Changed CCCD value...");
-        sendLogBroadcast(LOG_LEVEL_VERBOSE, "Reading Service Changed CCCD value...");
-
-        gatt.readDescriptor(descriptor);
-
-        // We have to wait until device receives a response or an error occur
-        try {
-            synchronized (mLock) {
-                while ((!mRequestCompleted && mConnectionState == STATE_CONNECTED_AND_READY && mError == 0 && !mAborted) || mPaused)
-                    mLock.wait();
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-
-        if (mAborted)
-            throw new UploadAbortedException();
-
-        if (mError != 0)
-            throw new DfuException("Unable to read Service Changed CCCD", mError);
-
-        if (mConnectionState != STATE_CONNECTED_AND_READY)
-            throw new DeviceDisconnectedException("Unable to read Service Changed CCCD", mConnectionState);
-
-        return mServiceChangedIndicationsEnabled;
-    }
-
-    /**
-     * Writes the operation code to the characteristic. This method is SYNCHRONOUS and wait until the
-     * {@link android.bluetooth.BluetoothGattCallback#onCharacteristicWrite(android.bluetooth.BluetoothGatt, android.bluetooth.BluetoothGattCharacteristic, int)} will be called or the connection state will change from {@link #STATE_CONNECTED_AND_READY}.
-     * If connection state will change, or an error will occur, an exception will be thrown.
-     *
-     * @param gatt           the GATT device
-     * @param characteristic the characteristic to write to. Should be the DFU CONTROL POINT
-     * @param value          the value to write to the characteristic
-     * @throws DeviceDisconnectedException
-     * @throws DfuException
-     * @throws UploadAbortedException
-     */
-    private void writeOpCode(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final byte[] value) throws DeviceDisconnectedException, DfuException, UploadAbortedException {
-        final boolean reset = value[0] == OP_CODE_RESET_KEY || value[0] == OP_CODE_ACTIVATE_AND_RESET_KEY;
-        writeOpCode(gatt, characteristic, value, reset);
-    }
-
-    /**
-     * Writes the operation code to the characteristic. This method is SYNCHRONOUS and wait until the
-     * {@link android.bluetooth.BluetoothGattCallback#onCharacteristicWrite(android.bluetooth.BluetoothGatt, android.bluetooth.BluetoothGattCharacteristic, int)} will be called or the connection state will change from {@link #STATE_CONNECTED_AND_READY}.
-     * If connection state will change, or an error will occur, an exception will be thrown.
-     *
-     * @param gatt           the GATT device
-     * @param characteristic the characteristic to write to. Should be the DFU CONTROL POINT
-     * @param value          the value to write to the characteristic
-     * @param reset          whether the command trigger restarting the device
-     * @throws DeviceDisconnectedException
-     * @throws DfuException
-     * @throws UploadAbortedException
-     */
-    private void writeOpCode(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final byte[] value, final boolean reset) throws DeviceDisconnectedException, DfuException,
-            UploadAbortedException {
-        mReceivedData = null;
-        mError = 0;
-        mRequestCompleted = false;
-		/*
-		 * Sending a command that will make the DFU target to reboot may cause an error 133 (0x85 - Gatt Error). If so, with this flag set, the error will not be shown to the user
-		 * as the peripheral is disconnected anyway. See: mGattCallback#onCharacteristicWrite(...) method
-		 */
-        mResetRequestSent = reset;
-
-        characteristic.setValue(value);
-        sendLogBroadcast(LOG_LEVEL_VERBOSE, "Writing to characteristic " + characteristic.getUuid());
-        sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.writeCharacteristic(" + characteristic.getUuid() + ")");
-        gatt.writeCharacteristic(characteristic);
-
-        // We have to wait for confirmation
-        try {
-            synchronized (mLock) {
-                while ((!mRequestCompleted && mConnectionState == STATE_CONNECTED_AND_READY && mError == 0 && !mAborted) || mPaused)
-                    mLock.wait();
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-
-        if (mAborted)
-            throw new UploadAbortedException();
-
-        if (!mResetRequestSent && mError != 0)
-            throw new DfuException("Unable to write Op Code " + value[0], mError);
-
-        if (!mResetRequestSent && mConnectionState != STATE_CONNECTED_AND_READY)
-            throw new DeviceDisconnectedException("Unable to write Op Code " + value[0], mConnectionState);
-    }
-
-    private void writeCharacteristic(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic) throws DeviceDisconnectedException, DfuException,
-            UploadAbortedException {
-
-        gatt.writeCharacteristic(characteristic);
-
-        // We have to wait for confirmation
-        try {
-            synchronized (mLock) {
-                while ((!mRequestCompleted && mConnectionState == STATE_CONNECTED_AND_READY && mError == 0 && !mAborted) || mPaused) {
-                    mLock.wait();
-                }
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-
-        if (mAborted) {
-            throw new UploadAbortedException();
-        }
-    }
-
-    /**
-     * Writes the image size to the characteristic. This method is SYNCHRONOUS and wait until the {@link android.bluetooth.BluetoothGattCallback#onCharacteristicWrite(android.bluetooth.BluetoothGatt, android.bluetooth.BluetoothGattCharacteristic, int)}
-     * will be called or the connection state will change from {@link #STATE_CONNECTED_AND_READY}. If connection state will change, or an error will occur, an exception will be thrown.
-     *
-     * @param gatt           the GATT device
-     * @param characteristic the characteristic to write to. Should be the DFU PACKET
-     * @param imageSize      the image size in bytes
-     * @throws DeviceDisconnectedException
-     * @throws DfuException
-     * @throws UploadAbortedException
-     */
-    private void writeImageSize(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final int imageSize) throws DeviceDisconnectedException, DfuException,
-            UploadAbortedException {
-        mReceivedData = null;
-        mError = 0;
-        mImageSizeSent = false;
-
-        characteristic.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE);
-        characteristic.setValue(new byte[4]);
-        characteristic.setValue(imageSize, BluetoothGattCharacteristic.FORMAT_UINT32, 0);
-        sendLogBroadcast(LOG_LEVEL_VERBOSE, "Writing to characteristic " + characteristic.getUuid());
-        sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.writeCharacteristic(" + characteristic.getUuid() + ")");
-        gatt.writeCharacteristic(characteristic);
-
-        // We have to wait for confirmation
-        try {
-            synchronized (mLock) {
-                while ((!mImageSizeSent && mConnectionState == STATE_CONNECTED_AND_READY && mError == 0 && !mAborted) || mPaused)
-                    mLock.wait();
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-
-        if (mAborted)
-            throw new UploadAbortedException();
-
-        if (mError != 0)
-            throw new DfuException("Unable to write Image Size", mError);
-
-        if (mConnectionState != STATE_CONNECTED_AND_READY)
-            throw new DeviceDisconnectedException("Unable to write Image Size", mConnectionState);
-    }
-
-    /**
-     * <p>
-     * Writes the Soft Device, Bootloader and Application image sizes to the characteristic. Soft Device and Bootloader update is supported since Soft Device s110 v7.0.0.
-     * Sizes of SD, BL and App are uploaded as 3x UINT32 even though some of them may be 0s. F.e. if only App is being updated the data will be <0x00000000, 0x00000000, [App size]>
-     * </p>
-     * <p>
-     * This method is SYNCHRONOUS and wait until the {@link android.bluetooth.BluetoothGattCallback#onCharacteristicWrite(android.bluetooth.BluetoothGatt, android.bluetooth.BluetoothGattCharacteristic, int)} will be called or the connection state will
-     * change from {@link #STATE_CONNECTED_AND_READY}. If connection state will change, or an error will occur, an exception will be thrown.
-     * </p>
-     *
-     * @param gatt                the GATT device
-     * @param characteristic      the characteristic to write to. Should be the DFU PACKET
-     * @param softDeviceImageSize the Soft Device image size in bytes
-     * @param bootloaderImageSize the Bootloader image size in bytes
-     * @param appImageSize        the Application image size in bytes
-     * @throws DeviceDisconnectedException
-     * @throws DfuException
-     * @throws UploadAbortedException
-     */
-    private void writeImageSize(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final int softDeviceImageSize,
-                                final int bootloaderImageSize, final int appImageSize) throws DeviceDisconnectedException, DfuException, UploadAbortedException {
-
-        mReceivedData = null;
-        mError = 0;
-        mImageSizeSent = false;
-
-        characteristic.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE);
-        characteristic.setValue(new byte[12]);
-        characteristic.setValue(softDeviceImageSize, BluetoothGattCharacteristic.FORMAT_UINT32, 0);
-        characteristic.setValue(bootloaderImageSize, BluetoothGattCharacteristic.FORMAT_UINT32, 4);
-        characteristic.setValue(appImageSize, BluetoothGattCharacteristic.FORMAT_UINT32, 8);
-        sendLogBroadcast(LOG_LEVEL_VERBOSE, "Writing to characteristic " + characteristic.getUuid());
-        sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.writeCharacteristic(" + characteristic.getUuid() + ")");
-        gatt.writeCharacteristic(characteristic);
-
-        // We have to wait for confirmation
-        try {
-            synchronized (mLock) {
-                while ((!mImageSizeSent && mConnectionState == STATE_CONNECTED_AND_READY && mError == 0 && !mAborted) || mPaused)
-                    mLock.wait();
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-
-        if (mAborted)
-            throw new UploadAbortedException();
-
-        if (mError != 0)
-            throw new DfuException("Unable to write Image Sizes", mError);
-
-        if (mConnectionState != STATE_CONNECTED_AND_READY)
-            throw new DeviceDisconnectedException("Unable to write Image Sizes", mConnectionState);
-    }
-
-    /**
-     * Writes the Init packet to the characteristic. This method is SYNCHRONOUS and wait until the {@link android.bluetooth.BluetoothGattCallback#onCharacteristicWrite(android.bluetooth.BluetoothGatt, android.bluetooth.BluetoothGattCharacteristic, int)}
-     * will be called or the connection state will change from {@link #STATE_CONNECTED_AND_READY}. If connection state will change, or an error will occur, an exception will be thrown.
-     *
-     * @param gatt           the GATT device
-     * @param characteristic the characteristic to write to. Should be the DFU PACKET
-     * @param buffer         the init packet as a byte array. This must be shorter or equal to 20 bytes (TODO check this restriction).
-     * @param size           the init packet size
-     * @throws DeviceDisconnectedException
-     * @throws DfuException
-     * @throws UploadAbortedException
-     */
-    private void writeInitPacket(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final byte[] buffer, final int size) throws DeviceDisconnectedException, DfuException,
-            UploadAbortedException {
-        byte[] locBuffer = buffer;
-        if (buffer.length != size) {
-            locBuffer = new byte[size];
-            System.arraycopy(buffer, 0, locBuffer, 0, size);
-        }
-
-        mReceivedData = null;
-        mError = 0;
-        mInitPacketSent = false;
-
-        characteristic.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE);
-        characteristic.setValue(locBuffer);
-        logi("Sending init packet (Value = " + parse(locBuffer) + ")");
-        sendLogBroadcast(LOG_LEVEL_VERBOSE, "Writing to characteristic " + characteristic.getUuid());
-        sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.writeCharacteristic(" + characteristic.getUuid() + ")");
-        gatt.writeCharacteristic(characteristic);
-
-        // We have to wait for confirmation
-        try {
-            synchronized (mLock) {
-                while ((!mInitPacketSent && mConnectionState == STATE_CONNECTED_AND_READY && mError == 0 && !mAborted) || mPaused)
-                    mLock.wait();
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-
-        if (mAborted)
-            throw new UploadAbortedException();
-
-        if (mError != 0)
-            throw new DfuException("Unable to write Init DFU Parameters", mError);
-
-        if (mConnectionState != STATE_CONNECTED_AND_READY)
-            throw new DeviceDisconnectedException("Unable to write Init DFU Parameters", mConnectionState);
-    }
-
-    /**
-     * Starts sending the data. This method is SYNCHRONOUS and terminates when the whole file will be uploaded or the connection status will change from {@link #STATE_CONNECTED_AND_READY}. If
-     * connection state will change, or an error will occur, an exception will be thrown.
-     *
-     * @param gatt                 the GATT device (DFU target)
-     * @param packetCharacteristic the characteristic to write file content to. Must be the DFU PACKET
-     * @return The response value received from notification with Op Code = 3 when all bytes will be uploaded successfully.
-     * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of the transmission. The error core will be saved in {@link #mConnectionState}.
-     * @throws DfuException                Thrown if DFU error occur
-     * @throws UploadAbortedException
-     */
-    private byte[] uploadFirmwareImage(final BluetoothGatt gatt, final BluetoothGattCharacteristic packetCharacteristic, final InputStream inputStream) throws DeviceDisconnectedException,
-            DfuException, UploadAbortedException {
-        mReceivedData = null;
-        mError = 0;
-
-        final byte[] buffer = mBuffer;
-        try {
-            final int size = inputStream.read(buffer);
-            sendLogBroadcast(LOG_LEVEL_VERBOSE, "Sending firmware to characteristic " + packetCharacteristic.getUuid() + "...");
-            writePacket(gatt, packetCharacteristic, buffer, size);
-        } catch (final HexFileValidationException e) {
-            throw new DfuException("HEX file not valid", ERROR_FILE_INVALID);
-        } catch (final IOException e) {
-            throw new DfuException("Error while reading file", ERROR_FILE_IO_EXCEPTION);
-        }
-
-        try {
-            synchronized (mLock) {
-                while ((mReceivedData == null && mConnectionState == STATE_CONNECTED_AND_READY && mError == 0 && !mAborted) || mPaused)
-                    mLock.wait();
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-
-        if (mAborted)
-            throw new UploadAbortedException();
-
-        if (mError != 0)
-            throw new DfuException("Uploading Firmware Image failed", mError);
-
-        if (mConnectionState != STATE_CONNECTED_AND_READY)
-            throw new DeviceDisconnectedException("Uploading Firmware Image failed: device disconnected", mConnectionState);
-
-        return mReceivedData;
-    }
-
-    //Duplicate of String parse(final byte[] data)
-    //TODO Remove this
-    public static String bytesToHex(byte[] bytes) {
-        char[] hexChars = new char[bytes.length * 2];
-        for (int j = 0; j < bytes.length; j++) {
-            int v = bytes[j] & 0xFF;
-            hexChars[j * 2] = HEX_ARRAY[v >> 4];
-            hexChars[j * 2 + 1] = HEX_ARRAY[v & 0x0F];
-        }
-        return new String(hexChars);
-    }
-
-    /**
-     * Writes the buffer to the characteristic. The maximum size of the buffer is 20 bytes. This method is ASYNCHRONOUS and returns immediately after adding the data to TX queue.
-     *
-     * @param gatt           the GATT device
-     * @param characteristic the characteristic to write to. Should be the DFU PACKET
-     * @param buffer         the buffer with 1-20 bytes
-     * @param size           the number of bytes from the buffer to send
-     */
-    private void writePacket(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final byte[] buffer, final int size) {
-        byte[] locBuffer = buffer;
-        if (buffer.length != size) {
-            locBuffer = new byte[size];
-            System.arraycopy(buffer, 0, locBuffer, 0, size);
-        }
-
-        //logi("Sending Packet - " + bytesToHex(locBuffer));
-        characteristic.setValue(locBuffer);
-        gatt.writeCharacteristic(characteristic);
-        // FIXME BLE buffer overflow
-        // after writing to the device with WRITE_NO_RESPONSE property the onCharacteristicWrite callback is received immediately after writing data to a buffer.
-        // The real sending is much slower than adding to the buffer. This method does not return false if writing didn't succeed.. just the callback is not invoked.
-        //
-        // More info: this works fine on Nexus 5 (Android 4.4) (4.3 seconds) and on Samsung S4 (Android 4.3) (20 seconds) so this is a driver issue.
-        // Nexus 4 and 7 uses Qualcomm chip, Nexus 5 and Samsung uses Broadcom chips.
-    }
-
-    private void waitIfPaused() {
-        synchronized (mLock) {
-            try {
-                while (mPaused)
-                    mLock.wait();
-            } catch (final InterruptedException e) {
-                loge("Sleeping interrupted", e);
-            }
-        }
-    }
-
-
-    @SuppressLint("NewApi")
-    private boolean createBond(final BluetoothDevice device) {
-        if (device.getBondState() == BluetoothDevice.BOND_BONDED)
-            return true;
-
-        boolean result;
-        mRequestCompleted = false;
-
-        sendLogBroadcast(LOG_LEVEL_VERBOSE, "Starting pairing...");
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
-            sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.getDevice().createBond()");
-            result = device.createBond();
-        } else {
-            result = createBondApi18(device);
-        }
-
-        // We have to wait until device is bounded
-        try {
-            synchronized (mLock) {
-                while (!mRequestCompleted && !mAborted)
-                    mLock.wait();
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-
-        return result;
-    }
-
-    private boolean createBondApi18(final BluetoothDevice device) {
-		/*
-		 * There is a createBond() method in BluetoothDevice class but for now it's hidden. We will call it using reflections. It has been revealed in KitKat (Api19)
-		 */
-        try {
-            final Method createBond = device.getClass().getMethod("createBond");
-            if (createBond != null) {
-                sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.getDevice().createBond() (hidden)");
-                return (Boolean) createBond.invoke(device);
-            }
-        } catch (final Exception e) {
-            Log.w(TAG, "An exception occurred while creating bond", e);
-            Log.e(TAG, e.toString());
-        }
-
-        return false;
-    }
-
-    /**
-     * Removes the bond information for the given device.
-     *
-     * @param device the device to unbound
-     * @return <code>true</code> if operation succeeded, <code>false</code> otherwise
-     */
-    private boolean removeBond(final BluetoothDevice device) {
-        if (device.getBondState() == BluetoothDevice.BOND_NONE)
-            return true;
-
-        sendLogBroadcast(LOG_LEVEL_VERBOSE, "Removing bond information...");
-        boolean result = false;
-		/*
-		 * There is a removeBond() method in BluetoothDevice class but for now it's hidden. We will call it using reflections.
-		 */
-        try {
-            final Method removeBond = device.getClass().getMethod("removeBond");
-            if (removeBond != null) {
-                mRequestCompleted = false;
-                sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.getDevice().removeBond() (hidden)");
-                result = (Boolean) removeBond.invoke(device);
-
-                // We have to wait until device is unbounded
-                try {
-                    synchronized (mLock) {
-                        while (!mRequestCompleted && !mAborted)
-                            mLock.wait();
-                    }
-                } catch (final InterruptedException e) {
-                    loge("Sleeping interrupted", e);
-                }
-            }
-
-            result = true;
-        } catch (final Exception e) {
-            Log.w(TAG, "An exception occurred while removing bond information", e);
-            Log.e(TAG, e.toString());
-        }
-
-        return result;
-    }
-
-    /**
-     * Waits until the notification will arrive. Returns the data returned by the notification. This method will block the thread if response is not ready or connection state will change from
-     * {@link #STATE_CONNECTED_AND_READY}. If connection state will change, or an error will occur, an exception will be thrown.
-     *
-     * @return the value returned by the Control Point notification
-     * @throws DeviceDisconnectedException
-     * @throws DfuException
-     * @throws UploadAbortedException
-     */
-    private byte[] readNotificationResponse() throws DeviceDisconnectedException, DfuException, UploadAbortedException {
-        // do not clear the mReceiveData here. The response might already be obtained. Clear it in write request instead.
-        mError = 0;
-        try {
-            synchronized (mLock) {
-                while ((mReceivedData == null && mConnectionState == STATE_CONNECTED_AND_READY && mError == 0 && !mAborted) || mPaused)
-                    mLock.wait();
-            }
-        } catch (final InterruptedException e) {
-            loge("Sleeping interrupted", e);
-        }
-
-        if (mAborted)
-            throw new UploadAbortedException();
-
-        if (mError != 0)
-            throw new DfuException("Unable to write Op Code", mError);
-
-        if (mConnectionState != STATE_CONNECTED_AND_READY)
-            throw new DeviceDisconnectedException("Unable to write Op Code", mConnectionState);
-
-        return mReceivedData;
-    }
-
-    /**
-     * Creates or updates the notification in the Notification Manager. Sends broadcast with current progress to the activity.
-     */
-    private void updateProgressNotification() {
-        final int progress = (int) (100.0f * mBytesSent / mImageSizeInBytes);
-        if (mLastProgress == progress)
-            return;
-
-        mLastProgress = progress;
-        updateProgressNotification(progress);
-    }
-
-    /**
-     * Creates or updates the notification in the Notification Manager. Sends broadcast with given progress or error state to the activity.
-     *
-     * @param progress the current progress state or an error number, can be one of {@link #PROGRESS_CONNECTING}, {@link #PROGRESS_STARTING}, {@link #PROGRESS_ENABLING_DFU_MODE},
-     *                 {@link #PROGRESS_VALIDATING}, {@link #PROGRESS_DISCONNECTING}, {@link #PROGRESS_COMPLETED} or {@link #ERROR_FILE_ERROR}, {@link #ERROR_FILE_INVALID} , etc
-     */
-    private void updateProgressNotification(final int progress) {
-        // send progress or error broadcast
-        if (progress < ERROR_MASK)
-            sendProgressBroadcast(progress);
-        else
-            sendErrorBroadcast(progress);
-    }
-
-    /**
-     * This method must return the activity class that will be used to create the pending intent used as a content intent in the notification showing the upload progress.
-     * The activity will be launched when user click the notification. DfuService will add {@link android.content.Intent#FLAG_ACTIVITY_NEW_TASK} flag and the following extras:
-     * <ul>
-     * <li>{@link #EXTRA_DEVICE_ADDRESS} - target device address</li>
-     * <li>{@link #EXTRA_DEVICE_NAME} - target device name</li>
-     * <li>{@link #EXTRA_PROGRESS} - the connection state (values < 0)*, current progress (0-100) or error number if {@link #ERROR_MASK} bit set.</li>
-     * </ul>
-     * <p>
-     * __________<br />
-     * * - connection state constants:
-     * <ul>
-     * <li>{@link #PROGRESS_CONNECTING}</li>
-     * <li>{@link #PROGRESS_DISCONNECTING}</li>
-     * <li>{@link #PROGRESS_COMPLETED}</li>
-     * <li>{@link #PROGRESS_ABORTED}</li>
-     * <li>{@link #PROGRESS_STARTING}</li>
-     * <li>{@link #PROGRESS_ENABLING_DFU_MODE}</li>
-     * <li>{@link #PROGRESS_VALIDATING}</li>
-     * </ul>
-     * </p>
-     *
-     * @return the target activity class
-     */
-    protected abstract Class<? extends Activity> getNotificationTarget();
-
-    private void sendProgressBroadcast(final int progress) {
-
-        final long now = SystemClock.elapsedRealtime();
-        final float speed = now - mLastProgressTime != 0 ? (float) (mBytesSent - mLastBytesSent) / (float) (now - mLastProgressTime) : 0.0f;
-        final float avgSpeed = now - mStartTime != 0 ? (float) mBytesSent / (float) (now - mStartTime) : 0.0f;
-        mLastProgressTime = now;
-        mLastBytesSent = mBytesSent;
-
-        final Intent broadcast = new Intent(BROADCAST_PROGRESS);
-        broadcast.putExtra(EXTRA_DATA, progress);
-        broadcast.putExtra(EXTRA_DEVICE_ADDRESS, mDeviceAddress);
-        broadcast.putExtra(EXTRA_PART_CURRENT, mPartCurrent);
-        broadcast.putExtra(EXTRA_PARTS_TOTAL, mPartsTotal);
-        broadcast.putExtra(EXTRA_SPEED_B_PER_MS, speed);
-        broadcast.putExtra(EXTRA_AVG_SPEED_B_PER_MS, avgSpeed);
-        LocalBroadcastManager.getInstance(this).sendBroadcast(broadcast);
-    }
-
-    private void sendErrorBroadcast(final int error) {
-
-        final Intent broadcast = new Intent(BROADCAST_ERROR);
-        if ((error & ERROR_CONNECTION_MASK) > 0) {
-            broadcast.putExtra(EXTRA_DATA, error & ~ERROR_CONNECTION_MASK);
-            broadcast.putExtra(EXTRA_ERROR_TYPE, ERROR_TYPE_COMMUNICATION);
-        } else if ((error & ERROR_CONNECTION_STATE_MASK) > 0) {
-            broadcast.putExtra(EXTRA_DATA, error & ~ERROR_CONNECTION_STATE_MASK);
-            broadcast.putExtra(EXTRA_ERROR_TYPE, ERROR_TYPE_COMMUNICATION_STATE);
-        } else if ((error & ERROR_REMOTE_MASK) > 0) {
-            broadcast.putExtra(EXTRA_DATA, error);
-            broadcast.putExtra(EXTRA_ERROR_TYPE, ERROR_TYPE_DFU_REMOTE);
-        } else {
-            broadcast.putExtra(EXTRA_DATA, error);
-            broadcast.putExtra(EXTRA_ERROR_TYPE, ERROR_TYPE_OTHER);
-        }
-
-        broadcast.putExtra(EXTRA_DEVICE_ADDRESS, mDeviceAddress);
-        LocalBroadcastManager.getInstance(this).sendBroadcast(broadcast);
-    }
-
-    private void sendLogBroadcast(final int level, final String message) {
-        final String fullMessage = "[DFU] " + message;
-        final Intent broadcast = new Intent(BROADCAST_LOG);
-        logi("Dfu update " + fullMessage);
-        broadcast.putExtra(EXTRA_LOG_MESSAGE, fullMessage);
-        broadcast.putExtra(EXTRA_LOG_LEVEL, level);
-        broadcast.putExtra(EXTRA_DEVICE_ADDRESS, mDeviceAddress);
-        LocalBroadcastManager.getInstance(this).sendBroadcast(broadcast);
-    }
-
-    private void sendStatsBinFileSize(final int size) {
-        final Intent broadcast = new Intent(BROADCAST_LOG);
-        broadcast.putExtra(EXTRA_LOG_LEVEL, LOG_LEVEL_BINARY_SIZE);
-        broadcast.putExtra(EXTRA_DATA, Integer.toString(size));
-
-
-        LocalBroadcastManager.getInstance(this).sendBroadcast(broadcast);
-    }
-
-    private void sendStatsMicroBitFirmware(final String firmware) {
-        final Intent broadcast = new Intent(BROADCAST_LOG);
-        broadcast.putExtra(EXTRA_LOG_LEVEL, LOG_LEVEL_FIRMWARE);
-        broadcast.putExtra(EXTRA_DATA, firmware);
-        LocalBroadcastManager.getInstance(this).sendBroadcast(broadcast);
-    }
-
-    /**
-     * Initializes bluetooth adapter
-     *
-     * @return <code>true</code> if initialization was successful
-     */
-    private boolean initialize() {
-        // For API level 18 and above, get a reference to BluetoothAdapter through
-        // BluetoothManager.
-        final BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
-        if (bluetoothManager == null) {
-            loge("Unable to initialize BluetoothManager.");
-            return false;
-        }
-
-        mBluetoothAdapter = bluetoothManager.getAdapter();
-        if (mBluetoothAdapter == null) {
-            loge("Unable to obtain a BluetoothAdapter.");
-            return false;
-        }
-
-        return true;
-    }
-
-    private void loge(final String message) {
-        if (DEBUG) {
-            Log.e(TAG, "### " + Thread.currentThread().getId() + " # " + message);
-        }
-    }
-
-    private void loge(final String message, final Throwable e) {
-        if (DEBUG) {
-            Log.e(TAG, "### " + Thread.currentThread().getId() + " # " + message, e);
-        }
-    }
-
-    private void logw(final String message) {
-        if (DEBUG) {
-            Log.w(TAG, "### " + Thread.currentThread().getId() + " # " + message);
-        }
-    }
-
-    private void logi(final String message) {
-        if (DEBUG) {
-            Log.i(TAG, "### " + Thread.currentThread().getId() + " # " + message);
-        }
-    }
-
-    private void logd(final String message) {
-        if (DEBUG) {
-            Log.d(TAG, "### " + Thread.currentThread().getId() + " # " + message);
-        }
-    }
-
-    private String parse(final byte[] data) {
-        if (data == null)
-            return "";
-
-        final int length = data.length;
-        if (length == 0)
-            return "";
-
-        final char[] out = new char[length * 3 - 1];
-        for (int j = 0; j < length; j++) {
-            int v = data[j] & 0xFF;
-            out[j * 3] = HEX_ARRAY[v >>> 4];
-            out[j * 3 + 1] = HEX_ARRAY[v & 0x0F];
-            if (j != length - 1)
-                out[j * 3 + 2] = '-';
-        }
-
-        return new String(out);
-    }
-}
diff --git a/partial-flashing-lib/src/main/java/org/microbit/android/partialflashing/HexUtils.java b/partial-flashing-lib/src/main/java/org/microbit/android/partialflashing/HexUtils.java
new file mode 100644
index 0000000..79203c9
--- /dev/null
+++ b/partial-flashing-lib/src/main/java/org/microbit/android/partialflashing/HexUtils.java
@@ -0,0 +1,272 @@
+package org.microbit.android.partialflashing;
+
+import android.util.Log;
+
+import java.io.BufferedReader;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.ListIterator;
+
+
+/**
+ * Created by Sam Kent on 01/11/2017.
+ *
+ * A Class to manipulate micro:bit hex files
+ * Focused towards stripping a file down to it's PXT section for use in Partial Flashing
+ *
+ *   (c) 2017 - 2021, Micro:bit Educational Foundation and contributors
+ *
+ *  SPDX-License-Identifier: MIT
+ *
+ */
+
+public class HexUtils {
+    private final static String TAG = HexUtils.class.getSimpleName();
+        
+    private final static int INIT = 0;
+    private final static int INVALID_FILE = 1;
+    private final static int NO_PARTIAL_FLASH = 2;
+    public int status = INIT;
+
+    FileInputStream fis = null;
+    BufferedReader reader = null;
+    List<String> hexLines = new ArrayList<String>();
+
+    public HexUtils(String filePath){
+        // Hex Utils initialization
+        // Open File
+        try {
+          if(!openHexFile(filePath)){
+                  status = INVALID_FILE;
+          }
+        } catch(Exception e) {
+          Log.e(TAG, "Error opening file: " + e);
+        }
+    }
+
+    /*
+        A function to open a hex file for reading
+        @param filePath - A string locating the hex file in use
+        @return true  - if file opens
+                false - if file cannot be opened
+     */
+    public Boolean openHexFile(String filePath) throws IOException {
+        // Open connection to hex file
+        try {
+            fis = new FileInputStream(filePath);
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+            return false;
+        }
+
+        // Create reader for hex file
+        reader = new BufferedReader(new InputStreamReader(fis));
+        String line;
+        while((line = reader.readLine()) != null) {
+            hexLines.add(line);
+        }
+        reader.close();
+        return true;
+    }
+
+    /* 
+     * A function to find the length of the hex file
+     * @param none
+     * @ return the size (# of lines) in the hex file
+     */
+    public int numOfLines() {
+            return hexLines.size();
+    }
+    
+    /* 
+     * A function to search for data in a hex file
+     * @param the _string_ of data to search for
+     * @return the index of the data. -1 if not found.
+     */
+    public int searchForData(String search) throws IOException {
+        // Iterate through
+        ListIterator i = hexLines.listIterator();
+        while (i.hasNext()) {
+            // Have to call nextIndex() before next()
+            int index = i.nextIndex();
+
+            // Return index if successful
+            if(i.next().toString().contains(search)){ return index; }
+        }
+
+        // Return -1 if no match
+        return -1;
+    }
+
+    /*
+     * A function to search for data in a hex file
+     * @param the _string_ of data to search for
+     * @return the index of the data. -1 if not found.
+     */
+    public int searchForDataRegEx(String search) throws IOException {
+        // Iterate through
+        ListIterator i = hexLines.listIterator();
+        while (i.hasNext()) {
+            // Have to call nextIndex() before next()
+            int index = i.nextIndex();
+
+            // Return index if successful
+            String match = i.next().toString();
+            if(match.matches(search)){
+                return index;
+            }
+        }
+
+        // Return -1 if no match
+        return -1;
+    }
+    
+    /*
+     * Returns data from an index
+     * @param index
+     * @return data as string
+     */
+    public String getDataFromIndex(int index) throws IOException {
+            return getRecordData(hexLines.get(index)); 
+    }
+
+    /*
+     * Returns record type from an index
+     * @param index
+     * @return type as int
+     */
+    public int getRecordTypeFromIndex(int index) throws IOException {
+            return getRecordType(hexLines.get(index));
+    }
+
+    /*
+     * Returns record address from an index
+     * Note: does not include segment address
+     * @param index
+     * @return address as int
+     */
+    public int getRecordAddressFromIndex(int index) throws IOException {
+            return getRecordAddress(hexLines.get(index));
+    }
+
+    /*
+    Used to get the data length from a record
+    @param Record as a String
+    @return Data length as a decimal / # of chars
+ */
+    public int getRecordDataLengthFromIndex(int index){
+        return getRecordDataLength(hexLines.get(index));
+    }
+
+    /*
+     * Returns segment address from an index
+     * @param index
+     * @return address as int
+     */
+    public int getSegmentAddress(int index) throws IOException {
+            // Look backwards to find current segment address
+            int segmentAddress = -1;
+            int cur = index;
+            while(segmentAddress == -1) {
+                if(getRecordTypeFromIndex(cur) == 4)
+                    break;
+                cur--;
+            }
+
+            // Return segment address
+            return Integer.parseInt(getRecordData(hexLines.get(cur)), 16);
+    }
+
+    /*
+        Used to get the data address from a record
+        @param Record as a String
+        @return Data address as a decimal
+     */
+    private int getRecordAddress(String record){
+        String hexAddress = record.substring(3,7);
+        return Integer.parseInt(hexAddress, 16);
+    }
+
+    /*
+        Used to get the data length from a record
+        @param Record as a String
+        @return Data length as a decimal / # of chars
+     */
+    private int getRecordDataLength(String record){
+        String hexLength = record.substring(1,3);
+        int len = 2 * Integer.parseInt(hexLength, 16); // Num Of Bytes. Each Byte is represented by 2 chars hence 2*
+        return len;
+    }
+
+    /*
+    Used to get the record type from a record
+    @param Record as a String
+    @return Record type as a decimal
+    */
+    private int getRecordType(String record){
+        try {
+            String hexType = record.substring(7, 9);
+            return Integer.parseInt(hexType, 16);
+        } catch (Exception e){
+            Log.e(TAG, "getRecordType " + e.toString());
+            return 0;
+        }
+    }
+
+    /*
+    Used to get the data from a record
+    @param Record as a String
+    @return Data
+    */
+    private String getRecordData(String record){
+        try {
+            int len = getRecordDataLength(record);
+            return record.substring(9, 9 + len);
+        } catch (Exception e) {
+            Log.e(TAG, "Get record data " + e.toString());
+            return "";
+        }
+    }
+
+    /*
+    Number of lines / packets in file
+     */
+    public int numOfLines(String filePath) throws IOException {
+        BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(filePath)));
+        int lines = 0;
+        while (!reader.readLine().contains("41140E2FB82FA2B")) lines++;
+        reader.close();
+        return lines;
+    }
+
+
+    /*
+    Record to byte Array
+    @param hexString string to convert
+    @return byteArray of hex
+     */
+    public static byte[] recordToByteArray(String hexString, int offset, int packetNum){
+        int len = hexString.length();
+        byte[] data = new byte[(len/2) + 4];
+        for(int i=0; i < len; i+=2){
+            data[(i / 2) + 4] = (byte) ((Character.digit(hexString.charAt(i), 16) << 4) + Character.digit(hexString.charAt(i+1), 16));
+        }
+
+        // WRITE Command
+        data[0] = 0x01;
+
+        data[1]   = (byte)(offset >> 8);
+        data[2] = (byte)(offset & 0xFF);
+        data[3] = (byte)(packetNum & 0xFF);
+
+//        Log.v(TAG, "Sent: " + data.toString());
+
+        return data;
+    }
+
+}
+
diff --git a/partial-flashing-lib/src/main/java/org/microbit/android/partialflashing/PartialFlashingBaseService.java b/partial-flashing-lib/src/main/java/org/microbit/android/partialflashing/PartialFlashingBaseService.java
new file mode 100644
index 0000000..610f5cc
--- /dev/null
+++ b/partial-flashing-lib/src/main/java/org/microbit/android/partialflashing/PartialFlashingBaseService.java
@@ -0,0 +1,695 @@
+package org.microbit.android.partialflashing;
+
+import android.Manifest;
+import android.app.Service;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothGatt;
+import android.bluetooth.BluetoothGattCallback;
+import android.bluetooth.BluetoothGattCharacteristic;
+import android.bluetooth.BluetoothGattDescriptor;
+import android.bluetooth.BluetoothGattService;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.PackageManager;
+import android.os.Build;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.IBinder;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Process;
+import android.os.SystemClock;
+import android.util.Log;
+
+import java.io.IOException;
+import java.lang.reflect.Method;
+import java.util.Arrays;
+import java.util.List;
+import java.util.UUID;
+
+import androidx.annotation.NonNull;
+import androidx.core.content.ContextCompat;
+import androidx.localbroadcastmanager.content.LocalBroadcastManager;
+
+import static android.bluetooth.BluetoothDevice.ACTION_BOND_STATE_CHANGED;
+import static android.bluetooth.BluetoothDevice.BOND_BONDED;
+import static android.bluetooth.BluetoothDevice.BOND_BONDING;
+import static android.bluetooth.BluetoothDevice.BOND_NONE;
+import static android.bluetooth.BluetoothDevice.ERROR;
+import static android.bluetooth.BluetoothDevice.EXTRA_BOND_STATE;
+
+public abstract class PartialFlashingBaseService extends Service {
+    private static final String TAG = "PartialFlashingService";
+    private static final int DELAY_TO_CLEAR_CACHE = 2000;
+    public static final String EXTRA_DEVICE_ADDRESS = "org.microbit.android.partialflashing.EXTRA_DEVICE_ADDRESS";
+    public static final String EXTRA_FILE_PATH = "org.microbit.android.partialflashing.EXTRA_FILE_PATH";
+    public static final String BROADCAST_START = "org.microbit.android.partialflashing.broadcast.BROADCAST_START";
+    public static final String BROADCAST_PROGRESS = "org.microbit.android.partialflashing.broadcast.BROADCAST_PROGRESS";
+    public static final String BROADCAST_COMPLETE = "org.microbit.android.partialflashing.broadcast.BROADCAST_COMPLETE";
+    public static final String BROADCAST_PF_FAILED = "org.microbit.android.partialflashing.broadcast.BROADCAST_PF_FAILED";
+    public static final String BROADCAST_PF_ATTEMPT_DFU = "org.microbit.android.partialflashing.broadcast.BROADCAST_PF_ATTEMPT_DFU";
+    public static final String EXTRA_PROGRESS = "org.microbit.android.partialflashing.extra.EXTRA_PROGRESS";
+    public static final UUID PARTIAL_FLASHING_SERVICE_UUID = UUID.fromString("E97DD91D-251D-470A-A062-FA1922DFA9A8");
+    public static final UUID PARTIAL_FLASHING_CHARACTERISTIC_UUID = UUID.fromString("E97D3B10-251D-470A-A062-FA1922DFA9A8");
+    private static final UUID CLIENT_CHARACTERISTIC_CONFIG_UUID = UUID.fromString("00002902-0000-1000-8000-00805f9b34fb");
+    private static final String PXT_MAGIC = "708E3B92C615A841C49866C975EE5197";
+    private static final String UPY_MAGIC = ".*FE307F59.{16}9DD7B1C1.*";
+    private static final byte REGION_INFO_COMMAND = (byte) 0x00;
+    private static final byte FLASH_COMMAND = (byte) 0x01;
+    private static final byte STATUS = (byte) 0xEE;
+    private static final int REGION_DAL = 1;
+    private static final byte MODE_APPLICATION = 0x01;
+
+    private final Object lock = new Object();
+    private String deviceAddress;
+    private String filePath;
+    private BluetoothGattCharacteristic partialFlashingCharacteristic;
+    private String dalHash;
+    private int bondState;
+    private ServiceHandler serviceHandler;
+
+    protected final static int STATE_DISCONNECTED = 0;
+    protected final static int STATE_CONNECTING = -1;
+    protected final static int STATE_CONNECTED = -2;
+    protected final static int STATE_CONNECTED_AND_READY = -3;
+    protected final static int STATE_DISCONNECTING = -4;
+    protected final static int STATE_CLOSED = -5;
+
+    protected final static int ATTEMPT_FILED = -1;
+    protected final static int ATTEMPT_ENTER_DFU = 0;
+    protected final static int ATTEMPT_SUCCESS = 1;
+
+
+    private int connectionState = STATE_DISCONNECTED;
+    private boolean descriptorWriteSuccess = false;
+    private boolean statusRequestSuccess = false;
+    private boolean hashRequestSuccess = false;
+    private static final byte PACKET_STATE_WAITING = (byte) 0x00;
+    private static final byte PACKET_STATE_RETRANSMIT = (byte) 0xAA;
+    private static final byte PACKET_STATE_COMPLETE_FLASH = (byte) 0xCF;
+    private byte packetState = PACKET_STATE_WAITING;
+
+    private static final String[] BLUETOOTH_PERMISSIONS;
+
+    static {
+        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.S) {
+            BLUETOOTH_PERMISSIONS = new String[]{Manifest.permission.BLUETOOTH_SCAN, Manifest.permission.BLUETOOTH_CONNECT};
+        } else {
+            BLUETOOTH_PERMISSIONS = new String[]{Manifest.permission.BLUETOOTH, Manifest.permission.BLUETOOTH_ADMIN};
+        }
+    }
+
+    private final BroadcastReceiver bondStateReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            final BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+            if (device == null || !device.getAddress().equals(deviceAddress)) {
+                return;
+            }
+
+            final String action = intent.getAction();
+            if (action == null) {
+                return;
+            }
+
+            // Take action depending on new bond state
+            if (action.equals(ACTION_BOND_STATE_CHANGED)) {
+                bondState = intent.getIntExtra(EXTRA_BOND_STATE, ERROR);
+                switch (bondState) {
+                    case BOND_BONDING -> {
+                        log(Log.WARN, "Bonding started");
+                    }
+                    case BOND_BONDED, BOND_NONE -> {
+                        log(Log.WARN, "Bonding " + (bondState == BOND_BONDED));
+                        synchronized (lock) {
+                            lock.notifyAll();
+                        }
+                    }
+                }
+            }
+        }
+    };
+
+    @SuppressWarnings({"MissingPermission"})
+    private final BluetoothGattCallback gattCallback = new BluetoothGattCallback() {
+        @Override
+        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
+            super.onConnectionStateChange(gatt, status, newState);
+            if (status == BluetoothGatt.GATT_SUCCESS) {
+                if (newState == BluetoothGatt.STATE_CONNECTED) {
+                    connectionState = STATE_CONNECTED;
+                    if (bondState == BOND_NONE || bondState == BOND_BONDED) {
+                        if (bondState == BOND_BONDED && Build.VERSION.SDK_INT <= Build.VERSION_CODES.N) {
+                            waitFor(1600);
+                        }
+                        boolean result = gatt.discoverServices();
+                        if (!result) {
+                            connectionState = STATE_DISCONNECTING;
+                            gatt.disconnect();
+                            log(Log.ERROR, "DiscoverServices failed to start");
+                        }
+                    } else if (bondState == BOND_BONDING) {
+                        log(Log.WARN, "Waiting for bonding to complete");
+                        try {
+                            synchronized (lock) {
+                                while (bondState == BOND_BONDING)
+                                    lock.wait();
+                            }
+                        } catch (final InterruptedException e) {
+                            log(Log.ERROR, "Sleeping interrupted, " + e);
+                        }
+                    }
+                } else if (newState == BluetoothGatt.STATE_DISCONNECTED) {
+                    connectionState = STATE_DISCONNECTED;
+                    clearServicesCache(gatt);
+                    gatt.close();
+                    stopSelf();
+                }
+            } else {
+                connectionState = STATE_DISCONNECTING;
+                gatt.disconnect();
+                sendProgressBroadcastFailed();
+            }
+            // Notify waiting thread
+            synchronized (lock) {
+                lock.notifyAll();
+            }
+        }
+
+        @Override
+        public void onServicesDiscovered(BluetoothGatt gatt, int status) {
+            super.onServicesDiscovered(gatt, status);
+            if (status == BluetoothGatt.GATT_SUCCESS) {
+                connectionState = STATE_CONNECTED_AND_READY;
+            } else {
+                connectionState = STATE_DISCONNECTING;
+                gatt.disconnect();
+                sendProgressBroadcastFailed();
+            }
+            // Notify waiting thread
+            synchronized (lock) {
+                lock.notifyAll();
+            }
+        }
+
+        @Override
+        public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {
+            super.onCharacteristicWrite(gatt, characteristic, status);
+            // Notify waiting thread
+            synchronized (lock) {
+                lock.notifyAll();
+            }
+        }
+
+        @Override
+        public void onCharacteristicChanged(@NonNull BluetoothGatt gatt, @NonNull BluetoothGattCharacteristic characteristic, @NonNull byte[] value) {
+            super.onCharacteristicChanged(gatt, characteristic, value);
+            switch (value[0]) {
+                case REGION_INFO_COMMAND -> {
+                    byte[] hash = Arrays.copyOfRange(value, 10, 18);
+                    if (value[1] == REGION_DAL) {
+                        dalHash = bytesToHex(hash);
+                        log(Log.VERBOSE, "Hash: " + dalHash);
+                        hashRequestSuccess = true;
+                    }
+                }
+                case FLASH_COMMAND -> packetState = value[1];
+                case STATUS -> {
+                    log(Log.WARN, value[2] == MODE_APPLICATION ? "Application Mode" : "Pairing Mode");
+                    if (value[2] == MODE_APPLICATION) {
+                        //Reset (0x00 for Pairing Mode, 0x01 for Application Mode)
+                        writeCharacteristic(gatt, (byte) 0xFF, (byte) 0x00);
+                    } else {
+                        statusRequestSuccess = true;
+                    }
+                }
+            }
+            synchronized (lock) {
+                lock.notifyAll();
+            }
+        }
+
+        @Override
+        public void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {
+            super.onDescriptorWrite(gatt, descriptor, status);
+            if (status == BluetoothGatt.GATT_SUCCESS) {
+                descriptorWriteSuccess = true;
+            } else {
+                connectionState = STATE_DISCONNECTING;
+                gatt.disconnect();
+                sendProgressBroadcastFailed();
+            }
+            // Notify waiting thread
+            synchronized (lock) {
+                lock.notifyAll();
+            }
+        }
+    };
+
+    // Handler that receives messages from the thread
+    private final class ServiceHandler extends Handler {
+        public ServiceHandler(Looper looper) {
+            super(looper);
+        }
+
+        @Override
+        @SuppressWarnings({"MissingPermission"})
+        public void handleMessage(Message msg) {
+            if (isPermissionGranted(BLUETOOTH_PERMISSIONS)) {
+                sendProgressBroadcastStart();
+                BluetoothGatt gatt = connect();
+                if (gatt != null && connectionState == STATE_CONNECTED_AND_READY) {
+                    log(Log.DEBUG, "Connected and ready");
+                    int status = attemptPartialFlashing(gatt);
+                    switch (status) {
+                        case ATTEMPT_ENTER_DFU -> {
+                            connectionState = STATE_DISCONNECTING;
+                            gatt.disconnect();
+                            sendProgressBroadcastAttemptDfu();
+                        }
+                        case ATTEMPT_FILED -> {
+                            connectionState = STATE_DISCONNECTING;
+                            gatt.disconnect();
+                            sendProgressBroadcastFailed();
+                        }
+                    }
+                } else {
+                    sendProgressBroadcastAttemptDfu();
+                    stopSelf(msg.arg1);
+                }
+
+            } else {
+                log(Log.ERROR, "No Permission Granted");
+                sendProgressBroadcastFailed();
+                stopSelf(msg.arg1);
+            }
+        }
+    }
+
+    @Override
+    public void onCreate() {
+        // Start up the thread running the service. Note that we create a
+        // separate thread because the service normally runs in the process's
+        // main thread, which we don't want to block. We also make it
+        // background priority so CPU-intensive work doesn't disrupt our UI.
+        HandlerThread thread = new HandlerThread("ServiceStartArguments",
+                Process.THREAD_PRIORITY_BACKGROUND);
+        thread.start();
+
+        // Get the HandlerThread's Looper and use it for our Handler
+        Looper serviceLooper = thread.getLooper();
+        serviceHandler = new ServiceHandler(serviceLooper);
+    }
+
+    @Override
+    public int onStartCommand(Intent intent, int flags, int startId) {
+        log(Log.WARN, "service starting, startId: " + startId);
+
+        registerReceiver(bondStateReceiver, new IntentFilter(ACTION_BOND_STATE_CHANGED));
+        deviceAddress = intent.getStringExtra(EXTRA_DEVICE_ADDRESS);
+        filePath = intent.getStringExtra(EXTRA_FILE_PATH);
+
+        // For each start request, send a message to start a job and deliver the
+        // start ID so we know which request we're stopping when we finish the job
+        Message msg = serviceHandler.obtainMessage();
+        msg.arg1 = startId;
+        serviceHandler.sendMessage(msg);
+
+        // If we get killed, after returning from here, restart
+        return START_STICKY;
+    }
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        // We don't provide binding, so return null
+        return null;
+    }
+
+    @Override
+    public void onDestroy() {
+        log(Log.WARN, "service done");
+        connectionState = STATE_CLOSED;
+        unregisterReceiver(bondStateReceiver);
+    }
+
+    @SuppressWarnings({"MissingPermission"})
+    private boolean isPartialFlashingServiceAvailable(BluetoothGatt gatt) {
+        log(Log.INFO, "Checking if the flashing services is available...");
+        BluetoothGattService partialFlashingService = gatt.getService(PARTIAL_FLASHING_SERVICE_UUID);
+        if (partialFlashingService == null) {
+            return false;
+
+        }
+
+        partialFlashingCharacteristic = partialFlashingService.getCharacteristic(PARTIAL_FLASHING_CHARACTERISTIC_UUID);
+        if (partialFlashingCharacteristic == null) {
+            gatt.disconnect();
+            return false;
+        }
+
+        if (!gatt.setCharacteristicNotification(partialFlashingCharacteristic, true)) {
+            log(Log.WARN, "setCharacteristicNotification FALSE");
+            return false;
+        }
+
+        BluetoothGattDescriptor descriptor = partialFlashingCharacteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG_UUID);
+        descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);
+        if (!gatt.writeDescriptor(descriptor)) {
+            log(Log.WARN, "writeDescriptor FALSE");
+            return false;
+        }
+
+        try {
+            synchronized (lock) {
+                while (!descriptorWriteSuccess)
+                    lock.wait();
+            }
+        } catch (final InterruptedException e) {
+            log(Log.ERROR, "Sleeping interrupted " + e);
+        }
+        return true;
+    }
+
+    private boolean sendStatusRequest(BluetoothGatt gatt) {
+        log(Log.INFO, "Send status request...");
+
+        boolean res = writeCharacteristic(gatt, (byte) 0xEE);
+        try {
+            synchronized (lock) {
+                while (!statusRequestSuccess)
+                    lock.wait();
+            }
+        } catch (final InterruptedException e) {
+            log(Log.ERROR, "Sleeping interrupted " + e);
+        }
+        return res;
+    }
+
+    private boolean sendHashRequest(BluetoothGatt gatt) {
+        log(Log.INFO, "Send hash request...");
+
+        boolean res = writeCharacteristic(gatt, (byte) 0x00, (byte) 0x01);
+        try {
+            synchronized (lock) {
+                while (!hashRequestSuccess)
+                    lock.wait();
+            }
+        } catch (final InterruptedException e) {
+            log(Log.ERROR, "Sleeping interrupted " + e);
+        }
+        return res;
+    }
+
+
+    private int attemptPartialFlashing(BluetoothGatt gatt) {
+        if (!isPartialFlashingServiceAvailable(gatt)) {
+            return ATTEMPT_ENTER_DFU;
+        }
+
+        if (!sendStatusRequest(gatt)) {
+            return ATTEMPT_ENTER_DFU;
+        }
+
+        if (!sendHashRequest(gatt)) {
+            return ATTEMPT_ENTER_DFU;
+        }
+
+        if (dalHash == null) {
+            return ATTEMPT_ENTER_DFU;
+        }
+        long startTime = SystemClock.elapsedRealtime();
+        int count = 0;
+        int numOfLines = 0;
+
+
+        try {
+            log(Log.DEBUG, "Attempt Partial Flashing");
+            log(Log.DEBUG, "File path: " + filePath);
+
+            HexUtils hex = new HexUtils(filePath);
+
+            // шукаємо індекс магічного magic number після йкого в нас записаний хеш
+            int magicIndex = hex.searchForData(PXT_MAGIC);
+            log(Log.DEBUG, "Magic Index: " + magicIndex);
+
+            // Якщо не знайдено пробуємо шукати для нового типу прошивки
+            if (magicIndex == -1) {
+                magicIndex = hex.searchForDataRegEx(UPY_MAGIC) - 3;
+                log(Log.DEBUG, "Magic Index: " + magicIndex);
+            }
+
+            // тут якщо ми щось таки знайшли працюємо далі, а якщо ні, то ніякого часткого перепрошиття не може бути
+            if (magicIndex > -1) {
+
+                log(Log.DEBUG, "Found magic");
+
+                // дивимося довжину рядка за цим індексом,
+
+                int record_length = hex.getRecordDataLengthFromIndex(magicIndex);
+                log(Log.DEBUG, "Length of record: " + record_length);
+
+                //вістановлюємо відступ, до розміщення хешу, чому в іншому випадку 0? UPY_MAGIC це частина хешу?
+                int magic_offset = (record_length == 64) ? 32 : 0;
+
+                // тут вже ми отримуємо сам хеш
+                String hashes = hex.getDataFromIndex(magicIndex + ((record_length == 64) ? 0 : 1)); // Size of rows
+
+                log(Log.DEBUG, "Hashes: " + hashes);
+
+                //Обрізаємо рядок з хешем і порівнюємо з отриманим з борда
+                if (!hashes.substring(magic_offset, magic_offset + 16).equals(dalHash)) {
+                    log(Log.WARN, "No match: " + hashes.substring(magic_offset, magic_offset + 16) + " " + (dalHash));
+                    return ATTEMPT_ENTER_DFU;
+                }
+
+                //Flashing
+
+                numOfLines = hex.numOfLines() - magicIndex;
+                log(Log.VERBOSE, "Total lines: " + numOfLines);
+
+                String hexData;
+                int packetNum = 0;
+                int lineCount = 0;
+
+                log(Log.DEBUG, "Enter flashing loop");
+
+                while (true) {
+                    // Timeout if total is > 30 seconds
+                    if (SystemClock.elapsedRealtime() - startTime > 60000) {
+                        log(Log.WARN, "Partial flashing has timed out");
+                        return ATTEMPT_ENTER_DFU;
+                    }
+
+                    // Get next data to write
+                    hexData = hex.getDataFromIndex(magicIndex + lineCount);
+
+                    // Check if EOF
+                    if (hex.getRecordTypeFromIndex(magicIndex + lineCount) != 0) break;
+
+                    // Split into bytes
+                    int offsetToSend = 0;
+                    if (count == 0) {
+                        offsetToSend = hex.getRecordAddressFromIndex(magicIndex + lineCount);
+                    }
+
+                    if (count == 1) {
+                        offsetToSend = hex.getSegmentAddress(magicIndex + lineCount);
+                    }
+
+                    byte[] chunk = HexUtils.recordToByteArray(hexData, offsetToSend, packetNum);
+
+                    // Write without response
+                    // Wait for previous write to complete
+                    writeCharacteristic(gatt, chunk);
+
+                    // Sleep after 4 packets
+                    count++;
+                    if (count == 4) {
+                        count = 0;
+
+                        // Send broadcast while waiting
+                        int percent = Math.round((float) 100 * ((float) (lineCount) / (float) (numOfLines)));
+                        sendProgressBroadcast(percent);
+
+                        long timeout = SystemClock.elapsedRealtime();
+                        try {
+                            while (packetState == PACKET_STATE_WAITING) {
+                                synchronized (lock) {
+                                    lock.wait(5000);
+                                }
+                                // Timeout if longer than 5 seconds
+                                if ((SystemClock.elapsedRealtime() - timeout) > 5000) {
+                                    return ATTEMPT_FILED;
+                                }
+                            }
+                        } catch (final InterruptedException e) {
+                            log(Log.ERROR, "Sleeping interrupted, " + e);
+                        }
+
+                        packetState = PACKET_STATE_WAITING;
+                    } else {
+                        //waitFor(5);
+                        Thread.sleep(5);
+                    }
+
+                    // If notification is retransmit -> retransmit last block.
+                    // Else set start of new block
+                    if (packetState == PACKET_STATE_RETRANSMIT) {
+                        lineCount = lineCount - 4;
+                    } else {
+                        // Next line
+                        lineCount = lineCount + 1;
+                    }
+
+                    // Always increment packet #
+                    packetNum = packetNum + 1;
+
+                }
+
+                // Write End of Flash packet
+                byte[] endOfFlashPacket = {(byte) 0x02};
+                writeCharacteristic(gatt, endOfFlashPacket);
+
+                // Finished Writing
+                log(Log.DEBUG, "Flash Complete");
+                packetState = PACKET_STATE_COMPLETE_FLASH;
+                sendProgressBroadcast(100);
+                sendProgressBroadcastComplete();
+
+                // Time execution
+                long endTime = SystemClock.elapsedRealtime();
+                long elapsedMilliSeconds = endTime - startTime;
+                double elapsedSeconds = elapsedMilliSeconds / 1000.0;
+                log(Log.DEBUG, "Flash Time: " + (float) elapsedSeconds + " seconds");
+
+                return ATTEMPT_SUCCESS;
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        } catch (InterruptedException e) {
+            throw new RuntimeException(e);
+        }
+        return ATTEMPT_ENTER_DFU;
+    }
+
+    @SuppressWarnings({"MissingPermission"})
+    private boolean writeCharacteristic(BluetoothGatt gatt, byte... data) {
+        partialFlashingCharacteristic.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE);
+        partialFlashingCharacteristic.setValue(data);
+        return gatt.writeCharacteristic(partialFlashingCharacteristic);
+    }
+
+    public static String bytesToHex(byte[] bytes) {
+        StringBuilder hexString = new StringBuilder(2 * bytes.length);
+        for (byte b : bytes) {
+            String hex = String.format("%02X", b);
+            hexString.append(hex);
+        }
+        return hexString.toString();
+    }
+
+    private boolean isPermissionGranted(String... permissions) {
+        for (String permission : permissions) {
+            boolean granted = ContextCompat.checkSelfPermission(getApplicationContext(), permission) == PackageManager.PERMISSION_GRANTED;
+            if (!granted) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    @SuppressWarnings({"MissingPermission"})
+    private BluetoothGatt connect() {
+        log(Log.DEBUG, "Connecting to the device...");
+        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
+        if (adapter == null || !adapter.isEnabled()) {
+            return null;
+        }
+
+        connectionState = STATE_CONNECTING;
+        BluetoothDevice device = adapter.getRemoteDevice(deviceAddress);
+        bondState = device.getBondState();
+
+        BluetoothGatt gatt;
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+            gatt = device.connectGatt(this, false, gattCallback, BluetoothDevice.TRANSPORT_LE, BluetoothDevice.PHY_LE_1M_MASK | BluetoothDevice.PHY_LE_2M_MASK);
+        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+            gatt = device.connectGatt(this, false, gattCallback, BluetoothDevice.TRANSPORT_LE);
+        } else {
+            gatt = device.connectGatt(this, false, gattCallback);
+        }
+
+        // We have to wait until the device is connected and services are discovered
+        // Connection error may occur as well.
+        try {
+            synchronized (lock) {
+                while (connectionState == STATE_CONNECTING || connectionState == STATE_CONNECTED)
+                    lock.wait();
+            }
+        } catch (final InterruptedException e) {
+            log(Log.ERROR, "Sleeping interrupted " + e);
+        }
+        return gatt;
+    }
+
+    protected void clearServicesCache(BluetoothGatt gatt) {
+        try {
+            //noinspection JavaReflectionMemberAccess
+            final Method refresh = gatt.getClass().getMethod("refresh");
+            //noinspection ConstantConditions
+            final boolean success = (boolean) refresh.invoke(gatt);
+            log(Log.DEBUG, "Refreshing result: " + success);
+        } catch (final Exception e) {
+            log(Log.ERROR, "An exception occurred while refreshing device. " + e);
+        }
+        waitFor(DELAY_TO_CLEAR_CACHE);
+    }
+
+    protected void waitFor(final long millis) {
+        synchronized (lock) {
+            try {
+                log(Log.DEBUG, "Wait for " + millis + " millis");
+                lock.wait(millis);
+            } catch (final InterruptedException e) {
+                log(Log.ERROR, "Sleeping interrupted, " + e);
+            }
+        }
+    }
+
+    private void sendProgressBroadcast(final int progress) {
+        final Intent broadcast = new Intent(BROADCAST_PROGRESS);
+        broadcast.putExtra(EXTRA_PROGRESS, progress);
+        LocalBroadcastManager.getInstance(this).sendBroadcast(broadcast);
+    }
+
+    private void sendProgressBroadcastStart() {
+        log(Log.ASSERT, "Sending progress broadcast start");
+        final Intent broadcast = new Intent(BROADCAST_START);
+        LocalBroadcastManager.getInstance(this).sendBroadcast(broadcast);
+    }
+
+    private void sendProgressBroadcastComplete() {
+        log(Log.ASSERT, "Sending progress broadcast complete");
+        final Intent broadcast = new Intent(BROADCAST_COMPLETE);
+        LocalBroadcastManager.getInstance(this).sendBroadcast(broadcast);
+    }
+
+    private void sendProgressBroadcastFailed() {
+        log(Log.ASSERT, "Sending progress broadcast failed");
+        final Intent broadcast = new Intent(BROADCAST_PF_FAILED);
+        LocalBroadcastManager.getInstance(this).sendBroadcast(broadcast);
+    }
+
+    private void sendProgressBroadcastAttemptDfu() {
+        log(Log.ASSERT, "Sending progress broadcast attempt DFU");
+        final Intent broadcast = new Intent(BROADCAST_PF_ATTEMPT_DFU);
+        LocalBroadcastManager.getInstance(this).sendBroadcast(broadcast);
+    }
+
+    public void log(int priority, @NonNull String message) {
+        Log.println(priority, TAG, "### " + Thread.currentThread().getId() + " # " + message);
+    }
+}
\ No newline at end of file
