diff --git a/app/src/fdroid/java/com/amaze/filemanager/activities/MainActivity.java b/app/src/fdroid/java/com/amaze/filemanager/activities/MainActivity.java
index 05927a57d..1dbfa7222 100644
--- a/app/src/fdroid/java/com/amaze/filemanager/activities/MainActivity.java
+++ b/app/src/fdroid/java/com/amaze/filemanager/activities/MainActivity.java
@@ -20,20 +20,14 @@
 
 package com.amaze.filemanager.activities;
 
-import android.animation.Animator;
-import android.animation.AnimatorListenerAdapter;
-import android.animation.ObjectAnimator;
 import android.app.Activity;
 import android.app.ActivityManager;
 import android.content.BroadcastReceiver;
-import android.content.ComponentName;
 import android.content.ContentResolver;
 import android.content.ContentUris;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
-import android.content.IntentSender;
-import android.content.ServiceConnection;
 import android.content.pm.PackageManager;
 import android.content.res.Configuration;
 import android.database.Cursor;
@@ -41,22 +35,22 @@ import android.graphics.Color;
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
+import android.graphics.drawable.VectorDrawable;
 import android.hardware.usb.UsbManager;
 import android.media.RingtoneManager;
 import android.net.Uri;
 import android.os.AsyncTask;
 import android.os.Build;
 import android.os.Bundle;
-import android.os.CountDownTimer;
 import android.os.Environment;
 import android.os.Handler;
 import android.os.HandlerThread;
-import android.os.IBinder;
 import android.service.quicksettings.TileService;
 import android.support.annotation.NonNull;
 import android.support.design.widget.AppBarLayout;
 import android.support.design.widget.CoordinatorLayout;
 import android.support.design.widget.Snackbar;
+import android.support.graphics.drawable.VectorDrawableCompat;
 import android.support.v4.app.ActionBarDrawerToggle;
 import android.support.v4.app.ActivityCompat.OnRequestPermissionsResultCallback;
 import android.support.v4.app.Fragment;
@@ -66,30 +60,17 @@ import android.support.v4.content.ContextCompat;
 import android.support.v4.content.CursorLoader;
 import android.support.v4.content.Loader;
 import android.support.v4.widget.DrawerLayout;
-import android.support.v7.widget.AppCompatEditText;
-import android.support.v7.widget.Toolbar;
 import android.text.TextUtils;
-import android.util.DisplayMetrics;
-import android.util.Log;
-import android.view.Gravity;
 import android.view.KeyEvent;
 import android.view.Menu;
 import android.view.MenuInflater;
 import android.view.MenuItem;
 import android.view.View;
-import android.view.ViewAnimationUtils;
 import android.view.ViewGroup;
 import android.view.Window;
 import android.view.WindowManager;
-import android.view.animation.AccelerateDecelerateInterpolator;
-import android.view.animation.Animation;
-import android.view.animation.AnimationUtils;
 import android.view.animation.DecelerateInterpolator;
-import android.view.inputmethod.InputMethodManager;
-import android.widget.Button;
 import android.widget.FrameLayout;
-import android.widget.HorizontalScrollView;
-import android.widget.ImageButton;
 import android.widget.ImageView;
 import android.widget.LinearLayout;
 import android.widget.ListView;
@@ -122,14 +103,11 @@ import com.amaze.filemanager.fragments.ProcessViewer;
 import com.amaze.filemanager.fragments.SearchWorkerFragment;
 import com.amaze.filemanager.fragments.TabFragment;
 import com.amaze.filemanager.fragments.ZipViewer;
-import com.amaze.filemanager.fragments.preference_fragments.FoldersPref;
 import com.amaze.filemanager.fragments.preference_fragments.QuickAccessPref;
-import com.amaze.filemanager.services.CopyService;
-import com.amaze.filemanager.services.DeleteTask;
-import com.amaze.filemanager.services.EncryptService;
-import com.amaze.filemanager.services.asynctasks.CopyFileCheck;
-import com.amaze.filemanager.services.asynctasks.MoveFiles;
-import com.amaze.filemanager.services.ssh.SshConnectionPool;
+import com.amaze.filemanager.asynchronous.CopyService;
+import com.amaze.filemanager.asynchronous.DeleteTask;
+import com.amaze.filemanager.asynchronous.asynctasks.CopyFileCheck;
+import com.amaze.filemanager.asynchronous.asynctasks.MoveFiles;
 import com.amaze.filemanager.ui.dialogs.GeneralDialogCreation;
 import com.amaze.filemanager.ui.dialogs.RenameBookmark;
 import com.amaze.filemanager.ui.dialogs.RenameBookmark.BookmarkCallback;
@@ -138,9 +116,10 @@ import com.amaze.filemanager.ui.dialogs.SmbConnectDialog.SmbConnectionListener;
 import com.amaze.filemanager.ui.drawer.EntryItem;
 import com.amaze.filemanager.ui.drawer.Item;
 import com.amaze.filemanager.ui.drawer.SectionItem;
-import com.amaze.filemanager.ui.icons.IconUtils;
 import com.amaze.filemanager.ui.views.RoundedImageView;
 import com.amaze.filemanager.ui.views.ScrimInsetsRelativeLayout;
+import com.amaze.filemanager.ui.views.appbar.AppBar;
+import com.amaze.filemanager.ui.views.appbar.SearchView;
 import com.amaze.filemanager.utils.AppConfig;
 import com.amaze.filemanager.utils.BookSorter;
 import com.amaze.filemanager.utils.DataUtils;
@@ -170,20 +149,18 @@ import com.github.clans.fab.FloatingActionMenu;
 import com.readystatesoftware.systembartint.SystemBarTintManager;
 
 import java.io.File;
-import java.net.MalformedURLException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.regex.Pattern;
 
 import eu.chainfire.libsuperuser.Shell;
-import jcifs.smb.SmbFile;
 
 import static android.os.Build.VERSION.SDK_INT;
 import static com.amaze.filemanager.fragments.preference_fragments.Preffrag.PREFERENCE_SHOW_SIDEBAR_FOLDERS;
 import static com.amaze.filemanager.fragments.preference_fragments.Preffrag.PREFERENCE_SHOW_SIDEBAR_QUICKACCESSES;
 
-public class MainActivity extends BaseActivity implements OnRequestPermissionsResultCallback,
+public class MainActivity extends ThemedActivity implements OnRequestPermissionsResultCallback,
         SmbConnectionListener, DataChangeListener, BookmarkCallback,
         SearchWorkerFragment.HelperCallbacks, CloudConnectionCallbacks,
         LoaderManager.LoaderCallbacks<Cursor> {
@@ -205,7 +182,6 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
     public boolean mReturnIntent = false;
     public boolean useGridView, openzip = false;
     public boolean mRingtonePickerIntent = false, colourednavigation = false;
-    public Toolbar toolbar;
     public int skinStatusBar;
 
     public volatile int storage_count = 0; // number of storage available (internal/external/otg etc)
@@ -229,16 +205,19 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
     public ArrayList<String> oppatheList;
     public RelativeLayout drawerHeaderParent;
 
+    /**
+     * @deprecated use getCurrentMainFragment()
+     */
     public MainFragment mainFragment;
 
     public static final String KEY_PREF_OTG = "uri_usb_otg";
 
     private static final int image_selector_request_code = 31;
 
+    private AppBar appbar;
     //private HistoryManager history, grid;
     private Futils utils;
     private MainActivity mainActivity = this;
-    private IconUtils util;
     private Context con = this;
     private String zippath;
     private FragmentTransaction pending_fragmentTransaction;
@@ -257,10 +236,6 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
     private ImageLoader mImageLoader;
 
     private TextView mGoogleName, mGoogleId;
-    private LinearLayout buttons;
-    private HorizontalScrollView scroll, scroll1;
-    private CountDownTimer timer;
-    private IconUtils icons;
     private TabHandler tabHandler;
     // Check for user interaction for Google+ api only once
     private boolean mGoogleApiKey = false;
@@ -270,21 +245,12 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
     private boolean mIntentInProgress, showHidden = false;
     private AsyncTask<Void, Void, Boolean> cloudSyncTask;
 
-    // string builder object variables for pathBar animations
-    private StringBuffer newPathBuilder, oldPathBuilder;
     private AppBarLayout appBarLayout;
 
-    private static final int PATH_ANIM_START_DELAY = 0;
-    private static final int PATH_ANIM_END_DELAY = 0;
-
     //TODO make var names meaningful
     private static final int SELECT_MINUS_2 = -2, NO_VALUE = -1, SELECT_0 = 0, SELECT_102 = 102;
     private int selectedStorage;
 
-    private int TOOLBAR_START_INSET;
-    private RelativeLayout searchViewLayout;
-    private AppCompatEditText searchViewEditText;
-    private int[] searchCoords = new int[2];
     private CoordinatorLayout mScreenLayout;
     private View fabBgView;
     private UtilsHandler utilsHandler;
@@ -304,13 +270,10 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
     // the current visible tab, either 0 or 1
     public static int currentTab;
 
-    public static boolean isSearchViewEnabled = false;
     public static Shell.Interactive shellInteractive;
     public static Handler handler;
 
     private static HandlerThread handlerThread;
-    public boolean isEncryptOpen = false;       // do we have to open a file when service is begin destroyed
-    public BaseFile encryptBaseFile;            // the cached base file which we're to open, delete it later
 
     private static final int REQUEST_CODE_CLOUD_LIST_KEYS = 5463;
     private static final int REQUEST_CODE_CLOUD_LIST_KEY = 5472;
@@ -329,9 +292,17 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
         dataUtils.registerOnDataChangedListener(this);
 
         setContentView(R.layout.main_toolbar);
+        appbar = new AppBar(this, sharedPref, new SearchView.SearchListener() {
+            @Override
+            public void onSearch(String queue) {
+                if(!queue.isEmpty()) {
+                    mainActivityHelper.search(queue);
+                }
+            }
+        });
         initialiseViews();
         tabHandler = new TabHandler(this);
-        utilsHandler = AppConfig.getInstance().getUtilsHandler();
+        utilsHandler = new UtilsHandler(this);
         cloudHandler = new CloudHandler(this);
 
         mImageLoader = AppConfig.getInstance().getImageLoader();
@@ -344,51 +315,64 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
             getSupportLoaderManager().initLoader(REQUEST_CODE_CLOUD_LIST_KEYS, null, this);
         }
 
-        util = new IconUtils(sharedPref, this);
-        icons = new IconUtils(sharedPref, this);
-
-        timer = new CountDownTimer(5000, 1000) {
-            @Override
-            public void onTick(long l) {
-            }
-
-            @Override
-            public void onFinish() {
-                utils.crossfadeInverse(buttons, pathbar);
-            }
-        };
         path = getIntent().getStringExtra("path");
         openProcesses = getIntent().getBooleanExtra(KEY_INTENT_PROCESS_VIEWER, false);
-        try {
-            intent = getIntent();
-            if (intent.getStringArrayListExtra(TAG_INTENT_FILTER_FAILED_OPS) != null) {
-                ArrayList<BaseFile> failedOps = intent.getParcelableArrayListExtra(TAG_INTENT_FILTER_FAILED_OPS);
-                if (failedOps != null) {
-                    mainActivityHelper.showFailedOperationDialog(failedOps, intent.getBooleanExtra("move", false), this);
-                }
-            }
-            if (intent.getAction() != null) {
-                if (intent.getAction().equals(Intent.ACTION_GET_CONTENT)) {
-
-                    // file picker intent
-                    mReturnIntent = true;
-                    Toast.makeText(this, getString(R.string.pick_a_file), Toast.LENGTH_LONG).show();
-                } else if (intent.getAction().equals(RingtoneManager.ACTION_RINGTONE_PICKER)) {
-                    // ringtone picker intent
-                    mReturnIntent = true;
-                    mRingtonePickerIntent = true;
-                    Toast.makeText(this, getString(R.string.pick_a_file), Toast.LENGTH_LONG).show();
-                } else if (intent.getAction().equals(Intent.ACTION_VIEW)) {
-
-                    // zip viewer intent
-                    Uri uri = intent.getData();
-                    openzip = true;
-                    zippath = uri.toString();
-                }
+        intent = getIntent();
+
+        String actionIntent = intent.getAction();
+        String typeIntent = intent.getType();
+        if (intent.getStringArrayListExtra(TAG_INTENT_FILTER_FAILED_OPS) != null) {
+            ArrayList<BaseFile> failedOps = intent.getParcelableArrayListExtra(TAG_INTENT_FILTER_FAILED_OPS);
+            if (failedOps != null) {
+                mainActivityHelper.showFailedOperationDialog(failedOps, intent.getBooleanExtra("move", false), this);
             }
-        } catch (Exception e) {
+        }
+        if (actionIntent != null) {
+            if (actionIntent.equals(Intent.ACTION_GET_CONTENT)) {
 
-            e.printStackTrace();
+                // file picker intent
+                mReturnIntent = true;
+                Toast.makeText(this, getString(R.string.pick_a_file), Toast.LENGTH_LONG).show();
+
+                // disable screen rotation just for convenience purpose
+                // TODO: Support screen rotation when picking file
+                Utils.disableScreenRotation(this);
+            } else if (actionIntent.equals(RingtoneManager.ACTION_RINGTONE_PICKER)) {
+                // ringtone picker intent
+                mReturnIntent = true;
+                mRingtonePickerIntent = true;
+                Toast.makeText(this, getString(R.string.pick_a_file), Toast.LENGTH_LONG).show();
+
+                // disable screen rotation just for convenience purpose
+                // TODO: Support screen rotation when picking file
+                Utils.disableScreenRotation(this);
+            } else if (actionIntent.equals(Intent.ACTION_VIEW)) {
+
+                // zip viewer intent
+                Uri uri = intent.getData();
+                openzip = true;
+                zippath = uri.toString();
+            } else if (actionIntent.equals(Intent.ACTION_SEND) && typeIntent != null) {
+                // save a single file to filesystem
+
+                Uri uri = intent.getParcelableExtra(Intent.EXTRA_STREAM);
+                ArrayList<Uri> uris = new ArrayList<>();
+                uris.add(uri);
+                initFabToSave(uris);
+
+                // disable screen rotation just for convenience purpose
+                // TODO: Support screen rotation when saving a file
+                Utils.disableScreenRotation(this);
+            } else if (actionIntent.equals(Intent.ACTION_SEND_MULTIPLE) && typeIntent != null) {
+                // save multiple files to filesystem
+
+                ArrayList<Uri> arrayList = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);
+                initFabToSave(arrayList);
+
+                // disable screen rotation just for convenience purpose
+                // TODO: Support screen rotation when saving a file
+                Utils.disableScreenRotation(this);
+            }
         }
 
         if (savedInstanceState != null) {
@@ -482,7 +466,7 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
 
                 if (savedInstanceState == null) {
                     if (openProcesses) {
-                        android.support.v4.app.FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
+                        FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
                         transaction.replace(R.id.content_frame, new ProcessViewer(), KEY_INTENT_PROCESS_VIEWER);
                         //transaction.addToBackStack(null);
                         selectedStorage = SELECT_102;
@@ -495,9 +479,9 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
                             intent.getAction().equals(TileService.ACTION_QS_TILE_PREFERENCES)) {
                         // tile preferences, open ftp fragment
 
-                        android.support.v4.app.FragmentTransaction transaction2 = getSupportFragmentManager().beginTransaction();
+                        FragmentTransaction transaction2 = getSupportFragmentManager().beginTransaction();
                         transaction2.replace(R.id.content_frame, new FTPServerFragment());
-                        findViewById(R.id.lin).animate().translationY(0).setInterpolator(new DecelerateInterpolator(2)).start();
+                        appBarLayout.animate().translationY(0).setInterpolator(new DecelerateInterpolator(2)).start();
 
                         selectedStorage = SELECT_MINUS_2;
                         adapter.toggleChecked(false);
@@ -548,6 +532,40 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
         });
     }
 
+    /**
+     * Initializes the floating action button to act as to save data from an external intent
+     */
+    private void initFabToSave(final ArrayList<Uri> uris) {
+
+        floatingActionButton.setVisibility(View.VISIBLE);
+
+        Drawable drawable = getResources().getDrawable(R.drawable.ic_file_download_black_24dp);
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            VectorDrawable vectorDrawable = (VectorDrawable) drawable;
+            vectorDrawable.setTint(getResources().getColor(android.R.color.white));
+
+            floatingActionButton.getMenuIconView().setImageDrawable(vectorDrawable);
+        } else {
+
+            VectorDrawableCompat vectorDrawableCompat = (VectorDrawableCompat) drawable;
+            vectorDrawableCompat.setTint(getResources().getColor(android.R.color.white));
+
+            floatingActionButton.getMenuIconView().setImageDrawable(vectorDrawableCompat);
+        }
+
+
+        floatingActionButton.setOnMenuButtonClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+
+                FileUtil.writeUriToStorage(MainActivity.this, uris, getContentResolver(), getCurrentMainFragment().getCurrentPath());
+                Toast.makeText(MainActivity.this, getResources().getString(R.string.saving), Toast.LENGTH_LONG).show();
+                finish();
+            }
+        });
+    }
+
     /**
      * Initializes an interactive shell, which will stay throughout the app lifecycle
      * The shell is associated with a handler thread which maintain the message queue from the
@@ -570,7 +588,7 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
                     closeInteractiveShell();
                     sharedPref.edit().putBoolean(PreferenceUtils.KEY_ROOT, false).apply();
                 }
-            } catch (RootNotPermittedException e) {
+            } catch (ShellNotRunningException e) {
                 e.printStackTrace();
                 sharedPref.edit().putBoolean(PreferenceUtils.KEY_ROOT, false).apply();
             }*/
@@ -644,7 +662,7 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
                     rv.add(s);
             }
         }
-        if (BaseActivity.rootMode)
+        if (ThemedActivity.rootMode)
             rv.add("/");
         File usb = getUsbDrive();
         if (usb != null && !rv.contains(usb.getPath())) rv.add(usb.getPath());
@@ -687,58 +705,51 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
     }
 
     void onbackpressed() {
-        try {
-            Fragment fragment = getSupportFragmentManager().findFragmentById(R.id.content_frame);
-            String name = fragment.getClass().getName();
-            if (searchViewLayout.isShown()) {
-                // hide search view if visible, with an animation
-                hideSearchView();
-            } else if (name.contains("TabFragment")) {
-                if (floatingActionButton.isOpened()) {
-                    floatingActionButton.close(true);
-                } else {
-                    TabFragment tabFragment = ((TabFragment) getSupportFragmentManager().findFragmentById(R.id.content_frame));
-                    Fragment fragment1 = tabFragment.getTab();
-                    MainFragment mainFrag = (MainFragment) fragment1;
-                    mainFrag.goBack();
-                }
-            } else if (name.contains("ZipViewer")) {
-                ZipViewer zipViewer = (ZipViewer) getSupportFragmentManager().findFragmentById(R.id.content_frame);
-                if (zipViewer.mActionMode == null) {
-                    if (zipViewer.canGoBack()) {
-                        zipViewer.goBack();
-                    } else if (openzip) {
-                        openzip = false;
-                        finish();
-                    } else {
-                        FragmentTransaction fragmentTransaction = getSupportFragmentManager().beginTransaction();
-                        fragmentTransaction.setCustomAnimations(R.anim.slide_out_bottom, R.anim.slide_out_bottom);
-                        fragmentTransaction.remove(zipViewer);
-                        fragmentTransaction.commit();
-                        supportInvalidateOptionsMenu();
-                        floatingActionButton.setVisibility(View.VISIBLE);
-                        floatingActionButton.showMenuButton(true);
-                    }
+        Fragment fragment = getFragmentAtFrame();
+        if (getAppbar().getSearchView().isShown()) {
+            // hide search view if visible, with an animation
+            getAppbar().getSearchView().hideSearchView();
+        } else if (fragment instanceof TabFragment) {
+            if (floatingActionButton.isOpened()) {
+                floatingActionButton.close(true);
+            } else {
+                getCurrentMainFragment().goBack();
+            }
+        } else if (fragment instanceof ZipViewer) {
+            ZipViewer zipViewer = (ZipViewer) getSupportFragmentManager().findFragmentById(R.id.content_frame);
+            if (zipViewer.mActionMode == null) {
+                if (zipViewer.canGoBack()) {
+                    zipViewer.goBack();
+                } else if (openzip) {
+                    openzip = false;
+                    finish();
                 } else {
-                    zipViewer.mActionMode.finish();
+                    FragmentTransaction fragmentTransaction = getSupportFragmentManager().beginTransaction();
+                    fragmentTransaction.setCustomAnimations(R.anim.slide_out_bottom, R.anim.slide_out_bottom);
+                    fragmentTransaction.remove(zipViewer);
+                    fragmentTransaction.commit();
+                    supportInvalidateOptionsMenu();
+                    floatingActionButton.setVisibility(View.VISIBLE);
+                    floatingActionButton.showMenuButton(true);
                 }
-            } else if (name.contains("FTPServerFragment")) {
-                //returning back from FTP server
-                if (path != null && path.length() > 0) {
-                    HFile file = new HFile(OpenMode.UNKNOWN, path);
-                    file.generateMode(this);
-                    if (file.isDirectory(this))
-                        goToMain(path);
-                    else {
-                        goToMain("");
-                        utils.openFile(new File(path), this);
-                    }
-                } else {
+            } else {
+                zipViewer.mActionMode.finish();
+            }
+        } else if (fragment instanceof FTPServerFragment) {
+            //returning back from FTP server
+            if (path != null && path.length() > 0) {
+                HFile file = new HFile(OpenMode.UNKNOWN, path);
+                file.generateMode(this);
+                if (file.isDirectory(this))
+                    goToMain(path);
+                else {
                     goToMain("");
+                    utils.openFile(new File(path), this);
                 }
-            } else
+            } else {
                 goToMain("");
-        } catch (ClassCastException e) {
+            }
+        } else {
             goToMain("");
         }
     }
@@ -753,9 +764,8 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
 
     public void exit() {
         if (backPressedToExitOnce) {
-            SshConnectionPool.getInstance().expungeAllConnections();
             finish();
-            if (BaseActivity.rootMode) {
+            if (ThemedActivity.rootMode) {
                 // TODO close all shells
             }
         } else {
@@ -825,7 +835,7 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
         selectedStorage = SELECT_0;
         transaction.addToBackStack("tabt" + 1);
         transaction.commitAllowingStateLoss();
-        setActionBarTitle(null);
+        appbar.setTitle(null);
         floatingActionButton.setVisibility(View.VISIBLE);
         floatingActionButton.showMenuButton(true);
         if (openzip && zippath != null) {
@@ -910,11 +920,6 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
         return super.onCreateOptionsMenu(menu);
     }
 
-    public void setActionBarTitle(String title) {
-        if (toolbar != null)
-            toolbar.setTitle(title);
-    }
-
     @Override
     public boolean onPrepareOptionsMenu(Menu menu) {
         MenuItem s = menu.findItem(R.id.view);
@@ -929,7 +934,7 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
             return true;
         }
         if (fragmentName.contains("TabFragment")) {
-            setActionBarTitle("Amaze");
+            appbar.setTitle("Amaze");
             if (useGridView) {
                 s.setTitle(getResources().getString(R.string.gridview));
             } else {
@@ -937,14 +942,14 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
             }
             try {
                 TabFragment tabFragment = (TabFragment) fragment;
-                MainFragment ma = ((MainFragment) tabFragment.getTab());
+                MainFragment ma = getCurrentMainFragment();
                 if (ma.IS_LIST) s.setTitle(R.string.gridview);
                 else s.setTitle(R.string.listview);
-                updatePath(ma.getCurrentPath(), ma.results, ma.openMode, ma.folder_count, ma.file_count);
+                appbar.getBottomBar().updatePath(ma.getCurrentPath(), ma.results, MainActivityHelper.SEARCH_TEXT, ma.openMode, ma.folder_count, ma.file_count);
             } catch (Exception e) {}
 
-            initiatebbar();
-            if (SDK_INT >= 21) toolbar.setElevation(0);
+            appbar.getBottomBar().setClickListener();
+
             invalidatePasteButton(paste);
             search.setVisible(true);
             if (indicator_layout != null) indicator_layout.setVisibility(View.VISIBLE);
@@ -979,17 +984,7 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
         } else if (fragmentName.contains("ZipViewer")) {
             menu.findItem(R.id.sethome).setVisible(false);
             if (indicator_layout != null) indicator_layout.setVisibility(View.GONE);
-            TextView textView = (TextView) mainActivity.pathbar.findViewById(R.id.fullpath);
-            pathbar.setOnClickListener(new View.OnClickListener() {
-                @Override
-                public void onClick(View view) {
-                }
-            });
-            textView.setOnClickListener(new View.OnClickListener() {
-                @Override
-                public void onClick(View view) {
-                }
-            });
+            getAppbar().getBottomBar().resetClickListener();
             menu.findItem(R.id.search).setVisible(false);
             menu.findItem(R.id.home).setVisible(false);
             menu.findItem(R.id.history).setVisible(false);
@@ -1032,12 +1027,7 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
             return true;
         }
         // Handle action buttons
-        MainFragment ma = null;
-        try {
-            TabFragment tabFragment = getFragment();
-            if (tabFragment != null)
-                ma = (MainFragment) tabFragment.getTab();
-        } catch (Exception e) {}
+        MainFragment ma = getCurrentMainFragment();
 
         switch (item.getItemId()) {
             case R.id.home:
@@ -1055,7 +1045,7 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
                     Toast.makeText(mainActivity, R.string.not_allowed, Toast.LENGTH_SHORT).show();
                     break;
                 }
-                final MaterialDialog dialog = GeneralDialogCreation.showBasicDialog(mainActivity, BaseActivity.accentSkin, getAppTheme(),
+                final MaterialDialog dialog = GeneralDialogCreation.showBasicDialog(mainActivity,
                         new String[]{getResources().getString(R.string.questionset),
                                 getResources().getString(R.string.setashome), getResources().getString(R.string.yes), getResources().getString(R.string.no), null});
                 dialog.getActionButton(DialogAction.POSITIVE).setOnClickListener(new View.OnClickListener() {
@@ -1072,7 +1062,7 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
                 finish();
                 break;
             case R.id.sort:
-                Fragment fragment = getDFragment();
+                Fragment fragment = getFragmentAtFrame();
                 if (fragment.getClass().getName().contains("AppsList"))
                     GeneralDialogCreation.showSortDialog((AppsList) fragment, getAppTheme());
                 break;
@@ -1156,7 +1146,7 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
                 String path = ma.getCurrentPath();
                 ArrayList<BaseFile> arrayList = COPY_PATH != null? COPY_PATH:MOVE_PATH;
                 boolean move = MOVE_PATH != null;
-                new CopyFileCheck(ma, path, move, mainActivity, BaseActivity.rootMode)
+                new CopyFileCheck(ma, path, move, mainActivity, ThemedActivity.rootMode)
                         .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, arrayList);
                 COPY_PATH = null;
                 MOVE_PATH = null;
@@ -1168,97 +1158,12 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
                     mainActivityHelper.extractFile(((ZipViewer) fragment1).f);
                 break;
             case R.id.search:
-                View searchItem = toolbar.findViewById(R.id.search);
-                searchViewEditText.setText("");
-                searchItem.getLocationOnScreen(searchCoords);
-                revealSearchView();
+                getAppbar().getSearchView().revealSearchView();
                 break;
         }
         return super.onOptionsItemSelected(item);
     }
 
-    /**
-     * show search view with a circular reveal animation
-     */
-    void revealSearchView() {
-        final int START_RADIUS = 16;
-        int endRadius = Math.max(toolbar.getWidth(), toolbar.getHeight());
-
-        Animator animator;
-        if (SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {
-            animator = ViewAnimationUtils.createCircularReveal(searchViewLayout,
-                    searchCoords[0] + 32, searchCoords[1] - 16, START_RADIUS, endRadius);
-        } else {
-            // TODO:ViewAnimationUtils.createCircularReveal
-            animator = ObjectAnimator.ofFloat(searchViewLayout, "alpha", 0f, 1f);
-        }
-
-        utils.revealShow(fabBgView, true);
-
-        animator.setInterpolator(new AccelerateDecelerateInterpolator());
-        animator.setDuration(600);
-        searchViewLayout.setVisibility(View.VISIBLE);
-        animator.start();
-        animator.addListener(new Animator.AnimatorListener() {
-            @Override
-            public void onAnimationStart(Animator animation) {}
-
-            @Override
-            public void onAnimationEnd(Animator animation) {
-                searchViewEditText.requestFocus();
-                InputMethodManager imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
-                imm.showSoftInput(searchViewEditText, InputMethodManager.SHOW_IMPLICIT);
-                isSearchViewEnabled = true;
-            }
-
-            @Override
-            public void onAnimationCancel(Animator animation) {}
-
-            @Override
-            public void onAnimationRepeat(Animator animation) {}
-        });
-    }
-
-    /**
-     * hide search view with a circular reveal animation
-     */
-    public void hideSearchView() {
-        final int END_RADIUS = 16;
-        int startRadius = Math.max(searchViewLayout.getWidth(), searchViewLayout.getHeight());
-        Animator animator;
-        if (SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {
-            animator = ViewAnimationUtils.createCircularReveal(searchViewLayout,
-                    searchCoords[0] + 32, searchCoords[1] - 16, startRadius, END_RADIUS);
-        } else {
-            // TODO: ViewAnimationUtils.createCircularReveal
-            animator = ObjectAnimator.ofFloat(searchViewLayout, "alpha", 1f, 0f);
-        }
-
-        // removing background fade view
-        utils.revealShow(fabBgView, false);
-        animator.setInterpolator(new AccelerateDecelerateInterpolator());
-        animator.setDuration(600);
-        animator.start();
-        animator.addListener(new Animator.AnimatorListener() {
-            @Override
-            public void onAnimationStart(Animator animation) {}
-
-            @Override
-            public void onAnimationEnd(Animator animation) {
-                searchViewLayout.setVisibility(View.GONE);
-                isSearchViewEnabled = false;
-                InputMethodManager inputMethodManager = (InputMethodManager) getSystemService(INPUT_METHOD_SERVICE);
-                inputMethodManager.hideSoftInputFromWindow(searchViewEditText.getWindowToken(), InputMethodManager.HIDE_IMPLICIT_ONLY);
-            }
-
-            @Override
-            public void onAnimationCancel(Animator animation) {}
-
-            @Override
-            public void onAnimationRepeat(Animator animation) {}
-        });
-    }
-
     /*@Override
     public void onRestoreInstanceState(Bundle savedInstanceState){
         COPY_PATH=savedInstanceState.getStringArrayList("COPY_PATH");
@@ -1311,9 +1216,6 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
         unregisterReceiver(mainActivityHelper.mNotificationReceiver);
         unregisterReceiver(receiver2);
 
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT)
-            unbindService(mEncryptServiceConnection);
-
         if (SDK_INT >= Build.VERSION_CODES.KITKAT) {
             unregisterReceiver(mOtgReceiver);
         }
@@ -1342,56 +1244,8 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
             otgFilter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);
             registerReceiver(mOtgReceiver, otgFilter);
         }
-
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
-            // let's register encryption service to know when we've decrypted
-            Intent encryptIntent = new Intent(this, EncryptService.class);
-            bindService(encryptIntent, mEncryptServiceConnection, 0);
-
-            if (!isEncryptOpen && encryptBaseFile != null) {
-                // we've opened the file and are ready to delete it
-                // don't move this to ondestroy as we'll be getting destroyed and starting
-                // an async task just before it is not a good idea
-                ArrayList<BaseFile> baseFiles = new ArrayList<>();
-                baseFiles.add(encryptBaseFile);
-                new DeleteTask(getContentResolver(), this).execute(baseFiles);
-            }
-        }
     }
 
-    ServiceConnection mEncryptServiceConnection = new ServiceConnection() {
-        @Override
-        public void onServiceConnected(ComponentName name, IBinder service) {
-
-        }
-
-        @Override
-        public void onServiceDisconnected(ComponentName name) {
-
-            if (isEncryptOpen && encryptBaseFile != null) {
-                if (mainFragment != null) {
-                    switch (mainFragment.openMode) {
-                        case OTG:
-                            getFutils().openFile(OTGUtil.getDocumentFile(encryptBaseFile.getPath(),
-                                    MainActivity.this, false), MainActivity.this);
-                            break;
-                        case SMB:
-                            try {
-                                MainFragment.launchSMB(new SmbFile(encryptBaseFile.getPath()),
-                                        encryptBaseFile.getSize(), MainActivity.this);
-                            } catch (MalformedURLException e) {
-                                e.printStackTrace();
-                            }
-                        default:
-                            getFutils().openFile(new File(encryptBaseFile.getPath()), MainActivity.this);
-                    }
-                } else
-                    getFutils().openFile(new File(encryptBaseFile.getPath()), MainActivity.this);
-                isEncryptOpen = false;
-            }
-        }
-    };
-
     /**
      * Receiver to check if a USB device is connected at the runtime of application
      * If device is not connected at runtime (i.e. it was connected when the app was closed)
@@ -1442,8 +1296,6 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
         CryptHandler cryptHandler = new CryptHandler(this);
         cryptHandler.close();
 
-        SshConnectionPool.getInstance().expungeAllConnections();
-
         /*if (mainFragment!=null)
             mainFragment = null;*/
     }
@@ -1463,13 +1315,13 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
     }
 
     public void updatePaths(int pos) {
-        TabFragment tabFragment = getFragment();
+        TabFragment tabFragment = getTabFragment();
         if (tabFragment != null)
             tabFragment.updatepaths(pos);
     }
 
     public void openZip(String path) {
-        findViewById(R.id.lin).animate().translationY(0).setInterpolator(new DecelerateInterpolator(2)).start();
+        appBarLayout.animate().translationY(0).setInterpolator(new DecelerateInterpolator(2)).start();
         FragmentTransaction fragmentTransaction = getSupportFragmentManager().beginTransaction();
         fragmentTransaction.setCustomAnimations(R.anim.slide_in_top, R.anim.slide_in_bottom);
         Fragment zipFragment = new ZipViewer();
@@ -1484,19 +1336,27 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
         openZip(path);
     }
 
-    public TabFragment getFragment() {
-        Fragment fragment = getDFragment();
+    public MainFragment getCurrentMainFragment() {
+        TabFragment tab = getTabFragment();
 
-        if (fragment == null || !(fragment instanceof TabFragment)) return null;
+        if(tab != null && tab.getCurrentTabFragment() instanceof MainFragment) {
+            return (MainFragment) tab.getCurrentTabFragment();
+        } else return null;
+    }
+
+    public TabFragment getTabFragment() {
+        Fragment fragment = getFragmentAtFrame();
+
+        if (!(fragment instanceof TabFragment)) return null;
         else return (TabFragment) fragment;
     }
 
-    public Fragment getDFragment() {
+    public Fragment getFragmentAtFrame() {
         return getSupportFragmentManager().findFragmentById(R.id.content_frame);
     }
 
     public void setPagingEnabled(boolean b) {
-        getFragment().mViewPager.setPagingEnabled(b);
+        getTabFragment().mViewPager.setPagingEnabled(b);
     }
 
     public File getUsbDrive() {
@@ -1526,17 +1386,17 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
         for (String file : storageDirectories) {
             File f = new File(file);
             String name;
-            Drawable icon1 = ContextCompat.getDrawable(MainActivity.this, R.drawable.ic_sd_storage_white_56dp);
+            Drawable icon1 = ContextCompat.getDrawable(this, R.drawable.ic_sd_storage_white_56dp);
             if ("/storage/emulated/legacy".equals(file) || "/storage/emulated/0".equals(file)) {
                 name = getResources().getString(R.string.storage);
             } else if ("/storage/sdcard1".equals(file)) {
                 name = getResources().getString(R.string.extstorage);
             } else if ("/".equals(file)) {
                 name = getResources().getString(R.string.rootdirectory);
-                icon1 = ContextCompat.getDrawable(MainActivity.this, R.drawable.ic_drawer_root_white);
+                icon1 = ContextCompat.getDrawable(this, R.drawable.ic_drawer_root_white);
             } else if (file.contains(OTGUtil.PREFIX_OTG)) {
                 name = "OTG";
-                icon1 = ContextCompat.getDrawable(MainActivity.this, R.drawable.ic_usb_white_48dp);
+                icon1 = ContextCompat.getDrawable(this, R.drawable.ic_usb_white_48dp);
             } else name = f.getName();
             if (!f.isDirectory() || f.canExecute()) {
                 storage_count++;
@@ -1549,25 +1409,23 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
         if (dataUtils.getServers().size() > 0) {
             Collections.sort(dataUtils.getServers(), new BookSorter());
             synchronized (dataUtils.getServers()) {
-
-                for (String[] file : dataUtils.getServers())
-                    sectionItems.add(new EntryItem(file[0], file[1], ContextCompat.getDrawable(MainActivity.this,
+                for (String[] file : dataUtils.getServers()) {
+                    sectionItems.add(new EntryItem(file[0], file[1], ContextCompat.getDrawable(this,
                             R.drawable.ic_settings_remote_white_48dp)));
+                }
             }
             sectionItems.add(new SectionItem());
         }
 
         ArrayList<String[]> accountAuthenticationList = new ArrayList<>();
 
-        if (CloudSheetFragment.isCloudProviderAvailable(MainActivity.this)) {
-
+        if (CloudSheetFragment.isCloudProviderAvailable(this)) {
             for (CloudStorage cloudStorage : dataUtils.getAccounts()) {
-
                 if (cloudStorage instanceof Dropbox) {
 
                     sectionItems.add(new EntryItem(CloudHandler.CLOUD_NAME_DROPBOX,
                             CloudHandler.CLOUD_PREFIX_DROPBOX + "/",
-                            ContextCompat.getDrawable(MainActivity.this, R.drawable.ic_dropbox_white_24dp)));
+                            ContextCompat.getDrawable(this, R.drawable.ic_dropbox_white_24dp)));
 
                     accountAuthenticationList.add(new String[] {
                             CloudHandler.CLOUD_NAME_DROPBOX,
@@ -1577,7 +1435,7 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
 
                     sectionItems.add(new EntryItem(CloudHandler.CLOUD_NAME_BOX,
                             CloudHandler.CLOUD_PREFIX_BOX + "/",
-                            ContextCompat.getDrawable(MainActivity.this, R.drawable.ic_box_white_24dp)));
+                            ContextCompat.getDrawable(this, R.drawable.ic_box_white_24dp)));
 
                     accountAuthenticationList.add(new String[] {
                             CloudHandler.CLOUD_NAME_BOX,
@@ -1587,7 +1445,7 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
 
                     sectionItems.add(new EntryItem(CloudHandler.CLOUD_NAME_ONE_DRIVE,
                             CloudHandler.CLOUD_PREFIX_ONE_DRIVE + "/",
-                            ContextCompat.getDrawable(MainActivity.this, R.drawable.ic_onedrive_white_24dp)));
+                            ContextCompat.getDrawable(this, R.drawable.ic_onedrive_white_24dp)));
 
                     accountAuthenticationList.add(new String[] {
                             CloudHandler.CLOUD_NAME_ONE_DRIVE,
@@ -1597,7 +1455,7 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
 
                     sectionItems.add(new EntryItem(CloudHandler.CLOUD_NAME_GOOGLE_DRIVE,
                             CloudHandler.CLOUD_PREFIX_GOOGLE_DRIVE + "/",
-                            ContextCompat.getDrawable(MainActivity.this, R.drawable.ic_google_drive_white_24dp)));
+                            ContextCompat.getDrawable(this, R.drawable.ic_google_drive_white_24dp)));
 
                     accountAuthenticationList.add(new String[] {
                             CloudHandler.CLOUD_NAME_GOOGLE_DRIVE,
@@ -1617,10 +1475,9 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
                 Collections.sort(dataUtils.getBooks(), new BookSorter());
 
                 synchronized (dataUtils.getBooks()) {
-
                     for (String[] file : dataUtils.getBooks()) {
                         sectionItems.add(new EntryItem(file[0], file[1],
-                                ContextCompat.getDrawable(MainActivity.this, R.drawable.folder_fab)));
+                                ContextCompat.getDrawable(this, R.drawable.folder_fab)));
                     }
                 }
                 sectionItems.add(new SectionItem());
@@ -1633,37 +1490,41 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
         if (sharedPref.getBoolean(PREFERENCE_SHOW_SIDEBAR_QUICKACCESSES, true)) {
             if (quickAccessPref[0])
                 sectionItems.add(new EntryItem(getResources().getString(R.string.quick), "5",
-                        ContextCompat.getDrawable(MainActivity.this, R.drawable.ic_star_white_18dp)));
+                        ContextCompat.getDrawable(this, R.drawable.ic_star_white_18dp)));
             if (quickAccessPref[1])
                 sectionItems.add(new EntryItem(getResources().getString(R.string.recent), "6",
-                        ContextCompat.getDrawable(MainActivity.this, R.drawable.ic_history_white_48dp)));
+                        ContextCompat.getDrawable(this, R.drawable.ic_history_white_48dp)));
             if (quickAccessPref[2])
                 sectionItems.add(new EntryItem(getResources().getString(R.string.images), "0",
-                        ContextCompat.getDrawable(MainActivity.this, R.drawable.ic_doc_image)));
+                        ContextCompat.getDrawable(this, R.drawable.ic_doc_image)));
             if (quickAccessPref[3])
                 sectionItems.add(new EntryItem(getResources().getString(R.string.videos), "1",
-                        ContextCompat.getDrawable(MainActivity.this, R.drawable.ic_doc_video_am)));
+                        ContextCompat.getDrawable(this, R.drawable.ic_doc_video_am)));
             if (quickAccessPref[4])
                 sectionItems.add(new EntryItem(getResources().getString(R.string.audio), "2",
-                        ContextCompat.getDrawable(MainActivity.this, R.drawable.ic_doc_audio_am)));
+                        ContextCompat.getDrawable(this, R.drawable.ic_doc_audio_am)));
             if (quickAccessPref[5])
                 sectionItems.add(new EntryItem(getResources().getString(R.string.documents), "3",
-                        ContextCompat.getDrawable(MainActivity.this, R.drawable.ic_doc_doc_am)));
+                        ContextCompat.getDrawable(this, R.drawable.ic_doc_doc_am)));
             if (quickAccessPref[6])
                 sectionItems.add(new EntryItem(getResources().getString(R.string.apks), "4",
-                        ContextCompat.getDrawable(MainActivity.this, R.drawable.ic_doc_apk_grid)));
+                        ContextCompat.getDrawable(this, R.drawable.ic_doc_apk_grid)));
         } else {
             sectionItems.remove(sectionItems.size() - 1); //Deletes last divider
         }
 
         dataUtils.setList(sectionItems);
 
-        adapter = new DrawerAdapter(MainActivity.this, MainActivity.this, sectionItems,
-                MainActivity.this, sharedPref);
+        adapter = new DrawerAdapter(this, this, sectionItems, this, sharedPref);
         mDrawerList.setAdapter(adapter);
     }
 
+    public AppBar getAppbar() {
+        return appbar;
+    }
+
     protected void onActivityResult(int requestCode, int responseCode, Intent intent) {
+
         if (requestCode == image_selector_request_code) {
             if (sharedPref != null && intent != null && intent.getData() != null) {
                 if (SDK_INT >= 19)
@@ -1725,22 +1586,22 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
                         oppathe = "";
                     }
 
-                    new MoveFiles(oparrayListList, ((MainFragment) getFragment().getTab()),
-                            getFragment().getTab().getActivity(), OpenMode.FILE)
+                    new MoveFiles(oparrayListList, getCurrentMainFragment(),
+                            getCurrentMainFragment().getActivity(), OpenMode.FILE)
                             .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, oppatheList);
                     break;
                 case DataUtils.NEW_FOLDER://mkdir
-                    MainFragment ma1 = ((MainFragment) getFragment().getTab());
-                    mainActivityHelper.mkDir(RootHelper.generateBaseFile(new File(oppathe), true), ma1);
+                    mainActivityHelper.mkDir(RootHelper.generateBaseFile(new File(oppathe), true),
+                            getCurrentMainFragment());
                     break;
                 case DataUtils.RENAME:
-                    MainFragment ma2 = ((MainFragment) getFragment().getTab());
-                    mainActivityHelper.rename(ma2.openMode, (oppathe), (oppathe1), mainActivity, BaseActivity.rootMode);
-                    ma2.updateList();
+                    MainFragment ma = getCurrentMainFragment();
+                    mainActivityHelper.rename(ma.openMode, (oppathe),
+                            (oppathe1), mainActivity, ThemedActivity.rootMode);
+                    ma.updateList();
                     break;
                 case DataUtils.NEW_FILE:
-                    MainFragment ma3 = ((MainFragment) getFragment().getTab());
-                    mainActivityHelper.mkFile(new HFile(OpenMode.FILE, oppathe), ma3);
+                    mainActivityHelper.mkFile(new HFile(OpenMode.FILE, oppathe), getCurrentMainFragment());
 
                     break;
                 case DataUtils.EXTRACT:
@@ -1762,142 +1623,6 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
         }
     }
 
-    public void bbar(final MainFragment mainFrag) {
-        final String path = mainFrag.getCurrentPath();
-        try {
-            buttons.removeAllViews();
-            buttons.setMinimumHeight(pathbar.getHeight());
-            Drawable arrow = getResources().getDrawable(R.drawable.abc_ic_ab_back_holo_dark);
-            Bundle bundle = utils.getPaths(path, this);
-            ArrayList<String> names = bundle.getStringArrayList("names");
-            ArrayList<String> rnames = bundle.getStringArrayList("names");
-            Collections.reverse(rnames);
-
-            ArrayList<String> paths = bundle.getStringArrayList("paths");
-            final ArrayList<String> rpaths = bundle.getStringArrayList("paths");
-            Collections.reverse(rpaths);
-
-            View view = new View(this);
-            LinearLayout.LayoutParams params1 = new LinearLayout.LayoutParams(
-                    toolbar.getContentInsetLeft(), LinearLayout.LayoutParams.WRAP_CONTENT);
-            view.setLayoutParams(params1);
-            buttons.addView(view);
-            for (int i = 0; i < names.size(); i++) {
-                final int k = i;
-                ImageView v = new ImageView(this);
-                v.setImageDrawable(arrow);
-                LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(
-                        LinearLayout.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
-                params.gravity = Gravity.CENTER_VERTICAL;
-                v.setLayoutParams(params);
-                final int index = i;
-                if (rpaths.get(i).equals("/")) {
-                    ImageButton ib = new ImageButton(this);
-                    ib.setImageDrawable(icons.getRootDrawable());
-                    ib.setBackgroundColor(Color.TRANSPARENT);
-                    ib.setOnClickListener(new View.OnClickListener() {
-
-                        public void onClick(View p1) {
-                            mainFrag.loadlist(("/"), false, mainFrag.openMode);
-                            timer.cancel();
-                            timer.start();
-                        }
-                    });
-                    ib.setLayoutParams(params);
-                    buttons.addView(ib);
-                    if (names.size() - i != 1)
-                        buttons.addView(v);
-                } else if (isStorage(rpaths.get(i))) {
-                    ImageButton ib = new ImageButton(this);
-                    ib.setImageDrawable(icons.getSdDrawable());
-                    ib.setBackgroundColor(Color.TRANSPARENT);
-                    ib.setOnClickListener(new View.OnClickListener() {
-
-                        public void onClick(View p1) {
-                            mainFrag.loadlist((rpaths.get(k)), false, mainFrag.openMode);
-                            timer.cancel();
-                            timer.start();
-                        }
-                    });
-                    ib.setLayoutParams(params);
-                    buttons.addView(ib);
-                    if (names.size() - i != 1)
-                        buttons.addView(v);
-                } else {
-                    Button b = new Button(this);
-                    b.setText(rnames.get(index));
-                    b.setTextColor(Utils.getColor(this, android.R.color.white));
-                    b.setTextSize(13);
-                    b.setLayoutParams(params);
-                    b.setBackgroundResource(0);
-                    b.setOnClickListener(new Button.OnClickListener() {
-
-                        public void onClick(View p1) {
-                            mainFrag.loadlist((rpaths.get(k)), false, mainFrag.openMode);
-                            mainFrag.loadlist((rpaths.get(k)), false, mainFrag.openMode);
-                            timer.cancel();
-                            timer.start();
-                        }
-                    });
-                    b.setOnLongClickListener(new View.OnLongClickListener() {
-                        @Override
-                        public boolean onLongClick(View view) {
-
-                            File file1 = new File(rpaths.get(index));
-                            copyToClipboard(MainActivity.this, file1.getPath());
-                            Toast.makeText(MainActivity.this, getResources().getString(R.string.pathcopied), Toast.LENGTH_SHORT).show();
-                            return false;
-                        }
-                    });
-
-                    buttons.addView(b);
-                    if (names.size() - i != 1)
-                        buttons.addView(v);
-                }
-            }
-
-            scroll.post(new Runnable() {
-                @Override
-                public void run() {
-                    sendScroll(scroll);
-                    sendScroll(scroll1);
-                }
-            });
-
-            if (buttons.getVisibility() == View.VISIBLE) {
-                timer.cancel();
-                timer.start();
-            }
-        } catch (Exception e) {
-            e.printStackTrace();
-            Log.d("BBar", "button view not available");
-        }
-    }
-
-    boolean isStorage(String path) {
-        for (String s : dataUtils.getStorages())
-            if (s.equals(path)) return true;
-        return false;
-    }
-
-    void sendScroll(final HorizontalScrollView scrollView) {
-        final Handler handler = new Handler();
-        new Thread(new Runnable() {
-            @Override
-            public void run() {
-                try {
-                    Thread.sleep(100);
-                } catch (InterruptedException e) {}
-                handler.post(new Runnable() {
-                    @Override
-                    public void run() {
-                        scrollView.fullScroll(View.FOCUS_RIGHT);
-                    }
-                });
-            }
-        }).start();
-    }
-
     void initialisePreferences() {
         hidemode = sharedPref.getInt("hidemode", 0);
         showHidden = sharedPref.getBoolean("showHidden", false);
@@ -1908,7 +1633,7 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
     }
 
     void initialiseViews() {
-        appBarLayout = (AppBarLayout) findViewById(R.id.lin);
+        appBarLayout = getAppbar().getAppbarLayout();
 
         mScreenLayout = (CoordinatorLayout) findViewById(R.id.main_frame);
         buttonBarFrame = (FrameLayout) findViewById(R.id.buttonbarframe);
@@ -1937,10 +1662,7 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
         drawerProfilePic = (RoundedImageView) drawerHeaderLayout.findViewById(R.id.profile_pic);
         mGoogleName = (TextView) drawerHeaderLayout.findViewById(R.id.account_header_drawer_name);
         mGoogleId = (TextView) drawerHeaderLayout.findViewById(R.id.account_header_drawer_email);
-        toolbar = (Toolbar) findViewById(R.id.action_bar);
-        /* For SearchView, see onCreateOptionsMenu(Menu menu)*/
-        TOOLBAR_START_INSET = toolbar.getContentInsetStart();
-        setSupportActionBar(toolbar);
+        setSupportActionBar(getAppbar().getToolbar());
         frameLayout = (FrameLayout) findViewById(R.id.content_frame);
         indicator_layout = findViewById(R.id.indicator_layout);
         mDrawerLinear = (ScrimInsetsRelativeLayout) findViewById(R.id.left_drawer);
@@ -1973,16 +1695,10 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
             @Override
             public void onClick(View view) {
                 floatingActionButton.close(true);
-                if (isSearchViewEnabled) hideSearchView();
+                if (getAppbar().getSearchView().isEnabled()) getAppbar().getSearchView().hideSearchView();
             }
         });
 
-        pathbar = (LinearLayout) findViewById(R.id.pathbar);
-        buttons = (LinearLayout) findViewById(R.id.buttons);
-        scroll = (HorizontalScrollView) findViewById(R.id.scroll);
-        scroll1 = (HorizontalScrollView) findViewById(R.id.scroll1);
-        scroll.setSmoothScrollingEnabled(true);
-        scroll1.setSmoothScrollingEnabled(true);
         ImageView divider = (ImageView) findViewById(R.id.divider1);
         if (getAppTheme().equals(AppTheme.LIGHT))
             divider.setImageResource(R.color.divider);
@@ -2016,7 +1732,7 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
             public void onClick(View v) {
                 android.support.v4.app.FragmentTransaction transaction2 = getSupportFragmentManager().beginTransaction();
                 transaction2.replace(R.id.content_frame, new AppsList());
-                findViewById(R.id.lin).animate().translationY(0).setInterpolator(new DecelerateInterpolator(2)).start();
+                appBarLayout.animate().translationY(0).setInterpolator(new DecelerateInterpolator(2)).start();
                 pending_fragmentTransaction = transaction2;
                 if (!isDrawerLocked) mDrawerLayout.closeDrawer(mDrawerLinear);
                 else onDrawerClosed();
@@ -2037,7 +1753,7 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
             public void onClick(View v) {
                 android.support.v4.app.FragmentTransaction transaction2 = getSupportFragmentManager().beginTransaction();
                 transaction2.replace(R.id.content_frame, new FTPServerFragment());
-                findViewById(R.id.lin).animate().translationY(0).setInterpolator(new DecelerateInterpolator(2)).start();
+                appBarLayout.animate().translationY(0).setInterpolator(new DecelerateInterpolator(2)).start();
                 pending_fragmentTransaction = transaction2;
                 if (!isDrawerLocked) mDrawerLayout.closeDrawer(mDrawerLinear);
                 else onDrawerClosed();
@@ -2065,38 +1781,6 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
             if (colourednavigation)
                 window.setNavigationBarColor(skinStatusBar);
         }
-
-        searchViewLayout = (RelativeLayout) findViewById(R.id.search_view);
-        searchViewEditText = (AppCompatEditText) findViewById(R.id.search_edit_text);
-        ImageView clear = (ImageView) findViewById(R.id.search_close_btn);
-        clear.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                searchViewEditText.setText("");
-            }
-        });
-        findViewById(R.id.img_view_back).setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                hideSearchView();
-            }
-        });
-        searchViewEditText.setOnKeyListener(new TextView.OnKeyListener() {
-            @Override
-            public boolean onKey(View v, int keyCode, KeyEvent event) {
-                // If the event is a key-down event on the "enter" button
-                if ((event.getAction() == KeyEvent.ACTION_DOWN)) {
-                    // Perform action on key press
-                    mainActivityHelper.search(searchViewEditText.getText().toString());
-                    hideSearchView();
-                    return true;
-                }
-                return false;
-            }
-        });
-
-        //    searchViewEditText.setTextColor(Utils.getColor(this, android.R.color.black));
-        //     searchViewEditText.setHintTextColor(Color.parseColor(BaseActivity.accentSkin));
     }
 
     /**
@@ -2130,13 +1814,12 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
     }
 
     void initialiseFab() {
-        String folder_skin = getColorPreference().getColorAsString(ColorUsage.ICON_SKIN);
-        int fabSkinPressed = PreferenceUtils.getStatusColor(BaseActivity.accentSkin);
-        int folderskin = Color.parseColor(folder_skin);
-        int fabskinpressed = (PreferenceUtils.getStatusColor(folder_skin));
+        int colorAccent = getColorPreference().getColor(ColorUsage.ACCENT);
+        int iconSkin = getColorPreference().getColor(ColorUsage.ICON_SKIN);
+
         floatingActionButton = (FloatingActionMenu) findViewById(R.id.menu);
-        floatingActionButton.setMenuButtonColorNormal(Color.parseColor(BaseActivity.accentSkin));
-        floatingActionButton.setMenuButtonColorPressed(fabSkinPressed);
+        floatingActionButton.setMenuButtonColorNormal(colorAccent);
+        floatingActionButton.setMenuButtonColorPressed(colorAccent);
 
         floatingActionButton.setOnMenuToggleListener(new FloatingActionMenu.OnMenuToggleListener() {
             @Override
@@ -2147,8 +1830,8 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
         });
 
         FloatingActionButton fabNewFolder = (FloatingActionButton) findViewById(R.id.menu_new_folder);
-        fabNewFolder.setColorNormal(folderskin);
-        fabNewFolder.setColorPressed(fabskinpressed);
+        fabNewFolder.setColorNormal(iconSkin);
+        fabNewFolder.setColorPressed(iconSkin);
         fabNewFolder.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View view) {
@@ -2159,8 +1842,8 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
             }
         });
         FloatingActionButton fabNewFile = (FloatingActionButton) findViewById(R.id.menu_new_file);
-        fabNewFile.setColorNormal(folderskin);
-        fabNewFile.setColorPressed(fabskinpressed);
+        fabNewFile.setColorNormal(iconSkin);
+        fabNewFile.setColorPressed(iconSkin);
         fabNewFile.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View view) {
@@ -2170,8 +1853,8 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
             }
         });
         final FloatingActionButton floatingActionButton3 = (FloatingActionButton) findViewById(R.id.menu_new_cloud);
-        floatingActionButton3.setColorNormal(folderskin);
-        floatingActionButton3.setColorPressed(fabskinpressed);
+        floatingActionButton3.setColorNormal(iconSkin);
+        floatingActionButton3.setColorPressed(iconSkin);
         floatingActionButton3.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View view) {
@@ -2182,276 +1865,6 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
         });
     }
 
-    public void updatePath(@NonNull final String news, boolean results, OpenMode openmode,
-                           int folder_count, int file_count) {
-
-        if (news.length() == 0) return;
-
-        switch (openmode) {
-            case SFTP:
-                newPath = mainActivityHelper.parseSftpPath(news);
-                break;
-            case SMB:
-                newPath = mainActivityHelper.parseSmbPath(news);
-                break;
-            case OTG:
-                newPath = mainActivityHelper.parseOTGPath(news);
-                break;
-            case CUSTOM:
-                newPath = mainActivityHelper.getIntegralNames(news);
-                break;
-            case DROPBOX:
-            case BOX:
-            case ONEDRIVE:
-            case GDRIVE:
-                newPath = mainActivityHelper.parseCloudPath(openmode, news);
-                break;
-            default:
-                newPath = news;
-        }
-
-        final TextView bapath = (TextView) pathbar.findViewById(R.id.fullpath);
-        final TextView animPath = (TextView) pathbar.findViewById(R.id.fullpath_anim);
-        TextView textView = (TextView) pathbar.findViewById(R.id.pathname);
-        if (!results) {
-            textView.setText(folder_count + " " + getResources().getString(R.string.folders) + "" +
-                    " " + file_count + " " + getResources().getString(R.string.files));
-        } else {
-            bapath.setText(R.string.searchresults);
-            textView.setText(R.string.empty);
-            return;
-        }
-        final String oldPath = bapath.getText().toString();
-        if (oldPath.equals(newPath)) return;
-
-        // implement animation while setting text
-        newPathBuilder = new StringBuffer().append(newPath);
-        oldPathBuilder = new StringBuffer().append(oldPath);
-
-        final Animation slideIn = AnimationUtils.loadAnimation(this, R.anim.slide_in);
-        Animation slideOut = AnimationUtils.loadAnimation(this, R.anim.slide_out);
-
-        if (newPath.length() > oldPath.length() &&
-                newPathBuilder.delete(oldPath.length(), newPath.length()).toString().equals(oldPath) &&
-                oldPath.length() != 0) {
-
-            // navigate forward
-            newPathBuilder.delete(0, newPathBuilder.length());
-            newPathBuilder.append(newPath);
-            newPathBuilder.delete(0, oldPath.length());
-            animPath.setAnimation(slideIn);
-            animPath.animate().setListener(new AnimatorListenerAdapter() {
-                @Override
-                public void onAnimationEnd(Animator animation) {
-                    super.onAnimationEnd(animation);
-                    new Handler().postDelayed(new Runnable() {
-                        @Override
-                        public void run() {
-
-                            animPath.setVisibility(View.GONE);
-                            bapath.setText(newPath);
-                        }
-                    }, PATH_ANIM_END_DELAY);
-                }
-
-                @Override
-                public void onAnimationStart(Animator animation) {
-                    super.onAnimationStart(animation);
-                    animPath.setVisibility(View.VISIBLE);
-                    animPath.setText(newPathBuilder.toString());
-                    //bapath.setText(oldPath);
-
-                    scroll.post(new Runnable() {
-                        @Override
-                        public void run() {
-                            scroll1.fullScroll(View.FOCUS_RIGHT);
-                        }
-                    });
-                }
-
-                @Override
-                public void onAnimationCancel(Animator animation) {
-                    super.onAnimationCancel(animation);
-                    //onAnimationEnd(animation);
-                }
-            }).setStartDelay(PATH_ANIM_START_DELAY).start();
-        } else if (newPath.length() < oldPath.length() &&
-                oldPathBuilder.delete(newPath.length(), oldPath.length()).toString().equals(newPath)) {
-
-            // navigate backwards
-            oldPathBuilder.delete(0, oldPathBuilder.length());
-            oldPathBuilder.append(oldPath);
-            oldPathBuilder.delete(0, newPath.length());
-            animPath.setAnimation(slideOut);
-            animPath.animate().setListener(new AnimatorListenerAdapter() {
-                @Override
-                public void onAnimationEnd(Animator animation) {
-                    super.onAnimationEnd(animation);
-                    animPath.setVisibility(View.GONE);
-                    bapath.setText(newPath);
-
-                    scroll.post(new Runnable() {
-                        @Override
-                        public void run() {
-                            scroll1.fullScroll(View.FOCUS_RIGHT);
-                        }
-                    });
-                }
-
-                @Override
-                public void onAnimationStart(Animator animation) {
-                    super.onAnimationStart(animation);
-                    animPath.setVisibility(View.VISIBLE);
-                    animPath.setText(oldPathBuilder.toString());
-                    bapath.setText(newPath);
-
-                    scroll.post(new Runnable() {
-                        @Override
-                        public void run() {
-                            scroll1.fullScroll(View.FOCUS_LEFT);
-                        }
-                    });
-                }
-            }).setStartDelay(PATH_ANIM_START_DELAY).start();
-        } else if (oldPath.isEmpty()) {
-
-            // case when app starts
-            animPath.setAnimation(slideIn);
-            animPath.setText(newPath);
-            animPath.animate().setListener(new AnimatorListenerAdapter() {
-                @Override
-                public void onAnimationStart(Animator animation) {
-                    super.onAnimationStart(animation);
-                    animPath.setVisibility(View.VISIBLE);
-                    bapath.setText("");
-                    scroll.post(new Runnable() {
-                        @Override
-                        public void run() {
-                            scroll1.fullScroll(View.FOCUS_RIGHT);
-                        }
-                    });
-                }
-
-                @Override
-                public void onAnimationEnd(Animator animation) {
-                    super.onAnimationEnd(animation);
-                    new Handler().postDelayed(new Runnable() {
-                        @Override
-                        public void run() {
-                            animPath.setVisibility(View.GONE);
-                            bapath.setText(newPath);
-                        }
-                    }, PATH_ANIM_END_DELAY);
-                }
-
-                @Override
-                public void onAnimationCancel(Animator animation) {
-                    super.onAnimationCancel(animation);
-                    //onAnimationEnd(animation);
-                }
-            }).setStartDelay(PATH_ANIM_START_DELAY).start();
-        } else {
-            // completely different path
-            // first slide out of old path followed by slide in of new path
-            animPath.setAnimation(slideOut);
-            animPath.animate().setListener(new AnimatorListenerAdapter() {
-                @Override
-                public void onAnimationStart(Animator animator) {
-                    super.onAnimationStart(animator);
-                    animPath.setVisibility(View.VISIBLE);
-                    animPath.setText(oldPath);
-                    bapath.setText("");
-
-                    scroll.post(new Runnable() {
-                        @Override
-                        public void run() {
-                            scroll1.fullScroll(View.FOCUS_LEFT);
-                        }
-                    });
-                }
-
-                @Override
-                public void onAnimationEnd(Animator animator) {
-                    super.onAnimationEnd(animator);
-
-                    //animPath.setVisibility(View.GONE);
-                    animPath.setText(newPath);
-                    bapath.setText("");
-                    animPath.setAnimation(slideIn);
-
-                    animPath.animate().setListener(new AnimatorListenerAdapter() {
-                        @Override
-                        public void onAnimationEnd(Animator animation) {
-                            super.onAnimationEnd(animation);
-                            new Handler().postDelayed(new Runnable() {
-                                @Override
-                                public void run() {
-                                    animPath.setVisibility(View.GONE);
-                                    bapath.setText(newPath);
-                                }
-                            }, PATH_ANIM_END_DELAY);
-                        }
-
-                        @Override
-                        public void onAnimationStart(Animator animation) {
-                            super.onAnimationStart(animation);
-                            // we should not be having anything here in path bar
-                            animPath.setVisibility(View.VISIBLE);
-                            bapath.setText("");
-                            scroll.post(new Runnable() {
-                                @Override
-                                public void run() {
-                                    scroll1.fullScroll(View.FOCUS_RIGHT);
-                                }
-                            });
-                        }
-                    }).start();
-                }
-
-                @Override
-                public void onAnimationCancel(Animator animation) {
-                    super.onAnimationCancel(animation);
-                    //onAnimationEnd(animation);
-                }
-            }).setStartDelay(PATH_ANIM_START_DELAY).start();
-        }
-    }
-
-    public int dpToPx(double dp) {
-        DisplayMetrics displayMetrics = getResources().getDisplayMetrics();
-        return Math.round(Math.round(dp * (displayMetrics.xdpi / DisplayMetrics.DENSITY_DEFAULT)));
-    }
-
-    public void initiatebbar() {
-        final View pathbar = findViewById(R.id.pathbar);
-        TextView textView = (TextView) findViewById(R.id.fullpath);
-
-        pathbar.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                MainFragment m = ((MainFragment) getFragment().getTab());
-                if (m.openMode == OpenMode.FILE) {
-                    bbar(m);
-                    utils.crossfade(buttons, pathbar);
-                    timer.cancel();
-                    timer.start();
-                }
-            }
-        });
-        textView.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                MainFragment m = ((MainFragment) getFragment().getTab());
-                if (m.openMode == OpenMode.FILE) {
-                    bbar(m);
-                    utils.crossfade(buttons, pathbar);
-                    timer.cancel();
-                    timer.start();
-                }
-            }
-        });
-    }
-
     public boolean copyToClipboard(Context context, String text) {
         try {
             android.content.ClipboardManager clipboard = (android.content.ClipboardManager) context
@@ -2478,7 +1891,7 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
 
     public void renameBookmark(final String title, final String path) {
         if (dataUtils.containsBooks(new String[]{title, path}) != -1) {
-            RenameBookmark renameBookmark = RenameBookmark.getInstance(title, path, BaseActivity.accentSkin);
+            RenameBookmark renameBookmark = RenameBookmark.getInstance(title, path, getColorPreference().getColor(ColorUsage.ACCENT));
             if (renameBookmark != null)
                 renameBookmark.show(getFragmentManager(), "renamedialog");
         }
@@ -2491,24 +1904,20 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
         }
 
         if (pendingPath != null) {
-            try {
-                HFile hFile = new HFile(OpenMode.UNKNOWN, pendingPath);
-                hFile.generateMode(this);
-                if (hFile.isSimpleFile()) {
-                    utils.openFile(new File(pendingPath), mainActivity);
-                    pendingPath = null;
-                    return;
-                }
-                TabFragment m = getFragment();
-                if (m == null) {
-                    goToMain(pendingPath);
-                    return;
-                }
-                MainFragment mainFrag = ((MainFragment) m.getTab());
-                if (mainFrag != null) mainFrag.loadlist(pendingPath, false, OpenMode.UNKNOWN);
-            } catch (ClassCastException e) {
-                selectedStorage = NO_VALUE;
-                goToMain("");
+            HFile hFile = new HFile(OpenMode.UNKNOWN, pendingPath);
+            hFile.generateMode(this);
+            if (hFile.isSimpleFile()) {
+                utils.openFile(new File(pendingPath), mainActivity);
+                pendingPath = null;
+                return;
+            }
+
+            MainFragment mainFrag = getCurrentMainFragment();
+            if (mainFrag != null) {
+                mainFrag.loadlist(pendingPath, false, OpenMode.UNKNOWN);
+            } else {
+                goToMain(pendingPath);
+                return;
             }
             pendingPath = null;
         }
@@ -2523,10 +1932,9 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
 
         if (path != null) {
             if (new File(path).isDirectory()) {
-                Fragment f = getDFragment();
-                if ((f.getClass().getName().contains("TabFragment"))) {
-                    MainFragment m = ((MainFragment) getFragment().getTab());
-                    m.loadlist(path, false, OpenMode.FILE);
+                MainFragment ma = getCurrentMainFragment();
+                if (ma != null) {
+                    ma.loadlist(path, false, OpenMode.FILE);
                 } else goToMain(path);
             } else utils.openFile(new File(path), mainActivity);
         } else if (i.getStringArrayListExtra(TAG_INTENT_FILTER_FAILED_OPS) != null) {
@@ -2625,7 +2033,7 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
         if (requestCode == 77) {
             if (grantResults.length == 1 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                 refreshDrawer();
-                TabFragment tabFragment = getFragment();
+                TabFragment tabFragment = getTabFragment();
                 boolean b = sharedPref.getBoolean("needtosethome", true);
                 //reset home and current paths according to new storages
                 if (b) {
@@ -2640,10 +2048,10 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
                     } else
                         tabHandler.addTab(new Tab(2, "", ((EntryItem) dataUtils.getList().get(1)).getPath(), "/"));
                     if (tabFragment != null) {
-                        Fragment main = tabFragment.getTab(0);
+                        Fragment main = tabFragment.getFragmentAtIndex(0);
                         if (main != null)
                             ((MainFragment) main).updateTabWithDb(tabHandler.findTab(1));
-                        Fragment main1 = tabFragment.getTab(1);
+                        Fragment main1 = tabFragment.getFragmentAtIndex(1);
                         if (main1 != null)
                             ((MainFragment) main1).updateTabWithDb(tabHandler.findTab(2));
                     }
@@ -2651,10 +2059,10 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
                 } else {
                     //just refresh list
                     if (tabFragment != null) {
-                        Fragment main = tabFragment.getTab(0);
+                        Fragment main = tabFragment.getFragmentAtIndex(0);
                         if (main != null)
                             ((MainFragment) main).updateList();
-                        Fragment main1 = tabFragment.getTab(1);
+                        Fragment main1 = tabFragment.getFragmentAtIndex(1);
                         if (main1 != null)
                             ((MainFragment) main1).updateList();
                     }
@@ -2681,6 +2089,18 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
         smbConnectDialog.show(getFragmentManager(), "smbdailog");
     }
 
+    /**
+     * Shows a view that goes from white at it's lowest part to transparent a the top.
+     * It covers the fragment.
+     */
+    public void showSmokeScreen() {
+        Futils.revealShow(fabBgView, true);
+    }
+
+    public void hideSmokeScreen() {
+        Futils.revealShow(fabBgView, false);
+    }
+
     @Override
     public void addConnection(boolean edit, final String name, final String path, final String encryptedPath,
                               final String oldname, final String oldPath) {
@@ -2698,14 +2118,8 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
                     }
                 });
                 //grid.addPath(name, encryptedPath, DataUtils.SMB, 1);
-                TabFragment fragment = getFragment();
-                if (fragment != null) {
-                    Fragment fragment1 = fragment.getTab();
-                    if (fragment1 != null) {
-                        final MainFragment ma = (MainFragment) fragment1;
-                        ma.loadlist(path, false, OpenMode.UNKNOWN);
-                    }
-                }
+                MainFragment ma = getCurrentMainFragment();
+                if (ma != null) getCurrentMainFragment().loadlist(path, false, OpenMode.UNKNOWN);
             } else {
                 Snackbar.make(frameLayout, getResources().getString(R.string.connection_exists), Snackbar.LENGTH_SHORT).show();
             }
@@ -3195,4 +2609,4 @@ public class MainActivity extends BaseActivity implements OnRequestPermissionsRe
     @Override
     public void onLoaderReset(Loader<Cursor> loader) {
     }
-}
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/amaze/filemanager/activities/AboutActivity.java b/app/src/main/java/com/amaze/filemanager/activities/AboutActivity.java
index a92d3a256..ab23ec1c1 100644
--- a/app/src/main/java/com/amaze/filemanager/activities/AboutActivity.java
+++ b/app/src/main/java/com/amaze/filemanager/activities/AboutActivity.java
@@ -1,6 +1,7 @@
 package com.amaze.filemanager.activities;
 
 import android.app.Dialog;
+import android.content.ActivityNotFoundException;
 import android.content.ClipData;
 import android.content.ClipboardManager;
 import android.content.Intent;
@@ -14,6 +15,7 @@ import android.support.annotation.Nullable;
 import android.support.design.widget.AppBarLayout;
 import android.support.design.widget.CollapsingToolbarLayout;
 import android.support.design.widget.CoordinatorLayout;
+import android.support.design.widget.Snackbar;
 import android.support.v7.graphics.Palette;
 import android.support.v7.widget.Toolbar;
 import android.util.Log;
@@ -22,11 +24,10 @@ import android.view.View;
 import android.view.Window;
 import android.webkit.WebView;
 import android.widget.ImageView;
-import android.widget.RelativeLayout;
 import android.widget.TextView;
-import android.widget.Toast;
 
 import com.amaze.filemanager.R;
+import com.amaze.filemanager.activities.superclasses.BasicActivity;
 import com.amaze.filemanager.utils.PreferenceUtils;
 import com.amaze.filemanager.utils.Utils;
 import com.amaze.filemanager.utils.theme.AppTheme;
@@ -43,13 +44,9 @@ public class AboutActivity extends BasicActivity implements View.OnClickListener
 
     private AppBarLayout mAppBarLayout;
     private CollapsingToolbarLayout mCollapsingToolbarLayout;
-    private Toolbar mToolbar;
-    private TextView mTitleTextView, mAuthor1Gplus, mAuthor1Donate, mAuthor2Gplus, mAuthor2Donate;
-    private RelativeLayout mVersion, mChangelog, mLicenses, mIssues, mTranslate, mGplusCommunity;
-    private RelativeLayout mXda, mRate;
-    private ImageView mLicensesIcon;
+    private TextView mTitleTextView;
     private int mCount=0;
-    private Toast mToast;
+    private Snackbar snackbar;
     private SharedPreferences mSharedPref;
     private View mAuthorsDivider;
 
@@ -57,15 +54,16 @@ public class AboutActivity extends BasicActivity implements View.OnClickListener
     private static final String URL_AUTHOR_1_G_PLUS = "https://plus.google.com/u/0/110424067388738907251/";
     private static final String URL_AUTHOR_1_PAYPAL = "arpitkh96@gmail.com";
     private static final String URL_AUTHOR_2_G_PLUS = "https://plus.google.com/+VishalNehra/";
-    private static final String URL_AUTHOR_2_PAYPAL = "vishalmeham2@gmail.com";
-    private static final String URL_REPO_CHANGELOG = "https://github.com/arpitkh96/AmazeFileManager/commits/master";
-    private static final String URL_REPO_ISSUES = "https://github.com/arpitkh96/AmazeFileManager/issues";
+    private static final String URL_AUTHOR_2_PAYPAL = "https://www.paypal.me/vishalnehra";
+    private static final String URL_DEVELOPER1_GITHUB = "https://github.com/EmmanuelMess";
+    private static final String URL_DEVELOPER1_BITCOIN = "bitcoin:12SRnoDQvDD8aoCy1SVSn6KSdhQFvRf955?amount=0.0005";
+    private static final String URL_REPO_CHANGELOG = "https://github.com/TeamAmaze/AmazeFileManager/commits/master";
+    private static final String URL_REPO_ISSUES = "https://github.com/TeamAmaze/AmazeFileManager/issues";
     private static final String URL_REPO_TRANSLATE = "https://www.transifex.com/amaze/amaze-file-manager-1/";
     private static final String URL_REPO_G_PLUS_COMMUNITY = "https://plus.google.com/communities/113997576965363268101";
     private static final String URL_REPO_XDA = "http://forum.xda-developers.com/android/apps-games/app-amaze-file-managermaterial-theme-t2937314";
     private static final String URL_REPO_RATE = "market://details?id=com.amaze.filemanager";
     private static final String TAG_CLIPBOARD_DONATE = "donate_id";
-    private static final String URL_DONATE_2 = "https://www.paypal.me/vishalnehra";
 
     @Override
     protected void onCreate(@Nullable Bundle savedInstanceState) {
@@ -81,40 +79,15 @@ public class AboutActivity extends BasicActivity implements View.OnClickListener
 
         mSharedPref = PreferenceManager.getDefaultSharedPreferences(this);
 
-        mAppBarLayout = (AppBarLayout) findViewById(R.id.appBarLayout);
-        mCollapsingToolbarLayout = (CollapsingToolbarLayout) findViewById(R.id.collapsing_toolbar_layout);
-        mTitleTextView = (TextView) findViewById(R.id.text_view_title);
-        mVersion = (RelativeLayout) findViewById(R.id.relative_layout_version);
-        mChangelog = (RelativeLayout) findViewById(R.id.relative_layout_changelog);
-        mLicenses = (RelativeLayout) findViewById(R.id.relative_layout_licenses);
-        mIssues = (RelativeLayout) findViewById(R.id.relative_layout_issues);
-        mTranslate = (RelativeLayout) findViewById(R.id.relative_layout_translate);
-        mAuthor1Gplus = (TextView) findViewById(R.id.text_view_author_1_g_plus);
-        mAuthor1Donate = (TextView) findViewById(R.id.text_view_author_1_donate);
-        mAuthor2Gplus = (TextView) findViewById(R.id.text_view_author_2_g_plus);
-        mAuthor2Donate = (TextView) findViewById(R.id.text_view_author_2_donate);
+        mAppBarLayout = findViewById(R.id.appBarLayout);
+        mCollapsingToolbarLayout = findViewById(R.id.collapsing_toolbar_layout);
+        mTitleTextView =  findViewById(R.id.text_view_title);
+        ImageView mLicensesIcon = findViewById(R.id.image_view_license);;
         mAuthorsDivider = findViewById(R.id.view_divider_authors);
-        mGplusCommunity = (RelativeLayout) findViewById(R.id.relative_layout_g_plus_community);
-        mXda = (RelativeLayout) findViewById(R.id.relative_layout_xda);
-        mRate = (RelativeLayout) findViewById(R.id.relative_layout_rate);
-        mLicensesIcon = (ImageView) findViewById(R.id.image_view_license);
-
-        mVersion.setOnClickListener(this);
-        mChangelog.setOnClickListener(this);
-        mLicenses.setOnClickListener(this);
-        mAuthor1Gplus.setOnClickListener(this);
-        mAuthor1Donate.setOnClickListener(this);
-        mAuthor2Gplus.setOnClickListener(this);
-        mAuthor2Donate.setOnClickListener(this);
-        mIssues.setOnClickListener(this);
-        mTranslate.setOnClickListener(this);
-        mGplusCommunity.setOnClickListener(this);
-        mXda.setOnClickListener(this);
-        mRate.setOnClickListener(this);
 
         mAppBarLayout.setLayoutParams(calculateHeaderViewParams());
 
-        mToolbar = (Toolbar)findViewById(R.id.toolBar);
+        Toolbar mToolbar = findViewById(R.id.toolBar);
         setSupportActionBar(mToolbar);
         getSupportActionBar().setDisplayHomeAsUpEnabled(true);
         getSupportActionBar().setHomeAsUpIndicator(getResources().getDrawable(R.drawable.md_nav_back));
@@ -132,26 +105,15 @@ public class AboutActivity extends BasicActivity implements View.OnClickListener
                 R.drawable.about_header);
 
         // It will generate colors based on the image in an AsyncTask.
-        Palette.from(bitmap).generate(new Palette.PaletteAsyncListener() {
-            @SuppressWarnings("ResourceType")
-            @Override
-            public void onGenerated(Palette palette) {
-
-                int mutedColor = palette.getMutedColor(Utils.getColor(AboutActivity.this, R.color.primary_blue));
-                int darkMutedColor = palette.getDarkMutedColor(Utils.getColor(AboutActivity.this, R.color.primary_blue));
-                mCollapsingToolbarLayout.setContentScrimColor(mutedColor);
-                mCollapsingToolbarLayout.setStatusBarScrimColor(darkMutedColor);
-            }
+        Palette.from(bitmap).generate(palette -> {
+            int mutedColor = palette.getMutedColor(Utils.getColor(AboutActivity.this, R.color.primary_blue));
+            int darkMutedColor = palette.getDarkMutedColor(Utils.getColor(AboutActivity.this, R.color.primary_blue));
+            mCollapsingToolbarLayout.setContentScrimColor(mutedColor);
+            mCollapsingToolbarLayout.setStatusBarScrimColor(darkMutedColor);
         });
 
-        mAppBarLayout.addOnOffsetChangedListener(new AppBarLayout.OnOffsetChangedListener() {
-
-            @Override
-            public void onOffsetChanged(AppBarLayout appBarLayout, int verticalOffset) {
-
-                mTitleTextView.setAlpha(Math.abs(verticalOffset / (float)
-                        appBarLayout.getTotalScrollRange()));
-            }
+        mAppBarLayout.addOnOffsetChangedListener((appBarLayout, verticalOffset) -> {
+            mTitleTextView.setAlpha(Math.abs(verticalOffset / (float) appBarLayout.getTotalScrollRange()));
         });
     }
 
@@ -203,12 +165,15 @@ public class AboutActivity extends BasicActivity implements View.OnClickListener
             case R.id.relative_layout_version:
                 mCount++;
                 if (mCount >= 5) {
-                    if (mToast!=null)
-                        mToast.cancel();
-                    mToast = Toast.makeText(this, getResources().getString(R.string.easter_egg_title) +
-                                    " : " + mCount, Toast.LENGTH_SHORT);
-                    mToast.show();
+                    String text = getResources().getString(R.string.easter_egg_title) + " : " + mCount;
+
+                    if(snackbar != null && snackbar.isShown()) {
+                        snackbar.setText(text);
+                    } else {
+                        snackbar = Snackbar.make(v, text, Snackbar.LENGTH_SHORT);
+                    }
 
+                    snackbar.show();
                     mSharedPref.edit().putInt(KEY_PREF_STUDIO, Integer.parseInt(Integer.toString(mCount) + "000")).apply();
                 } else {
                     mSharedPref.edit().putInt(KEY_PREF_STUDIO, 0).apply();
@@ -216,15 +181,11 @@ public class AboutActivity extends BasicActivity implements View.OnClickListener
                 break;
 
             case R.id.relative_layout_issues:
-                Intent issuesIntent = new Intent(Intent.ACTION_VIEW);
-                issuesIntent.setData(Uri.parse(URL_REPO_ISSUES));
-                startActivity(issuesIntent);
+                openURL(URL_REPO_ISSUES);
                 break;
 
             case R.id.relative_layout_changelog:
-                Intent intent = new Intent(Intent.ACTION_VIEW);
-                intent.setData(Uri.parse(URL_REPO_CHANGELOG));
-                startActivity(intent);
+                openURL(URL_REPO_CHANGELOG);
                 break;
 
             case R.id.relative_layout_licenses:
@@ -238,54 +199,58 @@ public class AboutActivity extends BasicActivity implements View.OnClickListener
                 break;
 
             case R.id.text_view_author_1_g_plus:
-                Intent author1GplusIntent = new Intent(Intent.ACTION_VIEW);
-                author1GplusIntent.setData(Uri.parse(URL_AUTHOR_1_G_PLUS));
-                startActivity(author1GplusIntent);
+                openURL(URL_AUTHOR_1_G_PLUS);
                 break;
 
             case R.id.text_view_author_1_donate:
                 ClipboardManager clipManager1 = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);
                 ClipData clip1 = ClipData.newPlainText(TAG_CLIPBOARD_DONATE, URL_AUTHOR_1_PAYPAL);
                 clipManager1.setPrimaryClip(clip1);
-                Toast.makeText(this, R.string.paypal_copy_message, Toast.LENGTH_LONG).show();
+                Snackbar.make(v, R.string.paypal_copy_message, Snackbar.LENGTH_LONG).show();
                 break;
 
             case R.id.text_view_author_2_g_plus:
-                Intent author2GplusIntent = new Intent(Intent.ACTION_VIEW);
-                author2GplusIntent.setData(Uri.parse(URL_AUTHOR_2_G_PLUS));
-                startActivity(author2GplusIntent);
+                openURL(URL_AUTHOR_2_G_PLUS);
                 break;
 
             case R.id.text_view_author_2_donate:
+                openURL(URL_AUTHOR_2_PAYPAL);
+                break;
+
+            case R.id.text_view_developer_1_github:
+                openURL(URL_DEVELOPER1_GITHUB);
+                break;
 
-                Intent donate2Intent = new Intent(Intent.ACTION_VIEW);
-                donate2Intent.setData(Uri.parse(URL_DONATE_2));
-                startActivity(donate2Intent);
+            case R.id.text_view_developer_1_donate:
+                try {
+                    openURL(URL_DEVELOPER1_BITCOIN);
+                } catch (ActivityNotFoundException e) {
+                    Snackbar.make(v, R.string.nobitcoinapp, Snackbar.LENGTH_LONG).show();
+                }
                 break;
 
             case R.id.relative_layout_translate:
-                Intent translateIntent = new Intent(Intent.ACTION_VIEW);
-                translateIntent.setData(Uri.parse(URL_REPO_TRANSLATE));
-                startActivity(translateIntent);
+                openURL(URL_REPO_TRANSLATE);
                 break;
 
             case R.id.relative_layout_g_plus_community:
-                Intent communityIntent = new Intent(Intent.ACTION_VIEW);
-                communityIntent.setData(Uri.parse(URL_REPO_G_PLUS_COMMUNITY));
-                startActivity(communityIntent);
+                openURL(URL_REPO_G_PLUS_COMMUNITY);
                 break;
 
             case R.id.relative_layout_xda:
-                Intent xdaIntent = new Intent(Intent.ACTION_VIEW);
-                xdaIntent.setData(Uri.parse(URL_REPO_XDA));
-                startActivity(xdaIntent);
+                openURL(URL_REPO_XDA);
                 break;
 
             case R.id.relative_layout_rate:
-                Intent rateIntent = new Intent(Intent.ACTION_VIEW);
-                rateIntent.setData(Uri.parse(URL_REPO_RATE));
-                startActivity(rateIntent);
+                openURL(URL_REPO_RATE);
                 break;
         }
     }
+
+    private void openURL(String url) {
+        Intent intent = new Intent(Intent.ACTION_VIEW);
+        intent.setData(Uri.parse(url));
+        startActivity(intent);
+    }
+
 }
diff --git a/app/src/main/java/com/amaze/filemanager/activities/DbViewer.java b/app/src/main/java/com/amaze/filemanager/activities/DatabaseViewerActivity.java
similarity index 69%
rename from app/src/main/java/com/amaze/filemanager/activities/DbViewer.java
rename to app/src/main/java/com/amaze/filemanager/activities/DatabaseViewerActivity.java
index 1ea2e5408..8ef46bb7a 100644
--- a/app/src/main/java/com/amaze/filemanager/activities/DbViewer.java
+++ b/app/src/main/java/com/amaze/filemanager/activities/DatabaseViewerActivity.java
@@ -20,27 +20,29 @@
 package com.amaze.filemanager.activities;
 
 import android.app.ActivityManager;
+import android.content.SharedPreferences;
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
 import android.graphics.drawable.BitmapDrawable;
 import android.os.Bundle;
+import android.preference.PreferenceManager;
 import android.support.v4.app.FragmentTransaction;
 import android.support.v4.content.ContextCompat;
 import android.support.v7.widget.Toolbar;
 import android.view.Menu;
 import android.view.MenuItem;
-import android.view.View;
 import android.view.ViewGroup;
 import android.view.Window;
 import android.view.WindowManager;
-import android.widget.AdapterView;
 import android.widget.ArrayAdapter;
 import android.widget.FrameLayout;
 import android.widget.ListView;
 
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.exceptions.RootNotPermittedException;
+import com.amaze.filemanager.activities.superclasses.ThemedActivity;
+import com.amaze.filemanager.exceptions.ShellNotRunningException;
 import com.amaze.filemanager.fragments.DbViewerFragment;
+import com.amaze.filemanager.fragments.preference_fragments.PrefFrag;
 import com.amaze.filemanager.utils.PreferenceUtils;
 import com.amaze.filemanager.utils.RootUtils;
 import com.amaze.filemanager.utils.Utils;
@@ -56,7 +58,7 @@ import static android.os.Build.VERSION.SDK_INT;
 /**
  * Created by Vishal on 02-02-2015.
  */
-public class DbViewer extends BaseActivity {
+public class DatabaseViewerActivity extends ThemedActivity {
 
     private String path;
     private ListView listView;
@@ -75,13 +77,14 @@ public class DbViewer extends BaseActivity {
         this.checkStorage = false;
         super.onCreate(savedInstanceState);
 
+        SharedPreferences sharedPref = PreferenceManager.getDefaultSharedPreferences(this);
 
         if (getAppTheme().equals(AppTheme.DARK)) {
             setTheme(R.style.appCompatDark);
             getWindow().getDecorView().setBackgroundColor(Utils.getColor(this, R.color.holo_dark_background));
         }
         setContentView(R.layout.activity_db_viewer);
-        toolbar = (android.support.v7.widget.Toolbar) findViewById(R.id.toolbar);
+        toolbar = findViewById(R.id.toolbar);
         setSupportActionBar(toolbar);
         if (SDK_INT >= 21) {
             ActivityManager.TaskDescription taskDescription = new ActivityManager.TaskDescription
@@ -93,7 +96,11 @@ public class DbViewer extends BaseActivity {
         }
         getSupportActionBar()
                 .setBackgroundDrawable(getColorPreference().getDrawable(ColorUsage.getPrimary(MainActivity.currentTab)));
-        getSupportActionBar().setDisplayHomeAsUpEnabled(true);
+
+        boolean useNewStack = sharedPref.getBoolean(PrefFrag.PREFERENCE_TEXTEDITOR_NEWSTACK, false);
+
+        getSupportActionBar().setDisplayHomeAsUpEnabled(!useNewStack);
+
         if (SDK_INT == 20 || SDK_INT == 19) {
             SystemBarTintManager tintManager = new SystemBarTintManager(this);
             tintManager.setStatusBarTintEnabled(true);
@@ -102,7 +109,7 @@ public class DbViewer extends BaseActivity {
             SystemBarTintManager.SystemBarConfig config = tintManager.getConfig();
             p.setMargins(0, config.getStatusBarHeight(), 0, 0);
         } else if (SDK_INT >= 21) {
-            boolean colourednavigation = sharedPref.getBoolean("colorednavigation", true);
+            boolean colourednavigation = getPrefs().getBoolean("colorednavigation", true);
             Window window = getWindow();
             window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
             window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
@@ -114,21 +121,18 @@ public class DbViewer extends BaseActivity {
 
         path = getIntent().getStringExtra("path");
         pathFile = new File(path);
-        listView = (ListView) findViewById(R.id.listView);
+        listView = findViewById(R.id.listView);
 
         load(pathFile);
-        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
-            @Override
-            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
-                FragmentTransaction fragmentTransaction = getSupportFragmentManager().beginTransaction();
-                DbViewerFragment fragment = new DbViewerFragment();
-                Bundle bundle = new Bundle();
-                bundle.putString("table", arrayList.get(position));
-                fragment.setArguments(bundle);
-                fragmentTransaction.add(R.id.content_frame, fragment);
-                fragmentTransaction.addToBackStack(null);
-                fragmentTransaction.commit();
-            }
+        listView.setOnItemClickListener((parent, view, position, id) -> {
+            FragmentTransaction fragmentTransaction = getSupportFragmentManager().beginTransaction();
+            DbViewerFragment fragment = new DbViewerFragment();
+            Bundle bundle = new Bundle();
+            bundle.putString("table", arrayList.get(position));
+            fragment.setArguments(bundle);
+            fragmentTransaction.add(R.id.content_frame, fragment);
+            fragmentTransaction.addToBackStack(null);
+            fragmentTransaction.commit();
         });
 
     }
@@ -144,44 +148,37 @@ public class DbViewer extends BaseActivity {
     }
 
     private void load(final File file) {
-        new Thread(new Runnable() {
-            @Override
-            public void run() {
-                File file1 = getExternalCacheDir();
-
-                // if the db can't be read, and we have root enabled, try reading it by
-                // first copying it in cache dir
-                if (!file.canRead() && BaseActivity.rootMode) {
-
-                    try {
-                        RootUtils.copy(pathFile.getPath(),
-                                new File(file1.getPath(), file.getName()).getPath());
-                        pathFile = new File(file1.getPath(), file.getName());
-                    } catch (RootNotPermittedException e) {
-                        e.printStackTrace();
-                    }
-                    delete = true;
-                }
+        new Thread(() -> {
+            File file1 = getExternalCacheDir();
+
+            // if the db can't be read, and we have root enabled, try reading it by
+            // first copying it in cache dir
+            if (!file.canRead() && ThemedActivity.rootMode) {
+
                 try {
-                    sqLiteDatabase = SQLiteDatabase.openDatabase(pathFile.getPath(), null,
-                            SQLiteDatabase.OPEN_READONLY);
-
-                    c = sqLiteDatabase.rawQuery(
-                            "SELECT name FROM sqlite_master WHERE type='table'", null);
-                    arrayList = getDbTableNames(c);
-                    arrayAdapter = new ArrayAdapter(DbViewer.this, android.R.layout.simple_list_item_1, arrayList);
-                } catch (Exception e) {
+                    RootUtils.copy(pathFile.getPath(),
+                            new File(file1.getPath(), file.getName()).getPath());
+                    pathFile = new File(file1.getPath(), file.getName());
+                } catch (ShellNotRunningException e) {
                     e.printStackTrace();
-                    finish();
                 }
-                runOnUiThread(new Runnable() {
-                    @Override
-                    public void run() {
-
-                        listView.setAdapter(arrayAdapter);
-                    }
-                });
+                delete = true;
+            }
+            try {
+                sqLiteDatabase = SQLiteDatabase.openDatabase(pathFile.getPath(), null,
+                        SQLiteDatabase.OPEN_READONLY);
+
+                c = sqLiteDatabase.rawQuery(
+                        "SELECT name FROM sqlite_master WHERE type='table'", null);
+                arrayList = getDbTableNames(c);
+                arrayAdapter = new ArrayAdapter(DatabaseViewerActivity.this, android.R.layout.simple_list_item_1, arrayList);
+            } catch (Exception e) {
+                e.printStackTrace();
+                finish();
             }
+            runOnUiThread(() -> {
+                listView.setAdapter(arrayAdapter);
+            });
         }).start();
     }
 
diff --git a/app/src/main/java/com/amaze/filemanager/activities/PreferencesActivity.java b/app/src/main/java/com/amaze/filemanager/activities/PreferencesActivity.java
index 659ed6db8..649be0b20 100644
--- a/app/src/main/java/com/amaze/filemanager/activities/PreferencesActivity.java
+++ b/app/src/main/java/com/amaze/filemanager/activities/PreferencesActivity.java
@@ -39,10 +39,11 @@ import android.view.WindowManager;
 import android.widget.FrameLayout;
 
 import com.amaze.filemanager.R;
+import com.amaze.filemanager.activities.superclasses.ThemedActivity;
 import com.amaze.filemanager.fragments.preference_fragments.AdvancedSearchPref;
 import com.amaze.filemanager.fragments.preference_fragments.ColorPref;
 import com.amaze.filemanager.fragments.preference_fragments.FoldersPref;
-import com.amaze.filemanager.fragments.preference_fragments.Preffrag;
+import com.amaze.filemanager.fragments.preference_fragments.PrefFrag;
 import com.amaze.filemanager.fragments.preference_fragments.QuickAccessPref;
 import com.amaze.filemanager.utils.PreferenceUtils;
 import com.amaze.filemanager.utils.color.ColorUsage;
@@ -50,7 +51,7 @@ import com.readystatesoftware.systembartint.SystemBarTintManager;
 
 import static android.os.Build.VERSION.SDK_INT;
 
-public class PreferencesActivity extends BaseActivity implements ActivityCompat.OnRequestPermissionsResultCallback {
+public class PreferencesActivity extends ThemedActivity {
 
     //Start is the first activity you see
     public static final int START_PREFERENCE = 0;
@@ -70,7 +71,7 @@ public class PreferencesActivity extends BaseActivity implements ActivityCompat.
         SharedPreferences Sp = PreferenceManager.getDefaultSharedPreferences(this);
         super.onCreate(savedInstanceState);
         setContentView(R.layout.prefsfrag);
-        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
+        Toolbar toolbar = findViewById(R.id.toolbar);
         if (SDK_INT >= 21) {
             ActivityManager.TaskDescription taskDescription = new ActivityManager.TaskDescription("Amaze",
                     ((BitmapDrawable) getResources().getDrawable(R.mipmap.ic_launcher)).getBitmap(),
@@ -176,7 +177,7 @@ public class PreferencesActivity extends BaseActivity implements ActivityCompat.
         selectedItem = i;
         switch (i) {
             case START_PREFERENCE:
-                loadPrefFragment(new Preffrag(), R.string.setting);
+                loadPrefFragment(new PrefFrag(), R.string.setting);
                 break;
             case COLORS_PREFERENCE:
                 loadPrefFragment(new ColorPref(), R.string.color_title);
@@ -193,20 +194,6 @@ public class PreferencesActivity extends BaseActivity implements ActivityCompat.
         }
     }
 
-    @Override
-    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,
-                                           @NonNull int[] grantResults) {
-        if (requestCode == 66) {
-            Preffrag preffrag = (Preffrag) getFragmentManager().findFragmentById(R.id.prefsfragment);
-
-            if (preffrag != null) {
-
-                preffrag.invalidateGplus();
-            }
-        }
-
-    }
-
     private void loadPrefFragment(PreferenceFragment fragment, @StringRes int titleBarName) {
         FragmentTransaction t = getFragmentManager().beginTransaction();
         t.replace(R.id.prefsfragment, fragment);
diff --git a/app/src/main/java/com/amaze/filemanager/activities/TextReader.java b/app/src/main/java/com/amaze/filemanager/activities/TextEditorActivity.java
similarity index 83%
rename from app/src/main/java/com/amaze/filemanager/activities/TextReader.java
rename to app/src/main/java/com/amaze/filemanager/activities/TextEditorActivity.java
index 6194a060a..28f801bf2 100644
--- a/app/src/main/java/com/amaze/filemanager/activities/TextReader.java
+++ b/app/src/main/java/com/amaze/filemanager/activities/TextEditorActivity.java
@@ -34,7 +34,6 @@ import android.net.Uri;
 import android.os.Build;
 import android.os.Bundle;
 import android.os.ParcelFileDescriptor;
-import android.preference.PreferenceManager;
 import android.provider.MediaStore;
 import android.support.v7.widget.Toolbar;
 import android.text.Editable;
@@ -60,18 +59,21 @@ import android.widget.Toast;
 
 import com.afollestad.materialdialogs.MaterialDialog;
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.exceptions.RootNotPermittedException;
+import com.amaze.filemanager.activities.superclasses.ThemedActivity;
+import com.amaze.filemanager.asynchronous.asynctasks.SearchTextTask;
+import com.amaze.filemanager.exceptions.ShellNotRunningException;
 import com.amaze.filemanager.exceptions.StreamNotFoundException;
-import com.amaze.filemanager.filesystem.BaseFile;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.FileUtil;
-import com.amaze.filemanager.services.asynctasks.SearchTextTask;
+import com.amaze.filemanager.fragments.preference_fragments.PrefFrag;
 import com.amaze.filemanager.ui.dialogs.GeneralDialogCreation;
-import com.amaze.filemanager.utils.files.GenericCopyUtil;
 import com.amaze.filemanager.utils.MapEntry;
 import com.amaze.filemanager.utils.PreferenceUtils;
 import com.amaze.filemanager.utils.RootUtils;
 import com.amaze.filemanager.utils.Utils;
 import com.amaze.filemanager.utils.color.ColorUsage;
+import com.amaze.filemanager.utils.files.FileUtils;
+import com.amaze.filemanager.utils.files.GenericCopyUtil;
 import com.amaze.filemanager.utils.theme.AppTheme;
 import com.readystatesoftware.systembartint.SystemBarTintManager;
 
@@ -89,10 +91,10 @@ import java.util.Map;
 import java.util.Timer;
 import java.util.TimerTask;
 
-public class TextReader extends BaseActivity implements TextWatcher, View.OnClickListener {
+public class TextEditorActivity extends ThemedActivity implements TextWatcher, View.OnClickListener {
 
     public EditText mInput, searchEditText;
-    private BaseFile mFile;
+    private HybridFileParcelable mFile;
     private String mOriginal;
     private Timer mTimer;
     private boolean mModified, isEditAllowed = true;
@@ -138,14 +140,13 @@ public class TextReader extends BaseActivity implements TextWatcher, View.OnClic
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        sharedPref = PreferenceManager.getDefaultSharedPreferences(this);
 
         if (getAppTheme().equals(AppTheme.DARK))
             getWindow().getDecorView().setBackgroundColor(Utils.getColor(this, R.color.holo_dark_background));
 
         setContentView(R.layout.search);
-        searchViewLayout = (RelativeLayout) findViewById(R.id.searchview);
-        toolbar = (Toolbar) findViewById(R.id.toolbar);
+        searchViewLayout = findViewById(R.id.searchview);
+        toolbar = findViewById(R.id.toolbar);
         setSupportActionBar(toolbar);
         //findViewById(R.id.lin).setBackgroundColor(Color.parseColor(skin));
         toolbar.setBackgroundColor(getColorPreference().getColor(ColorUsage.getPrimary(MainActivity.currentTab)));
@@ -171,10 +172,12 @@ public class TextReader extends BaseActivity implements TextWatcher, View.OnClic
         closeButton.setOnClickListener(this);
 
         getSupportActionBar().setBackgroundDrawable(getColorPreference().getDrawable(ColorUsage.getPrimary(MainActivity.currentTab)));
-        getSupportActionBar().setDisplayHomeAsUpEnabled(true);
-        int sdk = Build.VERSION.SDK_INT;
 
-        if (sdk == Build.VERSION_CODES.KITKAT_WATCH || sdk == Build.VERSION_CODES.KITKAT) {
+        boolean useNewStack = getPrefs().getBoolean(PrefFrag.PREFERENCE_TEXTEDITOR_NEWSTACK, false);
+
+        getSupportActionBar().setDisplayHomeAsUpEnabled(!useNewStack);
+
+        if (Build.VERSION.SDK_INT == Build.VERSION_CODES.KITKAT_WATCH || Build.VERSION.SDK_INT == Build.VERSION_CODES.KITKAT) {
             SystemBarTintManager tintManager = new SystemBarTintManager(this);
             tintManager.setStatusBarTintEnabled(true);
             tintManager.setStatusBarTintColor(getColorPreference().getColor(ColorUsage.getPrimary(MainActivity.currentTab)));
@@ -182,7 +185,7 @@ public class TextReader extends BaseActivity implements TextWatcher, View.OnClic
             SystemBarTintManager.SystemBarConfig config = tintManager.getConfig();
             p.setMargins(0, config.getStatusBarHeight(), 0, 0);
         } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
-            boolean colourednavigation = sharedPref.getBoolean("colorednavigation", true);
+            boolean colourednavigation = getPrefs().getBoolean("colorednavigation", true);
             Window window = getWindow();
             window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
             window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
@@ -191,14 +194,15 @@ public class TextReader extends BaseActivity implements TextWatcher, View.OnClic
                 window.setNavigationBarColor(PreferenceUtils.getStatusColor(getColorPreference().getColorAsString(ColorUsage.getPrimary(MainActivity.currentTab))));
 
         }
-        mInput = (EditText) findViewById(R.id.fname);
-        scrollView = (ScrollView) findViewById(R.id.editscroll);
+        mInput = findViewById(R.id.fname);
+        scrollView = findViewById(R.id.editscroll);
 
         if (getIntent().getData() != null) {
             // getting uri from external source
             uri = getIntent().getData();
 
-            mFile = new BaseFile(getIntent().getData().getPath());
+
+            mFile = new HybridFileParcelable(Utils.sanitizeInput(getIntent().getData().getPath()));
         }
 
         String fileName;
@@ -244,13 +248,8 @@ public class TextReader extends BaseActivity implements TextWatcher, View.OnClic
         getSupportActionBar().setTitle(fileName);
 
         mInput.addTextChangedListener(this);
-        try {
-            if (getAppTheme().equals(AppTheme.DARK))
-                mInput.setBackgroundColor(Utils.getColor(this, R.color.holo_dark_background));
-            getSupportActionBar().setDisplayHomeAsUpEnabled(true);
-        } catch (Exception e) {
-
-        }
+        if (getAppTheme().equals(AppTheme.DARK))
+            mInput.setBackgroundColor(Utils.getColor(this, R.color.holo_dark_background));
 
         mInputTypefaceDefault = mInput.getTypeface();
         mInputTypefaceMono = Typeface.MONOSPACE;
@@ -284,8 +283,8 @@ public class TextReader extends BaseActivity implements TextWatcher, View.OnClic
                     .content(R.string.unsavedchangesdesc)
                     .positiveText(R.string.yes)
                     .negativeText(R.string.no)
-                    .positiveColor(Color.parseColor(accentSkin))
-                    .negativeColor(Color.parseColor(accentSkin))
+                    .positiveColor(getColorPreference().getColor(ColorUsage.ACCENT))
+                    .negativeColor(getColorPreference().getColor(ColorUsage.ACCENT))
                     .callback(new MaterialDialog.ButtonCallback() {
                         @Override
                         public void onPositive(MaterialDialog dialog) {
@@ -315,42 +314,27 @@ public class TextReader extends BaseActivity implements TextWatcher, View.OnClic
      */
     private void saveFile(final Uri uri, final File file, final String editTextString) {
         Toast.makeText(this, R.string.saving, Toast.LENGTH_SHORT).show();
-        new Thread(new Runnable() {
-            @Override
-            public void run() {
-                try {
-                    writeTextFile(uri, file, editTextString);
-                } catch (StreamNotFoundException e) {
-                    e.printStackTrace();
-                    runOnUiThread(new Runnable() {
-                        @Override
-                        public void run() {
-
-                            Toast.makeText(getApplicationContext(), R.string.error_file_not_found,
-                                    Toast.LENGTH_SHORT).show();
-                        }
-                    });
-                } catch (IOException e) {
-                    e.printStackTrace();
-                    runOnUiThread(new Runnable() {
-                        @Override
-                        public void run() {
-
-                            Toast.makeText(getApplicationContext(), R.string.error_io,
-                                    Toast.LENGTH_SHORT).show();
-                        }
-                    });
-                } catch (RootNotPermittedException e) {
-                    e.printStackTrace();
-                    runOnUiThread(new Runnable() {
-                        @Override
-                        public void run() {
-
-                            Toast.makeText(getApplicationContext(), R.string.rootfailure,
-                                    Toast.LENGTH_SHORT).show();
-                        }
-                    });
-                }
+        new Thread(() -> {
+            try {
+                writeTextFile(uri, file, editTextString);
+            } catch (StreamNotFoundException e) {
+                e.printStackTrace();
+                runOnUiThread(() -> {
+                    Toast.makeText(getApplicationContext(), R.string.error_file_not_found,
+                            Toast.LENGTH_SHORT).show();
+                });
+            } catch (IOException e) {
+                e.printStackTrace();
+                runOnUiThread(() -> {
+                    Toast.makeText(getApplicationContext(), R.string.error_io,
+                            Toast.LENGTH_SHORT).show();
+                });
+            } catch (ShellNotRunningException e) {
+                e.printStackTrace();
+                runOnUiThread(() -> {
+                    Toast.makeText(getApplicationContext(), R.string.rootfailure,
+                            Toast.LENGTH_SHORT).show();
+                });
             }
         }).start();
     }
@@ -364,11 +348,11 @@ public class TextReader extends BaseActivity implements TextWatcher, View.OnClic
      * @param inputText
      * @throws StreamNotFoundException
      * @throws IOException
-     * @throws RootNotPermittedException
+     * @throws ShellNotRunningException
      * @see #saveFile(Uri, File, String)
      */
     private void writeTextFile(final Uri uri, final File file, String inputText)
-            throws StreamNotFoundException, IOException, RootNotPermittedException {
+            throws StreamNotFoundException, IOException, ShellNotRunningException {
         OutputStream outputStream = null;
 
         if (uri.toString().contains("file://")) {
@@ -379,7 +363,7 @@ public class TextReader extends BaseActivity implements TextWatcher, View.OnClic
                 outputStream = null;
             }
 
-            if (BaseActivity.rootMode && outputStream == null) {
+            if (ThemedActivity.rootMode && outputStream == null) {
                 // try loading stream associated using root
                 try {
 
@@ -430,11 +414,8 @@ public class TextReader extends BaseActivity implements TextWatcher, View.OnClic
             cacheFile.delete();
         }
 
-        runOnUiThread(new Runnable() {
-            @Override
-            public void run() {
-                Toast.makeText(getApplicationContext(), getString(R.string.done), Toast.LENGTH_SHORT).show();
-            }
+        runOnUiThread(() -> {
+            Toast.makeText(getApplicationContext(), getString(R.string.done), Toast.LENGTH_SHORT).show();
         });
     }
 
@@ -450,66 +431,52 @@ public class TextReader extends BaseActivity implements TextWatcher, View.OnClic
      * @param uri
      * @param mFile
      */
-    private void load(final Uri uri, final BaseFile mFile) {
+    private void load(final Uri uri, final HybridFileParcelable mFile) {
         setProgress(true);
         this.mFile = mFile;
         mInput.setHint(R.string.loading);
-        new Thread(new Runnable() {
-            @Override
-            public void run() {
-                try {
-                    inputStream = getInputStream(uri, mFile);
+        new Thread(() -> {
+            try {
+                inputStream = getInputStream(uri, mFile);
 
-                    String str;
+                String str;
 
-                    StringBuilder stringBuilder = new StringBuilder();
-                    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
-                    if (bufferedReader != null) {
-                        while ((str = bufferedReader.readLine()) != null) {
-                            stringBuilder.append(str).append("\n");
-                        }
+                StringBuilder stringBuilder = new StringBuilder();
+                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
+                if (bufferedReader != null) {
+                    while ((str = bufferedReader.readLine()) != null) {
+                        stringBuilder.append(str).append("\n");
                     }
-                    mOriginal = stringBuilder.toString();
-                    inputStream.close();
-
-                    runOnUiThread(new Runnable() {
-                        @Override
-                        public void run() {
-                            try {
-                                mInput.setText(mOriginal);
-                                if (mOriginal.isEmpty()) {
-
-                                    mInput.setHint(R.string.file_empty);
-                                } else
-                                    mInput.setHint(null);
-                            } catch (OutOfMemoryError e) {
-                                mInput.setHint(R.string.error);
-                            }
-                            setProgress(false);
-                        }
-                    });
-
-                } catch (StreamNotFoundException e) {
+                }
+                mOriginal = stringBuilder.toString();
+                inputStream.close();
 
-                    e.printStackTrace();
-                    runOnUiThread(new Runnable() {
-                        @Override
-                        public void run() {
+                runOnUiThread(() -> {
+                    try {
+                        mInput.setText(mOriginal);
+                        if (mOriginal.isEmpty()) {
+
+                            mInput.setHint(R.string.file_empty);
+                        } else
+                            mInput.setHint(null);
+                    } catch (OutOfMemoryError e) {
+                        mInput.setHint(R.string.error);
+                    }
+                    setProgress(false);
+                });
 
-                            mInput.setHint(R.string.error_file_not_found);
-                        }
-                    });
-                } catch (IOException e) {
+            } catch (StreamNotFoundException e) {
 
-                    e.printStackTrace();
-                    runOnUiThread(new Runnable() {
-                        @Override
-                        public void run() {
+                e.printStackTrace();
+                runOnUiThread(() -> {
+                    mInput.setHint(R.string.error_file_not_found);
+                });
+            } catch (IOException e) {
 
-                            mInput.setHint(R.string.error_io);
-                        }
-                    });
-                }
+                e.printStackTrace();
+                runOnUiThread(() -> {
+                    mInput.setHint(R.string.error_io);
+                });
             }
         }).start();
     }
@@ -544,14 +511,15 @@ public class TextReader extends BaseActivity implements TextWatcher, View.OnClic
                 break;
             case R.id.details:
                 if (mFile.exists()) {
-                    //HFile hFile = new HFile(OpenMode.FILE, mFile.getPath());
+                    //HybridFile hFile = new HybridFile(OpenMode.FILE, mFile.getPath());
                     //hFile.generateMode(this);
                     GeneralDialogCreation.showPropertiesDialogWithoutPermissions(mFile, this, getAppTheme());
                 } else Toast.makeText(this, R.string.not_allowed, Toast.LENGTH_SHORT).show();
                 break;
             case R.id.openwith:
                 if (mFile.exists()) {
-                    getFutils().openunknown(new File(mFile.getPath()), this, false);
+                    boolean useNewStack = getPrefs().getBoolean(PrefFrag.PREFERENCE_TEXTEDITOR_NEWSTACK, false);
+                    FileUtils.openunknown(new File(mFile.getPath()), this, false, useNewStack);
                 } else Toast.makeText(this, R.string.not_allowed, Toast.LENGTH_SHORT).show();
                 break;
             case R.id.find:
@@ -633,7 +601,7 @@ public class TextReader extends BaseActivity implements TextWatcher, View.OnClic
     }
 
     /**
-     * Helper method to {@link #load(Uri, BaseFile)}
+     * Helper method to {@link #load(Uri, HybridFileParcelable)}
      * Tries to find an input stream associated with file/uri
      *
      * @param uri
@@ -642,14 +610,14 @@ public class TextReader extends BaseActivity implements TextWatcher, View.OnClic
      * @throws StreamNotFoundException exception thrown when we couldn't find a stream
      *                                 after all the attempts
      */
-    private InputStream getInputStream(Uri uri, BaseFile baseFile) throws StreamNotFoundException {
+    private InputStream getInputStream(Uri uri, HybridFileParcelable baseFile) throws StreamNotFoundException {
         InputStream stream = null;
 
         File file = new File(baseFile.getPath());
 
         if (uri.toString().contains("file://")) {
             // dealing with files
-            if (!file.canWrite() && BaseActivity.rootMode) {
+            if (!file.canWrite() && ThemedActivity.rootMode) {
                 // try loading stream associated using root
 
                 try {
@@ -665,7 +633,7 @@ public class TextReader extends BaseActivity implements TextWatcher, View.OnClic
                         e.printStackTrace();
                         stream = null;
                     }
-                } catch (RootNotPermittedException e) {
+                } catch (ShellNotRunningException e) {
                     e.printStackTrace();
                     stream = null;
                 }
diff --git a/app/src/main/java/com/amaze/filemanager/activities/BasicActivity.java b/app/src/main/java/com/amaze/filemanager/activities/superclasses/BasicActivity.java
similarity index 73%
rename from app/src/main/java/com/amaze/filemanager/activities/BasicActivity.java
rename to app/src/main/java/com/amaze/filemanager/activities/superclasses/BasicActivity.java
index b7f872516..23fe124bf 100644
--- a/app/src/main/java/com/amaze/filemanager/activities/BasicActivity.java
+++ b/app/src/main/java/com/amaze/filemanager/activities/superclasses/BasicActivity.java
@@ -1,13 +1,12 @@
-package com.amaze.filemanager.activities;
+package com.amaze.filemanager.activities.superclasses;
 
 import android.support.v7.app.AppCompatActivity;
 
-import com.amaze.filemanager.utils.AppConfig;
-import com.amaze.filemanager.utils.files.Futils;
+import com.amaze.filemanager.utils.application.AppConfig;
 import com.amaze.filemanager.utils.color.ColorPreference;
 import com.amaze.filemanager.utils.provider.UtilitiesProviderInterface;
 import com.amaze.filemanager.utils.theme.AppTheme;
-import com.amaze.filemanager.utils.theme.AppThemeManagerInterface;
+import com.amaze.filemanager.utils.theme.AppThemeManager;
 
 /**
  * Created by rpiotaix on 17/10/16.
@@ -26,14 +25,6 @@ public class BasicActivity extends AppCompatActivity implements UtilitiesProvide
         return (AppConfig) getApplication();
     }
 
-    @Override
-    public Futils getFutils() {
-        if (!initialized)
-            initialize();
-
-        return utilsProvider.getFutils();
-    }
-
     public ColorPreference getColorPreference() {
         if (!initialized)
             initialize();
@@ -50,7 +41,7 @@ public class BasicActivity extends AppCompatActivity implements UtilitiesProvide
     }
 
     @Override
-    public AppThemeManagerInterface getThemeManager() {
+    public AppThemeManager getThemeManager() {
         if (!initialized)
             initialize();
 
diff --git a/app/src/main/java/com/amaze/filemanager/activities/superclasses/PreferenceActivity.java b/app/src/main/java/com/amaze/filemanager/activities/superclasses/PreferenceActivity.java
new file mode 100644
index 000000000..0ccc57701
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/activities/superclasses/PreferenceActivity.java
@@ -0,0 +1,27 @@
+package com.amaze.filemanager.activities.superclasses;
+
+import android.content.SharedPreferences;
+import android.os.Bundle;
+import android.preference.PreferenceManager;
+
+/**
+ * @author Emmanuel
+ *         on 24/8/2017, at 23:13.
+ */
+
+public class PreferenceActivity extends BasicActivity {
+
+    private SharedPreferences sharedPrefs;
+
+    @Override
+    public void onCreate(final Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        sharedPrefs = PreferenceManager.getDefaultSharedPreferences(this);
+    }
+
+    public SharedPreferences getPrefs() {
+        return sharedPrefs;
+    }
+
+}
diff --git a/app/src/main/java/com/amaze/filemanager/activities/BaseActivity.java b/app/src/main/java/com/amaze/filemanager/activities/superclasses/ThemedActivity.java
similarity index 79%
rename from app/src/main/java/com/amaze/filemanager/activities/BaseActivity.java
rename to app/src/main/java/com/amaze/filemanager/activities/superclasses/ThemedActivity.java
index b9c57d4b6..d595d435e 100644
--- a/app/src/main/java/com/amaze/filemanager/activities/BaseActivity.java
+++ b/app/src/main/java/com/amaze/filemanager/activities/superclasses/ThemedActivity.java
@@ -1,13 +1,10 @@
-package com.amaze.filemanager.activities;
+package com.amaze.filemanager.activities.superclasses;
 
 import android.Manifest;
-import android.content.SharedPreferences;
 import android.content.pm.PackageManager;
 import android.os.Build;
 import android.os.Bundle;
-import android.preference.PreferenceManager;
 import android.support.v4.app.ActivityCompat;
-import android.view.View;
 
 import com.afollestad.materialdialogs.DialogAction;
 import com.afollestad.materialdialogs.MaterialDialog;
@@ -20,72 +17,55 @@ import com.amaze.filemanager.utils.theme.AppTheme;
 /**
  * Created by arpitkh996 on 03-03-2016.
  */
-public class BaseActivity extends BasicActivity {
-    public SharedPreferences sharedPref;
-
-    // Accent and Primary hex color string respectively
-    /**
-     * @deprecated use {@link #getColorPreference()#getColor(int)} and {@link ColorUsage#ACCENT}
-     */
-    public static String accentSkin;
+public class ThemedActivity extends PreferenceActivity {
+
     public static boolean rootMode;
-    boolean checkStorage = true;
+    public boolean checkStorage = true;
 
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        sharedPref = PreferenceManager.getDefaultSharedPreferences(this);
 
         // checking if theme should be set light/dark or automatic
-        if (sharedPref.getBoolean("random_checkbox", false)) {
-            getColorPreference().randomize()
-                    .saveToPreferences(sharedPref);
+        if (getPrefs().getBoolean("random_checkbox", false)) {
+            getColorPreference().randomize().saveToPreferences(getPrefs());
         }
 
-        accentSkin = getColorPreference().getColorAsString(ColorUsage.ACCENT);
         setTheme();
 
-        rootMode = sharedPref.getBoolean(PreferenceUtils.KEY_ROOT, false);
+        rootMode = getPrefs().getBoolean(PreferenceUtils.KEY_ROOT, false);
 
         //requesting storage permissions
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M && checkStorage)
-            if (!checkStoragePermission())
-                requestStoragePermission();
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M && checkStorage && !checkStoragePermission()) {
+            requestStoragePermission();
+        }
     }
 
-
-    @Override
-    protected void onDestroy() {
-        super.onDestroy();
-    }
     public boolean checkStoragePermission() {
-
         // Verify that all required contact permissions have been granted.
         return ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE)
                 == PackageManager.PERMISSION_GRANTED;
     }
 
-    void requestStoragePermission() {
+    public void requestStoragePermission() {
         if (ActivityCompat.shouldShowRequestPermissionRationale(this,
                 Manifest.permission.WRITE_EXTERNAL_STORAGE)) {
 
             // Provide an additional rationale to the user if the permission was not granted
             // and the user would benefit from additional context for the use of the permission.
             // For example, if the request has been denied previously.
-            final MaterialDialog materialDialog = GeneralDialogCreation.showBasicDialog(this, accentSkin, getAppTheme(), new String[]{getResources().getString(R.string.granttext), getResources().getString(R.string.grantper), getResources().getString(R.string.grant), getResources().getString(R.string.cancel), null});
-            materialDialog.getActionButton(DialogAction.POSITIVE).setOnClickListener(new View.OnClickListener() {
-                @Override
-                public void onClick(View v) {
-                    ActivityCompat
-                            .requestPermissions(BaseActivity.this, new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, 77);
-                    materialDialog.dismiss();
-                }
+            final MaterialDialog materialDialog = GeneralDialogCreation.showBasicDialog(this,
+                    new String[]{getString(R.string.granttext),
+                            getString(R.string.grantper),
+                            getString(R.string.grant),
+                            getString(R.string.cancel),
+                            null});
+            materialDialog.getActionButton(DialogAction.POSITIVE).setOnClickListener(v -> {
+                ActivityCompat.requestPermissions(ThemedActivity.this, new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, 77);
+                materialDialog.dismiss();
             });
-            materialDialog.getActionButton(DialogAction.NEGATIVE).setOnClickListener(new View.OnClickListener() {
-                @Override
-                public void onClick(View v) {
-                    finish();
-                }
+            materialDialog.getActionButton(DialogAction.NEGATIVE).setOnClickListener(v -> {
+                finish();
             });
             materialDialog.setCancelable(false);
             materialDialog.show();
@@ -97,10 +77,10 @@ public class BaseActivity extends BasicActivity {
     }
 
     void setTheme() {
-        AppTheme theme = getAppTheme();
+        AppTheme theme = getAppTheme().getSimpleTheme();
         if (Build.VERSION.SDK_INT >= 21) {
 
-            switch (accentSkin.toUpperCase()) {
+            switch (getColorPreference().getColorAsString(ColorUsage.ACCENT).toUpperCase()) {
                 case "#F44336":
                     if (theme.equals(AppTheme.LIGHT))
                         setTheme(R.style.pref_accent_light_red);
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/AppsAdapter.java b/app/src/main/java/com/amaze/filemanager/adapters/AppsAdapter.java
index 9965766d7..0312f9611 100644
--- a/app/src/main/java/com/amaze/filemanager/adapters/AppsAdapter.java
+++ b/app/src/main/java/com/amaze/filemanager/adapters/AppsAdapter.java
@@ -29,7 +29,6 @@ import android.os.Build;
 import android.os.Environment;
 import android.util.SparseBooleanArray;
 import android.view.LayoutInflater;
-import android.view.MenuItem;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ArrayAdapter;
@@ -42,18 +41,18 @@ import android.widget.Toast;
 
 import com.afollestad.materialdialogs.MaterialDialog;
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.activities.BaseActivity;
-import com.amaze.filemanager.filesystem.BaseFile;
+import com.amaze.filemanager.activities.superclasses.ThemedActivity;
+import com.amaze.filemanager.asynchronous.asynctasks.DeleteTask;
+import com.amaze.filemanager.asynchronous.services.CopyService;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.RootHelper;
-import com.amaze.filemanager.fragments.AppsList;
-import com.amaze.filemanager.services.CopyService;
-import com.amaze.filemanager.services.DeleteTask;
-import com.amaze.filemanager.ui.LayoutElement;
+import com.amaze.filemanager.fragments.AppsListFragment;
+import com.amaze.filemanager.ui.LayoutElementParcelable;
 import com.amaze.filemanager.utils.OpenMode;
 import com.amaze.filemanager.utils.ServiceWatcherUtil;
 import com.amaze.filemanager.utils.Utils;
 import com.amaze.filemanager.utils.color.ColorUsage;
-import com.amaze.filemanager.utils.files.Futils;
+import com.amaze.filemanager.utils.files.FileUtils;
 import com.amaze.filemanager.utils.provider.UtilitiesProviderInterface;
 import com.amaze.filemanager.utils.theme.AppTheme;
 
@@ -61,20 +60,19 @@ import java.io.File;
 import java.util.ArrayList;
 import java.util.List;
 
-public class AppsAdapter extends ArrayAdapter<LayoutElement> {
+public class AppsAdapter extends ArrayAdapter<LayoutElementParcelable> {
 
     private UtilitiesProviderInterface utilsProvider;
-    Context context;
-    List<LayoutElement> items;
-    public SparseBooleanArray myChecked = new SparseBooleanArray();
-    AppsList app;
+    private Context context;
+    private SparseBooleanArray myChecked = new SparseBooleanArray();
+    private AppsListFragment app;
 
-    private BaseActivity baseActivity;
+    private ThemedActivity themedActivity;
 
-    public AppsAdapter(Context context, BaseActivity ba, UtilitiesProviderInterface utilsProvider,
-                       int resourceId, AppsList app) {
+    public AppsAdapter(Context context, ThemedActivity ba, UtilitiesProviderInterface utilsProvider,
+                       int resourceId, AppsListFragment app) {
         super(context, resourceId);
-        baseActivity = ba;
+        themedActivity = ba;
         this.utilsProvider = utilsProvider;
         this.context = context;
         this.app = app;
@@ -84,54 +82,10 @@ public class AppsAdapter extends ArrayAdapter<LayoutElement> {
         }*/
     }
 
-    public void toggleChecked(int position) {
-        if (myChecked.get(position)) {
-            myChecked.put(position, false);
-        } else {
-            myChecked.put(position, true);
-        }
-
-        notifyDataSetChanged();
-
-    }
-
-    public void toggleChecked(boolean b) {
-
-        for (int i = 0; i < items.size(); i++) {
-            myChecked.put(i, b);
-        }
-        notifyDataSetChanged();
-
-
-    }
-
-    public List<Integer> getCheckedItemPositions() {
-        List<Integer> checkedItemPositions = new ArrayList<Integer>();
-
-        for (int i = 0; i < myChecked.size(); i++) {
-            if (myChecked.get(i)) {
-                (checkedItemPositions).add(i);
-            }
-        }
-
-        return checkedItemPositions;
-    }
-
-    public boolean areAllChecked() {
-        boolean b = true;
-        for (int i = 0; i < myChecked.size(); i++) {
-            if (!myChecked.get(i)) {
-                b = false;
-            }
-        }
-        return b;
-    }
-
-    public void setData(List<LayoutElement> data) {
+    public void setData(List<LayoutElementParcelable> data) {
         clear();
 
         if (data != null) {
-            this.items = data;
             addAll(data);
         }
     }
@@ -144,12 +98,11 @@ public class AppsAdapter extends ArrayAdapter<LayoutElement> {
         ImageButton about;
     }
 
+    @Override
     public View getView(final int position, View convertView, ViewGroup parent) {
-
-        final LayoutElement rowItem = getItem(position);
+        final LayoutElementParcelable rowItem = getItem(position);
 
         View view;
-        final int p = position;
         if (convertView == null) {
             LayoutInflater mInflater = (LayoutInflater) context
                     .getSystemService(Activity.LAYOUT_INFLATER_SERVICE);
@@ -164,11 +117,10 @@ public class AppsAdapter extends ArrayAdapter<LayoutElement> {
             view.findViewById(R.id.generic_icon).setVisibility(View.GONE);
             view.findViewById(R.id.picture_icon).setVisibility(View.GONE);
             view.setTag(vholder);
-
         } else {
             view = convertView;
-
         }
+
         final ViewHolder holder = (ViewHolder) view.getTag();
         holder.apkIcon.setImageDrawable(rowItem.getImageId());
         app.ic.cancelLoad(holder.apkIcon);
@@ -182,144 +134,130 @@ public class AppsAdapter extends ArrayAdapter<LayoutElement> {
         //	File f = new File(rowItem.getDesc());
         holder.txtDesc.setText(rowItem.getSize());
         holder.rl.setClickable(true);
-        holder.rl.setOnClickListener(new View.OnClickListener() {
-
-            public void onClick(View p1) {
-                Intent i1 = app.getActivity().getPackageManager().getLaunchIntentForPackage(rowItem.getPermissions());
-                if (i1 != null)
-                    app.startActivity(i1);
-                else
-                    Toast.makeText(app.getActivity(), app.getResources().getString(R.string.not_allowed), Toast.LENGTH_LONG).show();
-                // TODO: Implement this method
-            }
+        holder.rl.setOnClickListener(p1 -> {
+            Intent i1 = app.getActivity().getPackageManager().getLaunchIntentForPackage(rowItem.getPermissions());
+            if (i1 != null)
+                app.startActivity(i1);
+            else
+                Toast.makeText(app.getActivity(), app.getResources().getString(R.string.not_allowed), Toast.LENGTH_LONG).show();
+            // TODO: Implement this method
         });
 
 
-        Boolean checked = myChecked.get(position);
-        if (checked != null) {
-
-            if (checked) {
-                holder.rl.setBackgroundColor(Utils.getColor(context, R.color.appsadapter_background));
+        if (myChecked.get(position)) {
+            holder.rl.setBackgroundColor(Utils.getColor(context, R.color.appsadapter_background));
+        } else {
+            if (utilsProvider.getAppTheme().equals(AppTheme.LIGHT)) {
+                holder.rl.setBackgroundResource(R.drawable.safr_ripple_white);
             } else {
-                if (utilsProvider.getAppTheme().equals(AppTheme.LIGHT)) {
-                    holder.rl.setBackgroundResource(R.drawable.safr_ripple_white);
-                } else {
-                    holder.rl.setBackgroundResource(R.drawable.safr_ripple_black);
-                }
+                holder.rl.setBackgroundResource(R.drawable.safr_ripple_black);
             }
         }
         return view;
     }
-    void showPopup(View v,final LayoutElement rowItem){
-        final Futils utils = utilsProvider.getFutils();
-        v.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                PopupMenu popupMenu = new PopupMenu(app.getActivity(), view);
-                popupMenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {
-                    @Override
-                    public boolean onMenuItemClick(MenuItem item) {
-                        int colorAccent = baseActivity.getColorPreference().getColor(ColorUsage.ACCENT);
-
-                        switch (item.getItemId()) {
-                            case R.id.open:
-                                Intent i1 = app.getActivity().getPackageManager().getLaunchIntentForPackage(rowItem.getPermissions());
-                                if (i1!= null)
-                                    app.startActivity(i1);
-                                else
-                                    Toast.makeText(app.getActivity(),app.getResources().getString(R.string.not_allowed), Toast.LENGTH_LONG).show();
-                                return true;
-                            case R.id.share:
-                                ArrayList<File> arrayList2=new ArrayList<File>();
-                                arrayList2.add(new File(rowItem.getDesc()));
-                                baseActivity.getColorPreference();
-                                utils.shareFiles(arrayList2, app.getActivity(), utilsProvider.getAppTheme(), colorAccent);
-                                return true;
-                            case R.id.unins:
-                                final BaseFile f1 = new BaseFile(rowItem.getDesc());
-                                f1.setMode(OpenMode.ROOT);
-
-                                if ((Integer.valueOf(rowItem.getSymlink().substring(0,
-                                        rowItem.getSymlink().indexOf("_"))) & ApplicationInfo.FLAG_SYSTEM) != 0) {
-                                    // system package
-                                    if(app.Sp.getBoolean("rootmode",false)) {
-                                        MaterialDialog.Builder builder1 = new MaterialDialog.Builder(app.getActivity());
-                                        builder1.theme(utilsProvider.getAppTheme().getMaterialDialogTheme())
-                                                .content(app.getResources().getString(R.string.unin_system_apk))
-                                                .title(app.getResources().getString(R.string.warning))
-                                                .negativeColor(colorAccent)
-                                                .positiveColor(colorAccent)
-                                                .negativeText(app.getResources().getString(R.string.no))
-                                                .positiveText(app.getResources().getString(R.string.yes))
-                                                .callback(new MaterialDialog.ButtonCallback() {
-                                                    @Override
-                                                    public void onNegative(MaterialDialog materialDialog) {
-
-                                                        materialDialog.cancel();
-                                                    }
-
-                                                    @Override
-                                                    public void onPositive(MaterialDialog materialDialog) {
-
-                                                        ArrayList<BaseFile> files = new ArrayList<>();
-                                                        if (Build.VERSION.SDK_INT >= 21) {
-                                                            String parent = f1.getParent();
-                                                            if (!parent.equals("app") && !parent.equals("priv-app")) {
-                                                                BaseFile baseFile=new BaseFile(f1.getParent());
-                                                                baseFile.setMode(OpenMode.ROOT);
-                                                                files.add(baseFile);
-                                                            }
-                                                            else files.add(f1);
-                                                        } else {
-                                                            files.add(f1);
-                                                        }
-                                                        new DeleteTask(app.getActivity().getContentResolver(), app.getActivity()).execute((files));
+    private void showPopup(View v, final LayoutElementParcelable rowItem){
+        v.setOnClickListener(view -> {
+            PopupMenu popupMenu = new PopupMenu(app.getActivity(), view);
+            popupMenu.setOnMenuItemClickListener(item -> {
+                int colorAccent = themedActivity.getColorPreference().getColor(ColorUsage.ACCENT);
+
+                switch (item.getItemId()) {
+                    case R.id.open:
+                        Intent i1 = app.getActivity().getPackageManager().getLaunchIntentForPackage(rowItem.getPermissions());
+                        if (i1!= null)
+                            app.startActivity(i1);
+                        else
+                            Toast.makeText(app.getActivity(),app.getResources().getString(R.string.not_allowed), Toast.LENGTH_LONG).show();
+                        return true;
+                    case R.id.share:
+                        ArrayList<File> arrayList2=new ArrayList<File>();
+                        arrayList2.add(new File(rowItem.getDesc()));
+                        themedActivity.getColorPreference();
+                        FileUtils.shareFiles(arrayList2, app.getActivity(), utilsProvider.getAppTheme(), colorAccent);
+                        return true;
+                    case R.id.unins:
+                        final HybridFileParcelable f1 = new HybridFileParcelable(rowItem.getDesc());
+                        f1.setMode(OpenMode.ROOT);
+
+                        if ((Integer.valueOf(rowItem.getSymlink().substring(0,
+                                rowItem.getSymlink().indexOf("_"))) & ApplicationInfo.FLAG_SYSTEM) != 0) {
+                            // system package
+                            if(app.Sp.getBoolean("rootmode",false)) {
+                                MaterialDialog.Builder builder1 = new MaterialDialog.Builder(app.getActivity());
+                                builder1.theme(utilsProvider.getAppTheme().getMaterialDialogTheme())
+                                        .content(app.getResources().getString(R.string.unin_system_apk))
+                                        .title(app.getResources().getString(R.string.warning))
+                                        .negativeColor(colorAccent)
+                                        .positiveColor(colorAccent)
+                                        .negativeText(app.getResources().getString(R.string.no))
+                                        .positiveText(app.getResources().getString(R.string.yes))
+                                        .callback(new MaterialDialog.ButtonCallback() {
+                                            @Override
+                                            public void onNegative(MaterialDialog materialDialog) {
+
+                                                materialDialog.cancel();
+                                            }
+
+                                            @Override
+                                            public void onPositive(MaterialDialog materialDialog) {
+
+                                                ArrayList<HybridFileParcelable> files = new ArrayList<>();
+                                                if (Build.VERSION.SDK_INT >= 21) {
+                                                    String parent = f1.getParent();
+                                                    if (!parent.equals("app") && !parent.equals("priv-app")) {
+                                                        HybridFileParcelable baseFile=new HybridFileParcelable(f1.getParent());
+                                                        baseFile.setMode(OpenMode.ROOT);
+                                                        files.add(baseFile);
                                                     }
-                                                }).build().show();
-                                    } else {
-                                        Toast.makeText(app.getActivity(),app.getResources().getString(R.string.enablerootmde),Toast.LENGTH_SHORT).show();
-                                    }
-                                } else {
-                                    app.unin(rowItem.getPermissions());
-                                }
-                                return true;
-                            case R.id.play:
-                                Intent intent1 = new Intent(Intent.ACTION_VIEW);
-                                intent1.setData(Uri.parse("market://details?id=" + rowItem.getPermissions()));
-                                app.startActivity(intent1);
-                                return true;
-                            case R.id.properties:
-
-                                app.startActivity(new Intent(
-                                        android.provider.Settings.ACTION_APPLICATION_DETAILS_SETTINGS,
-                                        Uri.parse("package:" + rowItem.getPermissions())));
-                                return true;
-                            case R.id.backup:
-                                Toast.makeText(app.getActivity(), app.getResources().getString( R.string.copyingapk) + Environment.getExternalStorageDirectory().getPath() + "/app_backup", Toast.LENGTH_LONG).show();
-                                File f = new File(rowItem.getDesc());
-                                ArrayList<BaseFile> ab = new ArrayList<>();
-                                File dst = new File(Environment.getExternalStorageDirectory().getPath() + "/app_backup");
-                                if(!dst.exists() || !dst.isDirectory())dst.mkdirs();
-                                Intent intent = new Intent(app.getActivity(), CopyService.class);
-                                BaseFile baseFile=RootHelper.generateBaseFile(f,true);
-                                baseFile.setName(rowItem.getTitle() + "_" +
-                                        rowItem.getSymlink().substring(rowItem.getSymlink().indexOf("_")+1) + ".apk");
-                                ab.add(baseFile);
-
-                                intent.putParcelableArrayListExtra(CopyService.TAG_COPY_SOURCES, ab);
-                                intent.putExtra(CopyService.TAG_COPY_TARGET, dst.getPath());
-                                intent.putExtra(CopyService.TAG_COPY_OPEN_MODE, 0);
-
-                                ServiceWatcherUtil.runService(app.getActivity(), intent);
-                                return true;
+                                                    else files.add(f1);
+                                                } else {
+                                                    files.add(f1);
+                                                }
+                                                new DeleteTask(app.getActivity().getContentResolver(), app.getActivity()).execute((files));
+                                            }
+                                        }).build().show();
+                            } else {
+                                Toast.makeText(app.getActivity(),app.getResources().getString(R.string.enablerootmde),Toast.LENGTH_SHORT).show();
+                            }
+                        } else {
+                            app.unin(rowItem.getPermissions());
                         }
-                        return false;
-                    }
-                });
+                        return true;
+                    case R.id.play:
+                        Intent intent1 = new Intent(Intent.ACTION_VIEW);
+                        intent1.setData(Uri.parse("market://details?id=" + rowItem.getPermissions()));
+                        app.startActivity(intent1);
+                        return true;
+                    case R.id.properties:
+
+                        app.startActivity(new Intent(
+                                android.provider.Settings.ACTION_APPLICATION_DETAILS_SETTINGS,
+                                Uri.parse("package:" + rowItem.getPermissions())));
+                        return true;
+                    case R.id.backup:
+                        Toast.makeText(app.getActivity(), app.getResources().getString( R.string.copyingapk) + Environment.getExternalStorageDirectory().getPath() + "/app_backup", Toast.LENGTH_LONG).show();
+                        File f = new File(rowItem.getDesc());
+                        ArrayList<HybridFileParcelable> ab = new ArrayList<>();
+                        File dst = new File(Environment.getExternalStorageDirectory().getPath() + "/app_backup");
+                        if(!dst.exists() || !dst.isDirectory())dst.mkdirs();
+                        Intent intent = new Intent(app.getActivity(), CopyService.class);
+                        HybridFileParcelable baseFile=RootHelper.generateBaseFile(f,true);
+                        baseFile.setName(rowItem.getTitle() + "_" +
+                                rowItem.getSymlink().substring(rowItem.getSymlink().indexOf("_")+1) + ".apk");
+                        ab.add(baseFile);
+
+                        intent.putParcelableArrayListExtra(CopyService.TAG_COPY_SOURCES, ab);
+                        intent.putExtra(CopyService.TAG_COPY_TARGET, dst.getPath());
+                        intent.putExtra(CopyService.TAG_COPY_OPEN_MODE, 0);
+
+                        ServiceWatcherUtil.runService(app.getActivity(), intent);
+                        return true;
+                }
+                return false;
+            });
 
-                popupMenu.inflate(R.menu.app_options);
-                popupMenu.show();
-            }
+            popupMenu.inflate(R.menu.app_options);
+            popupMenu.show();
         });
 
     }
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/CompressedExplorerAdapter.java b/app/src/main/java/com/amaze/filemanager/adapters/CompressedExplorerAdapter.java
new file mode 100644
index 000000000..467d0c725
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/adapters/CompressedExplorerAdapter.java
@@ -0,0 +1,316 @@
+package com.amaze.filemanager.adapters;
+
+import android.app.Activity;
+import android.content.Context;
+import android.graphics.Color;
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.GradientDrawable;
+import android.os.Build;
+import android.support.v7.widget.RecyclerView;
+import android.text.format.Formatter;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.animation.Animation;
+import android.view.animation.AnimationUtils;
+import android.widget.ImageButton;
+import android.widget.ImageView;
+import android.widget.Toast;
+
+import com.amaze.filemanager.R;
+import com.amaze.filemanager.adapters.holders.CompressedItemViewHolder;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
+import com.amaze.filemanager.filesystem.compressed.CompressedInterface;
+import com.amaze.filemanager.fragments.CompressedExplorerFragment;
+import com.amaze.filemanager.ui.CompressedObjectParcelable;
+import com.amaze.filemanager.ui.icons.Icons;
+import com.amaze.filemanager.ui.views.CircleGradientDrawable;
+import com.amaze.filemanager.utils.OpenMode;
+import com.amaze.filemanager.utils.Utils;
+import com.amaze.filemanager.utils.color.ColorUtils;
+import com.amaze.filemanager.utils.provider.UtilitiesProviderInterface;
+import com.amaze.filemanager.utils.theme.AppTheme;
+
+import java.util.ArrayList;
+
+/**
+ * Created by Arpit on 25-01-2015 edited by Emmanuel Messulam<emmanuelbendavid@gmail.com>
+ */
+public class CompressedExplorerAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolder> {
+
+    private static final int TYPE_HEADER = 0, TYPE_ITEM = 1;
+
+    public boolean stoppedAnimation = false;
+
+    private Context context;
+    private UtilitiesProviderInterface utilsProvider;
+    private Drawable folder;
+    private ArrayList<CompressedObjectParcelable> items;
+    private CompressedExplorerFragment compressedExplorerFragment;
+    private CompressedInterface compressedInterface;
+    private LayoutInflater mInflater;
+    private boolean[] itemsChecked;
+    private int offset = 0;
+
+    public CompressedExplorerAdapter(Context c, UtilitiesProviderInterface utilsProvider,
+                                     ArrayList<CompressedObjectParcelable> items,
+                                     CompressedExplorerFragment compressedExplorerFragment,
+                                     CompressedInterface compressedInterface) {
+        setHasStableIds(true);
+
+        this.utilsProvider = utilsProvider;
+        this.items = items;
+        this.compressedInterface = compressedInterface;
+
+        itemsChecked = new boolean[items.size()];
+
+        context = c;
+        if (c == null) return;
+        folder = c.getResources().getDrawable(R.drawable.ic_grid_folder_new);
+        this.compressedExplorerFragment = compressedExplorerFragment;
+        mInflater = (LayoutInflater) c.getSystemService(Activity.LAYOUT_INFLATER_SERVICE);
+    }
+
+    public void toggleChecked(boolean check) {
+        int k = 0;
+
+        for (int i = k; i < items.size(); i++) {
+            itemsChecked[i] = check;
+            notifyItemChanged(i);
+        }
+    }
+
+    public ArrayList<Integer> getCheckedItemPositions() {
+        ArrayList<Integer> checkedItemPositions = new ArrayList<>();
+
+        for (int i = 0; i < itemsChecked.length; i++) {
+            if (itemsChecked[i]) {
+                (checkedItemPositions).add(i);
+            }
+        }
+
+        return checkedItemPositions;
+    }
+
+    /**
+     * called as to toggle selection of any item in adapter
+     *
+     * @param position  the position of the item
+     * @param imageView the circular {@link CircleGradientDrawable} that is to be animated
+     */
+    private void toggleChecked(int position, ImageView imageView) {
+        compressedExplorerFragment.stopAnim();
+        stoppedAnimation = true;
+
+        Animation animation;
+        if (itemsChecked[position]) {
+            animation = AnimationUtils.loadAnimation(context, R.anim.check_out);
+        } else {
+            animation = AnimationUtils.loadAnimation(context, R.anim.check_in);
+        }
+
+        if (imageView != null) {
+            imageView.setAnimation(animation);
+        } else {
+            // TODO: we don't have the check icon object probably because of config change
+        }
+
+        itemsChecked[position] = !itemsChecked[position];
+
+        notifyDataSetChanged();
+        if (!compressedExplorerFragment.selection || compressedExplorerFragment.mActionMode == null) {
+            compressedExplorerFragment.selection = true;
+            /*compressedExplorerFragment.mActionMode = compressedExplorerFragment.getActivity().startActionMode(
+                   compressedExplorerFragment.mActionModeCallback);*/
+            compressedExplorerFragment.mActionMode = compressedExplorerFragment.mainActivity.getAppbar().getToolbar().startActionMode(compressedExplorerFragment.mActionModeCallback);
+        }
+        compressedExplorerFragment.mActionMode.invalidate();
+        if (getCheckedItemPositions().size() == 0) {
+            compressedExplorerFragment.selection = false;
+            compressedExplorerFragment.mActionMode.finish();
+            compressedExplorerFragment.mActionMode = null;
+        }
+    }
+
+    private void animate(CompressedItemViewHolder holder) {
+        holder.rl.clearAnimation();
+        Animation localAnimation = AnimationUtils.loadAnimation(compressedExplorerFragment.getActivity(), R.anim.fade_in_top);
+        localAnimation.setStartOffset(this.offset);
+        holder.rl.startAnimation(localAnimation);
+        this.offset = (30 + this.offset);
+    }
+
+    public void generateZip(ArrayList<CompressedObjectParcelable> arrayList) {
+        offset = 0;
+        stoppedAnimation = false;
+        items = arrayList;
+        notifyDataSetChanged();
+        itemsChecked = new boolean[items.size()];
+    }
+
+    @Override
+    public long getItemId(int position) {
+        return position;
+    }
+
+    @Override
+    public int getItemViewType(int position) {
+        if (isPositionHeader(position))
+            return TYPE_HEADER;
+
+        return TYPE_ITEM;
+    }
+
+    @Override
+    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+        if (viewType == TYPE_HEADER) {
+            View v = mInflater.inflate(R.layout.rowlayout, parent, false);
+            v.findViewById(R.id.picture_icon).setVisibility(View.INVISIBLE);
+            return new CompressedItemViewHolder(v);
+        } else if(viewType == TYPE_ITEM) {
+            View v = mInflater.inflate(R.layout.rowlayout, parent, false);
+            CompressedItemViewHolder vh = new CompressedItemViewHolder(v);
+            ImageButton about = (ImageButton) v.findViewById(R.id.properties);
+            about.setVisibility(View.INVISIBLE);
+            return vh;
+        } else {
+            throw new IllegalStateException();
+        }
+    }
+
+    @Override
+    public void onBindViewHolder(final RecyclerView.ViewHolder vholder, int position) {
+        CompressedItemViewHolder holder = (CompressedItemViewHolder) vholder;
+
+        if (!stoppedAnimation) {
+            animate((CompressedItemViewHolder) vholder);
+        }
+
+        final CompressedObjectParcelable rowItem = items.get(position);
+        GradientDrawable gradientDrawable = (GradientDrawable) holder.genericIcon.getBackground();
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
+            holder.checkImageView.setBackground(new CircleGradientDrawable(compressedExplorerFragment.accentColor,
+                    utilsProvider.getAppTheme(), compressedExplorerFragment.getResources().getDisplayMetrics()));
+        } else
+            holder.checkImageView.setBackgroundDrawable(new CircleGradientDrawable(compressedExplorerFragment.accentColor,
+                    utilsProvider.getAppTheme(), compressedExplorerFragment.getResources().getDisplayMetrics()));
+
+        if (rowItem.getType() == CompressedObjectParcelable.TYPE_GOBACK) {
+            holder.genericIcon.setImageDrawable(compressedExplorerFragment.getResources().getDrawable(R.drawable.ic_arrow_left_white_24dp));
+            gradientDrawable.setColor(Utils.getColor(context, R.color.goback_item));
+            holder.txtTitle.setText("..");
+            holder.txtDesc.setText("");
+            holder.date.setText(R.string.goback);
+        } else {
+            holder.genericIcon.setImageDrawable(Icons.loadMimeIcon(rowItem.getName(), false, context.getResources()));
+            final StringBuilder stringBuilder = new StringBuilder(rowItem.getName());
+            if (compressedExplorerFragment.showLastModified)
+                holder.date.setText(Utils.getDate(rowItem.getTime(), compressedExplorerFragment.year));
+            if (rowItem.isDirectory()) {
+                holder.genericIcon.setImageDrawable(folder);
+                gradientDrawable.setColor(Color.parseColor(compressedExplorerFragment.iconskin));
+                if (stringBuilder.toString().length() > 0) {
+                    stringBuilder.deleteCharAt(rowItem.getName().length() - 1);
+                    try {
+                        holder.txtTitle.setText(stringBuilder.toString().substring(stringBuilder.toString().lastIndexOf("/") + 1));
+                    } catch (Exception e) {
+                        holder.txtTitle.setText(rowItem.getName().substring(0, rowItem.getName().lastIndexOf("/")));
+                    }
+                }
+            } else {
+                if (compressedExplorerFragment.showSize)
+                    holder.txtDesc.setText(Formatter.formatFileSize(context, rowItem.getSize()));
+                holder.txtTitle.setText(rowItem.getName().substring(rowItem.getName().lastIndexOf("/") + 1));
+                if (compressedExplorerFragment.coloriseIcons) {
+                    ColorUtils.colorizeIcons(context, Icons.getTypeOfFile(rowItem.getName()),
+                            gradientDrawable, Color.parseColor(compressedExplorerFragment.iconskin));
+                } else gradientDrawable.setColor(Color.parseColor(compressedExplorerFragment.iconskin));
+            }
+        }
+
+        holder.rl.setOnLongClickListener(view -> {
+            if (rowItem.getType() != CompressedObjectParcelable.TYPE_GOBACK) {
+                toggleChecked(position, holder.checkImageView);
+            }
+            return true;
+        });
+        holder.genericIcon.setOnClickListener(view -> {
+            if (rowItem.getType() != CompressedObjectParcelable.TYPE_GOBACK) {
+                toggleChecked(position, holder.checkImageView);
+            }
+        });
+        if (utilsProvider.getAppTheme().equals(AppTheme.LIGHT)) {
+            holder.rl.setBackgroundResource(R.drawable.safr_ripple_white);
+        } else {
+            holder.rl.setBackgroundResource(R.drawable.safr_ripple_black);
+        }
+        holder.rl.setSelected(false);
+        if (itemsChecked[position]) {
+            //holder.genericIcon.setImageDrawable(compressedExplorerFragment.getResources().getDrawable(R.drawable.abc_ic_cab_done_holo_dark));
+            holder.checkImageView.setVisibility(View.VISIBLE);
+            gradientDrawable.setColor(Utils.getColor(context, R.color.goback_item));
+            holder.rl.setSelected(true);
+        } else holder.checkImageView.setVisibility(View.INVISIBLE);
+
+        holder.rl.setOnClickListener(p1 -> {
+            if (rowItem.getType() == CompressedObjectParcelable.TYPE_GOBACK)
+                compressedExplorerFragment.goBack();
+            else {
+                if (compressedExplorerFragment.selection) {
+                    toggleChecked(position, holder.checkImageView);
+                } else {
+                    final StringBuilder stringBuilder = new StringBuilder(rowItem.getName());
+                    if (rowItem.isDirectory())
+                        stringBuilder.deleteCharAt(rowItem.getName().length() - 1);
+
+                    if (rowItem.isDirectory()) {
+                        compressedExplorerFragment.changePath(stringBuilder.toString());
+                    } else {
+                        String fileName = compressedExplorerFragment.compressedFile.getName().substring(0,
+                                compressedExplorerFragment.compressedFile.getName().lastIndexOf("."));
+                        String archiveCacheDirPath = compressedExplorerFragment.getActivity().getExternalCacheDir().getPath() +
+                                "/" + fileName;
+
+                        HybridFileParcelable file = new HybridFileParcelable(archiveCacheDirPath + "/"
+                                + rowItem.getName().replaceAll("\\\\", "/"));
+                        file.setMode(OpenMode.FILE);
+                        // this file will be opened once service finishes up it's extraction
+                        compressedExplorerFragment.files.add(file);
+                        // setting flag for binder to know
+                        compressedExplorerFragment.isOpen = true;
+
+                        Toast.makeText(compressedExplorerFragment.getContext(),
+                                compressedExplorerFragment.getContext().getResources().getString(R.string.please_wait),
+                                Toast.LENGTH_SHORT).show();
+                        compressedInterface.decompress(compressedExplorerFragment.getActivity().getExternalCacheDir().getPath(),
+                                new String[]{rowItem.getName()});
+                    }
+                }
+            }
+        });
+    }
+
+    @Override
+    public int getItemCount() {
+        return items.size();
+    }
+
+    @Override
+    public void onViewDetachedFromWindow(RecyclerView.ViewHolder holder) {
+        super.onViewAttachedToWindow(holder);
+        ((CompressedItemViewHolder) holder).rl.clearAnimation();
+    }
+
+    @Override
+    public boolean onFailedToRecycleView(RecyclerView.ViewHolder holder) {
+        ((CompressedItemViewHolder) holder).rl.clearAnimation();
+        return super.onFailedToRecycleView(holder);
+    }
+
+    private boolean isPositionHeader(int position) {
+        return false;// TODO:
+    }
+
+}
+
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/DrawerAdapter.java b/app/src/main/java/com/amaze/filemanager/adapters/DrawerAdapter.java
index 01ebdc68d..74fd089e9 100644
--- a/app/src/main/java/com/amaze/filemanager/adapters/DrawerAdapter.java
+++ b/app/src/main/java/com/amaze/filemanager/adapters/DrawerAdapter.java
@@ -35,35 +35,32 @@ import android.widget.TextView;
 import android.widget.Toast;
 
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.activities.BaseActivity;
 import com.amaze.filemanager.activities.MainActivity;
+import com.amaze.filemanager.activities.superclasses.ThemedActivity;
 import com.amaze.filemanager.database.CloudHandler;
-import com.amaze.filemanager.filesystem.HFile;
+import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.Operations;
 import com.amaze.filemanager.filesystem.RootHelper;
 import com.amaze.filemanager.ui.dialogs.GeneralDialogCreation;
 import com.amaze.filemanager.ui.drawer.EntryItem;
 import com.amaze.filemanager.ui.drawer.Item;
 import com.amaze.filemanager.utils.DataUtils;
-import com.amaze.filemanager.utils.cloud.CloudUtil;
 import com.amaze.filemanager.utils.OpenMode;
 import com.amaze.filemanager.utils.Utils;
+import com.amaze.filemanager.utils.cloud.CloudUtil;
+import com.amaze.filemanager.utils.color.ColorUsage;
 import com.amaze.filemanager.utils.provider.UtilitiesProviderInterface;
 import com.amaze.filemanager.utils.theme.AppTheme;
 
 import java.io.File;
 import java.util.ArrayList;
-import java.util.HashMap;
 
 public class DrawerAdapter extends ArrayAdapter<Item> {
     private final Context context;
     private UtilitiesProviderInterface utilsProvider;
     private final ArrayList<Item> values;
     private MainActivity m;
-    private Float[] color;
     private SparseBooleanArray myChecked = new SparseBooleanArray();
-    //TODO queried but never updated
-    private HashMap<String, Float[]> colors = new HashMap<>();
     private DataUtils dataUtils = DataUtils.getInstance();
 
     public void toggleChecked(int position) {
@@ -80,9 +77,9 @@ public class DrawerAdapter extends ArrayAdapter<Item> {
     }
 
     private LayoutInflater inflater;
-    private int fabskin;
 
-    public DrawerAdapter(Context context, UtilitiesProviderInterface utilsProvider, ArrayList<Item> values, MainActivity m, SharedPreferences Sp) {
+    public DrawerAdapter(Context context, UtilitiesProviderInterface utilsProvider,
+                         ArrayList<Item> values, MainActivity m, SharedPreferences Sp) {
         super(context, R.layout.drawerrow, values);
         this.utilsProvider = utilsProvider;
 
@@ -93,11 +90,6 @@ public class DrawerAdapter extends ArrayAdapter<Item> {
             myChecked.put(i, false);
         }
         this.m = m;
-        fabskin = Color.parseColor(BaseActivity.accentSkin);
-        color = colors.get(BaseActivity.accentSkin);
-        if (color == null) {
-            color = colors.get("#e91e63");
-        }
         inflater = (LayoutInflater) context
                 .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
     }
@@ -116,8 +108,8 @@ public class DrawerAdapter extends ArrayAdapter<Item> {
             if (utilsProvider.getAppTheme().equals(AppTheme.LIGHT))
                 view.setBackgroundColor(Color.WHITE);
             else view.setBackgroundResource(R.color.background_material_dark);
-            view.setLayoutParams(new AbsListView.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, m.dpToPx(17)));
-            view.setPadding(0, m.dpToPx(8), 0, m.dpToPx(8));
+            view.setLayoutParams(new AbsListView.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, Utils.dpToPx(m, 17)));
+            view.setPadding(0, Utils.dpToPx(m, 8), 0, Utils.dpToPx(m, 8));
             return view;
         } else {
             View view = inflater.inflate(R.layout.drawerrow, parent, false);
@@ -128,79 +120,75 @@ public class DrawerAdapter extends ArrayAdapter<Item> {
             } else {
                 view.setBackgroundResource(R.drawable.safr_ripple_black);
             }
-            view.setOnClickListener(new View.OnClickListener() {
+            view.setOnClickListener(p1 -> {
+                EntryItem item = (EntryItem) getItem(position);
 
-                public void onClick(View p1) {
-                    EntryItem item = (EntryItem) getItem(position);
-
-                    if (dataUtils.containsBooks(new String[]{item.getTitle(), item.getPath()}) != -1) {
-
-                        checkForPath(item.getPath());
-                    }
+                if (dataUtils.containsBooks(new String[]{item.getTitle(), item.getPath()}) != -1) {
 
-                    if (dataUtils.getAccounts().size() > 0 && (item.getPath().startsWith(CloudHandler.CLOUD_PREFIX_BOX) ||
-                                    item.getPath().startsWith(CloudHandler.CLOUD_PREFIX_DROPBOX) ||
-                                    item.getPath().startsWith(CloudHandler.CLOUD_PREFIX_ONE_DRIVE) ||
-                                    item.getPath().startsWith(CloudHandler.CLOUD_PREFIX_GOOGLE_DRIVE))) {
-                        // we have cloud accounts, try see if token is expired or not
-                        CloudUtil.checkToken(item.getPath(), m);
-                    }
-                    m.selectItem(position);
+                    checkForPath(item.getPath());
                 }
-                // TODO: Implement this method
 
+                if (dataUtils.getAccounts().size() > 0 && (item.getPath().startsWith(CloudHandler.CLOUD_PREFIX_BOX) ||
+                                item.getPath().startsWith(CloudHandler.CLOUD_PREFIX_DROPBOX) ||
+                                item.getPath().startsWith(CloudHandler.CLOUD_PREFIX_ONE_DRIVE) ||
+                                item.getPath().startsWith(CloudHandler.CLOUD_PREFIX_GOOGLE_DRIVE))) {
+                    // we have cloud accounts, try see if token is expired or not
+                    CloudUtil.checkToken(item.getPath(), m);
+                }
+                m.selectItem(position);
             });
-            view.setOnLongClickListener(new View.OnLongClickListener() {
-                @Override
-                public boolean onLongClick(View v) {
-                    if (!getItem(position).isSection())
-                        // not to remove the first bookmark (storage) and permanent bookmarks
-                        if (position > m.storage_count && position < values.size() - 7) {
-                            EntryItem item = (EntryItem) getItem(position);
-                            String title = item.getTitle();
-                            String path = (item).getPath();
-                            if (dataUtils.containsBooks(new String[]{item.getTitle(), path}) != -1) {
-                                m.renameBookmark((item).getTitle(), path);
-                            } else if (path.startsWith("smb:/")) {
-                                m.showSMBDialog(item.getTitle(), path, true);
-                            } else if (path.startsWith("ssh:/")) {
-                                m.showSftpDialog(item.getTitle(), path, true);
-                            } else if (path.startsWith(CloudHandler.CLOUD_PREFIX_DROPBOX)) {
-
-                                GeneralDialogCreation.showCloudDialog(m, utilsProvider.getAppTheme(), OpenMode.DROPBOX);
-
-                            } else if (path.startsWith(CloudHandler.CLOUD_PREFIX_GOOGLE_DRIVE)) {
-
-                                GeneralDialogCreation.showCloudDialog(m, utilsProvider.getAppTheme(), OpenMode.GDRIVE);
-
-                            } else if (path.startsWith(CloudHandler.CLOUD_PREFIX_BOX)) {
-
-                                GeneralDialogCreation.showCloudDialog(m, utilsProvider.getAppTheme(), OpenMode.BOX);
-
-                            } else if (path.startsWith(CloudHandler.CLOUD_PREFIX_ONE_DRIVE)) {
-
-                                GeneralDialogCreation.showCloudDialog(m, utilsProvider.getAppTheme(), OpenMode.ONEDRIVE);
-                            }
-                        } else if (position < m.storage_count) {
-                            String path = ((EntryItem) getItem(position)).getPath();
-                            if (!path.equals("/"))
-                                GeneralDialogCreation.showPropertiesDialogForStorage(RootHelper.generateBaseFile(new File(path), true), m, utilsProvider.getAppTheme());
+            view.setOnLongClickListener(v -> {
+                if (!getItem(position).isSection())
+                    // not to remove the first bookmark (storage) and permanent bookmarks
+                    if (position > m.storage_count && position < values.size() - 7) {
+                        EntryItem item = (EntryItem) getItem(position);
+                        String title = item.getTitle();
+                        String path = (item).getPath();
+                        if (dataUtils.containsBooks(new String[]{item.getTitle(), path}) != -1) {
+                            m.renameBookmark((item).getTitle(), path);
+                        } else if (path.startsWith("smb:/")) {
+                            m.showSMBDialog(item.getTitle(), path, true);
+                        } else if (path.startsWith("ssh:/")) {
+                            m.showSftpDialog(item.getTitle(), path, true);
+                        } else if (path.startsWith(CloudHandler.CLOUD_PREFIX_DROPBOX)) {
+
+                            GeneralDialogCreation.showCloudDialog(m, utilsProvider.getAppTheme(), OpenMode.DROPBOX);
+
+                        } else if (path.startsWith(CloudHandler.CLOUD_PREFIX_GOOGLE_DRIVE)) {
+
+                            GeneralDialogCreation.showCloudDialog(m, utilsProvider.getAppTheme(), OpenMode.GDRIVE);
+
+                        } else if (path.startsWith(CloudHandler.CLOUD_PREFIX_BOX)) {
+
+                            GeneralDialogCreation.showCloudDialog(m, utilsProvider.getAppTheme(), OpenMode.BOX);
+
+                        } else if (path.startsWith(CloudHandler.CLOUD_PREFIX_ONE_DRIVE)) {
+
+                            GeneralDialogCreation.showCloudDialog(m, utilsProvider.getAppTheme(), OpenMode.ONEDRIVE);
                         }
+                    } else if (position < m.storage_count) {
+                        String path = ((EntryItem) getItem(position)).getPath();
+                        if (!path.equals("/"))
+                            GeneralDialogCreation.showPropertiesDialogForStorage(RootHelper.generateBaseFile(new File(path), true), m, utilsProvider.getAppTheme());
+                    }
 
-                    // return true to denote no further processing
-                    return true;
-                }
+                // return true to denote no further processing
+                return true;
             });
 
             txtTitle.setText(((EntryItem) (values.get(position))).getTitle());
             imageView.setImageDrawable(getDrawable(position));
             imageView.clearColorFilter();
+
             if (myChecked.get(position)) {
-                if (utilsProvider.getAppTheme().equals(AppTheme.LIGHT))
+                int accentColor = m.getColorPreference().getColor(ColorUsage.ACCENT);
+                if (utilsProvider.getAppTheme().equals(AppTheme.LIGHT)) {
                     view.setBackgroundColor(Color.parseColor("#ffeeeeee"));
-                else view.setBackgroundColor(Color.parseColor("#ff424242"));
-                imageView.setColorFilter(fabskin);
-                txtTitle.setTextColor(Color.parseColor(BaseActivity.accentSkin));
+                } else {
+                    view.setBackgroundColor(Color.parseColor("#ff424242"));
+                }
+                imageView.setColorFilter(accentColor);
+                txtTitle.setTextColor(accentColor);
             } else {
                 if (utilsProvider.getAppTheme().equals(AppTheme.LIGHT)) {
                     imageView.setColorFilter(Color.parseColor("#666666"));
@@ -226,30 +214,30 @@ public class DrawerAdapter extends ArrayAdapter<Item> {
         if (!new File(path).exists()) {
             Toast.makeText(getContext(), getContext().getString(R.string.bookmark_lost), Toast.LENGTH_SHORT).show();
             Operations.mkdir(RootHelper.generateBaseFile(new File(path), true), getContext(),
-                    BaseActivity.rootMode, new Operations.ErrorCallBack() {
+                    ThemedActivity.rootMode, new Operations.ErrorCallBack() {
                         //TODO empty
                         @Override
-                        public void exists(HFile file) {
+                        public void exists(HybridFile file) {
 
                         }
 
                         @Override
-                        public void launchSAF(HFile file) {
+                        public void launchSAF(HybridFile file) {
 
                         }
 
                         @Override
-                        public void launchSAF(HFile file, HFile file1) {
+                        public void launchSAF(HybridFile file, HybridFile file1) {
 
                         }
 
                         @Override
-                        public void done(HFile hFile, boolean b) {
+                        public void done(HybridFile hFile, boolean b) {
 
                         }
 
                         @Override
-                        public void invalidName(HFile file) {
+                        public void invalidName(HybridFile file) {
 
                         }
                     });
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/HiddenAdapter.java b/app/src/main/java/com/amaze/filemanager/adapters/HiddenAdapter.java
index 20075c4d6..f6ffa1f3e 100644
--- a/app/src/main/java/com/amaze/filemanager/adapters/HiddenAdapter.java
+++ b/app/src/main/java/com/amaze/filemanager/adapters/HiddenAdapter.java
@@ -2,141 +2,115 @@ package com.amaze.filemanager.adapters;
 
 import android.app.Activity;
 import android.content.Context;
-import android.support.annotation.LayoutRes;
+import android.content.SharedPreferences;
 import android.support.v7.widget.RecyclerView;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
-import android.widget.ImageButton;
-import android.widget.LinearLayout;
-import android.widget.TextView;
 
 import com.afollestad.materialdialogs.MaterialDialog;
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.MainActivity;
-import com.amaze.filemanager.filesystem.BaseFile;
-import com.amaze.filemanager.filesystem.HFile;
+import com.amaze.filemanager.adapters.holders.HiddenViewHolder;
+import com.amaze.filemanager.asynchronous.asynctasks.DeleteTask;
+import com.amaze.filemanager.filesystem.HybridFile;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.fragments.MainFragment;
-import com.amaze.filemanager.services.DeleteTask;
 import com.amaze.filemanager.utils.DataUtils;
-import com.amaze.filemanager.utils.files.Futils;
 import com.amaze.filemanager.utils.OpenMode;
+import com.amaze.filemanager.utils.files.FileUtils;
 
 import java.io.File;
 import java.util.ArrayList;
 
 
 /**
- * Created by Arpit on 16-11-2014.
+ * Created by Arpit on 16-11-2014 edited by Emmanuel Messulam <emmanuelbendavid@gmail.com>
  */
-public class HiddenAdapter extends RecyclerArrayAdapter<HFile, HiddenAdapter.ViewHolder> {
-
-    private Futils utils;
+public class HiddenAdapter extends RecyclerView.Adapter<HiddenViewHolder> {
 
+    private SharedPreferences sharedPrefs;
     private MainFragment context;
     private Context c;
-    public ArrayList<HFile> items;
+    private ArrayList<HybridFile> items;
     private MaterialDialog materialDialog;
     private boolean hide;
     private DataUtils dataUtils = DataUtils.getInstance();
-    ///	public HashMap<Integer, Boolean> myChecked = new HashMap<Integer, Boolean>();
 
-    public HiddenAdapter(Context context, MainFragment mainFrag, Futils utils, @LayoutRes int layoutId,
-                         ArrayList<HFile> items, MaterialDialog materialDialog, boolean hide) {
-        addAll(items);
-        this.utils = utils;
+    public HiddenAdapter(Context context, MainFragment mainFrag, SharedPreferences sharedPreferences,
+                         ArrayList<HybridFile> items, MaterialDialog materialDialog, boolean hide) {
         this.c = context;
         this.context = mainFrag;
-        this.items = items;
+        sharedPrefs = sharedPreferences;
+        this.items = new ArrayList<>(items);
         this.hide = hide;
         this.materialDialog = materialDialog;
     }
 
     @Override
-    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+    public HiddenViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
         LayoutInflater mInflater = (LayoutInflater) c
                 .getSystemService(Activity.LAYOUT_INFLATER_SERVICE);
         View view = mInflater.inflate(R.layout.bookmarkrow, parent, false);
 
-        return new ViewHolder(view);
+        return new HiddenViewHolder(view);
     }
 
     @Override
-    public void onBindViewHolder(ViewHolder holder, int position) {
-        holder.render(position, getItem(position));
-    }
-
-    class ViewHolder extends RecyclerView.ViewHolder {
-        private ImageButton image;
-        private TextView txtTitle;
-        private TextView txtDesc;
-        private LinearLayout row;
+    public void onBindViewHolder(HiddenViewHolder holder, int position) {
+        HybridFile file = items.get(position);
 
-        ViewHolder(View view) {
-            super(view);
+        holder.getTxtTitle().setText(file.getName());
+        String a = file.getReadablePath(file.getPath());
+        holder.getTxtDesc().setText(a);
 
-            txtTitle = (TextView) view.findViewById(R.id.text1);
-            image = (ImageButton) view.findViewById(R.id.delete_button);
-            txtDesc = (TextView) view.findViewById(R.id.text2);
-            row = (LinearLayout) view.findViewById(R.id.bookmarkrow);
+        if (hide) {
+            holder.getImage().setVisibility(View.GONE);
         }
 
-        void render(final int position, final HFile file) {
-            txtTitle.setText(file.getName());
-            String a = file.getReadablePath(file.getPath());
-            txtDesc.setText(a);
-
-            if (hide)
-                image.setVisibility(View.GONE);
-
-            // TODO: move the listeners to the constructor
-            image.setOnClickListener(new View.OnClickListener() {
-                @Override
-                public void onClick(View view) {
-                    if (!file.isSmb() && file.isDirectory()) {
-                        ArrayList<BaseFile> a = new ArrayList<>();
-                        BaseFile baseFile = new BaseFile(items.get(position).getPath() + "/.nomedia");
-                        baseFile.setMode(OpenMode.FILE);
-                        a.add(baseFile);
-                        new DeleteTask(context.getActivity().getContentResolver(), c).execute((a));
+        // TODO: move the listeners to the constructor
+        holder.getImage().setOnClickListener(view -> {
+            if (!file.isSmb() && file.isDirectory()) {
+                ArrayList<HybridFileParcelable> a1 = new ArrayList<>();
+                HybridFileParcelable baseFile = new HybridFileParcelable(items.get(position).getPath() + "/.nomedia");
+                baseFile.setMode(OpenMode.FILE);
+                a1.add(baseFile);
+                new DeleteTask(context.getActivity().getContentResolver(), c).execute((a1));
+            }
+            dataUtils.removeHiddenFile(items.get(position).getPath());
+            items.remove(items.get(position));
+            notifyDataSetChanged();
+        });
+        holder.getRow().setOnClickListener(view -> {
+            materialDialog.dismiss();
+            new Thread(() -> {
+                if (file.isDirectory()) {
+                    context.getActivity().runOnUiThread(() -> {
+                        context.loadlist(file.getPath(), false, OpenMode.UNKNOWN);
+                    });
+                } else {
+                    if (!file.isSmb()) {
+                        context.getActivity().runOnUiThread(() -> {
+                            FileUtils.openFile(new File(file.getPath()), (MainActivity) context.getActivity(), sharedPrefs);
+                        });
                     }
-                    dataUtils.removeHiddenFile(items.get(position).getPath());
-                    items.remove(items.get(position));
-                    notifyDataSetChanged();
                 }
-            });
-            row.setOnClickListener(new View.OnClickListener() {
-                @Override
-                public void onClick(View view) {
-                    materialDialog.dismiss();
-                    new Thread(new Runnable() {
-                        @Override
-                        public void run() {
-                            if (file.isDirectory()) {
-                                context.getActivity().runOnUiThread(new Runnable() {
-                                    @Override
-                                    public void run() {
-                                        context.loadlist(file.getPath(), false, OpenMode.UNKNOWN);
-                                    }
-                                });
-                            } else {
-                                if (!file.isSmb()) {
-                                    context.getActivity().runOnUiThread(new Runnable() {
-                                        @Override
-                                        public void run() {
-                                            utils.openFile(new File(file.getPath()), (MainActivity) context.getActivity());
-                                        }
-                                    });
-                                }
-                            }
-                        }
-                    }).start();
-                }
-            });
-        }
+            }).start();
+        });
     }
 
     public void updateDialog(MaterialDialog dialog) {
         materialDialog = dialog;
     }
+
+    @Override
+    public long getItemId(int position) {
+        return position;
+    }
+
+    @Override
+    public int getItemCount() {
+        return items.size();
+    }
+
 }
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/RarAdapter.java b/app/src/main/java/com/amaze/filemanager/adapters/RarAdapter.java
deleted file mode 100644
index 337c8a4c3..000000000
--- a/app/src/main/java/com/amaze/filemanager/adapters/RarAdapter.java
+++ /dev/null
@@ -1,527 +0,0 @@
-package com.amaze.filemanager.adapters;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.graphics.Color;
-import android.graphics.drawable.Drawable;
-import android.graphics.drawable.GradientDrawable;
-import android.os.Build;
-import android.support.v7.widget.RecyclerView;
-import android.text.format.Formatter;
-import android.util.SparseBooleanArray;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.animation.Animation;
-import android.view.animation.AnimationUtils;
-import android.widget.ImageButton;
-import android.widget.ImageView;
-import android.widget.TextView;
-import android.widget.Toast;
-
-import com.amaze.filemanager.R;
-import com.amaze.filemanager.filesystem.BaseFile;
-import com.amaze.filemanager.fragments.ZipViewer;
-import com.amaze.filemanager.services.ExtractService;
-import com.amaze.filemanager.services.asynctasks.RarHelperTask;
-import com.amaze.filemanager.services.asynctasks.ZipHelperTask;
-import com.amaze.filemanager.ui.ZipObj;
-import com.amaze.filemanager.ui.icons.Icons;
-import com.amaze.filemanager.ui.views.CircleGradientDrawable;
-import com.amaze.filemanager.ui.views.RoundedImageView;
-import com.amaze.filemanager.utils.OpenMode;
-import com.amaze.filemanager.utils.ServiceWatcherUtil;
-import com.amaze.filemanager.utils.Utils;
-import com.amaze.filemanager.utils.color.ColorUtils;
-import com.amaze.filemanager.utils.provider.UtilitiesProviderInterface;
-import com.amaze.filemanager.utils.theme.AppTheme;
-import com.github.junrar.rarfile.FileHeader;
-
-import java.util.ArrayList;
-
-/**
- * Created by Arpit on 25-01-2015.
- */
-public class RarAdapter extends RecyclerArrayAdapter<String, RecyclerView.ViewHolder> {
-
-    private Context c;
-    private UtilitiesProviderInterface utilsProvider;
-    private Drawable folder, unknown;
-    private ArrayList<FileHeader> enter;
-    private ArrayList<ZipObj> enter1;
-    private ZipViewer zipViewer;
-    private LayoutInflater mInflater;
-    private SparseBooleanArray myChecked = new SparseBooleanArray();
-    private boolean zipMode = false;  // flag specify whether adapter is based on a Rar file or not
-
-    public RarAdapter(Context c, UtilitiesProviderInterface utilsProvider, ArrayList<FileHeader> enter, ZipViewer zipViewer) {
-        this.utilsProvider = utilsProvider;
-        this.enter = enter;
-        for (int i = 0; i < enter.size(); i++)
-            myChecked.put(i, false);
-
-        mInflater = (LayoutInflater) c.getSystemService(Activity.LAYOUT_INFLATER_SERVICE);
-        this.c = c;
-        folder = c.getResources().getDrawable(R.drawable.ic_grid_folder_new);
-        unknown = c.getResources().getDrawable(R.drawable.ic_doc_generic_am);
-        this.zipViewer = zipViewer;
-    }
-
-    public RarAdapter(Context c, UtilitiesProviderInterface utilsProvider, ArrayList<ZipObj> enter, ZipViewer zipViewer, boolean l) {
-        this.utilsProvider = utilsProvider;
-        this.enter1 = enter;
-        for (int i = 0; i < enter.size(); i++) {
-            myChecked.put(i, false);
-        }
-        zipMode = true;
-        this.c = c;
-        if (c == null) return;
-        folder = c.getResources().getDrawable(R.drawable.ic_grid_folder_new);
-        unknown = c.getResources().getDrawable(R.drawable.ic_doc_generic_am);
-        this.zipViewer = zipViewer;
-        mInflater = (LayoutInflater) c.getSystemService(Activity.LAYOUT_INFLATER_SERVICE);
-    }
-
-    /**
-     * called as to toggle selection of any item in adapter
-     *
-     * @param position  the position of the item
-     * @param imageView the circular {@link CircleGradientDrawable} that is to be animated
-     */
-    private void toggleChecked(int position, ImageView imageView) {
-        zipViewer.stopAnim();
-        stoppedAnimation = true;
-        if (myChecked.get(position)) {
-            // if the view at position is checked, un-check it
-            myChecked.put(position, false);
-            Animation checkOutAnimation = AnimationUtils.loadAnimation(c, R.anim.check_out);
-            if (imageView != null) {
-
-                imageView.setAnimation(checkOutAnimation);
-            } else {
-                // TODO: we don't have the check icon object probably because of config change
-            }
-        } else {
-            // if view is un-checked, check it
-            myChecked.put(position, true);
-
-            Animation iconAnimation = AnimationUtils.loadAnimation(c, R.anim.check_in);
-            if (imageView != null) {
-
-                imageView.setAnimation(iconAnimation);
-            } else {
-                // TODO: we don't have the check icon object probably because of config change
-            }
-        }
-
-        notifyDataSetChanged();
-        if (!zipViewer.selection || zipViewer.mActionMode == null) {
-            zipViewer.selection = true;
-            /*zipViewer.mActionMode = zipViewer.getActivity().startActionMode(
-                   zipViewer.mActionModeCallback);*/
-            zipViewer.mActionMode = zipViewer.mainActivity.toolbar.startActionMode(zipViewer.mActionModeCallback);
-        }
-        zipViewer.mActionMode.invalidate();
-        if (getCheckedItemPositions().size() == 0) {
-            zipViewer.selection = false;
-            zipViewer.mActionMode.finish();
-            zipViewer.mActionMode = null;
-        }
-    }
-
-    public void toggleChecked(boolean b, String path) {
-        int k = 0;
-        // if(enter.get(0).getEntry()==null)k=1;
-        for (int i = k; i < (zipMode ? enter1.size() : enter.size()); i++) {
-            myChecked.put(i, b);
-            notifyItemChanged(i);
-        }
-    }
-
-    public ArrayList<Integer> getCheckedItemPositions() {
-        ArrayList<Integer> checkedItemPositions = new ArrayList<>();
-
-        for (int i = 0; i < myChecked.size(); i++) {
-            if (myChecked.get(i)) {
-                (checkedItemPositions).add(i);
-            }
-        }
-
-        return checkedItemPositions;
-    }
-
-    private static class ViewHolder extends RecyclerView.ViewHolder {
-        // each data item is just a string in this case
-        RoundedImageView pictureIcon;
-        ImageView genericIcon, apkIcon;
-        TextView txtTitle;
-        TextView txtDesc;
-        public TextView date;
-        TextView perm;
-        View rl;
-        ImageView checkImageView;
-
-        ViewHolder(View view) {
-            super(view);
-            txtTitle = (TextView) view.findViewById(R.id.firstline);
-            pictureIcon = (RoundedImageView) view.findViewById(R.id.picture_icon);
-            genericIcon = (ImageView) view.findViewById(R.id.generic_icon);
-            rl = view.findViewById(R.id.second);
-            perm = (TextView) view.findViewById(R.id.permis);
-            date = (TextView) view.findViewById(R.id.date);
-            txtDesc = (TextView) view.findViewById(R.id.secondLine);
-            apkIcon = (ImageView) view.findViewById(R.id.apk_icon);
-            checkImageView = (ImageView) view.findViewById(R.id.check_icon);
-        }
-    }
-
-    @Override
-    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
-        if (viewType == 0) {
-            View v = mInflater.inflate(R.layout.rowlayout, parent, false);
-            v.findViewById(R.id.picture_icon).setVisibility(View.INVISIBLE);
-            return new ViewHolder(v);
-
-        }
-        View v = mInflater.inflate(R.layout.rowlayout, parent, false);
-        ViewHolder vh = new ViewHolder(v);
-        ImageButton about = (ImageButton) v.findViewById(R.id.properties);
-        about.setVisibility(View.INVISIBLE);
-        return vh;
-    }
-
-    private int offset = 0;
-    public boolean stoppedAnimation = false;
-    private Animation localAnimation;
-
-    @Override
-    public void onViewDetachedFromWindow(RecyclerView.ViewHolder holder) {
-        super.onViewAttachedToWindow(holder);
-        ((ViewHolder) holder).rl.clearAnimation();
-    }
-
-    @Override
-    public boolean onFailedToRecycleView(RecyclerView.ViewHolder holder) {
-        ((ViewHolder) holder).rl.clearAnimation();
-        return super.onFailedToRecycleView(holder);
-    }
-
-    private void animate(RarAdapter.ViewHolder holder) {
-        holder.rl.clearAnimation();
-        localAnimation = AnimationUtils.loadAnimation(zipViewer.getActivity(), R.anim.fade_in_top);
-        localAnimation.setStartOffset(this.offset);
-        holder.rl.startAnimation(localAnimation);
-        this.offset = (30 + this.offset);
-    }
-
-    public void generate(ArrayList<FileHeader> arrayList) {
-        offset = 0;
-        stoppedAnimation = false;
-        notifyDataSetChanged();
-        enter = arrayList;
-    }
-
-    public void generate(ArrayList<ZipObj> arrayList, boolean zipMode) {
-        offset = 0;
-        stoppedAnimation = false;
-        notifyDataSetChanged();
-        enter1 = arrayList;
-    }
-
-    /**
-     * onBindViewHolder for zip files
-     *
-     * @param vholder   the ElementViewHolder reference for instantiating views
-     * @param position1 the position of the view to bind
-     */
-    private void onBindView(RecyclerView.ViewHolder vholder, final int position1) {
-        final RarAdapter.ViewHolder holder = ((RarAdapter.ViewHolder) vholder);
-        if (!this.stoppedAnimation) {
-            animate(holder);
-        }
-        final ZipObj rowItem = enter1.get(position1);
-        GradientDrawable gradientDrawable = (GradientDrawable) holder.genericIcon.getBackground();
-
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
-            holder.checkImageView.setBackground(new CircleGradientDrawable(zipViewer.accentColor,
-                    utilsProvider.getAppTheme(), zipViewer.getResources().getDisplayMetrics()));
-        } else
-            holder.checkImageView.setBackgroundDrawable(new CircleGradientDrawable(zipViewer.accentColor,
-                    utilsProvider.getAppTheme(), zipViewer.getResources().getDisplayMetrics()));
-
-        if (rowItem.getEntry() == null) {
-            holder.genericIcon.setImageDrawable(zipViewer.getResources().getDrawable(R.drawable.ic_arrow_left_white_24dp));
-            gradientDrawable.setColor(Utils.getColor(c, R.color.goback_item));
-            holder.txtTitle.setText("..");
-            holder.txtDesc.setText("");
-            holder.date.setText(R.string.goback);
-        } else {
-            holder.genericIcon.setImageDrawable(Icons.loadMimeIcon(rowItem.getName(), false, zipViewer.res));
-            final StringBuilder stringBuilder = new StringBuilder(rowItem.getName());
-            if (zipViewer.showLastModified)
-                holder.date.setText(Utils.getDate(rowItem.getTime(), zipViewer.year));
-            if (rowItem.isDirectory()) {
-                holder.genericIcon.setImageDrawable(folder);
-                gradientDrawable.setColor(Color.parseColor(zipViewer.iconskin));
-                if (stringBuilder.toString().length() > 0) {
-                    stringBuilder.deleteCharAt(rowItem.getName().length() - 1);
-                    try {
-                        holder.txtTitle.setText(stringBuilder.toString().substring(stringBuilder.toString().lastIndexOf("/") + 1));
-                    } catch (Exception e) {
-                        holder.txtTitle.setText(rowItem.getName().substring(0, rowItem.getName().lastIndexOf("/")));
-                    }
-                }
-            } else {
-                if (zipViewer.showSize)
-                    holder.txtDesc.setText(Formatter.formatFileSize(c, rowItem.getSize()));
-                holder.txtTitle.setText(rowItem.getName().substring(rowItem.getName().lastIndexOf("/") + 1));
-                if (zipViewer.coloriseIcons) {
-                    ColorUtils.colorizeIcons(c, Icons.getTypeOfFile(rowItem.getName()),
-                            gradientDrawable, Color.parseColor(zipViewer.iconskin));
-                } else gradientDrawable.setColor(Color.parseColor(zipViewer.iconskin));
-            }
-        }
-
-
-        holder.rl.setOnLongClickListener(new View.OnLongClickListener() {
-            @Override
-            public boolean onLongClick(View view) {
-                if (rowItem.getEntry() != null) {
-
-                    toggleChecked(position1, holder.checkImageView);
-                }
-                return true;
-            }
-        });
-        holder.genericIcon.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-
-                if (rowItem.getEntry() != null) {
-                    toggleChecked(position1, holder.checkImageView);
-                }
-            }
-        });
-        Boolean checked = myChecked.get(position1);
-        if (checked != null) {
-            if (utilsProvider.getAppTheme().equals(AppTheme.LIGHT)) {
-
-                holder.rl.setBackgroundResource(R.drawable.safr_ripple_white);
-            } else {
-
-                holder.rl.setBackgroundResource(R.drawable.safr_ripple_black);
-
-            }
-            holder.rl.setSelected(false);
-            if (checked) {
-                //holder.genericIcon.setImageDrawable(zipViewer.getResources().getDrawable(R.drawable.abc_ic_cab_done_holo_dark));
-                holder.checkImageView.setVisibility(View.VISIBLE);
-                gradientDrawable.setColor(Utils.getColor(c, R.color.goback_item));
-                holder.rl.setSelected(true);
-            } else holder.checkImageView.setVisibility(View.INVISIBLE);
-        }
-        holder.rl.setOnClickListener(new View.OnClickListener() {
-
-            public void onClick(View p1) {
-                if (rowItem.getEntry() == null)
-                    zipViewer.goBack();
-                else {
-                    if (zipViewer.selection) {
-
-                        toggleChecked(position1, holder.checkImageView);
-                    } else {
-                        final StringBuilder stringBuilder = new StringBuilder(rowItem.getName());
-                        if (rowItem.isDirectory())
-                            stringBuilder.deleteCharAt(rowItem.getName().length() - 1);
-
-                        if (rowItem.isDirectory()) {
-
-                            new ZipHelperTask(zipViewer, stringBuilder.toString()).execute(zipViewer.s);
-
-                        } else {
-
-                            String fileName = zipViewer.f.getName().substring(0,
-                                    zipViewer.f.getName().lastIndexOf("."));
-                            String archiveCacheDirPath = zipViewer.getActivity().getExternalCacheDir().getPath() +
-                                    "/" + fileName;
-
-                            BaseFile file = new BaseFile(archiveCacheDirPath + "/"
-                                    + rowItem.getName().replaceAll("\\\\", "/"));
-                            file.setMode(OpenMode.FILE);
-                            // this file will be opened once service finishes up it's extraction
-                            zipViewer.files.add(file);
-                            // setting flag for binder to know
-                            zipViewer.isOpen = true;
-
-                            Toast.makeText(zipViewer.getContext(),
-                                    zipViewer.getContext().getResources().getString(R.string.please_wait),
-                                    Toast.LENGTH_SHORT).show();
-                            Intent intent = new Intent(zipViewer.getContext(), ExtractService.class);
-                            ArrayList<String> a = new ArrayList<>();
-
-                            // adding name of entry to extract from zip, before opening it
-                            a.add(rowItem.getName());
-                            intent.putExtra(ExtractService.KEY_PATH_ZIP, zipViewer.f.getPath());
-                            intent.putExtra(ExtractService.KEY_ENTRIES_ZIP, a);
-                            intent.putExtra(ExtractService.KEY_PATH_EXTRACT,
-                                    zipViewer.getActivity().getExternalCacheDir().getPath());
-                            ServiceWatcherUtil.runService(zipViewer.getContext(), intent);
-                        }
-                    }
-                }
-            }
-        });
-    }
-
-    @Override
-    public void onBindViewHolder(RecyclerView.ViewHolder vholder, final int position1) {
-        if (zipMode) {
-            onBindView(vholder, position1);
-            return;
-        }
-        final RarAdapter.ViewHolder holder = ((RarAdapter.ViewHolder) vholder);
-        if (!this.stoppedAnimation) {
-            animate(holder);
-        }
-        if (position1 < 0) return;
-        final FileHeader rowItem = enter.get(position1);
-        zipViewer.elementsRar.add(position1, headerRequired(rowItem));
-
-        GradientDrawable gradientDrawable = (GradientDrawable) holder.genericIcon.getBackground();
-
-        holder.genericIcon.setImageDrawable(Icons.loadMimeIcon(rowItem.getFileNameString(), false, zipViewer.res));
-        holder.txtTitle.setText(rowItem.getFileNameString().substring(rowItem.getFileNameString().lastIndexOf("\\") + 1));
-
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
-            holder.checkImageView.setBackground(new CircleGradientDrawable(zipViewer.accentColor,
-                    utilsProvider.getAppTheme(), zipViewer.getResources().getDisplayMetrics()));
-        } else
-            holder.checkImageView.setBackgroundDrawable(new CircleGradientDrawable(zipViewer.accentColor,
-                    utilsProvider.getAppTheme(), zipViewer.getResources().getDisplayMetrics()));
-
-        if (rowItem.isDirectory()) {
-            holder.genericIcon.setImageDrawable(folder);
-            gradientDrawable.setColor(Color.parseColor(zipViewer.iconskin));
-        } else {
-            if (zipViewer.coloriseIcons) {
-                ColorUtils.colorizeIcons(c, Icons.getTypeOfFile(rowItem.getFileNameString()),
-                        gradientDrawable, Color.parseColor(zipViewer.iconskin));
-            } else gradientDrawable.setColor(Color.parseColor(zipViewer.iconskin));
-        }
-
-
-        holder.rl.setOnLongClickListener(new View.OnLongClickListener() {
-            @Override
-            public boolean onLongClick(View view) {
-
-                toggleChecked(position1, holder.checkImageView);
-                return true;
-            }
-        });
-        holder.genericIcon.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-
-                toggleChecked(position1, holder.checkImageView);
-            }
-
-        });
-        Boolean checked = myChecked.get(position1);
-        if (checked != null) {
-            if (utilsProvider.getAppTheme().equals(AppTheme.LIGHT)) {
-
-                holder.rl.setBackgroundResource(R.drawable.safr_ripple_white);
-            } else {
-
-                holder.rl.setBackgroundResource(R.drawable.safr_ripple_black);
-            }
-            holder.rl.setSelected(false);
-            if (checked) {
-                //holder.genericIcon.setImageDrawable(zipViewer.getResources().getDrawable(R.drawable.abc_ic_cab_done_holo_dark));
-                holder.checkImageView.setVisibility(View.VISIBLE);
-                gradientDrawable.setColor(Utils.getColor(c, R.color.goback_item));
-                holder.rl.setSelected(true);
-            } else holder.checkImageView.setVisibility(View.INVISIBLE);
-        }
-        holder.rl.setOnClickListener(new View.OnClickListener() {
-
-            public void onClick(View p1) {
-                if (zipViewer.selection) {
-
-                    toggleChecked(position1, holder.checkImageView);
-                } else {
-
-                    if (rowItem.isDirectory()) {
-
-                        zipViewer.elementsRar.clear();
-                        new RarHelperTask(zipViewer, rowItem.getFileNameString()).execute
-                                (zipViewer.f);
-
-                    } else {
-                        String fileName = zipViewer.f.getName().substring(0,
-                                zipViewer.f.getName().lastIndexOf("."));
-                        String archiveCacheDirPath = zipViewer.getActivity().getExternalCacheDir().getPath() +
-                                "/" + fileName;
-
-                        BaseFile file1 = new BaseFile(archiveCacheDirPath + "/"
-                                + rowItem.getFileNameString().replaceAll("\\\\", "/"));
-                        file1.setMode(OpenMode.FILE);
-
-                        // this file will be opened once service finishes up it's extraction
-                        zipViewer.files.add(file1);
-                        // setting flag for binder to know
-                        zipViewer.isOpen = true;
-
-                        Toast.makeText(zipViewer.getContext(),
-                                zipViewer.getContext().getResources().getString(R.string.please_wait),
-                                Toast.LENGTH_SHORT).show();
-                        Intent intent = new Intent(zipViewer.getContext(), ExtractService.class);
-                        ArrayList<String> a = new ArrayList<>();
-
-                        // adding name of entry to extract from zip, before opening it
-                        a.add(rowItem.getFileNameString());
-                        intent.putExtra(ExtractService.KEY_PATH_ZIP, zipViewer.f.getPath());
-                        intent.putExtra(ExtractService.KEY_ENTRIES_ZIP, a);
-                        intent.putExtra(ExtractService.KEY_PATH_EXTRACT,
-                                zipViewer.getActivity().getExternalCacheDir().getPath());
-                        ServiceWatcherUtil.runService(zipViewer.getContext(), intent);
-                    }
-                }
-            }
-        });
-    }
-
-    private static final int TYPE_HEADER = 0;
-    private static final int TYPE_ITEM = 1;
-
-    @Override
-    public int getItemViewType(int position) {
-        if (isPositionHeader(position))
-            return TYPE_HEADER;
-
-        return TYPE_ITEM;
-    }
-
-    private boolean isPositionHeader(int position) {
-        return false;
-    }
-
-
-    private FileHeader headerRequired(FileHeader rowItem) {
-
-        for (FileHeader fileHeader : zipViewer.archive.getFileHeaders()) {
-            String req = fileHeader.getFileNameString();
-            if (rowItem.getFileNameString().equals(req))
-                return fileHeader;
-        }
-        return null;
-    }
-
-    @Override
-    public int getItemCount() {
-        return zipMode ? enter1.size() : enter.size();
-    }
-
-}
-
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/RecyclerAdapter.java b/app/src/main/java/com/amaze/filemanager/adapters/RecyclerAdapter.java
index 1532c4763..63243f6e4 100644
--- a/app/src/main/java/com/amaze/filemanager/adapters/RecyclerAdapter.java
+++ b/app/src/main/java/com/amaze/filemanager/adapters/RecyclerAdapter.java
@@ -2,6 +2,7 @@ package com.amaze.filemanager.adapters;
 
 import android.app.Activity;
 import android.content.Context;
+import android.content.SharedPreferences;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
 import android.graphics.Color;
@@ -9,7 +10,6 @@ import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.GradientDrawable;
 import android.os.Build;
 import android.support.v7.widget.RecyclerView;
-import android.util.SparseBooleanArray;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
@@ -24,7 +24,7 @@ import com.amaze.filemanager.adapters.holders.ItemViewHolder;
 import com.amaze.filemanager.adapters.holders.SpecialViewHolder;
 import com.amaze.filemanager.fragments.MainFragment;
 import com.amaze.filemanager.ui.ItemPopupMenu;
-import com.amaze.filemanager.ui.LayoutElement;
+import com.amaze.filemanager.ui.LayoutElementParcelable;
 import com.amaze.filemanager.ui.icons.Icons;
 import com.amaze.filemanager.ui.icons.MimeTypes;
 import com.amaze.filemanager.ui.views.CircleGradientDrawable;
@@ -42,11 +42,12 @@ import java.util.ArrayList;
  * There are 3 types of item TYPE_ITEM, TYPE_HEADER_FOLDERS and TYPE_HEADER_FILES and EMPTY_LAST_ITEM
  * represeted by ItemViewHolder, SpecialViewHolder and EmptyViewHolder respectively.
  * The showPopup shows the file's popup menu.
- * TODO optimize checking items (all the toggleChecked()).
+ * The 'go to parent' aka '..' button (go to settings to activate it) is just a folder.
  *
  * Created by Arpit on 11-04-2015 edited by Emmanuel Messulam <emmanuelbendavid@gmail.com>
+ *                                edited by Jens Klingenberg <mail@jensklingenberg.de>
  */
-public class RecyclerAdapter extends RecyclerArrayAdapter<String, RecyclerView.ViewHolder> {
+public class RecyclerAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolder> {
 
     private static final int PICTURE_FILETYPE = 0, APK_FILETYPE = 1, VIDEO_FILETYPE = 2,
             GENERIC_FILETYPE = 3, ENCRYPTED_FILETYPE = 4;
@@ -60,23 +61,24 @@ public class RecyclerAdapter extends RecyclerArrayAdapter<String, RecyclerView.V
 
     private UtilitiesProviderInterface utilsProvider;
     private MainFragment mainFrag;
+    private SharedPreferences sharedPrefs;
     private boolean showHeaders;
     private ArrayList<ListItem> itemsDigested = new ArrayList<>();
     private Context context;
-    private SparseBooleanArray checkedItems = new SparseBooleanArray();
-    private SparseBooleanArray animation = new SparseBooleanArray();
     private LayoutInflater mInflater;
     private float minRowHeight;
     private int grey_color, accentColor, iconSkinColor, goBackColor, videoColor, audioColor,
             pdfColor, codeColor, textColor, archiveColor, genericColor;
     private int offset = 0;
 
+    public RecyclerAdapter(MainFragment m, UtilitiesProviderInterface utilsProvider, SharedPreferences sharedPrefs,
+                           ArrayList<LayoutElementParcelable> itemsRaw, Context context, boolean showHeaders) {
+        setHasStableIds(true);
 
-    public RecyclerAdapter(MainFragment m, UtilitiesProviderInterface utilsProvider,
-                           ArrayList<LayoutElement> itemsRaw, Context context, boolean showHeaders) {
         this.mainFrag = m;
         this.utilsProvider = utilsProvider;
         this.context = context;
+        this.sharedPrefs = sharedPrefs;
         this.showHeaders = showHeaders;
 
         mInflater = (LayoutInflater) context.getSystemService(Activity.LAYOUT_INFLATER_SERVICE);
@@ -103,10 +105,14 @@ public class RecyclerAdapter extends RecyclerArrayAdapter<String, RecyclerView.V
      * @param imageView the check {@link CircleGradientDrawable} that is to be animated
      */
     public void toggleChecked(int position, ImageView imageView) {
+        if(itemsDigested.get(position).getChecked() == ListItem.UNCHECKABLE) {
+            throw new IllegalArgumentException("You have checked a header");
+        }
+
         if (!stoppedAnimation) mainFrag.stopAnimation();
-        if (checkedItems.get(position)) {
+        if (itemsDigested.get(position).getChecked() == ListItem.CHECKED) {
             // if the view at position is checked, un-check it
-            checkedItems.put(position, false);
+            itemsDigested.get(position).setChecked(false);
 
             Animation iconAnimation = AnimationUtils.loadAnimation(context, R.anim.check_out);
             if (imageView != null) {
@@ -116,7 +122,7 @@ public class RecyclerAdapter extends RecyclerArrayAdapter<String, RecyclerView.V
             }
         } else {
             // if view is un-checked, check it
-            checkedItems.put(position, true);
+            itemsDigested.get(position).setChecked(true);
 
             Animation iconAnimation = AnimationUtils.loadAnimation(context, R.anim.check_in);
             if (imageView != null) {
@@ -149,7 +155,7 @@ public class RecyclerAdapter extends RecyclerArrayAdapter<String, RecyclerView.V
         int i = path.equals("/") || !mainFrag.GO_BACK_ITEM ? 0 : 1;
 
         for (; i < itemsDigested.size(); i++) {
-            checkedItems.put(i, b);
+            itemsDigested.get(i).setChecked(b);
             notifyItemChanged(i);
         }
 
@@ -173,7 +179,7 @@ public class RecyclerAdapter extends RecyclerArrayAdapter<String, RecyclerView.V
      */
     public void toggleChecked(boolean b) {
         for (int i = 0; i < itemsDigested.size(); i++) {
-            checkedItems.put(i, b);
+            itemsDigested.get(i).setChecked(b);
             notifyItemChanged(i);
         }
 
@@ -189,31 +195,43 @@ public class RecyclerAdapter extends RecyclerArrayAdapter<String, RecyclerView.V
         }
     }
 
-    public ArrayList<LayoutElement> getCheckedItems() {
-        ArrayList<LayoutElement> checkedItems = new ArrayList<>();
+    public ArrayList<LayoutElementParcelable> getCheckedItems() {
+        ArrayList<LayoutElementParcelable> selected = new ArrayList<>();
 
-        for (int i = 0; i < this.checkedItems.size(); i++) {
-            if (this.checkedItems.get(i)) {
-                checkedItems.add(itemsDigested.get(i).elem);
+        for (int i = 0; i < itemsDigested.size(); i++) {
+            if (itemsDigested.get(i).getChecked() == ListItem.CHECKED) {
+                selected.add(itemsDigested.get(i).elem);
             }
         }
 
-        return checkedItems;
+        return selected;
     }
 
     public boolean areAllChecked(String path) {
         boolean allChecked = true;
-        int i;
-        if (path.equals("/") || !mainFrag.GO_BACK_ITEM) i = 0;
-        else i = 1;
-        for (; i < checkedItems.size(); i++) {
-            if (!checkedItems.get(i)) {
+        int i = (path.equals("/") || !mainFrag.GO_BACK_ITEM)? 0:1;
+
+        for (; i < itemsDigested.size(); i++) {
+            if (itemsDigested.get(i).getChecked() == ListItem.NOT_CHECKED) {
                 allChecked = false;
             }
         }
+
         return allChecked;
     }
 
+    public ArrayList<Integer> getCheckedItemsIndex() {
+        ArrayList<Integer> checked = new ArrayList<>();
+
+        for (int i = 0; i < itemsDigested.size(); i++) {
+            if (itemsDigested.get(i).getChecked() == ListItem.CHECKED) {
+                checked.add(i);
+            }
+        }
+
+        return checked;
+    }
+
     @Override
     public void onViewDetachedFromWindow(RecyclerView.ViewHolder holder) {
         super.onViewAttachedToWindow(holder);
@@ -241,7 +259,7 @@ public class RecyclerAdapter extends RecyclerArrayAdapter<String, RecyclerView.V
      * after you are finished you must call createHeaders
      * @param e
      */
-    public void addItem(LayoutElement e) {
+    public void addItem(LayoutElementParcelable e) {
         if (mainFrag.IS_LIST && itemsDigested.size() > 0) {
             itemsDigested.add(itemsDigested.size()-1, new ListItem(e));
         } else if(mainFrag.IS_LIST) {
@@ -254,33 +272,29 @@ public class RecyclerAdapter extends RecyclerArrayAdapter<String, RecyclerView.V
         notifyItemInserted(getItemCount());
     }
 
-    public void setItems(ArrayList<LayoutElement> arrayList) {
+    public void setItems(ArrayList<LayoutElementParcelable> arrayList) {
         setItems(arrayList, true);
     }
 
-    private void setItems(ArrayList<LayoutElement> arrayList, boolean invalidate) {
-        synchronized (arrayList) {
-            itemsDigested.clear();
-            checkedItems.clear();
-            offset = 0;
-            stoppedAnimation = false;
+    private void setItems(ArrayList<LayoutElementParcelable> arrayList, boolean invalidate) {
+        itemsDigested.clear();
+        offset = 0;
+        stoppedAnimation = false;
 
-            for (LayoutElement e : arrayList) {
-                itemsDigested.add(new ListItem(e));
-            }
+        for (LayoutElementParcelable e : arrayList) {
+            itemsDigested.add(new ListItem(e));
+        }
 
-            if (mainFrag.IS_LIST && itemsDigested.size() > 0) {
-                itemsDigested.add(new ListItem(EMPTY_LAST_ITEM));
-            }
+        if (mainFrag.IS_LIST && itemsDigested.size() > 0) {
+            itemsDigested.add(new ListItem(EMPTY_LAST_ITEM));
+        }
 
-            for (int i = 0; i < itemsDigested.size(); i++) {
-                checkedItems.put(i, false);
-                animation.put(i, false);
-            }
+        for (int i = 0; i < itemsDigested.size(); i++) {
+            itemsDigested.get(i).setAnimate(false);
+        }
 
-            if(showHeaders) {
-                createHeaders(invalidate);
-            }
+        if (showHeaders) {
+            createHeaders(invalidate);
         }
     }
 
@@ -288,9 +302,9 @@ public class RecyclerAdapter extends RecyclerArrayAdapter<String, RecyclerView.V
         boolean[] headers = new boolean[]{false, false};
 
         for (int i = 0; i < itemsDigested.size(); i++) {
-            if(mainFrag.IS_LIST) {// TODO: 31/5/2017 add fragments to gird view
+            
                 if (itemsDigested.get(i).elem != null) {
-                    LayoutElement nextItem = itemsDigested.get(i).elem;
+                    LayoutElementParcelable nextItem = itemsDigested.get(i).elem;
 
                     if (!headers[0] && nextItem.isDirectory()) {
                         headers[0] = true;
@@ -305,7 +319,7 @@ public class RecyclerAdapter extends RecyclerArrayAdapter<String, RecyclerView.V
                         continue;//leave this continue for symmetry
                     }
                 }
-            }
+
         }
 
         if(invalidate) {
@@ -318,6 +332,11 @@ public class RecyclerAdapter extends RecyclerArrayAdapter<String, RecyclerView.V
         return itemsDigested.size();
     }
 
+    @Override
+    public long getItemId(int position) {
+        return position;
+    }
+
     @Override
     public int getItemViewType(int position) {
         if(itemsDigested.get(position).specialType != -1) {
@@ -329,26 +348,34 @@ public class RecyclerAdapter extends RecyclerArrayAdapter<String, RecyclerView.V
 
     @Override
     public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
-        View v;
+        View view;
 
         switch (viewType) {
             case TYPE_HEADER_FOLDERS:
             case TYPE_HEADER_FILES:
-                v = mInflater.inflate(R.layout.list_header, parent, false);
+
+                if (mainFrag.IS_LIST) {
+
+                    view = mInflater.inflate(R.layout.list_header, parent, false);
+                } else {
+
+                    view = mInflater.inflate(R.layout.grid_header, parent, false);
+                }
+
                 int type = viewType == TYPE_HEADER_FOLDERS ? SpecialViewHolder.HEADER_FOLDERS : SpecialViewHolder.HEADER_FILES;
 
-                return new SpecialViewHolder(context, v, utilsProvider, type);
+                return new SpecialViewHolder(context, view, utilsProvider, type);
             case TYPE_ITEM:
-                if (mainFrag.IS_LIST) v = mInflater.inflate(R.layout.rowlayout, parent, false);
-                else v = mInflater.inflate(R.layout.griditem, parent, false);
+                if (mainFrag.IS_LIST) view = mInflater.inflate(R.layout.rowlayout, parent, false);
+                else view = mInflater.inflate(R.layout.griditem, parent, false);
 
-                return new ItemViewHolder(v);
+                return new ItemViewHolder(view);
             case EMPTY_LAST_ITEM:
                 int totalFabHeight = (int) context.getResources().getDimension(R.dimen.fab_height),
                         marginFab = (int) context.getResources().getDimension(R.dimen.fab_margin);
-                v = new View(context);
-                v.setMinimumHeight(totalFabHeight + marginFab);
-                return new EmptyViewHolder(v);
+                view = new View(context);
+                view.setMinimumHeight(totalFabHeight + marginFab);
+                return new EmptyViewHolder(view);
             default:
                 throw new IllegalArgumentException("Illegal: " + viewType);
         }
@@ -358,6 +385,8 @@ public class RecyclerAdapter extends RecyclerArrayAdapter<String, RecyclerView.V
     public void onBindViewHolder(final RecyclerView.ViewHolder vholder, int p) {
         if(vholder instanceof ItemViewHolder) {
             final ItemViewHolder holder = (ItemViewHolder) vholder;
+            final boolean isBackButton = mainFrag.GO_BACK_ITEM && p == 0;
+
             if (mainFrag.IS_LIST) {
                 if (p == getItemCount() - 1) {
                     holder.rl.setMinimumHeight((int) minRowHeight);
@@ -367,18 +396,15 @@ public class RecyclerAdapter extends RecyclerArrayAdapter<String, RecyclerView.V
                     return;
                 }
             }
-            if (!this.stoppedAnimation && !animation.get(p)) {
+            if (!this.stoppedAnimation && !itemsDigested.get(p).getAnimating()) {
                 animate(holder);
-                animation.put(p, true);
+                itemsDigested.get(p).setAnimate(true);
             }
-            final LayoutElement rowItem = itemsDigested.get(p).elem;
+            final LayoutElementParcelable rowItem = itemsDigested.get(p).elem;
             if (mainFrag.IS_LIST) {
-                holder.rl.setOnClickListener(new View.OnClickListener() {
-                    @Override
-                    public void onClick(View v) {
-                        mainFrag.onListItemClicked(vholder.getAdapterPosition(), rowItem,
-                                holder.checkImageView);
-                    }
+                holder.rl.setOnClickListener(v -> {
+                    mainFrag.onListItemClicked(isBackButton, vholder.getAdapterPosition(), rowItem,
+                            holder.checkImageView);
                 });
 
                 if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
@@ -389,16 +415,13 @@ public class RecyclerAdapter extends RecyclerArrayAdapter<String, RecyclerView.V
                             utilsProvider.getAppTheme(), mainFrag.getResources().getDisplayMetrics()));
                 }
 
-                holder.rl.setOnLongClickListener(new View.OnLongClickListener() {
-
-                    public boolean onLongClick(View p1) {
-                        // check if the item on which action is performed is not the first {goback} item
-                        if (!rowItem.getSize().equals(mainFrag.goback)) {
-                            toggleChecked(vholder.getAdapterPosition(), holder.checkImageView);
-                        }
-
-                        return true;
+                holder.rl.setOnLongClickListener(p1 -> {
+                    // check if the item on which action is performed is not the first {goback} item
+                    if (!isBackButton) {
+                        toggleChecked(vholder.getAdapterPosition(), holder.checkImageView);
                     }
+
+                    return true;
                 });
 
                 int filetype = -1;
@@ -430,35 +453,26 @@ public class RecyclerAdapter extends RecyclerArrayAdapter<String, RecyclerView.V
                         holder.about.setColorFilter(grey_color);
                     showPopup(holder.about, rowItem, p);
                 }
-                holder.genericIcon.setOnClickListener(new View.OnClickListener() {
-                    @Override
-                    public void onClick(View v) {
-                        int id = v.getId();
-                        if (id == R.id.generic_icon || id == R.id.picture_icon || id == R.id.apk_icon) {
-                            // TODO: transform icon on press to the properties dialog with animation
-                            if (!rowItem.getSize().equals(mainFrag.goback)) {
-                                toggleChecked(vholder.getAdapterPosition(), holder.checkImageView);
-                            } else mainFrag.goBack();
-                        }
-                    }
-                });
-
-                holder.pictureIcon.setOnClickListener(new View.OnClickListener() {
-                    @Override
-                    public void onClick(View view) {
-                        if (!rowItem.getSize().equals(mainFrag.goback)) {
+                holder.genericIcon.setOnClickListener(v -> {
+                    int id = v.getId();
+                    if (id == R.id.generic_icon || id == R.id.picture_icon || id == R.id.apk_icon) {
+                        // TODO: transform icon on press to the properties dialog with animation
+                        if (!isBackButton) {
                             toggleChecked(vholder.getAdapterPosition(), holder.checkImageView);
                         } else mainFrag.goBack();
                     }
                 });
 
-                holder.apkIcon.setOnClickListener(new View.OnClickListener() {
-                    @Override
-                    public void onClick(View view) {
-                        if (!rowItem.getSize().equals(mainFrag.goback)) {
-                            toggleChecked(vholder.getAdapterPosition(), holder.checkImageView);
-                        } else mainFrag.goBack();
-                    }
+                holder.pictureIcon.setOnClickListener(view -> {
+                    if (!isBackButton) {
+                        toggleChecked(vholder.getAdapterPosition(), holder.checkImageView);
+                    } else mainFrag.goBack();
+                });
+
+                holder.apkIcon.setOnClickListener(view -> {
+                    if (!isBackButton) {
+                        toggleChecked(vholder.getAdapterPosition(), holder.checkImageView);
+                    } else mainFrag.goBack();
                 });
 
                 // resetting icons visibility
@@ -479,13 +493,13 @@ public class RecyclerAdapter extends RecyclerArrayAdapter<String, RecyclerView.V
                                 holder.apkIcon.setVisibility(View.GONE);
                                 holder.pictureIcon.setVisibility(View.VISIBLE);
                                 holder.pictureIcon.setImageDrawable(mainFrag.DARK_IMAGE);
-                                mainFrag.ic.cancelLoad(holder.pictureIcon);
-                                mainFrag.ic.loadDrawable(holder.pictureIcon, (rowItem.getDesc()), null);
+                                mainFrag.iconHolder.cancelLoad(holder.pictureIcon);
+                                mainFrag.iconHolder.loadDrawable(holder.pictureIcon, (rowItem.getDesc()), null);
                             } else {
                                 holder.apkIcon.setVisibility(View.VISIBLE);
                                 holder.apkIcon.setImageDrawable(mainFrag.DARK_IMAGE);
-                                mainFrag.ic.cancelLoad(holder.apkIcon);
-                                mainFrag.ic.loadDrawable(holder.apkIcon, (rowItem.getDesc()), null);
+                                mainFrag.iconHolder.cancelLoad(holder.apkIcon);
+                                mainFrag.iconHolder.loadDrawable(holder.apkIcon, (rowItem.getDesc()), null);
                             }
                         }
                         break;
@@ -495,8 +509,8 @@ public class RecyclerAdapter extends RecyclerArrayAdapter<String, RecyclerView.V
                             holder.pictureIcon.setVisibility(View.GONE);
                             holder.apkIcon.setVisibility(View.VISIBLE);
                             holder.apkIcon.setImageDrawable(mainFrag.apk);
-                            mainFrag.ic.cancelLoad(holder.apkIcon);
-                            mainFrag.ic.loadDrawable(holder.apkIcon, (rowItem.getDesc()), null);
+                            mainFrag.iconHolder.cancelLoad(holder.apkIcon);
+                            mainFrag.iconHolder.loadDrawable(holder.apkIcon, (rowItem.getDesc()), null);
                         }
                         break;
                     case VIDEO_FILETYPE:
@@ -505,13 +519,13 @@ public class RecyclerAdapter extends RecyclerArrayAdapter<String, RecyclerView.V
                             if (mainFrag.CIRCULAR_IMAGES) {
                                 holder.pictureIcon.setVisibility(View.VISIBLE);
                                 holder.pictureIcon.setImageDrawable(mainFrag.DARK_VIDEO);
-                                mainFrag.ic.cancelLoad(holder.pictureIcon);
-                                mainFrag.ic.loadDrawable(holder.pictureIcon, (rowItem.getDesc()), null);
+                                mainFrag.iconHolder.cancelLoad(holder.pictureIcon);
+                                mainFrag.iconHolder.loadDrawable(holder.pictureIcon, (rowItem.getDesc()), null);
                             } else {
                                 holder.apkIcon.setVisibility(View.VISIBLE);
                                 holder.apkIcon.setImageDrawable(mainFrag.DARK_VIDEO);
-                                mainFrag.ic.cancelLoad(holder.apkIcon);
-                                mainFrag.ic.loadDrawable(holder.apkIcon, (rowItem.getDesc()), null);
+                                mainFrag.iconHolder.cancelLoad(holder.apkIcon);
+                                mainFrag.iconHolder.loadDrawable(holder.apkIcon, (rowItem.getDesc()), null);
                             }
                         }
                         break;
@@ -558,7 +572,7 @@ public class RecyclerAdapter extends RecyclerArrayAdapter<String, RecyclerView.V
                     holder.rl.setBackgroundResource(R.drawable.safr_ripple_black);
                 }
                 holder.rl.setSelected(false);
-                if (checkedItems.get(p)) {
+                if (itemsDigested.get(p).getChecked() == ListItem.CHECKED) {
                     holder.checkImageView.setVisibility(View.VISIBLE);
                     // making sure the generic icon background color filter doesn't get changed
                     // to grey on picture/video/apk/generic text icons when checked
@@ -585,7 +599,7 @@ public class RecyclerAdapter extends RecyclerArrayAdapter<String, RecyclerView.V
                         }
                     } else gradientDrawable.setColor(iconSkinColor);
 
-                    if (rowItem.getSize().equals(mainFrag.goback))
+                    if (isBackButton)
                         gradientDrawable.setColor(goBackColor);
                 }
                 if (mainFrag.SHOW_PERMISSIONS)
@@ -595,37 +609,26 @@ public class RecyclerAdapter extends RecyclerArrayAdapter<String, RecyclerView.V
                 } else {
                     holder.date.setVisibility(View.GONE);
                 }
-                String size = rowItem.getSize();
-
-                if (size.equals(mainFrag.goback)) {
-
-                    holder.date.setText(size);
 
+                if (isBackButton) {
+                    holder.date.setText(rowItem.getSize());
                     holder.txtDesc.setText("");
-                } else if (mainFrag.SHOW_SIZE)
-
+                } else if (mainFrag.SHOW_SIZE) {
                     holder.txtDesc.setText(rowItem.getSize());
+                }
             } else {
                 // view is a grid view
-                Boolean checked = checkedItems.get(p);
-
                 holder.checkImageViewGrid.setColorFilter(accentColor);
-                holder.rl.setOnClickListener(new View.OnClickListener() {
-                    @Override
-                    public void onClick(View v) {
-                        mainFrag.onListItemClicked(vholder.getAdapterPosition(), rowItem,
-                                holder.checkImageViewGrid);
-                    }
+                holder.rl.setOnClickListener(v -> {
+                    mainFrag.onListItemClicked(isBackButton, vholder.getAdapterPosition(), rowItem,
+                            holder.checkImageViewGrid);
                 });
 
-                holder.rl.setOnLongClickListener(new View.OnLongClickListener() {
-
-                    public boolean onLongClick(View p1) {
-                        if (!rowItem.getSize().equals(mainFrag.goback)) {
-                            toggleChecked(vholder.getAdapterPosition(), holder.checkImageViewGrid);
-                        }
-                        return true;
+                holder.rl.setOnLongClickListener(p1 -> {
+                    if (!isBackButton) {
+                        toggleChecked(vholder.getAdapterPosition(), holder.checkImageViewGrid);
                     }
+                    return true;
                 });
                 holder.txtTitle.setText(rowItem.getTitle());
                 holder.imageView1.setVisibility(View.INVISIBLE);
@@ -639,12 +642,12 @@ public class RecyclerAdapter extends RecyclerArrayAdapter<String, RecyclerView.V
                     holder.imageView1.setImageDrawable(null);
                     if (utilsProvider.getAppTheme().equals(AppTheme.DARK))
                         holder.imageView1.setBackgroundColor(Color.BLACK);
-                    mainFrag.ic.cancelLoad(holder.imageView1);
-                    mainFrag.ic.loadDrawable(holder.imageView1, (rowItem.getDesc()), null);
+                    mainFrag.iconHolder.cancelLoad(holder.imageView1);
+                    mainFrag.iconHolder.loadDrawable(holder.imageView1, (rowItem.getDesc()), null);
                 } else if (Icons.isApk((rowItem.getDesc()))) {
                     holder.genericIcon.setColorFilter(null);
-                    mainFrag.ic.cancelLoad(holder.genericIcon);
-                    mainFrag.ic.loadDrawable(holder.genericIcon, (rowItem.getDesc()), null);
+                    mainFrag.iconHolder.cancelLoad(holder.genericIcon);
+                    mainFrag.iconHolder.loadDrawable(holder.genericIcon, (rowItem.getDesc()), null);
                 }
 
                 if (rowItem.isDirectory()) {
@@ -682,10 +685,10 @@ public class RecyclerAdapter extends RecyclerArrayAdapter<String, RecyclerView.V
                     }
                 }
 
-                if (rowItem.getSize().equals(mainFrag.goback))
+                if (isBackButton)
                     holder.genericIcon.setColorFilter(goBackColor);
 
-                if (checked) {
+                if (itemsDigested.get(p).getChecked() == ListItem.CHECKED) {
                     holder.genericIcon.setColorFilter(iconSkinColor);
                     //holder.genericIcon.setImageDrawable(main.getResources().getDrawable(R.drawable.abc_ic_cab_done_holo_dark));
 
@@ -708,7 +711,7 @@ public class RecyclerAdapter extends RecyclerArrayAdapter<String, RecyclerView.V
                 }
                 if (mainFrag.SHOW_LAST_MODIFIED)
                     holder.date.setText(rowItem.getDate());
-                if (rowItem.getSize().equals(mainFrag.goback)) {
+                if (isBackButton) {
                     holder.date.setText(rowItem.getSize());
                     holder.txtDesc.setText("");
                 }/*else if(main.SHOW_SIZE)
@@ -720,54 +723,73 @@ public class RecyclerAdapter extends RecyclerArrayAdapter<String, RecyclerView.V
         }
     }
 
-    private void showPopup(View v, final LayoutElement rowItem, final int position) {
-        v.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                PopupMenu popupMenu = new ItemPopupMenu(context, mainFrag.getMainActivity(),
-                        utilsProvider, mainFrag, rowItem, view);
-                popupMenu.inflate(R.menu.item_extras);
-                String description = rowItem.getDesc().toLowerCase();
+    private void showPopup(View v, final LayoutElementParcelable rowItem, final int position) {
+        v.setOnClickListener(view -> {
+            PopupMenu popupMenu = new ItemPopupMenu(context, mainFrag.getMainActivity(),
+                    utilsProvider, mainFrag, rowItem, view, sharedPrefs);
+            popupMenu.inflate(R.menu.item_extras);
+            String description = rowItem.getDesc().toLowerCase();
 
-                if (rowItem.isDirectory()) {
-                    popupMenu.getMenu().findItem(R.id.open_with).setVisible(false);
-                    popupMenu.getMenu().findItem(R.id.share).setVisible(false);
+            if (rowItem.isDirectory()) {
+                popupMenu.getMenu().findItem(R.id.open_with).setVisible(false);
+                popupMenu.getMenu().findItem(R.id.share).setVisible(false);
 
-                    if (mainFrag.getMainActivity().mReturnIntent) {
-                        popupMenu.getMenu().findItem(R.id.return_select).setVisible(true);
-                    }
-                } else {
-                    popupMenu.getMenu().findItem(R.id.book).setVisible(false);
+                if (mainFrag.getMainActivity().mReturnIntent) {
+                    popupMenu.getMenu().findItem(R.id.return_select).setVisible(true);
                 }
+            } else {
+                popupMenu.getMenu().findItem(R.id.book).setVisible(false);
+            }
 
-                if (description.endsWith(".zip") || description.endsWith(".jar")
-                        || description.endsWith(".apk") || description.endsWith(".rar")
-                        || description.endsWith(".tar") || description.endsWith(".tar.gz"))
-                    popupMenu.getMenu().findItem(R.id.ex).setVisible(true);
+            if (description.endsWith(".zip") || description.endsWith(".jar")
+                    || description.endsWith(".apk") || description.endsWith(".rar")
+                    || description.endsWith(".tar") || description.endsWith(".tar.gz"))
+                popupMenu.getMenu().findItem(R.id.ex).setVisible(true);
 
-                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
-                    if (description.endsWith(CryptUtil.CRYPT_EXTENSION))
-                        popupMenu.getMenu().findItem(R.id.decrypt).setVisible(true);
-                    else popupMenu.getMenu().findItem(R.id.encrypt).setVisible(true);
-                }
-
-                popupMenu.show();
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
+                if (description.endsWith(CryptUtil.CRYPT_EXTENSION))
+                    popupMenu.getMenu().findItem(R.id.decrypt).setVisible(true);
+                else popupMenu.getMenu().findItem(R.id.encrypt).setVisible(true);
             }
+
+            popupMenu.show();
         });
     }
 
     private static class ListItem {
-        private LayoutElement elem;
+        public static final int CHECKED = 0, NOT_CHECKED = 1, UNCHECKABLE = 2;
+
+        private LayoutElementParcelable elem;
         private int specialType;
+        private boolean checked;
+        private boolean animate;
 
-        ListItem(LayoutElement elem) {
+        ListItem(LayoutElementParcelable elem) {
             this.elem = elem;
-            specialType = -1;
+            specialType = TYPE_ITEM;
         }
 
         ListItem(int specialType) {
             this.specialType = specialType;
         }
+
+        public void setChecked(boolean checked) {
+            if(specialType == TYPE_ITEM) this.checked = checked;
+        }
+
+        public int getChecked() {
+            if(checked) return CHECKED;
+            else if(specialType == TYPE_ITEM) return NOT_CHECKED;
+            else return UNCHECKABLE;
+        }
+
+        public void setAnimate(boolean animating) {
+            if(specialType == -1) this.animate = animating;
+        }
+
+        public boolean getAnimating() {
+            return animate;
+        }
     }
 
-}
\ No newline at end of file
+}
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/RecyclerArrayAdapter.java b/app/src/main/java/com/amaze/filemanager/adapters/RecyclerArrayAdapter.java
deleted file mode 100644
index 661d6c17b..000000000
--- a/app/src/main/java/com/amaze/filemanager/adapters/RecyclerArrayAdapter.java
+++ /dev/null
@@ -1,64 +0,0 @@
-package com.amaze.filemanager.adapters;
-
-import android.support.v7.widget.RecyclerView;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-
-/**
- * Created by Arpit on 13-04-2015.
- */
-public abstract class RecyclerArrayAdapter<M, VH extends RecyclerView.ViewHolder>
-        extends RecyclerView.Adapter<VH> {
-    private ArrayList<M> items = new ArrayList<>();
-
-    protected RecyclerArrayAdapter() {
-        setHasStableIds(true);
-    }
-
-    public void add(M object) {
-        items.add(object);
-        notifyDataSetChanged();
-    }
-
-    public void add(int index, M object) {
-        items.add(index, object);
-        notifyDataSetChanged();
-    }
-
-    protected void addAll(Collection<? extends M> collection) {
-        if (collection != null) {
-            items.addAll(collection);
-            notifyDataSetChanged();
-        }
-    }
-
-    public void addAll(M... items) {
-        addAll(Arrays.asList(items));
-    }
-
-    public void clear() {
-        items.clear();
-        notifyDataSetChanged();
-    }
-
-    public void remove(M object) {
-        items.remove(object);
-        notifyDataSetChanged();
-    }
-
-    public M getItem(int position) {
-        return items.get(position);
-    }
-
-    @Override
-    public long getItemId(int position) {
-        return position;
-    }
-
-    @Override
-    public int getItemCount() {
-        return items.size();
-    }
-}
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/holders/CompressedItemViewHolder.java b/app/src/main/java/com/amaze/filemanager/adapters/holders/CompressedItemViewHolder.java
new file mode 100644
index 000000000..9d1d421ed
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/adapters/holders/CompressedItemViewHolder.java
@@ -0,0 +1,39 @@
+package com.amaze.filemanager.adapters.holders;
+
+import android.support.v7.widget.RecyclerView;
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import com.amaze.filemanager.R;
+import com.amaze.filemanager.ui.views.RoundedImageView;
+
+/**
+ * @author Emmanuel Messulam<emmanuelbendavid@gmail.com>
+ *         on 17/9/2017, at 18:13.
+ */
+
+public class CompressedItemViewHolder extends RecyclerView.ViewHolder {
+    // each data item is just a string in this case
+    public RoundedImageView pictureIcon;
+    public ImageView genericIcon, apkIcon;
+    public TextView txtTitle;
+    public TextView txtDesc;
+    public TextView date;
+    public TextView perm;
+    public View rl;
+    public ImageView checkImageView;
+
+    public CompressedItemViewHolder(View view) {
+        super(view);
+        txtTitle = (TextView) view.findViewById(R.id.firstline);
+        pictureIcon = (RoundedImageView) view.findViewById(R.id.picture_icon);
+        genericIcon = (ImageView) view.findViewById(R.id.generic_icon);
+        rl = view.findViewById(R.id.second);
+        perm = (TextView) view.findViewById(R.id.permis);
+        date = (TextView) view.findViewById(R.id.date);
+        txtDesc = (TextView) view.findViewById(R.id.secondLine);
+        apkIcon = (ImageView) view.findViewById(R.id.apk_icon);
+        checkImageView = (ImageView) view.findViewById(R.id.check_icon);
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/holders/HiddenViewHolder.java b/app/src/main/java/com/amaze/filemanager/adapters/holders/HiddenViewHolder.java
new file mode 100644
index 000000000..20658fa3b
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/adapters/holders/HiddenViewHolder.java
@@ -0,0 +1,46 @@
+package com.amaze.filemanager.adapters.holders;
+
+import android.support.v7.widget.RecyclerView;
+import android.view.View;
+import android.widget.ImageButton;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+import com.amaze.filemanager.R;
+
+/**
+ * @author Emmanuel
+ *         on 20/11/2017, at 18:38.
+ */
+
+public class HiddenViewHolder extends RecyclerView.ViewHolder {
+    private final ImageButton image;
+    private final TextView txtTitle;
+    private final TextView txtDesc;
+    private final LinearLayout row;
+
+    public HiddenViewHolder(View view) {
+        super(view);
+
+        txtTitle = (TextView) view.findViewById(R.id.text1);
+        image = (ImageButton) view.findViewById(R.id.delete_button);
+        txtDesc = (TextView) view.findViewById(R.id.text2);
+        row = (LinearLayout) view.findViewById(R.id.bookmarkrow);
+    }
+
+    public ImageButton getImage() {
+        return image;
+    }
+
+    public TextView getTxtTitle() {
+        return txtTitle;
+    }
+
+    public TextView getTxtDesc() {
+        return txtDesc;
+    }
+
+    public LinearLayout getRow() {
+        return row;
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/amaze/filemanager/services/asynctasks/CountItemsOrAndSize.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/CountItemsOrAndSizeTask.java
similarity index 64%
rename from app/src/main/java/com/amaze/filemanager/services/asynctasks/CountItemsOrAndSize.java
rename to app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/CountItemsOrAndSizeTask.java
index cc497784e..d52dfed07 100644
--- a/app/src/main/java/com/amaze/filemanager/services/asynctasks/CountItemsOrAndSize.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/CountItemsOrAndSizeTask.java
@@ -1,4 +1,4 @@
-package com.amaze.filemanager.services.asynctasks;
+package com.amaze.filemanager.asynchronous.asynctasks;
 
 import android.content.Context;
 import android.os.AsyncTask;
@@ -7,23 +7,26 @@ import android.text.format.Formatter;
 import android.widget.TextView;
 
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.filesystem.BaseFile;
-import com.amaze.filemanager.utils.files.Futils;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
+import com.amaze.filemanager.utils.OnFileFound;
+import com.amaze.filemanager.utils.files.FileUtils;
 import com.amaze.filemanager.utils.OnProgressUpdate;
 
+import java.util.concurrent.atomic.AtomicInteger;
+
 /**
  * @author Emmanuel
  *         on 12/5/2017, at 19:40.
  */
 
-public class CountItemsOrAndSize extends AsyncTask<Void, Pair<Integer, Long>, String> {
+public class CountItemsOrAndSizeTask extends AsyncTask<Void, Pair<Integer, Long>, String> {
 
     private Context context;
     private TextView itemsText;
-    private BaseFile file;
+    private HybridFileParcelable file;
     private boolean isStorage;
 
-    public CountItemsOrAndSize(Context c, TextView itemsText, BaseFile f, boolean storage) {
+    public CountItemsOrAndSizeTask(Context c, TextView itemsText, HybridFileParcelable f, boolean storage) {
         this.context = c;
         this.itemsText = itemsText;
         file = f;
@@ -36,21 +39,28 @@ public class CountItemsOrAndSize extends AsyncTask<Void, Pair<Integer, Long>, St
         long fileLength = file.length(context);
 
         if (file.isDirectory(context)) {
-            final int x = file.listFiles(context, false).size();
+            final AtomicInteger x = new AtomicInteger(0);
+            file.forEachChildrenFile(context, false, new OnFileFound() {
+                @Override
+                public void onFileFound(HybridFileParcelable file) {
+                    x.incrementAndGet();
+                }
+            });
+            final int folderLength = x.intValue();
             long folderSize;
 
             if(isStorage) {
                 folderSize = file.getUsableSpace();
             } else {
-                folderSize = Futils.folderSize(file, new OnProgressUpdate<Long>() {
+                folderSize = FileUtils.folderSize(file, new OnProgressUpdate<Long>() {
                     @Override
                     public void onUpdate(Long data) {
-                        publishProgress(new Pair<>(x, data));
+                        publishProgress(new Pair<>(folderLength, data));
                     }
                 });
             }
 
-            items = getText(x, folderSize, false);
+            items = getText(folderLength, folderSize, false);
         } else {
             items = Formatter.formatFileSize(context, fileLength) + (" (" + fileLength + " "
                     + context.getResources().getQuantityString(R.plurals.bytes, (int) fileLength) //truncation is insignificant
diff --git a/app/src/main/java/com/amaze/filemanager/services/asynctasks/DbViewerTask.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/DbViewerTask.java
similarity index 97%
rename from app/src/main/java/com/amaze/filemanager/services/asynctasks/DbViewerTask.java
rename to app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/DbViewerTask.java
index 36952c23e..775c55ac5 100644
--- a/app/src/main/java/com/amaze/filemanager/services/asynctasks/DbViewerTask.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/DbViewerTask.java
@@ -1,4 +1,4 @@
-package com.amaze.filemanager.services.asynctasks;
+package com.amaze.filemanager.asynchronous.asynctasks;
 
 import android.database.Cursor;
 import android.os.AsyncTask;
@@ -35,7 +35,7 @@ public class DbViewerTask extends AsyncTask<Void, Integer, Void> {
     protected void onPreExecute() {
         super.onPreExecute();
 
-        if (dbViewerFragment.dbViewer.getAppTheme().equals(AppTheme.DARK)) {
+        if (dbViewerFragment.databaseViewerActivity.getAppTheme().equals(AppTheme.DARK)) {
 
             htmlInit = "<html><body>" +
                     "<table border='1' style='width:100%;color:#ffffff'>";
diff --git a/app/src/main/java/com/amaze/filemanager/services/DeleteTask.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/DeleteTask.java
similarity index 76%
rename from app/src/main/java/com/amaze/filemanager/services/DeleteTask.java
rename to app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/DeleteTask.java
index f51aa5ed5..c1b06a247 100644
--- a/app/src/main/java/com/amaze/filemanager/services/DeleteTask.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/DeleteTask.java
@@ -17,7 +17,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.services;
+package com.amaze.filemanager.asynchronous.asynctasks;
 
 import android.content.ContentResolver;
 import android.content.Context;
@@ -30,27 +30,27 @@ import android.support.v4.provider.DocumentFile;
 import android.widget.Toast;
 
 import com.amaze.filemanager.R;
+import com.amaze.filemanager.activities.MainActivity;
 import com.amaze.filemanager.database.CryptHandler;
-import com.amaze.filemanager.exceptions.RootNotPermittedException;
-import com.amaze.filemanager.filesystem.BaseFile;
-import com.amaze.filemanager.filesystem.RootHelper;
-import com.amaze.filemanager.fragments.ZipViewer;
+import com.amaze.filemanager.exceptions.ShellNotRunningException;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
+import com.amaze.filemanager.fragments.CompressedExplorerFragment;
 import com.amaze.filemanager.utils.DataUtils;
 import com.amaze.filemanager.utils.OTGUtil;
 import com.amaze.filemanager.utils.cloud.CloudUtil;
 import com.amaze.filemanager.utils.files.CryptUtil;
-import com.amaze.filemanager.utils.files.Futils;
+import com.amaze.filemanager.utils.files.FileUtils;
 import com.amaze.filemanager.utils.OpenMode;
 import com.cloudrail.si.interfaces.CloudStorage;
 
 import java.util.ArrayList;
 
-public class DeleteTask extends AsyncTask<ArrayList<BaseFile>, String, Boolean> {
+public class DeleteTask extends AsyncTask<ArrayList<HybridFileParcelable>, String, Boolean> {
 
-    private ArrayList<BaseFile> files;
+    private ArrayList<HybridFileParcelable> files;
     private Context cd;
     private boolean rootMode;
-    private ZipViewer zipViewer;
+    private CompressedExplorerFragment compressedExplorerFragment;
     private DataUtils dataUtils = DataUtils.getInstance();
 
     public DeleteTask(ContentResolver c, Context cd) {
@@ -58,10 +58,10 @@ public class DeleteTask extends AsyncTask<ArrayList<BaseFile>, String, Boolean>
         rootMode = PreferenceManager.getDefaultSharedPreferences(cd).getBoolean("rootmode", false);
     }
 
-    public DeleteTask(ContentResolver c, Context cd, ZipViewer zipViewer) {
+    public DeleteTask(ContentResolver c, Context cd, CompressedExplorerFragment compressedExplorerFragment) {
         this.cd = cd;
         rootMode = PreferenceManager.getDefaultSharedPreferences(cd).getBoolean("rootmode", false);
-        this.zipViewer = zipViewer;
+        this.compressedExplorerFragment = compressedExplorerFragment;
     }
 
     @Override
@@ -70,20 +70,20 @@ public class DeleteTask extends AsyncTask<ArrayList<BaseFile>, String, Boolean>
         Toast.makeText(cd, values[0], Toast.LENGTH_SHORT).show();
     }
 
-    protected Boolean doInBackground(ArrayList<BaseFile>... p1) {
+    protected Boolean doInBackground(ArrayList<HybridFileParcelable>... p1) {
         files = p1[0];
         boolean b = true;
         if(files.size()==0)return true;
 
         if (files.get(0).isOtgFile()) {
-            for (BaseFile a : files) {
+            for (HybridFileParcelable a : files) {
 
                 DocumentFile documentFile = OTGUtil.getDocumentFile(a.getPath(), cd, false);
                  b = documentFile.delete();
             }
         } else if (files.get(0).isDropBoxFile()) {
             CloudStorage cloudStorageDropbox = dataUtils.getAccount(OpenMode.DROPBOX);
-            for (BaseFile baseFile : files) {
+            for (HybridFileParcelable baseFile : files) {
                 try {
                     cloudStorageDropbox.delete(CloudUtil.stripPath(OpenMode.DROPBOX, baseFile.getPath()));
                 } catch (Exception e) {
@@ -94,7 +94,7 @@ public class DeleteTask extends AsyncTask<ArrayList<BaseFile>, String, Boolean>
             }
         } else if (files.get(0).isBoxFile()) {
             CloudStorage cloudStorageBox = dataUtils.getAccount(OpenMode.BOX);
-            for (BaseFile baseFile : files) {
+            for (HybridFileParcelable baseFile : files) {
                 try {
                     cloudStorageBox.delete(CloudUtil.stripPath(OpenMode.BOX, baseFile.getPath()));
                 } catch (Exception e) {
@@ -105,7 +105,7 @@ public class DeleteTask extends AsyncTask<ArrayList<BaseFile>, String, Boolean>
             }
         } else if (files.get(0).isGoogleDriveFile()) {
             CloudStorage cloudStorageGdrive = dataUtils.getAccount(OpenMode.GDRIVE);
-            for (BaseFile baseFile : files) {
+            for (HybridFileParcelable baseFile : files) {
                 try {
                     cloudStorageGdrive.delete(CloudUtil.stripPath(OpenMode.GDRIVE, baseFile.getPath()));
                 } catch (Exception e) {
@@ -116,7 +116,7 @@ public class DeleteTask extends AsyncTask<ArrayList<BaseFile>, String, Boolean>
             }
         } else if (files.get(0).isOneDriveFile()) {
             CloudStorage cloudStorageOnedrive = dataUtils.getAccount(OpenMode.ONEDRIVE);
-            for (BaseFile baseFile : files) {
+            for (HybridFileParcelable baseFile : files) {
                 try {
                     cloudStorageOnedrive.delete(CloudUtil.stripPath(OpenMode.ONEDRIVE, baseFile.getPath()));
                 } catch (Exception e) {
@@ -127,10 +127,10 @@ public class DeleteTask extends AsyncTask<ArrayList<BaseFile>, String, Boolean>
             }
         } else {
 
-            for(BaseFile a : files)
+            for(HybridFileParcelable a : files)
                 try {
                     (a).delete(cd, rootMode);
-                } catch (RootNotPermittedException e) {
+                } catch (ShellNotRunningException e) {
                     e.printStackTrace();
                     b = false;
                 }
@@ -139,18 +139,18 @@ public class DeleteTask extends AsyncTask<ArrayList<BaseFile>, String, Boolean>
         // delete file from media database
         if(!files.get(0).isSmb()) {
             try {
-                for (BaseFile f : files) {
+                for (HybridFileParcelable f : files) {
                     delete(cd,f.getPath());
                 }
             } catch (Exception e) {
-                for (BaseFile f : files) {
-                    Futils.scanFile(f.getPath(), cd);
+                for (HybridFileParcelable f : files) {
+                    FileUtils.scanFile(f.getPath(), cd);
                 }
             }
         }
 
         // delete file entry from encrypted database
-        for (BaseFile file : files) {
+        for (HybridFileParcelable file : files) {
             if (file.getName().endsWith(CryptUtil.CRYPT_EXTENSION)) {
                 CryptHandler handler = new CryptHandler(cd);
                 handler.clear(file.getPath());
@@ -162,17 +162,20 @@ public class DeleteTask extends AsyncTask<ArrayList<BaseFile>, String, Boolean>
 
     @Override
     public void onPostExecute(Boolean b) {
-        Intent intent = new Intent("loadlist");
+
+        Intent intent = new Intent(MainActivity.KEY_INTENT_LOAD_LIST);
+        String path = files.get(0).getParent(cd);
+        intent.putExtra(MainActivity.KEY_INTENT_LOAD_LIST_FILE, path);
         cd.sendBroadcast(intent);
 
         if (!b) {
             Toast.makeText(cd, cd.getResources().getString(R.string.error), Toast.LENGTH_SHORT).show();
-        } else if (zipViewer==null) {
+        } else if (compressedExplorerFragment ==null) {
             Toast.makeText(cd, cd.getResources().getString(R.string.done), Toast.LENGTH_SHORT).show();
         }
 
-        if (zipViewer!=null) {
-            zipViewer.files.clear();
+        if (compressedExplorerFragment !=null) {
+            compressedExplorerFragment.files.clear();
         }
     }
 
@@ -185,7 +188,6 @@ public class DeleteTask extends AsyncTask<ArrayList<BaseFile>, String, Boolean>
         final Uri filesUri = MediaStore.Files.getContentUri("external");
         // Delete the entry from the media database. This will actually delete media files.
         contentResolver.delete(filesUri, where, selectionArgs);
-
     }
 }
 
diff --git a/app/src/main/java/com/amaze/filemanager/services/asynctasks/GenerateHashes.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/GenerateHashesTask.java
similarity index 79%
rename from app/src/main/java/com/amaze/filemanager/services/asynctasks/GenerateHashes.java
rename to app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/GenerateHashesTask.java
index dc4acd4f8..fedd616c7 100644
--- a/app/src/main/java/com/amaze/filemanager/services/asynctasks/GenerateHashes.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/GenerateHashesTask.java
@@ -1,4 +1,4 @@
-package com.amaze.filemanager.services.asynctasks;
+package com.amaze.filemanager.asynchronous.asynctasks;
 
 import android.content.Context;
 import android.os.AsyncTask;
@@ -9,14 +9,12 @@ import android.widget.TextView;
 import android.widget.Toast;
 
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.filesystem.BaseFile;
 import com.amaze.filemanager.services.ssh.SshClientSessionTemplate;
-import com.amaze.filemanager.services.ssh.SshClientTemplate;
 import com.amaze.filemanager.services.ssh.SshClientUtils;
-import com.amaze.filemanager.utils.files.Futils;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
+import com.amaze.filemanager.utils.files.FileUtils;
 import com.amaze.filemanager.utils.files.GenericCopyUtil;
 
-import net.schmizz.sshj.SSHClient;
 import net.schmizz.sshj.common.IOUtils;
 import net.schmizz.sshj.connection.channel.direct.Session;
 
@@ -30,15 +28,15 @@ import java.security.NoSuchAlgorithmException;
  *
  * Created by Vishal on 05-02-2015 edited by Emmanuel Messulam<emmanuelbendavid@gmail.com>
  */
-public class GenerateHashes extends AsyncTask<Void, String, String[]> {
+public class GenerateHashesTask extends AsyncTask<Void, String, String[]> {
 
-    private BaseFile file;
+    private HybridFileParcelable file;
     private Context context;
     private TextView md5HashText;
     private TextView sha256Text;
     private LinearLayout mMD5LinearLayout, mSHA256LinearLayout;
 
-    public GenerateHashes(BaseFile f, final Context c, final View view) {
+    public GenerateHashesTask(HybridFileParcelable f, final Context c, final View view) {
         this.context = c;
         this.file = f;
 
@@ -103,25 +101,17 @@ public class GenerateHashes extends AsyncTask<Void, String, String[]> {
             md5HashText.setText(hashes[0]);
             sha256Text.setText(hashes[1]);
 
-            mMD5LinearLayout.setOnLongClickListener(new View.OnLongClickListener() {
-                @Override
-                public boolean onLongClick(View v) {
-
-                    Futils.copyToClipboard(context, hashes[0]);
-                    Toast.makeText(context, context.getResources().getString(R.string.md5).toUpperCase() + " " +
-                            context.getResources().getString(R.string.properties_copied_clipboard), Toast.LENGTH_SHORT).show();
-                    return false;
-                }
+            mMD5LinearLayout.setOnLongClickListener(v -> {
+                FileUtils.copyToClipboard(context, hashes[0]);
+                Toast.makeText(context, context.getResources().getString(R.string.md5).toUpperCase() + " " +
+                        context.getResources().getString(R.string.properties_copied_clipboard), Toast.LENGTH_SHORT).show();
+                return false;
             });
-            mSHA256LinearLayout.setOnLongClickListener(new View.OnLongClickListener() {
-                @Override
-                public boolean onLongClick(View v) {
-
-                    Futils.copyToClipboard(context, hashes[1]);
-                    Toast.makeText(context, context.getResources().getString(R.string.hash_sha256) + " " +
-                            context.getResources().getString(R.string.properties_copied_clipboard), Toast.LENGTH_SHORT).show();
-                    return false;
-                }
+            mSHA256LinearLayout.setOnLongClickListener(v -> {
+                FileUtils.copyToClipboard(context, hashes[1]);
+                Toast.makeText(context, context.getResources().getString(R.string.hash_sha256) + " " +
+                        context.getResources().getString(R.string.properties_copied_clipboard), Toast.LENGTH_SHORT).show();
+                return false;
             });
         } else {
             mMD5LinearLayout.setVisibility(View.GONE);
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/LoadFilesListTask.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/LoadFilesListTask.java
new file mode 100644
index 000000000..7ec1dfcdf
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/LoadFilesListTask.java
@@ -0,0 +1,502 @@
+/*
+ * Copyright (C) 2014 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>
+ *     Emmanuel Messulam <emmanuelbendavid@gmail.com>
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.asynchronous.asynctasks;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.os.AsyncTask;
+import android.provider.MediaStore;
+import android.support.v4.util.Pair;
+import android.text.format.Formatter;
+
+import com.amaze.filemanager.R;
+import com.amaze.filemanager.activities.superclasses.ThemedActivity;
+import com.amaze.filemanager.database.UtilsHandler;
+import com.amaze.filemanager.exceptions.CloudPluginException;
+import com.amaze.filemanager.filesystem.HybridFile;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
+import com.amaze.filemanager.filesystem.RootHelper;
+import com.amaze.filemanager.fragments.CloudSheetFragment;
+import com.amaze.filemanager.fragments.MainFragment;
+import com.amaze.filemanager.ui.LayoutElementParcelable;
+import com.amaze.filemanager.ui.icons.Icons;
+import com.amaze.filemanager.utils.DataUtils;
+import com.amaze.filemanager.utils.OTGUtil;
+import com.amaze.filemanager.utils.OnAsyncTaskFinished;
+import com.amaze.filemanager.utils.OnFileFound;
+import com.amaze.filemanager.utils.OpenMode;
+import com.amaze.filemanager.utils.application.AppConfig;
+import com.amaze.filemanager.utils.cloud.CloudUtil;
+import com.amaze.filemanager.utils.files.CryptUtil;
+import com.amaze.filemanager.utils.files.FileListSorter;
+import com.cloudrail.si.interfaces.CloudStorage;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Calendar;
+import java.util.Collections;
+import java.util.Date;
+import java.util.LinkedList;
+
+import jcifs.smb.SmbAuthException;
+import jcifs.smb.SmbException;
+import jcifs.smb.SmbFile;
+
+public class LoadFilesListTask extends AsyncTask<Void, Void, Pair<OpenMode, ArrayList<LayoutElementParcelable>>> {
+
+    private String path;
+    private MainFragment ma;
+    private Context c;
+    private OpenMode openmode;
+    private Drawable lockBitmapDrawable = null;
+    private DataUtils dataUtils = DataUtils.getInstance();
+    private OnAsyncTaskFinished<Pair<OpenMode, ArrayList<LayoutElementParcelable>>> listener;
+
+    public LoadFilesListTask(Context c, String path, MainFragment ma, OpenMode openmode,
+                             OnAsyncTaskFinished<Pair<OpenMode, ArrayList<LayoutElementParcelable>>> l) {
+        this.path = path;
+        this.ma = ma;
+        this.openmode = openmode;
+        this.c = c;
+        this.listener = l;
+    }
+
+    @Override
+    protected Pair<OpenMode, ArrayList<LayoutElementParcelable>> doInBackground(Void... p) {
+        HybridFile hFile = null;
+
+        if (openmode == OpenMode.UNKNOWN) {
+            hFile = new HybridFile(OpenMode.UNKNOWN, path);
+            hFile.generateMode(ma.getActivity());
+            openmode = hFile.getMode();
+
+            if (hFile.isSmb()) {
+                ma.smbPath = path;
+            } else if (android.util.Patterns.EMAIL_ADDRESS.matcher(path).matches()) {
+                openmode = OpenMode.ROOT;
+            }
+        }
+
+        if(isCancelled()) return null;
+
+        ma.folder_count = 0;
+        ma.file_count = 0;
+        final ArrayList<LayoutElementParcelable> list;
+
+        switch (openmode) {
+            case SMB:
+                if (hFile == null) {
+                    hFile = new HybridFile(OpenMode.SMB, path);
+                }
+
+                try {
+                    SmbFile[] smbFile = hFile.getSmbFile(5000).listFiles();
+                    list = ma.addToSmb(smbFile, path);
+                    openmode = OpenMode.SMB;
+                } catch (SmbAuthException e) {
+                    if (!e.getMessage().toLowerCase().contains("denied")) {
+                        ma.reauthenticateSmb();
+                    }
+                    return null;
+                } catch (SmbException | NullPointerException e) {
+                    e.printStackTrace();
+                    return null;
+                }
+                break;
+            case SFTP:
+                HybridFile sftpHFile = new HybridFile(OpenMode.SFTP, path);
+
+                list = new ArrayList<LayoutElementParcelable>();
+
+                sftpHFile.forEachChildrenFile(c, false, new OnFileFound() {
+
+                    String size = "";
+
+                    @Override
+                    public void onFileFound(HybridFileParcelable baseFile) {
+
+                        if (baseFile.isDirectory()) {
+                            size = "";
+
+                            Bitmap lockBitmap = BitmapFactory.decodeResource(ma.getResources(), R.drawable.ic_folder_lock_white_36dp);
+                            BitmapDrawable lockBitmapDrawable = new BitmapDrawable(ma.getResources(), lockBitmap);
+
+                            LayoutElementParcelable layoutElement = new LayoutElementParcelable(baseFile.getName().endsWith(CryptUtil.CRYPT_EXTENSION) ? lockBitmapDrawable
+                                                    : ma.folder,
+                                            baseFile.getPath(), baseFile.getPermission(), baseFile.getLink(), size, 0, true, false,
+                                            baseFile.getDate() + "");
+                            layoutElement.setMode(baseFile.getMode());
+                            list.add(layoutElement);
+                            ma.folder_count++;
+                        } else {
+                            long longSize = 0;
+                            try {
+                                if (baseFile.getSize() != -1) {
+                                    longSize = baseFile.getSize();
+                                    size = Formatter.formatFileSize(c, longSize);
+                                } else {
+                                    size = "";
+                                    longSize = 0;
+                                }
+                            } catch (NumberFormatException e) {
+                                //e.printStackTrace();
+                            }
+                            try {
+                                LayoutElementParcelable layoutElement = new LayoutElementParcelable(Icons.loadMimeIcon(
+                                        baseFile.getPath(), !ma.IS_LIST, ma.getResources()), baseFile.getPath(), baseFile.getPermission(),
+                                        baseFile.getLink(), size, longSize, false, false, baseFile.getDate() + "");
+                                layoutElement.setMode(baseFile.getMode());
+                                list.add(layoutElement);
+                                ma.file_count++;
+                            } catch (Exception e) {
+                                e.printStackTrace();
+                            }
+                        }
+                    }
+                });
+                break;
+            case CUSTOM:
+                switch (Integer.parseInt(path)) {
+                    case 0:
+                        list = listImages();
+                        break;
+                    case 1:
+                        list = listVideos();
+                        break;
+                    case 2:
+                        list = listaudio();
+                        break;
+                    case 3:
+                        list = listDocs();
+                        break;
+                    case 4:
+                        list = listApks();
+                        break;
+                    case 5:
+                        list = listRecent();
+                        break;
+                    case 6:
+                        list = listRecentFiles();
+                        break;
+                    default:
+                        throw new IllegalStateException();
+                }
+
+                break;
+            case OTG:
+                list = new ArrayList<>();
+                listOtg(path, new OnFileFound() {
+                    @Override
+                    public void onFileFound(HybridFileParcelable file) {
+                        LayoutElementParcelable elem = createListParcelables(file);
+                        if(elem != null) list.add(elem);
+                    }
+                });
+                openmode = OpenMode.OTG;
+                break;
+            case DROPBOX:
+            case BOX:
+            case GDRIVE:
+            case ONEDRIVE:
+                CloudStorage cloudStorage = dataUtils.getAccount(openmode);
+                list = new ArrayList<>();
+
+                try {
+                    listCloud(path, cloudStorage, openmode, new OnFileFound() {
+                        @Override
+                        public void onFileFound(HybridFileParcelable file) {
+                            LayoutElementParcelable elem = createListParcelables(file);
+                            if(elem != null) list.add(elem);
+                        }
+                    });
+                } catch (CloudPluginException e) {
+                    e.printStackTrace();
+                    AppConfig.toast(c, c.getResources().getString(R.string.failed_no_connection));
+                    return new Pair<>(openmode, list);
+                }
+                break;
+            default:
+                // we're neither in OTG not in SMB, load the list based on root/general filesystem
+                list = new ArrayList<>();
+                RootHelper.getFiles(path, ThemedActivity.rootMode, ma.SHOW_HIDDEN,
+                        new RootHelper.GetModeCallBack() {
+                            @Override
+                            public void getMode(OpenMode mode) {
+                                openmode = mode;
+                            }
+                        }, new OnFileFound() {
+                            @Override
+                            public void onFileFound(HybridFileParcelable file) {
+                                LayoutElementParcelable elem = createListParcelables(file);
+                                if(elem != null) list.add(elem);
+                            }
+                        });
+                break;
+        }
+
+        if (list != null && !(openmode == OpenMode.CUSTOM && ((path).equals("5") || (path).equals("6")))) {
+            Collections.sort(list, new FileListSorter(ma.dsort, ma.sortby, ma.asc));
+        }
+
+        return new Pair<>(openmode, list);
+    }
+
+    @Override
+    protected void onPostExecute(Pair<OpenMode, ArrayList<LayoutElementParcelable>> list) {
+        super.onPostExecute(list);
+        listener.onAsyncTaskFinished(list);
+    }
+
+    private LayoutElementParcelable createListParcelables(HybridFileParcelable baseFile) {
+        if (!dataUtils.isFileHidden(baseFile.getPath())) {
+            String size = "";
+            Drawable drawable;
+            long longSize= 0;
+
+            if (baseFile.isDirectory()) {
+                if(lockBitmapDrawable == null) {
+                    lockBitmapDrawable = ma.getResources().getDrawable(R.drawable.ic_folder_lock_white_36dp);
+                }
+
+                drawable = baseFile.getName().endsWith(CryptUtil.CRYPT_EXTENSION)? lockBitmapDrawable:ma.folder;
+                ma.folder_count++;
+            } else {
+                if (baseFile.getSize() != -1) {
+                    try {
+                        longSize = baseFile.getSize();
+                        size = Formatter.formatFileSize(c, longSize);
+                    } catch (NumberFormatException e) {
+                        e.printStackTrace();
+                    }
+                }
+                drawable = Icons.loadMimeIcon(baseFile.getPath(), !ma.IS_LIST, ma.getResources());
+                ma.file_count++;
+            }
+
+            LayoutElementParcelable layoutElement = new LayoutElementParcelable(drawable,
+                    baseFile.getPath(), baseFile.getPermission(), baseFile.getLink(), size,
+                    longSize, baseFile.isDirectory(), false, baseFile.getDate() + "");
+            layoutElement.setMode(baseFile.getMode());
+            return layoutElement;
+        }
+
+        return null;
+    }
+
+    private ArrayList<LayoutElementParcelable> listImages() {
+        ArrayList<LayoutElementParcelable> songs = new ArrayList<>();
+        final String[] projection = {MediaStore.Images.Media.DATA};
+        final Cursor cursor = c.getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
+                projection, null, null, null);
+        if (cursor.getCount() > 0 && cursor.moveToFirst()) {
+            do {
+                String path = cursor.getString(cursor.getColumnIndex
+                        (MediaStore.Files.FileColumns.DATA));
+                HybridFileParcelable strings = RootHelper.generateBaseFile(new File(path), ma.SHOW_HIDDEN);
+                if (strings != null) {
+                    LayoutElementParcelable parcelable = createListParcelables(strings);
+                    if(parcelable != null) songs.add(parcelable);
+                }
+            } while (cursor.moveToNext());
+        }
+        cursor.close();
+        return songs;
+    }
+
+    private ArrayList<LayoutElementParcelable> listVideos() {
+        ArrayList<LayoutElementParcelable> songs = new ArrayList<>();
+        final String[] projection = {MediaStore.Images.Media.DATA};
+        final Cursor cursor = c.getContentResolver().query(MediaStore.Video.Media.EXTERNAL_CONTENT_URI,
+                projection, null, null, null);
+        if (cursor.getCount() > 0 && cursor.moveToFirst()) {
+            do {
+                String path = cursor.getString(cursor.getColumnIndex
+                        (MediaStore.Files.FileColumns.DATA));
+                HybridFileParcelable strings = RootHelper.generateBaseFile(new File(path), ma.SHOW_HIDDEN);
+                if (strings != null) {
+                    LayoutElementParcelable parcelable = createListParcelables(strings);
+                    if(parcelable != null) songs.add(parcelable);
+                }
+            } while (cursor.moveToNext());
+        }
+        cursor.close();
+        return songs;
+    }
+
+    private ArrayList<LayoutElementParcelable> listaudio() {
+        String selection = MediaStore.Audio.Media.IS_MUSIC + " != 0";
+        String[] projection = {
+                MediaStore.Audio.Media.DATA
+        };
+
+        Cursor cursor = c.getContentResolver().query(
+                MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
+                projection,
+                selection,
+                null,
+                null);
+
+        ArrayList<LayoutElementParcelable> songs = new ArrayList<>();
+        if (cursor.getCount() > 0 && cursor.moveToFirst()) {
+            do {
+                String path = cursor.getString(cursor.getColumnIndex
+                        (MediaStore.Files.FileColumns.DATA));
+                HybridFileParcelable strings = RootHelper.generateBaseFile(new File(path), ma.SHOW_HIDDEN);
+                if (strings != null) {
+                    LayoutElementParcelable parcelable = createListParcelables(strings);
+                    if(parcelable != null) songs.add(parcelable);
+                }
+            } while (cursor.moveToNext());
+        }
+        cursor.close();
+        return songs;
+    }
+
+    private ArrayList<LayoutElementParcelable> listDocs() {
+        ArrayList<LayoutElementParcelable> songs = new ArrayList<>();
+        final String[] projection = {MediaStore.Files.FileColumns.DATA};
+        Cursor cursor = c.getContentResolver().query(MediaStore.Files.getContentUri("external"),
+                projection, null, null, null);
+        String[] types = new String[]{".pdf", ".xml", ".html", ".asm", ".text/x-asm", ".def", ".in", ".rc",
+                ".list", ".log", ".pl", ".prop", ".properties", ".rc",
+                ".doc", ".docx", ".msg", ".odt", ".pages", ".rtf", ".txt", ".wpd", ".wps"};
+        if (cursor.getCount() > 0 && cursor.moveToFirst()) {
+            do {
+                String path = cursor.getString(cursor.getColumnIndex
+                        (MediaStore.Files.FileColumns.DATA));
+                if (path != null && Arrays.asList(types).contains(path)) {
+                    HybridFileParcelable strings = RootHelper.generateBaseFile(new File(path), ma.SHOW_HIDDEN);
+                    if (strings != null) {
+                        LayoutElementParcelable parcelable = createListParcelables(strings);
+                        if(parcelable != null) songs.add(parcelable);
+                    }
+                }
+            } while (cursor.moveToNext());
+        }
+        cursor.close();
+        Collections.sort(songs, (lhs, rhs) -> -1 * Long.valueOf(lhs.getDate1()).compareTo(rhs.getDate1()));
+        if (songs.size() > 20)
+            for (int i = songs.size() - 1; i > 20; i--) {
+                songs.remove(i);
+            }
+        return songs;
+    }
+
+    private ArrayList<LayoutElementParcelable> listApks() {
+        ArrayList<LayoutElementParcelable> songs = new ArrayList<>();
+        final String[] projection = {MediaStore.Files.FileColumns.DATA};
+
+        Cursor cursor = c.getContentResolver()
+                .query(MediaStore.Files.getContentUri("external"), projection, null, null, null);
+        if (cursor.getCount() > 0 && cursor.moveToFirst()) {
+            do {
+                String path = cursor.getString(cursor.getColumnIndex
+                        (MediaStore.Files.FileColumns.DATA));
+                if (path != null && path.endsWith(".apk")) {
+                    HybridFileParcelable strings = RootHelper.generateBaseFile(new File(path), ma.SHOW_HIDDEN);
+                    if (strings != null) {
+                        LayoutElementParcelable parcelable = createListParcelables(strings);
+                        if(parcelable != null) songs.add(parcelable);
+                    }
+                }
+            } while (cursor.moveToNext());
+        }
+        cursor.close();
+        return songs;
+    }
+
+    private ArrayList<LayoutElementParcelable> listRecent() {
+        UtilsHandler utilsHandler = new UtilsHandler(c);
+        final LinkedList<String> paths = utilsHandler.getHistoryLinkedList();
+        ArrayList<LayoutElementParcelable> songs = new ArrayList<>();
+        for (String f : paths) {
+            if (!f.equals("/")) {
+                HybridFileParcelable hybridFileParcelable = RootHelper.generateBaseFile(new File(f), ma.SHOW_HIDDEN);
+                if (hybridFileParcelable != null) {
+                    hybridFileParcelable.generateMode(ma.getActivity());
+                    if (!hybridFileParcelable.isSmb() && !hybridFileParcelable.isDirectory() && hybridFileParcelable.exists()) {
+                        LayoutElementParcelable parcelable = createListParcelables(hybridFileParcelable);
+                        if (parcelable != null) songs.add(parcelable);
+                    }
+                }
+            }
+        }
+        return songs;
+    }
+
+    private ArrayList<LayoutElementParcelable> listRecentFiles() {
+        ArrayList<LayoutElementParcelable> songs = new ArrayList<>();
+        final String[] projection = {MediaStore.Files.FileColumns.DATA, MediaStore.Files.FileColumns.DATE_MODIFIED};
+        Calendar c = Calendar.getInstance();
+        c.set(Calendar.DAY_OF_YEAR, c.get(Calendar.DAY_OF_YEAR) - 2);
+        Date d = c.getTime();
+        Cursor cursor = this.c.getContentResolver().query(MediaStore.Files
+                        .getContentUri("external"), projection,
+                null,
+                null, null);
+        if (cursor == null) return songs;
+        if (cursor.getCount() > 0 && cursor.moveToFirst()) {
+            do {
+                String path = cursor.getString(cursor.getColumnIndex
+                        (MediaStore.Files.FileColumns.DATA));
+                File f = new File(path);
+                if (d.compareTo(new Date(f.lastModified())) != 1 && !f.isDirectory()) {
+                    HybridFileParcelable strings = RootHelper.generateBaseFile(new File(path), ma.SHOW_HIDDEN);
+                    if (strings != null) {
+                        LayoutElementParcelable parcelable = createListParcelables(strings);
+                        if(parcelable != null) songs.add(parcelable);
+                    }
+                }
+            } while (cursor.moveToNext());
+        }
+        cursor.close();
+        Collections.sort(songs, (lhs, rhs) -> -1 * Long.valueOf(lhs.getDate1()).compareTo(rhs.getDate1()));
+        if (songs.size() > 20)
+            for (int i = songs.size() - 1; i > 20; i--) {
+                songs.remove(i);
+            }
+        return songs;
+    }
+
+    /**
+     * Lists files from an OTG device
+     *
+     * @param path the path to the directory tree, starts with prefix {@link com.amaze.filemanager.utils.OTGUtil#PREFIX_OTG}
+     *             Independent of URI (or mount point) for the OTG
+     */
+    private void listOtg(String path, OnFileFound fileFound) {
+        OTGUtil.getDocumentFiles(path, c, fileFound);
+    }
+
+    private void listCloud(String path, CloudStorage cloudStorage, OpenMode openMode,
+                           OnFileFound fileFoundCallback) throws CloudPluginException {
+        if (!CloudSheetFragment.isCloudProviderAvailable(c)) {
+            throw new CloudPluginException();
+        }
+
+        CloudUtil.getCloudFiles(path, cloudStorage, openMode, fileFoundCallback);
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/services/asynctasks/LoadFolderSpaceData.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/LoadFolderSpaceDataTask.java
similarity index 85%
rename from app/src/main/java/com/amaze/filemanager/services/asynctasks/LoadFolderSpaceData.java
rename to app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/LoadFolderSpaceDataTask.java
index f1111bdcd..b68baee7d 100644
--- a/app/src/main/java/com/amaze/filemanager/services/asynctasks/LoadFolderSpaceData.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/LoadFolderSpaceDataTask.java
@@ -1,4 +1,4 @@
-package com.amaze.filemanager.services.asynctasks;
+package com.amaze.filemanager.asynchronous.asynctasks;
 
 import android.content.Context;
 import android.graphics.Color;
@@ -10,10 +10,9 @@ import android.view.View;
 
 import com.afollestad.materialdialogs.Theme;
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.filesystem.BaseFile;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.ui.dialogs.GeneralDialogCreation;
-import com.amaze.filemanager.utils.files.Futils;
-import com.amaze.filemanager.utils.OnProgressUpdate;
+import com.amaze.filemanager.utils.files.FileUtils;
 import com.amaze.filemanager.utils.theme.AppTheme;
 import com.github.mikephil.charting.charts.PieChart;
 import com.github.mikephil.charting.data.PieData;
@@ -26,13 +25,13 @@ import java.util.List;
 import static com.amaze.filemanager.utils.Utils.getColor;
 
 /**
- * Loads data for chart in Futils.showPropertiesDialog()
+ * Loads data for chart in FileUtils.showPropertiesDialog()
  *
  * @author Emmanuel Messulam<emmanuelbendavid@gmail.com>
  *         on 12/5/2017, at 00:07.
  */
 
-public class LoadFolderSpaceData extends AsyncTask<Void, Long, Pair<String, List<PieEntry>>> {
+public class LoadFolderSpaceDataTask extends AsyncTask<Void, Long, Pair<String, List<PieEntry>>> {
 
     private static int[] COLORS;
     private static String[] LEGENDS;
@@ -40,9 +39,9 @@ public class LoadFolderSpaceData extends AsyncTask<Void, Long, Pair<String, List
     private Context context;
     private AppTheme appTheme;
     private PieChart chart;
-    private BaseFile file;
+    private HybridFileParcelable file;
 
-    public LoadFolderSpaceData(Context c, AppTheme appTheme, PieChart chart, BaseFile f) {
+    public LoadFolderSpaceDataTask(Context c, AppTheme appTheme, PieChart chart, HybridFileParcelable f) {
         context = c;
         this.appTheme = appTheme;
         this.chart = chart;
@@ -54,12 +53,7 @@ public class LoadFolderSpaceData extends AsyncTask<Void, Long, Pair<String, List
 
     @Override
     protected Pair<String, List<PieEntry>> doInBackground(Void... params) {
-        long[] dataArray = Futils.getSpaces(file, context, new OnProgressUpdate<Long[]>() {
-            @Override
-            public void onUpdate(Long[] data) {
-                publishProgress(data);
-            }
-        });
+        long[] dataArray = FileUtils.getSpaces(file, context, this::publishProgress);
 
         if (dataArray[0] != -1 && dataArray[0] != 0) {
             long totalSpace = dataArray[0];
diff --git a/app/src/main/java/com/amaze/filemanager/services/asynctasks/MoveFiles.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/MoveFiles.java
similarity index 71%
rename from app/src/main/java/com/amaze/filemanager/services/asynctasks/MoveFiles.java
rename to app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/MoveFiles.java
index dd9c2980f..cee1b0b5d 100644
--- a/app/src/main/java/com/amaze/filemanager/services/asynctasks/MoveFiles.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/MoveFiles.java
@@ -17,24 +17,25 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.services.asynctasks;
+package com.amaze.filemanager.asynchronous.asynctasks;
 
 import android.content.Context;
 import android.content.Intent;
 import android.os.AsyncTask;
 
-import com.amaze.filemanager.activities.BaseActivity;
+import com.amaze.filemanager.activities.MainActivity;
+import com.amaze.filemanager.activities.superclasses.ThemedActivity;
 import com.amaze.filemanager.database.CryptHandler;
 import com.amaze.filemanager.database.models.EncryptedEntry;
-import com.amaze.filemanager.exceptions.RootNotPermittedException;
-import com.amaze.filemanager.filesystem.BaseFile;
+import com.amaze.filemanager.exceptions.ShellNotRunningException;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.fragments.MainFragment;
-import com.amaze.filemanager.services.CopyService;
-import com.amaze.filemanager.utils.AppConfig;
+import com.amaze.filemanager.utils.application.AppConfig;
+import com.amaze.filemanager.asynchronous.services.CopyService;
 import com.amaze.filemanager.utils.DataUtils;
 import com.amaze.filemanager.utils.cloud.CloudUtil;
 import com.amaze.filemanager.utils.files.CryptUtil;
-import com.amaze.filemanager.utils.files.Futils;
+import com.amaze.filemanager.utils.files.FileUtils;
 import com.amaze.filemanager.utils.OpenMode;
 import com.amaze.filemanager.utils.RootUtils;
 import com.amaze.filemanager.utils.ServiceWatcherUtil;
@@ -50,17 +51,17 @@ import jcifs.smb.SmbFile;
 /**
  * AsyncTask that moves files from source to destination by trying to rename files first,
  * if they're in the same filesystem, else starting the copy service.
- * Be advised - do not start this AsyncTask directly but use {@link CopyFileCheck} instead
+ * Be advised - do not start this AsyncTask directly but use {@link PrepareCopyTask} instead
  */
 public class MoveFiles extends AsyncTask<ArrayList<String>, Void, Boolean> {
 
-    private ArrayList<ArrayList<BaseFile>> files;
+    private ArrayList<ArrayList<HybridFileParcelable>> files;
     private MainFragment mainFrag;
     private ArrayList<String> paths;
     private Context context;
     private OpenMode mode;
 
-    public MoveFiles(ArrayList<ArrayList<BaseFile>> files, MainFragment ma, Context context, OpenMode mode) {
+    public MoveFiles(ArrayList<ArrayList<HybridFileParcelable>> files, MainFragment ma, Context context, OpenMode mode) {
         mainFrag = ma;
         this.context = context;
         this.files = files;
@@ -76,7 +77,7 @@ public class MoveFiles extends AsyncTask<ArrayList<String>, Void, Boolean> {
         switch (mode) {
             case SMB:
                 for (int i = 0; i < paths.size(); i++) {
-                    for (BaseFile f : files.get(i)) {
+                    for (HybridFileParcelable f : files.get(i)) {
                         try {
                             SmbFile source = new SmbFile(f.getPath());
                             SmbFile dest = new SmbFile(paths.get(i) + "/" + f.getName());
@@ -93,17 +94,17 @@ public class MoveFiles extends AsyncTask<ArrayList<String>, Void, Boolean> {
                 break;
             case FILE:
                 for (int i = 0; i < paths.size(); i++) {
-                    for (BaseFile f : files.get(i)) {
+                    for (HybridFileParcelable f : files.get(i)) {
                         File dest = new File(paths.get(i) + "/" + f.getName());
                         File source = new File(f.getPath());
                         if (!source.renameTo(dest)) {
 
                             // check if we have root
-                            if (BaseActivity.rootMode) {
+                            if (ThemedActivity.rootMode) {
                                 try {
                                     if (!RootUtils.rename(f.getPath(), paths.get(i) + "/" + f.getName()))
                                         return false;
-                                } catch (RootNotPermittedException e) {
+                                } catch (ShellNotRunningException e) {
                                     e.printStackTrace();
                                     return false;
                                 }
@@ -117,7 +118,7 @@ public class MoveFiles extends AsyncTask<ArrayList<String>, Void, Boolean> {
             case ONEDRIVE:
             case GDRIVE:
                 for (int i=0; i<paths.size(); i++) {
-                    for (BaseFile baseFile : files.get(i)) {
+                    for (HybridFileParcelable baseFile : files.get(i)) {
 
                         DataUtils dataUtils = DataUtils.getInstance();
 
@@ -150,37 +151,36 @@ public class MoveFiles extends AsyncTask<ArrayList<String>, Void, Boolean> {
         if (movedCorrectly) {
             if (mainFrag != null && mainFrag.getCurrentPath().equals(paths.get(0))) {
                 // mainFrag.updateList();
-                Intent intent = new Intent("loadlist");
+                Intent intent = new Intent(MainActivity.KEY_INTENT_LOAD_LIST);
+
+                intent.putExtra(MainActivity.KEY_INTENT_LOAD_LIST_FILE, paths.get(0));
                 context.sendBroadcast(intent);
             }
 
             for (int i = 0; i < paths.size(); i++) {
-                for (BaseFile f : files.get(i)) {
-                    Futils.scanFile(f.getPath(), context);
-                    Futils.scanFile(paths.get(i) + "/" + f.getName(), context);
+                for (HybridFileParcelable f : files.get(i)) {
+                    FileUtils.scanFile(f.getPath(), context);
+                    FileUtils.scanFile(paths.get(i) + "/" + f.getName(), context);
                 }
             }
 
             // updating encrypted db entry if any encrypted file was moved
-            AppConfig.runInBackground(new Runnable() {
-                @Override
-                public void run() {
-                    for (int i=0; i<paths.size(); i++) {
-                        for (BaseFile file : files.get(i)) {
-                            if (file.getName().endsWith(CryptUtil.CRYPT_EXTENSION)) {
-                                try {
+            AppConfig.runInBackground(() -> {
+                for (int i = 0; i < paths.size(); i++) {
+                    for (HybridFileParcelable file : files.get(i)) {
+                        if (file.getName().endsWith(CryptUtil.CRYPT_EXTENSION)) {
+                            try {
 
-                                    CryptHandler cryptHandler = new CryptHandler(context);
-                                    EncryptedEntry oldEntry = cryptHandler.findEntry(file.getPath());
-                                    EncryptedEntry newEntry = new EncryptedEntry();
-                                    newEntry.setId(oldEntry.getId());
-                                    newEntry.setPassword(oldEntry.getPassword());
-                                    newEntry.setPath(paths.get(i) + "/" + file.getName());
-                                    cryptHandler.updateEntry(oldEntry, newEntry);
-                                } catch (Exception e) {
-                                    e.printStackTrace();
-                                    // couldn't change the entry, leave it alone
-                                }
+                                CryptHandler cryptHandler = new CryptHandler(context);
+                                EncryptedEntry oldEntry = cryptHandler.findEntry(file.getPath());
+                                EncryptedEntry newEntry = new EncryptedEntry();
+                                newEntry.setId(oldEntry.getId());
+                                newEntry.setPassword(oldEntry.getPassword());
+                                newEntry.setPath(paths.get(i) + "/" + file.getName());
+                                cryptHandler.updateEntry(oldEntry, newEntry);
+                            } catch (Exception e) {
+                                e.printStackTrace();
+                                // couldn't change the entry, leave it alone
                             }
                         }
                     }
diff --git a/app/src/main/java/com/amaze/filemanager/services/asynctasks/CopyFileCheck.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/PrepareCopyTask.java
similarity index 74%
rename from app/src/main/java/com/amaze/filemanager/services/asynctasks/CopyFileCheck.java
rename to app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/PrepareCopyTask.java
index b640f6eaa..b8d9e6657 100644
--- a/app/src/main/java/com/amaze/filemanager/services/asynctasks/CopyFileCheck.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/PrepareCopyTask.java
@@ -1,10 +1,9 @@
-package com.amaze.filemanager.services.asynctasks;
+package com.amaze.filemanager.asynchronous.asynctasks;
 
+import android.app.ProgressDialog;
 import android.content.Context;
 import android.content.Intent;
-import android.graphics.Color;
 import android.os.AsyncTask;
-import android.support.annotation.NonNull;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.widget.CheckBox;
@@ -14,19 +13,19 @@ import android.widget.Toast;
 import com.afollestad.materialdialogs.DialogAction;
 import com.afollestad.materialdialogs.MaterialDialog;
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.activities.BaseActivity;
 import com.amaze.filemanager.activities.MainActivity;
-import com.amaze.filemanager.filesystem.BaseFile;
-import com.amaze.filemanager.filesystem.FileUtil;
-import com.amaze.filemanager.filesystem.HFile;
+import com.amaze.filemanager.asynchronous.services.CopyService;
+import com.amaze.filemanager.filesystem.HybridFile;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.fragments.MainFragment;
-import com.amaze.filemanager.services.CopyService;
 import com.amaze.filemanager.utils.DataUtils;
 import com.amaze.filemanager.utils.MainActivityHelper;
+import com.amaze.filemanager.utils.OnFileFound;
 import com.amaze.filemanager.utils.OpenMode;
 import com.amaze.filemanager.utils.ServiceWatcherUtil;
 import com.amaze.filemanager.utils.Utils;
-import com.amaze.filemanager.utils.files.Futils;
+import com.amaze.filemanager.utils.color.ColorUsage;
+import com.amaze.filemanager.utils.files.FileUtils;
 
 import java.io.File;
 import java.util.ArrayList;
@@ -38,12 +37,13 @@ import java.util.Set;
  * Created by arpitkh996 on 12-01-2016, modified by Emmanuel Messulam<emmanuelbendavid@gmail.com>
  *
  *  This AsyncTask works by creating a tree where each folder that can be fusioned together with
- *  another in the destination is a node (CopyNode), each node is copied when the conflicts are dealt
- *  with (the dialog is shown, and the tree is walked via a BFS).
+ *  another in the destination is a node (CopyNode). While the tree is being created an indeterminate
+ *  ProgressDialog is shown. Each node is copied when the conflicts are dealt with
+ *  (the dialog is shown, and the tree is walked via a BFS).
  *  If the process is cancelled (via the button in the dialog) the dialog closes without any more code
  *  to be executed, finishCopying() is never executed so no changes are made.
  */
-public class CopyFileCheck extends AsyncTask<ArrayList<BaseFile>, String, CopyFileCheck.CopyNode> {
+public class PrepareCopyTask extends AsyncTask<ArrayList<HybridFileParcelable>, String, PrepareCopyTask.CopyNode> {
 
     private enum DO_FOR_ALL_ELEMENTS {
         DO_NOT_REPLACE,
@@ -56,6 +56,7 @@ public class CopyFileCheck extends AsyncTask<ArrayList<BaseFile>, String, CopyFi
     private int counter = 0;
     private MainActivity mainActivity;
     private Context context;
+    private ProgressDialog dialog;
     private boolean rootMode = false;
     private OpenMode openMode = OpenMode.FILE;
     private DO_FOR_ALL_ELEMENTS dialogState = null;
@@ -64,10 +65,10 @@ public class CopyFileCheck extends AsyncTask<ArrayList<BaseFile>, String, CopyFi
     private ArrayList<File> deleteCopiedFolder = null;
     private CopyNode copyFolder;
     private final ArrayList<String> paths = new ArrayList<>();
-    private final ArrayList<ArrayList<BaseFile>> filesToCopyPerFolder = new ArrayList<>();
-    private ArrayList<BaseFile> filesToCopy;    // a copy of params sent to this
+    private final ArrayList<ArrayList<HybridFileParcelable>> filesToCopyPerFolder = new ArrayList<>();
+    private ArrayList<HybridFileParcelable> filesToCopy;    // a copy of params sent to this
 
-    public CopyFileCheck(MainFragment ma, String path, Boolean move, MainActivity con, boolean rootMode) {
+    public PrepareCopyTask(MainFragment ma, String path, Boolean move, MainActivity con, boolean rootMode) {
         mainFrag = ma;
         this.move = move;
         mainActivity = con;
@@ -78,13 +79,19 @@ public class CopyFileCheck extends AsyncTask<ArrayList<BaseFile>, String, CopyFi
         this.path = path;
     }
 
+    @Override
+    protected void onPreExecute() {
+        super.onPreExecute();
+        dialog = ProgressDialog.show(context, "", context.getString(R.string.processing), true);
+    }
+
     @Override
     public void onProgressUpdate(String... message) {
         Toast.makeText(context, message[0], Toast.LENGTH_LONG).show();
     }
 
     @Override
-    protected CopyNode doInBackground(ArrayList<BaseFile>... params) {
+    protected CopyNode doInBackground(ArrayList<HybridFileParcelable>... params) {
         filesToCopy = params[0];
         long totalBytes = 0;
 
@@ -98,9 +105,9 @@ public class CopyFileCheck extends AsyncTask<ArrayList<BaseFile>, String, CopyFi
             return null;
         }
 
-        totalBytes = Futils.getTotalBytes(filesToCopy, context);
+        totalBytes = FileUtils.getTotalBytes(filesToCopy, context);
 
-        HFile destination = new HFile(openMode, path);
+        HybridFile destination = new HybridFile(openMode, path);
         if (destination.getUsableSpace() < totalBytes) {
             publishProgress(context.getResources().getString(R.string.in_safe));
             return null;
@@ -111,17 +118,18 @@ public class CopyFileCheck extends AsyncTask<ArrayList<BaseFile>, String, CopyFi
         return copyFolder;
     }
 
-    private ArrayList<BaseFile> checkConflicts(ArrayList<BaseFile> filesToCopy, HFile destination) {
-        ArrayList<BaseFile> conflictingFiles = new ArrayList<>();
-
-        for (BaseFile k1 : destination.listFiles(context, rootMode)) {
-            for (BaseFile j : filesToCopy) {
-                if (k1.getName().equals((j).getName())) {
-                    conflictingFiles.add(j);
+    private ArrayList<HybridFileParcelable> checkConflicts(final ArrayList<HybridFileParcelable> filesToCopy, HybridFile destination) {
+        final ArrayList<HybridFileParcelable> conflictingFiles = new ArrayList<>();
+        destination.forEachChildrenFile(context, rootMode, new OnFileFound() {
+            @Override
+            public void onFileFound(HybridFileParcelable file) {
+                for (HybridFileParcelable j : filesToCopy) {
+                    if (file.getName().equals((j).getName())) {
+                        conflictingFiles.add(j);
+                    }
                 }
             }
-        }
-
+        });
         return conflictingFiles;
     }
 
@@ -144,9 +152,11 @@ public class CopyFileCheck extends AsyncTask<ArrayList<BaseFile>, String, CopyFi
 
             onEndDialog(null, null, null);
         }
+
+        dialog.dismiss();
     }
 
-    private void startService(ArrayList<BaseFile> sourceFiles, String target, OpenMode openmode) {
+    private void startService(ArrayList<HybridFileParcelable> sourceFiles, String target, OpenMode openmode) {
         Intent intent = new Intent(context, CopyService.class);
         intent.putParcelableArrayListExtra(CopyService.TAG_COPY_SOURCES, sourceFiles);
         intent.putExtra(CopyService.TAG_COPY_TARGET, target);
@@ -155,8 +165,9 @@ public class CopyFileCheck extends AsyncTask<ArrayList<BaseFile>, String, CopyFi
         ServiceWatcherUtil.runService(context, intent);
     }
 
-    private void showDialog(final String path, final ArrayList<BaseFile> filesToCopy,
-                            final ArrayList<BaseFile> conflictingFiles) {
+    private void showDialog(final String path, final ArrayList<HybridFileParcelable> filesToCopy,
+                            final ArrayList<HybridFileParcelable> conflictingFiles) {
+        int accentColor = mainActivity.getColorPreference().getColor(ColorUsage.ACCENT);
         final MaterialDialog.Builder dialogBuilder = new MaterialDialog.Builder(context);
         LayoutInflater layoutInflater =
                 (LayoutInflater) mainActivity.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
@@ -168,30 +179,24 @@ public class CopyFileCheck extends AsyncTask<ArrayList<BaseFile>, String, CopyFi
 
         // checkBox
         final CheckBox checkBox = (CheckBox) view.findViewById(R.id.checkBox);
-        Utils.setTint(context, checkBox, Color.parseColor(BaseActivity.accentSkin));
+        Utils.setTint(context, checkBox, accentColor);
         dialogBuilder.theme(mainActivity.getAppTheme().getMaterialDialogTheme());
         dialogBuilder.title(context.getResources().getString(R.string.paste));
         dialogBuilder.positiveText(R.string.skip);
         dialogBuilder.negativeText(R.string.overwrite);
         dialogBuilder.neutralText(R.string.cancel);
-        dialogBuilder.positiveColor(Color.parseColor(BaseActivity.accentSkin));
-        dialogBuilder.negativeColor(Color.parseColor(BaseActivity.accentSkin));
-        dialogBuilder.neutralColor(Color.parseColor(BaseActivity.accentSkin));
-        dialogBuilder.onPositive(new MaterialDialog.SingleButtonCallback() {
-            @Override
-            public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
-                if (checkBox.isChecked())
-                    dialogState = DO_FOR_ALL_ELEMENTS.DO_NOT_REPLACE;
-                doNotReplaceFiles(path, filesToCopy, conflictingFiles);
-            }
+        dialogBuilder.positiveColor(accentColor);
+        dialogBuilder.negativeColor(accentColor);
+        dialogBuilder.neutralColor(accentColor);
+        dialogBuilder.onPositive((dialog, which) -> {
+            if (checkBox.isChecked())
+                dialogState = DO_FOR_ALL_ELEMENTS.DO_NOT_REPLACE;
+            doNotReplaceFiles(path, filesToCopy, conflictingFiles);
         });
-        dialogBuilder.onNegative(new MaterialDialog.SingleButtonCallback() {
-            @Override
-            public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
-                if (checkBox.isChecked())
-                    dialogState = DO_FOR_ALL_ELEMENTS.REPLACE;
-                replaceFiles(path, filesToCopy, conflictingFiles);
-            }
+        dialogBuilder.onNegative((dialog, which) -> {
+            if (checkBox.isChecked())
+                dialogState = DO_FOR_ALL_ELEMENTS.REPLACE;
+            replaceFiles(path, filesToCopy, conflictingFiles);
         });
 
         final MaterialDialog dialog = dialogBuilder.build();
@@ -202,8 +207,8 @@ public class CopyFileCheck extends AsyncTask<ArrayList<BaseFile>, String, CopyFi
         }
     }
 
-    private void onEndDialog(String path, ArrayList<BaseFile> filesToCopy,
-                             ArrayList<BaseFile> conflictingFiles) {
+    private void onEndDialog(String path, ArrayList<HybridFileParcelable> filesToCopy,
+                             ArrayList<HybridFileParcelable> conflictingFiles) {
         if (conflictingFiles != null && counter != conflictingFiles.size() && conflictingFiles.size() > 0) {
             if (dialogState == null)
                 showDialog(path, filesToCopy, conflictingFiles);
@@ -232,7 +237,7 @@ public class CopyFileCheck extends AsyncTask<ArrayList<BaseFile>, String, CopyFi
         }
     }
 
-    private void doNotReplaceFiles(String path, ArrayList<BaseFile> filesToCopy, ArrayList<BaseFile> conflictingFiles) {
+    private void doNotReplaceFiles(String path, ArrayList<HybridFileParcelable> filesToCopy, ArrayList<HybridFileParcelable> conflictingFiles) {
         if (counter < conflictingFiles.size()) {
             if (dialogState != null) {
                 filesToCopy.remove(conflictingFiles.get(counter));
@@ -248,7 +253,7 @@ public class CopyFileCheck extends AsyncTask<ArrayList<BaseFile>, String, CopyFi
         onEndDialog(path, filesToCopy, conflictingFiles);
     }
 
-    private void replaceFiles(String path, ArrayList<BaseFile> filesToCopy, ArrayList<BaseFile> conflictingFiles) {
+    private void replaceFiles(String path, ArrayList<HybridFileParcelable> filesToCopy, ArrayList<HybridFileParcelable> conflictingFiles) {
         if (counter < conflictingFiles.size()) {
             if (dialogState != null) {
                 counter++;
@@ -260,7 +265,7 @@ public class CopyFileCheck extends AsyncTask<ArrayList<BaseFile>, String, CopyFi
         onEndDialog(path, filesToCopy, conflictingFiles);
     }
 
-    private void finishCopying(ArrayList<String> paths, ArrayList<ArrayList<BaseFile>> filesToCopyPerFolder) {
+    private void finishCopying(ArrayList<String> paths, ArrayList<ArrayList<HybridFileParcelable>> filesToCopyPerFolder) {
         for (int i = 0; i < filesToCopyPerFolder.size(); i++) {
             if (filesToCopyPerFolder.get(i) == null || filesToCopyPerFolder.get(i).size() == 0) {
                 filesToCopyPerFolder.remove(i);
@@ -296,14 +301,14 @@ public class CopyFileCheck extends AsyncTask<ArrayList<BaseFile>, String, CopyFi
 
     class CopyNode {
         private String path;
-        private ArrayList<BaseFile> filesToCopy, conflictingFiles;
+        private ArrayList<HybridFileParcelable> filesToCopy, conflictingFiles;
         private ArrayList<CopyNode> nextNodes = new ArrayList<>();
 
-        CopyNode(String p, ArrayList<BaseFile> filesToCopy) {
+        CopyNode(String p, ArrayList<HybridFileParcelable> filesToCopy) {
             path = p;
             this.filesToCopy = filesToCopy;
 
-            HFile destination = new HFile(openMode, path);
+            HybridFile destination = new HybridFile(openMode, path);
             conflictingFiles = checkConflicts(filesToCopy, destination);
 
             for (int i = 0; i < conflictingFiles.size(); i++) {
@@ -367,11 +372,11 @@ public class CopyFileCheck extends AsyncTask<ArrayList<BaseFile>, String, CopyFi
             return path;
         }
 
-        ArrayList<BaseFile> getFilesToCopy() {
+        ArrayList<HybridFileParcelable> getFilesToCopy() {
             return filesToCopy;
         }
 
-        ArrayList<BaseFile> getConflictingFiles() {
+        ArrayList<HybridFileParcelable> getConflictingFiles() {
             return conflictingFiles;
         }
 
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/RarHelperTask.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/RarHelperTask.java
new file mode 100644
index 000000000..ceb1ffba5
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/RarHelperTask.java
@@ -0,0 +1,77 @@
+package com.amaze.filemanager.asynchronous.asynctasks;
+
+import android.os.AsyncTask;
+
+import com.amaze.filemanager.filesystem.compressed.RarHelper;
+import com.amaze.filemanager.ui.CompressedObjectParcelable;
+import com.amaze.filemanager.utils.OnAsyncTaskFinished;
+import com.github.junrar.Archive;
+import com.github.junrar.exception.RarException;
+import com.github.junrar.rarfile.FileHeader;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+
+/**
+ * Created by Arpit on 25-01-2015 edited by Emmanuel Messulam<emmanuelbendavid@gmail.com>
+ */
+public class RarHelperTask extends AsyncTask<Void, Void, ArrayList<CompressedObjectParcelable>> {
+
+    private String fileLocation;
+    private String relativeDirectory;
+    private boolean createBackItem;
+    private OnAsyncTaskFinished<ArrayList<CompressedObjectParcelable>> onFinish;
+
+    /**
+     * AsyncTask to load RAR file items.
+     * @param realFileDirectory the location of the zip file
+     * @param dir relativeDirectory to access inside the zip file
+     */
+    public RarHelperTask(String realFileDirectory, String dir, boolean goBack,
+                         OnAsyncTaskFinished<ArrayList<CompressedObjectParcelable>> l) {
+        fileLocation = realFileDirectory;
+        relativeDirectory = dir;
+        createBackItem = goBack;
+        onFinish = l;
+    }
+
+    @Override
+    protected ArrayList<CompressedObjectParcelable> doInBackground(Void... params) {
+        ArrayList<CompressedObjectParcelable> elements = new ArrayList<>();
+
+        try {
+            if (createBackItem) {
+                elements.add(0, new CompressedObjectParcelable());
+            }
+
+            Archive zipfile = new Archive(new File(fileLocation));
+            String relativeDirDiffSeparator = relativeDirectory.replace("/", "\\");
+
+            for (FileHeader header : zipfile.getFileHeaders()) {
+                String name = header.getFileNameString();//This uses \ as separator, not /
+                boolean isInBaseDir = (relativeDirDiffSeparator == null || relativeDirDiffSeparator.equals("")) && !name.contains("\\");
+                boolean isInRelativeDir = relativeDirDiffSeparator != null && name.contains("\\")
+                        && name.substring(0, name.lastIndexOf("\\")).equals(relativeDirDiffSeparator);
+
+                if (isInBaseDir || isInRelativeDir) {
+                    elements.add(new CompressedObjectParcelable(RarHelper.convertName(header), 0, header.getDataSize(), header.isDirectory()));
+                }
+            }
+            Collections.sort(elements, new CompressedObjectParcelable.Sorter());
+        } catch (RarException | IOException e) {
+            e.printStackTrace();
+        }
+
+        return elements;
+    }
+
+    @Override
+    protected void onPostExecute(ArrayList<CompressedObjectParcelable> zipEntries) {
+        super.onPostExecute(zipEntries);
+        onFinish.onAsyncTaskFinished(zipEntries);
+    }
+
+}
+
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/SearchAsyncTask.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/SearchAsyncTask.java
new file mode 100644
index 000000000..0f36b8c4a
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/SearchAsyncTask.java
@@ -0,0 +1,190 @@
+package com.amaze.filemanager.asynchronous.asynctasks;
+
+import android.app.Activity;
+import android.os.AsyncTask;
+import android.util.Log;
+
+import com.amaze.filemanager.filesystem.HybridFile;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
+import com.amaze.filemanager.fragments.SearchWorkerFragment;
+import com.amaze.filemanager.utils.OnFileFound;
+import com.amaze.filemanager.utils.OpenMode;
+
+import java.lang.ref.WeakReference;
+import java.util.regex.Pattern;
+
+/**
+ * @author Emmanuel
+ *         on 15/8/2017, at 19:47.
+ */
+
+public class SearchAsyncTask extends AsyncTask<String, HybridFileParcelable, Void> {
+
+    private static final String TAG = "SearchAsyncTask";
+
+    private WeakReference<Activity> activity;
+    private SearchWorkerFragment.HelperCallbacks mCallbacks;
+    private String mInput;
+    private OpenMode mOpenMode;
+    private boolean mRootMode, isRegexEnabled, isMatchesEnabled;
+
+    public SearchAsyncTask(Activity a, SearchWorkerFragment.HelperCallbacks l,
+                           String input, OpenMode openMode, boolean root, boolean regex,
+                           boolean matches) {
+        activity = new WeakReference<>(a);
+        mCallbacks = l;
+        mInput = input;
+        mOpenMode = openMode;
+        mRootMode = root;
+        isRegexEnabled = regex;
+        isMatchesEnabled = matches;
+    }
+
+    @Override
+    protected void onPreExecute() {
+            /*
+            * Note that we need to check if the callbacks are null in each
+            * method in case they are invoked after the Activity's and
+            * Fragment's onDestroy() method have been called.
+             */
+        if (mCallbacks != null) {
+            mCallbacks.onPreExecute(mInput);
+        }
+    }
+
+    // mCallbacks not checked for null because of possibility of
+    // race conditions b/w worker thread main thread
+    @Override
+    protected Void doInBackground(String... params) {
+
+        String path = params[0];
+        HybridFile file = new HybridFile(mOpenMode, path);
+        file.generateMode(activity.get());
+        if (file.isSmb()) return null;
+
+        // level 1
+        // if regex or not
+        if (!isRegexEnabled) {
+            search(file, mInput);
+        } else {
+            // compile the regular expression in the input
+            Pattern pattern = Pattern.compile(bashRegexToJava(mInput));
+            // level 2
+            if (!isMatchesEnabled) searchRegExFind(file, pattern);
+            else searchRegExMatch(file, pattern);
+        }
+        return null;
+    }
+
+    @Override
+    public void onPostExecute(Void c) {
+        if (mCallbacks != null) {
+            mCallbacks.onPostExecute(mInput);
+        }
+    }
+
+    @Override
+    protected void onCancelled() {
+        if (mCallbacks != null) mCallbacks.onCancelled();
+    }
+
+    @Override
+    public void onProgressUpdate(HybridFileParcelable... val) {
+        if (!isCancelled() && mCallbacks != null) {
+            mCallbacks.onProgressUpdate(val[0], mInput);
+        }
+    }
+
+    /**
+     * Recursively search for occurrences of a given text in file names and publish the result
+     *
+     * @param directory the current path
+     */
+    private void search(HybridFile directory, final SearchFilter filter) {
+        if (directory.isDirectory(activity.get())) {// do you have permission to read this directory?
+            directory.forEachChildrenFile(activity.get(), mRootMode, new OnFileFound() {
+                @Override
+                public void onFileFound(HybridFileParcelable file) {
+                    if (!isCancelled()) {
+                        if (filter.searchFilter(file.getName())) {
+                            publishProgress(file);
+                        }
+                        if (file.isDirectory() && !isCancelled()) {
+                            search(file, filter);
+                        }
+                    }
+                }
+            });
+        } else {
+            Log.d(TAG, "Cannot search " + directory.getPath() + ": Permission Denied");
+        }
+    }
+
+
+    /**
+     * Recursively search for occurrences of a given text in file names and publish the result
+     *
+     * @param file  the current path
+     * @param query the searched text
+     */
+    private void search(HybridFile file, final String query) {
+        search(file, fileName -> fileName.toLowerCase().contains(query.toLowerCase()));
+    }
+
+    /**
+     * Recursively find a java regex pattern {@link Pattern} in the file names and publish the result
+     *
+     * @param file    the current file
+     * @param pattern the compiled java regex
+     */
+    private void searchRegExFind(HybridFile file, final Pattern pattern) {
+        search(file, new SearchFilter() {
+            @Override
+            public boolean searchFilter(String fileName) {
+                return pattern.matcher(fileName).find();
+            }
+        });
+    }
+
+    /**
+     * Recursively match a java regex pattern {@link Pattern} with the file names and publish the result
+     *
+     * @param file    the current file
+     * @param pattern the compiled java regex
+     */
+    private void searchRegExMatch(HybridFile file, final Pattern pattern) {
+        search(file, fileName -> pattern.matcher(fileName).matches());
+    }
+
+    /**
+     * method converts bash style regular expression to java. See {@link Pattern}
+     *
+     * @param originalString
+     * @return converted string
+     */
+    private String bashRegexToJava(String originalString) {
+        StringBuilder stringBuilder = new StringBuilder();
+
+        for (int i = 0; i < originalString.length(); i++) {
+            switch (originalString.charAt(i) + "") {
+                case "*":
+                    stringBuilder.append("\\w*");
+                    break;
+                case "?":
+                    stringBuilder.append("\\w");
+                    break;
+                default:
+                    stringBuilder.append(originalString.charAt(i));
+                    break;
+            }
+        }
+
+        Log.d(getClass().getSimpleName(), stringBuilder.toString());
+        return stringBuilder.toString();
+    }
+
+    public interface SearchFilter {
+        boolean searchFilter(String fileName);
+    }
+
+}
diff --git a/app/src/main/java/com/amaze/filemanager/services/asynctasks/SearchTextTask.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/SearchTextTask.java
similarity index 76%
rename from app/src/main/java/com/amaze/filemanager/services/asynctasks/SearchTextTask.java
rename to app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/SearchTextTask.java
index c185080cb..cd8baedf4 100644
--- a/app/src/main/java/com/amaze/filemanager/services/asynctasks/SearchTextTask.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/SearchTextTask.java
@@ -1,4 +1,4 @@
-package com.amaze.filemanager.services.asynctasks;
+package com.amaze.filemanager.asynchronous.asynctasks;
 
 import android.graphics.Color;
 import android.os.AsyncTask;
@@ -8,7 +8,8 @@ import android.text.style.BackgroundColorSpan;
 import android.widget.EditText;
 import android.widget.ImageButton;
 
-import com.amaze.filemanager.activities.TextReader;
+import com.amaze.filemanager.activities.TextEditorActivity;
+import com.amaze.filemanager.utils.ImmutableEntry;
 import com.amaze.filemanager.utils.MapEntry;
 import com.amaze.filemanager.utils.theme.AppTheme;
 
@@ -27,25 +28,25 @@ public class SearchTextTask extends AsyncTask<Editable, Void, ArrayList<MapEntry
     private ArrayList<MapEntry> nodes;
     private int searchTextLength;
     private ImageButton upButton, downButton;
-    private TextReader textReader;
+    private TextEditorActivity textEditorActivity;
     private Editable editText;
     private String searchSubString;
     private StringReader stringReader;
     private LineNumberReader lineNumberReader;
 
-    public SearchTextTask(TextReader textReader) {
-        this.textReader = textReader;
+    public SearchTextTask(TextEditorActivity textEditorActivity) {
+        this.textEditorActivity = textEditorActivity;
     }
 
     @Override
     protected void onPreExecute() {
         super.onPreExecute();
 
-        this.searchEditText = textReader.searchEditText;
-        this.nodes = textReader.nodes;
-        this.upButton = textReader.upButton;
-        this.downButton = textReader.downButton;
-        this.mInput = textReader.mInput;
+        this.searchEditText = textEditorActivity.searchEditText;
+        this.nodes = textEditorActivity.nodes;
+        this.upButton = textEditorActivity.upButton;
+        this.downButton = textEditorActivity.downButton;
+        this.mInput = textEditorActivity.mInput;
         searchTextLength = searchEditText.length();
         editText = mInput.getText();
         stringReader = new StringReader(editText.toString());
@@ -63,7 +64,7 @@ public class SearchTextTask extends AsyncTask<Editable, Void, ArrayList<MapEntry
             // comparing and adding searched phrase to a list
             if (searchSubString.equalsIgnoreCase(params[0].toString())) {
 
-                nodes.add(new MapEntry(new MapEntry.KeyMapEntry(i, i + params[0].length()),
+                nodes.add(new MapEntry(new ImmutableEntry<>(i, i + params[0].length()),
                         lineNumberReader.getLineNumber()));
             }
 
@@ -85,7 +86,7 @@ public class SearchTextTask extends AsyncTask<Editable, Void, ArrayList<MapEntry
         for (Map.Entry mapEntry : mapEntries) {
 
             Map.Entry keyMapEntry = (Map.Entry) mapEntry.getKey();
-            mInput.getText().setSpan(textReader.getAppTheme().equals(AppTheme.LIGHT) ? new BackgroundColorSpan(Color.YELLOW) :
+            mInput.getText().setSpan(textEditorActivity.getAppTheme().equals(AppTheme.LIGHT) ? new BackgroundColorSpan(Color.YELLOW) :
                             new BackgroundColorSpan(Color.LTGRAY),
                     (Integer) keyMapEntry.getKey(), (Integer) keyMapEntry.getValue(),
                     Spanned.SPAN_INCLUSIVE_INCLUSIVE);
@@ -96,7 +97,7 @@ public class SearchTextTask extends AsyncTask<Editable, Void, ArrayList<MapEntry
             downButton.setEnabled(true);
 
             // downButton
-            textReader.onClick(downButton);
+            textEditorActivity.onClick(downButton);
         } else {
             upButton.setEnabled(false);
             downButton.setEnabled(false);
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ZipHelperTask.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ZipHelperTask.java
new file mode 100644
index 000000000..c3d35a104
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ZipHelperTask.java
@@ -0,0 +1,130 @@
+package com.amaze.filemanager.asynchronous.asynctasks;
+
+import android.content.Context;
+import android.net.Uri;
+import android.os.AsyncTask;
+
+import com.amaze.filemanager.ui.CompressedObjectParcelable;
+import com.amaze.filemanager.utils.OnAsyncTaskFinished;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+import java.util.zip.ZipInputStream;
+
+/**
+ * Created by Vishal on 11/23/2014 edited by Emmanuel Messulam<emmanuelbendavid@gmail.com>
+ */
+public class ZipHelperTask extends AsyncTask<Void, Void, ArrayList<CompressedObjectParcelable>> {
+
+    private WeakReference<Context> context;
+    private Uri fileLocation;
+    private String relativeDirectory;
+    private boolean createBackItem;
+    private OnAsyncTaskFinished<ArrayList<CompressedObjectParcelable>> onFinish;
+
+    /**
+     * AsyncTask to load ZIP file items.
+     * @param realFileDirectory the location of the zip file
+     * @param dir relativeDirectory to access inside the zip file
+     */
+    public ZipHelperTask(Context c, String realFileDirectory, String dir, boolean goback,
+                         OnAsyncTaskFinished<ArrayList<CompressedObjectParcelable>> l) {
+        context = new WeakReference<>(c);
+        fileLocation = Uri.parse(realFileDirectory);
+        relativeDirectory = dir;
+        createBackItem = goback;
+        onFinish = l;
+    }
+
+    @Override
+    protected ArrayList<CompressedObjectParcelable> doInBackground(Void... params) {
+        ArrayList<CompressedObjectParcelable> elements = new ArrayList<>();
+
+        if (createBackItem) {
+            elements.add(0, new CompressedObjectParcelable());
+        }
+
+        try {
+            ArrayList<CompressedObjectParcelable> wholelist = new ArrayList<>();
+            if (new File(fileLocation.getPath()).canRead()) {
+                ZipFile zipfile = new ZipFile(fileLocation.getPath());
+                for (Enumeration e = zipfile.entries(); e.hasMoreElements(); ) {
+                    ZipEntry entry = (ZipEntry) e.nextElement();
+                    wholelist.add(new CompressedObjectParcelable(entry.getName(), entry.getTime(), entry.getSize(), entry.isDirectory()));
+                }
+            } else {
+                ZipInputStream zipfile1 = new ZipInputStream(context.get().getContentResolver().openInputStream(fileLocation));
+                for (ZipEntry entry = zipfile1.getNextEntry(); entry != null; entry = zipfile1.getNextEntry()) {
+                    wholelist.add(new CompressedObjectParcelable(entry.getName(), entry.getTime(), entry.getSize(), entry.isDirectory()));
+                }
+            }
+
+            ArrayList<String> strings = new ArrayList<>();
+
+            for (CompressedObjectParcelable entry : wholelist) {
+                File file = new File(entry.getName());
+                if (relativeDirectory == null || relativeDirectory.trim().length() == 0) {
+                    String y = entry.getName();
+                    if (y.startsWith("/"))
+                        y = y.substring(1, y.length());
+                    if (file.getParent() == null || file.getParent().length() == 0 || file.getParent().equals("/")) {
+                        if (!strings.contains(y)) {
+                            elements.add(new CompressedObjectParcelable(y, entry.getTime(), entry.getSize(), entry.isDirectory()));
+                            strings.add(y);
+                        }
+                    } else {
+                        String path = y.substring(0, y.indexOf("/") + 1);
+                        if (!strings.contains(path)) {
+                            CompressedObjectParcelable zipObj = new CompressedObjectParcelable(path, entry.getTime(), entry.getSize(), true);
+                            strings.add(path);
+                            elements.add(zipObj);
+                        }
+                    }
+                } else {
+                    String y = entry.getName();
+                    if (entry.getName().startsWith("/"))
+                        y = y.substring(1, y.length());
+
+                    if (file.getParent() != null && (file.getParent().equals(relativeDirectory) || file.getParent().equals("/" + relativeDirectory))) {
+                        if (!strings.contains(y)) {
+                            elements.add(new CompressedObjectParcelable(y, entry.getTime(), entry.getSize(), entry.isDirectory()));
+                            strings.add(y);
+                        }
+                    } else {
+                        if (y.startsWith(relativeDirectory + "/") && y.length() > relativeDirectory.length() + 1) {
+                            String path1 = y.substring(relativeDirectory.length() + 1, y.length());
+
+                            int index = relativeDirectory.length() + 1 + path1.indexOf("/");
+                            String path = y.substring(0, index + 1);
+                            if (!strings.contains(path)) {
+                                CompressedObjectParcelable zipObj = new CompressedObjectParcelable(y.substring(0, index + 1), entry.getTime(), entry.getSize(), true);
+                                strings.add(path);
+                                elements.add(zipObj);
+                            }
+                        }
+                    }
+
+                }
+            }
+
+            Collections.sort(elements, new CompressedObjectParcelable.Sorter());
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+
+        return elements;
+    }
+
+    @Override
+    protected void onPostExecute(ArrayList<CompressedObjectParcelable> zipEntries) {
+        super.onPostExecute(zipEntries);
+        onFinish.onAsyncTaskFinished(zipEntries);
+    }
+
+}
diff --git a/app/src/main/java/com/amaze/filemanager/services/ftpservice/FTPReceiver.java b/app/src/main/java/com/amaze/filemanager/asynchronous/ftpservice/FTPReceiver.java
similarity index 65%
rename from app/src/main/java/com/amaze/filemanager/services/ftpservice/FTPReceiver.java
rename to app/src/main/java/com/amaze/filemanager/asynchronous/ftpservice/FTPReceiver.java
index 6033777be..6b2a158ad 100644
--- a/app/src/main/java/com/amaze/filemanager/services/ftpservice/FTPReceiver.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/ftpservice/FTPReceiver.java
@@ -1,4 +1,4 @@
-package com.amaze.filemanager.services.ftpservice;
+package com.amaze.filemanager.asynchronous.ftpservice;
 
 /**
  * Created by yashwanthreddyg on 09-06-2016.
@@ -17,14 +17,13 @@ public class FTPReceiver extends BroadcastReceiver {
         Log.v(TAG, "Received: " + intent.getAction());
 
         try {
-            if (intent.getAction().equals(FTPService.ACTION_START_FTPSERVER)) {
-                Intent serverService = new Intent(context, FTPService.class);
-                if (!FTPService.isRunning()) {
-                    context.startService(serverService);
-                }
+            Intent service = new Intent(context, FTPService.class);
+            service.putExtras(intent);
+            if (intent.getAction().equals(FTPService.ACTION_START_FTPSERVER) &&
+                    !FTPService.isRunning()) {
+                context.startService(service);
             } else if (intent.getAction().equals(FTPService.ACTION_STOP_FTPSERVER)) {
-                Intent serverService = new Intent(context, FTPService.class);
-                context.stopService(serverService);
+                context.stopService(service);
             }
         } catch (Exception e) {
             Log.e(TAG, "Failed to start/stop on intent " + e.getMessage());
diff --git a/app/src/main/java/com/amaze/filemanager/services/ftpservice/FTPService.java b/app/src/main/java/com/amaze/filemanager/asynchronous/ftpservice/FTPService.java
similarity index 96%
rename from app/src/main/java/com/amaze/filemanager/services/ftpservice/FTPService.java
rename to app/src/main/java/com/amaze/filemanager/asynchronous/ftpservice/FTPService.java
index 1c6295739..4b22122ba 100644
--- a/app/src/main/java/com/amaze/filemanager/services/ftpservice/FTPService.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/ftpservice/FTPService.java
@@ -1,4 +1,4 @@
-package com.amaze.filemanager.services.ftpservice;
+package com.amaze.filemanager.asynchronous.ftpservice;
 
 /**
  * Created by yashwanthreddyg on 09-06-2016.
@@ -21,7 +21,6 @@ import android.util.Log;
 import android.widget.Toast;
 
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.exceptions.CryptException;
 import com.amaze.filemanager.utils.files.CryptUtil;
 
 import org.apache.commons.compress.utils.IOUtils;
@@ -46,6 +45,7 @@ import java.net.NetworkInterface;
 import java.net.ServerSocket;
 import java.net.SocketException;
 import java.net.UnknownHostException;
+import java.security.GeneralSecurityException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Enumeration;
@@ -80,19 +80,24 @@ public class FTPService extends Service implements Runnable {
     static public final String ACTION_START_FTPSERVER = "com.amaze.filemanager.services.ftpservice.FTPReceiver.ACTION_START_FTPSERVER";
     static public final String ACTION_STOP_FTPSERVER = "com.amaze.filemanager.services.ftpservice.FTPReceiver.ACTION_STOP_FTPSERVER";
 
+    static public final String TAG_STARTED_BY_TILE = "started_by_tile";  // attribute of action_started, used by notification
+
     private String username, password;
     private boolean isPasswordProtected = false;
 
     private FtpServer server;
     protected static Thread serverThread = null;
 
+    private boolean isStartedByTile = false;
+
     @Override
     public int onStartCommand(Intent intent, int flags, int startId) {
+        isStartedByTile = intent.getBooleanExtra(TAG_STARTED_BY_TILE, false);
         int attempts = 10;
         while (serverThread != null) {
             if (attempts > 0) {
                 attempts--;
-                FTPService.sleepIgnoreInterupt(1000);
+                sleepIgnoreInterupt(1000);
             } else {
                 return START_STICKY;
             }
@@ -126,7 +131,7 @@ public class FTPService extends Service implements Runnable {
             try {
                 password = CryptUtil.decryptPassword(getApplicationContext(), preferences.getString(KEY_PREFERENCE_PASSWORD, ""));
                 isPasswordProtected = true;
-            } catch (CryptException e) {
+            } catch (GeneralSecurityException | IOException e) {
                 e.printStackTrace();
 
                 Toast.makeText(getApplicationContext(), getResources().getString(R.string.error), Toast.LENGTH_SHORT).show();
@@ -189,7 +194,7 @@ public class FTPService extends Service implements Runnable {
         try {
             server = serverFactory.createServer();
             server.start();
-            sendBroadcast(new Intent(FTPService.ACTION_STARTED));
+            sendBroadcast(new Intent(FTPService.ACTION_STARTED).putExtra(TAG_STARTED_BY_TILE, isStartedByTile));
         } catch (Exception e) {
             sendBroadcast(new Intent(FTPService.ACTION_FAILEDTOSTART));
         }
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/ftpservice/FTPTileService.java b/app/src/main/java/com/amaze/filemanager/asynchronous/ftpservice/FTPTileService.java
new file mode 100644
index 000000000..7dc7f522d
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/ftpservice/FTPTileService.java
@@ -0,0 +1,77 @@
+package com.amaze.filemanager.asynchronous.ftpservice;
+
+import android.annotation.TargetApi;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.graphics.drawable.Icon;
+import android.os.Build;
+import android.service.quicksettings.Tile;
+import android.service.quicksettings.TileService;
+import android.widget.Toast;
+
+import com.amaze.filemanager.R;
+
+/**
+ * Created by vishal on 1/1/17.
+ */
+
+@TargetApi(Build.VERSION_CODES.N)
+public class FTPTileService extends TileService {
+    private BroadcastReceiver ftpReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            updateTileState();
+        }
+    };
+
+    @Override
+    public void onStartListening() {
+        super.onStartListening();
+
+        IntentFilter f = new IntentFilter();
+        f.addAction(FTPService.ACTION_STARTED);
+        f.addAction(FTPService.ACTION_STOPPED);
+        registerReceiver(ftpReceiver, f);
+        updateTileState();
+    }
+
+    @Override
+    public void onStopListening() {
+        super.onStopListening();
+
+        unregisterReceiver(ftpReceiver);
+    }
+
+    @Override
+    public void onClick() {
+        super.onClick();
+
+        if (getQsTile().getState() == Tile.STATE_ACTIVE) {
+            getApplicationContext().sendBroadcast(new Intent(FTPService.ACTION_STOP_FTPSERVER));
+        } else {
+            if (FTPService.isConnectedToWifi(getApplicationContext())
+                    || FTPService.isConnectedToLocalNetwork(getApplicationContext())
+                    || FTPService.isEnabledWifiHotspot(getApplicationContext())) {
+                Intent i = new Intent(FTPService.ACTION_START_FTPSERVER);
+                i.putExtra(FTPService.TAG_STARTED_BY_TILE, true);
+                getApplicationContext().sendBroadcast(i);
+            } else {
+                Toast.makeText(getApplicationContext(), getString(R.string.ftp_no_wifi), Toast.LENGTH_LONG).show();
+            }
+        }
+    }
+
+    private void updateTileState() {
+        Tile tile = getQsTile();
+        if (FTPService.isRunning()) {
+            tile.setState(Tile.STATE_ACTIVE);
+            tile.setIcon(Icon.createWithResource(this, R.drawable.ic_ftp_dark));
+        } else {
+            tile.setState(Tile.STATE_INACTIVE);
+            tile.setIcon(Icon.createWithResource(this, R.drawable.ic_ftp_light));
+        }
+        tile.updateTile();
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/handlers/FileHandler.java b/app/src/main/java/com/amaze/filemanager/asynchronous/handlers/FileHandler.java
new file mode 100644
index 000000000..4d9aa585a
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/handlers/FileHandler.java
@@ -0,0 +1,82 @@
+package com.amaze.filemanager.asynchronous.handlers;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import android.support.v7.widget.RecyclerView;
+import android.view.View;
+
+import com.amaze.filemanager.adapters.RecyclerAdapter;
+import com.amaze.filemanager.filesystem.CustomFileObserver;
+import com.amaze.filemanager.filesystem.HybridFile;
+import com.amaze.filemanager.fragments.MainFragment;
+import com.amaze.filemanager.utils.provider.UtilitiesProviderInterface;
+
+import java.io.File;
+import java.lang.ref.WeakReference;
+
+/**
+ * @author Emmanuel
+ *         on 8/11/2017, at 17:37.
+ */
+public class FileHandler extends Handler {
+    private WeakReference<MainFragment> mainFragment;
+    private UtilitiesProviderInterface utilsProvider;
+    private RecyclerView listView;
+
+    public FileHandler(MainFragment mainFragment, UtilitiesProviderInterface utilsProvider,
+                        RecyclerView listView) {
+        super(Looper.getMainLooper());
+        this.mainFragment = new WeakReference<>(mainFragment);
+        this.utilsProvider = utilsProvider;
+        this.listView = listView;
+    }
+
+    @Override
+    public void handleMessage(Message msg) {
+        super.handleMessage(msg);
+        MainFragment main = mainFragment.get();
+
+        String path = (String) msg.obj;
+
+        switch (msg.what) {
+            case CustomFileObserver.GOBACK:
+                main.goBack();
+                break;
+            case CustomFileObserver.NEW_ITEM:
+                HybridFile fileCreated = new HybridFile(main.openMode,
+                        main.getCurrentPath() + "/" + path);
+                main.getElementsList().add(fileCreated.generateLayoutElement(main,
+                        utilsProvider));
+                break;
+            case CustomFileObserver.DELETED_ITEM:
+                for (int i = 0; i < main.getElementsList().size(); i++) {
+                    File currentFile = new File(main.getElementsList().get(i).getDesc());
+
+                    if (currentFile.getName().equals(path)) {
+                        main.getElementsList().remove(i);
+                        break;
+                    }
+                }
+                break;
+            default://Pass along other messages from the UI
+                super.handleMessage(msg);
+                return;
+        }
+
+        if (listView.getVisibility() == View.VISIBLE) {
+            if (main.getElementsList().size() == 0) {
+                // no item left in list, recreate views
+                main.reloadListElements(true, main.results, !main.IS_LIST);
+            } else {
+                // we already have some elements in list view, invalidate the adapter
+                ((RecyclerAdapter) listView.getAdapter()).setItems(main.getElementsList());
+            }
+        } else {
+            // there was no list view, means the directory was empty
+            main.loadlist(main.getCurrentPath(), true, main.openMode);
+        }
+
+        main.computeScroll();
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/services/asynctasks/AppListLoader.java b/app/src/main/java/com/amaze/filemanager/asynchronous/loaders/AppListLoader.java
similarity index 88%
rename from app/src/main/java/com/amaze/filemanager/services/asynctasks/AppListLoader.java
rename to app/src/main/java/com/amaze/filemanager/asynchronous/loaders/AppListLoader.java
index a4ccee45c..11ee086f0 100644
--- a/app/src/main/java/com/amaze/filemanager/services/asynctasks/AppListLoader.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/loaders/AppListLoader.java
@@ -1,4 +1,4 @@
-package com.amaze.filemanager.services.asynctasks;
+package com.amaze.filemanager.asynchronous.loaders;
 
 import android.content.Context;
 import android.content.pm.ApplicationInfo;
@@ -10,7 +10,7 @@ import android.support.v4.content.AsyncTaskLoader;
 import android.text.format.Formatter;
 
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.ui.LayoutElement;
+import com.amaze.filemanager.ui.LayoutElementParcelable;
 import com.amaze.filemanager.utils.files.FileListSorter;
 import com.amaze.filemanager.utils.InterestingConfigChange;
 import com.amaze.filemanager.utils.broadcast_receiver.PackageReceiver;
@@ -26,12 +26,12 @@ import java.util.List;
  * Class loads all the packages installed
  */
 
-public class AppListLoader extends AsyncTaskLoader<List<LayoutElement>> {
+public class AppListLoader extends AsyncTaskLoader<List<LayoutElementParcelable>> {
 
     private PackageManager packageManager;
     private PackageReceiver packageReceiver;
     private Context context;
-    private List<LayoutElement> mApps;
+    private List<LayoutElementParcelable> mApps;
     private int sortBy, asc;
 
     public AppListLoader(Context context, int sortBy, int asc) {
@@ -49,7 +49,7 @@ public class AppListLoader extends AsyncTaskLoader<List<LayoutElement>> {
     }
 
     @Override
-    public List<LayoutElement> loadInBackground() {
+    public List<LayoutElementParcelable> loadInBackground() {
         List<ApplicationInfo> apps = packageManager.getInstalledApplications(
                 PackageManager.MATCH_UNINSTALLED_PACKAGES |
                         PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS);
@@ -73,7 +73,7 @@ public class AppListLoader extends AsyncTaskLoader<List<LayoutElement>> {
                 info = null;
             }
 
-            mApps.add(new LayoutElement(new BitmapDrawable(context.getResources(),
+            mApps.add(new LayoutElementParcelable(new BitmapDrawable(context.getResources(),
                     BitmapFactory.decodeResource(context.getResources(), R.drawable.ic_doc_apk_grid)),
                     label == null ? object.packageName : label, object.sourceDir,
                     object.packageName, object.flags + "_" + (info!=null ? info.versionName:""),
@@ -86,7 +86,7 @@ public class AppListLoader extends AsyncTaskLoader<List<LayoutElement>> {
     }
 
     @Override
-    public void deliverResult(List<LayoutElement> data) {
+    public void deliverResult(List<LayoutElementParcelable> data) {
         if (isReset()) {
 
             if (data != null)
@@ -94,7 +94,7 @@ public class AppListLoader extends AsyncTaskLoader<List<LayoutElement>> {
         }
 
         // preserving old data for it to be closed
-        List<LayoutElement> oldData = mApps;
+        List<LayoutElementParcelable> oldData = mApps;
         mApps = data;
         if (isStarted()) {
             // loader has been started, if we have data, return immediately
@@ -132,7 +132,7 @@ public class AppListLoader extends AsyncTaskLoader<List<LayoutElement>> {
     }
 
     @Override
-    public void onCanceled(List<LayoutElement> data) {
+    public void onCanceled(List<LayoutElementParcelable> data) {
         super.onCanceled(data);
 
         onReleaseResources(data);//TODO onReleaseResources() is empty
@@ -166,7 +166,7 @@ public class AppListLoader extends AsyncTaskLoader<List<LayoutElement>> {
      * @param layoutElementList
      */
     //TODO do something
-    private void onReleaseResources(List<LayoutElement> layoutElementList) {
+    private void onReleaseResources(List<LayoutElementParcelable> layoutElementList) {
 
     }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/services/CopyService.java b/app/src/main/java/com/amaze/filemanager/asynchronous/services/CopyService.java
similarity index 75%
rename from app/src/main/java/com/amaze/filemanager/services/CopyService.java
rename to app/src/main/java/com/amaze/filemanager/asynchronous/services/CopyService.java
index fe2f9ab6e..48df12429 100644
--- a/app/src/main/java/com/amaze/filemanager/services/CopyService.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/services/CopyService.java
@@ -18,7 +18,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.services;
+package com.amaze.filemanager.asynchronous.services;
 
 import android.app.NotificationManager;
 import android.app.PendingIntent;
@@ -36,24 +36,28 @@ import android.text.format.Formatter;
 import android.util.Log;
 
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.activities.BaseActivity;
 import com.amaze.filemanager.activities.MainActivity;
+import com.amaze.filemanager.activities.superclasses.ThemedActivity;
+import com.amaze.filemanager.asynchronous.asynctasks.DeleteTask;
 import com.amaze.filemanager.database.CryptHandler;
 import com.amaze.filemanager.database.models.EncryptedEntry;
-import com.amaze.filemanager.exceptions.RootNotPermittedException;
-import com.amaze.filemanager.filesystem.BaseFile;
+import com.amaze.filemanager.exceptions.ShellNotRunningException;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.FileUtil;
-import com.amaze.filemanager.filesystem.HFile;
+import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.Operations;
 import com.amaze.filemanager.filesystem.RootHelper;
+import com.amaze.filemanager.fragments.ProcessViewerFragment;
+import com.amaze.filemanager.utils.OnFileFound;
 import com.amaze.filemanager.utils.files.CryptUtil;
-import com.amaze.filemanager.utils.DataPackage;
-import com.amaze.filemanager.utils.files.Futils;
-import com.amaze.filemanager.utils.files.GenericCopyUtil;
+import com.amaze.filemanager.ui.notifications.NotificationConstants;
+import com.amaze.filemanager.utils.CopyDataParcelable;
 import com.amaze.filemanager.utils.OpenMode;
 import com.amaze.filemanager.utils.ProgressHandler;
 import com.amaze.filemanager.utils.RootUtils;
 import com.amaze.filemanager.utils.ServiceWatcherUtil;
+import com.amaze.filemanager.utils.files.FileUtils;
+import com.amaze.filemanager.utils.files.GenericCopyUtil;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -69,7 +73,7 @@ public class CopyService extends Service {
     public static final String TAG_BROADCAST_COPY_CANCEL = "copycancel";
 
     // list of data packages, to initiate chart in process viewer fragment
-    private ArrayList<DataPackage> dataPackages = new ArrayList<>();
+    private ArrayList<CopyDataParcelable> dataPackages = new ArrayList<>();
     private NotificationManager mNotifyManager;
     private NotificationCompat.Builder mBuilder;
     private Context c;
@@ -93,23 +97,27 @@ public class CopyService extends Service {
     @Override
     public int onStartCommand(Intent intent, int flags, final int startId) {
         Bundle b = new Bundle();
-        ArrayList<BaseFile> files = intent.getParcelableArrayListExtra(TAG_COPY_SOURCES);
+        ArrayList<HybridFileParcelable> files = intent.getParcelableArrayListExtra(TAG_COPY_SOURCES);
         String targetPath = intent.getStringExtra(TAG_COPY_TARGET);
         int mode = intent.getIntExtra(TAG_COPY_OPEN_MODE, OpenMode.UNKNOWN.ordinal());
         final boolean move = intent.getBooleanExtra(TAG_COPY_MOVE, false);
 
         mNotifyManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
         b.putInt(TAG_COPY_START_ID, startId);
+
         Intent notificationIntent = new Intent(this, MainActivity.class);
         notificationIntent.setAction(Intent.ACTION_MAIN);
         notificationIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
         notificationIntent.putExtra(MainActivity.KEY_INTENT_PROCESS_VIEWER, true);
         PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);
-        mBuilder = new NotificationCompat.Builder(c);
-        mBuilder.setContentIntent(pendingIntent);
-        mBuilder.setContentTitle(getResources().getString(R.string.copying))
+
+        mBuilder = new NotificationCompat.Builder(c, NotificationConstants.CHANNEL_NORMAL_ID)
+                .setContentIntent(pendingIntent)
+                .setContentTitle(getResources().getString(R.string.copying))
                 .setSmallIcon(R.drawable.ic_content_copy_white_36dp);
 
+        NotificationConstants.setMetadata(c, mBuilder);
+
         startForeground(Integer.parseInt("456" + startId), mBuilder.build());
 
         b.putBoolean(TAG_COPY_MOVE, move);
@@ -129,7 +137,7 @@ public class CopyService extends Service {
     }
 
     private class DoInBackground extends AsyncTask<Bundle, Void, Integer> {
-        ArrayList<BaseFile> sourceFiles;
+        ArrayList<HybridFileParcelable> sourceFiles;
         boolean move;
         Copy copy;
         private String targetPath;
@@ -142,23 +150,17 @@ public class CopyService extends Service {
 
             // setting up service watchers and initial data packages
             // finding total size on background thread (this is necessary condition for SMB!)
-            totalSize = Futils.getTotalBytes(sourceFiles, c);
+            totalSize = FileUtils.getTotalBytes(sourceFiles, c);
             totalSourceFiles = sourceFiles.size();
             progressHandler = new ProgressHandler(totalSourceFiles, totalSize);
 
-            progressHandler.setProgressListener(new ProgressHandler.ProgressListener() {
-
-                @Override
-                public void onProgressed(String fileName, int sourceFiles, int sourceProgress,
-                                         long totalSize, long writtenSize, int speed) {
-                    publishResults(id, fileName, sourceFiles, sourceProgress, totalSize,
-                            writtenSize, speed, false, move);
-                }
+            progressHandler.setProgressListener((fileName, sourceFiles1, sourceProgress1, totalSize1, writtenSize, speed) -> {
+                publishResults(id, fileName, sourceFiles1, sourceProgress1, totalSize1, writtenSize, speed, false, move);
             });
 
             watcherUtil = new ServiceWatcherUtil(progressHandler, totalSize);
 
-            DataPackage intent1 = new DataPackage();
+            CopyDataParcelable intent1 = new CopyDataParcelable();
             intent1.setName(sourceFiles.get(0).getName());
             intent1.setSourceFiles(sourceFiles.size());
             intent1.setSourceProgress(0);
@@ -178,7 +180,7 @@ public class CopyService extends Service {
             if (copy.failedFOps.size() == 0) {
 
                 // adding/updating new encrypted db entry if any encrypted file was copied/moved
-                for (BaseFile sourceFile : sourceFiles) {
+                for (HybridFileParcelable sourceFile : sourceFiles) {
                     findAndReplaceEncryptedEntry(sourceFile);
                 }
             }
@@ -194,7 +196,8 @@ public class CopyService extends Service {
             watcherUtil.stopWatch();
             generateNotification(copy.failedFOps, move);
 
-            Intent intent = new Intent("loadlist");
+            Intent intent = new Intent(MainActivity.KEY_INTENT_LOAD_LIST);
+            intent.putExtra(MainActivity.KEY_INTENT_LOAD_LIST_FILE, targetPath);
             sendBroadcast(intent);
             stopSelf();
         }
@@ -204,18 +207,19 @@ public class CopyService extends Service {
          * metadata in the database
          * @param sourceFile the file which is to be iterated
          */
-        private void findAndReplaceEncryptedEntry(BaseFile sourceFile) {
+        private void findAndReplaceEncryptedEntry(HybridFileParcelable sourceFile) {
 
             // even directories can end with CRYPT_EXTENSION
             if (sourceFile.isDirectory() && !sourceFile.getName().endsWith(CryptUtil.CRYPT_EXTENSION)) {
+                sourceFile.forEachChildrenFile(getApplicationContext(), ThemedActivity.rootMode, new OnFileFound() {
+                    @Override
+                    public void onFileFound(HybridFileParcelable file) {
+                        // iterating each file inside source files which were copied to find instance of
+                        // any copied / moved encrypted file
 
-                for (BaseFile file : sourceFile.listFiles(getApplicationContext(), BaseActivity.rootMode)) {
-                    // iterating each file inside source files which were copied to find instance of
-                    // any copied / moved encrypted file
-
-                    findAndReplaceEncryptedEntry(file);
-
-                }
+                        findAndReplaceEncryptedEntry(file);
+                    }
+                });
             } else {
 
                 if (sourceFile.getName().endsWith(CryptUtil.CRYPT_EXTENSION)) {
@@ -247,8 +251,8 @@ public class CopyService extends Service {
 
         class Copy {
 
-            ArrayList<HFile> failedFOps;
-            ArrayList<BaseFile> toDelete;
+            ArrayList<HybridFile> failedFOps;
+            ArrayList<HybridFileParcelable> toDelete;
 
             Copy() {
                 failedFOps = new ArrayList<>();
@@ -263,7 +267,7 @@ public class CopyService extends Service {
              * @param move
              * @param mode        target file open mode (current path's open mode)
              */
-            public void execute(final ArrayList<BaseFile> sourceFiles, final String targetPath,
+            public void execute(final ArrayList<HybridFileParcelable> sourceFiles, final String targetPath,
                                 final boolean move, OpenMode mode) {
 
                 // initial start of copy, initiate the watcher
@@ -272,21 +276,20 @@ public class CopyService extends Service {
                 if (FileUtil.checkFolder((targetPath), c) == 1) {
                     for (int i = 0; i < sourceFiles.size(); i++) {
                         sourceProgress = i;
-                        BaseFile f1 = (sourceFiles.get(i));
-                        Log.e("Copy", "basefile\t" + f1.getPath());
+                        HybridFileParcelable f1 = (sourceFiles.get(i));
 
                         try {
 
-                            HFile hFile;
+                            HybridFile hFile;
                             if (targetPath.contains(getExternalCacheDir().getPath())) {
                                 // the target open mode is not the one we're currently in!
                                 // we're processing the file for cache
-                                hFile = new HFile(OpenMode.FILE, targetPath, sourceFiles.get(i).getName(),
+                                hFile = new HybridFile(OpenMode.FILE, targetPath, sourceFiles.get(i).getName(),
                                         f1.isDirectory());
                             } else {
 
                                 // the target open mode is where we're currently at
-                                hFile = new HFile(mode, targetPath, sourceFiles.get(i).getName(),
+                                hFile = new HybridFile(mode, targetPath, sourceFiles.get(i).getName(),
                                         f1.isDirectory());
                             }
 
@@ -294,7 +297,7 @@ public class CopyService extends Service {
 
                                 if (!f1.isSmb()
                                         && (f1.getMode() == OpenMode.ROOT || mode == OpenMode.ROOT)
-                                        && BaseActivity.rootMode) {
+                                        && ThemedActivity.rootMode) {
                                     // either source or target are in root
                                     progressHandler.setSourceFilesProcessed(++sourceProgress);
                                     copyRoot(f1, hFile, move);
@@ -307,7 +310,7 @@ public class CopyService extends Service {
                             }
                         } catch (Exception e) {
                             e.printStackTrace();
-                            Log.e("Copy", "Got exception checkout");
+                            Log.e("CopyService", "Got exception checkout: " + f1.getPath());
 
                             failedFOps.add(sourceFiles.get(i));
                             for (int j = i + 1; j < sourceFiles.size(); j++)
@@ -316,17 +319,17 @@ public class CopyService extends Service {
                         }
                     }
 
-                } else if (BaseActivity.rootMode) {
+                } else if (ThemedActivity.rootMode) {
                     for (int i = 0; i < sourceFiles.size(); i++) {
                         if (!progressHandler.getCancelled()) {
 
-                            HFile hFile = new HFile(mode, targetPath, sourceFiles.get(i).getName(),
+                            HybridFile hFile = new HybridFile(mode, targetPath, sourceFiles.get(i).getName(),
                                     sourceFiles.get(i).isDirectory());
                             progressHandler.setSourceFilesProcessed(++sourceProgress);
                             progressHandler.setFileName(sourceFiles.get(i).getName());
                             copyRoot(sourceFiles.get(i), hFile, move);
-                            /*if(checkFiles(new HFile(sourceFiles.get(i).getMode(),path),
-                            new HFile(OpenMode.ROOT,targetPath+"/"+name))){
+                            /*if(checkFiles(new HybridFile(sourceFiles.get(i).getMode(),path),
+                            new HybridFile(OpenMode.ROOT,targetPath+"/"+name))){
                                 failedFOps.add(sourceFiles.get(i));
                             }*/
                         }
@@ -334,15 +337,15 @@ public class CopyService extends Service {
 
 
                 } else {
-                    for (BaseFile f : sourceFiles) failedFOps.add(f);
+                    for (HybridFileParcelable f : sourceFiles) failedFOps.add(f);
                     return;
                 }
 
                 // making sure to delete files after copy operation is done
                 // and not if the copy was cancelled
                 if (move && !progressHandler.getCancelled()) {
-                    ArrayList<BaseFile> toDelete = new ArrayList<>();
-                    for (BaseFile a : sourceFiles) {
+                    ArrayList<HybridFileParcelable> toDelete = new ArrayList<>();
+                    for (HybridFileParcelable a : sourceFiles) {
                         if (!failedFOps.contains(a))
                             toDelete.add(a);
                     }
@@ -350,21 +353,21 @@ public class CopyService extends Service {
                 }
             }
 
-            void copyRoot(BaseFile sourceFile, HFile targetFile, boolean move) {
+            void copyRoot(HybridFileParcelable sourceFile, HybridFile targetFile, boolean move) {
 
                 try {
                     if (!move) RootUtils.copy(sourceFile.getPath(), targetFile.getPath());
                     else if (move) RootUtils.move(sourceFile.getPath(), targetFile.getPath());
                     ServiceWatcherUtil.POSITION += sourceFile.getSize();
-                } catch (RootNotPermittedException e) {
+                } catch (ShellNotRunningException e) {
                     failedFOps.add(sourceFile);
                     e.printStackTrace();
                 }
-                Futils.scanFile(targetFile.getPath(), c);
+                FileUtils.scanFile(targetFile.getPath(), c);
             }
 
-            private void copyFiles(final BaseFile sourceFile, final HFile targetFile,
-                                   ProgressHandler progressHandler) throws IOException {
+            private void copyFiles(final HybridFileParcelable sourceFile, final HybridFile targetFile,
+                                   final ProgressHandler progressHandler) throws IOException {
 
                 if (sourceFile.isDirectory()) {
                     if (progressHandler.getCancelled()) return;
@@ -382,12 +385,18 @@ public class CopyService extends Service {
                     targetFile.setLastModified(sourceFile.lastModified());
 
                     if(progressHandler.getCancelled()) return;
-                    ArrayList<BaseFile> filePaths = sourceFile.listFiles(c, false);
-                    for (BaseFile file : filePaths) {
-                        HFile destFile = new HFile(targetFile.getMode(), targetFile.getPath(),
-                                file.getName(), file.isDirectory());
-                        copyFiles(file, destFile, progressHandler);
-                    }
+                    sourceFile.forEachChildrenFile(c, false, new OnFileFound() {
+                        @Override
+                        public void onFileFound(HybridFileParcelable file) {
+                            HybridFile destFile = new HybridFile(targetFile.getMode(), targetFile.getPath(),
+                                    file.getName(), file.isDirectory());
+                            try {
+                                copyFiles(file, destFile, progressHandler);
+                            } catch (IOException e) {
+                                throw new IllegalStateException(e);//throw unchecked exception, no throws needed
+                            }
+                        }
+                    });
                 } else {
                     if (progressHandler.getCancelled()) return;
                     if (!Operations.isFileNameValid(sourceFile.getName())) {
@@ -411,17 +420,18 @@ public class CopyService extends Service {
      * @param failedOps
      * @param move
      */
-    void generateNotification(ArrayList<HFile> failedOps, boolean move) {
+    void generateNotification(ArrayList<HybridFile> failedOps, boolean move) {
 
         mNotifyManager.cancelAll();
 
         if(failedOps.size()==0) return;
 
-        NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(c);
-        mBuilder.setContentTitle(c.getString(R.string.operationunsuccesful));
-        mBuilder.setContentText(c.getString(R.string.copy_error).replace("%s",
-                move ? c.getString(R.string.moved) : c.getString(R.string.copied)));
-        mBuilder.setAutoCancel(true);
+        String error = move? c.getString(R.string.moved):c.getString(R.string.copied);
+
+        NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(c, NotificationConstants.CHANNEL_NORMAL_ID)
+            .setContentTitle(c.getString(R.string.operationunsuccesful))
+            .setContentText(c.getString(R.string.copy_error, error))
+            .setAutoCancel(true);
 
         progressHandler.setCancelled(true);
 
@@ -444,8 +454,8 @@ public class CopyService extends Service {
     }
 
     /**
-     * Publish the results of the progress to notification and {@link DataPackage}
-     * and eventually to {@link com.amaze.filemanager.fragments.ProcessViewer}
+     * Publish the results of the progress to notification and {@link CopyDataParcelable}
+     * and eventually to {@link ProcessViewerFragment}
      *
      * @param id             id of current service
      * @param fileName       file name of current file being copied
@@ -492,7 +502,7 @@ public class CopyService extends Service {
             }
 
             //for processviewer
-            DataPackage intent = new DataPackage();
+            CopyDataParcelable intent = new CopyDataParcelable();
             intent.setName(fileName);
             intent.setSourceFiles(sourceFiles);
             intent.setSourceProgress(sourceProgress);
@@ -520,35 +530,35 @@ public class CopyService extends Service {
     //check if copy is successful
     // avoid using the method as there is no way to know when we would be returning from command callbacks
     // rather confirm from the command result itself, inside it's callback
-    boolean checkFiles(HFile hFile1, HFile hFile2) throws RootNotPermittedException {
-        if (RootHelper.isDirectory(hFile1.getPath(), BaseActivity.rootMode, 5)) {
+    boolean checkFiles(HybridFile hFile1, HybridFile hFile2) throws ShellNotRunningException {
+        if (RootHelper.isDirectory(hFile1.getPath(), ThemedActivity.rootMode, 5)) {
             if (RootHelper.fileExists(hFile2.getPath())) return false;
-            ArrayList<BaseFile> baseFiles = RootHelper.getFilesList(hFile1.getPath(), true, true, null);
+            ArrayList<HybridFileParcelable> baseFiles = RootHelper.getFilesList(hFile1.getPath(), true, true, null);
             if (baseFiles.size() > 0) {
                 boolean b = true;
-                for (BaseFile baseFile : baseFiles) {
-                    if (!checkFiles(new HFile(baseFile.getMode(), baseFile.getPath()),
-                            new HFile(hFile2.getMode(), hFile2.getPath() + "/" + (baseFile.getName()))))
+                for (HybridFileParcelable baseFile : baseFiles) {
+                    if (!checkFiles(new HybridFile(baseFile.getMode(), baseFile.getPath()),
+                            new HybridFile(hFile2.getMode(), hFile2.getPath() + "/" + (baseFile.getName()))))
                         b = false;
                 }
                 return b;
             }
             return RootHelper.fileExists(hFile2.getPath());
         } else {
-            ArrayList<BaseFile> baseFiles = RootHelper.getFilesList(hFile1.getParent(), true, true, null);
+            ArrayList<HybridFileParcelable> baseFiles = RootHelper.getFilesList(hFile1.getParent(), true, true, null);
             int i = -1;
             int index = -1;
-            for (BaseFile b : baseFiles) {
+            for (HybridFileParcelable b : baseFiles) {
                 i++;
                 if (b.getPath().equals(hFile1.getPath())) {
                     index = i;
                     break;
                 }
             }
-            ArrayList<BaseFile> baseFiles1 = RootHelper.getFilesList(hFile1.getParent(), true, true, null);
+            ArrayList<HybridFileParcelable> baseFiles1 = RootHelper.getFilesList(hFile1.getParent(), true, true, null);
             int i1 = -1;
             int index1 = -1;
-            for (BaseFile b : baseFiles1) {
+            for (HybridFileParcelable b : baseFiles1) {
                 i1++;
                 if (b.getPath().equals(hFile1.getPath())) {
                     index1 = i1;
@@ -582,7 +592,7 @@ public class CopyService extends Service {
     }
 
     public interface ProgressListener {
-        void onUpdate(DataPackage dataPackage);
+        void onUpdate(CopyDataParcelable dataPackage);
 
         void refresh();
     }
@@ -593,14 +603,14 @@ public class CopyService extends Service {
 
     /**
      * Returns the {@link #dataPackages} list which contains
-     * data to be transferred to {@link com.amaze.filemanager.fragments.ProcessViewer}
+     * data to be transferred to {@link ProcessViewerFragment}
      * Method call is synchronized so as to avoid modifying the list
      * by {@link ServiceWatcherUtil#handlerThread} while {@link MainActivity#runOnUiThread(Runnable)}
-     * is executing the callbacks in {@link com.amaze.filemanager.fragments.ProcessViewer}
+     * is executing the callbacks in {@link ProcessViewerFragment}
      *
      * @return
      */
-    public synchronized DataPackage getDataPackage(int index) {
+    public synchronized CopyDataParcelable getDataPackage(int index) {
         return this.dataPackages.get(index);
     }
 
@@ -609,14 +619,14 @@ public class CopyService extends Service {
     }
 
     /**
-     * Puts a {@link DataPackage} into a list
+     * Puts a {@link CopyDataParcelable} into a list
      * Method call is synchronized so as to avoid modifying the list
      * by {@link ServiceWatcherUtil#handlerThread} while {@link MainActivity#runOnUiThread(Runnable)}
-     * is executing the callbacks in {@link com.amaze.filemanager.fragments.ProcessViewer}
+     * is executing the callbacks in {@link ProcessViewerFragment}
      *
      * @param dataPackage
      */
-    private synchronized void putDataPackage(DataPackage dataPackage) {
+    private synchronized void putDataPackage(CopyDataParcelable dataPackage) {
         this.dataPackages.add(dataPackage);
     }
 
diff --git a/app/src/main/java/com/amaze/filemanager/services/EncryptService.java b/app/src/main/java/com/amaze/filemanager/asynchronous/services/EncryptService.java
similarity index 81%
rename from app/src/main/java/com/amaze/filemanager/services/EncryptService.java
rename to app/src/main/java/com/amaze/filemanager/asynchronous/services/EncryptService.java
index a33845bc2..02180fd2a 100644
--- a/app/src/main/java/com/amaze/filemanager/services/EncryptService.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/services/EncryptService.java
@@ -1,4 +1,4 @@
-package com.amaze.filemanager.services;
+package com.amaze.filemanager.asynchronous.services;
 
 import android.app.NotificationManager;
 import android.app.PendingIntent;
@@ -15,14 +15,17 @@ import android.text.format.Formatter;
 
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.MainActivity;
-import com.amaze.filemanager.filesystem.BaseFile;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.FileUtil;
-import com.amaze.filemanager.filesystem.HFile;
+import com.amaze.filemanager.filesystem.HybridFile;
+import com.amaze.filemanager.fragments.ProcessViewerFragment;
+import com.amaze.filemanager.ui.notifications.NotificationConstants;
 import com.amaze.filemanager.utils.files.CryptUtil;
-import com.amaze.filemanager.utils.DataPackage;
+import com.amaze.filemanager.utils.CopyDataParcelable;
 import com.amaze.filemanager.utils.OpenMode;
 import com.amaze.filemanager.utils.ProgressHandler;
 import com.amaze.filemanager.utils.ServiceWatcherUtil;
+import com.amaze.filemanager.utils.files.EncryptDecryptUtils;
 
 import java.util.ArrayList;
 
@@ -37,13 +40,14 @@ public class EncryptService extends Service {
     public static final String TAG_OPEN_MODE = "open_mode";
     public static final String TAG_CRYPT_MODE = "crypt_mode";   // ordinal of type of service
                                                                 // expected (encryption or decryption)
+    public static final String TAG_BROADCAST_RESULT = "broadcast_result";
 
     private static final int ID_NOTIFICATION = 27978;
 
     public static final String TAG_BROADCAST_CRYPT_CANCEL = "crypt_cancel";
 
     // list of data packages which contains progress
-    private ArrayList<DataPackage> dataPackages = new ArrayList<>();
+    private ArrayList<CopyDataParcelable> dataPackages = new ArrayList<>();
     private NotificationManager notificationManager;
     private NotificationCompat.Builder notificationBuilder;
     private Context context;
@@ -53,10 +57,11 @@ public class EncryptService extends Service {
     private long totalSize = 0l;
     private OpenMode openMode;
     private String decryptPath;
-    private BaseFile baseFile;
+    private HybridFileParcelable baseFile;
     private CryptEnum cryptEnum;
-    private ArrayList<HFile> failedOps = new ArrayList<>();
+    private ArrayList<HybridFile> failedOps = new ArrayList<>();
     private ProgressListener progressListener;
+    private boolean broadcastResult = false;
 
     @Override
     public void onCreate() {
@@ -71,6 +76,7 @@ public class EncryptService extends Service {
 
         baseFile = intent.getParcelableExtra(TAG_SOURCE);
         cryptEnum = CryptEnum.values()[intent.getIntExtra(TAG_CRYPT_MODE, CryptEnum.ENCRYPT.ordinal())];
+        broadcastResult = intent.getBooleanExtra(TAG_BROADCAST_RESULT, false);
 
         openMode = OpenMode.values()[intent.getIntExtra(TAG_OPEN_MODE, OpenMode.UNKNOWN.ordinal())];
         notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
@@ -79,7 +85,7 @@ public class EncryptService extends Service {
         notificationIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
         notificationIntent.putExtra(MainActivity.KEY_INTENT_PROCESS_VIEWER, true);
         PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);
-        notificationBuilder = new NotificationCompat.Builder(this);
+        notificationBuilder = new NotificationCompat.Builder(this, NotificationConstants.CHANNEL_NORMAL_ID);
         notificationBuilder.setContentIntent(pendingIntent);
 
         if (cryptEnum == CryptEnum.ENCRYPT) {
@@ -94,6 +100,8 @@ public class EncryptService extends Service {
             notificationBuilder.setSmallIcon(R.drawable.ic_folder_lock_open_white_36dp);
         }
 
+        NotificationConstants.setMetadata(getApplicationContext(), notificationBuilder);
+
         startForeground(ID_NOTIFICATION, notificationBuilder.build());
 
         new BackgroundTask().execute();
@@ -111,17 +119,10 @@ public class EncryptService extends Service {
             else totalSize = baseFile.length(context);
 
             progressHandler = new ProgressHandler(1, totalSize);
-            progressHandler.setProgressListener(new ProgressHandler.ProgressListener() {
-                @Override
-                public void onProgressed(String fileName, int sourceFiles, int sourceProgress,
-                                         long totalSize, long writtenSize, int speed) {
-
-                    publishResults(fileName, sourceFiles, sourceProgress, totalSize, writtenSize, speed);
-                }
-            });
+            progressHandler.setProgressListener(EncryptService.this::publishResults);
             serviceWatcherUtil = new ServiceWatcherUtil(progressHandler, totalSize);
 
-            DataPackage dataPackage = new DataPackage();
+            CopyDataParcelable dataPackage = new CopyDataParcelable();
             dataPackage.setName(baseFile.getName());
             dataPackage.setSourceFiles(1);
             dataPackage.setSourceProgress(1);
@@ -167,8 +168,16 @@ public class EncryptService extends Service {
 
             serviceWatcherUtil.stopWatch();
             generateNotification(failedOps, cryptEnum==CryptEnum.ENCRYPT ? false : true);
-            Intent intent = new Intent("loadlist");
-            sendBroadcast(intent);
+
+            if (!broadcastResult) {
+
+                Intent intent = new Intent(MainActivity.KEY_INTENT_LOAD_LIST);
+                intent.putExtra(MainActivity.KEY_INTENT_LOAD_LIST_FILE, decryptPath);
+                sendBroadcast(intent);
+            } else {
+                Intent intent = new Intent(EncryptDecryptUtils.DECRYPT_BROADCAST);
+                sendBroadcast(intent);
+            }
             stopSelf();
         }
     }
@@ -200,7 +209,7 @@ public class EncryptService extends Service {
             }
 
             //for processviewer
-            DataPackage intent = new DataPackage();
+            CopyDataParcelable intent = new CopyDataParcelable();
             intent.setName(fileName);
             intent.setSourceFiles(sourceFiles);
             intent.setSourceProgress(sourceProgress);
@@ -249,17 +258,19 @@ public class EncryptService extends Service {
      * @param failedOps
      * @param move
      */
-    void generateNotification(ArrayList<HFile> failedOps, boolean move) {
+    void generateNotification(ArrayList<HybridFile> failedOps, boolean move) {
         notificationManager.cancelAll();
 
         if(failedOps.size()==0)return;
 
-        NotificationCompat.Builder mBuilder=new NotificationCompat.Builder(context);
-        mBuilder.setContentTitle(context.getString(R.string.operationunsuccesful));
-        mBuilder.setContentText(context.getString(R.string.copy_error).replace("%s",
-                move ? context.getString(R.string.crypt_encrypted).toLowerCase() :
-                        context.getString(R.string.crypt_decrypted).toLowerCase()));
-        mBuilder.setAutoCancel(true);
+        String error = move ? context.getString(R.string.crypt_encrypted).toLowerCase():context.getString(R.string.crypt_decrypted).toLowerCase();
+
+        NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(context, NotificationConstants.CHANNEL_NORMAL_ID)
+            .setContentTitle(context.getString(R.string.operationunsuccesful))
+            .setContentText(context.getString(R.string.copy_error, error))
+            .setAutoCancel(true);
+
+        NotificationConstants.setMetadata(context, mBuilder);
 
         progressHandler.setCancelled(true);
 
@@ -301,7 +312,7 @@ public class EncryptService extends Service {
 
 
     public interface ProgressListener {
-        void onUpdate(DataPackage dataPackage);
+        void onUpdate(CopyDataParcelable dataPackage);
         void refresh();
     }
 
@@ -311,13 +322,13 @@ public class EncryptService extends Service {
 
     /**
      * Returns the {@link #dataPackages} list which contains
-     * data to be transferred to {@link com.amaze.filemanager.fragments.ProcessViewer}
+     * data to be transferred to {@link ProcessViewerFragment}
      * Method call is synchronized so as to avoid modifying the list
      * by {@link ServiceWatcherUtil#handlerThread} while {@link MainActivity#runOnUiThread(Runnable)}
-     * is executing the callbacks in {@link com.amaze.filemanager.fragments.ProcessViewer}
+     * is executing the callbacks in {@link ProcessViewerFragment}
      * @return
      */
-    public synchronized DataPackage getDataPackage(int index) {
+    public synchronized CopyDataParcelable getDataPackage(int index) {
         return this.dataPackages.get(index);
     }
 
@@ -326,13 +337,13 @@ public class EncryptService extends Service {
     }
 
     /**
-     * Puts a {@link DataPackage} into a list
+     * Puts a {@link CopyDataParcelable} into a list
      * Method call is synchronized so as to avoid modifying the list
      * by {@link ServiceWatcherUtil#handlerThread} while {@link MainActivity#runOnUiThread(Runnable)}
-     * is executing the callbacks in {@link com.amaze.filemanager.fragments.ProcessViewer}
+     * is executing the callbacks in {@link ProcessViewerFragment}
      * @param dataPackage
      */
-    private synchronized void putDataPackage(DataPackage dataPackage) {
+    private synchronized void putDataPackage(CopyDataParcelable dataPackage) {
         this.dataPackages.add(dataPackage);
     }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/services/ExtractService.java b/app/src/main/java/com/amaze/filemanager/asynchronous/services/ExtractService.java
new file mode 100644
index 000000000..4a04ff58e
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/services/ExtractService.java
@@ -0,0 +1,649 @@
+/*
+ * Copyright (C) 2014 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.asynchronous.services;
+
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.app.Service;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.AsyncTask;
+import android.os.Binder;
+import android.os.IBinder;
+import android.support.annotation.NonNull;
+import android.support.v4.app.NotificationCompat;
+import android.text.format.Formatter;
+import android.util.Log;
+
+import com.amaze.filemanager.R;
+import com.amaze.filemanager.activities.MainActivity;
+import com.amaze.filemanager.filesystem.FileUtil;
+import com.amaze.filemanager.fragments.ProcessViewerFragment;
+import com.amaze.filemanager.ui.notifications.NotificationConstants;
+import com.amaze.filemanager.utils.CopyDataParcelable;
+import com.amaze.filemanager.utils.ProgressHandler;
+import com.amaze.filemanager.utils.ServiceWatcherUtil;
+import com.amaze.filemanager.utils.application.AppConfig;
+import com.amaze.filemanager.utils.files.GenericCopyUtil;
+import com.github.junrar.Archive;
+import com.github.junrar.exception.RarException;
+import com.github.junrar.rarfile.FileHeader;
+
+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
+import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.Enumeration;
+import java.util.zip.GZIPInputStream;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+public class ExtractService extends Service {
+
+    Context context;
+
+    // list of data packages,// to initiate chart in process viewer fragment
+    private ArrayList<CopyDataParcelable> dataPackages = new ArrayList<>();
+
+    private NotificationManager mNotifyManager;
+    private NotificationCompat.Builder mBuilder;
+    private ProgressHandler progressHandler;
+
+    public static final String KEY_PATH_ZIP = "zip";
+    public static final String KEY_ENTRIES_ZIP = "entries";
+    public static final String TAG_BROADCAST_EXTRACT_CANCEL = "excancel";
+    public static final String KEY_PATH_EXTRACT = "extractpath";
+
+    @Override
+    public void onCreate() {
+        registerReceiver(receiver1, new IntentFilter(TAG_BROADCAST_EXTRACT_CANCEL));
+        context = getApplicationContext();
+    }
+
+    @Override
+    public int onStartCommand(Intent intent, int flags, final int startId) {
+        String file = intent.getStringExtra(KEY_PATH_ZIP);
+        String extractPath = intent.getStringExtra(KEY_PATH_EXTRACT);
+        String[] entries = intent.getStringArrayExtra(KEY_ENTRIES_ZIP);
+
+        mNotifyManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
+
+        long totalSize = getTotalSize(file);
+        progressHandler = new ProgressHandler(1, totalSize);
+
+        progressHandler.setProgressListener((fileName, sourceFiles, sourceProgress, totalSize1, writtenSize, speed) -> {
+            publishResults(startId, fileName, sourceFiles, sourceProgress, totalSize1, writtenSize, speed, false);
+        });
+
+        Intent notificationIntent = new Intent(this, MainActivity.class);
+        notificationIntent.setAction(Intent.ACTION_MAIN);
+        notificationIntent.putExtra(MainActivity.KEY_INTENT_PROCESS_VIEWER, true);
+        PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);
+
+        mBuilder = new NotificationCompat.Builder(context, NotificationConstants.CHANNEL_NORMAL_ID);
+        mBuilder.setContentIntent(pendingIntent);
+        mBuilder.setContentTitle(getResources().getString(R.string.extracting))
+                .setContentText(new File(file).getName())
+                .setSmallIcon(R.drawable.ic_zip_box_grey600_36dp);
+        NotificationConstants.setMetadata(getApplicationContext(), mBuilder);
+        startForeground(Integer.parseInt("123" + startId), mBuilder.build());
+
+        new DoWork(this, progressHandler, file, extractPath, entries).execute();
+        return START_STICKY;
+    }
+
+    /**
+     * Method calculates zip file size to initiate progress
+     * Supporting local file extraction progress for now
+     *
+     * @param filePath
+     * @return
+     */
+    private long getTotalSize(String filePath) {
+
+        return new File(filePath).length();
+    }
+
+    private final IBinder mBinder = new LocalBinder();
+
+    public class LocalBinder extends Binder {
+        public ExtractService getService() {
+            // Return this instance of LocalService so clients can call public methods
+            return ExtractService.this;
+        }
+    }
+
+    public void setProgressListener(ProgressListener progressListener) {
+        this.progressListener = progressListener;
+    }
+
+    ProgressListener progressListener;
+
+    public interface ProgressListener {
+        void onUpdate(CopyDataParcelable dataPackage);
+
+        void refresh();
+    }
+
+    private void publishResults(int id, String fileName, int sourceFiles, int sourceProgress,
+                                long total, long done, int speed, boolean isCompleted) {
+        if (!progressHandler.getCancelled()) {
+            mBuilder.setContentTitle(getResources().getString(R.string.extracting));
+            float progressPercent = ((float) done / total) * 100;
+            mBuilder.setProgress(100, Math.round(progressPercent), false);
+            mBuilder.setOngoing(true);
+            mBuilder.setContentText(fileName + " " + Formatter.formatFileSize(context, done) + "/"
+                    + Formatter.formatFileSize(context, total));
+            int id1 = Integer.parseInt("123" + id);
+            mNotifyManager.notify(id1, mBuilder.build());
+            if (progressPercent == 100 || total == 0) {
+                mBuilder.setContentTitle(getString(R.string.extract_complete));
+                mBuilder.setContentText(fileName + " " + Formatter.formatFileSize(context, total));
+                mBuilder.setProgress(100, 100, false);
+                mBuilder.setOngoing(false);
+                mNotifyManager.notify(id1, mBuilder.build());
+                publishCompletedResult("", id1);
+            }
+
+            CopyDataParcelable intent = new CopyDataParcelable();
+            intent.setName(fileName);
+            intent.setSourceFiles(sourceFiles);
+            intent.setSourceProgress(sourceProgress);
+            intent.setTotal(total);
+            intent.setByteProgress(done);
+            intent.setSpeedRaw(speed);
+            intent.setMove(false);
+            intent.setCompleted(isCompleted);
+            putDataPackage(intent);
+
+            if (progressListener != null) {
+                progressListener.onUpdate(intent);
+                if (isCompleted) progressListener.refresh();
+            }
+        } else publishCompletedResult(fileName, Integer.parseInt("123" + id));
+    }
+
+    public void publishCompletedResult(String a, int id1) {
+        try {
+            mNotifyManager.cancel(id1);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static class DoWork extends AsyncTask<Void, Void, Void> {
+
+        private WeakReference<ExtractService> extractService;
+        private String[] entriesToExtract;
+        private String extractionPath, compressedPath;
+        private ProgressHandler progressHandler;
+        private long totalBytes = 0L;
+        private ServiceWatcherUtil watcherUtil;
+
+
+        private DoWork(ExtractService extractService, ProgressHandler progressHandler, String cpath, String epath,
+                       String[] entries) {
+            this.extractService = new WeakReference<>(extractService);
+            this.progressHandler = progressHandler;
+            compressedPath = cpath;
+            extractionPath = epath;
+            entriesToExtract = entries;
+        }
+
+        @Override
+        protected Void doInBackground(Void... p) {
+            final Context context = this.extractService.get();
+            if(context == null) return null;
+
+            File f = new File(compressedPath);
+
+            if (!compressedPath.equals(extractionPath)) {// custom extraction path not set, extract at default path
+                extractionPath = f.getParent() + "/" + f.getName().substring(0, f.getName().lastIndexOf("."));
+            } else if (extractionPath.endsWith("/")) {
+                extractionPath = extractionPath + f.getName().substring(0, f.getName().lastIndexOf("."));
+            }
+
+            try {
+                String path = f.getPath().toLowerCase();
+                boolean isZip = path.endsWith(".zip") || path.endsWith(".jar") || path.endsWith(".apk");
+                boolean isTar = path.endsWith(".tar") || path.endsWith(".tar.gz");
+                boolean isRar = path.endsWith(".rar");
+
+                if (entriesToExtract != null && entriesToExtract.length != 0) {
+                    if (isZip) extract(context, f, extractionPath, entriesToExtract);
+                    else if (isRar) extractRar(context, f, extractionPath, entriesToExtract);
+                } else {
+                    if (isZip) extract(context, f, extractionPath);
+                    else if (isRar) extractRar(context, f, extractionPath);
+                    else if (isTar) extractTar(context, f, extractionPath);
+                }
+            } catch (IOException | RarException e) {
+                Log.e("amaze", "Error while extracting file " + compressedPath, e);
+                AppConfig.toast(context, context.getString(R.string.error));
+            }
+            return null;
+        }
+
+        /**
+         * Method extracts {@link ZipEntry} from {@link ZipFile}
+         *
+         * @param zipFile   zip file from which entriesToExtract are to be extracted
+         * @param entry     zip entry that is to be extracted
+         * @param outputDir output directory
+         */
+        private void unzipEntry(@NonNull final Context context, ZipFile zipFile, ZipEntry entry, String outputDir)
+                throws IOException {
+
+            if (entry.isDirectory()) {
+                // zip entry is a directory, return after creating new directory
+                FileUtil.mkdir(new File(outputDir, entry.getName()), context);
+                return;
+            }
+
+            final File outputFile = new File(outputDir, entry.getName());
+
+            if (!outputFile.getParentFile().exists()) {
+                // creating directory if not already exists
+
+                FileUtil.mkdir(outputFile.getParentFile(), context);
+            }
+
+            BufferedInputStream inputStream = new BufferedInputStream(
+                    zipFile.getInputStream(entry));
+            BufferedOutputStream outputStream = new BufferedOutputStream(
+                    FileUtil.getOutputStream(outputFile, context, 0));
+            try {
+                int len;
+                byte buf[] = new byte[GenericCopyUtil.DEFAULT_BUFFER_SIZE];
+                while ((len = inputStream.read(buf)) > 0) {
+
+                    outputStream.write(buf, 0, len);
+                    ServiceWatcherUtil.POSITION += len;
+                }
+            } finally {
+                outputStream.close();
+                inputStream.close();
+            }
+        }
+
+        private void unzipRAREntry(@NonNull final Context context, Archive zipFile, FileHeader entry, String outputDir)
+                throws RarException, IOException {
+            String name = entry.getFileNameString();
+            name = name.replaceAll("\\\\", "/");
+            if (entry.isDirectory()) {
+                FileUtil.mkdir(new File(outputDir, name), context);
+                return;
+            }
+            File outputFile = new File(outputDir, name);
+            if (!outputFile.getParentFile().exists()) {
+                FileUtil.mkdir(outputFile.getParentFile(), context);
+            }
+            //	Log.i("Amaze", "Extracting: " + entry);
+            BufferedInputStream inputStream = new BufferedInputStream(
+                    zipFile.getInputStream(entry));
+            BufferedOutputStream outputStream = new BufferedOutputStream(
+                    FileUtil.getOutputStream(outputFile, context, entry.getFullUnpackSize()));
+            try {
+                int len;
+                byte buf[] = new byte[GenericCopyUtil.DEFAULT_BUFFER_SIZE];
+                while ((len = inputStream.read(buf)) > 0) {
+
+                    outputStream.write(buf, 0, len);
+                    ServiceWatcherUtil.POSITION += len;
+                }
+            } finally {
+                outputStream.close();
+                inputStream.close();
+            }
+        }
+
+        private void unzipTAREntry(@NonNull final Context context, TarArchiveInputStream zipFileStream, TarArchiveEntry entry,
+                                   String outputDir) throws IOException {
+            String name = entry.getName();
+            if (entry.isDirectory()) {
+                FileUtil.mkdir(new File(outputDir, name), context);
+                return;
+            }
+            File outputFile = new File(outputDir, name);
+            if (!outputFile.getParentFile().exists()) {
+                FileUtil.mkdir(outputFile.getParentFile(), context);
+            }
+
+            BufferedOutputStream outputStream = new BufferedOutputStream(
+                    FileUtil.getOutputStream(outputFile, context, entry.getRealSize()));
+            try {
+                int len;
+                byte buf[] = new byte[GenericCopyUtil.DEFAULT_BUFFER_SIZE];
+                while ((len = zipFileStream.read(buf)) > 0) {
+
+                    outputStream.write(buf, 0, len);
+                    ServiceWatcherUtil.POSITION += len;
+                }
+            } finally {
+                outputStream.close();
+            }
+        }
+
+        /**
+         * Helper method to initiate extraction of zip/jar files.
+         *
+         * @param archive         the file pointing to archive
+         * @param destinationPath the where to extract
+         * @param entryNamesList  names of files to be extracted from the archive
+         * @return
+         */
+        private void extract(@NonNull final Context context, File archive, String destinationPath,
+                                String[] entryNamesList) throws IOException {
+
+            ArrayList<ZipEntry> entry1 = new ArrayList<>();
+            ZipFile zipfile = new ZipFile(archive);
+
+            // iterating archive elements to find file names that are to be extracted
+            for (Enumeration e = zipfile.entries(); e.hasMoreElements(); ) {
+
+                ZipEntry zipEntry = (ZipEntry) e.nextElement();
+
+                for (String entry : entryNamesList) {
+
+                    if (zipEntry.getName().contains(entry)) {
+                        // header to be extracted is atleast the entry path (may be more, when it is a directory)
+                        entry1.add(zipEntry);
+                    }
+                }
+            }
+
+            // get the total size of elements to be extracted
+            for (ZipEntry entry : entry1) {
+                totalBytes += entry.getSize();
+            }
+
+            // setting total bytes calculated from zip entries
+            progressHandler.setTotalSize(totalBytes);
+
+            setInitDataPackage(totalBytes, entry1.get(0).getName(), entryNamesList.length);
+
+            watcherUtil = new ServiceWatcherUtil(progressHandler, totalBytes);
+            watcherUtil.watch();
+
+            int i = 0;
+            for (ZipEntry entry : entry1) {
+                if (!progressHandler.getCancelled()) {
+
+                    progressHandler.setFileName(entry.getName());
+                    unzipEntry(context, zipfile, entry, destinationPath);
+                    progressHandler.setSourceFilesProcessed(++i);
+                }
+            }
+        }
+
+        private void extract(@NonNull final Context context, File archive, String destinationPath) throws IOException {
+            ArrayList<ZipEntry> arrayList = new ArrayList<>();
+            ZipFile zipfile = new ZipFile(archive);
+            for (Enumeration e = zipfile.entries(); e.hasMoreElements(); ) {
+
+                // adding all the elements to be extracted to an array list
+                ZipEntry entry = (ZipEntry) e.nextElement();
+                arrayList.add(entry);
+            }
+
+            for (ZipEntry entry : arrayList) {
+                // calculating size of compressed items
+                totalBytes += entry.getSize();
+            }
+
+            // setting total bytes calculated from zip entries
+            progressHandler.setTotalSize(totalBytes);
+
+            setInitDataPackage(totalBytes, arrayList.get(0).getName(), 1);
+
+            watcherUtil = new ServiceWatcherUtil(progressHandler, totalBytes);
+            watcherUtil.watch();
+
+            for (ZipEntry entry : arrayList) {
+                if (!progressHandler.getCancelled()) {
+
+                    progressHandler.setFileName(entry.getName());
+                    unzipEntry(context, zipfile, entry, destinationPath);
+                }
+            }
+            progressHandler.setSourceFilesProcessed(1);
+        }
+
+        private void extractTar(@NonNull final Context context, File archive, String destinationPath) throws IOException {
+            ArrayList<TarArchiveEntry> archiveEntries = new ArrayList<>();
+
+            TarArchiveInputStream inputStream = createTarInputStream(archive);
+
+            TarArchiveEntry tarArchiveEntry = inputStream.getNextTarEntry();
+
+            while (tarArchiveEntry != null) {
+                archiveEntries.add(tarArchiveEntry);
+                tarArchiveEntry = inputStream.getNextTarEntry();
+            }
+
+            for (TarArchiveEntry entry : archiveEntries) {
+                totalBytes += entry.getSize();
+            }
+
+            // setting total bytes calculated from zip entries
+            progressHandler.setTotalSize(totalBytes);
+
+            setInitDataPackage(totalBytes, archiveEntries.get(0).getName(), 1);
+
+            watcherUtil = new ServiceWatcherUtil(progressHandler, totalBytes);
+            watcherUtil.watch();
+
+            inputStream = createTarInputStream(archive);
+
+            for (TarArchiveEntry entry : archiveEntries) {
+
+                if (!progressHandler.getCancelled()) {
+
+                    inputStream.getNextTarEntry();
+                    progressHandler.setFileName(entry.getName());
+                    unzipTAREntry(context, inputStream, entry, destinationPath);
+                }
+            }
+            progressHandler.setSourceFilesProcessed(1);
+
+            // operating finished
+            inputStream.close();
+        }
+
+        private TarArchiveInputStream createTarInputStream(File archive) throws IOException {
+            if (archive.getName().endsWith(".tar")) {
+                return new TarArchiveInputStream(new BufferedInputStream(new FileInputStream(archive)));
+            } else {
+                return new TarArchiveInputStream(new GZIPInputStream(new FileInputStream(archive)));
+            }
+        }
+
+        private void extractRar(@NonNull final Context context, File archive, String destinationPath) throws IOException, RarException {
+            ArrayList<FileHeader> arrayList = new ArrayList<>();
+            Archive zipFile = new Archive(archive);
+            FileHeader fh = zipFile.nextFileHeader();
+
+            while (fh != null) {
+                arrayList.add(fh);
+                fh = zipFile.nextFileHeader();
+
+            }
+
+            for (FileHeader header : arrayList) {
+                totalBytes += header.getFullUnpackSize();
+            }
+
+            // setting total bytes calculated from zip entriesToExtract
+            progressHandler.setTotalSize(totalBytes);
+
+            setInitDataPackage(totalBytes, arrayList.get(0).getFileNameString(), 1);
+
+            watcherUtil = new ServiceWatcherUtil(progressHandler, totalBytes);
+            watcherUtil.watch();
+
+            for (FileHeader header : arrayList) {
+
+                if (!progressHandler.getCancelled()) {
+
+                    progressHandler.setFileName(header.getFileNameString());
+                    unzipRAREntry(context, zipFile, header, destinationPath);
+                }
+            }
+            progressHandler.setSourceFilesProcessed(1);
+        }
+
+        private void extractRar(@NonNull final Context context, File archive, String destinationPath,
+                                String[] entriesToExtract) throws IOException, RarException {
+            Archive rarFile = new Archive(archive);
+
+            ArrayList<FileHeader> arrayList = new ArrayList<>();
+
+            // iterating archive elements to find file names that are to be extracted
+            for (FileHeader header : rarFile.getFileHeaders()) {
+                for (String entry : entriesToExtract) {
+
+                    if (header.getFileNameString().contains(entry)) {
+                        // header to be extracted is atleast the entry path (may be more, when it is a directory)
+                        arrayList.add(header);
+                    }
+                }
+            }
+
+            // get the total size of elements to be extracted
+            for (FileHeader entry : arrayList) {
+                totalBytes += entry.getFullUnpackSize();
+            }
+
+            // setting total bytes calculated from zip entries
+            progressHandler.setTotalSize(totalBytes);
+
+            setInitDataPackage(totalBytes, arrayList.get(0).getFileNameString(), arrayList.size());
+
+            watcherUtil = new ServiceWatcherUtil(progressHandler, totalBytes);
+            watcherUtil.watch();
+
+            int i = 0;
+            for (FileHeader entry : arrayList) {
+                if (!progressHandler.getCancelled()) {
+
+                    progressHandler.setFileName(entry.getFileNameString());
+                    unzipRAREntry(context, rarFile, entry, destinationPath);
+                    progressHandler.setSourceFilesProcessed(++i);
+                }
+            }
+        }
+
+        @Override
+        public void onPostExecute(Void b) {
+            final ExtractService extractService = this.extractService.get();
+            if(extractService == null) return;
+
+            // check whether watcherutil was initialized. It was not initialized when we got exception
+            // in extracting the file
+            if (watcherUtil != null) watcherUtil.stopWatch();
+            Intent intent = new Intent(MainActivity.KEY_INTENT_LOAD_LIST);
+            intent.putExtra(MainActivity.KEY_INTENT_LOAD_LIST_FILE, extractionPath);
+            extractService.sendBroadcast(intent);
+            extractService.stopSelf();
+        }
+
+        /**
+         * Setting initial package to initialize charts in process viewer properly
+         */
+        private void setInitDataPackage(long totalSize, String fileName, int sourceTotal) {
+            final ExtractService extractService = this.extractService.get();
+            if(extractService == null) return;
+
+            CopyDataParcelable intent1 = new CopyDataParcelable();
+            intent1.setName(fileName);
+            intent1.setSourceFiles(sourceTotal);
+            intent1.setSourceProgress(0);
+            intent1.setTotal(totalSize);
+            intent1.setByteProgress(0);
+            intent1.setSpeedRaw(0);
+            intent1.setMove(false);
+            intent1.setCompleted(false);
+            extractService.putDataPackage(intent1);
+        }
+
+    }
+
+
+    @Override
+    public void onDestroy() {
+        unregisterReceiver(receiver1);
+    }
+
+    /**
+     * Class used for the client Binder.  Because we know this service always
+     * runs in the same process as its clients, we don't need to deal with IPC.
+     */
+    private BroadcastReceiver receiver1 = new BroadcastReceiver() {
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            progressHandler.setCancelled(true);
+        }
+    };
+
+    @Override
+    public IBinder onBind(Intent arg0) {
+        // TODO Auto-generated method stub
+        return mBinder;
+    }
+
+    /**
+     * Returns the {@link #dataPackages} list which contains
+     * data to be transferred to {@link ProcessViewerFragment}
+     * Method call is synchronized so as to avoid modifying the list
+     * by {@link ServiceWatcherUtil#handlerThread} while {@link MainActivity#runOnUiThread(Runnable)}
+     * is executing the callbacks in {@link ProcessViewerFragment}
+     *
+     * @return
+     */
+    public synchronized CopyDataParcelable getDataPackage(int index) {
+        return this.dataPackages.get(index);
+    }
+
+    public synchronized int getDataPackageSize() {
+        return this.dataPackages.size();
+    }
+
+    /**
+     * Puts a {@link CopyDataParcelable} into a list
+     * Method call is synchronized so as to avoid modifying the list
+     * by {@link ServiceWatcherUtil#handlerThread} while {@link MainActivity#runOnUiThread(Runnable)}
+     * is executing the callbacks in {@link ProcessViewerFragment}
+     *
+     * @param dataPackage
+     */
+    private synchronized void putDataPackage(CopyDataParcelable dataPackage) {
+        this.dataPackages.add(dataPackage);
+    }
+
+}
+
diff --git a/app/src/main/java/com/amaze/filemanager/services/ZipTask.java b/app/src/main/java/com/amaze/filemanager/asynchronous/services/ZipService.java
similarity index 83%
rename from app/src/main/java/com/amaze/filemanager/services/ZipTask.java
rename to app/src/main/java/com/amaze/filemanager/asynchronous/services/ZipService.java
index d50a10dc7..1b6dfd0e6 100644
--- a/app/src/main/java/com/amaze/filemanager/services/ZipTask.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/services/ZipService.java
@@ -17,7 +17,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.services;
+package com.amaze.filemanager.asynchronous.services;
 
 import android.app.NotificationManager;
 import android.app.PendingIntent;
@@ -36,14 +36,16 @@ import android.text.format.Formatter;
 
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.MainActivity;
-import com.amaze.filemanager.filesystem.BaseFile;
 import com.amaze.filemanager.filesystem.FileUtil;
-import com.amaze.filemanager.utils.DataPackage;
-import com.amaze.filemanager.utils.files.Futils;
-import com.amaze.filemanager.utils.files.GenericCopyUtil;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
+import com.amaze.filemanager.fragments.ProcessViewerFragment;
+import com.amaze.filemanager.ui.notifications.NotificationConstants;
+import com.amaze.filemanager.utils.CopyDataParcelable;
 import com.amaze.filemanager.utils.PreferenceUtils;
 import com.amaze.filemanager.utils.ProgressHandler;
 import com.amaze.filemanager.utils.ServiceWatcherUtil;
+import com.amaze.filemanager.utils.files.FileUtils;
+import com.amaze.filemanager.utils.files.GenericCopyUtil;
 
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
@@ -55,7 +57,7 @@ import java.util.ArrayList;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipOutputStream;
 
-public class ZipTask extends Service {
+public class ZipService extends Service {
 
     NotificationManager mNotifyManager;
     NotificationCompat.Builder mBuilder;
@@ -65,7 +67,7 @@ public class ZipTask extends Service {
     long totalBytes = 0L;
     private final IBinder mBinder = new LocalBinder();
     private ProgressHandler progressHandler;
-    private ArrayList<DataPackage> dataPackages = new ArrayList<>();
+    private ArrayList<CopyDataParcelable> dataPackages = new ArrayList<>();
 
     public static final String KEY_COMPRESS_PATH = "zip_path";
     public static final String KEY_COMPRESS_FILES = "zip_files";
@@ -82,7 +84,7 @@ public class ZipTask extends Service {
         Bundle b = new Bundle();
         String path = intent.getStringExtra(KEY_COMPRESS_PATH);
 
-        ArrayList<BaseFile> baseFiles = intent.getParcelableArrayListExtra(KEY_COMPRESS_FILES);
+        ArrayList<HybridFileParcelable> baseFiles = intent.getParcelableArrayListExtra(KEY_COMPRESS_FILES);
 
         File zipFile = new File(path);
         mZipPath = PreferenceManager.getDefaultSharedPreferences(this)
@@ -101,14 +103,16 @@ public class ZipTask extends Service {
             }
         }
 
-        mBuilder = new NotificationCompat.Builder(this);
+        mBuilder = new NotificationCompat.Builder(this, NotificationConstants.CHANNEL_NORMAL_ID);
         Intent notificationIntent = new Intent(this, MainActivity.class);
         notificationIntent.putExtra(MainActivity.KEY_INTENT_PROCESS_VIEWER, true);
         PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);
-        mBuilder.setContentIntent(pendingIntent);
-        mBuilder.setContentTitle(getResources().getString(R.string.compressing))
+        mBuilder.setContentIntent(pendingIntent)
+                .setContentTitle(getResources().getString(R.string.compressing))
                 .setSmallIcon(R.drawable.ic_zip_box_grey600_36dp);
+        NotificationConstants.setMetadata(this, mBuilder);
         startForeground(Integer.parseInt("789" + startId), mBuilder.build());
+
         b.putInt("id", startId);
         b.putParcelableArrayList(KEY_COMPRESS_FILES, baseFiles);
         b.putString(KEY_COMPRESS_PATH, mZipPath);
@@ -118,9 +122,9 @@ public class ZipTask extends Service {
     }
 
     public class LocalBinder extends Binder {
-        public ZipTask getService() {
+        public ZipService getService() {
             // Return this instance of LocalService so clients can call public methods
-            return ZipTask.this;
+            return ZipService.this;
         }
     }
 
@@ -129,7 +133,7 @@ public class ZipTask extends Service {
     }
 
     public interface ProgressListener {
-        void onUpdate(DataPackage dataPackage);
+        void onUpdate(CopyDataParcelable dataPackage);
 
         void refresh();
     }
@@ -144,7 +148,7 @@ public class ZipTask extends Service {
         public DoWork() {
         }
 
-        public ArrayList<File> toFileArray(ArrayList<BaseFile> a) {
+        public ArrayList<File> toFileArray(ArrayList<HybridFileParcelable> a) {
             ArrayList<File> b = new ArrayList<>();
             for (int i = 0; i < a.size(); i++) {
                 b.add(new File(a.get(i).getPath()));
@@ -154,22 +158,17 @@ public class ZipTask extends Service {
 
         protected Integer doInBackground(Bundle... p1) {
             final int id = p1[0].getInt("id");
-            ArrayList<BaseFile> baseFiles = p1[0].getParcelableArrayList(KEY_COMPRESS_FILES);
+            ArrayList<HybridFileParcelable> baseFiles = p1[0].getParcelableArrayList(KEY_COMPRESS_FILES);
 
             // setting up service watchers and initial data packages
             // finding total size on background thread (this is necessary condition for SMB!)
-            totalBytes = Futils.getTotalBytes(baseFiles, c);
+            totalBytes = FileUtils.getTotalBytes(baseFiles, c);
             progressHandler = new ProgressHandler(baseFiles.size(), totalBytes);
-            progressHandler.setProgressListener(new ProgressHandler.ProgressListener() {
-                @Override
-                public void onProgressed(String fileName, int sourceFiles, int sourceProgress,
-                                         long totalSize, long writtenSize, int speed) {
-                    publishResults(id, fileName, sourceFiles, sourceProgress,
-                            totalSize, writtenSize, speed, false);
-                }
+            progressHandler.setProgressListener((fileName, sourceFiles, sourceProgress, totalSize, writtenSize, speed) -> {
+                publishResults(id, fileName, sourceFiles, sourceProgress, totalSize, writtenSize, speed, false);
             });
 
-            DataPackage intent1 = new DataPackage();
+            CopyDataParcelable intent1 = new CopyDataParcelable();
             intent1.setName(baseFiles.get(0).getName());
             intent1.setSourceFiles(baseFiles.size());
             intent1.setSourceProgress(0);
@@ -189,7 +188,8 @@ public class ZipTask extends Service {
         public void onPostExecute(Integer b) {
 
             watcherUtil.stopWatch();
-            Intent intent = new Intent("loadlist");
+            Intent intent = new Intent(MainActivity.KEY_INTENT_LOAD_LIST);
+            intent.putExtra(MainActivity.KEY_INTENT_LOAD_LIST_FILE, mZipPath);
             sendBroadcast(intent);
             stopSelf();
         }
@@ -214,9 +214,9 @@ public class ZipTask extends Service {
                         compressFile(file, "");
                     } else return;
                 }
-            } catch (Exception e) {
+            } catch (IOException e) {
+                e.printStackTrace();
             } finally {
-
                 try {
                     zos.flush();
                     zos.close();
@@ -276,7 +276,7 @@ public class ZipTask extends Service {
                 isCompleted = true;
             }
 
-            DataPackage intent = new DataPackage();
+            CopyDataParcelable intent = new CopyDataParcelable();
             intent.setName(fileName);
             intent.setSourceFiles(sourceFiles);
             intent.setSourceProgress(sourceProgress);
@@ -330,14 +330,14 @@ public class ZipTask extends Service {
 
     /**
      * Returns the {@link #dataPackages} list which contains
-     * data to be transferred to {@link com.amaze.filemanager.fragments.ProcessViewer}
+     * data to be transferred to {@link ProcessViewerFragment}
      * Method call is synchronized so as to avoid modifying the list
      * by {@link ServiceWatcherUtil#handlerThread} while {@link MainActivity#runOnUiThread(Runnable)}
-     * is executing the callbacks in {@link com.amaze.filemanager.fragments.ProcessViewer}
+     * is executing the callbacks in {@link ProcessViewerFragment}
      *
      * @return
      */
-    public synchronized DataPackage getDataPackage(int index) {
+    public synchronized CopyDataParcelable getDataPackage(int index) {
         return this.dataPackages.get(index);
     }
 
@@ -346,14 +346,14 @@ public class ZipTask extends Service {
     }
 
     /**
-     * Puts a {@link DataPackage} into a list
+     * Puts a {@link CopyDataParcelable} into a list
      * Method call is synchronized so as to avoid modifying the list
      * by {@link ServiceWatcherUtil#handlerThread} while {@link MainActivity#runOnUiThread(Runnable)}
-     * is executing the callbacks in {@link com.amaze.filemanager.fragments.ProcessViewer}
+     * is executing the callbacks in {@link ProcessViewerFragment}
      *
      * @param dataPackage
      */
-    private synchronized void putDataPackage(DataPackage dataPackage) {
+    private synchronized void putDataPackage(CopyDataParcelable dataPackage) {
         this.dataPackages.add(dataPackage);
     }
 
diff --git a/app/src/main/java/com/amaze/filemanager/database/CloudHandler.java b/app/src/main/java/com/amaze/filemanager/database/CloudHandler.java
index 1f31699f2..164d7c15d 100644
--- a/app/src/main/java/com/amaze/filemanager/database/CloudHandler.java
+++ b/app/src/main/java/com/amaze/filemanager/database/CloudHandler.java
@@ -155,9 +155,8 @@ public class CloudHandler extends SQLiteOpenHelper {
                 cloudEntry.setPersistData(CryptUtil.decryptPassword(context, cursor.getString(2)));
             } catch (Exception e) {
                 e.printStackTrace();
-                cloudEntry.setPersistData(cursor.getString(2));
-                // we're getting plain text, just in case it works,
-                // if this doesn't restore the cloud storage state, it'll automatically be updated later
+                cloudEntry.setPersistData("");
+                return cloudEntry;
             }
 
             cursor.close();
@@ -191,9 +190,9 @@ public class CloudHandler extends SQLiteOpenHelper {
                         cloudEntry.setPersistData(CryptUtil.decryptPassword(context, cursor.getString(2)));
                     } catch (Exception e) {
                         e.printStackTrace();
-                        cloudEntry.setPersistData(cursor.getString(2));
-                        // we're getting plain text, just in case it works,
-                        // if this doesn't restore the cloud storage state, it'll automatically be updated later
+                        cloudEntry.setPersistData("");
+                        entryList.add(cloudEntry);
+                        continue;
                     }
 
                     entryList.add(cloudEntry);
diff --git a/app/src/main/java/com/amaze/filemanager/database/CryptHandler.java b/app/src/main/java/com/amaze/filemanager/database/CryptHandler.java
index bb632d0ca..b58f7ad65 100644
--- a/app/src/main/java/com/amaze/filemanager/database/CryptHandler.java
+++ b/app/src/main/java/com/amaze/filemanager/database/CryptHandler.java
@@ -7,24 +7,13 @@ import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteOpenHelper;
 
 import com.amaze.filemanager.database.models.EncryptedEntry;
-import com.amaze.filemanager.exceptions.CryptException;
 import com.amaze.filemanager.utils.files.CryptUtil;
 
 import java.io.IOException;
-import java.security.InvalidAlgorithmParameterException;
-import java.security.InvalidKeyException;
-import java.security.KeyStoreException;
-import java.security.NoSuchAlgorithmException;
-import java.security.NoSuchProviderException;
-import java.security.UnrecoverableEntryException;
-import java.security.cert.CertificateException;
+import java.security.GeneralSecurityException;
 import java.util.ArrayList;
 import java.util.List;
 
-import javax.crypto.BadPaddingException;
-import javax.crypto.IllegalBlockSizeException;
-import javax.crypto.NoSuchPaddingException;
-
 /**
  * Created by vishal on 15/4/17.
  */
@@ -63,7 +52,7 @@ public class CryptHandler extends SQLiteOpenHelper {
         onCreate(db);
     }
 
-    public void addEntry(EncryptedEntry encryptedEntry) throws CryptException {
+    public void addEntry(EncryptedEntry encryptedEntry) throws GeneralSecurityException, IOException {
 
         ContentValues contentValues = new ContentValues();
         //contentValues.put(COLUMN_ENCRYPTED_ID, encryptedEntry.getId());
@@ -84,7 +73,7 @@ public class CryptHandler extends SQLiteOpenHelper {
         }
     }
 
-    public void updateEntry(EncryptedEntry oldEncryptedEntry, EncryptedEntry newEncryptedEntry) throws CryptException {
+    public void updateEntry(EncryptedEntry oldEncryptedEntry, EncryptedEntry newEncryptedEntry) throws GeneralSecurityException, IOException  {
         SQLiteDatabase sqLiteDatabase = getWritableDatabase();
         ContentValues contentValues = new ContentValues();
         contentValues.put(COLUMN_ENCRYPTED_ID, newEncryptedEntry.getId());
@@ -96,7 +85,7 @@ public class CryptHandler extends SQLiteOpenHelper {
                 new String[]{oldEncryptedEntry.getId() + ""});
     }
 
-    public EncryptedEntry findEntry(String path) throws CryptException {
+    public EncryptedEntry findEntry(String path) throws GeneralSecurityException, IOException {
         String query = "Select * FROM " + TABLE_ENCRYPTED + " WHERE " + COLUMN_ENCRYPTED_PATH
                 + "= \"" + path + "\"";
         SQLiteDatabase sqLiteDatabase = getReadableDatabase();
@@ -115,7 +104,7 @@ public class CryptHandler extends SQLiteOpenHelper {
         return encryptedEntry;
     }
 
-    public List<EncryptedEntry> getAllEntries() throws CryptException {
+    public List<EncryptedEntry> getAllEntries() throws GeneralSecurityException, IOException {
         List<EncryptedEntry> entryList = new ArrayList<EncryptedEntry>();
         // Select all query
         String query = "Select * FROM " + TABLE_ENCRYPTED;
diff --git a/app/src/main/java/com/amaze/filemanager/database/UtilsHandler.java b/app/src/main/java/com/amaze/filemanager/database/UtilsHandler.java
index 9c2cf5d84..347356087 100644
--- a/app/src/main/java/com/amaze/filemanager/database/UtilsHandler.java
+++ b/app/src/main/java/com/amaze/filemanager/database/UtilsHandler.java
@@ -11,14 +11,18 @@ import android.util.Log;
 import android.widget.Toast;
 
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.exceptions.CryptException;
 import com.amaze.filemanager.services.ssh.SshClientUtils;
 import com.amaze.filemanager.services.ssh.SshConnectionPool;
 import com.amaze.filemanager.utils.SmbUtil;
-import com.amaze.filemanager.utils.files.CryptUtil;
+import com.googlecode.concurrenttrees.radix.ConcurrentRadixTree;
+import com.googlecode.concurrenttrees.radix.node.concrete.DefaultCharArrayNodeFactory;
+import com.googlecode.concurrenttrees.radix.node.concrete.voidvalue.VoidValue;
 
 import java.io.File;
+import java.io.IOException;
+import java.security.GeneralSecurityException;
 import java.util.ArrayList;
+import java.util.LinkedList;
 import java.util.List;
 
 /**
@@ -184,12 +188,35 @@ public class UtilsHandler extends SQLiteOpenHelper {
         database.insert(getTableForOperation(Operation.SFTP), null, values);
     }
 
-    public ArrayList<String> getHistoryList() {
-        return getPath(Operation.HISTORY);
+    public LinkedList<String> getHistoryLinkedList() {
+        SQLiteDatabase sqLiteDatabase = getReadableDatabase();
+        Cursor cursor = sqLiteDatabase.query(getTableForOperation(Operation.HISTORY), null,
+                null, null, null, null, null);
+
+        LinkedList<String> paths = new LinkedList<>();
+        cursor.moveToFirst();
+        try {
+            while (cursor.moveToNext()) {
+                paths.push(cursor.getString(cursor.getColumnIndex(COLUMN_PATH)));
+            }
+        } finally {
+            cursor.close();
+        }
+        return paths;
     }
 
-    public ArrayList<String> getHiddenList() {
-        return getPath(Operation.HIDDEN);
+    public ConcurrentRadixTree<VoidValue> getHiddenFilesConcurrentRadixTree() {
+        ConcurrentRadixTree<VoidValue> paths = new ConcurrentRadixTree<>(new DefaultCharArrayNodeFactory());
+
+        Cursor cursor = getReadableDatabase().query(getTableForOperation(Operation.HIDDEN), null,
+                null, null, null, null, null);
+        cursor.moveToFirst();
+        while (cursor.moveToNext()) {
+            paths.put(cursor.getString(cursor.getColumnIndex(COLUMN_PATH)), VoidValue.SINGLETON);
+        }
+        cursor.close();
+
+        return paths;
     }
 
     public ArrayList<String> getListViewList() {
@@ -238,7 +265,7 @@ public class UtilsHandler extends SQLiteOpenHelper {
                             cursor.getString(cursor.getColumnIndex(COLUMN_NAME)),
                             SmbUtil.getSmbDecryptedPath(context, cursor.getString(cursor.getColumnIndex(COLUMN_PATH)))
                     });
-                } catch (CryptException e) {
+                } catch (GeneralSecurityException | IOException e) {
                     e.printStackTrace();
 
                     // failing to decrypt the path, removing entry from database
@@ -396,12 +423,12 @@ public class UtilsHandler extends SQLiteOpenHelper {
         try {
             if (path.equals("")) {
                 // we don't have a path, remove the entry with this name
-                throw new CryptException();
+                throw new IOException();
             }
 
             sqLiteDatabase.delete(TABLE_SMB, COLUMN_NAME + " = ? AND " + COLUMN_PATH + " = ?",
                     new String[] {name, SmbUtil.getSmbEncryptedPath(context, path)});
-        } catch (CryptException e) {
+        } catch (IOException | GeneralSecurityException e) {
             e.printStackTrace();
             // force remove entry, we end up deleting all entries with same name
 
@@ -418,14 +445,14 @@ public class UtilsHandler extends SQLiteOpenHelper {
         {
             if (path.equals("")) {
                 // we don't have a path, remove the entry with this name
-                throw new CryptException();
+                throw new IOException();
             }
 
             sqLiteDatabase.delete(TABLE_SFTP, COLUMN_NAME + " = ? AND " + COLUMN_PATH + " = ?",
                     new String[] {name, SshClientUtils.encryptSshPathAsNecessary(path)});
 
         }
-        catch (CryptException e)
+        catch (IOException e)
         {
             e.printStackTrace();
             // force remove entry, we end up deleting all entries with same name
@@ -490,16 +517,14 @@ public class UtilsHandler extends SQLiteOpenHelper {
         SQLiteDatabase sqLiteDatabase = getReadableDatabase();
         Cursor cursor = sqLiteDatabase.query(getTableForOperation(operation), null,
                 null, null, null, null, null);
-        cursor.moveToFirst();
+
+        ArrayList<String> paths = new ArrayList<>();
 
         switch (operation) {
-            case HISTORY:
-            case HIDDEN:
             case LIST:
             case GRID:
-                ArrayList<String> paths = new ArrayList<>();
+                cursor.moveToFirst();
                 try {
-
                     while (cursor.moveToNext()) {
                         paths.add(cursor.getString(cursor.getColumnIndex(COLUMN_PATH)));
                     }
@@ -520,12 +545,8 @@ public class UtilsHandler extends SQLiteOpenHelper {
                 new String[] {path});
     }
 
-    private void clearTable(Operation operation) {
-
-        SQLiteDatabase sqLiteDatabase = getWritableDatabase();
-
-        sqLiteDatabase.delete(getTableForOperation(operation), COLUMN_PATH + "=?",
-                new String[] { "NOT NULL" });
+    private void clearTable(Operation table) {
+        getWritableDatabase().delete(getTableForOperation(table), null, null);
     }
 
     private void renamePath(Operation operation, String name, String path) {
diff --git a/app/src/main/java/com/amaze/filemanager/database/models/DrawerEntry.java b/app/src/main/java/com/amaze/filemanager/database/models/DrawerEntry.java
deleted file mode 100644
index 878b0a01a..000000000
--- a/app/src/main/java/com/amaze/filemanager/database/models/DrawerEntry.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package com.amaze.filemanager.database.models;
-
-/**
- * Created by Vishal on 08-06-2017.
- *
- * Model class storing name and path for bookmarks and smb entries in drawer
- */
-
-public class DrawerEntry {
-
-    String drawerName, path;
-
-    public DrawerEntry(String drawerName, String path) {
-
-        setDrawerName(drawerName);
-        setPath(path);
-    }
-
-    public void setDrawerName(String drawerName) {
-        this.drawerName = drawerName;
-    }
-
-    public void setPath(String path) {
-        this.path = path;
-    }
-
-    public String getDrawerName() {
-        return this.drawerName;
-    }
-
-    public String getPath() {
-        return this.path;
-    }
-}
diff --git a/app/src/main/java/com/amaze/filemanager/database/models/PathEntry.java b/app/src/main/java/com/amaze/filemanager/database/models/PathEntry.java
deleted file mode 100644
index e5968bbf4..000000000
--- a/app/src/main/java/com/amaze/filemanager/database/models/PathEntry.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package com.amaze.filemanager.database.models;
-
-/**
- * Created by Vishal on 08-06-2017.
- *
- * Model class for storing path for list, grid, history and hidden objects
- */
-
-public class PathEntry {
-
-    private String path;
-
-    public PathEntry(String path) {
-        this.path = path;
-    }
-
-    public PathEntry() {}
-
-    public void setPath(String path) {
-        this.path = path;
-    }
-
-    public String getPath() {
-        return this.path;
-    }
-}
diff --git a/app/src/main/java/com/amaze/filemanager/exceptions/CryptException.java b/app/src/main/java/com/amaze/filemanager/exceptions/CryptException.java
deleted file mode 100644
index 31ae84a5d..000000000
--- a/app/src/main/java/com/amaze/filemanager/exceptions/CryptException.java
+++ /dev/null
@@ -1,11 +0,0 @@
-package com.amaze.filemanager.exceptions;
-
-/**
- * Created by Vishal on 01-07-2017.
- *
- * Exception thrown when there is some problem with cryptographic function and the operation fails.
- * The problem can by anything from no padding, wrong cryptographic algorithm to illegal block size
- */
-
-public class CryptException extends Exception {
-}
diff --git a/app/src/main/java/com/amaze/filemanager/exceptions/RootNotPermittedException.java b/app/src/main/java/com/amaze/filemanager/exceptions/RootNotPermittedException.java
deleted file mode 100644
index cd97d6e71..000000000
--- a/app/src/main/java/com/amaze/filemanager/exceptions/RootNotPermittedException.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package com.amaze.filemanager.exceptions;
-
-/**
- * Created by vishal on 24/12/16.
- * Exception thrown when root is
- */
-
-public class RootNotPermittedException extends Exception {
-
-    private static final String MESSAGE = "Exception thrown when root is";
-
-    public RootNotPermittedException() { super(MESSAGE); }
-    public RootNotPermittedException(String message) { super(message); }
-    public RootNotPermittedException(String message, Throwable cause) { super(message, cause); }
-    public RootNotPermittedException(Throwable cause) { super(MESSAGE, cause); }
-
-}
diff --git a/app/src/main/java/com/amaze/filemanager/exceptions/ShellNotRunningException.java b/app/src/main/java/com/amaze/filemanager/exceptions/ShellNotRunningException.java
new file mode 100644
index 000000000..78dec852a
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/exceptions/ShellNotRunningException.java
@@ -0,0 +1,12 @@
+package com.amaze.filemanager.exceptions;
+
+/**
+ * Created by vishal on 24/12/16.
+ * Exception thrown when root is
+ */
+
+public class ShellNotRunningException extends Exception {
+    public ShellNotRunningException() {
+        super("Shell stopped running!");
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/exceptions/TypeNotSupportedException.java b/app/src/main/java/com/amaze/filemanager/exceptions/TypeNotSupportedException.java
deleted file mode 100644
index 15f8de943..000000000
--- a/app/src/main/java/com/amaze/filemanager/exceptions/TypeNotSupportedException.java
+++ /dev/null
@@ -1,10 +0,0 @@
-package com.amaze.filemanager.exceptions;
-
-/**
- * Created by vishal on 18/2/17.
- * Exception thrown when certain {@link com.amaze.filemanager.utils.OpenMode} type is not supported
- * by the callback
- */
-
-public class TypeNotSupportedException extends Exception {
-}
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/CustomFileObserver.java b/app/src/main/java/com/amaze/filemanager/filesystem/CustomFileObserver.java
new file mode 100644
index 000000000..5e3e48956
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/CustomFileObserver.java
@@ -0,0 +1,215 @@
+package com.amaze.filemanager.filesystem;
+
+import android.os.Build;
+import android.os.FileObserver;
+import android.os.Handler;
+import android.support.annotation.RequiresApi;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Calendar;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Timer;
+import java.util.TimerTask;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Class which monitors any change in local filesystem and updates the adapter
+ * Makes use of inotify in Linux
+ */
+public class CustomFileObserver extends FileObserver {
+
+    /**
+     * Values for what of Handler Message
+     */
+    public static final int GOBACK = -1, NEW_ITEM = 0, DELETED_ITEM = 1;
+
+    /**
+     * When the bserver stops observing this event is recieved
+     * Check: http://rswiki.csie.org/lxr/http/source/include/linux/inotify.h?a=m68k#L45
+     */
+    private static final int IN_IGNORED = 0x00008000;
+    private static final int DEFER_CONSTANT_SECONDS = 5;
+    private static final int DEFER_CONSTANT = DEFER_CONSTANT_SECONDS*1000;
+    private static final int MASK = CREATE | MOVED_TO | DELETE | MOVED_FROM | DELETE_SELF | MOVE_SELF;
+
+    private long lastMessagedTime = 0L;
+    private boolean messagingScheduled = false;
+    private boolean wasStopped = false;
+
+    private Handler handler;
+    private String path;
+    private final List<String> pathsAdded = Collections.synchronizedList(new ArrayList<>());
+    private final List<String> pathsRemoved = Collections.synchronizedList(new ArrayList<>());
+
+    public CustomFileObserver(String path, Handler handler) {
+        super(path, MASK);
+        this.path = path;
+        this.handler = handler;
+    }
+
+    public boolean wasStopped() {
+        return wasStopped;
+    }
+
+    public String getPath() {
+        return path;
+    }
+
+    @Override
+    public void startWatching() {
+        if(Build.VERSION.SDK_INT == Build.VERSION_CODES.M) {
+            startPollingSystem();
+        } else {
+            super.startWatching();
+        }
+    }
+
+    @Override
+    public void stopWatching() {
+        wasStopped = true;
+
+        if(Build.VERSION.SDK_INT == Build.VERSION_CODES.M) {
+            stopPollingSystem();
+        } else {
+            super.startWatching();
+        }
+    }
+
+    @Override
+    public void onEvent(int event, String path) {
+        if(event == IN_IGNORED) {
+            wasStopped = true;
+            return;
+        }
+
+        long deltaTime = Calendar.getInstance().getTimeInMillis() - lastMessagedTime;
+
+        switch (event) {
+            case CREATE:
+            case MOVED_TO:
+                pathsAdded.add(path);
+                break;
+            case DELETE:
+            case MOVED_FROM:
+                pathsRemoved.add(path);
+                break;
+            case DELETE_SELF:
+            case MOVE_SELF:
+                handler.obtainMessage(GOBACK).sendToTarget();
+                return;
+        }
+
+
+        if(deltaTime <= DEFER_CONSTANT) {
+            // defer the observer until unless it reports a change after at least 5 secs of last one
+            // keep adding files added, if there were any, to the buffer
+
+            new Timer().schedule(new TimerTask() {
+                @Override
+                public void run() {
+
+                    if(messagingScheduled) return;
+                    sendMessages();
+                }
+            }, DEFER_CONSTANT - deltaTime);
+
+            messagingScheduled = true;
+        } else {
+            if(messagingScheduled) return;
+            sendMessages();
+        }
+    }
+
+    private synchronized void sendMessages() {
+        lastMessagedTime = Calendar.getInstance().getTimeInMillis();
+
+        synchronized (pathsAdded) {
+            for (String pathAdded : pathsAdded) {
+                handler.obtainMessage(NEW_ITEM, pathAdded).sendToTarget();
+            }
+        }
+        pathsAdded.clear();
+
+        synchronized (pathsRemoved) {
+            for (String pathRemoved : pathsRemoved) {
+                handler.obtainMessage(DELETED_ITEM, pathRemoved).sendToTarget();
+            }
+        }
+        pathsRemoved.clear();
+        messagingScheduled = false;
+    }
+
+    /**
+     *  No such file or directory
+     *  From: http://www-numi.fnal.gov/offline_software/srt_public_context/WebDocs/Errors/unix_system_errors.html
+     */
+    private static final int ENOENT = 2, ENOTDIR = 20;
+
+    private ScheduledExecutorService executor = null;
+
+    /**
+     * In Marshmallow FileObserver is broken, this hack will let you know of changes to a directory
+     * every DEFER_CONSTANT_SECONDS seconds, calling onEvent as expected EXCEPT when moving, in such
+     * cases the event will be creation (if moved into) or deletion (if moved out of) or
+     * DELETE_SELF instead of MOVE_SELF.
+     */
+    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
+    private void startPollingSystem() {
+        executor = Executors.newScheduledThreadPool(1);
+        executor.scheduleWithFixedDelay(new FileTimerTask(path, this),
+                DEFER_CONSTANT_SECONDS, DEFER_CONSTANT_SECONDS, TimeUnit.SECONDS); //This doesn't work with milliseconds (don't know why)
+    }
+
+    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
+    private void stopPollingSystem() {
+        executor.shutdown();
+    }
+
+    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
+    private static class FileTimerTask implements Runnable {
+        private FileObserver fileObserver;
+        private String[] files = null;
+        private File file;
+
+        private FileTimerTask(String path, FileObserver fileObserver) {
+            file = new File(path);
+            if(!file.isDirectory()) throw new IllegalArgumentException("Illegal path, you can only watch directories!");
+            files = file.list();
+            this.fileObserver = fileObserver;
+        }
+
+        @Override
+        public void run() {
+            if (!file.exists()) {
+                fileObserver.onEvent(DELETE_SELF, null);
+                return;
+            }
+            if (!file.canRead() || !file.isHidden()) {
+                fileObserver.onEvent(IN_IGNORED, null);
+                return;
+            }
+
+            String[] newFiles = file.list();
+            for (String s : compare(newFiles, files)) {
+                fileObserver.onEvent(CREATE, s);
+            }
+            for (String s : compare(files, newFiles)) {
+                fileObserver.onEvent(DELETE, s);
+            }
+        }
+
+        private HashSet<String> compare(String[] s1, String[] s2) {
+            HashSet<String> set1 = new HashSet<>(Arrays.asList(s1));
+            HashSet<String> set2 = new HashSet<>(Arrays.asList(s2));
+            set1.removeAll(set2);
+            return set1;
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/FileUtil.java b/app/src/main/java/com/amaze/filemanager/filesystem/FileUtil.java
index ff5770f2b..d2f1dfbed 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/FileUtil.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/FileUtil.java
@@ -1,7 +1,6 @@
 package com.amaze.filemanager.filesystem;
 
 import android.annotation.TargetApi;
-import android.app.Activity;
 import android.content.ContentResolver;
 import android.content.ContentValues;
 import android.content.Context;
@@ -17,12 +16,21 @@ import android.support.v4.provider.DocumentFile;
 import android.util.Log;
 
 import com.amaze.filemanager.R;
+import com.amaze.filemanager.activities.MainActivity;
 import com.amaze.filemanager.database.CloudHandler;
-import com.amaze.filemanager.exceptions.RootNotPermittedException;
+import com.amaze.filemanager.exceptions.ShellNotRunningException;
 import com.amaze.filemanager.ui.icons.MimeTypes;
+import com.amaze.filemanager.utils.DataUtils;
 import com.amaze.filemanager.utils.OTGUtil;
+import com.amaze.filemanager.utils.OpenMode;
 import com.amaze.filemanager.utils.RootUtils;
+import com.amaze.filemanager.utils.application.AppConfig;
+import com.amaze.filemanager.utils.cloud.CloudUtil;
+import com.amaze.filemanager.utils.files.GenericCopyUtil;
+import com.cloudrail.si.interfaces.CloudStorage;
 
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
@@ -132,35 +140,167 @@ public abstract class FileUtil {
         return true;
     }
 
-    public static OutputStream getOutputStream(final File target, Context context) throws Exception {
+    public static OutputStream getOutputStream(final File target, Context context) throws FileNotFoundException {
         return getOutputStream(target, context, 0);
     }
 
-    public static OutputStream getOutputStream(final File target, Context context, long s) throws Exception {
+    public static OutputStream getOutputStream(final File target, Context context, long s) throws FileNotFoundException {
         OutputStream outStream = null;
-        try {
-            // First try the normal way
-            if (isWritable(target)) {
-                // standard way
-                outStream = new FileOutputStream(target);
-            } else {
-                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
-                    // Storage Access Framework
-                    DocumentFile targetDocument = getDocumentFile(target, false, context);
-                    outStream = context.getContentResolver().openOutputStream(targetDocument.getUri());
-                } else if (Build.VERSION.SDK_INT == Build.VERSION_CODES.KITKAT) {
-                    // Workaround for Kitkat ext SD card
-                    return MediaStoreHack.getOutputStream(context, target.getPath());
-                }
+        // First try the normal way
+        if (isWritable(target)) {
+            // standard way
+            outStream = new FileOutputStream(target);
+        } else {
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+                // Storage Access Framework
+                DocumentFile targetDocument = getDocumentFile(target, false, context);
+                outStream = context.getContentResolver().openOutputStream(targetDocument.getUri());
+            } else if (Build.VERSION.SDK_INT == Build.VERSION_CODES.KITKAT) {
+                // Workaround for Kitkat ext SD card
+                return MediaStoreHack.getOutputStream(context, target.getPath());
             }
-        } catch (Exception e) {
-            Log.e("AmazeFileUtils",
-                    "Error when copying file from " + target.getAbsolutePath(), e);
-            throw new Exception();
         }
         return outStream;
     }
 
+    /**
+     * Writes uri stream from external application to the specified path
+     * @param uris
+     * @param contentResolver
+     * @param currentPath
+     */
+    public static final void writeUriToStorage(final MainActivity mainActivity, final ArrayList<Uri> uris,
+                                               final ContentResolver contentResolver, final String currentPath) {
+
+        AppConfig.runInBackground(new AppConfig.CustomAsyncCallbacks() {
+
+            @Override
+            public <E> E doInBackground() {
+
+                for (Uri uri : uris) {
+
+                    BufferedInputStream bufferedInputStream = null;
+                    try {
+                        bufferedInputStream = new BufferedInputStream(contentResolver.openInputStream(uri));
+                    } catch (FileNotFoundException e) {
+                        e.printStackTrace();
+                    }
+
+                    BufferedOutputStream bufferedOutputStream = null;
+
+                    try {
+
+                        DocumentFile documentFile = DocumentFile.fromSingleUri(mainActivity, uri);
+                        String finalFilePath = currentPath + "/" + documentFile.getName();
+                        DataUtils dataUtils = DataUtils.getInstance();
+
+                        HybridFile hFile = new HybridFile(OpenMode.UNKNOWN, currentPath);
+                        hFile.generateMode(mainActivity);
+
+                        switch (hFile.getMode()) {
+                            case FILE:
+                            case ROOT:
+                                if (!FileUtil.isWritable(new File(currentPath))) {
+                                    AppConfig.toast(mainActivity, mainActivity.getResources().getString(R.string.not_allowed));
+                                    return null;
+                                }
+                                bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(finalFilePath));
+                                break;
+                            case SMB:
+                                OutputStream outputStream = new SmbFile(finalFilePath).getOutputStream();
+                                bufferedOutputStream = new BufferedOutputStream(outputStream);
+                                break;
+                            case DROPBOX:
+                                CloudStorage cloudStorageDropbox = dataUtils.getAccount(OpenMode.DROPBOX);
+                                cloudStorageDropbox.upload(CloudUtil.stripPath(OpenMode.DROPBOX, finalFilePath),
+                                        bufferedInputStream, documentFile.length(), true);
+                                break;
+                            case BOX:
+                                CloudStorage cloudStorageBox = dataUtils.getAccount(OpenMode.BOX);
+                                cloudStorageBox.upload(CloudUtil.stripPath(OpenMode.BOX, finalFilePath),
+                                        bufferedInputStream, documentFile.length(), true);
+                                break;
+                            case ONEDRIVE:
+                                CloudStorage cloudStorageOneDrive = dataUtils.getAccount(OpenMode.ONEDRIVE);
+                                cloudStorageOneDrive.upload(CloudUtil.stripPath(OpenMode.ONEDRIVE, finalFilePath),
+                                        bufferedInputStream, documentFile.length(), true);
+                                break;
+                            case GDRIVE:
+                                CloudStorage cloudStorageGDrive = dataUtils.getAccount(OpenMode.GDRIVE);
+                                cloudStorageGDrive.upload(CloudUtil.stripPath(OpenMode.GDRIVE, finalFilePath),
+                                        bufferedInputStream, documentFile.length(), true);
+                                break;
+                            case OTG:
+                                DocumentFile documentTargetFile = OTGUtil.getDocumentFile(finalFilePath,
+                                        mainActivity, true);
+
+                                bufferedOutputStream = new BufferedOutputStream(contentResolver
+                                        .openOutputStream(documentTargetFile.getUri()),
+                                        GenericCopyUtil.DEFAULT_BUFFER_SIZE);
+                                break;
+                            default:
+                                return null;
+                        }
+
+                        int count = 0;
+                        byte[] buffer = new byte[GenericCopyUtil.DEFAULT_BUFFER_SIZE];
+
+                        while (count != -1) {
+
+                            count = bufferedInputStream.read(buffer);
+                            if (count != -1) {
+
+                                bufferedOutputStream.write(buffer, 0, count);
+                            }
+                        }
+                        bufferedOutputStream.flush();
+
+                    } catch (FileNotFoundException e) {
+                        e.printStackTrace();
+                    } catch (MalformedURLException e) {
+                        e.printStackTrace();
+                    } catch (IOException e) {
+                        e.printStackTrace();
+                    } finally {
+
+                        try {
+
+                            if (bufferedInputStream != null) {
+                                bufferedInputStream.close();
+                            }
+                            if (bufferedOutputStream != null) {
+                                bufferedOutputStream.close();
+                            }
+                        } catch (IOException e) {
+                            e.printStackTrace();
+                        }
+                    }
+                }
+                return null;
+            }
+
+            @Override
+            public Void onPostExecute(Object result) {
+                return null;
+            }
+
+            @Override
+            public Void onPreExecute() {
+                return null;
+            }
+
+            @Override
+            public Void publishResult(Object... result) {
+                return null;
+            }
+
+            @Override
+            public <T> T[] params() {
+                return null;
+            }
+        });
+    }
+
     /**
      * Delete a file. May be even on external SD card.
      *
@@ -198,7 +338,7 @@ public abstract class FileUtil {
         return !file.exists();
     }
 
-    private static boolean rename(File f, String name, boolean root) throws RootNotPermittedException {
+    private static boolean rename(File f, String name, boolean root) throws ShellNotRunningException {
         String newPath = f.getParent() + "/" + name;
         if (f.getParentFile().canWrite()) {
             return f.renameTo(new File(newPath));
@@ -217,7 +357,7 @@ public abstract class FileUtil {
      * @return true if the renaming was successful.
      */
     static boolean renameFolder(@NonNull final File source, @NonNull final File target,
-                                Context context) throws RootNotPermittedException {
+                                Context context) throws ShellNotRunningException {
         // First try the normal rename.
         if (rename(source, target.getName(), false)) {
             return true;
@@ -278,7 +418,7 @@ public abstract class FileUtil {
     /**
      * Create a folder. The folder may even be on external SD card for Kitkat.
      *
-     * @deprecated use {@link #mkdirs(Context, HFile)}
+     * @deprecated use {@link #mkdirs(Context, HybridFile)}
      * @param file  The folder to be created.
      * @return True if creation was successful.
      */
@@ -314,7 +454,7 @@ public abstract class FileUtil {
         return false;
     }
 
-    public static boolean mkdirs(Context context, HFile file) {
+    public static boolean mkdirs(Context context, HybridFile file) {
         boolean isSuccessful = true;
         switch (file.mode) {
             case SMB:
@@ -473,40 +613,6 @@ public abstract class FileUtil {
         return totalSuccess;
     }
 
-    /**
-     * Delete a directory asynchronously.
-     *
-     * @param activity    The activity calling this method.
-     * @param file        The folder name.
-     * @param postActions Commands to be executed after success.
-     */
-    public static void rmdirAsynchronously(final Activity activity, final File file, final Runnable postActions, final Context context) {
-        if (file == null)
-            return;
-        new Thread() {
-            @Override
-            public void run() {
-                int retryCounter = 5; // MAGIC_NUMBER
-                while (!FileUtil.rmdir(file, context) && retryCounter > 0) {
-                    try {
-                        Thread.sleep(100); // MAGIC_NUMBER
-                    } catch (InterruptedException e) {
-                        // do nothing
-                    }
-                    retryCounter--;
-                }
-                if (file.exists()) {
-           /*         DialogUtil.displayError(activity, R.string.message_dialog_failed_to_delete_folder, false,
-                            file.getAbsolutePath());
-           */
-                } else {
-                    activity.runOnUiThread(postActions);
-                }
-
-            }
-        }.start();
-    }
-
     /**
      * Check if a file is readable.
      *
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/HFile.java b/app/src/main/java/com/amaze/filemanager/filesystem/HybridFile.java
similarity index 87%
rename from app/src/main/java/com/amaze/filemanager/filesystem/HFile.java
rename to app/src/main/java/com/amaze/filemanager/filesystem/HybridFile.java
index e0050ef37..94f05d939 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/HFile.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/HybridFile.java
@@ -9,22 +9,24 @@ import android.util.Log;
 
 import com.amaze.filemanager.database.CloudHandler;
 import com.amaze.filemanager.exceptions.CloudPluginException;
-import com.amaze.filemanager.exceptions.RootNotPermittedException;
+import com.amaze.filemanager.exceptions.ShellNotRunningException;
 import com.amaze.filemanager.fragments.MainFragment;
 import com.amaze.filemanager.services.ssh.SFtpClientTemplate;
 import com.amaze.filemanager.services.ssh.SshClientSessionTemplate;
 import com.amaze.filemanager.services.ssh.SshClientTemplate;
 import com.amaze.filemanager.services.ssh.SshClientUtils;
-import com.amaze.filemanager.ui.LayoutElement;
+import com.amaze.filemanager.ui.LayoutElementParcelable;
 import com.amaze.filemanager.ui.icons.Icons;
-import com.amaze.filemanager.utils.AppConfig;
+import com.amaze.filemanager.utils.RootUtils;
+import com.amaze.filemanager.utils.application.AppConfig;
 import com.amaze.filemanager.utils.DataUtils;
-import com.amaze.filemanager.utils.Logger;
 import com.amaze.filemanager.utils.OTGUtil;
+import com.amaze.filemanager.utils.OnFileFound;
 import com.amaze.filemanager.utils.OpenMode;
-import com.amaze.filemanager.utils.RootUtils;
+
 import com.amaze.filemanager.utils.cloud.CloudUtil;
-import com.amaze.filemanager.utils.files.Futils;
+import com.amaze.filemanager.utils.files.FileUtils;
+
 import com.amaze.filemanager.utils.provider.UtilitiesProviderInterface;
 import com.cloudrail.si.interfaces.CloudStorage;
 import com.cloudrail.si.types.SpaceAllocation;
@@ -56,7 +58,7 @@ import jcifs.smb.SmbFile;
  * Created by Arpit on 07-07-2015.
  */
 //Hybrid file for handeling all types of files
-public class HFile {
+public class HybridFile {
 
     private static final String TAG = "HFile";
 
@@ -66,12 +68,12 @@ public class HFile {
 
     private DataUtils dataUtils = DataUtils.getInstance();
 
-    public HFile(OpenMode mode, String path) {
+    public HybridFile(OpenMode mode, String path) {
         this.path = path;
         this.mode = mode;
     }
 
-    public HFile(OpenMode mode, String path, String name, boolean isDirectory) {
+    public HybridFile(OpenMode mode, String path, String name, boolean isDirectory) {
         this.mode = mode;
         if (path.startsWith("smb://") || isSmb()) {
             if (!isDirectory) this.path = path + name;
@@ -100,24 +102,26 @@ public class HFile {
             mode = OpenMode.GDRIVE;
         } else if (path.startsWith(CloudHandler.CLOUD_PREFIX_DROPBOX)) {
             mode = OpenMode.DROPBOX;
+        } else if(context == null) {
+            mode = OpenMode.FILE;
         } else {
-            if (context == null) {
-                mode = OpenMode.FILE;
-                return;
-            }
             boolean rootmode = PreferenceManager.getDefaultSharedPreferences(context).getBoolean("rootMode", false);
             if (Build.VERSION.SDK_INT < Build.VERSION_CODES.KITKAT) {
                 mode = OpenMode.FILE;
-                if (rootmode) {
-                    if (!getFile().canRead()) mode = OpenMode.ROOT;
+                if (rootmode && !getFile().canRead()) {
+                    mode = OpenMode.ROOT;
+                }
+            } else {
+                if (FileUtil.isOnExtSdCard(getFile(), context)) {
+                    mode = OpenMode.FILE;
+                } else if (rootmode && !getFile().canRead()) {
+                    mode = OpenMode.ROOT;
+                }
+
+                if (mode == OpenMode.UNKNOWN) {
+                    mode = OpenMode.FILE;
                 }
-                return;
-            }
-            if (FileUtil.isOnExtSdCard(getFile(), context)) mode = OpenMode.FILE;
-            else if (rootmode) {
-                if (!getFile().canRead()) mode = OpenMode.ROOT;
             }
-            if (mode == OpenMode.UNKNOWN) mode = OpenMode.FILE;
         }
 
     }
@@ -172,15 +176,9 @@ public class HFile {
         return new File(path);
     }
 
-    BaseFile generateBaseFileFromParent() {
-        ArrayList<BaseFile> arrayList = null;
-        try {
-            arrayList = RootHelper.getFilesList(getFile().getParent(), true, true, null);
-        } catch (RootNotPermittedException e) {
-            e.printStackTrace();
-            return null;
-        }
-        for (BaseFile baseFile : arrayList) {
+    HybridFileParcelable generateBaseFileFromParent() {
+        ArrayList<HybridFileParcelable> arrayList = RootHelper.getFilesList(getFile().getParent(), true, true, null);
+        for (HybridFileParcelable baseFile : arrayList) {
             if (baseFile.getPath().equals(path))
                 return baseFile;
         }
@@ -206,7 +204,7 @@ public class HFile {
                 new File(path).lastModified();
                 break;
             case ROOT:
-                BaseFile baseFile = generateBaseFileFromParent();
+                HybridFileParcelable baseFile = generateBaseFileFromParent();
                 if (baseFile != null)
                     return baseFile.getDate();
         }
@@ -239,7 +237,7 @@ public class HFile {
                 s = new File(path).length();
                 return s;
             case ROOT:
-                BaseFile baseFile = generateBaseFileFromParent();
+                HybridFileParcelable baseFile = generateBaseFileFromParent();
                 if (baseFile != null) return baseFile.getSize();
                 break;
         }
@@ -256,7 +254,7 @@ public class HFile {
         long s = 0l;
         switch (mode){
             case SFTP:
-                return ((BaseFile)this).getSize();
+                return ((HybridFileParcelable)this).getSize();
             case SMB:
                 SmbFile smbFile=getSmbFile();
                 if(smbFile!=null)
@@ -269,7 +267,7 @@ public class HFile {
                 s = new File(path).length();
                 return s;
             case ROOT:
-                BaseFile baseFile=generateBaseFileFromParent();
+                HybridFileParcelable baseFile=generateBaseFileFromParent();
                 if(baseFile!=null) return baseFile.getSize();
                 break;
             case OTG:
@@ -469,7 +467,7 @@ public class HFile {
             case ROOT:
                 try {
                     isDirectory = RootHelper.isDirectory(path, true, 5);
-                } catch (RootNotPermittedException e) {
+                } catch (ShellNotRunningException e) {
                     e.printStackTrace();
                     isDirectory = false;
                 }
@@ -520,7 +518,7 @@ public class HFile {
             case ROOT:
                 try {
                     isDirectory = RootHelper.isDirectory(path,true,5);
-                } catch (RootNotPermittedException e) {
+                } catch (ShellNotRunningException e) {
                     e.printStackTrace();
                     isDirectory = false;
                 }
@@ -571,17 +569,17 @@ public class HFile {
                 });
             case SMB:
                 try {
-                    size = Futils.folderSize(new SmbFile(path));
+                    size = FileUtils.folderSize(new SmbFile(path));
                 } catch (MalformedURLException e) {
                     size = 0L;
                     e.printStackTrace();
                 }
                 break;
             case FILE:
-                size = Futils.folderSize(new File(path), null);
+                size = FileUtils.folderSize(new File(path), null);
                 break;
             case ROOT:
-                BaseFile baseFile = generateBaseFileFromParent();
+                HybridFileParcelable baseFile = generateBaseFileFromParent();
                 if (baseFile != null) size = baseFile.getSize();
                 break;
             default:
@@ -625,27 +623,27 @@ public class HFile {
                 });
             case SMB:
                 try {
-                    size = Futils.folderSize(new SmbFile(path));
+                    size = FileUtils.folderSize(new SmbFile(path));
                 } catch (MalformedURLException e) {
                     size = 0l;
                     e.printStackTrace();
                 }
                 break;
             case FILE:
-                size = Futils.folderSize(new File(path), null);
+                size = FileUtils.folderSize(new File(path), null);
                 break;
             case ROOT:
-                BaseFile baseFile=generateBaseFileFromParent();
+                HybridFileParcelable baseFile=generateBaseFileFromParent();
                 if(baseFile!=null) size = baseFile.getSize();
                 break;
             case OTG:
-                size = Futils.folderSize(path, context);
+                size = FileUtils.otgFolderSize(path, context);
                 break;
             case DROPBOX:
             case BOX:
             case GDRIVE:
             case ONEDRIVE:
-                size = Futils.folderSizeCloud(mode,
+                size = FileUtils.folderSizeCloud(mode,
                         dataUtils.getAccount(mode).getMetadata(CloudUtil.stripPath(mode, path)));
                 break;
             default:
@@ -770,64 +768,88 @@ public class HFile {
     }
 
     /**
-     * @deprecated use {@link #listFiles(Context, boolean)}
-     * @param rootmode
-     * @return
+     * Helper method to list children of this file
      */
-    public ArrayList<BaseFile> listFiles(boolean rootmode) {
-        ArrayList<BaseFile> arrayList = new ArrayList<>();
-        if (isSmb()) {
-            try {
-                SmbFile smbFile = new SmbFile(path);
-                for (SmbFile smbFile1 : smbFile.listFiles()) {
-                    BaseFile baseFile = new BaseFile(smbFile1.getPath());
-                    baseFile.setName(smbFile1.getName());
-                    baseFile.setMode(OpenMode.SMB);
-                    baseFile.setDirectory(smbFile1.isDirectory());
-                    baseFile.setDate(smbFile1.lastModified());
-                    baseFile.setSize(baseFile.isDirectory() ? 0 : smbFile1.length());
-                    arrayList.add(baseFile);
+    public void forEachChildrenFile(Context context, boolean isRoot, OnFileFound onFileFound) {
+        switch (mode) {
+            case SFTP:
+                try {
+                    SshClientUtils.execute(new SFtpClientTemplate(path) {
+                        @Override
+                        public Void execute(SFTPClient client) throws IOException {
+                            try {
+                                for (RemoteResourceInfo info : client.ls(SshClientUtils.extractRemotePathFrom(path))) {
+                                    HybridFileParcelable f = new HybridFileParcelable(String.format("%s/%s", path, info.getName()));
+                                    f.setName(info.getName());
+                                    f.setMode(OpenMode.SFTP);
+                                    f.setDirectory(info.isDirectory());
+                                    f.setDate(info.getAttributes().getMtime() * 1000);
+                                    f.setSize(f.isDirectory() ? 0 : info.getAttributes().getSize());
+                                    f.setPermission(Integer.toString(FilePermission.toMask(info.getAttributes().getPermissions()), 8));
+                                    onFileFound.onFileFound(f);
+                                }
+                            } catch (IOException e) {
+                                Log.w("DEBUG.listFiles", "IOException", e);
+                            }
+                            return null;
+                        }
+                    });
+                } catch(Exception e){
+                    e.printStackTrace();
                 }
-            } catch (MalformedURLException e) {
-                if (arrayList != null) arrayList.clear();
-                e.printStackTrace();
-            } catch (SmbException e) {
-                if (arrayList != null) arrayList.clear();
-                e.printStackTrace();
-            }
-        } else if (isSftp()) {
-            Log.d(TAG, "Listing file at [" + path + "]");
-        } else if (isOtgFile()) {
+                break;
+            case SMB:
+                try {
+                    SmbFile smbFile = new SmbFile(path);
+                    for (SmbFile smbFile1 : smbFile.listFiles()) {
+                        HybridFileParcelable baseFile=new HybridFileParcelable(smbFile1.getPath());
+                        baseFile.setName(smbFile1.getName());
+                        baseFile.setMode(OpenMode.SMB);
+                        baseFile.setDirectory(smbFile1.isDirectory());
+                        baseFile.setDate(smbFile1.lastModified());
+                        baseFile.setSize(baseFile.isDirectory()?0:smbFile1.length());
+                        onFileFound.onFileFound(baseFile);
+                    }
+                } catch (MalformedURLException | SmbException e) {
+                    e.printStackTrace();
+                }
+                break;
+            case OTG:
+                OTGUtil.getDocumentFiles(path, context, onFileFound);
+                break;
+            case DROPBOX:
+            case BOX:
+            case GDRIVE:
+            case ONEDRIVE:
+                try {
+                    CloudUtil.getCloudFiles(path, dataUtils.getAccount(mode), mode, onFileFound);
+                } catch (CloudPluginException e) {
+                    e.printStackTrace();
+                }
+                break;
+            default:
+                RootHelper.getFiles(path, isRoot, true, null, onFileFound);
 
-        } else {
-            try {
-                arrayList = RootHelper.getFilesList(path, rootmode, true, null);
-            } catch (RootNotPermittedException e) {
-                e.printStackTrace();
-            }
         }
-        return arrayList;
     }
 
     /**
      * Helper method to list children of this file
-     *
-     * @param context
-     * @return
+     * @deprecated use forEachChildrenFile()
      */
-    public ArrayList<BaseFile> listFiles(Context context, boolean isRoot) {
-        ArrayList<BaseFile> arrayList = new ArrayList<>();
+    public ArrayList<HybridFileParcelable> listFiles(Context context, boolean isRoot) {
+        ArrayList<HybridFileParcelable> arrayList = new ArrayList<>();
         switch (mode) {
             case SFTP:
                 try {
                     arrayList = SshClientUtils.execute(new SFtpClientTemplate(path) {
                         @Override
-                        public ArrayList<BaseFile> execute(SFTPClient client) throws IOException {
-                            ArrayList<BaseFile> retval = new ArrayList<BaseFile>();
+                        public ArrayList<HybridFileParcelable> execute(SFTPClient client) throws IOException {
+                            ArrayList<HybridFileParcelable> retval = new ArrayList<HybridFileParcelable>();
                             Log.d("DEBUG.listFiles", "ls " + SshClientUtils.extractRemotePathFrom(path));
                             try {
                                 for (RemoteResourceInfo info : client.ls(SshClientUtils.extractRemotePathFrom(path))) {
-                                    BaseFile f = new BaseFile(String.format("%s/%s", path, info.getName()));
+                                    HybridFileParcelable f = new HybridFileParcelable(String.format("%s/%s", path, info.getName()));
                                     f.setName(info.getName());
                                     f.setMode(OpenMode.SFTP);
                                     f.setDirectory(info.isDirectory());
@@ -851,7 +873,7 @@ public class HFile {
                 try {
                     SmbFile smbFile = new SmbFile(path);
                     for (SmbFile smbFile1 : smbFile.listFiles()) {
-                        BaseFile baseFile=new BaseFile(smbFile1.getPath());
+                        HybridFileParcelable baseFile=new HybridFileParcelable(smbFile1.getPath());
                         baseFile.setName(smbFile1.getName());
                         baseFile.setMode(OpenMode.SMB);
                         baseFile.setDirectory(smbFile1.isDirectory());
@@ -871,50 +893,19 @@ public class HFile {
                 arrayList = OTGUtil.getDocumentFilesList(path, context);
                 break;
             case DROPBOX:
-                try {
-
-                    arrayList = CloudUtil.listFiles(path, dataUtils.getAccount(OpenMode.DROPBOX), OpenMode.DROPBOX);
-                } catch (CloudPluginException e) {
-                    e.printStackTrace();
-
-                    arrayList = new ArrayList<>();
-                }
-                break;
             case BOX:
-                try {
-
-                    arrayList = CloudUtil.listFiles(path, dataUtils.getAccount(OpenMode.BOX), OpenMode.BOX);
-                } catch (CloudPluginException e) {
-                    e.printStackTrace();
-                    arrayList = new ArrayList<>();
-                }
-                break;
             case GDRIVE:
-                try {
-
-                    arrayList = CloudUtil.listFiles(path, dataUtils.getAccount(OpenMode.GDRIVE), OpenMode.GDRIVE);
-                } catch (CloudPluginException e) {
-                    e.printStackTrace();
-
-                    arrayList = new ArrayList<>();
-                }
-                break;
             case ONEDRIVE:
                 try {
-
-                    arrayList = CloudUtil.listFiles(path, dataUtils.getAccount(OpenMode.ONEDRIVE), OpenMode.ONEDRIVE);
+                    arrayList = CloudUtil.listFiles(path, dataUtils.getAccount(mode), mode);
                 } catch (CloudPluginException e) {
                     e.printStackTrace();
-
                     arrayList = new ArrayList<>();
                 }
                 break;
             default:
-                try {
-                    arrayList = RootHelper.getFilesList(path, isRoot, true, null);
-                } catch (RootNotPermittedException e) {
-                    e.printStackTrace();
-                }
+                arrayList = RootHelper.getFilesList(path, isRoot, true, null);
+
         }
 
         return arrayList;
@@ -1155,7 +1146,7 @@ public class HFile {
         } else if (isRoot()) {
             try {
                 return RootHelper.fileExists(path);
-            } catch (RootNotPermittedException e) {
+            } catch (ShellNotRunningException e) {
                 e.printStackTrace();
                 return false;
             }
@@ -1223,7 +1214,7 @@ public class HFile {
             try {
                 new SmbFile(path).mkdirs();
             } catch (SmbException | MalformedURLException e) {
-                Logger.log(e, path, context);
+                e.printStackTrace();
             }
         } else if (isOtgFile()) {
             if (!exists(context)) {
@@ -1268,7 +1259,7 @@ public class HFile {
             FileUtil.mkdir(new File(path), context);
     }
 
-    public boolean delete(Context context, boolean rootmode) throws RootNotPermittedException {
+    public boolean delete(Context context, boolean rootmode) throws ShellNotRunningException {
         if (isSftp()) {
             SshClientUtils.execute(new SFtpClientTemplate(path) {
                 @Override
@@ -1282,7 +1273,7 @@ public class HFile {
             try {
                 new SmbFile(path).delete();
             } catch (SmbException | MalformedURLException e) {
-                Logger.log(e, path, context);
+                e.printStackTrace();
             }
         } else {
             if (isRoot() && rootmode) {
@@ -1311,27 +1302,26 @@ public class HFile {
     }
 
     /**
-     * Generates a {@link LayoutElement} adapted compatible element.
+     * Generates a {@link LayoutElementParcelable} adapted compatible element.
      * Currently supports only local filesystem
      * @param mainFragment
      * @param utilitiesProvider
      * @return
      */
-    public LayoutElement generateLayoutElement(MainFragment mainFragment, UtilitiesProviderInterface utilitiesProvider) {
+    public LayoutElementParcelable generateLayoutElement(MainFragment mainFragment, UtilitiesProviderInterface utilitiesProvider) {
         switch (mode) {
             case FILE:
             case ROOT:
                 File file = new File(path);
-                LayoutElement layoutElement;
+                LayoutElementParcelable layoutElement;
                 if (isDirectory()) {
 
-                    layoutElement = utilitiesProvider.getFutils()
-                            .newElement(mainFragment.folder,
+                    layoutElement = new LayoutElementParcelable(mainFragment.folder,
                                     path, RootHelper.parseFilePermission(file),
                                     "", folderSize() + "", 0, true, false,
                                     file.lastModified() + "");
                 } else {
-                    layoutElement = utilitiesProvider.getFutils().newElement(Icons.loadMimeIcon(
+                    layoutElement = new LayoutElementParcelable(Icons.loadMimeIcon(
                             file.getPath(), !mainFragment.IS_LIST, mainFragment.getResources()),
                             file.getPath(), RootHelper.parseFilePermission(file),
                             file.getPath(), file.length() + "", file.length(), false, false, file.lastModified() + "");
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/BaseFile.java b/app/src/main/java/com/amaze/filemanager/filesystem/HybridFileParcelable.java
similarity index 79%
rename from app/src/main/java/com/amaze/filemanager/filesystem/BaseFile.java
rename to app/src/main/java/com/amaze/filemanager/filesystem/HybridFileParcelable.java
index b8ae65c6f..faa6c6b54 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/BaseFile.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/HybridFileParcelable.java
@@ -8,7 +8,7 @@ import com.amaze.filemanager.utils.OpenMode;
 /**
  * Created by arpitkh996 on 11-01-2016.
  */
-public class BaseFile extends HFile implements Parcelable {
+public class HybridFileParcelable extends HybridFile implements Parcelable {
 
     private long date, size;
     private boolean isDirectory;
@@ -16,12 +16,12 @@ public class BaseFile extends HFile implements Parcelable {
     private String name;
     private String link = "";
 
-    public BaseFile(String path) {
+    public HybridFileParcelable(String path) {
         super(OpenMode.FILE, path);
         this.path = path;
     }
 
-    public BaseFile(String path, String permission, long date, long size, boolean isDirectory) {
+    public HybridFileParcelable(String path, String permission, long date, long size, boolean isDirectory) {
         super(OpenMode.FILE, path);
         this.date = date;
         this.size = size;
@@ -93,7 +93,7 @@ public class BaseFile extends HFile implements Parcelable {
         this.permission = permission;
     }
 
-    protected BaseFile(Parcel in) {
+    protected HybridFileParcelable(Parcel in) {
         super(OpenMode.getOpenMode(in.readInt()), in.readString());
         permission = in.readString();
         name = in.readString();
@@ -103,15 +103,15 @@ public class BaseFile extends HFile implements Parcelable {
 
     }
 
-    public static final Creator<BaseFile> CREATOR = new Creator<BaseFile>() {
+    public static final Creator<HybridFileParcelable> CREATOR = new Creator<HybridFileParcelable>() {
         @Override
-        public BaseFile createFromParcel(Parcel in) {
-            return new BaseFile(in);
+        public HybridFileParcelable createFromParcel(Parcel in) {
+            return new HybridFileParcelable(in);
         }
 
         @Override
-        public BaseFile[] newArray(int size) {
-            return new BaseFile[size];
+        public HybridFileParcelable[] newArray(int size) {
+            return new HybridFileParcelable[size];
         }
     };
 
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/Operations.java b/app/src/main/java/com/amaze/filemanager/filesystem/Operations.java
index 2db31b0be..efa246871 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/Operations.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/Operations.java
@@ -7,14 +7,13 @@ import android.support.annotation.NonNull;
 import android.support.v4.provider.DocumentFile;
 import android.util.Log;
 
-import com.amaze.filemanager.exceptions.RootNotPermittedException;
+import com.amaze.filemanager.exceptions.ShellNotRunningException;
 import com.amaze.filemanager.utils.DataUtils;
-import com.amaze.filemanager.utils.cloud.CloudUtil;
-import com.amaze.filemanager.utils.Logger;
 import com.amaze.filemanager.utils.MainActivityHelper;
 import com.amaze.filemanager.utils.OTGUtil;
 import com.amaze.filemanager.utils.OpenMode;
 import com.amaze.filemanager.utils.RootUtils;
+import com.amaze.filemanager.utils.cloud.CloudUtil;
 import com.cloudrail.si.interfaces.CloudStorage;
 
 import java.io.ByteArrayInputStream;
@@ -51,7 +50,7 @@ public class Operations {
          *
          * @param file
          */
-        void exists(HFile file);
+        void exists(HybridFile file);
 
         /**
          * Callback fired when creating new file/directory and required storage access framework permission
@@ -59,7 +58,7 @@ public class Operations {
          *
          * @param file
          */
-        void launchSAF(HFile file);
+        void launchSAF(HybridFile file);
 
         /**
          * Callback fired when renaming file and required storage access framework permission to access
@@ -68,7 +67,7 @@ public class Operations {
          * @param file
          * @param file1
          */
-        void launchSAF(HFile file, HFile file1);
+        void launchSAF(HybridFile file, HybridFile file1);
 
         /**
          * Callback fired when we're done processing the operation
@@ -76,17 +75,17 @@ public class Operations {
          * @param hFile
          * @param b     defines whether operation was successful
          */
-        void done(HFile hFile, boolean b);
+        void done(HybridFile hFile, boolean b);
 
         /**
          * Callback fired when an invalid file name is found.
          *
          * @param file
          */
-        void invalidName(HFile file);
+        void invalidName(HybridFile file);
     }
 
-    public static void mkdir(@NonNull final HFile file, final Context context, final boolean rootMode,
+    public static void mkdir(@NonNull final HybridFile file, final Context context, final boolean rootMode,
                              @NonNull final ErrorCallBack errorCallBack) {
 
         new AsyncTask<Void, Void, Void>() {
@@ -114,7 +113,7 @@ public class Operations {
                     try {
                         file.getSmbFile(2000).mkdirs();
                     } catch (SmbException e) {
-                        Logger.log(e, file.getPath(), context);
+                        e.printStackTrace();
                         errorCallBack.done(file, false);
                         return null;
                     }
@@ -183,8 +182,8 @@ public class Operations {
                             try {
 
                                 RootUtils.mkDir(file.getParent(context), file.getName(context));
-                            } catch (RootNotPermittedException e) {
-                                Logger.log(e, file.getPath(), context);
+                            } catch (ShellNotRunningException e) {
+                                e.printStackTrace();
                             }
                             errorCallBack.done(file, file.exists());
                             return null;
@@ -201,7 +200,7 @@ public class Operations {
 
     }
 
-    public static void mkfile(@NonNull final HFile file, final Context context, final boolean rootMode,
+    public static void mkfile(@NonNull final HybridFile file, final Context context, final boolean rootMode,
                               @NonNull final ErrorCallBack errorCallBack) {
 
         new AsyncTask<Void, Void, Void>() {
@@ -235,7 +234,7 @@ public class Operations {
                     try {
                         file.getSmbFile(2000).createNewFile();
                     } catch (SmbException e) {
-                        Logger.log(e, file.getPath(), context);
+                        e.printStackTrace();
                         errorCallBack.done(file, false);
                         return null;
                     }
@@ -320,8 +319,8 @@ public class Operations {
                             try {
 
                                 RootUtils.mkFile(file.getPath());
-                            } catch (RootNotPermittedException e) {
-                                Logger.log(e, file.getPath(), context);
+                            } catch (ShellNotRunningException e) {
+                                e.printStackTrace();
                             }
                             errorCallBack.done(file, file.exists());
                             return null;
@@ -338,7 +337,7 @@ public class Operations {
         }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
     }
 
-    public static void rename(final HFile oldFile, final HFile newFile, final boolean rootMode,
+    public static void rename(final HybridFile oldFile, final HybridFile newFile, final boolean rootMode,
                               final Context context, final ErrorCallBack errorCallBack) {
 
         new AsyncTask<Void, Void, Void>() {
@@ -437,15 +436,15 @@ public class Operations {
                             } else if (mode == 1 || mode == 0) {
                                 try {
                                     FileUtil.renameFolder(file, file1, context);
-                                } catch (RootNotPermittedException e) {
+                                } catch (ShellNotRunningException e) {
                                     e.printStackTrace();
                                 }
                                 boolean a = !file.exists() && file1.exists();
                                 if (!a && rootMode) {
                                     try {
                                         RootUtils.rename(file.getPath(), file1.getPath());
-                                    } catch (Exception e) {
-                                        Logger.log(e, oldFile.getPath() + "\n" + newFile.getPath(), context);
+                                    } catch (ShellNotRunningException e) {
+                                        e.printStackTrace();
                                     }
                                     oldFile.setMode(OpenMode.ROOT);
                                     newFile.setMode(OpenMode.ROOT);
@@ -457,10 +456,9 @@ public class Operations {
                             break;
                         case ROOT:
                             try {
-
                                 RootUtils.rename(file.getPath(), file1.getPath());
-                            } catch (Exception e) {
-                                Logger.log(e, oldFile.getPath() + "\n" + newFile.getPath(), context);
+                            } catch (ShellNotRunningException e) {
+                                e.printStackTrace();
                             }
 
                             newFile.setMode(OpenMode.ROOT);
@@ -514,7 +512,7 @@ public class Operations {
      * @param targetFile
      * @return true when copy loop is possible
      */
-    public static boolean isCopyLoopPossible(BaseFile sourceFile, HFile targetFile) {
+    public static boolean isCopyLoopPossible(HybridFileParcelable sourceFile, HybridFile targetFile) {
         return targetFile.getPath().contains(sourceFile.getPath());
     }
 
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/PasteHelper.java b/app/src/main/java/com/amaze/filemanager/filesystem/PasteHelper.java
new file mode 100644
index 000000000..7132daa80
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/PasteHelper.java
@@ -0,0 +1,52 @@
+package com.amaze.filemanager.filesystem;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * Special immutable class for handling cut/copy operations.
+ *
+ * @author Emmanuel
+ *         on 5/9/2017, at 09:59.
+ */
+
+public final class PasteHelper implements Parcelable {
+
+    public static final int OPERATION_COPY = 0, OPERATION_CUT = 1;
+
+    public final int operation;
+    public final HybridFileParcelable[] paths;
+
+    public PasteHelper(int op, HybridFileParcelable[] paths) {
+        if(paths == null || paths.length == 0) throw new IllegalArgumentException();
+        operation = op;
+        this.paths = paths;
+    }
+
+    private PasteHelper(Parcel in) {
+        operation = in.readInt();
+        paths = (HybridFileParcelable[]) in.readParcelableArray(HybridFileParcelable.class.getClassLoader());
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(operation);
+        dest.writeParcelableArray(paths, 0);
+    }
+
+    public static final Parcelable.Creator CREATOR = new Parcelable.Creator() {
+        public PasteHelper createFromParcel(Parcel in) {
+            return new PasteHelper(in);
+        }
+
+        public PasteHelper[] newArray(int size) {
+            return new PasteHelper[size];
+        }
+    };
+
+}
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/RootHelper.java b/app/src/main/java/com/amaze/filemanager/filesystem/RootHelper.java
index af629c9fb..8c3f04453 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/RootHelper.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/RootHelper.java
@@ -19,17 +19,13 @@
 
 package com.amaze.filemanager.filesystem;
 
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.net.Uri;
-import android.preference.PreferenceManager;
 import android.support.v4.provider.DocumentFile;
-import android.util.Log;
 
 import com.amaze.filemanager.activities.MainActivity;
-import com.amaze.filemanager.exceptions.RootNotPermittedException;
-import com.amaze.filemanager.utils.files.Futils;
+import com.amaze.filemanager.exceptions.ShellNotRunningException;
+import com.amaze.filemanager.utils.OnFileFound;
 import com.amaze.filemanager.utils.OpenMode;
+import com.amaze.filemanager.utils.files.FileUtils;
 
 import java.io.File;
 import java.util.ArrayList;
@@ -47,21 +43,16 @@ public class RootHelper {
      * @param cmd the command
      * @return a list of results. Null only if the command passed is a blocking call or no output is
      * there for the command passed
-     * @throws RootNotPermittedException
      */
-    public static ArrayList<String> runShellCommand(String cmd) throws RootNotPermittedException {
+    public static ArrayList<String> runShellCommand(String cmd) throws ShellNotRunningException {
         if (MainActivity.shellInteractive == null || !MainActivity.shellInteractive.isRunning())
-            throw new RootNotPermittedException();
+            throw new ShellNotRunningException();
         final ArrayList<String> result = new ArrayList<>();
 
         // callback being called on a background handler thread
-        MainActivity.shellInteractive.addCommand(cmd, 0, new Shell.OnCommandResultListener() {
-            @Override
-            public void onCommandResult(int commandCode, int exitCode, List<String> output) {
-
-                for (String line : output) {
-                    result.add(line);
-                }
+        MainActivity.shellInteractive.addCommand(cmd, 0, (commandCode, exitCode, output) -> {
+            for (String line : output) {
+                result.add(line);
             }
         });
         MainActivity.shellInteractive.waitForIdle();
@@ -78,12 +69,11 @@ public class RootHelper {
      * @param callback
      * @return a list of results. Null only if the command passed is a blocking call or no output is
      * there for the command passed
-     * @throws RootNotPermittedException
      */
     public static void runShellCommand(String cmd, Shell.OnCommandResultListener callback)
-            throws RootNotPermittedException {
+            throws ShellNotRunningException {
         if (MainActivity.shellInteractive == null || !MainActivity.shellInteractive.isRunning())
-            throw new RootNotPermittedException();
+            throw new ShellNotRunningException();
         MainActivity.shellInteractive.addCommand(cmd, 0, callback);
         MainActivity.shellInteractive.waitForIdle();
     }
@@ -92,7 +82,7 @@ public class RootHelper {
      * @param cmd the command
      * @return a list of results. Null only if the command passed is a blocking call or no output is
      * there for the command passed
-     * @throws RootNotPermittedException
+     * @throws ShellNotRunningException
      * @deprecated Use {@link #runShellCommand(String)} instead which runs command on an interactive shell
      * <p>
      * Runs the command and stores output in a list. The listener is set on the caller thread,
@@ -117,23 +107,25 @@ public class RootHelper {
      * @param showHidden
      * @return
      */
-    public static ArrayList<BaseFile> getFilesList(String path, boolean showHidden) {
+    public static ArrayList<HybridFileParcelable> getFilesList(String path, boolean showHidden, OnFileFound listener) {
         File f = new File(path);
-        ArrayList<BaseFile> files = new ArrayList<>();
+        ArrayList<HybridFileParcelable> files = new ArrayList<>();
         try {
             if (f.exists() && f.isDirectory()) {
                 for (File x : f.listFiles()) {
                     long size = 0;
                     if (!x.isDirectory()) size = x.length();
-                    BaseFile baseFile = new BaseFile(x.getPath(), parseFilePermission(x),
+                    HybridFileParcelable baseFile = new HybridFileParcelable(x.getPath(), parseFilePermission(x),
                             x.lastModified(), size, x.isDirectory());
                     baseFile.setName(x.getName());
                     baseFile.setMode(OpenMode.FILE);
                     if (showHidden) {
                         files.add(baseFile);
+                        listener.onFileFound(baseFile);
                     } else {
                         if (!x.isHidden()) {
                             files.add(baseFile);
+                            listener.onFileFound(baseFile);
                         }
                     }
                 }
@@ -143,11 +135,11 @@ public class RootHelper {
         return files;
     }
 
-    public static BaseFile generateBaseFile(File x, boolean showHidden) {
+    public static HybridFileParcelable generateBaseFile(File x, boolean showHidden) {
         long size = 0;
         if (!x.isDirectory())
             size = x.length();
-        BaseFile baseFile = new BaseFile(x.getPath(), parseFilePermission(x), x.lastModified(), size, x.isDirectory());
+        HybridFileParcelable baseFile = new HybridFileParcelable(x.getPath(), parseFilePermission(x), x.lastModified(), size, x.isDirectory());
         baseFile.setName(x.getName());
         baseFile.setMode(OpenMode.FILE);
         if (showHidden) {
@@ -158,11 +150,11 @@ public class RootHelper {
         return null;
     }
 
-    public static BaseFile generateBaseFile(DocumentFile file, boolean showHidden) {
+    public static HybridFileParcelable generateBaseFile(DocumentFile file, boolean showHidden) {
         long size = 0;
         if (!file.isDirectory())
             size = file.length();
-        BaseFile baseFile = new BaseFile(file.getName(), parseDocumentFilePermission(file),
+        HybridFileParcelable baseFile = new HybridFileParcelable(file.getName(), parseDocumentFilePermission(file),
                 file.lastModified(), size, file.isDirectory());
         baseFile.setName(file.getName());
         baseFile.setMode(OpenMode.OTG);
@@ -204,19 +196,14 @@ public class RootHelper {
      *
      * @param path
      * @return
-     * @throws RootNotPermittedException
+     * @throws ShellNotRunningException
      */
-    public static boolean fileExists(String path) throws RootNotPermittedException {
+    public static boolean fileExists(String path) throws ShellNotRunningException {
         File f = new File(path);
         String p = f.getParent();
         if (p != null && p.length() > 0) {
-            ArrayList<BaseFile> ls = getFilesList(p, true, true, new GetModeCallBack() {
-                @Override
-                public void getMode(OpenMode mode) {
-
-                }
-            });
-            for (BaseFile strings : ls) {
+            ArrayList<HybridFileParcelable> ls = getFilesList(p, true, true, null);
+            for (HybridFileParcelable strings : ls) {
                 if (strings.getPath() != null && strings.getPath().equals(path)) {
                     return true;
                 }
@@ -243,7 +230,7 @@ public class RootHelper {
      * @return TODO: Avoid parsing ls
      */
     public static boolean isDirectory(String toTest, boolean root, int count)
-            throws RootNotPermittedException {
+            throws ShellNotRunningException {
         File f = new File(toTest);
         String name = f.getName();
         String p = f.getParent();
@@ -252,7 +239,7 @@ public class RootHelper {
             for (String s : ls) {
                 if (contains(s.split(" "), name)) {
                     try {
-                        BaseFile path = Futils.parseName(s);
+                        HybridFileParcelable path = FileUtils.parseName(s);
                         if (path.getPermission().trim().startsWith("d")) return true;
                         else if (path.getPermission().trim().startsWith("l")) {
                             if (count > 5)
@@ -271,7 +258,7 @@ public class RootHelper {
         return f.isDirectory();
     }
 
-    private static boolean isDirectory(BaseFile path) {
+    private static boolean isDirectory(HybridFileParcelable path) {
         return path.getPermission().startsWith("d") || new File(path.getPath()).isDirectory();
     }
 
@@ -290,67 +277,80 @@ public class RootHelper {
      * @param showHidden      to show hidden files
      * @param getModeCallBack callback to set the type of file
      * @return TODO: Avoid parsing ls
+     * @deprecated use getFiles()
      */
-    public static ArrayList<BaseFile> getFilesList(String path, boolean root, boolean showHidden,
-                                                   GetModeCallBack getModeCallBack)
-            throws RootNotPermittedException {
-        //String p = " ";
+    public static ArrayList<HybridFileParcelable> getFilesList(String path, boolean root, boolean showHidden,
+                                                               GetModeCallBack getModeCallBack) {
+        final ArrayList<HybridFileParcelable> files = new ArrayList<>();
+        getFiles(path, root, showHidden, getModeCallBack, new OnFileFound() {
+            @Override
+            public void onFileFound(HybridFileParcelable file) {
+                files.add(file);
+            }
+        });
+        return files;
+    }
+
+    /**
+     * Get files using shell, supposing the path is not a SMB/OTG/Custom (*.apk/images)
+     *
+     * @param path
+     * @param root            whether root is available or not
+     * @param showHidden      to show hidden files
+     * @param getModeCallBack callback to set the type of file
+     * @return TODO: Avoid parsing ls
+     */
+    public static void getFiles(String path, boolean root, boolean showHidden,
+                                GetModeCallBack getModeCallBack, OnFileFound fileCallback) {
         OpenMode mode = OpenMode.FILE;
-        //if (showHidden) p = "a ";
-        ArrayList<BaseFile> files = new ArrayList<>();
-        ArrayList<String> ls;
-        if (root) {
-            // we're rooted and we're trying to load file with superuser
-            if (!path.startsWith("/storage") && !path.startsWith("/sdcard")) {
+        ArrayList<HybridFileParcelable> files = new ArrayList<>();
+        if (root && !path.startsWith("/storage") && !path.startsWith("/sdcard")) {
+            try {
+                // we're rooted and we're trying to load file with superuser
                 // we're at the root directories, superuser is required!
+                ArrayList<String> ls;
                 String cpath = getCommandLineString(path);
                 //ls = Shell.SU.run("ls -l " + cpath);
                 ls = runShellCommand("ls -l " + (showHidden ? "-a " : "") + "\"" + cpath + "\"");
                 if (ls != null) {
                     for (int i = 0; i < ls.size(); i++) {
                         String file = ls.get(i);
-                        if (!file.contains("Permission denied"))
-                            try {
-                                BaseFile array = Futils.parseName(file);
+                        if (!file.contains("Permission denied")) {
+                            HybridFileParcelable array = FileUtils.parseName(file);
+                            if (array != null) {
                                 array.setMode(OpenMode.ROOT);
-                                if (array != null) {
-                                    array.setName(array.getPath());
-                                    array.setPath(path + "/" + array.getPath());
-                                    if (array.getLink().trim().length() > 0) {
-                                        boolean isdirectory = isDirectory(array.getLink(), root, 0);
-                                        array.setDirectory(isdirectory);
-                                    } else array.setDirectory(isDirectory(array));
-                                    files.add(array);
-                                }
-                            } catch (Exception e) {
-                                e.printStackTrace();
+                                array.setName(array.getPath());
+                                array.setPath(path + "/" + array.getPath());
+                                if (array.getLink().trim().length() > 0) {
+                                    boolean isdirectory = isDirectory(array.getLink(), root, 0);
+                                    array.setDirectory(isdirectory);
+                                } else array.setDirectory(isDirectory(array));
+                                files.add(array);
+                                fileCallback.onFileFound(array);
                             }
+                        }
 
                     }
                     mode = OpenMode.ROOT;
                 }
-            } else if (Futils.canListFiles(new File(path))) {
-                // we might as well not require root to load files
-                files = getFilesList(path, showHidden);
-                mode = OpenMode.FILE;
-            } else {
-                // couldn't load files using native java filesystem callbacks
-                // maybe the access is not allowed due to android system restrictions, we'll see later
-                mode = OpenMode.FILE;
-                files = new ArrayList<>();
+
+                if (getModeCallBack != null) getModeCallBack.getMode(mode);
+            } catch (ShellNotRunningException e) {
+                e.printStackTrace();
             }
-        } else if (Futils.canListFiles(new File(path))) {
-            // we don't have root, so we're taking a chance to load files using basic java filesystem
-            files = getFilesList(path, showHidden);
+        }
+
+        if (FileUtils.canListFiles(new File(path))) {
+            // we're taking a chance to load files using basic java filesystem
+            getFilesList(path, showHidden, fileCallback);
             mode = OpenMode.FILE;
         } else {
-            // couldn't load files using native java filesystem callbacks
+            // we couldn't load files using native java filesystem callbacks
             // maybe the access is not allowed due to android system restrictions, we'll see later
             mode = OpenMode.FILE;
-            files = new ArrayList<>();
         }
+
         if (getModeCallBack != null) getModeCallBack.getMode(mode);
-        return files;
     }
 
 }
\ No newline at end of file
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/CompressedHelper.java b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/CompressedHelper.java
new file mode 100644
index 000000000..2f4cb109a
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/CompressedHelper.java
@@ -0,0 +1,37 @@
+package com.amaze.filemanager.filesystem.compressed;
+
+import android.content.Context;
+
+import java.io.File;
+
+/**
+ * @author Emmanuel
+ *         on 23/11/2017, at 17:46.
+ */
+
+public class CompressedHelper {
+
+    /**
+     * To add compatibility with other compressed file types edit this method
+     */
+    public static CompressedInterface getCompressedInterfaceInstance(Context context, File file) {
+        CompressedInterface compressedInterface;
+
+        String path = file.getPath().toLowerCase();
+        boolean isZip = path.endsWith(".zip") || path.endsWith(".jar") || path.endsWith(".apk");
+        boolean isTar = path.endsWith(".tar") || path.endsWith(".tar.gz");
+        boolean isRar = path.endsWith(".rar");
+
+        if (isZip || isTar) {
+            compressedInterface = new ZipHelper(context);
+        } else if (isRar) {
+            compressedInterface = new RarHelper(context);
+        } else {
+            return null;
+        }
+
+        compressedInterface.setFilePath(file.getPath());
+        return compressedInterface;
+    }
+
+}
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/CompressedInterface.java b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/CompressedInterface.java
new file mode 100644
index 000000000..efec80dbf
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/CompressedInterface.java
@@ -0,0 +1,32 @@
+package com.amaze.filemanager.filesystem.compressed;
+
+import com.amaze.filemanager.ui.CompressedObjectParcelable;
+import com.amaze.filemanager.utils.OnAsyncTaskFinished;
+
+import java.util.ArrayList;
+
+/**
+ * @author Emmanuel
+ *         on 20/11/2017, at 17:14.
+ */
+
+public interface CompressedInterface {
+    void setFilePath(String path);
+
+    /**
+     * Separator must be "/"
+     * @param path end with "/" if it is a directory, does not if it's a file
+     */
+    void changePath(String path, boolean addGoBackItem,
+                    OnAsyncTaskFinished<ArrayList<CompressedObjectParcelable>> onFinish);
+    /**
+     * Decompress a file somewhere
+     */
+    void decompress(String whereToDecompress);
+
+    /**
+     * Decompress files or dirs inside the compressed file.
+     * @param subDirectories separator is "/", ended with "/" if it is a directory, does not if it's a file
+     */
+    void decompress(String whereToDecompress, String[] subDirectories);
+}
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/RarHelper.java b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/RarHelper.java
new file mode 100644
index 000000000..e1d5be3b8
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/RarHelper.java
@@ -0,0 +1,74 @@
+package com.amaze.filemanager.filesystem.compressed;
+
+import android.content.Context;
+import android.content.Intent;
+
+import com.amaze.filemanager.asynchronous.asynctasks.RarHelperTask;
+import com.amaze.filemanager.asynchronous.services.ExtractService;
+import com.amaze.filemanager.ui.CompressedObjectParcelable;
+import com.amaze.filemanager.utils.OnAsyncTaskFinished;
+import com.amaze.filemanager.utils.ServiceWatcherUtil;
+import com.github.junrar.rarfile.FileHeader;
+
+import java.util.ArrayList;
+
+/**
+ * @author Emmanuel
+ *         on 20/11/2017, at 17:23.
+ */
+
+public class RarHelper implements CompressedInterface {
+    private Context context;
+    private String filePath;
+
+    public RarHelper(Context context) {
+        this.context = context;
+    }
+
+    @Override
+    public void setFilePath(String path) {
+        filePath = path;
+    }
+
+    @Override
+    public void changePath(String path, boolean addGoBackItem,
+                           OnAsyncTaskFinished<ArrayList<CompressedObjectParcelable>> onFinish) {
+        new RarHelperTask(filePath, path, addGoBackItem, onFinish).execute();
+    }
+
+    @Override
+    public void decompress(String whereToDecompress) {
+        Intent intent = new Intent(context, ExtractService.class);
+        intent.putExtra(ExtractService.KEY_PATH_ZIP, filePath);
+        intent.putExtra(ExtractService.KEY_ENTRIES_ZIP, new String[0]);
+        intent.putExtra(ExtractService.KEY_PATH_EXTRACT, whereToDecompress);
+        ServiceWatcherUtil.runService(context, intent);
+    }
+
+    @Override
+    public void decompress(String whereToDecompress, String[] subDirectories) {
+        for (int i = 0; i < subDirectories.length; i++) {
+            subDirectories[i] = deconvertName(subDirectories[i]);
+        }
+
+        Intent intent = new Intent(context, ExtractService.class);
+        intent.putExtra(ExtractService.KEY_PATH_ZIP, filePath);
+        intent.putExtra(ExtractService.KEY_ENTRIES_ZIP, subDirectories);
+        intent.putExtra(ExtractService.KEY_PATH_EXTRACT, whereToDecompress);
+        ServiceWatcherUtil.runService(context, intent);
+    }
+
+
+    public static String convertName(FileHeader file) {
+        String name = file.getFileNameString().replace('\\', '/');
+
+        if(file.isDirectory()) return name + "/";
+        else return name;
+    }
+
+    public static String deconvertName(String dir) {
+        if(dir.endsWith("/")) dir = dir.substring(0, dir.length()-1);
+        return dir.replace('/', '\\');
+    }
+
+}
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/ZipHelper.java b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/ZipHelper.java
new file mode 100644
index 000000000..740feeb65
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/ZipHelper.java
@@ -0,0 +1,56 @@
+package com.amaze.filemanager.filesystem.compressed;
+
+import android.content.Context;
+import android.content.Intent;
+
+import com.amaze.filemanager.asynchronous.asynctasks.ZipHelperTask;
+import com.amaze.filemanager.asynchronous.services.ExtractService;
+import com.amaze.filemanager.ui.CompressedObjectParcelable;
+import com.amaze.filemanager.utils.OnAsyncTaskFinished;
+import com.amaze.filemanager.utils.ServiceWatcherUtil;
+
+import java.util.ArrayList;
+
+/**
+ * @author Emmanuel
+ *         on 20/11/2017, at 17:19.
+ */
+
+public class ZipHelper implements CompressedInterface {
+    private String filePath;
+    private Context context;
+
+    public ZipHelper(Context context) {
+        this.context = context;
+    }
+
+    @Override
+    public void setFilePath(String path) {
+        filePath = path;
+    }
+
+    @Override
+    public void changePath(String path, boolean addGoBackItem,
+                           OnAsyncTaskFinished<ArrayList<CompressedObjectParcelable>> onFinish) {
+        new ZipHelperTask(context, filePath, path, addGoBackItem, onFinish).execute();
+    }
+
+    @Override
+    public void decompress(String whereToDecompress) {
+        Intent intent = new Intent(context, ExtractService.class);
+        intent.putExtra(ExtractService.KEY_PATH_ZIP, filePath);
+        intent.putExtra(ExtractService.KEY_ENTRIES_ZIP, new String[0]);
+        intent.putExtra(ExtractService.KEY_PATH_EXTRACT, whereToDecompress);
+        ServiceWatcherUtil.runService(context, intent);
+    }
+
+    @Override
+    public void decompress(String whereToDecompress, String[] subDirectories) {
+        Intent intent = new Intent(context, ExtractService.class);
+        intent.putExtra(ExtractService.KEY_PATH_ZIP, filePath);
+        intent.putExtra(ExtractService.KEY_ENTRIES_ZIP, subDirectories);
+        intent.putExtra(ExtractService.KEY_PATH_EXTRACT, whereToDecompress);
+        ServiceWatcherUtil.runService(context, intent);
+    }
+
+}
diff --git a/app/src/main/java/com/amaze/filemanager/fragments/AppsList.java b/app/src/main/java/com/amaze/filemanager/fragments/AppsListFragment.java
similarity index 86%
rename from app/src/main/java/com/amaze/filemanager/fragments/AppsList.java
rename to app/src/main/java/com/amaze/filemanager/fragments/AppsListFragment.java
index b1703abd6..9912ab703 100644
--- a/app/src/main/java/com/amaze/filemanager/fragments/AppsList.java
+++ b/app/src/main/java/com/amaze/filemanager/fragments/AppsListFragment.java
@@ -32,11 +32,11 @@ import android.widget.ListView;
 import android.widget.Toast;
 
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.activities.BaseActivity;
+import com.amaze.filemanager.activities.superclasses.ThemedActivity;
 import com.amaze.filemanager.activities.MainActivity;
 import com.amaze.filemanager.adapters.AppsAdapter;
-import com.amaze.filemanager.services.asynctasks.AppListLoader;
-import com.amaze.filemanager.ui.LayoutElement;
+import com.amaze.filemanager.asynchronous.loaders.AppListLoader;
+import com.amaze.filemanager.ui.LayoutElementParcelable;
 import com.amaze.filemanager.ui.icons.IconHolder;
 import com.amaze.filemanager.utils.Utils;
 import com.amaze.filemanager.utils.provider.UtilitiesProviderInterface;
@@ -44,10 +44,10 @@ import com.amaze.filemanager.utils.theme.AppTheme;
 
 import java.util.List;
 
-public class AppsList extends ListFragment implements LoaderManager.LoaderCallbacks<List<LayoutElement>> {
+public class AppsListFragment extends ListFragment implements LoaderManager.LoaderCallbacks<List<LayoutElementParcelable>> {
 
     UtilitiesProviderInterface utilsProvider;
-    AppsList app = this;
+    AppsListFragment app = this;
     AppsAdapter adapter;
 
     public SharedPreferences Sp;
@@ -74,7 +74,7 @@ public class AppsList extends ListFragment implements LoaderManager.LoaderCallba
         super.onActivityCreated(savedInstanceState);
         setRetainInstance(true);
         MainActivity mainActivity = (MainActivity) getActivity();
-        mainActivity.setActionBarTitle(getResources().getString(R.string.apps));
+        mainActivity.getAppbar().setTitle(R.string.apps);
         mainActivity.floatingActionButton.hideMenuButton(true);
         mainActivity.buttonBarFrame.setVisibility(View.GONE);
         mainActivity.supportInvalidateOptionsMenu();
@@ -86,7 +86,7 @@ public class AppsList extends ListFragment implements LoaderManager.LoaderCallba
         if (utilsProvider.getAppTheme().equals(AppTheme.DARK))
             getActivity().getWindow().getDecorView().setBackgroundColor(Utils.getColor(getContext(), R.color.holo_dark_background));
 
-        adapter = new AppsAdapter(getContext(), (BaseActivity) getActivity(), utilsProvider,
+        adapter = new AppsAdapter(getContext(), (ThemedActivity) getActivity(), utilsProvider,
                 R.layout.rowlayout, app);
         setListAdapter(adapter);
         setListShown(false);
@@ -146,12 +146,12 @@ public class AppsList extends ListFragment implements LoaderManager.LoaderCallba
     }
 
     @Override
-    public Loader<List<LayoutElement>> onCreateLoader(int id, Bundle args) {
+    public Loader<List<LayoutElementParcelable>> onCreateLoader(int id, Bundle args) {
         return new AppListLoader(getContext(), sortby, asc);
     }
 
     @Override
-    public void onLoadFinished(Loader<List<LayoutElement>> loader, List<LayoutElement> data) {
+    public void onLoadFinished(Loader<List<LayoutElementParcelable>> loader, List<LayoutElementParcelable> data) {
         // set new data to adapter
         adapter.setData(data);
 
@@ -166,7 +166,7 @@ public class AppsList extends ListFragment implements LoaderManager.LoaderCallba
     }
 
     @Override
-    public void onLoaderReset(Loader<List<LayoutElement>> loader) {
+    public void onLoaderReset(Loader<List<LayoutElementParcelable>> loader) {
         adapter.setData(null);
     }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/fragments/CompressedExplorerFragment.java b/app/src/main/java/com/amaze/filemanager/fragments/CompressedExplorerFragment.java
new file mode 100644
index 000000000..5a6bcb5ea
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/fragments/CompressedExplorerFragment.java
@@ -0,0 +1,466 @@
+/*
+ * Copyright (C) 2014 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ *                      Emmanuel Messulam<emmanuelbendavid@gmail.com>
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.fragments;
+
+import android.content.ComponentName;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.content.SharedPreferences;
+import android.graphics.drawable.ColorDrawable;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.IBinder;
+import android.preference.PreferenceManager;
+import android.support.annotation.Nullable;
+import android.support.design.widget.AppBarLayout;
+import android.support.v4.app.Fragment;
+import android.support.v4.widget.SwipeRefreshLayout;
+import android.support.v7.widget.LinearLayoutManager;
+import android.support.v7.widget.RecyclerView;
+import android.view.ActionMode;
+import android.view.LayoutInflater;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.Window;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import com.amaze.filemanager.R;
+import com.amaze.filemanager.activities.MainActivity;
+import com.amaze.filemanager.adapters.CompressedExplorerAdapter;
+import com.amaze.filemanager.asynchronous.asynctasks.DeleteTask;
+import com.amaze.filemanager.asynchronous.services.ExtractService;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
+import com.amaze.filemanager.filesystem.compressed.CompressedHelper;
+import com.amaze.filemanager.filesystem.compressed.CompressedInterface;
+import com.amaze.filemanager.ui.CompressedObjectParcelable;
+import com.amaze.filemanager.ui.views.DividerItemDecoration;
+import com.amaze.filemanager.ui.views.FastScroller;
+import com.amaze.filemanager.utils.BottomBarButtonPath;
+import com.amaze.filemanager.utils.OpenMode;
+import com.amaze.filemanager.utils.Utils;
+import com.amaze.filemanager.utils.color.ColorUsage;
+import com.amaze.filemanager.utils.files.FileUtils;
+import com.amaze.filemanager.utils.provider.UtilitiesProviderInterface;
+import com.amaze.filemanager.utils.theme.AppTheme;
+import com.github.junrar.Archive;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Calendar;
+
+public class CompressedExplorerFragment extends Fragment implements BottomBarButtonPath {
+    public static final String KEY_PATH = "path";
+
+    private static final String KEY_CACHE_FILES = "cache_files";
+    private static final String KEY_URI = "uri";
+    private static final String KEY_FILE = "file";
+    private static final String KEY_WHOLE_LIST = "whole_list";
+    private static final String KEY_ELEMENTS = "elements";
+    private static final String KEY_OPEN = "is_open";
+
+
+    public File compressedFile;
+
+    /**
+     * files to be deleted from cache
+     * with a Map maintaining key - the root of directory created (for deletion purposes after we exit out of here
+     * and value - the path of file to open
+     */
+    public ArrayList<HybridFileParcelable> files;
+    public boolean selection = false;
+    public String relativeDirectory = "";//Normally this would be "/" but for pathing issues it isn't
+    public String skin, accentColor, iconskin, year;
+    public CompressedExplorerAdapter compressedExplorerAdapter;
+    public ActionMode mActionMode;
+    public boolean coloriseIcons, showSize, showLastModified, gobackitem;
+    public Archive archive;
+    public ArrayList<CompressedObjectParcelable> elements = new ArrayList<>();
+    public MainActivity mainActivity;
+    public RecyclerView listView;
+    public SwipeRefreshLayout swipeRefreshLayout;
+    public boolean isOpen = false;  // flag states whether to open file after service extracts it
+
+    private UtilitiesProviderInterface utilsProvider;
+    private CompressedInterface compressedInterface;
+    private View rootView;
+    private boolean addheader = true;
+    private LinearLayoutManager mLayoutManager;
+    private DividerItemDecoration dividerItemDecoration;
+    private boolean showDividers;
+    private View mToolbarContainer;
+    private boolean stopAnims = true;
+    private int file = 0, folder = 0;
+
+    @Override
+    public void onCreate(@Nullable Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        utilsProvider = (UtilitiesProviderInterface) getActivity();
+    }
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        rootView = inflater.inflate(R.layout.main_frag, container, false);
+        mainActivity = (MainActivity) getActivity();
+        listView = (RecyclerView) rootView.findViewById(R.id.listView);
+        listView.setOnTouchListener((view, motionEvent) -> {
+            if (stopAnims && !compressedExplorerAdapter.stoppedAnimation) {
+                stopAnim();
+            }
+            compressedExplorerAdapter.stoppedAnimation = true;
+
+            stopAnims = false;
+            return false;
+        });
+        swipeRefreshLayout = (SwipeRefreshLayout) rootView.findViewById(R.id.activity_main_swipe_refresh_layout);
+        swipeRefreshLayout.setOnRefreshListener(this::refresh);
+
+        return rootView;
+    }
+
+    public void stopAnim() {
+        for (int j = 0; j < listView.getChildCount(); j++) {
+            View v = listView.getChildAt(j);
+            if (v != null) v.clearAnimation();
+        }
+    }
+
+    @Override
+    public void onActivityCreated(Bundle savedInstanceState) {
+        super.onActivityCreated(savedInstanceState);
+        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getActivity());
+        compressedFile = new File(Uri.parse(getArguments().getString(KEY_PATH)).getPath());
+
+        mToolbarContainer = mainActivity.getAppbar().getAppbarLayout();
+        mToolbarContainer.setOnTouchListener((view, motionEvent) -> {
+            if (stopAnims) {
+                if ((!compressedExplorerAdapter.stoppedAnimation)) {
+                    stopAnim();
+                }
+                compressedExplorerAdapter.stoppedAnimation = true;
+            }
+            stopAnims = false;
+            return false;
+        });
+
+        listView.setVisibility(View.VISIBLE);
+        mLayoutManager = new LinearLayoutManager(getActivity());
+        listView.setLayoutManager(mLayoutManager);
+
+        if (utilsProvider.getAppTheme().equals(AppTheme.DARK)) {
+            rootView.setBackgroundColor(Utils.getColor(getContext(), R.color.holo_dark_background));
+        } else {
+            listView.setBackgroundColor(Utils.getColor(getContext(), android.R.color.background_light));
+        }
+
+        gobackitem = sp.getBoolean("goBack_checkbox", false);
+        coloriseIcons = sp.getBoolean("coloriseIcons", true);
+        showSize = sp.getBoolean("showFileSize", false);
+        showLastModified = sp.getBoolean("showLastModified", true);
+        showDividers = sp.getBoolean("showDividers", true);
+        year = ("" + Calendar.getInstance().get(Calendar.YEAR)).substring(2, 4);
+        skin = mainActivity.getColorPreference().getColorAsString(ColorUsage.PRIMARY);
+        accentColor = mainActivity.getColorPreference().getColorAsString(ColorUsage.ACCENT);
+        iconskin = mainActivity.getColorPreference().getColorAsString(ColorUsage.ICON_SKIN);
+
+        //mainActivity.findViewById(R.id.buttonbarframe).setBackgroundColor(Color.parseColor(skin));
+
+        if (savedInstanceState == null && compressedFile != null) {
+            files = new ArrayList<>();
+            // adding a cache file to delete where any user interaction elements will be cached
+            String fileName = compressedFile.getName().substring(0, compressedFile.getName().lastIndexOf("."));
+            files.add(new HybridFileParcelable(getActivity().getExternalCacheDir().getPath() + "/" + fileName));
+            compressedInterface = CompressedHelper.getCompressedInterfaceInstance(getContext(), compressedFile);
+
+            changePath("");
+        } else {
+            onRestoreInstanceState(savedInstanceState);
+        }
+        mainActivity.supportInvalidateOptionsMenu();
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+
+        outState.putParcelableArrayList(KEY_ELEMENTS, elements);
+        outState.putString(KEY_PATH, relativeDirectory);
+        outState.putString(KEY_URI, compressedFile.getPath());
+        outState.putString(KEY_FILE, compressedFile.getPath());
+        outState.putParcelableArrayList(KEY_CACHE_FILES, files);
+        outState.putBoolean(KEY_OPEN, isOpen);
+    }
+
+    private void onRestoreInstanceState(Bundle savedInstanceState) {
+        compressedFile = new File(Uri.parse(savedInstanceState.getString(KEY_URI)).getPath());
+        files = savedInstanceState.getParcelableArrayList(KEY_CACHE_FILES);
+        isOpen = savedInstanceState.getBoolean(KEY_OPEN);
+        elements = savedInstanceState.getParcelableArrayList(KEY_ELEMENTS);
+        relativeDirectory = savedInstanceState.getString(KEY_PATH, "");
+
+        compressedInterface = CompressedHelper.getCompressedInterfaceInstance(getContext(), compressedFile);
+        createViews(elements, relativeDirectory);
+    }
+
+    public ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
+        private void hideOption(int id, Menu menu) {
+            MenuItem item = menu.findItem(id);
+            item.setVisible(false);
+        }
+
+        private void showOption(int id, Menu menu) {
+            MenuItem item = menu.findItem(id);
+            item.setVisible(true);
+        }
+
+        View v;
+
+        // called when the action mode is created; startActionMode() was called
+        public boolean onCreateActionMode(ActionMode mode, Menu menu) {
+            // Inflate a menu resource providing context menu items
+            MenuInflater inflater = mode.getMenuInflater();
+            v = getActivity().getLayoutInflater().inflate(R.layout.actionmode, null);
+            mode.setCustomView(v);
+            // assumes that you have "contexual.xml" menu resources
+            inflater.inflate(R.menu.contextual, menu);
+            hideOption(R.id.cpy, menu);
+            hideOption(R.id.cut, menu);
+            hideOption(R.id.delete, menu);
+            hideOption(R.id.addshortcut, menu);
+            hideOption(R.id.share, menu);
+            hideOption(R.id.openwith, menu);
+            showOption(R.id.all, menu);
+            hideOption(R.id.compress, menu);
+            hideOption(R.id.hide, menu);
+            showOption(R.id.ex, menu);
+            mode.setTitle(getResources().getString(R.string.select));
+            mainActivity.updateViews(new ColorDrawable(Utils.getColor(getContext(), R.color.holo_dark_action_mode)));
+            if (Build.VERSION.SDK_INT >= 21) {
+
+                Window window = getActivity().getWindow();
+                if (mainActivity.colourednavigation)
+                    window.setNavigationBarColor(Utils.getColor(getContext(), android.R.color.black));
+            }
+            if (Build.VERSION.SDK_INT < 19) {
+                mainActivity.getAppbar().getToolbar().setVisibility(View.GONE);
+            }
+            return true;
+        }
+
+        // the following method is called each time
+        // the action mode is shown. Always called after
+        // onCreateActionMode, but
+        // may be called multiple times if the mode is invalidated.
+        public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
+            ArrayList<Integer> positions = compressedExplorerAdapter.getCheckedItemPositions();
+            ((TextView) v.findViewById(R.id.item_count)).setText(positions.size() + "");
+
+            return false; // Return false if nothing is done
+        }
+
+        // called when the user selects a contextual menu item
+        public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
+            switch (item.getItemId()) {
+                case R.id.all:
+                    compressedExplorerAdapter.toggleChecked(true);
+                    mode.invalidate();
+                    return true;
+                case R.id.ex:
+                    Toast.makeText(getActivity(), getResources().getString(R.string.extracting), Toast.LENGTH_SHORT).show();
+
+                    String[] dirs = new String[compressedExplorerAdapter.getCheckedItemPositions().size()];
+                    for (int i = 0; i < dirs.length; i++) {
+                        dirs[i] = elements.get(compressedExplorerAdapter.getCheckedItemPositions().get(i)).getName();
+                    }
+
+                    compressedInterface.decompress(null, dirs);
+
+                    mode.finish();
+                    return true;
+            }
+            return false;
+        }
+
+        @Override
+        public void onDestroyActionMode(ActionMode actionMode) {
+            if (compressedExplorerAdapter != null) compressedExplorerAdapter.toggleChecked(false);
+            selection = false;
+            mainActivity.updateViews(mainActivity.getColorPreference().getDrawable(ColorUsage.getPrimary(MainActivity.currentTab)));
+            if (Build.VERSION.SDK_INT >= 21) {
+
+                Window window = getActivity().getWindow();
+                if (mainActivity.colourednavigation)
+                    window.setNavigationBarColor(mainActivity.skinStatusBar);
+            }
+            mActionMode = null;
+        }
+    };
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+        mainActivity.supportInvalidateOptionsMenu();
+
+        // needed to remove any extracted file from cache, when onResume was not called
+        // in case of opening any unknown file inside the zip
+
+        if (files.get(0).exists()) {
+            new DeleteTask(getActivity().getContentResolver(), getActivity(), this).execute(files);
+        }
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+
+        mainActivity.floatingActionButton.hideMenuButton(true);
+        Intent intent = new Intent(getActivity(), ExtractService.class);
+        getActivity().bindService(intent, mServiceConnection, 0);
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+
+        getActivity().unbindService(mServiceConnection);
+    }
+
+    private ServiceConnection mServiceConnection = new ServiceConnection() {
+        @Override
+        public void onServiceConnected(ComponentName name, IBinder service) {
+        }
+
+        @Override
+        public void onServiceDisconnected(ComponentName name) {
+            // open file if pending
+            if (isOpen) {
+                // open most recent entry added to files to be deleted from cache
+                File cacheFile = new File(files.get(files.size() - 1).getPath());
+                if (cacheFile.exists()) {
+                    FileUtils.openFile(cacheFile, mainActivity, mainActivity.getPrefs());
+                }
+                // reset the flag and cache file, as it's root is already in the list for deletion
+                isOpen = false;
+                files.remove(files.size() - 1);
+            }
+        }
+    };
+
+    @Override
+    public void changePath(String folder) {
+        if(folder == null) folder = "";
+        if(folder.startsWith("/")) folder = folder.substring(1);
+
+        boolean addGoBackItem = gobackitem && !isRoot(folder);
+        String finalfolder = folder;
+        compressedInterface.changePath(folder, addGoBackItem, data -> {
+            elements = data;
+            createViews(elements, finalfolder);
+
+            swipeRefreshLayout.setRefreshing(false);
+            updateBottomBar();
+        });
+
+        updateBottomBar();
+    }
+
+    @Override
+    public String getPath() {
+        if(!isRootRelativePath()) return "/" + relativeDirectory;
+        else return "";
+    }
+
+    @Override
+    public int getRootDrawable() {
+        return R.drawable.ic_compressed_white_24dp;
+    }
+
+    private void refresh() {
+        changePath(relativeDirectory);
+    }
+
+    private void updateBottomBar() {
+        String path = !isRootRelativePath()? compressedFile.getName() + "/" + relativeDirectory : compressedFile.getName();
+        mainActivity.getAppbar().getBottomBar().updatePath(path, false, null, OpenMode.FILE, folder, file, this);
+    }
+
+    private void createViews(ArrayList<CompressedObjectParcelable> items, String dir) {
+        if (compressedExplorerAdapter == null) {
+            compressedExplorerAdapter = new CompressedExplorerAdapter(getActivity(), utilsProvider, items, this, compressedInterface);
+            listView.setAdapter(compressedExplorerAdapter);
+        } else {
+            compressedExplorerAdapter.generateZip(items);
+        }
+
+        folder = 0;
+        file = 0;
+        for (CompressedObjectParcelable item : items) {
+            if(item.getType() == CompressedObjectParcelable.TYPE_GOBACK) continue;
+            
+            if (item.isDirectory()) folder++;
+            else file++;
+        }
+
+        stopAnims = true;
+        if (!addheader) {
+            listView.removeItemDecoration(dividerItemDecoration);
+            //listView.removeItemDecoration(headersDecor);
+            addheader = true;
+        } else {
+            dividerItemDecoration = new DividerItemDecoration(getActivity(), true, showDividers);
+            listView.addItemDecoration(dividerItemDecoration);
+            //headersDecor = new StickyRecyclerHeadersDecoration(compressedExplorerAdapter);
+            //listView.addItemDecoration(headersDecor);
+            addheader = false;
+        }
+        final FastScroller fastScroller = (FastScroller) rootView.findViewById(R.id.fastscroll);
+        fastScroller.setRecyclerView(listView, 1);
+        fastScroller.setPressedHandleColor(mainActivity.getColorPreference().getColor(ColorUsage.ACCENT));
+        ((AppBarLayout) mToolbarContainer).addOnOffsetChangedListener((appBarLayout, verticalOffset) -> {
+            fastScroller.updateHandlePosition(verticalOffset, 112);
+        });
+        listView.stopScroll();
+        relativeDirectory = dir;
+        updateBottomBar();
+        swipeRefreshLayout.setRefreshing(false);
+    }
+
+    public boolean canGoBack() {
+        return !isRootRelativePath();
+    }
+
+    public void goBack() {
+        changePath(new File(relativeDirectory).getParent());
+    }
+
+    private boolean isRootRelativePath() {
+        return isRoot(relativeDirectory);
+    }
+
+    private boolean isRoot(String folder) {
+        return folder == null || folder.isEmpty();
+    }
+
+}
diff --git a/app/src/main/java/com/amaze/filemanager/fragments/DbViewerFragment.java b/app/src/main/java/com/amaze/filemanager/fragments/DbViewerFragment.java
index c78fe7a7f..5080fc324 100644
--- a/app/src/main/java/com/amaze/filemanager/fragments/DbViewerFragment.java
+++ b/app/src/main/java/com/amaze/filemanager/fragments/DbViewerFragment.java
@@ -13,8 +13,8 @@ import android.widget.RelativeLayout;
 import android.widget.TextView;
 
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.activities.DbViewer;
-import com.amaze.filemanager.services.asynctasks.DbViewerTask;
+import com.amaze.filemanager.activities.DatabaseViewerActivity;
+import com.amaze.filemanager.asynchronous.asynctasks.DbViewerTask;
 import com.amaze.filemanager.utils.Utils;
 import com.amaze.filemanager.utils.theme.AppTheme;
 
@@ -22,7 +22,7 @@ import com.amaze.filemanager.utils.theme.AppTheme;
  * Created by Vishal on 06-02-2015.
  */
 public class DbViewerFragment extends Fragment {
-    public DbViewer dbViewer;
+    public DatabaseViewerActivity databaseViewerActivity;
     private String tableName;
     private View rootView;
     private Cursor schemaCursor, contentCursor;
@@ -32,17 +32,17 @@ public class DbViewerFragment extends Fragment {
 
     @Override
     public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
-        dbViewer = (DbViewer) getActivity();
+        databaseViewerActivity = (DatabaseViewerActivity) getActivity();
 
         rootView = inflater.inflate(R.layout.fragment_db_viewer, null);
         webView = (WebView) rootView.findViewById(R.id.webView1);
         loadingText = (TextView) rootView.findViewById(R.id.loadingText);
         relativeLayout = (RelativeLayout) rootView.findViewById(R.id.tableLayout);
         tableName = getArguments().getString("table");
-        dbViewer.setTitle(tableName);
+        databaseViewerActivity.setTitle(tableName);
 
-        schemaCursor = dbViewer.sqLiteDatabase.rawQuery("PRAGMA table_info(" + tableName + ");", null);
-        contentCursor = dbViewer.sqLiteDatabase.rawQuery("SELECT * FROM " + tableName, null);
+        schemaCursor = databaseViewerActivity.sqLiteDatabase.rawQuery("PRAGMA table_info(" + tableName + ");", null);
+        contentCursor = databaseViewerActivity.sqLiteDatabase.rawQuery("SELECT * FROM " + tableName, null);
 
         new DbViewerTask(schemaCursor, contentCursor, webView, this).execute();
 
@@ -52,7 +52,7 @@ public class DbViewerFragment extends Fragment {
     @Override
     public void onActivityCreated(@Nullable Bundle savedInstanceState) {
         super.onActivityCreated(savedInstanceState);
-        if (dbViewer.getAppTheme().equals(AppTheme.DARK)) {
+        if (databaseViewerActivity.getAppTheme().equals(AppTheme.DARK)) {
             relativeLayout.setBackgroundColor(Utils.getColor(getContext(), R.color.holo_dark_background));
             webView.setBackgroundColor(Utils.getColor(getContext(), R.color.holo_dark_background));
         } else {
diff --git a/app/src/main/java/com/amaze/filemanager/fragments/FTPServerFragment.java b/app/src/main/java/com/amaze/filemanager/fragments/FTPServerFragment.java
index a15198ac3..1d6e14727 100644
--- a/app/src/main/java/com/amaze/filemanager/fragments/FTPServerFragment.java
+++ b/app/src/main/java/com/amaze/filemanager/fragments/FTPServerFragment.java
@@ -10,7 +10,6 @@ import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
 import android.os.Bundle;
 import android.preference.PreferenceManager;
-import android.support.annotation.NonNull;
 import android.support.design.widget.TextInputLayout;
 import android.support.v4.app.Fragment;
 import android.support.v7.widget.AppCompatCheckBox;
@@ -25,27 +24,25 @@ import android.view.MenuItem;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.Button;
-import android.widget.CompoundButton;
 import android.widget.EditText;
 import android.widget.ImageButton;
 import android.widget.TextView;
 import android.widget.Toast;
 
-import com.afollestad.materialdialogs.DialogAction;
 import com.afollestad.materialdialogs.MaterialDialog;
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.MainActivity;
-import com.amaze.filemanager.exceptions.CryptException;
-import com.amaze.filemanager.services.ftpservice.FTPService;
+import com.amaze.filemanager.asynchronous.ftpservice.FTPService;
 import com.amaze.filemanager.utils.Utils;
 import com.amaze.filemanager.utils.color.ColorUsage;
 import com.amaze.filemanager.utils.files.CryptUtil;
 import com.amaze.filemanager.utils.theme.AppTheme;
 
 import java.io.File;
+import java.io.IOException;
 import java.io.InputStream;
 import java.net.InetAddress;
-import java.util.Objects;
+import java.security.GeneralSecurityException;
 
 /**
  * Created by yashwanthreddyg on 10-06-2016.
@@ -104,23 +101,19 @@ public class FTPServerFragment extends Fragment {
             statusDividerView.setBackgroundColor(Utils.getColor(getContext(), R.color.divider_dark_card));
         }
 
-        ftpBtn.setOnClickListener(new View.OnClickListener() {
-
-            @Override
-            public void onClick(View v) {
-                if (!FTPService.isRunning()) {
-                    if (FTPService.isConnectedToWifi(getContext())
-                            || FTPService.isConnectedToLocalNetwork(getContext())
-                            || FTPService.isEnabledWifiHotspot(getContext()))
-                        startServer();
-                    else {
-                        // no wifi and no eth, we shouldn't be here in the first place, because of broadcast
-                        // receiver, but just to be sure
-                        statusText.setText(spannedStatusNoConnection);
-                    }
-                } else {
-                    stopServer();
+        ftpBtn.setOnClickListener(v -> {
+            if (!FTPService.isRunning()) {
+                if (FTPService.isConnectedToWifi(getContext())
+                        || FTPService.isConnectedToLocalNetwork(getContext())
+                        || FTPService.isEnabledWifiHotspot(getContext()))
+                    startServer();
+                else {
+                    // no wifi and no eth, we shouldn't be here in the first place, because of broadcast
+                    // receiver, but just to be sure
+                    statusText.setText(spannedStatusNoConnection);
                 }
+            } else {
+                stopServer();
             }
         });
 
@@ -131,7 +124,7 @@ public class FTPServerFragment extends Fragment {
     public void onActivityCreated(Bundle savedInstanceState) {
         super.onActivityCreated(savedInstanceState);
         setRetainInstance(true);
-        mainActivity.setActionBarTitle(getResources().getString(R.string.ftp));
+        mainActivity.getAppbar().setTitle(R.string.ftp);
         mainActivity.floatingActionButton.hideMenuButton(true);
         mainActivity.buttonBarFrame.setVisibility(View.GONE);
         mainActivity.supportInvalidateOptionsMenu();
@@ -154,29 +147,21 @@ public class FTPServerFragment extends Fragment {
                 int currentFtpPort = getDefaultPortFromPreferences();
 
                 new MaterialDialog.Builder(getActivity())
-                        .input(getString(R.string.ftp_port_edit_menu_title), Integer.toString(currentFtpPort), true, new MaterialDialog.InputCallback() {
-                            @Override
-                            public void onInput(@NonNull MaterialDialog dialog, CharSequence input) {
-
-                            }
-                        })
+                        .input(getString(R.string.ftp_port_edit_menu_title), Integer.toString(currentFtpPort), true, (dialog, input) -> {})
                         .inputType(InputType.TYPE_CLASS_NUMBER)
-                        .onPositive(new MaterialDialog.SingleButtonCallback() {
-                            @Override
-                            public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
-                                EditText editText = dialog.getInputEditText();
-                                if (editText != null) {
-                                    String name = editText.getText().toString();
-
-                                    int portNumber = Integer.parseInt(name);
-                                    if (portNumber < 1024) {
-                                        Toast.makeText(getActivity(), R.string.ftp_port_change_error_invalid, Toast.LENGTH_SHORT)
-                                                .show();
-                                    } else {
-                                        changeFTPServerPort(portNumber);
-                                        Toast.makeText(getActivity(), R.string.ftp_port_change_success, Toast.LENGTH_SHORT)
-                                                .show();
-                                    }
+                        .onPositive((dialog, which) -> {
+                            EditText editText = dialog.getInputEditText();
+                            if (editText != null) {
+                                String name = editText.getText().toString();
+
+                                int portNumber = Integer.parseInt(name);
+                                if (portNumber < 1024) {
+                                    Toast.makeText(getActivity(), R.string.ftp_port_change_error_invalid, Toast.LENGTH_SHORT)
+                                            .show();
+                                } else {
+                                    changeFTPServerPort(portNumber);
+                                    Toast.makeText(getActivity(), R.string.ftp_port_change_success, Toast.LENGTH_SHORT)
+                                            .show();
                                 }
                             }
                         })
@@ -190,44 +175,35 @@ public class FTPServerFragment extends Fragment {
                 dialogBuilder.title(getString(R.string.ftp_path));
                 dialogBuilder.input(getString(R.string.ftp_path_hint),
                         getDefaultPathFromPreferences(),
-                        false, new MaterialDialog.InputCallback() {
-                            @Override
-                            public void onInput(@NonNull MaterialDialog dialog, CharSequence input) {
+                        false, (dialog, input) -> {});
+                dialogBuilder.onPositive((dialog, which) -> {
+                    EditText editText = dialog.getInputEditText();
+                    if (editText != null) {
+                        String path = editText.getText().toString();
 
-                            }
-                        });
-                dialogBuilder.onPositive(new MaterialDialog.SingleButtonCallback() {
-                    @Override
-                    public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
-
-                        EditText editText = dialog.getInputEditText();
-                        if (editText != null) {
-                            String path = editText.getText().toString();
+                        File pathFile = new File(path);
+                        if (pathFile.exists() && pathFile.isDirectory()) {
 
-                            File pathFile = new File(path);
-                            if (pathFile.exists() && pathFile.isDirectory()) {
+                            changeFTPServerPath(pathFile.getPath());
 
-                                changeFTPServerPath(pathFile.getPath());
+                            Toast.makeText(getActivity(), R.string.ftp_path_change_success,
+                                    Toast.LENGTH_SHORT)
+                                    .show();
+                        } else {
+                            // try to get parent
+                            File pathParentFile = new File(pathFile.getParent());
+                            if (pathParentFile.exists() && pathParentFile.isDirectory()) {
 
+                                changeFTPServerPath(pathParentFile.getPath());
                                 Toast.makeText(getActivity(), R.string.ftp_path_change_success,
                                         Toast.LENGTH_SHORT)
                                         .show();
                             } else {
-                                // try to get parent
-                                File pathParentFile = new File(pathFile.getParent());
-                                if (pathParentFile.exists() && pathParentFile.isDirectory()) {
-
-                                    changeFTPServerPath(pathParentFile.getPath());
-                                    Toast.makeText(getActivity(), R.string.ftp_path_change_success,
-                                            Toast.LENGTH_SHORT)
-                                            .show();
-                                } else {
-                                    // don't have access, print error
+                                // don't have access, print error
 
-                                    Toast.makeText(getActivity(), R.string.ftp_path_change_error_invalid,
-                                            Toast.LENGTH_SHORT)
-                                            .show();
-                                }
+                                Toast.makeText(getActivity(), R.string.ftp_path_change_error_invalid,
+                                        Toast.LENGTH_SHORT)
+                                        .show();
                             }
                         }
                     }
@@ -249,33 +225,34 @@ public class FTPServerFragment extends Fragment {
 
                 loginDialogBuilder.title(getString(R.string.ftp_login));
 
-                loginDialogBuilder.onPositive(new MaterialDialog.SingleButtonCallback() {
-                    @Override
-                    public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
+                loginDialogBuilder.onPositive((dialog, which) -> {
+                    if (mAnonymousCheckBox.isChecked()) {
 
-                        if (mAnonymousCheckBox.isChecked()) {
+                        // remove preferences
+                        setFTPUsername("");
+                        setFTPPassword("");
+                    } else {
 
-                            // remove preferences
-                            setFTPUsername("");
-                            setFTPPassword("");
+                        if (passwordEditText.getText().toString().equals("")) {
+                            passwordTextInput.setError(getResources().getString(R.string.field_empty));
+                        } else if (usernameEditText.getText().toString().equals("")) {
+                            usernameTextInput.setError(getResources().getString(R.string.field_empty));
                         } else {
 
-                            if (passwordEditText.getText().toString().equals("")) {
-                                passwordTextInput.setError(getResources().getString(R.string.field_empty));
-                            } else if (usernameEditText.getText().toString().equals("")) {
-                                usernameTextInput.setError(getResources().getString(R.string.field_empty));
-                            } else {
-
-                                // password and username field not empty, let's set them to preferences
-                                setFTPUsername(usernameEditText.getText().toString());
-                                setFTPPassword(passwordEditText.getText().toString());
-                            }
+                            // password and username field not empty, let's set them to preferences
+                            setFTPUsername(usernameEditText.getText().toString());
+                            setFTPPassword(passwordEditText.getText().toString());
                         }
-
-                        if (mSecureCheckBox.isChecked()) {
-                            setSecurePreference(true);
-                        } else setSecurePreference(false);
                     }
+
+                    if (mSecureCheckBox.isChecked()) {
+                        setSecurePreference(true);
+                    } else setSecurePreference(false);
+
+                    // TODO: Fix secure connection certification
+                    mSecureCheckBox.setEnabled(false);
+                    setSecurePreference(false);
+                    // TODO: Fix secure connection certification
                 });
 
                 loginDialogBuilder.positiveText(getResources().getString(R.string.set).toUpperCase())
@@ -291,24 +268,20 @@ public class FTPServerFragment extends Fragment {
                         getResources().getString(R.string.ftp_seconds) + ")");
                 timeoutBuilder.input(String.valueOf(FTPService.DEFAULT_TIMEOUT + " " +
                                 getResources().getString(R.string.ftp_seconds)), String.valueOf(getFTPTimeout()),
-                        true, new MaterialDialog.InputCallback() {
-                            @Override
-                            public void onInput(@NonNull MaterialDialog dialog, CharSequence input) {
-
-                                boolean isInputInteger;
-                                try {
-                                    // try parsing for integer check
-                                    Integer.parseInt(input.toString());
-                                    isInputInteger = true;
-                                } catch (NumberFormatException e) {
-                                    isInputInteger = false;
-                                }
-
-                                if (input.length()==0 || !isInputInteger)
-                                    setFTPTimeout(FTPService.DEFAULT_TIMEOUT);
-                                else
-                                    setFTPTimeout(Integer.valueOf(input.toString()));
+                        true, (dialog, input) -> {
+                            boolean isInputInteger;
+                            try {
+                                // try parsing for integer check
+                                Integer.parseInt(input.toString());
+                                isInputInteger = true;
+                            } catch (NumberFormatException e) {
+                                isInputInteger = false;
                             }
+
+                            if (input.length()==0 || !isInputInteger)
+                                setFTPTimeout(FTPService.DEFAULT_TIMEOUT);
+                            else
+                                setFTPTimeout(Integer.valueOf(input.toString()));
                         });
                 timeoutBuilder.positiveText(getResources().getString(R.string.set).toUpperCase())
                         .negativeText(getResources().getString(R.string.cancel))
@@ -449,19 +422,16 @@ public class FTPServerFragment extends Fragment {
             ftpPasswordVisibleButton.setVisibility(View.VISIBLE);
         }
 
-        ftpPasswordVisibleButton.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                if (password.getText().toString().contains("\u25CF")) {
-                    // password was not visible, let's make it visible
-                    password.setText(getResources().getString(R.string.password) + ": " +
-                            passwordDecrypted);
-                    ftpPasswordVisibleButton.setImageDrawable(getResources().getDrawable(R.drawable.ic_eye_off_grey600_24dp));
-                } else {
-                    // password was visible, let's hide it
-                    password.setText(getResources().getString(R.string.password) + ": " + passwordBulleted);
-                    ftpPasswordVisibleButton.setImageDrawable(getResources().getDrawable(R.drawable.ic_eye_grey600_24dp));
-                }
+        ftpPasswordVisibleButton.setOnClickListener(v -> {
+            if (password.getText().toString().contains("\u25CF")) {
+                // password was not visible, let's make it visible
+                password.setText(getResources().getString(R.string.password) + ": " +
+                        passwordDecrypted);
+                ftpPasswordVisibleButton.setImageDrawable(getResources().getDrawable(R.drawable.ic_eye_off_grey600_24dp));
+            } else {
+                // password was visible, let's hide it
+                password.setText(getResources().getString(R.string.password) + ": " + passwordBulleted);
+                ftpPasswordVisibleButton.setImageDrawable(getResources().getDrawable(R.drawable.ic_eye_grey600_24dp));
             }
         });
 
@@ -476,12 +446,22 @@ public class FTPServerFragment extends Fragment {
      */
     private void updateSpans() {
 
+        String ftpAddress;
+
+        try{
+            ftpAddress = getFTPAddressString();
+        } catch (NullPointerException npe){
+            npe.printStackTrace();
+            ftpAddress = "";
+            Toast.makeText(getContext(), getResources().getString(R.string.local_inet_addr_error), Toast.LENGTH_SHORT).show();
+        }
+
         String statusHead = getResources().getString(R.string.ftp_status_title) + ": ";
 
         spannedStatusConnected = Html.fromHtml(statusHead + "<b>&nbsp;&nbsp;" +
                 "<font color='" + accentColor + "'>"
                 + getResources().getString(R.string.ftp_status_running) + "</font></b>" +
-                "&nbsp;<i>(" + getFTPAddressString() + ")</i>");
+                "&nbsp;<i>(" + ftpAddress + ")</i>");
         spannedStatusNoConnection = Html.fromHtml(statusHead + "<b>&nbsp;&nbsp;&nbsp;&nbsp;" +
                 "<font color='" + Utils.getColor(getContext(), android.R.color.holo_red_light) + "'>"
                 + getResources().getString(R.string.ftp_status_no_connection) + "</font></b>");
@@ -491,7 +471,7 @@ public class FTPServerFragment extends Fragment {
         spannedStatusSecure = Html.fromHtml(statusHead + "<b>&nbsp;&nbsp;&nbsp;&nbsp;" +
                 "<font color='" + Utils.getColor(getContext(), android.R.color.holo_green_light) + "'>"
                 + getResources().getString(R.string.ftp_status_secure_connection) + "</font></b>" +
-                "&nbsp;<i>(" + getFTPAddressString() + ")</i>");
+                "&nbsp;<i>(" + ftpAddress + ")</i>");
     }
 
     private void initLoginDialogViews(View loginDialogView) {
@@ -503,16 +483,13 @@ public class FTPServerFragment extends Fragment {
         mAnonymousCheckBox = (AppCompatCheckBox) loginDialogView.findViewById(R.id.checkbox_ftp_anonymous);
         mSecureCheckBox = (AppCompatCheckBox) loginDialogView.findViewById(R.id.checkbox_ftp_secure);
 
-        mAnonymousCheckBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
-            @Override
-            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
-                if (isChecked) {
-                    usernameEditText.setEnabled(false);
-                    passwordEditText.setEnabled(false);
-                } else {
-                    usernameEditText.setEnabled(true);
-                    passwordEditText.setEnabled(true);
-                }
+        mAnonymousCheckBox.setOnCheckedChangeListener((buttonView, isChecked) -> {
+            if (isChecked) {
+                usernameEditText.setEnabled(false);
+                passwordEditText.setEnabled(false);
+            } else {
+                usernameEditText.setEnabled(true);
+                passwordEditText.setEnabled(true);
             }
         });
 
@@ -542,13 +519,12 @@ public class FTPServerFragment extends Fragment {
      * @return address at which server is running
      */
     private String getFTPAddressString() {
-        String hostAddress = "";
         InetAddress ia = FTPService.getLocalInetAddress(getContext());
-        if (ia != null)
-            hostAddress = ia.getHostAddress();
-
+        if(ia == null){
+            throw new NullPointerException("getLocalInetAddress returned a null value");
+        }
         return (getSecurePreference() ? FTPService.INITIALS_HOST_SFTP : FTPService.INITIALS_HOST_FTP)
-                + hostAddress  + ":" + getDefaultPortFromPreferences();
+                + ia.getHostAddress()  + ":" + getDefaultPortFromPreferences();
     }
 
     private int getDefaultPortFromPreferences() {
@@ -572,7 +548,7 @@ public class FTPServerFragment extends Fragment {
             } else {
                 return CryptUtil.decryptPassword(getContext(), encryptedPassword);
             }
-        } catch (CryptException e) {
+        } catch (GeneralSecurityException | IOException e) {
             e.printStackTrace();
 
             Toast.makeText(getContext(), getResources().getString(R.string.error), Toast.LENGTH_SHORT).show();
@@ -620,7 +596,7 @@ public class FTPServerFragment extends Fragment {
 
         try {
             preferences.edit().putString(FTPService.KEY_PREFERENCE_PASSWORD, CryptUtil.encryptPassword(getContext(), password)).apply();
-        } catch (CryptException e) {
+        } catch (GeneralSecurityException | IOException e) {
             e.printStackTrace();
             Toast.makeText(getContext(), getResources().getString(R.string.error), Toast.LENGTH_LONG).show();
         }
diff --git a/app/src/main/java/com/amaze/filemanager/fragments/MainFragment.java b/app/src/main/java/com/amaze/filemanager/fragments/MainFragment.java
index 1026de6e7..8b9b6b2fd 100644
--- a/app/src/main/java/com/amaze/filemanager/fragments/MainFragment.java
+++ b/app/src/main/java/com/amaze/filemanager/fragments/MainFragment.java
@@ -1,6 +1,7 @@
 /* Diego Felipe Lassa <diegoflassa@gmail.com>
  *
- * Copyright (C) 2014 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>
+ * Copyright (C) 2014 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ *                          Emmanuel Messulam <emmanuelbendavid@gmail.com>, Jens Klingenberg <mail@jensklingenberg.de>
  *
  * This file is part of Amaze File Manager.
  *
@@ -23,7 +24,6 @@ package com.amaze.filemanager.fragments;
 import android.app.Activity;
 import android.content.ActivityNotFoundException;
 import android.content.BroadcastReceiver;
-import android.content.ClipData;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
@@ -32,18 +32,17 @@ import android.content.pm.PackageManager;
 import android.content.pm.ResolveInfo;
 import android.content.res.Resources;
 import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
 import android.graphics.Color;
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import android.media.MediaScannerConnection;
 import android.media.RingtoneManager;
 import android.net.Uri;
 import android.os.AsyncTask;
 import android.os.Build;
 import android.os.Bundle;
-import android.os.FileObserver;
 import android.preference.PreferenceManager;
-import android.support.annotation.NonNull;
 import android.support.design.widget.AppBarLayout;
 import android.support.v4.app.FragmentActivity;
 import android.support.v4.app.FragmentManager;
@@ -59,30 +58,32 @@ import android.view.LayoutInflater;
 import android.view.Menu;
 import android.view.MenuInflater;
 import android.view.MenuItem;
-import android.view.MotionEvent;
 import android.view.View;
 import android.view.ViewGroup;
 import android.view.ViewTreeObserver;
 import android.widget.ImageView;
-import android.widget.LinearLayout;
 import android.widget.TextView;
 import android.widget.Toast;
 
-import com.afollestad.materialdialogs.DialogAction;
 import com.afollestad.materialdialogs.MaterialDialog;
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.activities.BaseActivity;
 import com.amaze.filemanager.activities.MainActivity;
+import com.amaze.filemanager.activities.superclasses.ThemedActivity;
 import com.amaze.filemanager.adapters.RecyclerAdapter;
+import com.amaze.filemanager.asynchronous.asynctasks.DeleteTask;
+import com.amaze.filemanager.asynchronous.asynctasks.LoadFilesListTask;
+import com.amaze.filemanager.asynchronous.handlers.FileHandler;
 import com.amaze.filemanager.database.CloudHandler;
 import com.amaze.filemanager.database.CryptHandler;
 import com.amaze.filemanager.database.models.EncryptedEntry;
 import com.amaze.filemanager.database.models.Tab;
-import com.amaze.filemanager.filesystem.BaseFile;
-import com.amaze.filemanager.filesystem.HFile;
+import com.amaze.filemanager.filesystem.CustomFileObserver;
+import com.amaze.filemanager.filesystem.HybridFile;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.MediaStoreHack;
-import com.amaze.filemanager.services.asynctasks.LoadList;
-import com.amaze.filemanager.ui.LayoutElement;
+import com.amaze.filemanager.filesystem.PasteHelper;
+import com.amaze.filemanager.fragments.preference_fragments.PrefFrag;
+import com.amaze.filemanager.ui.LayoutElementParcelable;
 import com.amaze.filemanager.ui.dialogs.GeneralDialogCreation;
 import com.amaze.filemanager.ui.icons.IconHolder;
 import com.amaze.filemanager.ui.icons.Icons;
@@ -90,7 +91,7 @@ import com.amaze.filemanager.ui.icons.MimeTypes;
 import com.amaze.filemanager.ui.views.DividerItemDecoration;
 import com.amaze.filemanager.ui.views.FastScroller;
 import com.amaze.filemanager.ui.views.RoundedImageView;
-import com.amaze.filemanager.utils.AppConfig;
+import com.amaze.filemanager.utils.BottomBarButtonPath;
 import com.amaze.filemanager.utils.DataUtils;
 import com.amaze.filemanager.utils.MainActivityHelper;
 import com.amaze.filemanager.utils.OTGUtil;
@@ -102,7 +103,7 @@ import com.amaze.filemanager.utils.color.ColorUsage;
 import com.amaze.filemanager.utils.files.CryptUtil;
 import com.amaze.filemanager.utils.files.EncryptDecryptUtils;
 import com.amaze.filemanager.utils.files.FileListSorter;
-import com.amaze.filemanager.utils.files.Futils;
+import com.amaze.filemanager.utils.files.FileUtils;
 import com.amaze.filemanager.utils.provider.UtilitiesProviderInterface;
 import com.amaze.filemanager.utils.theme.AppTheme;
 
@@ -116,16 +117,14 @@ import java.util.List;
 import jcifs.smb.SmbException;
 import jcifs.smb.SmbFile;
 
-public class MainFragment extends android.support.v4.app.Fragment {
+public class MainFragment extends android.support.v4.app.Fragment implements BottomBarButtonPath {
 
     public ActionMode mActionMode;
-    public BitmapDrawable folder, apk, DARK_IMAGE, DARK_VIDEO;
-    public LinearLayout buttons;
+    public Drawable folder, apk, DARK_IMAGE, DARK_VIDEO;
     public int sortby, dsort, asc;
-    public String home, goback;
+    public String home;
     public boolean selection, results = false, SHOW_HIDDEN, CIRCULAR_IMAGES, SHOW_PERMISSIONS,
             SHOW_SIZE, SHOW_LAST_MODIFIED;
-    public LinearLayout pathbar;
     public OpenMode openMode = OpenMode.FILE;
 
     public boolean GO_BACK_ITEM, SHOW_THUMBS, COLORISE_ICONS, SHOW_DIVIDERS, SHOW_HEADERS;
@@ -134,19 +133,19 @@ public class MainFragment extends android.support.v4.app.Fragment {
      * {@link MainFragment#IS_LIST} boolean to identify if the view is a list or grid
      */
     public boolean IS_LIST = true;
-    public IconHolder ic;
+    public IconHolder iconHolder;
     public SwipeRefreshLayout mSwipeRefreshLayout;
     public int file_count, folder_count, columns;
     public String smbPath;
     public String sftpPath;
-    public ArrayList<BaseFile> searchHelper = new ArrayList<>();
+    public ArrayList<HybridFileParcelable> searchHelper = new ArrayList<>();
     public int no;
 
     private String CURRENT_PATH = "";
     /**
      * This is not an exact copy of the elements in the adapter
      */
-    private ArrayList<LayoutElement> LIST_ELEMENTS;
+    private ArrayList<LayoutElementParcelable> LIST_ELEMENTS;
     private RecyclerAdapter adapter;
     private SharedPreferences sharedPref;
     private Resources res;
@@ -158,13 +157,11 @@ public class MainFragment extends android.support.v4.app.Fragment {
     private boolean addheader = false;
     private DividerItemDecoration dividerItemDecoration;
     private AppBarLayout mToolbarContainer;
-    private TextView pathname, mFullPath;
     private boolean stopAnims = true;
-    private View nofilesview;
+    private SwipeRefreshLayout nofilesview;
 
     private android.support.v7.widget.RecyclerView listView;
     private UtilitiesProviderInterface utilsProvider;
-    private Futils utils;
     private HashMap<String, Bundle> scrolls = new HashMap<>();
     private MainFragment ma = this;
     private View rootView;
@@ -173,6 +170,14 @@ public class MainFragment extends android.support.v4.app.Fragment {
     private Bitmap mFolderBitmap;
     private CustomFileObserver customFileObserver;
     private DataUtils dataUtils = DataUtils.getInstance();
+    private boolean isEncryptOpen = false;       // do we have to open a file when service is begin destroyed
+    private HybridFileParcelable encryptBaseFile;            // the cached base file which we're to open, delete it later
+
+    /**
+     *  a list of encrypted base files which are supposed to be deleted
+     */
+    private ArrayList<HybridFileParcelable> encryptBaseFiles = new ArrayList<>();
+    private MediaScannerConnection mediaScannerConnection;
 
     // defines the current visible tab, default either 0 or 1
     //private int mCurrentTab;
@@ -183,6 +188,12 @@ public class MainFragment extends android.support.v4.app.Fragment {
      */
     private boolean mRetainSearchTask = false;
 
+    /**
+     * For caching the back button
+     */
+    private Drawable backIcon = null;
+    private LayoutElementParcelable back = null;
+
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
@@ -190,7 +201,6 @@ public class MainFragment extends android.support.v4.app.Fragment {
         setRetainInstance(true);
 
         utilsProvider = getMainActivity();
-        utils = utilsProvider.getFutils();
         sharedPref = PreferenceManager.getDefaultSharedPreferences(getActivity());
         res = getResources();
 
@@ -205,7 +215,7 @@ public class MainFragment extends android.support.v4.app.Fragment {
         primaryTwoColor = getMainActivity().getColorPreference().getColor(ColorUsage.PRIMARY_TWO);
 
         SHOW_PERMISSIONS = sharedPref.getBoolean("showPermissions", false);
-        SHOW_SIZE = sharedPref.getBoolean("showFileSize", false);
+        SHOW_SIZE = sharedPref.getBoolean("showFileSize", true);
         SHOW_DIVIDERS = sharedPref.getBoolean("showDividers", true);
         SHOW_HEADERS = sharedPref.getBoolean("showHeaders", true);
         GO_BACK_ITEM = sharedPref.getBoolean("goBack_checkbox", false);
@@ -228,54 +238,33 @@ public class MainFragment extends android.support.v4.app.Fragment {
         rootView = inflater.inflate(R.layout.main_frag, container, false);
         setRetainInstance(true);
         listView = (android.support.v7.widget.RecyclerView) rootView.findViewById(R.id.listView);
-        mToolbarContainer = (AppBarLayout) getActivity().findViewById(R.id.lin);
+        mToolbarContainer = getMainActivity().getAppbar().getAppbarLayout();
         fastScroller = (FastScroller) rootView.findViewById(R.id.fastscroll);
         fastScroller.setPressedHandleColor(accentColor);
-        listView.setOnTouchListener(new View.OnTouchListener() {
-            @Override
-            public boolean onTouch(View view, MotionEvent motionEvent) {
-                if (adapter != null && stopAnims) {
-                    stopAnimation();
-                    stopAnims = false;
-                }
-                return false;
+        listView.setOnTouchListener((view, motionEvent) -> {
+            if (adapter != null && stopAnims) {
+                stopAnimation();
+                stopAnims = false;
             }
+            return false;
         });
-        mToolbarContainer.setOnTouchListener(new View.OnTouchListener() {
-            @Override
-            public boolean onTouch(View view, MotionEvent motionEvent) {
-                if (adapter != null && stopAnims) {
-                    stopAnimation();
-                    stopAnims = false;
-                }
-                return false;
+        mToolbarContainer.setOnTouchListener((view, motionEvent) -> {
+            if (adapter != null && stopAnims) {
+                stopAnimation();
+                stopAnims = false;
             }
+            return false;
         });
 
         mSwipeRefreshLayout = (SwipeRefreshLayout) rootView.findViewById(R.id.activity_main_swipe_refresh_layout);
 
-        mSwipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {
-            @Override
-            public void onRefresh() {
-                loadlist((CURRENT_PATH), false, openMode);
-            }
-        });
-        buttons = (LinearLayout) getActivity().findViewById(R.id.buttons);
-        pathbar = (LinearLayout) getActivity().findViewById(R.id.pathbar);
+        mSwipeRefreshLayout.setOnRefreshListener(() -> loadlist((CURRENT_PATH), false, openMode));
+
         SHOW_THUMBS = sharedPref.getBoolean("showThumbs", true);
-        pathname = (TextView) getActivity().findViewById(R.id.pathname);
-        mFullPath = (TextView) getActivity().findViewById(R.id.fullpath);
         //String itemsstring = res.getString(R.string.items);// TODO: 23/5/2017 use or delete
-        apk = new BitmapDrawable(res, BitmapFactory.decodeResource(res, R.drawable.ic_doc_apk_grid));
+        apk = res.getDrawable(R.drawable.ic_doc_apk_grid);
         mToolbarContainer.setBackgroundColor(MainActivity.currentTab == 1 ? primaryTwoColor : primaryColor);
 
-        if (!sharedPref.getBoolean("intelliHideToolbar", true)) {
-            AppBarLayout.LayoutParams params = (AppBarLayout.LayoutParams) getActivity()
-                    .findViewById(R.id.action_bar).getLayoutParams();
-            params.setScrollFlags(0);
-            mToolbarContainer.setExpanded(true, true);
-        }
-
         //   listView.setPadding(listView.getPaddingLeft(), paddingTop, listView.getPaddingRight(), listView.getPaddingBottom());
         return rootView;
     }
@@ -289,17 +278,15 @@ public class MainFragment extends android.support.v4.app.Fragment {
         initNoFileLayout();
         SHOW_HIDDEN = sharedPref.getBoolean("showHidden", false);
         COLORISE_ICONS = sharedPref.getBoolean("coloriseIcons", true);
-        mFolderBitmap = BitmapFactory.decodeResource(res, R.drawable.ic_grid_folder_new);
-        goback = getString(R.string.goback);
-        folder = new BitmapDrawable(res, mFolderBitmap);
+        folder = res.getDrawable(R.drawable.ic_grid_folder_new);
         getSortModes();
-        DARK_IMAGE = new BitmapDrawable(res, BitmapFactory.decodeResource(res, R.drawable.ic_doc_image_dark));
-        DARK_VIDEO = new BitmapDrawable(res, BitmapFactory.decodeResource(res, R.drawable.ic_doc_video_dark));
+        DARK_IMAGE = res.getDrawable(R.drawable.ic_doc_image_dark);
+        DARK_VIDEO = res.getDrawable(R.drawable.ic_doc_video_dark);
         this.setRetainInstance(false);
-        HFile f = new HFile(OpenMode.UNKNOWN, CURRENT_PATH);
+        HybridFile f = new HybridFile(OpenMode.UNKNOWN, CURRENT_PATH);
         f.generateMode(getActivity());
-        getMainActivity().initiatebbar();
-        ic = new IconHolder(getActivity(), SHOW_THUMBS, !IS_LIST);
+        getMainActivity().getAppbar().getBottomBar().setClickListener();
+        iconHolder = new IconHolder(getActivity(), SHOW_THUMBS, !IS_LIST);
 
         if (utilsProvider.getAppTheme().equals(AppTheme.LIGHT) && !IS_LIST) {
             listView.setBackgroundColor(Utils.getColor(getContext(), R.color.grid_background_light));
@@ -317,6 +304,7 @@ public class MainFragment extends android.support.v4.app.Fragment {
                 mLayoutManagerGrid = new GridLayoutManager(getActivity(), 3);
             else
                 mLayoutManagerGrid = new GridLayoutManager(getActivity(), columns);
+            setGridLayoutSpanSizeLookup(mLayoutManagerGrid);
             listView.setLayoutManager(mLayoutManagerGrid);
         }
         // use a linear layout manager
@@ -331,7 +319,7 @@ public class MainFragment extends android.support.v4.app.Fragment {
             public void onGlobalLayout() {
                 if ((columns == 0 || columns == -1)) {
                     int screen_width = listView.getWidth();
-                    int dptopx = Utils.dpToPx(115, getContext());
+                    int dptopx = Utils.dpToPx(getContext(), 115);
                     columns = screen_width / dptopx;
                     if (columns == 0 || columns == -1) columns = 3;
                     if (!IS_LIST) mLayoutManagerGrid.setSpanCount(columns);
@@ -355,10 +343,27 @@ public class MainFragment extends android.support.v4.app.Fragment {
         }
     }
 
+    void setGridLayoutSpanSizeLookup(GridLayoutManager mLayoutManagerGrid) {
+
+        mLayoutManagerGrid.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() {
+
+            @Override
+            public int getSpanSize(int position) {
+                switch(adapter.getItemViewType(position)){
+                    case RecyclerAdapter.TYPE_HEADER_FILES:
+                    case RecyclerAdapter.TYPE_HEADER_FOLDERS:
+                        return columns;
+                    default:
+                        return 1;
+                }
+            }
+        });
+    }
+
     void switchToGrid() {
         IS_LIST = false;
 
-        ic = new IconHolder(getActivity(), SHOW_THUMBS, !IS_LIST);
+        iconHolder = new IconHolder(getActivity(), SHOW_THUMBS, !IS_LIST);
         folder = new BitmapDrawable(res, mFolderBitmap);
         fixIcons(true);
 
@@ -373,6 +378,7 @@ public class MainFragment extends android.support.v4.app.Fragment {
                 mLayoutManagerGrid = new GridLayoutManager(getActivity(), 3);
             else
                 mLayoutManagerGrid = new GridLayoutManager(getActivity(), columns);
+        setGridLayoutSpanSizeLookup(mLayoutManagerGrid);
         listView.setLayoutManager(mLayoutManagerGrid);
         adapter = null;
     }
@@ -385,7 +391,7 @@ public class MainFragment extends android.support.v4.app.Fragment {
             listView.setBackgroundDrawable(null);
         }
 
-        ic = new IconHolder(getActivity(), SHOW_THUMBS, !IS_LIST);
+        iconHolder = new IconHolder(getActivity(), SHOW_THUMBS, !IS_LIST);
         folder = new BitmapDrawable(res, mFolderBitmap);
         fixIcons(true);
         if (mLayoutManager == null)
@@ -395,7 +401,7 @@ public class MainFragment extends android.support.v4.app.Fragment {
     }
 
     public void switchView() {
-        createViews(getLayoutElements(), false, CURRENT_PATH, openMode, results, checkPathIsGrid(CURRENT_PATH));
+        reloadListElements(false, results, checkPathIsGrid(CURRENT_PATH));
     }
 
     @Override
@@ -417,7 +423,7 @@ public class MainFragment extends android.support.v4.app.Fragment {
 
             outState.putInt("index", index);
             outState.putInt("top", top);
-            outState.putParcelableArrayList("list", getLayoutElements());
+            outState.putParcelableArrayList("list", LIST_ELEMENTS);
             outState.putString("CURRENT_PATH", CURRENT_PATH);
             outState.putBoolean("selection", selection);
             outState.putInt("openMode", openMode.ordinal());
@@ -425,11 +431,7 @@ public class MainFragment extends android.support.v4.app.Fragment {
             outState.putInt("file_count", file_count);
 
             if (selection) {
-                ArrayList<String> selectedPaths = new ArrayList<>();
-                for(LayoutElement e : adapter.getCheckedItems()) {
-                    selectedPaths.add(e.getDesc());
-                }
-                outState.putStringArrayList("position", selectedPaths);
+                outState.putIntegerArrayList("position", adapter.getCheckedItemsIndex());
             }
 
             outState.putBoolean("results", results);
@@ -452,16 +454,16 @@ public class MainFragment extends android.support.v4.app.Fragment {
             openMode = OpenMode.getOpenMode(savedInstanceState.getInt("openMode", 0));
             if (openMode == OpenMode.SMB)
                 smbPath = savedInstanceState.getString("SmbPath");
-            putLayoutElements(savedInstanceState.<LayoutElement>getParcelableArrayList("list"));
+            LIST_ELEMENTS = savedInstanceState.getParcelableArrayList("list");
             CURRENT_PATH = cur;
             folder_count = savedInstanceState.getInt("folder_count", 0);
             file_count = savedInstanceState.getInt("file_count", 0);
             results = savedInstanceState.getBoolean("results");
-            getMainActivity().updatePath(CURRENT_PATH, results, openMode, folder_count, file_count);
-            createViews(getLayoutElements(), true, (CURRENT_PATH), openMode, results, !IS_LIST);
+            getMainActivity().getAppbar().getBottomBar().updatePath(CURRENT_PATH, results, MainActivityHelper.SEARCH_TEXT, openMode, folder_count, file_count, this);
+            reloadListElements( true, results, !IS_LIST);
             if (savedInstanceState.getBoolean("selection")) {
-                for (String path : savedInstanceState.getStringArrayList("position")) {
-                    adapter.toggleChecked(true, path);
+                for (Integer index : savedInstanceState.getIntegerArrayList("position")) {
+                    adapter.toggleChecked(index, null);
                 }
             }
         }
@@ -529,7 +531,7 @@ public class MainFragment extends android.support.v4.app.Fragment {
          * may be called multiple times if the mode is invalidated.
          */
         public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
-            ArrayList<LayoutElement> positions = adapter.getCheckedItems();
+            ArrayList<LayoutElementParcelable> positions = adapter.getCheckedItems();
             TextView textView1 = (TextView) actionModeView.findViewById(R.id.item_count);
             textView1.setText(String.valueOf(positions.size()));
             textView1.setOnClickListener(null);
@@ -570,7 +572,7 @@ public class MainFragment extends android.support.v4.app.Fragment {
                         showOption(R.id.share, menu);
                         if (getMainActivity().mReturnIntent)
                             if (Build.VERSION.SDK_INT >= 16) showOption(R.id.openmulti, menu);
-                        for (LayoutElement e : adapter.getCheckedItems()) {
+                        for (LayoutElementParcelable e : adapter.getCheckedItems()) {
                             File x = new File(e.getDesc());
                             if (x.isDirectory()) {
                                 hideOption(R.id.share, menu);
@@ -608,7 +610,7 @@ public class MainFragment extends android.support.v4.app.Fragment {
                         if (Build.VERSION.SDK_INT >= 16)
                             showOption(R.id.openmulti, menu);
                     try {
-                        for (LayoutElement e : adapter.getCheckedItems()) {
+                        for (LayoutElementParcelable e : adapter.getCheckedItems()) {
                             File x = new File(e.getDesc());
                             if (x.isDirectory()) {
                                 hideOption(R.id.share, menu);
@@ -630,84 +632,47 @@ public class MainFragment extends android.support.v4.app.Fragment {
         // called when the user selects a contextual menu item
         public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
             computeScroll();
-            ArrayList<LayoutElement> plist = adapter.getCheckedItems();
+            ArrayList<LayoutElementParcelable> checkedItems = adapter.getCheckedItems();
             switch (item.getItemId()) {
                 case R.id.openmulti:
-                    if (Build.VERSION.SDK_INT >= 16) {
-                        Intent intentresult = new Intent();
+
+                    try {
+
+                        Intent intent_result = new Intent(Intent.ACTION_SEND_MULTIPLE);
                         ArrayList<Uri> resulturis = new ArrayList<>();
-                        for (LayoutElement element : plist) {
-                            try {
-                                resulturis.add(Uri.fromFile(new File(element.getDesc())));
-                            } catch (Exception e) {
-                                e.printStackTrace();
+
+                        for (LayoutElementParcelable element : checkedItems) {
+                            HybridFileParcelable baseFile = element.generateBaseFile();
+                            Uri resultUri = Utils.getUriForBaseFile(getActivity(), baseFile);
+
+                            if (resultUri != null) {
+                                resulturis.add(resultUri);
                             }
                         }
-                        final ClipData clipData = new ClipData(
-                                null, new String[]{"*/*"}, new ClipData.Item(resulturis.get(0)));
-                        for (int i = 1; i < resulturis.size(); i++) {
-                            clipData.addItem(new ClipData.Item(resulturis.get(i)));
-                        }
-                        intentresult.setClipData(clipData);
-                        mode.finish();
-                        getActivity().setResult(FragmentActivity.RESULT_OK, intentresult);
+
+                        intent_result.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
+                        getActivity().setResult(FragmentActivity.RESULT_OK, intent_result);
+                        intent_result.putParcelableArrayListExtra(Intent.EXTRA_STREAM, resulturis);
                         getActivity().finish();
+                        //mode.finish();
+                    } catch (Exception e) {
+                        e.printStackTrace();
                     }
                     return true;
                 case R.id.about:
-                    LayoutElement x = plist.get(0);
+                    LayoutElementParcelable x = checkedItems.get(0);
                     GeneralDialogCreation.showPropertiesDialogWithPermissions((x).generateBaseFile(),
-                            x.getPermissions(), (BaseActivity) getActivity(), BaseActivity.rootMode,
+                            x.getPermissions(), (ThemedActivity) getActivity(), ThemedActivity.rootMode,
                             utilsProvider.getAppTheme());
-                    /*
-                    PropertiesSheet propertiesSheet = new PropertiesSheet();
-                    Bundle arguments = new Bundle();
-                    arguments.putParcelable(PropertiesSheet.KEY_FILE, x.generateBaseFile());
-                    arguments.putString(PropertiesSheet.KEY_PERMISSION, x.getPermissions());
-                    arguments.putBoolean(PropertiesSheet.KEY_ROOT, BaseActivity.rootMode);
-                    propertiesSheet.setArguments(arguments);
-                    propertiesSheet.show(getFragmentManager(), PropertiesSheet.TAG_FRAGMENT);
-                    */
                     mode.finish();
                     return true;
-                /*
-                case R.id.setringtone:
-                    File fx;
-                    if(results)
-                        fx=new File(slist.get((plist.get(0))).getDesc());
-                        else
-                        fx=new File(list.get((plist.get(0))).getDesc());
-
-                    ContentValues values = new ContentValues();
-                    values.put(MediaStore.MediaColumns.DATA, fx.getAbsolutePath());
-                    values.put(MediaStore.MediaColumns.TITLE, "Amaze");
-                    values.put(MediaStore.MediaColumns.MIME_TYPE, "audio/mp3");
-                    //values.put(MediaStore.MediaColumns.SIZE, fx.);
-                    values.put(MediaStore.Audio.Media.ARTIST, R.string.app_name);
-                    values.put(MediaStore.Audio.Media.IS_RINGTONE, true);
-                    values.put(MediaStore.Audio.Media.IS_NOTIFICATION, false);
-                    values.put(MediaStore.Audio.Media.IS_ALARM, false);
-                    values.put(MediaStore.Audio.Media.IS_MUSIC, false);
-
-                    Uri uri = MediaStore.Audio.Media.getContentUriForPath(fx.getAbsolutePath());
-                    Uri newUri = getActivity().getContentResolver().insert(uri, values);
-                    try {
-                        RingtoneManager.setActualDefaultRingtoneUri(getActivity(), RingtoneManager.TYPE_RINGTONE, newUri);
-                        //Settings.System.putString(getActivity().getContentResolver(), Settings.System.RINGTONE, newUri.toString());
-                        Toast.makeText(getActivity(), "Successful" + fx.getAbsolutePath(), Toast.LENGTH_LONG).show();
-                    } catch (Throwable t) {
-
-                        Log.d("ringtone", "failed");
-                    }
-                    return true;
-                */
                 case R.id.delete:
-                    GeneralDialogCreation.deleteFilesDialog(getContext(), getLayoutElements(),
-                            getMainActivity(), plist, utilsProvider.getAppTheme());
+                    GeneralDialogCreation.deleteFilesDialog(getContext(), LIST_ELEMENTS,
+                            getMainActivity(), checkedItems, utilsProvider.getAppTheme());
                     return true;
                 case R.id.share:
                     ArrayList<File> arrayList = new ArrayList<>();
-                    for (LayoutElement e: plist) {
+                    for (LayoutElementParcelable e: checkedItems) {
                         arrayList.add(new File(e.getDesc()));
                     }
                     if (arrayList.size() > 100)
@@ -715,22 +680,22 @@ public class MainFragment extends android.support.v4.app.Fragment {
                                 Toast.LENGTH_SHORT).show();
                     else {
 
-                        switch (getLayoutElement(0).getMode()) {
+                        switch (LIST_ELEMENTS.get(0).getMode()) {
                             case DROPBOX:
                             case BOX:
                             case GDRIVE:
                             case ONEDRIVE:
-                                utils.shareCloudFile(getLayoutElement(0).getDesc(),
-                                        getLayoutElement(0).getMode(), getContext());
+                                FileUtils.shareCloudFile(LIST_ELEMENTS.get(0).getDesc(),
+                                        LIST_ELEMENTS.get(0).getMode(), getContext());
                                 break;
                             default:
-                                utils.shareFiles(arrayList, getActivity(), utilsProvider.getAppTheme(), accentColor);
+                                FileUtils.shareFiles(arrayList, getActivity(), utilsProvider.getAppTheme(), accentColor);
                                 break;
                         }
                     }
                     return true;
                 case R.id.openparent:
-                    loadlist(new File(plist.get(0).getDesc()).getParent(), false, OpenMode.FILE);
+                    loadlist(new File(checkedItems.get(0).getDesc()).getParent(), false, OpenMode.FILE);
                     return true;
                 case R.id.all:
                     if (adapter.areAllChecked(CURRENT_PATH)) {
@@ -744,55 +709,50 @@ public class MainFragment extends android.support.v4.app.Fragment {
                 case R.id.rename:
 
                     final ActionMode m = mode;
-                    final BaseFile f;
-                    f = plist.get(0).generateBaseFile();
+                    final HybridFileParcelable f;
+                    f = checkedItems.get(0).generateBaseFile();
                     rename(f);
                     mode.finish();
                     return true;
                 case R.id.hide:
-                    for (int i1 = 0; i1 < plist.size(); i1++) {
-                        hide(plist.get(i1).getDesc());
+                    for (int i1 = 0; i1 < checkedItems.size(); i1++) {
+                        hide(checkedItems.get(i1).getDesc());
                     }
                     updateList();
                     mode.finish();
                     return true;
                 case R.id.ex:
-                    getMainActivity().mainActivityHelper.extractFile(new File(plist.get(0).getDesc()));
+                    getMainActivity().mainActivityHelper.extractFile(new File(checkedItems.get(0).getDesc()));
                     mode.finish();
                     return true;
                 case R.id.cpy:
-                    getMainActivity().MOVE_PATH = null;
-                    ArrayList<BaseFile> copies = new ArrayList<>();
-                    for (int i2 = 0; i2 < plist.size(); i2++) {
-                        copies.add(plist.get(i2).generateBaseFile());
+                case R.id.cut: {
+                    HybridFileParcelable[] copies = new HybridFileParcelable[checkedItems.size()];
+                    for (int i = 0; i < checkedItems.size(); i++) {
+                        copies[i] = checkedItems.get(i).generateBaseFile();
                     }
-                    getMainActivity().COPY_PATH = copies;
-                    getMainActivity().supportInvalidateOptionsMenu();
-                    mode.finish();
-                    return true;
-                case R.id.cut:
-                    getMainActivity().COPY_PATH = null;
-                    ArrayList<BaseFile> copie = new ArrayList<>();
-                    for (int i3 = 0; i3 < plist.size(); i3++) {
-                        copie.add(plist.get(i3).generateBaseFile());
-                    }
-                    getMainActivity().MOVE_PATH = copie;
-                    getMainActivity().supportInvalidateOptionsMenu();
+                    int op = item.getItemId() == R.id.cpy? PasteHelper.OPERATION_COPY:PasteHelper.OPERATION_CUT;
+
+                    PasteHelper pasteHelper = new PasteHelper(op, copies);
+                    getMainActivity().setPaste(pasteHelper);
+
                     mode.finish();
                     return true;
+                }
                 case R.id.compress:
-                    ArrayList<BaseFile> copies1 = new ArrayList<>();
-                    for (int i4 = 0; i4 < plist.size(); i4++) {
-                        copies1.add(plist.get(i4).generateBaseFile());
+                    ArrayList<HybridFileParcelable> copies1 = new ArrayList<>();
+                    for (int i4 = 0; i4 < checkedItems.size(); i4++) {
+                        copies1.add(checkedItems.get(i4).generateBaseFile());
                     }
                     GeneralDialogCreation.showCompressDialog((MainActivity) getActivity(), copies1, CURRENT_PATH);
                     mode.finish();
                     return true;
                 case R.id.openwith:
-                    Futils.openunknown(new File(plist.get(0).getDesc()), getActivity(), true);
+                    boolean useNewStack = sharedPref.getBoolean(PrefFrag.PREFERENCE_TEXTEDITOR_NEWSTACK, false);
+                    FileUtils.openunknown(new File(checkedItems.get(0).getDesc()), getActivity(), true, useNewStack);
                     return true;
                 case R.id.addshortcut:
-                    addShortcut(plist.get(0));
+                    addShortcut(checkedItems.get(0));
                     mode.finish();
                     return true;
                 default:
@@ -833,7 +793,41 @@ public class MainFragment extends android.support.v4.app.Fragment {
                 case FILE:
                     // local file system don't need an explicit load, we've set an observer to
                     // take actions on creation/moving/deletion/modification of file on current path
-                    break;
+
+                    // run media scanner
+                    String[] path = new String[1];
+                    String arg = intent.getStringExtra(MainActivity.KEY_INTENT_LOAD_LIST_FILE);
+
+                    // run media scanner for only one context
+                    if (arg != null && getMainActivity().getCurrentMainFragment() == MainFragment.this) {
+
+                        if (Build.VERSION.SDK_INT >= 19) {
+
+                            path[0] = arg;
+
+                            MediaScannerConnection.MediaScannerConnectionClient mediaScannerConnectionClient = new MediaScannerConnection.MediaScannerConnectionClient() {
+                                @Override
+                                public void onMediaScannerConnected() {
+
+                                }
+
+                                @Override
+                                public void onScanCompleted(String path, Uri uri) {
+
+                                    Log.d("SCAN completed", path);
+                                }
+                            };
+
+                            if (mediaScannerConnection != null) {
+                                mediaScannerConnection.disconnect();
+                            }
+                            mediaScannerConnection = new MediaScannerConnection(context, mediaScannerConnectionClient);
+                            //FileUtils.scanFile(context, mediaScannerConnection, path);
+                        } else {
+                            FileUtils.scanFile(arg, context);
+                        }
+                    }
+                    //break;
                 default:
                     updateList();
                     break;
@@ -841,6 +835,17 @@ public class MainFragment extends android.support.v4.app.Fragment {
         }
     };
 
+    private BroadcastReceiver decryptReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+
+            if (isEncryptOpen && encryptBaseFile != null) {
+                FileUtils.openFile(new File(encryptBaseFile.getPath()), getMainActivity(), sharedPref);
+                isEncryptOpen = false;
+            }
+        }
+    };
+
     public void home() {
         ma.loadlist((ma.home), false, OpenMode.FILE);
     }
@@ -848,11 +853,12 @@ public class MainFragment extends android.support.v4.app.Fragment {
     /**
      * method called when list item is clicked in the adapter
      *
+     * @param isBackButton is it the back button aka '..'
      * @param position the position
      * @param e the list item
      * @param imageView the check {@link RoundedImageView} that is to be animated
      */
-    public void onListItemClicked(int position, LayoutElement e, ImageView imageView) {
+    public void onListItemClicked(boolean isBackButton, int position, LayoutElementParcelable e, ImageView imageView) {
         if (results) {
             // check to initialize search results
             // if search task is been running, cancel it
@@ -860,9 +866,7 @@ public class MainFragment extends android.support.v4.app.Fragment {
             SearchWorkerFragment fragment = (SearchWorkerFragment) fragmentManager
                     .findFragmentByTag(MainActivity.TAG_ASYNC_HELPER);
             if (fragment != null) {
-
                 if (fragment.mSearchAsyncTask.getStatus() == AsyncTask.Status.RUNNING) {
-
                     fragment.mSearchAsyncTask.cancel(true);
                 }
                 getActivity().getSupportFragmentManager().beginTransaction().remove(fragment).commit();
@@ -876,85 +880,74 @@ public class MainFragment extends android.support.v4.app.Fragment {
         }
 
         if (selection) {
-            if (!e.getSize().equals(goback)) {
-                // the first {goback} item if back navigation is enabled
-                adapter.toggleChecked(position, imageView);
-            } else {
+            if (isBackButton) {
                 selection = false;
                 if (mActionMode != null)
                     mActionMode.finish();
                 mActionMode = null;
+            } else {
+                // the first {goback} item if back navigation is enabled
+                adapter.toggleChecked(position, imageView);
             }
         } else {
-            if (!e.getSize().equals(goback)) {
+            if(isBackButton) {
+                goBackItemClick();
+            } else {
                 // hiding search view if visible
-                if (MainActivity.isSearchViewEnabled) getMainActivity().hideSearchView();
-
-                String path;
-                if (!e.hasSymlink()) {
-
-                    path = e.getDesc();
-                } else {
-
-                    path = e.getSymlink();
+                if (getMainActivity().getAppbar().getSearchView().isEnabled()) {
+                    getMainActivity().getAppbar().getSearchView().hideSearchView();
                 }
 
-                // check if we're trying to click on encrypted file
-                if (!e.isDirectory() &&
-                        e.getDesc().endsWith(CryptUtil.CRYPT_EXTENSION)) {
+                String path = !e.hasSymlink()? e.getDesc():e.getSymlink();
+
+                if (e.isDirectory()) {
+                    computeScroll();
+                    loadlist(path, false, openMode);
+                } else if (e.getDesc().endsWith(CryptUtil.CRYPT_EXTENSION)) {
                     // decrypt the file
-                    getMainActivity().isEncryptOpen = true;
+                    isEncryptOpen = true;
 
-                    getMainActivity().encryptBaseFile = new BaseFile(getActivity().getExternalCacheDir().getPath()
+                    encryptBaseFile = new HybridFileParcelable(getActivity().getExternalCacheDir().getPath()
                             + "/"
                             + e.generateBaseFile().getName().replace(CryptUtil.CRYPT_EXTENSION, ""));
+                    encryptBaseFiles.add(encryptBaseFile);
 
                     EncryptDecryptUtils.decryptFile(getContext(), getMainActivity(), ma, openMode,
                             e.generateBaseFile(), getActivity().getExternalCacheDir().getPath(),
-                            utilsProvider);
-                    return;
-                }
-
-                if (e.isDirectory()) {
-
-                    computeScroll();
-                    loadlist(path, false, openMode);
+                            utilsProvider, true);
                 } else {
-
                     if (getMainActivity().mReturnIntent) {
+                        // are we here to return an intent to another app
                         returnIntentResults(e.generateBaseFile());
-                        return;
-                    }
+                    } else {
+                        switch (e.getMode()) {
+                            case SMB:
+                                try {
+                                    SmbFile smbFile = new SmbFile(e.getDesc());
+                                    launchSMB(smbFile, e.getlongSize(), getMainActivity());
+                                } catch (MalformedURLException ex) {
+                                    ex.printStackTrace();
+                                }
+                                break;
+                            case OTG:
+                                FileUtils.openFile(OTGUtil.getDocumentFile(e.getDesc(), getContext(), false),
+                                        (MainActivity) getActivity(), sharedPref);
+                                break;
+                            case DROPBOX:
+                            case BOX:
+                            case GDRIVE:
+                            case ONEDRIVE:
+                                Toast.makeText(getContext(), getResources().getString(R.string.please_wait), Toast.LENGTH_LONG).show();
+                                CloudUtil.launchCloud(e.generateBaseFile(), openMode, getMainActivity());
+                                break;
+                            default:
+                                FileUtils.openFile(new File(e.getDesc()), (MainActivity) getActivity(), sharedPref);
+                                break;
+                        }
 
-                    switch (e.getMode()) {
-                        case SMB:
-                            try {
-                                SmbFile smbFile = new SmbFile(e.getDesc());
-                                launchSMB(smbFile, e.getlongSize(), getMainActivity());
-                            } catch (MalformedURLException ex) {
-                                ex.printStackTrace();
-                            }
-                            break;
-                        case OTG:
-                            utils.openFile(OTGUtil.getDocumentFile(e.getDesc(), getContext(), false),
-                                    (MainActivity) getActivity());
-                            break;
-                        case DROPBOX:
-                        case BOX:
-                        case GDRIVE:
-                        case ONEDRIVE:
-                            Toast.makeText(getContext(), getResources().getString(R.string.please_wait), Toast.LENGTH_LONG).show();
-                            CloudUtil.launchCloud(e.generateBaseFile(), openMode, getMainActivity());
-                            break;
-                        default:
-                            utils.openFile(new File(e.getDesc()), (MainActivity) getActivity());
-                            break;
+                        dataUtils.addHistoryFile(e.getDesc());
                     }
-
-                    dataUtils.addHistoryFile(e.getDesc());
                 }
-            } else {
-                goBackItemClick();
             }
         }
     }
@@ -988,7 +981,11 @@ public class MainFragment extends android.support.v4.app.Fragment {
         loadlist(CURRENT_PATH, false, OpenMode.UNKNOWN);
     }
 
-    public void returnIntentResults(BaseFile baseFile) {
+    /**
+     * Returns the intent with uri corresponding to specific {@link HybridFileParcelable} back to external app
+     * @param baseFile
+     */
+    public void returnIntentResults(HybridFileParcelable baseFile) {
 
         getMainActivity().mReturnIntent = false;
 
@@ -996,7 +993,7 @@ public class MainFragment extends android.support.v4.app.Fragment {
         if (getMainActivity().mRingtonePickerIntent) {
 
             Uri mediaStoreUri = MediaStoreHack.getUriFromFile(baseFile.getPath(), getActivity());
-            System.out.println(mediaStoreUri.toString() + "\t" + MimeTypes.getMimeType(new File(baseFile.getPath())));
+            Log.d(getClass().getSimpleName(), mediaStoreUri.toString() + "\t" + MimeTypes.getMimeType(new File(baseFile.getPath())));
             intent.setDataAndType(mediaStoreUri, MimeTypes.getMimeType(new File(baseFile.getPath())));
             intent.putExtra(RingtoneManager.EXTRA_RINGTONE_PICKED_URI, mediaStoreUri);
             getActivity().setResult(FragmentActivity.RESULT_OK, intent);
@@ -1005,49 +1002,54 @@ public class MainFragment extends android.support.v4.app.Fragment {
 
             Log.d("pickup", "file");
 
-            switch (baseFile.getMode()) {
-                case FILE:
-                case ROOT:
-                    intent.setData(Uri.fromFile(new File(baseFile.getPath())));
-                    break;
-                case OTG:
-                    intent.setData(OTGUtil.getDocumentFile(baseFile.getPath(), getContext(), true).getUri());
-                    break;
-                case SMB:
-                case DROPBOX:
-                case GDRIVE:
-                case ONEDRIVE:
-                case BOX:
-                    Toast.makeText(getActivity(),
-                            getActivity().getResources().getString(R.string.smb_launch_error),
-                            Toast.LENGTH_LONG).show();
-
-                    getMainActivity().mReturnIntent = true;
-                    return;
-            }
+            Intent intentresult = new Intent();
 
-            getActivity().setResult(FragmentActivity.RESULT_OK, intent);
+            Uri resultUri = Utils.getUriForBaseFile(getActivity(), baseFile);
+            intentresult.setAction(Intent.ACTION_SEND);
+            intentresult.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
+
+            if (resultUri != null)
+                intentresult.setDataAndType(resultUri, MimeTypes.getExtension(baseFile.getPath()));
+
+            getActivity().setResult(FragmentActivity.RESULT_OK, intentresult);
             getActivity().finish();
+            //mode.finish();
         }
     }
 
-    LoadList loadList;
+    LoadFilesListTask loadFilesListTask;
+
+    /**
+     * This loads a path into the MainFragment.
+     * @param path the path to be loaded
+     * @param back if we're coming back from any directory and want the scroll to be restored
+     * @param openMode the mode in which the directory should be opened
+     */
+    public void loadlist(final String path, final boolean back, final OpenMode openMode) {
+        if (mActionMode != null) mActionMode.finish();
 
-    public void loadlist(String path, boolean back, OpenMode openMode) {
-        if (mActionMode != null) {
-            mActionMode.finish();
+        mSwipeRefreshLayout.setRefreshing(true);
+
+        if (loadFilesListTask != null && loadFilesListTask.getStatus() == AsyncTask.Status.RUNNING) {
+            loadFilesListTask.cancel(true);
         }
-        /*if(openMode==-1 && android.util.Patterns.EMAIL_ADDRESS.matcher(path).matches())
-            bindDrive(path);
-        else */
-        if (loadList != null) loadList.cancel(true);
-        loadList = new LoadList(ma.getActivity(), utilsProvider, back, ma, openMode, AppConfig.getInstance().getUtilsHandler());
-        loadList.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (path));
 
+        loadFilesListTask = new LoadFilesListTask(ma.getActivity(), path, ma, openMode, (data) -> {
+            if (data != null && data.second != null) {
+                setListElements(data.second, back, path, data.first, false, checkPathIsGrid(path));
+                mSwipeRefreshLayout.setRefreshing(false);
+            }
+        });
+        loadFilesListTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
     }
 
     void initNoFileLayout() {
-        nofilesview = rootView.findViewById(R.id.nofilelayout);
+        nofilesview = (SwipeRefreshLayout) rootView.findViewById(R.id.nofilelayout);
+        nofilesview.setColorSchemeColors(accentColor);
+        nofilesview.setOnRefreshListener(() -> {
+            loadlist((CURRENT_PATH), false, openMode);
+            nofilesview.setRefreshing(false);
+        });
         if (utilsProvider.getAppTheme().equals(AppTheme.LIGHT))
             ((ImageView) nofilesview.findViewById(R.id.image)).setColorFilter(Color.parseColor("#666666"));
         else {
@@ -1101,98 +1103,100 @@ public class MainFragment extends android.support.v4.app.Fragment {
      * @param results  is the list of elements a result from search
      * @param grid     whether to set grid view or list view
      */
-    public void createViews(ArrayList<LayoutElement> bitmap, boolean back, String path,
-                            final OpenMode openMode, boolean results, boolean grid) {
-        if (bitmap != null && isAdded()) {
-            synchronized (bitmap) {
-                boolean isOtg = path.equals(OTGUtil.PREFIX_OTG + "/"),
-                            isOnTheCloud = path.equals(CloudHandler.CLOUD_PREFIX_GOOGLE_DRIVE + "/")
-                                    || path.equals(CloudHandler.CLOUD_PREFIX_ONE_DRIVE + "/")
-                                    || path.equals(CloudHandler.CLOUD_PREFIX_BOX + "/")
-                                    || path.equals(CloudHandler.CLOUD_PREFIX_DROPBOX + "/");
-
-                if (GO_BACK_ITEM && !path.equals("/") && (openMode == OpenMode.FILE || openMode == OpenMode.ROOT)
-                        && !isOtg && !isOnTheCloud && (bitmap.size() == 0 || !bitmap.get(0).getSize().equals(goback))) {
-                    Bitmap iconBitmap = BitmapFactory.decodeResource(res, R.drawable.ic_arrow_left_white_24dp);
-                    bitmap.add(0, new LayoutElement(new BitmapDrawable(res, iconBitmap),
-                            "..", "", "", goback, 0, false, true, ""));
-                }
-              
-                if (bitmap.size() == 0 && !results) {
-                    nofilesview.setVisibility(View.VISIBLE);
-                    listView.setVisibility(View.GONE);
-                    mSwipeRefreshLayout.setEnabled(false);
-                } else {
-                    mSwipeRefreshLayout.setEnabled(true);
-                    nofilesview.setVisibility(View.GONE);
-                    listView.setVisibility(View.VISIBLE);
+    public void setListElements(ArrayList<LayoutElementParcelable> bitmap, boolean back, String path,
+                                final OpenMode openMode, boolean results, boolean grid) {
+        if (bitmap != null) {
+            LIST_ELEMENTS = bitmap;
+            CURRENT_PATH = path;
+            this.openMode = openMode;
+            reloadListElements(back, results, grid);
+        } else {
+            // list loading cancelled
+            // TODO: Add support for cancelling list loading
+            loadlist(home, true, OpenMode.FILE);
+        }
+    }
 
-                }
-                putLayoutElements(bitmap);
-                if (grid && IS_LIST)
-                    switchToGrid();
-                else if (!grid && !IS_LIST) switchToList();
-                if (adapter == null) {
-                    adapter = new RecyclerAdapter(ma, utilsProvider, bitmap, ma.getActivity(), SHOW_HEADERS);
-                } else {
-                    adapter.setItems(getLayoutElements());
-                }
-                stopAnims = true;
-                this.openMode = openMode;
-                if (openMode != OpenMode.CUSTOM)
-                    dataUtils.addHistoryFile(path);
-                //mSwipeRefreshLayout.setRefreshing(false);
-
-                listView.setAdapter(adapter);
-                if (!addheader) {
-                    //listView.removeItemDecoration(headersDecor);
-                    listView.removeItemDecoration(dividerItemDecoration);
-                    addheader = true;
-                }
-                if (addheader && IS_LIST) {
-                    dividerItemDecoration = new DividerItemDecoration(getActivity(), true, SHOW_DIVIDERS);
-                    listView.addItemDecoration(dividerItemDecoration);
-                    addheader = false;
-                }
-                if (!results) this.results = false;
-                CURRENT_PATH = path;
-                if (back) {
-                    if (scrolls.containsKey(CURRENT_PATH)) {
-                        Bundle b = scrolls.get(CURRENT_PATH);
-                        if (IS_LIST)
-                            mLayoutManager.scrollToPositionWithOffset(b.getInt("index"), b.getInt("top"));
-                        else
-                            mLayoutManagerGrid.scrollToPositionWithOffset(b.getInt("index"), b.getInt("top"));
-                    }
-                }
+    public void reloadListElements(boolean back, boolean results, boolean grid) {
+        if (isAdded()) {
+            boolean isOtg = CURRENT_PATH.equals(OTGUtil.PREFIX_OTG + "/"),
+                    isOnTheCloud = CURRENT_PATH.equals(CloudHandler.CLOUD_PREFIX_GOOGLE_DRIVE + "/")
+                            || CURRENT_PATH.equals(CloudHandler.CLOUD_PREFIX_ONE_DRIVE + "/")
+                            || CURRENT_PATH.equals(CloudHandler.CLOUD_PREFIX_BOX + "/")
+                            || CURRENT_PATH.equals(CloudHandler.CLOUD_PREFIX_DROPBOX + "/");
 
-                //floatingActionButton.show();
-                getMainActivity().updatePaths(no);
-                listView.stopScroll();
-                fastScroller.setRecyclerView(listView, IS_LIST ? 1 : columns);
-                mToolbarContainer.addOnOffsetChangedListener(new AppBarLayout.OnOffsetChangedListener() {
-                    @Override
-                    public void onOffsetChanged(AppBarLayout appBarLayout, int verticalOffset) {
-                        fastScroller.updateHandlePosition(verticalOffset, 112);
-                        //    fastScroller.setPadding(fastScroller.getPaddingLeft(),fastScroller.getTop(),fastScroller.getPaddingRight(),112+verticalOffset);
-                        //      fastScroller.updateHandlePosition();
-                    }
-                });
-                fastScroller.registerOnTouchListener(new FastScroller.onTouchListener() {
-                    @Override
-                    public void onTouch() {
-                        if (stopAnims && adapter != null) {
-                            stopAnimation();
-                            stopAnims = false;
-                        }
-                    }
-                });
+            if (GO_BACK_ITEM && !CURRENT_PATH.equals("/")
+                    && (openMode == OpenMode.FILE || openMode == OpenMode.ROOT) && !isOtg && !isOnTheCloud
+                    && (LIST_ELEMENTS.size() == 0 || !LIST_ELEMENTS.get(0).getSize().equals(getString(R.string.goback)))) {
+                LIST_ELEMENTS.add(0, getBackElement());
+            }
 
-                if (buttons.getVisibility() == View.VISIBLE) getMainActivity().bbar(this);
+            if (LIST_ELEMENTS.size() == 0 && !results) {
+                nofilesview.setVisibility(View.VISIBLE);
+                listView.setVisibility(View.GONE);
+                mSwipeRefreshLayout.setEnabled(false);
+            } else {
+                mSwipeRefreshLayout.setEnabled(true);
+                nofilesview.setVisibility(View.GONE);
+                listView.setVisibility(View.VISIBLE);
+            }
+
+            if (grid && IS_LIST) switchToGrid();
+            else if (!grid && !IS_LIST) switchToList();
+
+            if (adapter == null) {
+                adapter = new RecyclerAdapter(ma, utilsProvider, sharedPref, LIST_ELEMENTS, ma.getActivity(), SHOW_HEADERS);
+            } else {
+                adapter.setItems(new ArrayList<>(LIST_ELEMENTS));
+            }
 
-                startFileObserver();
-                //getMainActivity().invalidateFab(openMode);
+            stopAnims = true;
+
+            if (openMode != OpenMode.CUSTOM) {
+                dataUtils.addHistoryFile(CURRENT_PATH);
             }
+
+            listView.setAdapter(adapter);
+
+            if (!addheader) {
+                listView.removeItemDecoration(dividerItemDecoration);
+                addheader = true;
+            }
+
+            if (addheader && IS_LIST) {
+                dividerItemDecoration = new DividerItemDecoration(getActivity(), true, SHOW_DIVIDERS);
+                listView.addItemDecoration(dividerItemDecoration);
+                addheader = false;
+            }
+
+            if (!results) {
+                this.results = false;
+            }
+
+            if (back && scrolls.containsKey(CURRENT_PATH)) {
+                Bundle b = scrolls.get(CURRENT_PATH);
+                int index = b.getInt("index"), top = b.getInt("top");
+                if (IS_LIST) {
+                    mLayoutManager.scrollToPositionWithOffset(index, top);
+                } else {
+                    mLayoutManagerGrid.scrollToPositionWithOffset(index, top);
+                }
+            }
+
+            getMainActivity().updatePaths(no);
+            listView.stopScroll();
+            fastScroller.setRecyclerView(listView, IS_LIST? 1:columns);
+            mToolbarContainer.addOnOffsetChangedListener((appBarLayout, verticalOffset) -> {
+                fastScroller.updateHandlePosition(verticalOffset, 112);
+            });
+            fastScroller.registerOnTouchListener(() -> {
+                if (stopAnims && adapter != null) {
+                    stopAnimation();
+                    stopAnims = false;
+                }
+            });
+
+            startFileObserver();
         } else {
             // list loading cancelled
             // TODO: Add support for cancelling list loading
@@ -1200,33 +1204,41 @@ public class MainFragment extends android.support.v4.app.Fragment {
         }
     }
 
-    private void startFileObserver() {
+    private LayoutElementParcelable getBackElement() {
+        if (backIcon == null || back == null) {
+            backIcon = res.getDrawable(R.drawable.ic_arrow_left_white_24dp);
+            back = new LayoutElementParcelable(backIcon, "..", "", "",
+                    getString(R.string.goback), 0, false, true, "");
+        }
 
-        AppConfig.runInBackground(new Runnable() {
-            @Override
-            public void run() {
-                switch (openMode) {
-                    case ROOT:
-                    case FILE:
-                        // watch the current directory
-                        File file = new File(CURRENT_PATH);
+        return back;
+    }
 
-                        if (file.isDirectory() && file.canRead()) {
+    private void startFileObserver() {
+        switch (openMode) {
+            case ROOT:
+            case FILE:
+                if(customFileObserver != null && !customFileObserver.wasStopped()
+                        && customFileObserver.getPath().equals(getCurrentPath())) {
+                    return;
+                }
 
-                            if (customFileObserver != null) {
-                                // already a watcher instantiated, first it should be stopped
-                                customFileObserver.stopWatching();
-                            }
+                File file = new File(CURRENT_PATH);
 
-                            customFileObserver = new CustomFileObserver(CURRENT_PATH);
-                            customFileObserver.startWatching();
-                        }
-                        break;
-                    default:
-                        break;
+                if (file.isDirectory() && file.canRead()) {
+                    if (customFileObserver != null) {
+                        // already a watcher instantiated, first it should be stopped
+                        customFileObserver.stopWatching();
+                    }
+
+                    customFileObserver = new CustomFileObserver(CURRENT_PATH,
+                            new FileHandler(this, utilsProvider, listView));
+                    customFileObserver.startWatching();
                 }
-            }
-        });
+                break;
+            default:
+                break;
+        }
     }
 
     /**
@@ -1234,37 +1246,23 @@ public class MainFragment extends android.support.v4.app.Fragment {
      *
      * @param f the file to rename
      */
-    public void rename(final BaseFile f) {
+    public void rename(final HybridFileParcelable f) {
         MaterialDialog.Builder builder = new MaterialDialog.Builder(getActivity());
         String name = f.getName();
-        builder.input("", name, false, new MaterialDialog.InputCallback() {
-            @Override
-            public void onInput(MaterialDialog materialDialog, CharSequence charSequence) {
-
-            }
-        });
+        builder.input("", name, false, (materialDialog, charSequence) -> {});
         builder.theme(utilsProvider.getAppTheme().getMaterialDialogTheme());
         builder.title(getResources().getString(R.string.rename));
 
-        builder.onNegative(new MaterialDialog.SingleButtonCallback() {
-            @Override
-            public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
+        builder.onNegative((dialog, which) -> dialog.cancel());
 
-                dialog.cancel();
-            }
-        });
-
-        builder.onPositive(new MaterialDialog.SingleButtonCallback() {
-            @Override
-            public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
-                String name = dialog.getInputEditText().getText().toString();
-                if (f.isSmb()){
-                    if (f.isDirectory() && !name.endsWith("/"))
-                        name = name + "/";
-                }
-                getMainActivity().mainActivityHelper.rename(openMode, f.getPath(),
-                        CURRENT_PATH + "/" + name, getActivity(), BaseActivity.rootMode);
+        builder.onPositive((dialog, which) -> {
+            String name1 = dialog.getInputEditText().getText().toString();
+            if (f.isSmb()){
+                if (f.isDirectory() && !name1.endsWith("/"))
+                    name1 = name1 + "/";
             }
+            getMainActivity().mainActivityHelper.rename(openMode, f.getPath(),
+                    CURRENT_PATH + "/" + name1, getActivity(), ThemedActivity.rootMode);
         });
 
         builder.positiveText(R.string.save);
@@ -1277,14 +1275,9 @@ public class MainFragment extends android.support.v4.app.Fragment {
         // place cursor at the starting of edit text by posting a runnable to edit text
         // this is done because in case android has not populated the edit text layouts yet, it'll
         // reset calls to selection if not posted in message queue
-        materialDialog.getInputEditText().post(new Runnable() {
-            @Override
-            public void run() {
-
-                if (!f.isDirectory()) {
-
-                    materialDialog.getInputEditText().setSelection(f.getNameString(getContext()).length());
-                }
+        materialDialog.getInputEditText().post(() -> {
+            if (!f.isDirectory()) {
+                materialDialog.getInputEditText().setSelection(f.getNameString(getContext()).length());
             }
         });
     }
@@ -1308,7 +1301,7 @@ public class MainFragment extends android.support.v4.app.Fragment {
             return;
         }
 
-        HFile currentFile = new HFile(openMode, CURRENT_PATH);
+        HybridFile currentFile = new HybridFile(openMode, CURRENT_PATH);
         if (!results) {
             if (!mRetainSearchTask) {
                 // normal case
@@ -1339,7 +1332,7 @@ public class MainFragment extends android.support.v4.app.Fragment {
                             || CURRENT_PATH.equals(CloudHandler.CLOUD_PREFIX_ONE_DRIVE + "/")
                             )
                         getMainActivity().exit();
-                    else if (utils.canGoBack(getContext(), currentFile)) {
+                    else if (FileUtils.canGoBack(getContext(), currentFile)) {
                         loadlist(currentFile.getParent(getContext()), true, openMode);
                     } else getMainActivity().exit();
                 }
@@ -1350,17 +1343,17 @@ public class MainFragment extends android.support.v4.app.Fragment {
                 if (MainActivityHelper.SEARCH_TEXT != null) {
 
                     // starting the search query again :O
-                    getMainActivity().mainFragment = (MainFragment) getMainActivity().getFragment().getTab();
+                    getMainActivity().mainFragment = (MainFragment) getMainActivity().getTabFragment().getCurrentTabFragment();
                     FragmentManager fm = getMainActivity().getSupportFragmentManager();
 
                     // getting parent path to resume search from there
-                    String parentPath = new HFile(openMode, CURRENT_PATH).getParent(getActivity());
+                    String parentPath = new HybridFile(openMode, CURRENT_PATH).getParent(getActivity());
                     // don't fuckin' remove this line, we need to change
                     // the path back to parent on back press
                     CURRENT_PATH = parentPath;
 
                     MainActivityHelper.addSearchFragment(fm, new SearchWorkerFragment(),
-                            parentPath, MainActivityHelper.SEARCH_TEXT, openMode, BaseActivity.rootMode,
+                            parentPath, MainActivityHelper.SEARCH_TEXT, openMode, ThemedActivity.rootMode,
                             sharedPref.getBoolean(SearchWorkerFragment.KEY_REGEX, false),
                             sharedPref.getBoolean(SearchWorkerFragment.KEY_REGEX_MATCHES, false));
                 } else loadlist(CURRENT_PATH, true, OpenMode.UNKNOWN);
@@ -1384,13 +1377,10 @@ public class MainFragment extends android.support.v4.app.Fragment {
     public void reauthenticateSmb() {
         if (smbPath != null) {
             try {
-                getMainActivity().runOnUiThread(new Runnable() {
-                    @Override
-                    public void run() {
-                        int i;
-                        if ((i = dataUtils.containsServer(smbPath)) != -1) {
-                            getMainActivity().showSMBDialog(dataUtils.getServers().get(i)[0], smbPath, true);
-                        }
+                getMainActivity().runOnUiThread(() -> {
+                    int i;
+                    if ((i = dataUtils.containsServer(smbPath)) != -1) {
+                        getMainActivity().showSMBDialog(dataUtils.getServers().get(i)[0], smbPath, true);
                     }
                 });
             } catch (Exception e) {
@@ -1404,13 +1394,12 @@ public class MainFragment extends android.support.v4.app.Fragment {
             loadlist(home, false, OpenMode.FILE);
             return;
         }
-        HFile currentFile = new HFile(openMode, CURRENT_PATH);
+        HybridFile currentFile = new HybridFile(openMode, CURRENT_PATH);
         if (!results) {
             if (selection) {
                 adapter.toggleChecked(false);
             } else {
                 if (openMode == OpenMode.SMB) {
-
                     try {
                         if (!CURRENT_PATH.equals(smbPath)) {
                             String path = (new SmbFile(CURRENT_PATH).getParent());
@@ -1419,15 +1408,13 @@ public class MainFragment extends android.support.v4.app.Fragment {
                     } catch (MalformedURLException e) {
                         e.printStackTrace();
                     }
-                } else if (CURRENT_PATH.equals("/") || CURRENT_PATH.equals(home) ||
-                        CURRENT_PATH.equals(OTGUtil.PREFIX_OTG)
+                } else if (CURRENT_PATH.equals("/") || CURRENT_PATH.equals(OTGUtil.PREFIX_OTG)
                         || CURRENT_PATH.equals(CloudHandler.CLOUD_PREFIX_BOX + "/")
                         || CURRENT_PATH.equals(CloudHandler.CLOUD_PREFIX_DROPBOX + "/")
                         || CURRENT_PATH.equals(CloudHandler.CLOUD_PREFIX_GOOGLE_DRIVE + "/")
-                        || CURRENT_PATH.equals(CloudHandler.CLOUD_PREFIX_ONE_DRIVE + "/")
-                        )
+                        || CURRENT_PATH.equals(CloudHandler.CLOUD_PREFIX_ONE_DRIVE + "/")) {
                     getMainActivity().exit();
-                else if (utils.canGoBack(getContext(), currentFile)) {
+                } else if (FileUtils.canGoBack(getContext(), currentFile)) {
                     loadlist(currentFile.getParent(getContext()), true, openMode);
                 } else getMainActivity().exit();
             }
@@ -1438,7 +1425,7 @@ public class MainFragment extends android.support.v4.app.Fragment {
 
     public void updateList() {
         computeScroll();
-        ic.cleanup();
+        iconHolder.cleanup();
         loadlist((CURRENT_PATH), true, openMode);
     }
 
@@ -1465,9 +1452,13 @@ public class MainFragment extends android.support.v4.app.Fragment {
     @Override
     public void onResume() {
         super.onResume();
-        (getActivity()).registerReceiver(receiver2, new IntentFilter("loadlist"));
+        (getActivity()).registerReceiver(receiver2, new IntentFilter(MainActivity.KEY_INTENT_LOAD_LIST));
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
 
-        //startFileObserver();
+            (getActivity()).registerReceiver(decryptReceiver, new IntentFilter(EncryptDecryptUtils.DECRYPT_BROADCAST));
+        }
+        startFileObserver();
         fixIcons(false);
     }
 
@@ -1475,36 +1466,48 @@ public class MainFragment extends android.support.v4.app.Fragment {
     public void onPause() {
         super.onPause();
         (getActivity()).unregisterReceiver(receiver2);
+        if(customFileObserver != null) {
+            customFileObserver.stopWatching();
+        }
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            (getActivity()).unregisterReceiver(decryptReceiver);
+        }
     }
 
     @Override
     public void onStop() {
         super.onStop();
 
-        if (customFileObserver != null)
-            customFileObserver.stopWatching();
+        if (mediaScannerConnection != null)
+            mediaScannerConnection.disconnect();
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
+
+            if (!isEncryptOpen && encryptBaseFiles.size() != 0) {
+                // we've opened the file and are ready to delete it
+                new DeleteTask(getMainActivity().getContentResolver(), getActivity()).execute(encryptBaseFiles);
+            }
+        }
     }
 
     void fixIcons(boolean forceReload) {
-        if (getLayoutElements() == null) return;
-        BitmapDrawable iconDrawable;
-
-        synchronized (getLayoutElements()) {
-            for (LayoutElement layoutElement : getLayoutElements()) {
-                if (forceReload || layoutElement.getImageId() == null) {
-                    iconDrawable = layoutElement.isDirectory() ?
-                            folder : Icons.loadMimeIcon(layoutElement.getDesc(), !IS_LIST, res);
-                    layoutElement.setImageId(iconDrawable);
-                }
+        if (LIST_ELEMENTS == null) return;
+        Drawable iconDrawable;
+        for (LayoutElementParcelable layoutElement : LIST_ELEMENTS) {
+            if (forceReload || layoutElement.getImageId() == null) {
+                iconDrawable = layoutElement.isDirectory()?
+                        folder:Icons.loadMimeIcon(layoutElement.getDesc(), !IS_LIST, res);
+                layoutElement.setImageId(iconDrawable);
             }
         }
     }
 
-    public ArrayList<LayoutElement> addToSmb(SmbFile[] mFile, String path) throws SmbException {
-        ArrayList<LayoutElement> a = new ArrayList<>();
+    public ArrayList<LayoutElementParcelable> addToSmb(SmbFile[] mFile, String path) throws SmbException {
+        ArrayList<LayoutElementParcelable> a = new ArrayList<>();
         if (searchHelper.size() > 500) searchHelper.clear();
         for (SmbFile aMFile : mFile) {
-            if (dataUtils.getHiddenfiles().contains(aMFile.getPath()))
+            if (dataUtils.isFileHidden(aMFile.getPath()))
                 continue;
             String name = aMFile.getName();
             name = (aMFile.isDirectory() && name.endsWith("/")) ? name.substring(0, name.length() - 1) : name;
@@ -1513,7 +1516,7 @@ public class MainFragment extends android.support.v4.app.Fragment {
             }
             if (aMFile.isDirectory()) {
                 folder_count++;
-                LayoutElement layoutElement = new LayoutElement(folder, name, aMFile.getPath(),
+                LayoutElementParcelable layoutElement = new LayoutElementParcelable(folder, name, aMFile.getPath(),
                         "", "", "", 0, false, aMFile.lastModified() + "", true);
                 layoutElement.setMode(OpenMode.SMB);
                 searchHelper.add(layoutElement.generateBaseFile());
@@ -1521,7 +1524,7 @@ public class MainFragment extends android.support.v4.app.Fragment {
             } else {
                 file_count++;
                 try {
-                    LayoutElement layoutElement = new LayoutElement(
+                    LayoutElementParcelable layoutElement = new LayoutElementParcelable(
                             Icons.loadMimeIcon(aMFile.getPath(), !IS_LIST, res), name,
                             aMFile.getPath(), "", "", Formatter.formatFileSize(getContext(),
                             aMFile.length()), aMFile.length(), false,
@@ -1538,17 +1541,17 @@ public class MainFragment extends android.support.v4.app.Fragment {
     }
 
     // method to add search result entry to the LIST_ELEMENT arrayList
-    private LayoutElement addTo(BaseFile mFile) {
+    private LayoutElementParcelable addTo(HybridFileParcelable mFile) {
         File f = new File(mFile.getPath());
         String size = "";
-        if (!dataUtils.getHiddenfiles().contains(mFile.getPath())) {
+        if (!dataUtils.isFileHidden(mFile.getPath())) {
             if (mFile.isDirectory()) {
                 size = "";
-                LayoutElement layoutElement = new LayoutElement(folder, f.getPath(), mFile.getPermission(),
+                LayoutElementParcelable layoutElement = new LayoutElementParcelable(folder, f.getPath(), mFile.getPermission(),
                         mFile.getLink(), size, 0, true, false, mFile.getDate() + "");
 
                 layoutElement.setMode(mFile.getMode());
-                addLayoutElement(layoutElement);
+                LIST_ELEMENTS.add(layoutElement);
                 folder_count++;
                 return layoutElement;
             } else {
@@ -1565,10 +1568,10 @@ public class MainFragment extends android.support.v4.app.Fragment {
                     //e.printStackTrace();
                 }
                 try {
-                    LayoutElement layoutElement = new LayoutElement(Icons.loadMimeIcon(f.getPath(), !IS_LIST, res),
+                    LayoutElementParcelable layoutElement = new LayoutElementParcelable(Icons.loadMimeIcon(f.getPath(), !IS_LIST, res),
                             f.getPath(), mFile.getPermission(), mFile.getLink(), size, longSize, false, false, mFile.getDate() + "");
                     layoutElement.setMode(mFile.getMode());
-                    addLayoutElement(layoutElement);
+                    LIST_ELEMENTS.add(layoutElement);
                     file_count++;
                     return layoutElement;
                 } catch (Exception e) {
@@ -1583,6 +1586,9 @@ public class MainFragment extends android.support.v4.app.Fragment {
     @Override
     public void onDestroy() {
         super.onDestroy();
+
+        // not guaranteed to be called unless we call #finish();
+        // please move code to onStop
     }
 
     public void hide(String path) {
@@ -1592,12 +1598,12 @@ public class MainFragment extends android.support.v4.app.Fragment {
             File f1 = new File(path + "/" + ".nomedia");
             if (!f1.exists()) {
                 try {
-                    getMainActivity().mainActivityHelper.mkFile(new HFile(OpenMode.FILE, f1.getPath()), this);
+                    getMainActivity().mainActivityHelper.mkFile(new HybridFile(OpenMode.FILE, f1.getPath()), this);
                 } catch (Exception e) {
                     e.printStackTrace();
                 }
             }
-            Futils.scanFile(path, getActivity());
+            FileUtils.scanFile(path, getActivity());
         }
 
     }
@@ -1606,7 +1612,7 @@ public class MainFragment extends android.support.v4.app.Fragment {
         return CURRENT_PATH;
     }
 
-    private void addShortcut(LayoutElement path) {
+    private void addShortcut(LayoutElementParcelable path) {
         //Adding shortcut for MainActivity
         //on Home screen
         Intent shortcutIntent = new Intent(getActivity().getApplicationContext(),
@@ -1625,29 +1631,29 @@ public class MainFragment extends android.support.v4.app.Fragment {
 
     // This method is used to implement the modification for the pre Searching
     public void onSearchPreExecute(String query) {
-        pathname.setText(getMainActivity().getString(R.string.empty));
-        mFullPath.setText(getMainActivity().getString(R.string.searching) + " " + query);
+        getMainActivity().getAppbar().getBottomBar().setPathText("");
+        getMainActivity().getAppbar().getBottomBar().setFullPathText(getString(R.string.searching, query));
     }
 
 
     // adds search results based on result boolean. If false, the adapter is initialised with initial
     // values, if true, new values are added to the adapter.
-    public void addSearchResult(BaseFile a, String query) {
+    public void addSearchResult(HybridFileParcelable a, String query) {
         if (listView != null) {
 
             // initially clearing the array for new result set
             if (!results) {
-                getLayoutElements().clear();
+                LIST_ELEMENTS.clear();
                 file_count = 0;
                 folder_count = 0;
             }
 
             // adding new value to LIST_ELEMENTS
-            LayoutElement layoutElementAdded = addTo(a);
+            LayoutElementParcelable layoutElementAdded = addTo(a);
             if (!results) {
-                createViews(getLayoutElements(), false, (CURRENT_PATH), openMode, false, !IS_LIST);
-                pathname.setText(getMainActivity().getString(R.string.empty));
-                mFullPath.setText(getMainActivity().getString(R.string.searching) + " " + query);
+                reloadListElements(false, false, !IS_LIST);
+                getMainActivity().getAppbar().getBottomBar().setPathText("");
+                getMainActivity().getAppbar().getBottomBar().setFullPathText(getString(R.string.searching, query));
                 results = true;
             } else {
                 adapter.addItem(layoutElementAdded);
@@ -1659,20 +1665,20 @@ public class MainFragment extends android.support.v4.app.Fragment {
     public void onSearchCompleted(final String query) {
         if (!results) {
             // no results were found
-            getLayoutElements().clear();
+            LIST_ELEMENTS.clear();
         }
         new AsyncTask<Void, Void, Void>() {
             @Override
             protected Void doInBackground(Void... params) {
-                Collections.sort(getLayoutElements(), new FileListSorter(dsort, sortby, asc));
+                Collections.sort(LIST_ELEMENTS, new FileListSorter(dsort, sortby, asc));
                 return null;
             }
 
             @Override
             public void onPostExecute(Void c) {
-                createViews(getLayoutElements(), true, (CURRENT_PATH), openMode, true, !IS_LIST);// TODO: 7/7/2017 this is really inneffient, use RecycleAdapter's createHeaders()
-                pathname.setText(getMainActivity().getString(R.string.empty));
-                mFullPath.setText(getMainActivity().getString(R.string.searchresults) + " " + query);
+                reloadListElements(true, true, !IS_LIST);// TODO: 7/7/2017 this is really inneffient, use RecycleAdapter's createHeaders()
+                getMainActivity().getAppbar().getBottomBar().setPathText("");
+                getMainActivity().getAppbar().getBottomBar().setFullPathText(getString(R.string.searchresults, query));
             }
         }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
     }
@@ -1693,23 +1699,21 @@ public class MainFragment extends android.support.v4.app.Fragment {
                     */
 
                     s.setStreamSrc(smbFile, si);
-                    activity.runOnUiThread(new Runnable() {
-                        public void run() {
-                            try {
-                                Uri uri = Uri.parse(Streamer.URL + Uri.fromFile(new File(Uri.parse(smbFile.getPath()).getPath())).getEncodedPath());
-                                Intent i = new Intent(Intent.ACTION_VIEW);
-                                i.setDataAndType(uri, MimeTypes.getMimeType(new File(smbFile.getPath())));
-                                PackageManager packageManager = activity.getPackageManager();
-                                List<ResolveInfo> resInfos = packageManager.queryIntentActivities(i, 0);
-                                if (resInfos != null && resInfos.size() > 0)
-                                    activity.startActivity(i);
-                                else
-                                    Toast.makeText(activity,
-                                            activity.getResources().getString(R.string.smb_launch_error),
-                                            Toast.LENGTH_SHORT).show();
-                            } catch (ActivityNotFoundException e) {
-                                e.printStackTrace();
-                            }
+                    activity.runOnUiThread(() -> {
+                        try {
+                            Uri uri = Uri.parse(Streamer.URL + Uri.fromFile(new File(Uri.parse(smbFile.getPath()).getPath())).getEncodedPath());
+                            Intent i = new Intent(Intent.ACTION_VIEW);
+                            i.setDataAndType(uri, MimeTypes.getMimeType(new File(smbFile.getPath())));
+                            PackageManager packageManager = activity.getPackageManager();
+                            List<ResolveInfo> resInfos = packageManager.queryIntentActivities(i, 0);
+                            if (resInfos != null && resInfos.size() > 0)
+                                activity.startActivity(i);
+                            else
+                                Toast.makeText(activity,
+                                        activity.getResources().getString(R.string.smb_launch_error),
+                                        Toast.LENGTH_SHORT).show();
+                        } catch (ActivityNotFoundException e) {
+                            e.printStackTrace();
                         }
                     });
 
@@ -1729,106 +1733,23 @@ public class MainFragment extends android.support.v4.app.Fragment {
         return (MainActivity) getActivity();
     }
 
-    public synchronized void addLayoutElement(LayoutElement layoutElement) {
-        this.LIST_ELEMENTS.add(layoutElement);
-    }
-
-    public synchronized LayoutElement getLayoutElement(int index) {
-        return this.LIST_ELEMENTS.get(index);
-    }
-
-    public synchronized void putLayoutElements(ArrayList<LayoutElement> layoutElements) {
-        this.LIST_ELEMENTS = layoutElements;
+    public ArrayList<LayoutElementParcelable> getElementsList() {
+        return LIST_ELEMENTS;
     }
 
-    public synchronized ArrayList<LayoutElement> getLayoutElements() {
-        return this.LIST_ELEMENTS;
+    @Override
+    public void changePath(String path) {
+        loadlist(path, false, openMode);
     }
 
-    public synchronized int getLayoutElementSize() {
-        return this.LIST_ELEMENTS.size();
+    @Override
+    public String getPath() {
+        return getCurrentPath();
     }
 
-    public synchronized void removeLayoutElement(int index) {
-        this.LIST_ELEMENTS.remove(index);
+    @Override
+    public int getRootDrawable() {
+        return R.drawable.root;
     }
 
-    /**
-     * Inner class which monitors any change in local filesystem and updates the adapter
-     * Makes use of inotify in Linux
-     */
-    private class CustomFileObserver extends FileObserver {
-
-        CustomFileObserver(String path) {
-            super(path);
-        }
-
-        @Override
-        public void onEvent(int event, String path) {
-
-            synchronized (getLayoutElements()) {
-
-                switch (event) {
-                    case CREATE:
-                    case MOVED_TO:
-                        /*HFile fileCreated = new HFile(openMode, CURRENT_PATH + "/" + path);
-                        addLayoutElement(fileCreated.generateLayoutElement(MainFragment.this, utilsProvider));
-                        Log.d(getClass().getSimpleName(), "ADDED: " + CURRENT_PATH + "/" + path);*/
-                        break;
-                    case DELETE:
-                    case MOVED_FROM:
-                        /*for (int i = 0; i < getLayoutElementSize(); i++) {
-                            File currentFile = new File(getLayoutElement(i).getDesc());
-                            if (currentFile.getName().equals(path)) {
-                                removeLayoutElement(i);
-                                break;
-                            }
-                        }
-                        Log.d(getClass().getSimpleName(), "REMOVED: " + CURRENT_PATH + "/" + path);*/
-                        break;
-                    case DELETE_SELF:
-                    case MOVE_SELF:
-                        getActivity().runOnUiThread(new Runnable() {
-                            @Override
-                            public void run() {
-
-                                goBack();
-                            }
-                        });
-                        return;
-                    case ATTRIB:
-                    case MODIFY:
-                        // just generate adapter list without making any change to it's content
-                        break;
-                    default:
-                        return;
-                }
-
-                getActivity().runOnUiThread(new Runnable() {
-                    @Override
-                    public void run() {
-
-                        /*if (listView.getVisibility() == View.VISIBLE) {
-                            if (getLayoutElements().size() == 0) {
-
-                                // no item left in list, recreate views
-                                createViews(getLayoutElements(), true, CURRENT_PATH, openMode, results, !IS_LIST);
-                            } else {
-
-                                // we already have some elements in list view, invalidate the adapter
-                                adapter.setItems(getLayoutElements());
-                            }
-                        } else {
-                            // there was no list view, means the directory was empty
-                            loadlist(CURRENT_PATH, true, openMode);
-                        }*/
-
-                        computeScroll();
-                        loadlist(CURRENT_PATH, true, openMode);
-                    }
-                });
-            }
-        }
-
-    }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/fragments/ProcessViewer.java b/app/src/main/java/com/amaze/filemanager/fragments/ProcessViewerFragment.java
similarity index 85%
rename from app/src/main/java/com/amaze/filemanager/fragments/ProcessViewer.java
rename to app/src/main/java/com/amaze/filemanager/fragments/ProcessViewerFragment.java
index ab1ab3ee7..443000e50 100644
--- a/app/src/main/java/com/amaze/filemanager/fragments/ProcessViewer.java
+++ b/app/src/main/java/com/amaze/filemanager/fragments/ProcessViewerFragment.java
@@ -44,15 +44,14 @@ import android.widget.Toast;
 
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.MainActivity;
-import com.amaze.filemanager.services.CopyService;
-import com.amaze.filemanager.services.EncryptService;
-import com.amaze.filemanager.services.ExtractService;
-import com.amaze.filemanager.services.ZipTask;
-import com.amaze.filemanager.ui.icons.IconUtils;
-import com.amaze.filemanager.utils.DataPackage;
-import com.amaze.filemanager.utils.files.Futils;
+import com.amaze.filemanager.asynchronous.services.CopyService;
+import com.amaze.filemanager.asynchronous.services.EncryptService;
+import com.amaze.filemanager.asynchronous.services.ExtractService;
+import com.amaze.filemanager.asynchronous.services.ZipService;
+import com.amaze.filemanager.utils.CopyDataParcelable;
 import com.amaze.filemanager.utils.Utils;
 import com.amaze.filemanager.utils.color.ColorUsage;
+import com.amaze.filemanager.utils.files.FileUtils;
 import com.amaze.filemanager.utils.theme.AppTheme;
 import com.github.mikephil.charting.charts.LineChart;
 import com.github.mikephil.charting.components.XAxis;
@@ -65,11 +64,10 @@ import com.github.mikephil.charting.interfaces.datasets.ILineDataSet;
 import java.util.ArrayList;
 import java.util.concurrent.TimeUnit;
 
-public class ProcessViewer extends Fragment {
+public class ProcessViewerFragment extends Fragment {
 
     boolean isInitialized = false;
     SharedPreferences sharedPrefs;
-    IconUtils icons;
     MainActivity mainActivity;
     int accentColor, primaryColor;
     ImageButton mCancelButton;
@@ -96,10 +94,9 @@ public class ProcessViewer extends Fragment {
         if (mainActivity.getAppTheme().equals(AppTheme.DARK))
             rootView.setBackgroundResource((R.color.cardView_background));
         mainActivity.updateViews(new ColorDrawable(primaryColor));
-        mainActivity.setActionBarTitle(getResources().getString(R.string.process_viewer));
+        mainActivity.getAppbar().setTitle(R.string.process_viewer);
         mainActivity.floatingActionButton.hideMenuButton(true);
         sharedPrefs = PreferenceManager.getDefaultSharedPreferences(getActivity());
-        icons = new IconUtils(sharedPrefs, getActivity());
         mainActivity.supportInvalidateOptionsMenu();
 
         mCardView = (CardView) rootView.findViewById(R.id.card_view);
@@ -144,19 +141,13 @@ public class ProcessViewer extends Fragment {
 
             copyService.setProgressListener(new CopyService.ProgressListener() {
                 @Override
-                public void onUpdate(final DataPackage dataPackage) {
+                public void onUpdate(final CopyDataParcelable dataPackage) {
                     if (getActivity() == null || getActivity().getSupportFragmentManager().
                             findFragmentByTag(MainActivity.KEY_INTENT_PROCESS_VIEWER) == null) {
                         // callback called when we're not inside the app
                         return;
                     }
-                    getActivity().runOnUiThread(new Runnable() {
-                        @Override
-                        public void run() {
-
-                            processResults(dataPackage, ServiceType.COPY);
-                        }
-                    });
+                    getActivity().runOnUiThread(() -> processResults(dataPackage, ServiceType.COPY));
                 }
 
                 @Override
@@ -190,18 +181,12 @@ public class ProcessViewer extends Fragment {
 
             extractService.setProgressListener(new ExtractService.ProgressListener() {
                 @Override
-                public void onUpdate(final DataPackage dataPackage) {
+                public void onUpdate(final CopyDataParcelable dataPackage) {
                     if (getActivity()==null) {
                         // callback called when we're not inside the app
                         return;
                     }
-                    getActivity().runOnUiThread(new Runnable() {
-                        @Override
-                        public void run() {
-
-                            processResults(dataPackage, ServiceType.EXTRACT);
-                        }
-                    });
+                    getActivity().runOnUiThread(() -> processResults(dataPackage, ServiceType.EXTRACT));
                 }
 
                 @Override
@@ -220,30 +205,25 @@ public class ProcessViewer extends Fragment {
         @Override
         public void onServiceConnected(ComponentName className, IBinder service) {
             // We've bound to LocalService, cast the IBinder and get LocalService instance
-            ZipTask.LocalBinder localBinder = (ZipTask.LocalBinder) service;
-            ZipTask zipTask = localBinder.getService();
+            ZipService.LocalBinder localBinder = (ZipService.LocalBinder) service;
+            ZipService zipService = localBinder.getService();
 
-            for (int i=0; i<zipTask.getDataPackageSize(); i++) {
+            for (int i = 0; i< zipService.getDataPackageSize(); i++) {
 
-                processResults(zipTask.getDataPackage(i), ServiceType.COMPRESS);
+                processResults(zipService.getDataPackage(i), ServiceType.COMPRESS);
             }
 
             // animate the chart a little after initial values have been applied
             mLineChart.animateXY(500, 500);
 
-            zipTask.setProgressListener(new ZipTask.ProgressListener() {
+            zipService.setProgressListener(new ZipService.ProgressListener() {
                 @Override
-                public void onUpdate(final DataPackage dataPackage) {
+                public void onUpdate(final CopyDataParcelable dataPackage) {
                     if (getActivity() == null) {
                         // callback called when we're not inside the app
                         return;
                     }
-                    getActivity().runOnUiThread(new Runnable() {
-                        @Override
-                        public void run() {
-                            processResults(dataPackage, ServiceType.COMPRESS);
-                        }
-                    });
+                    getActivity().runOnUiThread(() -> processResults(dataPackage, ServiceType.COMPRESS));
                 }
 
                 @Override
@@ -266,7 +246,7 @@ public class ProcessViewer extends Fragment {
             EncryptService encryptService = binder.getService();
 
             for (int i=0; i<encryptService.getDataPackageSize(); i++) {
-                DataPackage dataPackage = encryptService.getDataPackage(i);
+                CopyDataParcelable dataPackage = encryptService.getDataPackage(i);
                 processResults(dataPackage, dataPackage.isMove() ? ServiceType.DECRYPT
                         : ServiceType.ENCRYPT);
             }
@@ -276,7 +256,7 @@ public class ProcessViewer extends Fragment {
 
             encryptService.setProgressListener(new EncryptService.ProgressListener() {
                 @Override
-                public void onUpdate(final DataPackage dataPackage) {
+                public void onUpdate(final CopyDataParcelable dataPackage) {
                     if (getActivity() == null) {
                         // callback called when we're not inside the app
                         return;
@@ -314,7 +294,7 @@ public class ProcessViewer extends Fragment {
         Intent intent1 = new Intent(getActivity(), ExtractService.class);
         getActivity().bindService(intent1, mExtractConnection, 0);
 
-        Intent intent2 = new Intent(getActivity(), ZipTask.class);
+        Intent intent2 = new Intent(getActivity(), ZipService.class);
         getActivity().bindService(intent2, mCompressConnection, 0);
 
         Intent intent3 = new Intent(getActivity(), EncryptService.class);
@@ -336,7 +316,7 @@ public class ProcessViewer extends Fragment {
     }
 
     /**
-     * Enum helps defining the result type for {@link #processResults(DataPackage, ServiceType)}
+     * Enum helps defining the result type for {@link #processResults(CopyDataParcelable, ServiceType)}
      * to process
      */
     enum ServiceType {
@@ -344,7 +324,7 @@ public class ProcessViewer extends Fragment {
         COPY, EXTRACT, COMPRESS, ENCRYPT, DECRYPT
     }
 
-    public void processResults(final DataPackage dataPackage, ServiceType serviceType) {
+    public void processResults(final CopyDataParcelable dataPackage, ServiceType serviceType) {
         if (dataPackage != null) {
             String name = dataPackage.getName();
             long total = dataPackage.getTotal();
@@ -361,8 +341,8 @@ public class ProcessViewer extends Fragment {
                 isInitialized = true;
             }
 
-            addEntry(Futils.readableFileSizeFloat(doneBytes),
-                    Futils.readableFileSizeFloat(dataPackage.getSpeedRaw()));
+            addEntry(FileUtils.readableFileSizeFloat(doneBytes),
+                    FileUtils.readableFileSizeFloat(dataPackage.getSpeedRaw()));
 
             mProgressFileNameText.setText(name);
 
@@ -445,7 +425,7 @@ public class ProcessViewer extends Fragment {
                             .getDrawable(R.drawable.ic_zip_box_grey600_36dp));
                 }
                 mProgressTypeText.setText(getResources().getString(R.string.compressing));
-                cancelBroadcast(new Intent(ZipTask.KEY_COMPRESS_BROADCAST_CANCEL));
+                cancelBroadcast(new Intent(ZipService.KEY_COMPRESS_BROADCAST_CANCEL));
                 break;
             case ENCRYPT:
                 if (mainActivity.getAppTheme().equals(AppTheme.DARK)) {
@@ -480,20 +460,17 @@ public class ProcessViewer extends Fragment {
      */
     private void cancelBroadcast(final Intent intent) {
 
-        mCancelButton.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                Toast.makeText(getActivity(),
-                        getResources().getString(R.string.stopping), Toast.LENGTH_LONG).show();
-                getActivity().sendBroadcast(intent);
-                mProgressTypeText.setText(getResources().getString(R.string.cancelled));
-                mProgressSpeedText.setText("");
-                mProgressFileText.setText("");
-                mProgressBytesText.setText("");
-                mProgressFileNameText.setText("");
-
-                mProgressTypeText.setTextColor(Utils.getColor(getContext(), android.R.color.holo_red_light));
-            }
+        mCancelButton.setOnClickListener(v -> {
+            Toast.makeText(getActivity(),
+                    getResources().getString(R.string.stopping), Toast.LENGTH_LONG).show();
+            getActivity().sendBroadcast(intent);
+            mProgressTypeText.setText(getResources().getString(R.string.cancelled));
+            mProgressSpeedText.setText("");
+            mProgressFileText.setText("");
+            mProgressBytesText.setText("");
+            mProgressFileNameText.setText("");
+
+            mProgressTypeText.setTextColor(Utils.getColor(getContext(), android.R.color.holo_red_light));
         });
     }
 
@@ -558,7 +535,7 @@ public class ProcessViewer extends Fragment {
         yAxisLeft.setTypeface(Typeface.DEFAULT_BOLD);
         yAxisLeft.setGridColor(Utils.getColor(getContext(), R.color.white_translucent));
 
-        xAxis.setAxisMaximum(Futils.readableFileSizeFloat(totalBytes));
+        xAxis.setAxisMaximum(FileUtils.readableFileSizeFloat(totalBytes));
         xAxis.setAxisMinimum(0.0f);
         xAxis.setAxisLineColor(Color.TRANSPARENT);
         xAxis.setGridColor(Color.TRANSPARENT);
diff --git a/app/src/main/java/com/amaze/filemanager/fragments/PropertiesSheet.java b/app/src/main/java/com/amaze/filemanager/fragments/PropertiesSheet.java
index d2a399676..f80c43593 100644
--- a/app/src/main/java/com/amaze/filemanager/fragments/PropertiesSheet.java
+++ b/app/src/main/java/com/amaze/filemanager/fragments/PropertiesSheet.java
@@ -15,8 +15,8 @@ import android.view.View;
 import android.widget.TextView;
 
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.filesystem.BaseFile;
-import com.amaze.filemanager.utils.files.Futils;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
+import com.amaze.filemanager.utils.files.FileUtils;
 import com.amaze.filemanager.utils.Utils;
 
 import java.io.File;
@@ -28,7 +28,7 @@ import java.io.File;
 public class PropertiesSheet extends BottomSheetDialogFragment {
 
     private Bundle mBundle;
-    private BaseFile mFile;
+    private HybridFileParcelable mFile;
     private String mPermission;
     private boolean mIsRoot;
     private CollapsingToolbarLayout mToolbar;
@@ -68,7 +68,7 @@ public class PropertiesSheet extends BottomSheetDialogFragment {
         mFileTypeTextView = (TextView) rootView.findViewById(R.id.text_view_file_type);
         mFileTypeTextView.setText(mFile.isDirectory() ? getString(R.string.folder) : mFile.getName().substring(mFile.getName().lastIndexOf(".")));
         mFileSizeTextView = (TextView) rootView.findViewById(R.id.text_view_file_size);
-        mFileSizeTextView.setText(Formatter.formatFileSize(dialog.getContext(), mFile.isDirectory() ? Futils.folderSize(new File(mFile.getPath()), null) : mFile.getSize()));
+        mFileSizeTextView.setText(Formatter.formatFileSize(dialog.getContext(), mFile.isDirectory() ? FileUtils.folderSize(new File(mFile.getPath()), null) : mFile.getSize()));
         mFileLocationTextView = (TextView) rootView.findViewById(R.id.text_view_file_location);
         mFileLocationTextView.setText(mFile.getPath());
         mFileAccessedTextView = (TextView) rootView.findViewById(R.id.text_view_file_accessed);
diff --git a/app/src/main/java/com/amaze/filemanager/fragments/SearchWorkerFragment.java b/app/src/main/java/com/amaze/filemanager/fragments/SearchWorkerFragment.java
index a2a6e720e..11a6c52a5 100644
--- a/app/src/main/java/com/amaze/filemanager/fragments/SearchWorkerFragment.java
+++ b/app/src/main/java/com/amaze/filemanager/fragments/SearchWorkerFragment.java
@@ -1,18 +1,13 @@
 package com.amaze.filemanager.fragments;
 
 import android.content.Context;
-import android.os.AsyncTask;
 import android.os.Bundle;
 import android.support.v4.app.Fragment;
-import android.util.Log;
 
-import com.amaze.filemanager.filesystem.BaseFile;
-import com.amaze.filemanager.filesystem.HFile;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
+import com.amaze.filemanager.asynchronous.asynctasks.SearchAsyncTask;
 import com.amaze.filemanager.utils.OpenMode;
 
-import java.util.ArrayList;
-import java.util.regex.Pattern;
-
 /**
  * Worker fragment designed to not be destroyed when the activity holding it is recreated
  * (aka the state changes like screen rotation) thus maintaining alive an AsyncTask (SearchTask in this case)
@@ -33,15 +28,12 @@ public class SearchWorkerFragment extends Fragment {
     private static final String TAG = "SearchWorkerFragment";
 
     private HelperCallbacks mCallbacks;
-    private String mPath, mInput;
-    private OpenMode mOpenMode;
-    private boolean mRootMode, isRegexEnabled, isMatchesEnabled;
 
     // interface for activity to communicate with asynctask
     public interface HelperCallbacks {
         void onPreExecute(String query);
         void onPostExecute(String query);
-        void onProgressUpdate(BaseFile val,String query);
+        void onProgressUpdate(HybridFileParcelable val, String query);
         void onCancelled();
     }
 
@@ -58,13 +50,15 @@ public class SearchWorkerFragment extends Fragment {
         super.onCreate(savedInstanceState);
 
         setRetainInstance(true);
-        mPath = getArguments().getString(KEY_PATH);
-        mInput = getArguments().getString(KEY_INPUT);
-        mOpenMode = OpenMode.getOpenMode(getArguments().getInt(KEY_OPEN_MODE));
-        mRootMode = getArguments().getBoolean(KEY_ROOT_MODE);
-        isRegexEnabled = getArguments().getBoolean(KEY_REGEX);
-        isMatchesEnabled = getArguments().getBoolean(KEY_REGEX_MATCHES);
-        mSearchAsyncTask = new SearchAsyncTask();
+        String mPath = getArguments().getString(KEY_PATH);
+        String mInput = getArguments().getString(KEY_INPUT);
+        OpenMode mOpenMode = OpenMode.getOpenMode(getArguments().getInt(KEY_OPEN_MODE));
+        boolean mRootMode = getArguments().getBoolean(KEY_ROOT_MODE);
+        boolean isRegexEnabled = getArguments().getBoolean(KEY_REGEX);
+        boolean isMatchesEnabled = getArguments().getBoolean(KEY_REGEX_MATCHES);
+
+        mSearchAsyncTask = new SearchAsyncTask(getActivity(), mCallbacks, mInput, mOpenMode,
+                mRootMode, isRegexEnabled, isMatchesEnabled);
         mSearchAsyncTask.execute(mPath);
     }
 
@@ -76,155 +70,4 @@ public class SearchWorkerFragment extends Fragment {
         mCallbacks = null;
     }
 
-    public class SearchAsyncTask extends AsyncTask<String, BaseFile, Void> {
-        @Override
-        protected void onPreExecute() {
-            /*
-            * Note that we need to check if the callbacks are null in each
-            * method in case they are invoked after the Activity's and
-            * Fragment's onDestroy() method have been called.
-             */
-            if (mCallbacks!=null) {
-                mCallbacks.onPreExecute(mInput);
-            }
-        }
-
-        // mCallbacks not checked for null because of possibility of
-        // race conditions b/w worker thread main thread
-        @Override
-        protected Void doInBackground(String... params) {
-
-            String path = params[0];
-            HFile file=new HFile(mOpenMode, path);
-            file.generateMode(getActivity());
-            if(file.isSmb())return null;
-
-            // level 1
-            // if regex or not
-            if (!isRegexEnabled) {
-                search(file, mInput);
-            } else {
-                // compile the regular expression in the input
-                Pattern pattern = Pattern.compile(bashRegexToJava(mInput));
-                // level 2
-                if (!isMatchesEnabled) searchRegExFind(file, pattern);
-                else searchRegExMatch(file, pattern);
-            }
-            return null;
-        }
-
-        @Override
-        public void onPostExecute(Void c){
-            if (mCallbacks!=null) {
-                mCallbacks.onPostExecute(mInput);
-            }
-        }
-
-        @Override
-        protected void onCancelled() {
-            if (mCallbacks!=null) mCallbacks.onCancelled();
-        }
-
-        @Override
-        public void onProgressUpdate(BaseFile... val) {
-            if (!isCancelled() && mCallbacks!=null) {
-                mCallbacks.onProgressUpdate(val[0],mInput);
-            }
-        }
-
-        /**
-         * Recursively search for occurrences of a given text in file names and publish the result
-         * @param directory the current path
-         */
-        private void search(HFile directory, SearchFilter filter) {
-            if (directory.isDirectory(getContext())) {// do you have permission to read this directory?
-                ArrayList<BaseFile> filesInDirectory = directory.listFiles(getContext(), mRootMode);
-                for (BaseFile file : filesInDirectory) {
-                    if (!isCancelled()) {
-                        if (filter.searchFilter(file.getName())) {
-                            publishProgress(file);
-                        }
-                        if (file.isDirectory() && !isCancelled()) {
-                            search(file, filter);
-                        }
-                    } else return;
-                }
-            } else {
-                Log.d(TAG, "Cannot search " + directory.getPath() + ": Permission Denied");
-            }
-        }
-
-
-        /**
-         * Recursively search for occurrences of a given text in file names and publish the result
-         * @param file the current path
-         * @param query the searched text
-         */
-        private void search(HFile file, final String query) {
-            search(file, new SearchFilter() {
-                @Override
-                public boolean searchFilter(String fileName) {
-                    return fileName.toLowerCase().contains(query.toLowerCase());
-                }
-            });
-        }
-
-        /**
-         * Recursively find a java regex pattern {@link Pattern} in the file names and publish the result
-         * @param file the current file
-         * @param pattern the compiled java regex
-         */
-        private void searchRegExFind(HFile file, final Pattern pattern) {
-            search(file, new SearchFilter() {
-                @Override
-                public boolean searchFilter(String fileName) {
-                    return pattern.matcher(fileName).find();
-                }
-            });
-        }
-
-        /**
-         * Recursively match a java regex pattern {@link Pattern} with the file names and publish the result
-         * @param file the current file
-         * @param pattern the compiled java regex
-         */
-        private void searchRegExMatch(HFile file, final Pattern pattern) {
-            search(file, new SearchFilter() {
-                @Override
-                public boolean searchFilter(String fileName) {
-                    return pattern.matcher(fileName).matches();
-                }
-            });
-        }
-
-        /**
-         * method converts bash style regular expression to java. See {@link Pattern}
-         * @param originalString
-         * @return converted string
-         */
-        private String bashRegexToJava(String originalString) {
-            StringBuilder stringBuilder = new StringBuilder();
-
-            for(int i=0; i<originalString.length(); i++) {
-                switch (originalString.charAt(i) + "") {
-                    case "*":
-                        stringBuilder.append("\\w*");
-                        break;
-                    case "?":
-                        stringBuilder.append("\\w");
-                        break;
-                    default:
-                        stringBuilder.append(originalString.charAt(i));
-                        break;
-                }
-            }
-
-            Log.d(getClass().getSimpleName(), stringBuilder.toString());
-            return stringBuilder.toString();
-        }
-    }
-
-    public interface SearchFilter {
-        boolean searchFilter(String fileName);
-    }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/fragments/TabFragment.java b/app/src/main/java/com/amaze/filemanager/fragments/TabFragment.java
index 3a432bc8d..53b94808d 100644
--- a/app/src/main/java/com/amaze/filemanager/fragments/TabFragment.java
+++ b/app/src/main/java/com/amaze/filemanager/fragments/TabFragment.java
@@ -20,16 +20,14 @@ import android.view.animation.DecelerateInterpolator;
 import android.widget.ImageView;
 
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.activities.BaseActivity;
 import com.amaze.filemanager.activities.MainActivity;
-import com.amaze.filemanager.database.models.Tab;
 import com.amaze.filemanager.database.TabHandler;
+import com.amaze.filemanager.database.models.Tab;
 import com.amaze.filemanager.ui.ColorCircleDrawable;
 import com.amaze.filemanager.ui.drawer.EntryItem;
 import com.amaze.filemanager.ui.views.DisablableViewPager;
 import com.amaze.filemanager.ui.views.Indicator;
 import com.amaze.filemanager.utils.DataUtils;
-import com.amaze.filemanager.utils.Logger;
 import com.amaze.filemanager.utils.MainActivityHelper;
 import com.amaze.filemanager.utils.OpenMode;
 import com.amaze.filemanager.utils.PreferenceUtils;
@@ -54,8 +52,6 @@ public class TabFragment extends android.support.v4.app.Fragment
     // current visible tab, either 0 or 1
     //public int currenttab;
     MainActivity mainActivity;
-    View buttons;
-    View mToolBarContainer;
     boolean savepaths;
     FragmentManager fragmentManager;
 
@@ -81,7 +77,6 @@ public class TabFragment extends android.support.v4.app.Fragment
 
         tabHandler = new TabHandler(getContext());
         fragmentManager = getActivity().getSupportFragmentManager();
-        mToolBarContainer = getActivity().findViewById(R.id.lin);
 
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
             indicator = (Indicator) getActivity().findViewById(R.id.indicator);
@@ -99,7 +94,6 @@ public class TabFragment extends android.support.v4.app.Fragment
         if (getArguments() != null) {
             path = getArguments().getString("path");
         }
-        buttons = getActivity().findViewById(R.id.buttons);
         mainActivity = ((MainActivity) getActivity());
         mainActivity.supportInvalidateOptionsMenu();
         mViewPager.addOnPageChangeListener(this);
@@ -176,10 +170,10 @@ public class TabFragment extends android.support.v4.app.Fragment
         // update the views as there is any change in {@link MainActivity#currentTab}
         // probably due to config change
         /*colorDrawable.setColor(Color.parseColor(MainActivity.currentTab==1 ?
-                BaseActivity.skinTwo : BaseActivity.skin));
+                ThemedActivity.skinTwo : ThemedActivity.skin));
         mainActivity.updateViews(colorDrawable);*/
 
-        mainActivity.mainFragment = (MainFragment) getTab();
+        mainActivity.mainFragment = (MainFragment) getCurrentTabFragment();
 
         return rootView;
     }
@@ -206,12 +200,12 @@ public class TabFragment extends android.support.v4.app.Fragment
 
         tabHandler.clear();
         for (Fragment fragment : fragments) {
-            if (fragment.getClass().getName().contains("MainFragment")) {
+            if (fragment instanceof MainFragment) {
                 MainFragment m = (MainFragment) fragment;
                 items.add(parsePathForName(m.getCurrentPath(), m.openMode));
                 if (i - 1 == MainActivity.currentTab && i == pos) {
-                    mainActivity.updatePath(m.getCurrentPath(), m.results, m.openMode, m
-                            .folder_count, m.file_count);
+                    mainActivity.getAppbar().getBottomBar().updatePath(m.getCurrentPath(), m.results,
+                            MainActivityHelper.SEARCH_TEXT, m.openMode, m.folder_count, m.file_count, m);
                     mainActivity.updateDrawer(m.getCurrentPath());
                 }
                 if (m.openMode == OpenMode.FILE) {
@@ -247,21 +241,16 @@ public class TabFragment extends android.support.v4.app.Fragment
     @Override
     public void onSaveInstanceState(Bundle outState) {
         super.onSaveInstanceState(outState);
-        try {
-            int i = 0;
-            if (sharedPrefs != null)
-                sharedPrefs.edit().putInt(PreferenceUtils.KEY_CURRENT_TAB, MainActivity.currentTab).commit();
-            if (fragments != null && fragments.size() != 0) {
-                if (fragmentManager == null) return;
-                for (Fragment fragment : fragments) {
-                    fragmentManager.putFragment(outState, "tab" + i, fragment);
-                    i++;
-                }
-                outState.putInt("pos", mViewPager.getCurrentItem());
+        int i = 0;
+        if (sharedPrefs != null)
+            sharedPrefs.edit().putInt(PreferenceUtils.KEY_CURRENT_TAB, MainActivity.currentTab).commit();
+        if (fragments != null && fragments.size() != 0) {
+            if (fragmentManager == null) return;
+            for (Fragment fragment : fragments) {
+                fragmentManager.putFragment(outState, "tab" + i, fragment);
+                i++;
             }
-        } catch (Exception e) {
-            Logger.log(e, "puttingtosavedinstance", getActivity());
-            e.printStackTrace();
+            outState.putInt("pos", mViewPager.getCurrentItem());
         }
     }
 
@@ -283,7 +272,7 @@ public class TabFragment extends android.support.v4.app.Fragment
 
     @Override
     public void onPageSelected(int p1) {
-        mToolBarContainer.animate().translationY(0).setInterpolator(new DecelerateInterpolator(2)).start();
+        mainActivity.getAppbar().getAppbarLayout().animate().translationY(0).setInterpolator(new DecelerateInterpolator(2)).start();
 
         MainActivity.currentTab = p1;
         if (sharedPrefs != null)
@@ -291,22 +280,13 @@ public class TabFragment extends android.support.v4.app.Fragment
         Log.d(getClass().getSimpleName(), "Page Selected: " + MainActivity.currentTab);
 
         Fragment fragment = fragments.get(p1);
-        if (fragment != null) {
-            String name = fragments.get(p1).getClass().getName();
-            if (name != null && name.contains("Main")) {
-                MainFragment ma = ((MainFragment) fragments.get(p1));
-                if (ma.getCurrentPath() != null) {
-                    try {
-                        mainActivity.updateDrawer(ma.getCurrentPath());
-                        mainActivity.updatePath(ma.getCurrentPath(), ma.results, ma.openMode,
-                                ma.folder_count, ma.file_count);
-                        if (buttons.getVisibility() == View.VISIBLE) {
-                            mainActivity.bbar(ma);
-                        }
-                    } catch (Exception e) {
-                        //       e.printStackTrace();5
-                    }
-                }
+        if (fragment != null && fragment instanceof MainFragment) {
+            MainFragment ma = (MainFragment) fragment;
+            if (ma.getCurrentPath() != null) {
+                mainActivity.updateDrawer(ma.getCurrentPath());
+                mainActivity.getAppbar().getBottomBar().updatePath(ma.getCurrentPath(),
+                        ma.results, MainActivityHelper.SEARCH_TEXT, ma.openMode,
+                        ma.folder_count, ma.file_count, ma);
             }
         }
 
@@ -362,26 +342,27 @@ public class TabFragment extends android.support.v4.app.Fragment
         mViewPager.setOffscreenPageLimit(4);
     }
 
-    public Fragment getTab() {
-        if (fragments.size() == 2)
-            return fragments.get(mViewPager.getCurrentItem());
+    public Fragment getCurrentTabFragment() {
+        if (fragments.size() == 2) return fragments.get(mViewPager.getCurrentItem());
         else return null;
     }
 
-    public Fragment getTab(int pos) {
-        if (fragments.size() == 2 && pos < 2)
-            return fragments.get(pos);
+    public Fragment getFragmentAtIndex(int pos) {
+        if (fragments.size() == 2 && pos < 2) return fragments.get(pos);
         else return null;
     }
 
     // updating indicator color as per the current viewpager tab
     void updateIndicator(int index) {
         if (index != 0 && index != 1) return;
+
+        int accentColor = mainActivity.getColorPreference().getColor(ColorUsage.ACCENT);
+
         if (index == 0) {
-            circleDrawable1.setImageDrawable(new ColorCircleDrawable(Color.parseColor(BaseActivity.accentSkin)));
+            circleDrawable1.setImageDrawable(new ColorCircleDrawable(accentColor));
             circleDrawable2.setImageDrawable(new ColorCircleDrawable(Color.GRAY));
         } else {
-            circleDrawable1.setImageDrawable(new ColorCircleDrawable(Color.parseColor(BaseActivity.accentSkin)));
+            circleDrawable1.setImageDrawable(new ColorCircleDrawable(accentColor));
             circleDrawable2.setImageDrawable(new ColorCircleDrawable(Color.GRAY));
         }
     }
diff --git a/app/src/main/java/com/amaze/filemanager/fragments/ZipViewer.java b/app/src/main/java/com/amaze/filemanager/fragments/ZipViewer.java
deleted file mode 100644
index ff6cc6c40..000000000
--- a/app/src/main/java/com/amaze/filemanager/fragments/ZipViewer.java
+++ /dev/null
@@ -1,622 +0,0 @@
-/*
- * Copyright (C) 2014 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>
- *
- * This file is part of Amaze File Manager.
- *
- * Amaze File Manager is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.amaze.filemanager.fragments;
-
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.Intent;
-import android.content.ServiceConnection;
-import android.content.SharedPreferences;
-import android.content.res.Resources;
-import android.content.res.TypedArray;
-import android.database.Cursor;
-import android.graphics.drawable.ColorDrawable;
-import android.net.Uri;
-import android.os.Build;
-import android.os.Bundle;
-import android.os.IBinder;
-import android.preference.PreferenceManager;
-import android.provider.MediaStore;
-import android.support.annotation.Nullable;
-import android.support.design.widget.AppBarLayout;
-import android.support.v4.app.Fragment;
-import android.support.v4.widget.SwipeRefreshLayout;
-import android.support.v7.widget.LinearLayoutManager;
-import android.support.v7.widget.RecyclerView;
-import android.util.DisplayMetrics;
-import android.view.ActionMode;
-import android.view.LayoutInflater;
-import android.view.Menu;
-import android.view.MenuInflater;
-import android.view.MenuItem;
-import android.view.MotionEvent;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.ViewTreeObserver;
-import android.view.Window;
-import android.widget.TextView;
-import android.widget.Toast;
-
-import com.amaze.filemanager.R;
-import com.amaze.filemanager.activities.MainActivity;
-import com.amaze.filemanager.adapters.RarAdapter;
-import com.amaze.filemanager.filesystem.BaseFile;
-import com.amaze.filemanager.services.DeleteTask;
-import com.amaze.filemanager.services.ExtractService;
-import com.amaze.filemanager.services.asynctasks.RarHelperTask;
-import com.amaze.filemanager.services.asynctasks.ZipHelperTask;
-import com.amaze.filemanager.ui.ZipObj;
-import com.amaze.filemanager.ui.views.DividerItemDecoration;
-import com.amaze.filemanager.ui.views.FastScroller;
-import com.amaze.filemanager.utils.OpenMode;
-import com.amaze.filemanager.utils.ServiceWatcherUtil;
-import com.amaze.filemanager.utils.Utils;
-import com.amaze.filemanager.utils.color.ColorUsage;
-import com.amaze.filemanager.utils.provider.UtilitiesProviderInterface;
-import com.amaze.filemanager.utils.theme.AppTheme;
-import com.github.junrar.Archive;
-import com.github.junrar.rarfile.FileHeader;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Calendar;
-
-public class ZipViewer extends Fragment {
-
-    private UtilitiesProviderInterface utilsProvider;
-    public String s;
-    public File f;
-
-    /**
-     * files to be deleted from cache
-     * with a Map maintaining key - the root of directory created (for deletion purposes after we exit out of here
-     * and value - the path of file to open
-     */
-    public ArrayList<BaseFile> files;
-    public Boolean selection = false;
-    public String current;
-    public String skin, accentColor, iconskin, year;
-    public RarAdapter rarAdapter;
-    public ActionMode mActionMode;
-    public boolean coloriseIcons, showSize, showLastModified, gobackitem;
-    SharedPreferences Sp;
-    ZipViewer zipViewer = this;
-    public Archive archive;
-    public ArrayList<FileHeader> wholelistRar = new ArrayList<>();
-    public ArrayList<FileHeader> elementsRar = new ArrayList<>();
-    public ArrayList<ZipObj> wholelist = new ArrayList<>();
-    public ArrayList<ZipObj> elements = new ArrayList<>();
-    public MainActivity mainActivity;
-    public RecyclerView listView;
-    View rootView;
-    boolean addheader = true;
-    public SwipeRefreshLayout swipeRefreshLayout;
-    LinearLayoutManager mLayoutManager;
-    DividerItemDecoration dividerItemDecoration;
-    boolean showDividers;
-    public int paddingTop;
-    int mToolbarHeight, hidemode;
-    View mToolbarContainer;
-    public Resources res;
-    int openmode;   //0 for zip 1 for rar
-    boolean stopAnims = true;
-
-    public boolean isOpen = false;  // flag states whether to open file after service extracts it
-
-    public static final String KEY_CACHE_FILES = "cache_files";
-    public static final String KEY_PATH = "path";
-    public static final String KEY_URI = "uri";
-    public static final String KEY_OPEN_MODE = "open_mode";
-    public static final String KEY_FILE = "file";
-    public static final String KEY_WHOLE_LIST = "whole_list";
-    public static final String KEY_ELEMENTS = "elements";
-    public static final String KEY_OPEN = "is_open";
-
-    @Override
-    public void onCreate(@Nullable Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        utilsProvider = (UtilitiesProviderInterface) getActivity();
-    }
-
-    @Override
-    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-        rootView = inflater.inflate(R.layout.main_frag, container, false);
-        mainActivity = (MainActivity) getActivity();
-        listView = (RecyclerView) rootView.findViewById(R.id.listView);
-        listView.setOnTouchListener(new View.OnTouchListener() {
-            @Override
-            public boolean onTouch(View view, MotionEvent motionEvent) {
-                if (stopAnims && !rarAdapter.stoppedAnimation) {
-                    stopAnim();
-                }
-                rarAdapter.stoppedAnimation = true;
-
-                stopAnims = false;
-                return false;
-            }
-        });
-        swipeRefreshLayout = (SwipeRefreshLayout) rootView.findViewById(R.id.activity_main_swipe_refresh_layout);
-        swipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {
-            @Override
-            public void onRefresh() {
-                refresh();
-            }
-        });
-
-        return rootView;
-    }
-
-    public void stopAnim() {
-        for (int j = 0; j < listView.getChildCount(); j++) {
-            View v = listView.getChildAt(j);
-            if (v != null) v.clearAnimation();
-        }
-    }
-
-    @Override
-    public void onActivityCreated(Bundle savedInstanceState) {
-        super.onActivityCreated(savedInstanceState);
-        Sp = PreferenceManager.getDefaultSharedPreferences(getActivity());
-        s = getArguments().getString(KEY_PATH);
-        Uri uri = Uri.parse(s);
-        f = new File(uri.getPath());
-        mToolbarContainer = getActivity().findViewById(R.id.lin);
-        mToolbarContainer.setOnTouchListener(new View.OnTouchListener() {
-            @Override
-            public boolean onTouch(View view, MotionEvent motionEvent) {
-                if (stopAnims) {
-                    if ((!rarAdapter.stoppedAnimation)) {
-                        stopAnim();
-                    }
-                    rarAdapter.stoppedAnimation = true;
-
-                }
-                stopAnims = false;
-                return false;
-            }
-        });
-        hidemode = Sp.getInt("hidemode", 0);
-        listView.setVisibility(View.VISIBLE);
-        mLayoutManager = new LinearLayoutManager(getActivity());
-        listView.setLayoutManager(mLayoutManager);
-        res = getResources();
-        mainActivity.supportInvalidateOptionsMenu();
-        if (utilsProvider.getAppTheme().equals(AppTheme.DARK))
-            rootView.setBackgroundColor(Utils.getColor(getContext(), R.color.holo_dark_background));
-        else
-            listView.setBackgroundColor(Utils.getColor(getContext(), android.R.color.background_light));
-
-        gobackitem = Sp.getBoolean("goBack_checkbox", false);
-        coloriseIcons = Sp.getBoolean("coloriseIcons", true);
-        Calendar calendar = Calendar.getInstance();
-        showSize = Sp.getBoolean("showFileSize", false);
-        showLastModified = Sp.getBoolean("showLastModified", true);
-        showDividers = Sp.getBoolean("showDividers", true);
-        year = ("" + calendar.get(Calendar.YEAR)).substring(2, 4);
-        skin = mainActivity.getColorPreference().getColorAsString(ColorUsage.PRIMARY);
-        accentColor = mainActivity.getColorPreference().getColorAsString(ColorUsage.ACCENT);
-        iconskin = mainActivity.getColorPreference().getColorAsString(ColorUsage.ICON_SKIN);
-
-        //mainActivity.findViewById(R.id.buttonbarframe).setBackgroundColor(Color.parseColor(skin));
-
-        if (savedInstanceState == null && f != null) {
-
-            files = new ArrayList<>();
-            // adding a cache file to delete where any user interaction elements will be cached
-            String fileName = f.getName().substring(0, f.getName().lastIndexOf("."));
-            files.add(new BaseFile(getActivity().getExternalCacheDir().getPath() + "/" + fileName));
-            if (f.getPath().endsWith(".rar")) {
-                openmode = 1;
-                SetupRar(null);
-            } else {
-                openmode = 0;
-                SetupZip(null);
-            }
-        } else {
-
-            f = new File(savedInstanceState.getString(KEY_FILE));
-            s = savedInstanceState.getString(KEY_URI);
-            uri = Uri.parse(s);
-            f = new File(uri.getPath());
-            files = savedInstanceState.getParcelableArrayList(KEY_CACHE_FILES);
-            isOpen = savedInstanceState.getBoolean(KEY_OPEN);
-            if (f.getPath().endsWith(".rar")) {
-                openmode = 1;
-                SetupRar(savedInstanceState);
-            } else {
-                openmode = 0;
-                SetupZip(savedInstanceState);
-            }
-
-        }
-        String fileName = null;
-        try {
-            if (uri.getScheme().equals(KEY_FILE)) {
-                fileName = uri.getLastPathSegment();
-            } else {
-                Cursor cursor = null;
-                try {
-                    cursor = getActivity().getContentResolver().query(uri, new String[]{
-                            MediaStore.Images.ImageColumns.DISPLAY_NAME
-                    }, null, null, null);
-
-                    if (cursor != null && cursor.moveToFirst()) {
-                        fileName = cursor.getString(cursor.getColumnIndex(MediaStore.Images.ImageColumns.DISPLAY_NAME));
-                    }
-                } finally {
-
-                    if (cursor != null) {
-                        cursor.close();
-                    }
-                }
-            }
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-        if (fileName == null || fileName.trim().length() == 0) fileName = f.getName();
-        try {
-            mainActivity.setActionBarTitle(fileName);
-        } catch (Exception e) {
-            mainActivity.setActionBarTitle(getResources().getString(R.string.zip_viewer));
-        }
-        mainActivity.supportInvalidateOptionsMenu();
-        mToolbarHeight = getToolbarHeight(getActivity());
-        paddingTop = (mToolbarHeight) + dpToPx(72);
-        mToolbarContainer.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
-            @Override
-            public void onGlobalLayout() {
-                paddingTop = mToolbarContainer.getHeight();
-                mToolbarHeight = mainActivity.toolbar.getHeight();
-
-                if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN) {
-                    mToolbarContainer.getViewTreeObserver().removeOnGlobalLayoutListener(this);
-                } else {
-                    mToolbarContainer.getViewTreeObserver().removeGlobalOnLayoutListener(this);
-                }
-            }
-
-        });
-
-    }
-
-    public int dpToPx(int dp) {
-        DisplayMetrics displayMetrics = getResources().getDisplayMetrics();
-        int px = Math.round(dp * (displayMetrics.xdpi / DisplayMetrics.DENSITY_DEFAULT));
-        return px;
-    }
-
-    public static int getToolbarHeight(Context context) {
-        final TypedArray styledAttributes = context.getTheme().obtainStyledAttributes(
-                new int[]{android.R.attr.actionBarSize});
-        int toolbarHeight = (int) styledAttributes.getDimension(0, 0);
-        styledAttributes.recycle();
-
-        return toolbarHeight;
-    }
-
-    @Override
-    public void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-        putDatatoSavedInstance(outState);
-    }
-
-    public ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
-        private void hideOption(int id, Menu menu) {
-            MenuItem item = menu.findItem(id);
-            item.setVisible(false);
-        }
-
-        private void showOption(int id, Menu menu) {
-            MenuItem item = menu.findItem(id);
-            item.setVisible(true);
-        }
-
-        View v;
-
-        // called when the action mode is created; startActionMode() was called
-        public boolean onCreateActionMode(ActionMode mode, Menu menu) {
-            // Inflate a menu resource providing context menu items
-            MenuInflater inflater = mode.getMenuInflater();
-            v = getActivity().getLayoutInflater().inflate(R.layout.actionmode, null);
-            mode.setCustomView(v);
-            // assumes that you have "contexual.xml" menu resources
-            inflater.inflate(R.menu.contextual, menu);
-            hideOption(R.id.cpy, menu);
-            hideOption(R.id.cut, menu);
-            hideOption(R.id.delete, menu);
-            hideOption(R.id.addshortcut, menu);
-            hideOption(R.id.share, menu);
-            hideOption(R.id.openwith, menu);
-            showOption(R.id.all, menu);
-            hideOption(R.id.compress, menu);
-            hideOption(R.id.hide, menu);
-            showOption(R.id.ex, menu);
-            mode.setTitle(getResources().getString(R.string.select));
-            mainActivity.updateViews(new ColorDrawable(Utils.getColor(getContext(), R.color.holo_dark_action_mode)));
-            if (Build.VERSION.SDK_INT >= 21) {
-
-                Window window = getActivity().getWindow();
-                if (mainActivity.colourednavigation)
-                    window.setNavigationBarColor(Utils.getColor(getContext(), android.R.color.black));
-            }
-            if (Build.VERSION.SDK_INT < 19)
-                getActivity().findViewById(R.id.action_bar).setVisibility(View.GONE);
-            return true;
-        }
-
-        // the following method is called each time
-        // the action mode is shown. Always called after
-        // onCreateActionMode, but
-        // may be called multiple times if the mode is invalidated.
-        public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
-            ArrayList<Integer> positions = rarAdapter.getCheckedItemPositions();
-            ((TextView) v.findViewById(R.id.item_count)).setText(positions.size() + "");
-
-            return false; // Return false if nothing is done
-        }
-
-        // called when the user selects a contextual menu item
-        public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
-            switch (item.getItemId()) {
-                case R.id.all:
-                    rarAdapter.toggleChecked(true, "");
-                    mode.invalidate();
-                    return true;
-                case R.id.ex:
-
-                    Toast.makeText(getActivity(), getResources().getString(R.string.extracting), Toast.LENGTH_SHORT).show();
-                    Intent intent = new Intent(getActivity(), ExtractService.class);
-                    ArrayList<String> a = new ArrayList<>();
-                    for (int i : rarAdapter.getCheckedItemPositions()) {
-                        a.add(openmode == 0 ? elements.get(i).getName() : elementsRar.get(i).getFileNameString());
-                    }
-                    intent.putExtra(ExtractService.KEY_PATH_ZIP, f.getPath());
-                    intent.putExtra(ExtractService.KEY_ENTRIES_ZIP, a);
-                    ServiceWatcherUtil.runService(getContext(), intent);
-                    mode.finish();
-                    return true;
-            }
-            return false;
-        }
-
-        @Override
-        public void onDestroyActionMode(ActionMode actionMode) {
-            if (rarAdapter != null) rarAdapter.toggleChecked(false, "");
-            selection = false;
-            mainActivity.updateViews(mainActivity.getColorPreference().getDrawable(ColorUsage.getPrimary(MainActivity.currentTab)));
-            if (Build.VERSION.SDK_INT >= 21) {
-
-                Window window = getActivity().getWindow();
-                if (mainActivity.colourednavigation)
-                    window.setNavigationBarColor(mainActivity.skinStatusBar);
-            }
-            mActionMode = null;
-        }
-    };
-
-    @Override
-    public void onDestroyView() {
-        super.onDestroyView();
-        mainActivity.supportInvalidateOptionsMenu();
-
-        // needed to remove any extracted file from cache, when onResume was not called
-        // in case of opening any unknown file inside the zip
-
-        if (files.get(0).exists()) {
-
-            new DeleteTask(getActivity().getContentResolver(), getActivity(), this).execute((files));
-        }
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-
-        mainActivity.floatingActionButton.hideMenuButton(true);
-        Intent intent = new Intent(getActivity(), ExtractService.class);
-        getActivity().bindService(intent, mServiceConnection, 0);
-    }
-
-    @Override
-    public void onPause() {
-        super.onPause();
-
-        getActivity().unbindService(mServiceConnection);
-    }
-
-    private ServiceConnection mServiceConnection = new ServiceConnection() {
-
-        @Override
-        public void onServiceConnected(ComponentName name, IBinder service) {
-        }
-
-        @Override
-        public void onServiceDisconnected(ComponentName name) {
-            // open file if pending
-            if (isOpen) {
-                // open most recent entry added to files to be deleted from cache
-                File cacheFile = new File(files.get(files.size() - 1).getPath());
-                if (cacheFile != null && cacheFile.exists())
-                    utilsProvider.getFutils().openFile(cacheFile, zipViewer.mainActivity);
-
-                // reset the flag and cache file, as it's root is already in the list for deletion
-                isOpen = false;
-                files.remove(files.size() - 1);
-            }
-        }
-    };
-
-    void putDatatoSavedInstance(Bundle outState) {
-        if (openmode == 0) {
-            outState.putParcelableArrayList(KEY_WHOLE_LIST, wholelist);
-            outState.putParcelableArrayList(KEY_ELEMENTS, elements);
-        }
-        outState.putInt(KEY_OPEN_MODE, openmode);
-        outState.putString(KEY_PATH, current);
-        outState.putString(KEY_URI, s);
-        outState.putString(KEY_FILE, f.getPath());
-        outState.putParcelableArrayList(KEY_CACHE_FILES, files);
-        outState.putBoolean(KEY_OPEN, isOpen);
-    }
-
-    void SetupRar(Bundle savedInstanceState) {
-
-        if (savedInstanceState == null)
-            loadRarlist(f.getPath());
-        else {
-            String path = savedInstanceState.getString(KEY_FILE);
-            if (path != null && path.length() > 0) {
-                f = new File(path);
-                current = savedInstanceState.getString(KEY_PATH);
-                new RarHelperTask(this, current).execute(f);
-            } else loadRarlist(f.getPath());
-        }
-    }
-
-    void SetupZip(Bundle savedInstanceState) {
-        if (savedInstanceState == null)
-            loadlist(s);
-        else {
-            wholelist = savedInstanceState.getParcelableArrayList(KEY_WHOLE_LIST);
-            elements = savedInstanceState.getParcelableArrayList(KEY_ELEMENTS);
-            current = savedInstanceState.getString(KEY_PATH);
-            f = new File(savedInstanceState.getString(KEY_FILE));
-            createviews(elements, current);
-        }
-    }
-
-    public void loadRarlist(String path) {
-        File f = new File(path);
-        new RarHelperTask(this, "").execute(f);
-
-    }
-
-    public boolean cangoBackRar() {
-        return !(current == null || current.trim().length() == 0);
-    }
-
-    public void goBackRar() {
-        String path;
-        try {
-            path = current.substring(0, current.lastIndexOf("\\"));
-        } catch (Exception e) {
-            path = "";
-        }
-        new RarHelperTask(this, path).execute(f);
-    }
-
-    public boolean canGoBack() {
-        if (openmode == 1) return cangoBackRar();
-        else return !(current == null || current.trim().length() == 0);
-    }
-
-    public void goBack() {
-        if (openmode == 1) {
-            goBackRar();
-            return;
-        }
-        new ZipHelperTask(this, new File(current).getParent()).execute(s);
-    }
-
-    void refresh() {
-        switch (openmode) {
-            case 0:
-                new ZipHelperTask(this, current).execute(s);
-                break;
-            case 1:
-                new RarHelperTask(this, current).execute(f);
-                break;
-        }
-    }
-
-
-    public void bbar() {
-        if (current != null && current.length() != 0)
-            mainActivity.updatePath("/" + current, false, OpenMode.FILE, folder, file);
-        else mainActivity.updatePath("/", false, OpenMode.FILE, folder, file);
-
-
-    }
-
-    int file = 0, folder = 0;
-
-    public void createviews(ArrayList<ZipObj> zipEntries, String dir) {
-        if (rarAdapter == null) {
-            zipViewer.rarAdapter = new RarAdapter(zipViewer.getActivity(), utilsProvider, zipEntries, zipViewer, true);
-            zipViewer.listView.setAdapter(zipViewer.rarAdapter);
-        } else rarAdapter.generate(zipEntries, true);
-        folder = 0;
-        file = 0;
-        for (ZipObj zipEntry : zipEntries)
-            if (zipEntry.isDirectory()) folder++;
-            else file++;
-        createViews(dir);
-        openmode = 0;
-    }
-
-    public void createRarviews(ArrayList<FileHeader> zipEntries, String dir) {
-        if (rarAdapter == null) {
-            zipViewer.rarAdapter = new RarAdapter(zipViewer.getActivity(), utilsProvider, zipEntries, zipViewer);
-            zipViewer.listView.setAdapter(zipViewer.rarAdapter);
-        } else
-            rarAdapter.generate(zipEntries);
-        folder = 0;
-        file = 0;
-        for (FileHeader zipEntry : zipEntries)
-            if (zipEntry.isDirectory()) folder++;
-            else file++;
-        openmode = 1;
-        createViews(dir);
-    }
-
-    void createViews(String dir) {
-        stopAnims = true;
-        if (!addheader) {
-            listView.removeItemDecoration(dividerItemDecoration);
-            //listView.removeItemDecoration(headersDecor);
-            addheader = true;
-        }
-        if (addheader) {
-            dividerItemDecoration = new DividerItemDecoration(getActivity(), true, showDividers);
-            listView.addItemDecoration(dividerItemDecoration);
-            //headersDecor = new StickyRecyclerHeadersDecoration(rarAdapter);
-            //listView.addItemDecoration(headersDecor);
-            addheader = false;
-        }
-        final FastScroller fastScroller = (FastScroller) rootView.findViewById(R.id.fastscroll);
-        fastScroller.setRecyclerView(listView, 1);
-        fastScroller.setPressedHandleColor(mainActivity.getColorPreference().getColor(ColorUsage.ACCENT));
-        ((AppBarLayout) mToolbarContainer).addOnOffsetChangedListener(new AppBarLayout.OnOffsetChangedListener() {
-            @Override
-            public void onOffsetChanged(AppBarLayout appBarLayout, int verticalOffset) {
-                fastScroller.updateHandlePosition(verticalOffset, 112);
-            }
-        });
-        listView.stopScroll();
-        zipViewer.current = dir;
-        zipViewer.bbar();
-        swipeRefreshLayout.setRefreshing(false);
-    }
-
-    public void loadlist(String path) {
-        new ZipHelperTask(this, "").execute(path);
-
-    }
-}
diff --git a/app/src/main/java/com/amaze/filemanager/fragments/preference_fragments/FoldersPref.java b/app/src/main/java/com/amaze/filemanager/fragments/preference_fragments/FoldersPref.java
index a4fad941b..d1d05aea2 100644
--- a/app/src/main/java/com/amaze/filemanager/fragments/preference_fragments/FoldersPref.java
+++ b/app/src/main/java/com/amaze/filemanager/fragments/preference_fragments/FoldersPref.java
@@ -18,13 +18,12 @@ import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.PreferencesActivity;
 import com.amaze.filemanager.database.UtilsHandler;
 import com.amaze.filemanager.ui.views.preference.PathSwitchPreference;
-import com.amaze.filemanager.utils.AppConfig;
+import com.amaze.filemanager.utils.application.AppConfig;
 import com.amaze.filemanager.utils.DataUtils;
-import com.amaze.filemanager.utils.OTGUtil;
 import com.amaze.filemanager.utils.SimpleTextWatcher;
 import com.amaze.filemanager.utils.color.ColorUsage;
+import com.amaze.filemanager.utils.files.FileUtils;
 
-import java.io.File;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.Map;
@@ -35,12 +34,12 @@ import java.util.Map;
  */
 
 public class FoldersPref extends PreferenceFragment implements Preference.OnPreferenceClickListener {
+
     public static final String KEY_SHORTCUT_PREF = "add_shortcut";
 
     private SharedPreferences sharedPrefs;
     private PreferencesActivity activity;
     private Map<Preference, Integer> position = new HashMap<>();
-    private ArrayList<String[]> currentValue;
     private DataUtils dataUtils;
     private UtilsHandler utilsHandler;
 
@@ -50,21 +49,19 @@ public class FoldersPref extends PreferenceFragment implements Preference.OnPref
         activity = (PreferencesActivity) getActivity();
 
         utilsHandler = new UtilsHandler(getActivity());
-        dataUtils = dataUtils.getInstance();
+        dataUtils = DataUtils.getInstance();
 
         // Load the preferences from an XML resource
         addPreferencesFromResource(R.xml.folders_prefs);
 
         sharedPrefs = PreferenceManager.getDefaultSharedPreferences(activity);
 
-        currentValue = dataUtils.getBooks();
-
         findPreference(KEY_SHORTCUT_PREF).setOnPreferenceClickListener(this);
 
-        for (int i = 0; i < currentValue.size(); i++) {
+        for (int i = 0; i < dataUtils.getBooks().size(); i++) {
             PathSwitchPreference p = new PathSwitchPreference(getActivity());
-            p.setTitle(currentValue.get(i) [0]);
-            p.setSummary(currentValue.get(i) [1]);
+            p.setTitle(dataUtils.getBooks().get(i) [0]);
+            p.setSummary(dataUtils.getBooks().get(i) [1]);
             p.setOnPreferenceClickListener(this);
 
             position.put(p, i);
@@ -72,6 +69,12 @@ public class FoldersPref extends PreferenceFragment implements Preference.OnPref
         }
     }
 
+    @Override
+    public void onResume() {
+        super.onResume();
+        onCreate(null);
+    }
+
     @Override
     public boolean onPreferenceClick(final Preference preference) {
         if (sharedPrefs != null) activity.setChanged();
@@ -98,23 +101,6 @@ public class FoldersPref extends PreferenceFragment implements Preference.OnPref
         return false;
     }
 
-    public static boolean canShortcutTo(String dir, SharedPreferences pref) {
-        File f = new File(dir);
-        boolean showIfHidden = pref.getBoolean(Preffrag.PREFERENCE_SHOW_HIDDENFILES, false),
-                isDirSelfOrParent = dir.endsWith("/.") || dir.endsWith("/.."),
-                showIfRoot = pref.getBoolean(Preffrag.PREFERENCE_ROOTMODE, false);
-
-        return f.exists() && f.isDirectory()
-                && (!f.isHidden() || (showIfHidden && !isDirSelfOrParent))
-                && (!isRoot(dir) || showIfRoot);
-
-        // TODO: 2/5/2017 use another system that doesn't create new object
-    }
-
-    private static boolean isRoot(String dir) {// TODO: 5/5/2017 hardcoding root might lead to problems down the line
-        return !dir.contains(OTGUtil.PREFIX_OTG) && !dir.startsWith("/storage");
-    }
-
     private void loadCreateDialog() {
         int fab_skin = activity.getColorPreference().getColor(ColorUsage.ACCENT);
 
@@ -150,12 +136,11 @@ public class FoldersPref extends PreferenceFragment implements Preference.OnPref
                         p.setSummary(editText2.getText());
                         p.setOnPreferenceClickListener(FoldersPref.this);
 
-                        position.put(p, currentValue.size());
+                        position.put(p, dataUtils.getBooks().size());
                         getPreferenceScreen().addPreference(p);
 
                         String[] values = new String[] {editText1.getText().toString(),
                                 editText2.getText().toString()};
-                        currentValue.add(values);
 
                         dataUtils.addBook(values);
                         AppConfig.runInBackground(new Runnable() {
@@ -197,7 +182,7 @@ public class FoldersPref extends PreferenceFragment implements Preference.OnPref
                 .build();
 
         dialog.getActionButton(DialogAction.POSITIVE)
-                .setEnabled(canShortcutTo(editText2.getText().toString(), sharedPrefs));
+                .setEnabled(FileUtils.isPathAccesible(editText2.getText().toString(), sharedPrefs));
 
         disableButtonIfTitleEmpty(editText1, dialog);
         disableButtonIfNotPath(editText2, dialog);
@@ -210,17 +195,21 @@ public class FoldersPref extends PreferenceFragment implements Preference.OnPref
                         final String oldName = p.getTitle().toString();
                         final String oldPath = p.getSummary().toString();
 
+
+                        dataUtils.removeBook(position.get(p));
+                        position.remove(p);
+                        getPreferenceScreen().removePreference(p);
+
                         p.setTitle(editText1.getText());
                         p.setSummary(editText2.getText());
 
+                        position.put(p, position.size());
+                        getPreferenceScreen().addPreference(p);
+
                         String[] values = new String[] {editText1.getText().toString(),
                                 editText2.getText().toString()};
 
-                        currentValue.set(position.get(p), values);
-
-                        dataUtils.removeBook(position.get(p));
-                        dataUtils.addBook(new String[] {editText1.getText().toString(),
-                                editText2.getText().toString()});
+                        dataUtils.addBook(values);
                         AppConfig.runInBackground(new Runnable() {
 
                             @Override
@@ -244,7 +233,7 @@ public class FoldersPref extends PreferenceFragment implements Preference.OnPref
                 .title(R.string.questiondelete_shortcut)
                 .theme(activity.getAppTheme().getMaterialDialogTheme())
                 .positiveColor(fab_skin)
-                .positiveText(getString(R.string.delete).toUpperCase())// TODO: 29/4/2017 don't use toUpperCase()
+                .positiveText(getString(R.string.delete).toUpperCase())// TODO: 29/4/2017 don't use toUpperCase(), 20/9,2017 why not?
                 .negativeColor(fab_skin)
                 .negativeText(android.R.string.cancel)
                 .build();
@@ -253,8 +242,6 @@ public class FoldersPref extends PreferenceFragment implements Preference.OnPref
                 .setOnClickListener(new View.OnClickListener() {
                     @Override
                     public void onClick(View view) {
-                        getPreferenceScreen().removePreference(p);
-                        currentValue.remove((int) position.get(p));
 
                         dataUtils.removeBook(position.get(p));
 
@@ -265,6 +252,9 @@ public class FoldersPref extends PreferenceFragment implements Preference.OnPref
                                         p.getSummary().toString());
                             }
                         });
+
+                        getPreferenceScreen().removePreference(p);
+                        position.remove(p);
                         dialog.dismiss();
                     }
                 });
@@ -277,7 +267,7 @@ public class FoldersPref extends PreferenceFragment implements Preference.OnPref
             @Override
             public void afterTextChanged(Editable s) {
                 dialog.getActionButton(DialogAction.POSITIVE)
-                        .setEnabled(canShortcutTo(s.toString(), sharedPrefs));
+                        .setEnabled(FileUtils.isPathAccesible(s.toString(), sharedPrefs));
             }
         });
     }
diff --git a/app/src/main/java/com/amaze/filemanager/fragments/preference_fragments/Preffrag.java b/app/src/main/java/com/amaze/filemanager/fragments/preference_fragments/PrefFrag.java
similarity index 87%
rename from app/src/main/java/com/amaze/filemanager/fragments/preference_fragments/Preffrag.java
rename to app/src/main/java/com/amaze/filemanager/fragments/preference_fragments/PrefFrag.java
index 047e6b8e9..59116ae4c 100644
--- a/app/src/main/java/com/amaze/filemanager/fragments/preference_fragments/Preffrag.java
+++ b/app/src/main/java/com/amaze/filemanager/fragments/preference_fragments/PrefFrag.java
@@ -36,7 +36,6 @@ import android.preference.PreferenceFragment;
 import android.preference.PreferenceManager;
 import android.support.annotation.NonNull;
 import android.support.v4.app.ActivityCompat;
-import android.util.Log;
 import android.view.View;
 import android.widget.Toast;
 
@@ -46,36 +45,38 @@ import com.amaze.filemanager.BuildConfig;
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.AboutActivity;
 import com.amaze.filemanager.activities.PreferencesActivity;
-import com.amaze.filemanager.exceptions.CryptException;
 import com.amaze.filemanager.ui.views.preference.CheckBox;
 import com.amaze.filemanager.utils.MainActivityHelper;
 import com.amaze.filemanager.utils.PreferenceUtils;
-import com.amaze.filemanager.utils.TinyDB;
 import com.amaze.filemanager.utils.color.ColorUsage;
 import com.amaze.filemanager.utils.files.CryptUtil;
 import com.amaze.filemanager.utils.provider.UtilitiesProviderInterface;
 import com.amaze.filemanager.utils.theme.AppTheme;
 
-import java.util.ArrayList;
+import java.io.IOException;
+import java.security.GeneralSecurityException;
+import java.util.List;
 
 import static com.amaze.filemanager.R.string.feedback;
 
-public class Preffrag extends PreferenceFragment implements Preference.OnPreferenceClickListener {
+public class PrefFrag extends PreferenceFragment implements Preference.OnPreferenceClickListener {
 
     private static final String PREFERENCE_KEY_ABOUT = "about";
     private static final String[] PREFERENCE_KEYS =
-            {"columns", "theme", "sidebar_folders_enable", "sidebar_quickaccess_enable",
-                    "rootmode", "showHidden", "feedback", PREFERENCE_KEY_ABOUT, "plus_pic", "colors",
-                    "sidebar_folders", "sidebar_quickaccess", "advancedsearch"};
+            {"columns", "theme", "rootmode", "showHidden", "feedback", PREFERENCE_KEY_ABOUT,
+                    "colors", "sidebar_folders", "sidebar_quickaccess", "advancedsearch"};
 
+    public static final String PREFERENCE_SHOW_SIDEBAR_FOLDERS = "sidebar_folders_enable";
+    public static final String PREFERENCE_SHOW_SIDEBAR_QUICKACCESSES = "sidebar_quickaccess_enable";
 
-    public static final String PREFERENCE_SHOW_SIDEBAR_FOLDERS = "show_sidebar_folders";
-    public static final String PREFERENCE_SHOW_SIDEBAR_QUICKACCESSES = "show_sidebar_quickaccesses";
+    public static final String PREFERENCE_TEXTEDITOR_NEWSTACK = "texteditor_newstack";
 
     public static final String PREFERENCE_SHOW_HIDDENFILES = "showHidden";
 
     public static final String PREFERENCE_ROOTMODE = "rootmode";
 
+    public static final String PREFERENCE_CHANGEPATHS = "typeablepaths";
+
     public static final String PREFERENCE_CRYPT_MASTER_PASSWORD = "crypt_password";
     public static final String PREFERENCE_CRYPT_FINGERPRINT = "crypt_fingerprint";
     public static final String PREFERENCE_CRYPT_WARNING_REMEMBER = "crypt_remember";
@@ -88,14 +89,12 @@ public class Preffrag extends PreferenceFragment implements Preference.OnPrefere
 
     private UtilitiesProviderInterface utilsProvider;
     private SharedPreferences sharedPref;
-    private CheckBox gplus;
 
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         utilsProvider = (UtilitiesProviderInterface) getActivity();
 
-        PreferenceUtils.reset();
         // Load the preferences from an XML resource
         addPreferencesFromResource(R.xml.preferences);
 
@@ -105,11 +104,6 @@ public class Preffrag extends PreferenceFragment implements Preference.OnPrefere
             findPreference(PREFERENCE_KEY).setOnPreferenceClickListener(this);
         }
 
-        gplus = (CheckBox) findPreference("plus_pic");
-
-        if (BuildConfig.IS_VERSION_FDROID)
-            gplus.setEnabled(false);
-
         // crypt master password
         final Preference masterPasswordPreference = findPreference(PREFERENCE_CRYPT_MASTER_PASSWORD);
 
@@ -207,12 +201,7 @@ public class Preffrag extends PreferenceFragment implements Preference.OnPrefere
                 builder.items(sort).itemsCallbackSingleChoice(current, new MaterialDialog.ListCallbackSingleChoice() {
                     @Override
                     public boolean onSelection(MaterialDialog dialog, View view, int which, CharSequence text) {
-                        utilsProvider.getThemeManager()
-                                .setAppTheme(AppTheme.fromIndex(which))
-                                .save();
-
-                        Log.d("theme", AppTheme.fromIndex(which).name());
-
+                        utilsProvider.getThemeManager().setAppTheme(AppTheme.getTheme(which));
                         dialog.dismiss();
                         restartPC(getActivity());
                         return true;
@@ -221,29 +210,25 @@ public class Preffrag extends PreferenceFragment implements Preference.OnPrefere
                 builder.title(R.string.theme);
                 builder.build().show();
                 return true;
-            case "sidebar_folders_enable":
-                sharedPref.edit().putBoolean(PREFERENCE_SHOW_SIDEBAR_FOLDERS,
-                        !sharedPref.getBoolean(PREFERENCE_SHOW_SIDEBAR_FOLDERS, true)).apply();
-                return true;
-            case "sidebar_quickaccess_enable":
-                sharedPref.edit().putBoolean(PREFERENCE_SHOW_SIDEBAR_QUICKACCESSES,
-                        !sharedPref.getBoolean(PREFERENCE_SHOW_SIDEBAR_QUICKACCESSES, true)).apply();
-                return true;
             case "feedback":
                 Intent emailIntent = new Intent(Intent.ACTION_SENDTO, Uri.fromParts(
                         "mailto", "vishalmeham2@gmail.com", null));
                 emailIntent.putExtra(Intent.EXTRA_SUBJECT, "Feedback : Amaze File Manager");
-                startActivity(Intent.createChooser(emailIntent, getResources().getString(feedback)));
+
+                PackageManager packageManager = getActivity().getPackageManager();
+                List activities = packageManager.queryIntentActivities(emailIntent,
+                        PackageManager.MATCH_DEFAULT_ONLY);
+                boolean isIntentSafe = activities.size() > 0;
+
+                if (isIntentSafe)
+                    startActivity(Intent.createChooser(emailIntent, getResources().getString(feedback)));
+                else
+                    Toast.makeText(getActivity(), getResources().getString(R.string.send_email_to)
+                            + " vishalmeham2@gmail.com", Toast.LENGTH_LONG).show();
                 return false;
             case PREFERENCE_KEY_ABOUT:
                 startActivity(new Intent(getActivity(), AboutActivity.class));
                 return false;
-            case "plus_pic":
-                if(gplus.isChecked()){
-                    boolean b= MainActivityHelper.checkAccountsPermission(getActivity());
-                    if(!b) MainActivityHelper.requestAccountsPermission(getActivity());
-                }
-                return false;
             /*FROM HERE BE FRAGMENTS*/
             case "colors":
                 ((PreferencesActivity) getActivity())
@@ -277,7 +262,7 @@ public class Preffrag extends PreferenceFragment implements Preference.OnPrefere
                         // no password set in preferences, just leave the field empty
                         decryptedPassword = "";
                     }
-                } catch (CryptException e) {
+                } catch (GeneralSecurityException | IOException e) {
                     e.printStackTrace();
                 }
 
@@ -311,9 +296,8 @@ public class Preffrag extends PreferenceFragment implements Preference.OnPrefere
                                 sharedPref.edit().putString(PREFERENCE_CRYPT_MASTER_PASSWORD,
                                         "").apply();
                             }
-                        } catch (CryptException e) {
+                        } catch (GeneralSecurityException | IOException e) {
                             e.printStackTrace();
-
                             sharedPref.edit().putString(PREFERENCE_CRYPT_MASTER_PASSWORD,
                                     PREFERENCE_CRYPT_MASTER_PASSWORD_DEFAULT).apply();
                         }
@@ -345,8 +329,4 @@ public class Preffrag extends PreferenceFragment implements Preference.OnPrefere
         activity.startActivity(activity.getIntent());
     }
 
-    public void invalidateGplus(){
-        boolean a=MainActivityHelper.checkAccountsPermission(getActivity());
-        if(!a)gplus.setChecked(false);
-    }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/services/ExtractService.java b/app/src/main/java/com/amaze/filemanager/services/ExtractService.java
deleted file mode 100644
index 473cb9aca..000000000
--- a/app/src/main/java/com/amaze/filemanager/services/ExtractService.java
+++ /dev/null
@@ -1,704 +0,0 @@
-/*
- * Copyright (C) 2014 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>
- *
- * This file is part of Amaze File Manager.
- *
- * Amaze File Manager is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.amaze.filemanager.services;
-
-import android.app.NotificationManager;
-import android.app.PendingIntent;
-import android.app.Service;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.os.AsyncTask;
-import android.os.Binder;
-import android.os.Bundle;
-import android.os.IBinder;
-import android.preference.PreferenceManager;
-import android.support.v4.app.NotificationCompat;
-import android.text.format.Formatter;
-import android.util.Log;
-
-import com.amaze.filemanager.R;
-import com.amaze.filemanager.activities.MainActivity;
-import com.amaze.filemanager.filesystem.FileUtil;
-import com.amaze.filemanager.utils.AppConfig;
-import com.amaze.filemanager.utils.DataPackage;
-import com.amaze.filemanager.utils.files.GenericCopyUtil;
-import com.amaze.filemanager.utils.ProgressHandler;
-import com.amaze.filemanager.utils.ServiceWatcherUtil;
-import com.github.junrar.Archive;
-import com.github.junrar.rarfile.FileHeader;
-
-import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
-import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
-
-import java.io.BufferedInputStream;
-import java.io.BufferedOutputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.util.ArrayList;
-import java.util.Enumeration;
-import java.util.zip.GZIPInputStream;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipFile;
-public class ExtractService extends Service {
-
-    Context cd;
-
-    // list of data packages,// to initiate chart in process viewer fragment
-    private ArrayList<DataPackage> dataPackages = new ArrayList<>();
-
-    // total size of file, can change later
-    private long totalSize = 0L;
-
-    private NotificationManager mNotifyManager;
-    private NotificationCompat.Builder mBuilder;
-    // names of entries to be extracted
-    private ArrayList<String> entries = new ArrayList<>();
-    private String epath;
-    private ProgressHandler progressHandler;
-
-    public static final String KEY_PATH_ZIP = "zip";
-    public static final String KEY_ENTRIES_ZIP = "entries";
-    public static final String TAG_BROADCAST_EXTRACT_CANCEL = "excancel";
-    public static final String KEY_PATH_EXTRACT = "extractpath";
-
-    @Override
-    public void onCreate() {
-        registerReceiver(receiver1, new IntentFilter(TAG_BROADCAST_EXTRACT_CANCEL));
-        cd = getApplicationContext();
-    }
-
-    @Override
-    public int onStartCommand(Intent intent, int flags, final int startId) {
-        Bundle b = new Bundle();
-        String file = intent.getStringExtra(KEY_PATH_ZIP);
-        String extractPath = intent.getStringExtra(KEY_PATH_EXTRACT);
-
-        if (extractPath != null) {
-            // a custom dynamic path to extract files to
-            epath = extractPath;
-        } else {
-
-            epath = PreferenceManager.getDefaultSharedPreferences(this).getString(KEY_PATH_EXTRACT, file);
-        }
-        mNotifyManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
-
-        entries = intent.getStringArrayListExtra(KEY_ENTRIES_ZIP);
-
-        b.putString(KEY_PATH_ZIP, file);
-
-        totalSize = getTotalSize(file);
-        progressHandler = new ProgressHandler(1, totalSize);
-
-        progressHandler.setProgressListener(new ProgressHandler.ProgressListener() {
-            @Override
-            public void onProgressed(String fileName, int sourceFiles, int sourceProgress, long totalSize,
-                                     long writtenSize, int speed) {
-                publishResults(startId, fileName, sourceFiles, sourceProgress, totalSize, writtenSize, speed, false);
-            }
-        });
-
-        Intent notificationIntent = new Intent(this, MainActivity.class);
-        notificationIntent.setAction(Intent.ACTION_MAIN);
-        notificationIntent.putExtra(MainActivity.KEY_INTENT_PROCESS_VIEWER, true);
-        PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);
-        mBuilder = new NotificationCompat.Builder(cd);
-        mBuilder.setContentIntent(pendingIntent);
-        mBuilder.setContentTitle(getResources().getString(R.string.extracting))
-                .setContentText(new File(file).getName())
-                .setSmallIcon(R.drawable.ic_zip_box_grey600_36dp);
-        startForeground(Integer.parseInt("123" + startId), mBuilder.build());
-
-        new DoWork().execute(b);
-        return START_STICKY;
-    }
-
-    /**
-     * Method calculates zip file size to initiate progress
-     * Supporting local file extraction progress for now
-     *
-     * @param filePath
-     * @return
-     */
-    private long getTotalSize(String filePath) {
-
-        return new File(filePath).length();
-    }
-
-    private final IBinder mBinder = new LocalBinder();
-
-    public class LocalBinder extends Binder {
-        public ExtractService getService() {
-            // Return this instance of LocalService so clients can call public methods
-            return ExtractService.this;
-        }
-    }
-
-    public void setProgressListener(ProgressListener progressListener) {
-        this.progressListener = progressListener;
-    }
-
-    ProgressListener progressListener;
-
-    public interface ProgressListener {
-        void onUpdate(DataPackage dataPackage);
-
-        void refresh();
-    }
-
-    private void publishResults(int id, String fileName, int sourceFiles, int sourceProgress,
-                                long total, long done, int speed, boolean isCompleted) {
-        if (!progressHandler.getCancelled()) {
-            mBuilder.setContentTitle(getResources().getString(R.string.extracting));
-            float progressPercent = ((float) done / total) * 100;
-            mBuilder.setProgress(100, Math.round(progressPercent), false);
-            mBuilder.setOngoing(true);
-            mBuilder.setContentText(fileName + " " + Formatter.formatFileSize(cd, done) + "/"
-                    + Formatter.formatFileSize(cd, total));
-            int id1 = Integer.parseInt("123" + id);
-            mNotifyManager.notify(id1, mBuilder.build());
-            if (progressPercent == 100 || total == 0) {
-                mBuilder.setContentTitle(getString(R.string.extract_complete));
-                mBuilder.setContentText(fileName + " " + Formatter.formatFileSize(cd, total));
-                mBuilder.setProgress(100, 100, false);
-                mBuilder.setOngoing(false);
-                mNotifyManager.notify(id1, mBuilder.build());
-                publishCompletedResult("", id1);
-            }
-
-            DataPackage intent = new DataPackage();
-            intent.setName(fileName);
-            intent.setSourceFiles(sourceFiles);
-            intent.setSourceProgress(sourceProgress);
-            intent.setTotal(total);
-            intent.setByteProgress(done);
-            intent.setSpeedRaw(speed);
-            intent.setMove(false);
-            intent.setCompleted(isCompleted);
-            putDataPackage(intent);
-
-            if (progressListener != null) {
-                progressListener.onUpdate(intent);
-                if (isCompleted) progressListener.refresh();
-            }
-        } else publishCompletedResult(fileName, Integer.parseInt("123" + id));
-    }
-
-    public void publishCompletedResult(String a, int id1) {
-        try {
-            mNotifyManager.cancel(id1);
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-    }
-
-    public class DoWork extends AsyncTask<Bundle, Void, Integer> {
-
-        long totalBytes = 0L;
-        private ServiceWatcherUtil watcherUtil;
-
-        private void createDir(File dir) {
-            FileUtil.mkdir(dir, cd);
-        }
-
-        /**
-         * Method extracts {@link ZipEntry} from {@link ZipFile}
-         *
-         * @param zipFile   zip file from which entries are to be extracted
-         * @param entry     zip entry that is to be extracted
-         * @param outputDir output directory
-         * @throws Exception
-         */
-        private void unzipEntry(ZipFile zipFile, ZipEntry entry, String outputDir)
-                throws Exception {
-
-            if (entry.isDirectory()) {
-                // zip entry is a directory, return after creating new directory
-                createDir(new File(outputDir, entry.getName()));
-                return;
-            }
-
-            final File outputFile = new File(outputDir, entry.getName());
-
-            if (!outputFile.getParentFile().exists()) {
-                // creating directory if not already exists
-
-                createDir(outputFile.getParentFile());
-            }
-
-            BufferedInputStream inputStream = new BufferedInputStream(
-                    zipFile.getInputStream(entry));
-            BufferedOutputStream outputStream = new BufferedOutputStream(
-                    FileUtil.getOutputStream(outputFile, cd, 0));
-            try {
-                int len;
-                byte buf[] = new byte[GenericCopyUtil.DEFAULT_BUFFER_SIZE];
-                while ((len = inputStream.read(buf)) > 0) {
-
-                    outputStream.write(buf, 0, len);
-                    ServiceWatcherUtil.POSITION += len;
-                }
-            } finally {
-                outputStream.close();
-                inputStream.close();
-            }
-        }
-
-        private void unzipRAREntry(Archive zipFile, FileHeader entry, String outputDir)
-                throws Exception {
-            String name = entry.getFileNameString();
-            name = name.replaceAll("\\\\", "/");
-            if (entry.isDirectory()) {
-                createDir(new File(outputDir, name));
-                return;
-            }
-            File outputFile = new File(outputDir, name);
-            if (!outputFile.getParentFile().exists()) {
-                createDir(outputFile.getParentFile());
-            }
-            //	Log.i("Amaze", "Extracting: " + entry);
-            BufferedInputStream inputStream = new BufferedInputStream(
-                    zipFile.getInputStream(entry));
-            BufferedOutputStream outputStream = new BufferedOutputStream(
-                    FileUtil.getOutputStream(outputFile, cd, entry.getFullUnpackSize()));
-            try {
-                int len;
-                byte buf[] = new byte[GenericCopyUtil.DEFAULT_BUFFER_SIZE];
-                while ((len = inputStream.read(buf)) > 0) {
-
-                    outputStream.write(buf, 0, len);
-                    ServiceWatcherUtil.POSITION += len;
-                }
-            } catch (Exception e) {
-
-                throw new Exception();
-            } finally {
-                outputStream.close();
-                inputStream.close();
-            }
-        }
-
-        private void unzipTAREntry(TarArchiveInputStream zipFileStream, TarArchiveEntry entry,
-                                   String outputDir) throws Exception {
-            String name = entry.getName();
-            if (entry.isDirectory()) {
-                createDir(new File(outputDir, name));
-                return;
-            }
-            File outputFile = new File(outputDir, name);
-            if (!outputFile.getParentFile().exists()) {
-                createDir(outputFile.getParentFile());
-            }
-
-            BufferedOutputStream outputStream = new BufferedOutputStream(
-                    FileUtil.getOutputStream(outputFile, cd, entry.getRealSize()));
-            try {
-                int len;
-                byte buf[] = new byte[GenericCopyUtil.DEFAULT_BUFFER_SIZE];
-                while ((len = zipFileStream.read(buf)) > 0) {
-
-                    outputStream.write(buf, 0, len);
-                    ServiceWatcherUtil.POSITION += len;
-                }
-            } catch (Exception e) {
-
-                throw new Exception();
-            } finally {
-                outputStream.close();
-            }
-        }
-
-        /**
-         * Helper method to initiate extraction of zip/jar files.
-         *
-         * @param archive         the file pointing to archive
-         * @param destinationPath the where to extract
-         * @param entryNamesList  names of files to be extracted from the archive
-         * @return
-         */
-        private boolean extract(File archive, String destinationPath,
-                                ArrayList<String> entryNamesList) {
-
-            ArrayList<ZipEntry> entry1 = new ArrayList<>();
-            try {
-                ZipFile zipfile = new ZipFile(archive);
-
-                // iterating archive elements to find file names that are to be extracted
-                for (Enumeration e = zipfile.entries(); e.hasMoreElements(); ) {
-
-                    ZipEntry zipEntry = (ZipEntry) e.nextElement();
-
-                    for (String entry : entryNamesList) {
-
-                        if (zipEntry.getName().contains(entry)) {
-                            // header to be extracted is atleast the entry path (may be more, when it is a directory)
-                            entry1.add(zipEntry);
-                        }
-                    }
-                }
-
-                // get the total size of elements to be extracted
-                for (ZipEntry entry : entry1) {
-                    totalBytes += entry.getSize();
-                }
-
-                // setting total bytes calculated from zip entries
-                progressHandler.setTotalSize(totalBytes);
-
-                setInitDataPackage(totalBytes, entry1.get(0).getName(), entryNamesList.size());
-
-                watcherUtil = new ServiceWatcherUtil(progressHandler, totalBytes);
-                watcherUtil.watch();
-
-                int i = 0;
-                for (ZipEntry entry : entry1) {
-                    if (!progressHandler.getCancelled()) {
-
-                        progressHandler.setFileName(entry.getName());
-                        unzipEntry(zipfile, entry, destinationPath);
-                        progressHandler.setSourceFilesProcessed(++i);
-                    }
-                }
-
-                return true;
-            } catch (Exception e) {
-                Log.e("amaze", "Error while extracting file " + archive, e);
-                AppConfig.toast(getApplicationContext(), getString(R.string.error));
-                return false;
-            }
-
-        }
-
-        private boolean extract(File archive, String destinationPath) {
-
-            try {
-                ArrayList<ZipEntry> arrayList = new ArrayList<>();
-                ZipFile zipfile = new ZipFile(archive);
-                for (Enumeration e = zipfile.entries(); e.hasMoreElements(); ) {
-
-                    // adding all the elements to be extracted to an array list
-                    ZipEntry entry = (ZipEntry) e.nextElement();
-                    arrayList.add(entry);
-                }
-
-                for (ZipEntry entry : arrayList) {
-                    // calculating size of compressed items
-                    totalBytes += entry.getSize();
-                }
-
-                // setting total bytes calculated from zip entries
-                progressHandler.setTotalSize(totalBytes);
-
-                setInitDataPackage(totalBytes, arrayList.get(0).getName(), 1);
-
-                watcherUtil = new ServiceWatcherUtil(progressHandler, totalBytes);
-                watcherUtil.watch();
-
-                for (ZipEntry entry : arrayList) {
-                    if (!progressHandler.getCancelled()) {
-
-                        progressHandler.setFileName(entry.getName());
-                        unzipEntry(zipfile, entry, destinationPath);
-                    }
-                }
-                progressHandler.setSourceFilesProcessed(1);
-
-                return true;
-            } catch (Exception e) {
-                Log.e("amaze", "Error while extracting file " + archive, e);
-                AppConfig.toast(getApplicationContext(), getString(R.string.error));
-                return false;
-            }
-
-        }
-
-        private boolean extractTar(File archive, String destinationPath) {
-
-            try {
-
-                ArrayList<TarArchiveEntry> archiveEntries = new ArrayList<>();
-
-                TarArchiveInputStream inputStream;
-
-                if (archive.getName().endsWith(".tar"))
-                    inputStream = new TarArchiveInputStream(new BufferedInputStream(new FileInputStream(archive)));
-                else
-                    inputStream = new TarArchiveInputStream(new GZIPInputStream(new FileInputStream(archive)));
-
-                TarArchiveEntry tarArchiveEntry = inputStream.getNextTarEntry();
-
-                while (tarArchiveEntry != null) {
-                    archiveEntries.add(tarArchiveEntry);
-                    tarArchiveEntry = inputStream.getNextTarEntry();
-                }
-
-                for (TarArchiveEntry entry : archiveEntries) {
-                    totalBytes += entry.getSize();
-                }
-
-                // setting total bytes calculated from zip entries
-                progressHandler.setTotalSize(totalBytes);
-
-                setInitDataPackage(totalBytes, archiveEntries.get(0).getName(), 1);
-
-                watcherUtil = new ServiceWatcherUtil(progressHandler, totalBytes);
-                watcherUtil.watch();
-
-                for (TarArchiveEntry entry : archiveEntries) {
-
-                    if (!progressHandler.getCancelled()) {
-
-                        progressHandler.setFileName(entry.getName());
-                        unzipTAREntry(inputStream, entry, destinationPath);
-                    }
-                }
-                progressHandler.setSourceFilesProcessed(1);
-
-                // operating finished
-                inputStream.close();
-
-                return true;
-            } catch (Exception e) {
-                Log.e("amaze", "Error while extracting file " + archive, e);
-                AppConfig.toast(getApplicationContext(), getString(R.string.error));
-                return false;
-            }
-
-        }
-
-        private boolean extractRar(File archive, String destinationPath) {
-
-            try {
-                ArrayList<FileHeader> arrayList = new ArrayList<>();
-                Archive zipFile = new Archive(archive);
-                FileHeader fh = zipFile.nextFileHeader();
-
-                while (fh != null) {
-                    arrayList.add(fh);
-                    fh = zipFile.nextFileHeader();
-
-                }
-
-                for (FileHeader header : arrayList) {
-                    totalBytes += header.getFullUnpackSize();
-                }
-
-                // setting total bytes calculated from zip entries
-                progressHandler.setTotalSize(totalBytes);
-
-                setInitDataPackage(totalBytes, arrayList.get(0).getFileNameString(), 1);
-
-                watcherUtil = new ServiceWatcherUtil(progressHandler, totalBytes);
-                watcherUtil.watch();
-
-                for (FileHeader header : arrayList) {
-
-                    if (!progressHandler.getCancelled()) {
-
-                        progressHandler.setFileName(header.getFileNameString());
-                        unzipRAREntry(zipFile, header, destinationPath);
-                    }
-                }
-                progressHandler.setSourceFilesProcessed(1);
-
-                return true;
-            } catch (Exception e) {
-                Log.e("amaze", "Error while extracting file " + archive, e);
-                AppConfig.toast(getApplicationContext(), getString(R.string.error));
-                return false;
-            }
-        }
-
-        private boolean extractRar(File archive, String destinationPath, ArrayList<String> entries) {
-
-            try {
-
-                Archive rarFile = new Archive(archive);
-
-                ArrayList<FileHeader> arrayList = new ArrayList<>();
-
-                // iterating archive elements to find file names that are to be extracted
-                for (FileHeader header : rarFile.getFileHeaders()) {
-                    for (String entry : entries) {
-
-                        if (header.getFileNameString().contains(entry)) {
-                            // header to be extracted is atleast the entry path (may be more, when it is a directory)
-                            arrayList.add(header);
-                        }
-                    }
-                }
-
-                // get the total size of elements to be extracted
-                for (FileHeader entry : arrayList) {
-                    totalBytes += entry.getFullUnpackSize();
-                }
-
-                // setting total bytes calculated from zip entries
-                progressHandler.setTotalSize(totalBytes);
-
-                setInitDataPackage(totalBytes, arrayList.get(0).getFileNameString(), arrayList.size());
-
-                watcherUtil = new ServiceWatcherUtil(progressHandler, totalBytes);
-                watcherUtil.watch();
-
-                int i = 0;
-                for (FileHeader entry : arrayList) {
-                    if (!progressHandler.getCancelled()) {
-
-                        progressHandler.setFileName(entry.getFileNameString());
-                        unzipRAREntry(rarFile, entry, destinationPath);
-                        progressHandler.setSourceFilesProcessed(++i);
-                    }
-                }
-
-                return true;
-            } catch (Exception e) {
-
-                Log.e("amaze", "Error while extracting file " + archive, e);
-                AppConfig.toast(getApplicationContext(), getString(R.string.error));
-                return false;
-            }
-        }
-
-        protected Integer doInBackground(Bundle... p1) {
-
-            String file = p1[0].getString(KEY_PATH_ZIP);
-
-            File f = new File(file);
-
-            String path;
-            if (epath.equals(file)) {
-
-                // custom extraction path not set, extract at default path
-                path = f.getParent() + "/" + f.getName().substring(0, f.getName().lastIndexOf("."));
-            } else {
-
-                if (epath.endsWith("/")) {
-                    path = epath + f.getName().substring(0, f.getName().lastIndexOf("."));
-                } else {
-                    path = epath + "/" + f.getName().substring(0, f.getName().lastIndexOf("."));
-                }
-            }
-
-            if (entries != null && entries.size() != 0) {
-                if (f.getName().toLowerCase().endsWith(".zip") || f.getName().toLowerCase().endsWith(".jar") || f.getName().toLowerCase().endsWith(".apk"))
-                    extract(f, path, entries);
-                else if (f.getName().toLowerCase().endsWith(".rar"))
-                    extractRar(f, path, entries);
-            } else if (f.getName().toLowerCase().endsWith(".zip") || f.getName().toLowerCase().endsWith(".jar") || f.getName().toLowerCase().endsWith(".apk"))
-                extract(f, path);
-            else if (f.getName().toLowerCase().endsWith(".rar"))
-                extractRar(f, path);
-            else if (f.getName().toLowerCase().endsWith(".tar") || f.getName().toLowerCase().endsWith(".tar.gz"))
-                extractTar(f, path);
-            Log.i("Amaze", "Almost Completed");
-            // TODO: Implement this method
-            return p1[0].getInt("id");
-        }
-
-        @Override
-        public void onPostExecute(Integer b) {
-
-            // check whether watcherutil was initialized. It was not initialized when we got exception
-            // in extracting the file
-            if (watcherUtil != null) watcherUtil.stopWatch();
-            Intent intent = new Intent("loadlist");
-            sendBroadcast(intent);
-            stopSelf();
-        }
-
-
-    }
-
-    /**
-     * Setting initial package to initialize charts in process viewer properly
-     *
-     * @param totalSize
-     * @param fileName
-     */
-    private void setInitDataPackage(long totalSize, String fileName, int sourceTotal) {
-
-        DataPackage intent1 = new DataPackage();
-        intent1.setName(fileName);
-        intent1.setSourceFiles(sourceTotal);
-        intent1.setSourceProgress(0);
-        intent1.setTotal(totalSize);
-        intent1.setByteProgress(0);
-        intent1.setSpeedRaw(0);
-        intent1.setMove(false);
-        intent1.setCompleted(false);
-        putDataPackage(intent1);
-    }
-
-    @Override
-    public void onDestroy() {
-        unregisterReceiver(receiver1);
-    }
-
-    /**
-     * Class used for the client Binder.  Because we know this service always
-     * runs in the same process as its clients, we don't need to deal with IPC.
-     */
-    private BroadcastReceiver receiver1 = new BroadcastReceiver() {
-
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            progressHandler.setCancelled(true);
-        }
-    };
-
-    @Override
-    public IBinder onBind(Intent arg0) {
-        // TODO Auto-generated method stub
-        return mBinder;
-    }
-
-    /**
-     * Returns the {@link #dataPackages} list which contains
-     * data to be transferred to {@link com.amaze.filemanager.fragments.ProcessViewer}
-     * Method call is synchronized so as to avoid modifying the list
-     * by {@link ServiceWatcherUtil#handlerThread} while {@link MainActivity#runOnUiThread(Runnable)}
-     * is executing the callbacks in {@link com.amaze.filemanager.fragments.ProcessViewer}
-     *
-     * @return
-     */
-    public synchronized DataPackage getDataPackage(int index) {
-        return this.dataPackages.get(index);
-    }
-
-    public synchronized int getDataPackageSize() {
-        return this.dataPackages.size();
-    }
-
-    /**
-     * Puts a {@link DataPackage} into a list
-     * Method call is synchronized so as to avoid modifying the list
-     * by {@link ServiceWatcherUtil#handlerThread} while {@link MainActivity#runOnUiThread(Runnable)}
-     * is executing the callbacks in {@link com.amaze.filemanager.fragments.ProcessViewer}
-     *
-     * @param dataPackage
-     */
-    private synchronized void putDataPackage(DataPackage dataPackage) {
-        this.dataPackages.add(dataPackage);
-    }
-
-}
-
diff --git a/app/src/main/java/com/amaze/filemanager/services/asynctasks/LoadList.java b/app/src/main/java/com/amaze/filemanager/services/asynctasks/LoadList.java
deleted file mode 100644
index b3117625e..000000000
--- a/app/src/main/java/com/amaze/filemanager/services/asynctasks/LoadList.java
+++ /dev/null
@@ -1,501 +0,0 @@
-/*
- * Copyright (C) 2014 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>
- *     Emmanuel Messulam <emmanuelbendavid@gmail.com>
- *
- * This file is part of Amaze File Manager.
- *
- * Amaze File Manager is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.amaze.filemanager.services.asynctasks;
-
-import android.content.Context;
-import android.database.Cursor;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.graphics.drawable.BitmapDrawable;
-import android.net.Uri;
-import android.os.AsyncTask;
-import android.provider.MediaStore;
-import android.text.format.Formatter;
-import android.util.Log;
-import android.widget.Toast;
-
-import com.amaze.filemanager.R;
-import com.amaze.filemanager.activities.BaseActivity;
-import com.amaze.filemanager.database.UtilsHandler;
-import com.amaze.filemanager.exceptions.CloudPluginException;
-import com.amaze.filemanager.exceptions.RootNotPermittedException;
-import com.amaze.filemanager.filesystem.BaseFile;
-import com.amaze.filemanager.filesystem.HFile;
-import com.amaze.filemanager.filesystem.RootHelper;
-import com.amaze.filemanager.fragments.CloudSheetFragment;
-import com.amaze.filemanager.fragments.MainFragment;
-import com.amaze.filemanager.ui.LayoutElement;
-import com.amaze.filemanager.ui.icons.Icons;
-import com.amaze.filemanager.utils.DataUtils;
-import com.amaze.filemanager.utils.OTGUtil;
-import com.amaze.filemanager.utils.OpenMode;
-import com.amaze.filemanager.utils.cloud.CloudUtil;
-import com.amaze.filemanager.utils.files.CryptUtil;
-import com.amaze.filemanager.utils.files.FileListSorter;
-import com.amaze.filemanager.utils.provider.UtilitiesProviderInterface;
-import com.cloudrail.si.interfaces.CloudStorage;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Calendar;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.Date;
-
-import jcifs.smb.SmbAuthException;
-import jcifs.smb.SmbException;
-import jcifs.smb.SmbFile;
-
-public class LoadList extends AsyncTask<String, String, ArrayList<LayoutElement>> {
-
-    private UtilitiesProviderInterface utilsProvider;
-    private String path;
-    private boolean back;
-    private MainFragment ma;
-    private Context c;
-    private OpenMode openmode;
-    private boolean grid;
-    private DataUtils dataUtils = DataUtils.getInstance();
-    private UtilsHandler utilsHandler;
-
-    public LoadList(Context c, UtilitiesProviderInterface utilsProvider, boolean back,
-                    MainFragment ma, OpenMode openmode, UtilsHandler utilsHandler) {
-        this.utilsProvider = utilsProvider;
-        this.back = back;
-        this.ma = ma;
-        this.openmode = openmode;
-        this.c = c;
-        this.utilsHandler = utilsHandler;
-    }
-
-    @Override
-    protected void onPreExecute() {
-        ma.mSwipeRefreshLayout.setRefreshing(true);
-    }
-
-    @Override
-    protected ArrayList<LayoutElement> doInBackground(String... params) {// params[0] is the url.
-        ArrayList<LayoutElement> list = null;
-        path = params[0];
-        grid = ma.checkPathIsGrid(path);
-        ma.folder_count = 0;
-        ma.file_count = 0;
-        if (openmode == OpenMode.UNKNOWN) {
-            HFile hFile = new HFile(OpenMode.UNKNOWN, path);
-            hFile.generateMode(ma.getActivity());
-
-            if (hFile.isLocal()) {
-                openmode = OpenMode.FILE;
-            } else if (hFile.isSmb()) {
-                openmode = OpenMode.SMB;
-                ma.smbPath = path;
-            } else if (hFile.isOtgFile()) {
-                openmode = OpenMode.OTG;
-            } else if (hFile.isBoxFile()) {
-                openmode = OpenMode.BOX;
-            } else if (hFile.isDropBoxFile()) {
-                openmode = OpenMode.DROPBOX;
-            } else if (hFile.isGoogleDriveFile()) {
-                openmode = OpenMode.GDRIVE;
-            } else if (hFile.isOneDriveFile()) {
-                openmode = OpenMode.ONEDRIVE;
-            } else if (hFile.isSftp()) {
-                openmode = OpenMode.SFTP;
-            } else if (hFile.isCustomPath())
-                openmode = OpenMode.CUSTOM;
-            else if (android.util.Patterns.EMAIL_ADDRESS.matcher(path).matches()) {
-                openmode = OpenMode.ROOT;
-            }
-        }
-
-        switch (openmode) {
-            case SMB:
-                HFile hFile = new HFile(OpenMode.SMB, path);
-                try {
-                    SmbFile[] smbFile = hFile.getSmbFile(5000).listFiles();
-                    list = ma.addToSmb(smbFile, path);
-                    openmode = OpenMode.SMB;
-                } catch (SmbAuthException e) {
-                    if (!e.getMessage().toLowerCase().contains("denied"))
-                        ma.reauthenticateSmb();
-                    publishProgress(e.getLocalizedMessage());
-                } catch (SmbException | NullPointerException e) {
-                    publishProgress(e.getLocalizedMessage());
-                    e.printStackTrace();
-                }
-                break;
-            case SFTP:
-                HFile sftpHFile = new HFile(OpenMode.SFTP, path);
-                Log.d("DEBUG.LoadList", path);
-                ArrayList<BaseFile> files = sftpHFile.listFiles(c, false);
-                list = addTo(files);
-                break;
-            case CUSTOM:
-                ArrayList<BaseFile> arrayList = null;
-                switch (Integer.parseInt(path)) {
-                    case 0:
-                        arrayList = listImages();
-                        break;
-                    case 1:
-                        arrayList = listVideos();
-                        break;
-                    case 2:
-                        arrayList = listaudio();
-                        break;
-                    case 3:
-                        arrayList = listDocs();
-                        break;
-                    case 4:
-                        arrayList = listApks();
-                        break;
-                    case 5:
-                        arrayList = listRecent();
-                        break;
-                    case 6:
-                        arrayList = listRecentFiles();
-                        break;
-                }
-
-                path = String.valueOf(Integer.parseInt(path));
-
-                if (arrayList != null)
-                    list = addTo(arrayList);
-                else return new ArrayList<>();
-                break;
-            case OTG:
-                list = addTo(listOtg(path));
-                openmode = OpenMode.OTG;
-                break;
-            case DROPBOX:
-
-                CloudStorage cloudStorageDropbox = dataUtils.getAccount(OpenMode.DROPBOX);
-
-                try {
-                    list = addTo(listCloud(path, cloudStorageDropbox, OpenMode.DROPBOX));
-                } catch (CloudPluginException e) {
-                    e.printStackTrace();
-                    return new ArrayList<>();
-                }
-                break;
-            case BOX:
-                CloudStorage cloudStorageBox = dataUtils.getAccount(OpenMode.BOX);
-
-                try {
-                    list = addTo(listCloud(path, cloudStorageBox, OpenMode.BOX));
-                } catch (CloudPluginException e) {
-                    e.printStackTrace();
-                    return new ArrayList<>();
-                }
-                break;
-            case GDRIVE:
-                CloudStorage cloudStorageGDrive = dataUtils.getAccount(OpenMode.GDRIVE);
-
-                try {
-                    list = addTo(listCloud(path, cloudStorageGDrive, OpenMode.GDRIVE));
-                } catch (CloudPluginException e) {
-                    e.printStackTrace();
-                    return new ArrayList<>();
-                }
-                break;
-            case ONEDRIVE:
-                CloudStorage cloudStorageOneDrive = dataUtils.getAccount(OpenMode.ONEDRIVE);
-
-                try {
-                    list = addTo(listCloud(path, cloudStorageOneDrive, OpenMode.ONEDRIVE));
-                } catch (CloudPluginException e) {
-                    e.printStackTrace();
-                    return new ArrayList<>();
-                }
-                break;
-            default:
-                // we're neither in OTG not in SMB, load the list based on root/general filesystem
-                try {
-                    ArrayList<BaseFile> arrayList1;
-                    arrayList1 = RootHelper.getFilesList(path, BaseActivity.rootMode, ma.SHOW_HIDDEN,
-                            new RootHelper.GetModeCallBack() {
-                                @Override
-                                public void getMode(OpenMode mode) {
-                                    openmode = mode;
-                                }
-                            });
-                    list = addTo(arrayList1);
-
-                } catch (RootNotPermittedException e) {
-                    //AppConfig.toast(c, c.getString(R.string.rootfailure));
-                    return null;
-                }
-                break;
-        }
-
-        if (list != null && !(openmode == OpenMode.CUSTOM && ((path).equals("5") || (path).equals("6")))) {
-            Collections.sort(list, new FileListSorter(ma.dsort, ma.sortby, ma.asc));
-        }
-
-        return list;
-    }
-
-    @Override
-    protected void onPostExecute(ArrayList<LayoutElement> list) {
-        if (isCancelled()) {
-            list = null;
-        }
-
-        ma.createViews(list, back, path, openmode, false, grid);
-        ma.mSwipeRefreshLayout.setRefreshing(false);
-    }
-
-    @Override
-    public void onProgressUpdate(String... message) {
-        Toast.makeText(c, message[0], Toast.LENGTH_SHORT).show();
-    }
-
-    private ArrayList<LayoutElement> addTo(ArrayList<BaseFile> baseFiles) {
-        ArrayList<LayoutElement> items = new ArrayList<>();
-
-        for (int i = 0; i < baseFiles.size(); i++) {
-            BaseFile baseFile = baseFiles.get(i);
-            //File f = new File(ele.getPath());
-            String size = "";
-            if (!dataUtils.getHiddenfiles().contains(baseFile.getPath())) {
-                if (baseFile.isDirectory()) {
-                    size = "";
-
-                    Bitmap lockBitmap = BitmapFactory.decodeResource(ma.getResources(), R.drawable.ic_folder_lock_white_36dp);
-                    BitmapDrawable lockBitmapDrawable = new BitmapDrawable(ma.getResources(), lockBitmap);
-
-                    LayoutElement layoutElement = utilsProvider.getFutils()
-                            .newElement(baseFile.getName().endsWith(CryptUtil.CRYPT_EXTENSION) ? lockBitmapDrawable
-                                            : ma.folder,
-                                    baseFile.getPath(), baseFile.getPermission(), baseFile.getLink(), size, 0, true, false,
-                                    baseFile.getDate() + "");
-                    layoutElement.setMode(baseFile.getMode());
-                    items.add(layoutElement);
-                    ma.folder_count++;
-                } else {
-                    long longSize = 0;
-                    try {
-                        if (baseFile.getSize() != -1) {
-                            longSize = baseFile.getSize();
-                            size = Formatter.formatFileSize(c, longSize);
-                        } else {
-                            size = "";
-                            longSize = 0;
-                        }
-                    } catch (NumberFormatException e) {
-                        //e.printStackTrace();
-                    }
-                    try {
-                        LayoutElement layoutElement = utilsProvider.getFutils().newElement(Icons.loadMimeIcon(
-                                baseFile.getPath(), !ma.IS_LIST, ma.getResources()), baseFile.getPath(), baseFile.getPermission(),
-                                baseFile.getLink(), size, longSize, false, false, baseFile.getDate() + "");
-                        layoutElement.setMode(baseFile.getMode());
-                        items.add(layoutElement);
-                        ma.file_count++;
-                    } catch (Exception e) {
-                        e.printStackTrace();
-                    }
-                }
-            }
-        }
-        return items;
-    }
-
-    private ArrayList<BaseFile> listaudio() {
-        String selection = MediaStore.Audio.Media.IS_MUSIC + " != 0";
-        String[] projection = {
-                MediaStore.Audio.Media.DATA
-        };
-
-        Cursor cursor = c.getContentResolver().query(
-                MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
-                projection,
-                selection,
-                null,
-                null);
-
-        ArrayList<BaseFile> songs = new ArrayList<>();
-        if (cursor.getCount() > 0 && cursor.moveToFirst()) {
-            do {
-                String path = cursor.getString(cursor.getColumnIndex
-                        (MediaStore.Files.FileColumns.DATA));
-                BaseFile strings = RootHelper.generateBaseFile(new File(path), ma.SHOW_HIDDEN);
-                if (strings != null) songs.add(strings);
-            } while (cursor.moveToNext());
-        }
-        cursor.close();
-        return songs;
-    }
-
-    private ArrayList<BaseFile> listImages() {
-        ArrayList<BaseFile> songs = new ArrayList<>();
-        final String[] projection = {MediaStore.Images.Media.DATA};
-        final Cursor cursor = c.getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
-                projection, null, null, null);
-        if (cursor.getCount() > 0 && cursor.moveToFirst()) {
-            do {
-                String path = cursor.getString(cursor.getColumnIndex
-                        (MediaStore.Files.FileColumns.DATA));
-                BaseFile strings = RootHelper.generateBaseFile(new File(path), ma.SHOW_HIDDEN);
-                if (strings != null) songs.add(strings);
-            } while (cursor.moveToNext());
-        }
-        cursor.close();
-        return songs;
-    }
-
-    private ArrayList<BaseFile> listVideos() {
-        ArrayList<BaseFile> songs = new ArrayList<>();
-        final String[] projection = {MediaStore.Images.Media.DATA};
-        final Cursor cursor = c.getContentResolver().query(MediaStore.Video.Media.EXTERNAL_CONTENT_URI,
-                projection, null, null, null);
-        if (cursor.getCount() > 0 && cursor.moveToFirst()) {
-            do {
-                String path = cursor.getString(cursor.getColumnIndex
-                        (MediaStore.Files.FileColumns.DATA));
-                BaseFile strings = RootHelper.generateBaseFile(new File(path), ma.SHOW_HIDDEN);
-                if (strings != null) songs.add(strings);
-            } while (cursor.moveToNext());
-        }
-        cursor.close();
-        return songs;
-    }
-
-    private ArrayList<BaseFile> listRecentFiles() {
-        ArrayList<BaseFile> songs = new ArrayList<>();
-        final String[] projection = {MediaStore.Files.FileColumns.DATA, MediaStore.Files.FileColumns.DATE_MODIFIED};
-        Calendar c = Calendar.getInstance();
-        c.set(Calendar.DAY_OF_YEAR, c.get(Calendar.DAY_OF_YEAR) - 2);
-        Date d = c.getTime();
-        Cursor cursor = this.c.getContentResolver().query(MediaStore.Files
-                        .getContentUri("external"), projection,
-                null,
-                null, null);
-        if (cursor == null) return songs;
-        if (cursor.getCount() > 0 && cursor.moveToFirst()) {
-            do {
-                String path = cursor.getString(cursor.getColumnIndex
-                        (MediaStore.Files.FileColumns.DATA));
-                File f = new File(path);
-                if (d.compareTo(new Date(f.lastModified())) != 1 && !f.isDirectory()) {
-                    BaseFile strings = RootHelper.generateBaseFile(new File(path), ma.SHOW_HIDDEN);
-                    if (strings != null) songs.add(strings);
-                }
-            } while (cursor.moveToNext());
-        }
-        cursor.close();
-        Collections.sort(songs, new Comparator<BaseFile>() {
-            @Override
-            public int compare(BaseFile lhs, BaseFile rhs) {
-                return -1 * Long.valueOf(lhs.getDate()).compareTo(rhs.getDate());
-
-            }
-        });
-        if (songs.size() > 20)
-            for (int i = songs.size() - 1; i > 20; i--) {
-                songs.remove(i);
-            }
-        return songs;
-    }
-
-    private ArrayList<BaseFile> listApks() {
-        ArrayList<BaseFile> songs = new ArrayList<>();
-        final String[] projection = {MediaStore.Files.FileColumns.DATA};
-
-        Cursor cursor = c.getContentResolver()
-                .query(MediaStore.Files.getContentUri("external"), projection, null, null, null);
-        if (cursor.getCount() > 0 && cursor.moveToFirst()) {
-            do {
-                String path = cursor.getString(cursor.getColumnIndex
-                        (MediaStore.Files.FileColumns.DATA));
-                if (path != null && path.endsWith(".apk")) {
-                    BaseFile strings = RootHelper.generateBaseFile(new File(path), ma.SHOW_HIDDEN);
-                    if (strings != null) songs.add(strings);
-                }
-            } while (cursor.moveToNext());
-        }
-        cursor.close();
-        return songs;
-    }
-
-    private ArrayList<BaseFile> listRecent() {
-        UtilsHandler utilsHandler = new UtilsHandler(c);
-        final ArrayList<String> paths = utilsHandler.getHistoryList();
-        ArrayList<BaseFile> songs = new ArrayList<>();
-        for (String f : paths) {
-            if (!f.equals("/")) {
-                BaseFile a = RootHelper.generateBaseFile(new File(f), ma.SHOW_HIDDEN);
-                a.generateMode(ma.getActivity());
-                if (a != null && !a.isSmb() && !(a).isDirectory() && a.exists())
-                    songs.add(a);
-            }
-        }
-        return songs;
-    }
-
-    private ArrayList<BaseFile> listDocs() {
-        ArrayList<BaseFile> songs = new ArrayList<>();
-        final String[] projection = {MediaStore.Files.FileColumns.DATA};
-        Cursor cursor = c.getContentResolver().query(MediaStore.Files.getContentUri("external"),
-                projection, null, null, null);
-        String[] types = new String[]{".pdf", ".xml", ".html", ".asm", ".text/x-asm", ".def", ".in", ".rc",
-                ".list", ".log", ".pl", ".prop", ".properties", ".rc",
-                ".doc", ".docx", ".msg", ".odt", ".pages", ".rtf", ".txt", ".wpd", ".wps"};
-        if (cursor.getCount() > 0 && cursor.moveToFirst()) {
-            do {
-                String path = cursor.getString(cursor.getColumnIndex
-                        (MediaStore.Files.FileColumns.DATA));
-                if (path != null && contains(types, path)) {
-                    BaseFile strings = RootHelper.generateBaseFile(new File(path), ma.SHOW_HIDDEN);
-                    if (strings != null) songs.add(strings);
-                }
-            } while (cursor.moveToNext());
-        }
-        cursor.close();
-        return songs;
-    }
-
-    /**
-     * Lists files from an OTG device
-     *
-     * @param path the path to the directory tree, starts with prefix {@link com.amaze.filemanager.utils.OTGUtil#PREFIX_OTG}
-     *             Independent of URI (or mount point) for the OTG
-     * @return a list of files loaded
-     */
-    private ArrayList<BaseFile> listOtg(String path) {
-
-        return OTGUtil.getDocumentFilesList(path, c);
-    }
-
-    private boolean contains(String[] types, String path) {
-        for (String string : types) {
-            if (path.endsWith(string)) return true;
-        }
-        return false;
-    }
-
-    private ArrayList<BaseFile> listCloud(String path, CloudStorage cloudStorage, OpenMode openMode)
-            throws CloudPluginException {
-        if (!CloudSheetFragment.isCloudProviderAvailable(c))
-            throw new CloudPluginException();
-
-        return CloudUtil.listFiles(path, cloudStorage, openMode);
-    }
-}
diff --git a/app/src/main/java/com/amaze/filemanager/services/asynctasks/RarHelperTask.java b/app/src/main/java/com/amaze/filemanager/services/asynctasks/RarHelperTask.java
deleted file mode 100644
index a962e0eeb..000000000
--- a/app/src/main/java/com/amaze/filemanager/services/asynctasks/RarHelperTask.java
+++ /dev/null
@@ -1,104 +0,0 @@
-package com.amaze.filemanager.services.asynctasks;
-
-/**
- * Created by Arpit on 25-01-2015.
- */
-
-import android.os.AsyncTask;
-
-import com.amaze.filemanager.fragments.ZipViewer;
-import com.github.junrar.Archive;
-import com.github.junrar.rarfile.FileHeader;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-
-/**
- * Created by Vishal on 11/23/2014.
- */
-public class RarHelperTask extends AsyncTask<File, Void, ArrayList<FileHeader>> {
-
-    ZipViewer zipViewer;
-    String dir;
-
-    /**
-     * AsyncTask to load RAR file items.
-     * @param zipViewer the zipViewer fragment instance
-     * @param dir
-     */
-    public RarHelperTask(ZipViewer zipViewer, String dir) {
-        this.zipViewer = zipViewer;
-        this.dir = dir;
-    }
-
-    @Override
-    protected void onPreExecute() {
-        super.onPreExecute();
-
-        zipViewer.swipeRefreshLayout.setRefreshing(true);
-    }
-
-    @Override
-    protected ArrayList<FileHeader> doInBackground(File... params) {
-        ArrayList<FileHeader> elements = new ArrayList<>();
-        try {
-            Archive zipfile = new Archive(params[0]);
-            zipViewer.archive = zipfile;
-            if (zipViewer.wholelistRar.size() == 0) {
-
-                FileHeader fh = zipfile.nextFileHeader();
-                while (fh != null) {
-                    zipViewer.wholelistRar.add(fh);
-                    fh = zipfile.nextFileHeader();
-                }
-            }
-            if (dir == null || dir.trim().length() == 0 || dir.equals("")) {
-
-                for (FileHeader header : zipViewer.wholelistRar) {
-                    String name = header.getFileNameString();
-
-                    if (!name.contains("\\")) {
-                        elements.add(header);
-
-                    }
-                }
-            } else {
-                for (FileHeader header : zipViewer.wholelistRar) {
-                    String name = header.getFileNameString();
-                    if (name.substring(0, name.lastIndexOf("\\")).equals(dir)) {
-                        elements.add(header);
-                    }
-                }
-            }
-        } catch (Exception e) {
-
-        }
-        Collections.sort(elements, new FileListSorter());
-        return elements;
-    }
-
-    @Override
-    protected void onPostExecute(ArrayList<FileHeader> zipEntries) {
-        super.onPostExecute(zipEntries);
-        zipViewer.swipeRefreshLayout.setRefreshing(false);
-        zipViewer.createRarviews(zipEntries, dir);
-    }
-
-    private class FileListSorter implements Comparator<FileHeader> {
-        @Override
-        public int compare(FileHeader file1, FileHeader file2) {
-
-            if (file1.isDirectory() && !file2.isDirectory()) {
-                return -1;
-
-
-            } else if (file2.isDirectory() && !(file1).isDirectory()) {
-                return 1;
-            }
-            return file1.getFileNameString().compareToIgnoreCase(file2.getFileNameString());
-        }
-    }
-}
-
diff --git a/app/src/main/java/com/amaze/filemanager/services/asynctasks/ZipHelperTask.java b/app/src/main/java/com/amaze/filemanager/services/asynctasks/ZipHelperTask.java
deleted file mode 100644
index 42aac71bf..000000000
--- a/app/src/main/java/com/amaze/filemanager/services/asynctasks/ZipHelperTask.java
+++ /dev/null
@@ -1,151 +0,0 @@
-package com.amaze.filemanager.services.asynctasks;
-
-import android.net.Uri;
-import android.os.AsyncTask;
-
-import com.amaze.filemanager.fragments.ZipViewer;
-import com.amaze.filemanager.ui.ZipObj;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.Enumeration;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipFile;
-import java.util.zip.ZipInputStream;
-
-/**
- * Created by Vishal on 11/23/2014.
- */
-public class ZipHelperTask extends AsyncTask<String, Void, ArrayList<ZipObj>> {
-
-    ZipViewer zipViewer;
-    String dir;
-
-    /**
-     * AsyncTask to load ZIP file items.
-     * @param zipViewer the zipViewer fragment instance
-     * @param dir
-     */
-    public ZipHelperTask(ZipViewer zipViewer, String dir) {
-        this.zipViewer = zipViewer;
-        this.dir = dir;
-        zipViewer.swipeRefreshLayout.setRefreshing(true);
-    }
-
-    @Override
-    protected void onPreExecute() {
-        super.onPreExecute();
-        zipViewer.swipeRefreshLayout.setRefreshing(true);
-    }
-
-    @Override
-    protected ArrayList<ZipObj> doInBackground(String... params) {
-        ArrayList<ZipObj> elements = new ArrayList<>();
-        try {
-            if (zipViewer.wholelist.size() == 0) {
-                Uri uri = Uri.parse(params[0]);
-                if (new File(uri.getPath()).canRead()) {
-                    ZipFile zipfile = new ZipFile(uri.getPath());
-                    for (Enumeration e = zipfile.entries(); e.hasMoreElements(); ) {
-                        ZipEntry entry = (ZipEntry) e.nextElement();
-                        zipViewer.wholelist.add(new ZipObj(entry, entry.getTime(), entry.getSize(), entry.isDirectory()));
-                    }
-                } else {
-                    ZipEntry entry1;
-                    if (zipViewer.wholelist.size() == 0) {
-                        ZipInputStream zipfile1 = new ZipInputStream(zipViewer.getActivity().getContentResolver().openInputStream(uri));
-                        while ((entry1 = zipfile1.getNextEntry()) != null) {
-                            zipViewer.wholelist.add(new ZipObj(entry1, entry1.getTime(), entry1.getSize(), entry1.isDirectory()));
-                        }
-                    }
-                }
-            }
-            ArrayList<String> strings = new ArrayList<>();
-            //  int fileCount = zipfile.size();
-
-            for (ZipObj entry : zipViewer.wholelist) {
-
-                String s = entry.getName();
-                //  System.out.println(s);
-                File file = new File(entry.getName());
-                if (dir == null || dir.trim().length() == 0) {
-                    String y = entry.getName();
-                    if (y.startsWith("/"))
-                        y = y.substring(1, y.length());
-                    if (file.getParent() == null || file.getParent().length() == 0 || file.getParent().equals("/")) {
-                        if (!strings.contains(y)) {
-                            elements.add(new ZipObj(new ZipEntry(y), entry.getTime(), entry.getSize(), entry.isDirectory()));
-                            strings.add(y);
-                        }
-                    } else {
-                        String path = y.substring(0, y.indexOf("/") + 1);
-                        if (!strings.contains(path)) {
-                            ZipObj zipObj = new ZipObj(new ZipEntry(path), entry.getTime(), entry.getSize(), true);
-                            strings.add(path);
-                            elements.add(zipObj);
-                        }
-
-                    }
-                } else {
-                    String y = entry.getName();
-                    if (entry.getName().startsWith("/"))
-                        y = y.substring(1, y.length());
-
-                    if (file.getParent() != null && (file.getParent().equals(dir) || file.getParent().equals("/" + dir))) {
-                        if (!strings.contains(y)) {
-                            elements.add(new ZipObj(new ZipEntry(y), entry.getTime(), entry.getSize(), entry.isDirectory()));
-                            strings.add(y);
-                        }
-                    } else {
-                        if (y.startsWith(dir + "/") && y.length() > dir.length() + 1) {
-                            String path1 = y.substring(dir.length() + 1, y.length());
-
-                            int index = dir.length() + 1 + path1.indexOf("/");
-                            String path = y.substring(0, index + 1);
-                            if (!strings.contains(path)) {
-                                ZipObj zipObj = new ZipObj(new ZipEntry(y.substring(0, index + 1)), entry.getTime(), entry.getSize(), true);
-                                strings.add(path);
-                                //System.out.println(path);
-                                elements.add(zipObj);
-                            }
-                        }
-                    }
-
-                }
-            }
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-
-        Collections.sort(elements, new FileListSorter());
-        if (zipViewer.gobackitem && dir != null && dir.trim().length() != 0)
-            elements.add(0, new ZipObj(null, 0, 0, true));
-        zipViewer.elements = elements;
-        return elements;
-    }
-
-    @Override
-    protected void onPostExecute(ArrayList<ZipObj> zipEntries) {
-        super.onPostExecute(zipEntries);
-        zipViewer.swipeRefreshLayout.setRefreshing(false);
-        zipViewer.createviews(zipEntries, dir);
-    }
-
-    private class FileListSorter implements Comparator<ZipObj> {
-        @Override
-        public int compare(ZipObj file1, ZipObj file2) {
-            if (file1.isDirectory() && !file2.isDirectory()) {
-                return -1;
-
-
-            } else if (file2.isDirectory() && !(file1).isDirectory()) {
-                return 1;
-            }
-            return file1.getEntry().getName().compareToIgnoreCase(file2.getEntry().getName());
-        }
-
-    }
-
-}
diff --git a/app/src/main/java/com/amaze/filemanager/services/ftpservice/FTPTileService.java b/app/src/main/java/com/amaze/filemanager/services/ftpservice/FTPTileService.java
deleted file mode 100644
index 862c58430..000000000
--- a/app/src/main/java/com/amaze/filemanager/services/ftpservice/FTPTileService.java
+++ /dev/null
@@ -1,67 +0,0 @@
-package com.amaze.filemanager.services.ftpservice;
-
-import android.annotation.TargetApi;
-import android.content.Intent;
-import android.os.Build;
-import android.service.quicksettings.Tile;
-import android.service.quicksettings.TileService;
-import android.widget.Toast;
-
-import com.amaze.filemanager.R;
-
-/**
- * Created by vishal on 1/1/17.
- */
-
-@TargetApi(Build.VERSION_CODES.N)
-public class FTPTileService extends TileService {
-
-    // callbacks are not guaranteed to be called serially, so initialize this before use
-    private Tile mTile;
-
-    @Override
-    public void onTileAdded() {
-        super.onTileAdded();
-        mTile = getQsTile();
-        mTile.setState(Tile.STATE_INACTIVE);
-        mTile.updateTile();
-    }
-
-    @Override
-    public void onClick() {
-        super.onClick();
-
-        mTile = getQsTile();
-
-        if (!FTPService.isRunning()) {
-            if (FTPService.isConnectedToWifi(getApplicationContext())) {
-                startServer();
-                mTile.setState(Tile.STATE_ACTIVE);
-                mTile.updateTile();
-            }
-            else {
-                mTile.setState(Tile.STATE_INACTIVE);
-                mTile.updateTile();
-                Toast.makeText(getApplicationContext(), getString(R.string.ftp_no_wifi), Toast.LENGTH_LONG).show();
-            }
-        } else {
-            stopServer();
-            mTile.setState(Tile.STATE_INACTIVE);
-            mTile.updateTile();
-        }
-    }
-
-    /**
-     * Sends a broadcast to start ftp server
-     */
-    private void startServer() {
-        getApplicationContext().sendBroadcast(new Intent(FTPService.ACTION_START_FTPSERVER));
-    }
-
-    /**
-     * Sends a broadcast to stop ftp server
-     */
-    private void stopServer() {
-        getApplicationContext().sendBroadcast(new Intent(FTPService.ACTION_STOP_FTPSERVER));
-    }
-}
diff --git a/app/src/main/java/com/amaze/filemanager/services/ssh/SshConnectionPool.java b/app/src/main/java/com/amaze/filemanager/services/ssh/SshConnectionPool.java
index d1cc880bd..c61819735 100644
--- a/app/src/main/java/com/amaze/filemanager/services/ssh/SshConnectionPool.java
+++ b/app/src/main/java/com/amaze/filemanager/services/ssh/SshConnectionPool.java
@@ -30,7 +30,7 @@ import com.amaze.filemanager.database.UtilsHandler;
 import com.amaze.filemanager.services.ssh.tasks.AsyncTaskResult;
 import com.amaze.filemanager.services.ssh.tasks.PemToKeyPairTask;
 import com.amaze.filemanager.services.ssh.tasks.SshAuthenticationTask;
-import com.amaze.filemanager.utils.AppConfig;
+import com.amaze.filemanager.utils.application.AppConfig;
 
 import net.schmizz.sshj.SSHClient;
 
diff --git a/app/src/main/java/com/amaze/filemanager/ui/CircleAnimation.java b/app/src/main/java/com/amaze/filemanager/ui/CircleAnimation.java
deleted file mode 100644
index 153d96c30..000000000
--- a/app/src/main/java/com/amaze/filemanager/ui/CircleAnimation.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package com.amaze.filemanager.ui;
-
-import android.view.animation.Animation;
-import android.view.animation.Transformation;
-
-import com.amaze.filemanager.ui.views.SizeDrawable;
-
-/**
- * Created by Arpit on 30-07-2015.
- */
-public class CircleAnimation extends Animation {
-
-    private SizeDrawable circle;
-
-    private float newAngle2;
-    private float newAngle;
-    private float newAngle1;
-
-    public CircleAnimation(SizeDrawable circle, float newAngle, Float secondAngle) {
-        this.newAngle1 = newAngle;
-        this.newAngle = secondAngle;
-        newAngle2 = 360;
-        this.circle = circle;
-    }
-
-    @Override
-    protected void applyTransformation(float interpolatedTime, Transformation transformation) {
-
-        float angle = (interpolatedTime) * 360;
-        if (angle < newAngle) {
-            circle.setAngle(interpolatedTime, newAngle / 360);
-        } else if (angle < newAngle1) {
-            circle.setAngle(newAngle / 360, newAngle / 360);
-            circle.setAngle1(interpolatedTime, newAngle1 / 360);
-        } else {
-            circle.setAngle(newAngle / 360, newAngle / 360);
-            circle.setAngle1(newAngle1 / 360, newAngle1 / 360);
-            circle.setAngle2(interpolatedTime, newAngle2 / 360);
-        }
-        /*if(angle<newAngle){
-            circle.setAngle( angle,p1);
-        }else if(angle<newAngle1){
-            circle.setAngle( newAngle,p1);
-            circle.setAngle1(angle-newAngle,p2);
-        }else {
-            circle.setAngle(newAngle,p1);
-            circle.setAngle1(newAngle1-newAngle,p2);
-            circle.setAngle2(angle-newAngle1,p3);
-        }*/
-        circle.requestLayout();
-    }
-}
\ No newline at end of file
diff --git a/app/src/main/java/com/amaze/filemanager/ui/CompressedObjectParcelable.java b/app/src/main/java/com/amaze/filemanager/ui/CompressedObjectParcelable.java
new file mode 100644
index 000000000..bd9c04c73
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/ui/CompressedObjectParcelable.java
@@ -0,0 +1,114 @@
+package com.amaze.filemanager.ui;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import java.util.Comparator;
+
+/**
+ * @author Emmanuel Messulam <emmanuelbendavid@gmail.com>
+ *         on 20/11/2017, at 15:26.
+ */
+public class CompressedObjectParcelable implements Parcelable {
+    public static final int TYPE_GOBACK = -1, TYPE_NORMAL = 0;
+
+    private final boolean directory;
+    private final int type;
+    private final String name;
+    private final long date, size;
+
+    public CompressedObjectParcelable(String name, long date, long size, boolean directory) {
+        this.directory = directory;
+        this.type = TYPE_NORMAL;
+        this.name = name;
+        this.date = date;
+        this.size = size;
+    }
+
+    /**
+     * TYPE_GOBACK instance
+     */
+    public CompressedObjectParcelable() {
+        this.directory = true;
+        this.type = TYPE_GOBACK;
+        this.name = null;
+        this.date = 0;
+        this.size = 0;
+    }
+
+    public int getType() {
+        return type;
+    }
+
+    public boolean isDirectory() {
+        return directory;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public long getSize() {
+        return size;
+    }
+
+    public long getTime() {
+        return date;
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    public void writeToParcel(Parcel p1, int p2) {
+        p1.writeInt(type);
+        if(type != TYPE_GOBACK) {
+            p1.writeInt(directory? 1:0);
+            p1.writeString(name);
+            p1.writeLong(size);
+            p1.writeLong(date);
+        }
+    }
+
+    public static final Parcelable.Creator<CompressedObjectParcelable> CREATOR =
+            new Parcelable.Creator<CompressedObjectParcelable>() {
+                public CompressedObjectParcelable createFromParcel(Parcel in) {
+                    return new CompressedObjectParcelable(in);
+                }
+
+                public CompressedObjectParcelable[] newArray(int size) {
+                    return new CompressedObjectParcelable[size];
+                }
+            };
+
+    private CompressedObjectParcelable(Parcel im) {
+        type = im.readInt();
+        if(type == TYPE_GOBACK) {
+            directory = true;
+            name = null;
+            date = 0;
+            size = 0;
+        } else {
+            directory = im.readInt() == 1;
+            name = im.readString();
+            size = im.readLong();
+            date = im.readLong();
+        }
+    }
+
+    public static class Sorter implements Comparator<CompressedObjectParcelable> {
+        @Override
+        public int compare(CompressedObjectParcelable file1, CompressedObjectParcelable file2) {
+            if(file1.getType() == CompressedObjectParcelable.TYPE_GOBACK) return -1;
+            else if(file2.getType() == CompressedObjectParcelable.TYPE_GOBACK) return 1;
+            else if (file1.isDirectory() && !file2.isDirectory()) {
+                return -1;
+            } else if (file2.isDirectory() && !(file1).isDirectory()) {
+                return 1;
+            } else return file1.getName().compareToIgnoreCase(file2.getName());
+        }
+
+    }
+
+}
diff --git a/app/src/main/java/com/amaze/filemanager/ui/ItemPopupMenu.java b/app/src/main/java/com/amaze/filemanager/ui/ItemPopupMenu.java
index 00f2df5a6..d2801c390 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/ItemPopupMenu.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/ItemPopupMenu.java
@@ -10,17 +10,18 @@ import android.widget.PopupMenu;
 import android.widget.Toast;
 
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.activities.BaseActivity;
 import com.amaze.filemanager.activities.MainActivity;
-import com.amaze.filemanager.filesystem.BaseFile;
+import com.amaze.filemanager.activities.superclasses.ThemedActivity;
+import com.amaze.filemanager.asynchronous.services.EncryptService;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
+import com.amaze.filemanager.filesystem.PasteHelper;
 import com.amaze.filemanager.fragments.MainFragment;
-import com.amaze.filemanager.fragments.preference_fragments.Preffrag;
-import com.amaze.filemanager.services.EncryptService;
+import com.amaze.filemanager.fragments.preference_fragments.PrefFrag;
 import com.amaze.filemanager.ui.dialogs.GeneralDialogCreation;
 import com.amaze.filemanager.utils.DataUtils;
 import com.amaze.filemanager.utils.color.ColorUsage;
 import com.amaze.filemanager.utils.files.EncryptDecryptUtils;
-import com.amaze.filemanager.utils.files.Futils;
+import com.amaze.filemanager.utils.files.FileUtils;
 import com.amaze.filemanager.utils.provider.UtilitiesProviderInterface;
 
 import java.io.File;
@@ -39,17 +40,19 @@ public class ItemPopupMenu extends PopupMenu implements PopupMenu.OnMenuItemClic
     private MainActivity mainActivity;
     private UtilitiesProviderInterface utilitiesProvider;
     private MainFragment mainFragment;
-    private LayoutElement rowItem;
+    private SharedPreferences sharedPrefs;
+    private LayoutElementParcelable rowItem;
     private int accentColor;
 
     public ItemPopupMenu(Context c, MainActivity ma, UtilitiesProviderInterface up, MainFragment mainFragment,
-                         LayoutElement ri, View anchor) {
+                         LayoutElementParcelable ri, View anchor, SharedPreferences sharedPreferences) {
         super(c, anchor);
 
         context = c;
         mainActivity = ma;
         utilitiesProvider = up;
         this.mainFragment = mainFragment;
+        sharedPrefs = sharedPreferences;
         rowItem = ri;
         accentColor = mainActivity.getColorPreference().getColor(ColorUsage.ACCENT);
 
@@ -62,14 +65,14 @@ public class ItemPopupMenu extends PopupMenu implements PopupMenu.OnMenuItemClic
         switch (item.getItemId()) {
             case R.id.about:
                 GeneralDialogCreation.showPropertiesDialogWithPermissions((rowItem).generateBaseFile(),
-                        rowItem.getPermissions(), (BaseActivity) mainFragment.getActivity(),
-                        BaseActivity.rootMode, utilitiesProvider.getAppTheme());
+                        rowItem.getPermissions(), (ThemedActivity) mainFragment.getActivity(),
+                        ThemedActivity.rootMode, utilitiesProvider.getAppTheme());
                                 /*
                                 PropertiesSheet propertiesSheet = new PropertiesSheet();
                                 Bundle arguments = new Bundle();
                                 arguments.putParcelable(PropertiesSheet.KEY_FILE, rowItem.generateBaseFile());
                                 arguments.putString(PropertiesSheet.KEY_PERMISSION, rowItem.getPermissions());
-                                arguments.putBoolean(PropertiesSheet.KEY_ROOT, BaseActivity.rootMode);
+                                arguments.putBoolean(PropertiesSheet.KEY_ROOT, ThemedActivity.rootMode);
                                 propertiesSheet.setArguments(arguments);
                                 propertiesSheet.show(main.getFragmentManager(), PropertiesSheet.TAG_FRAGMENT);
                                 */
@@ -80,12 +83,12 @@ public class ItemPopupMenu extends PopupMenu implements PopupMenu.OnMenuItemClic
                     case BOX:
                     case GDRIVE:
                     case ONEDRIVE:
-                        utilitiesProvider.getFutils().shareCloudFile(rowItem.getDesc(), rowItem.getMode(), context);
+                        FileUtils.shareCloudFile(rowItem.getDesc(), rowItem.getMode(), context);
                         break;
                     default:
                         ArrayList<File> arrayList = new ArrayList<>();
                         arrayList.add(new File(rowItem.getDesc()));
-                        utilitiesProvider.getFutils().shareFiles(arrayList,
+                        FileUtils.shareFiles(arrayList,
                                 mainFragment.getMainActivity(), utilitiesProvider.getAppTheme(),
                                 accentColor);
                         break;
@@ -95,19 +98,12 @@ public class ItemPopupMenu extends PopupMenu implements PopupMenu.OnMenuItemClic
                 mainFragment.rename(rowItem.generateBaseFile());
                 return true;
             case R.id.cpy:
-                mainFragment.getMainActivity().MOVE_PATH = null;
-                ArrayList<BaseFile> copies = new ArrayList<>();
-                copies.add(rowItem.generateBaseFile());
-                mainFragment.getMainActivity().COPY_PATH = copies;
-                mainFragment.getMainActivity().supportInvalidateOptionsMenu();
-                return true;
-            case R.id.cut:
-                mainFragment.getMainActivity().COPY_PATH = null;
-                ArrayList<BaseFile> copie = new ArrayList<>();
-                copie.add(rowItem.generateBaseFile());
-                mainFragment.getMainActivity().MOVE_PATH = copie;
-                mainFragment.getMainActivity().supportInvalidateOptionsMenu();
+            case R.id.cut: {
+                int op = item.getItemId() == R.id.cpy? PasteHelper.OPERATION_COPY:PasteHelper.OPERATION_CUT;
+                PasteHelper pasteHelper = new PasteHelper(op, new HybridFileParcelable[]{rowItem.generateBaseFile()});
+                mainFragment.getMainActivity().setPaste(pasteHelper);
                 return true;
+            }
             case R.id.ex:
                 mainFragment.getMainActivity().mainActivityHelper.extractFile(new File(rowItem.getDesc()));
                 return true;
@@ -118,15 +114,16 @@ public class ItemPopupMenu extends PopupMenu implements PopupMenu.OnMenuItemClic
                 Toast.makeText(mainFragment.getActivity(), mainFragment.getResources().getString(R.string.bookmarksadded), Toast.LENGTH_LONG).show();
                 return true;
             case R.id.delete:
-                ArrayList<LayoutElement> positions = new ArrayList<>();
+                ArrayList<LayoutElementParcelable> positions = new ArrayList<>();
                 positions.add(rowItem);
                 GeneralDialogCreation.deleteFilesDialog(context,
-                        mainFragment.getLayoutElements(),
+                        mainFragment.getElementsList(),
                         mainFragment.getMainActivity(),
                         positions, utilitiesProvider.getAppTheme());
                 return true;
             case R.id.open_with:
-                Futils.openWith(new File(rowItem.getDesc()), mainFragment.getActivity());
+                boolean useNewStack = sharedPrefs.getBoolean(PrefFrag.PREFERENCE_TEXTEDITOR_NEWSTACK, false);
+                FileUtils.openWith(new File(rowItem.getDesc()), mainFragment.getActivity(), useNewStack);
                 return true;
             case R.id.encrypt:
                 final Intent encryptIntent = new Intent(context, EncryptService.class);
@@ -156,18 +153,18 @@ public class ItemPopupMenu extends PopupMenu implements PopupMenu.OnMenuItemClic
                             @Override
                             public void onButtonPressed(Intent intent) throws Exception {
                                 // check if a master password or fingerprint is set
-                                if (!preferences.getString(Preffrag.PREFERENCE_CRYPT_MASTER_PASSWORD,
-                                        Preffrag.PREFERENCE_CRYPT_MASTER_PASSWORD_DEFAULT).equals("")) {
+                                if (!preferences.getString(PrefFrag.PREFERENCE_CRYPT_MASTER_PASSWORD,
+                                        PrefFrag.PREFERENCE_CRYPT_MASTER_PASSWORD_DEFAULT).equals("")) {
 
                                     EncryptDecryptUtils.startEncryption(context,
                                             rowItem.generateBaseFile().getPath(),
-                                            Preffrag.ENCRYPT_PASSWORD_MASTER, encryptIntent);
-                                } else if (preferences.getBoolean(Preffrag.PREFERENCE_CRYPT_FINGERPRINT,
-                                        Preffrag.PREFERENCE_CRYPT_FINGERPRINT_DEFAULT)) {
+                                            PrefFrag.ENCRYPT_PASSWORD_MASTER, encryptIntent);
+                                } else if (preferences.getBoolean(PrefFrag.PREFERENCE_CRYPT_FINGERPRINT,
+                                        PrefFrag.PREFERENCE_CRYPT_FINGERPRINT_DEFAULT)) {
 
                                     EncryptDecryptUtils.startEncryption(context,
                                             rowItem.generateBaseFile().getPath(),
-                                            Preffrag.ENCRYPT_PASSWORD_FINGERPRINT, encryptIntent);
+                                            PrefFrag.ENCRYPT_PASSWORD_FINGERPRINT, encryptIntent);
                                 } else {
                                     // let's ask a password from user
                                     GeneralDialogCreation.showEncryptAuthenticateDialog(context, encryptIntent,
@@ -181,8 +178,8 @@ public class ItemPopupMenu extends PopupMenu implements PopupMenu.OnMenuItemClic
                             }
                         };
 
-                if (preferences.getBoolean(Preffrag.PREFERENCE_CRYPT_WARNING_REMEMBER,
-                        Preffrag.PREFERENCE_CRYPT_WARNING_REMEMBER_DEFAULT)) {
+                if (preferences.getBoolean(PrefFrag.PREFERENCE_CRYPT_WARNING_REMEMBER,
+                        PrefFrag.PREFERENCE_CRYPT_WARNING_REMEMBER_DEFAULT)) {
                     // let's skip warning dialog call
                     try {
                         encryptButtonCallbackInterface.onButtonPressed(encryptIntent);
@@ -201,7 +198,7 @@ public class ItemPopupMenu extends PopupMenu implements PopupMenu.OnMenuItemClic
             case R.id.decrypt:
                 EncryptDecryptUtils.decryptFile(context, mainActivity, mainFragment,
                         mainFragment.openMode, rowItem.generateBaseFile(),
-                        rowItem.generateBaseFile().getParent(context), utilitiesProvider);
+                        rowItem.generateBaseFile().getParent(context), utilitiesProvider, false);
                 return true;
             case R.id.return_select:
                 mainFragment.returnIntentResults(rowItem.generateBaseFile());
diff --git a/app/src/main/java/com/amaze/filemanager/ui/LayoutElement.java b/app/src/main/java/com/amaze/filemanager/ui/LayoutElementParcelable.java
similarity index 76%
rename from app/src/main/java/com/amaze/filemanager/ui/LayoutElement.java
rename to app/src/main/java/com/amaze/filemanager/ui/LayoutElementParcelable.java
index a66a2400e..46d3330af 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/LayoutElement.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/LayoutElementParcelable.java
@@ -19,23 +19,22 @@
 
 package com.amaze.filemanager.ui;
 
-import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
 import android.os.Parcel;
 import android.os.Parcelable;
 
-import com.amaze.filemanager.filesystem.BaseFile;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.utils.OpenMode;
 import com.amaze.filemanager.utils.Utils;
 
 import java.io.File;
 import java.util.Calendar;
 
-public class LayoutElement implements Parcelable {
+public class LayoutElementParcelable implements Parcelable {
 
     private static final String CURRENT_YEAR = String.valueOf(Calendar.getInstance().get(Calendar.YEAR));
 
-    public LayoutElement(Parcel im) {
+    public LayoutElementParcelable(Parcel im) {
         title = im.readString();
         desc = im.readString();
         permissions = im.readString();
@@ -75,7 +74,7 @@ public class LayoutElement implements Parcelable {
         // TODO: Implement this method
     }
 
-    private BitmapDrawable imageId;
+    private Drawable imageId;
     private String title;
     private String desc;
     private String permissions;
@@ -88,8 +87,8 @@ public class LayoutElement implements Parcelable {
     //same as hfile.modes but different than openmode in Main.java
     private OpenMode mode = OpenMode.FILE;
 
-    public LayoutElement(BitmapDrawable imageId, String title, String desc, String permissions,
-                         String symlink, String size, long longSize, boolean header, String date, boolean isDirectory) {
+    public LayoutElementParcelable(Drawable imageId, String title, String desc, String permissions,
+                                   String symlink, String size, long longSize, boolean header, String date, boolean isDirectory) {
         this.imageId = imageId;
         this.title = title;
         this.desc = desc;
@@ -105,20 +104,20 @@ public class LayoutElement implements Parcelable {
         }
     }
 
-    public LayoutElement(BitmapDrawable drawable, String path, String permissions, String symlink,
-                                           String size, long longSize, boolean isDirectory, boolean header,
-                                           String date) {
+    public LayoutElementParcelable(Drawable drawable, String path, String permissions, String symlink,
+                                   String size, long longSize, boolean isDirectory, boolean header,
+                                   String date) {
         this(drawable, new File(path).getName(), path, permissions, symlink, size, longSize, header, date, isDirectory);
     }
 
-    public static final Parcelable.Creator<LayoutElement> CREATOR =
-            new Parcelable.Creator<LayoutElement>() {
-                public LayoutElement createFromParcel(Parcel in) {
-                    return new LayoutElement(in);
+    public static final Parcelable.Creator<LayoutElementParcelable> CREATOR =
+            new Parcelable.Creator<LayoutElementParcelable>() {
+                public LayoutElementParcelable createFromParcel(Parcel in) {
+                    return new LayoutElementParcelable(in);
                 }
 
-                public LayoutElement[] newArray(int size) {
-                    return new LayoutElement[size];
+                public LayoutElementParcelable[] newArray(int size) {
+                    return new LayoutElementParcelable[size];
                 }
             };
 
@@ -126,7 +125,7 @@ public class LayoutElement implements Parcelable {
         return imageId;
     }
 
-    public void setImageId(BitmapDrawable imageId){this.imageId=imageId;}
+    public void setImageId(Drawable imageId){this.imageId=imageId;}
     public String getDesc() {
         return desc;
     }
@@ -148,8 +147,8 @@ public class LayoutElement implements Parcelable {
         return isDirectory;
     }
 
-    public BaseFile generateBaseFile() {
-        BaseFile baseFile=new BaseFile(getDesc(), getPermissions(), getDate1(), getlongSize(), isDirectory());
+    public HybridFileParcelable generateBaseFile() {
+        HybridFileParcelable baseFile=new HybridFileParcelable(getDesc(), getPermissions(), getDate1(), getlongSize(), isDirectory());
         baseFile.setMode(mode);
         baseFile.setName(title);
         return baseFile;
diff --git a/app/src/main/java/com/amaze/filemanager/ui/ZipObj.java b/app/src/main/java/com/amaze/filemanager/ui/ZipObj.java
deleted file mode 100644
index 89e4b215a..000000000
--- a/app/src/main/java/com/amaze/filemanager/ui/ZipObj.java
+++ /dev/null
@@ -1,81 +0,0 @@
-package com.amaze.filemanager.ui;
-
-import android.os.Parcel;
-import android.os.Parcelable;
-
-import java.util.zip.ZipEntry;
-
-/**
- * Created by Arpit on 11-12-2014.
- */
-public class ZipObj implements Parcelable {
-
-    private boolean directory;
-    private ZipEntry entry;
-    private String name;
-    private long date, size;
-
-    public ZipObj(ZipEntry entry, long date, long size, boolean directory) {
-        this.directory = directory;
-        this.entry = entry;
-        if (entry != null) {
-            name = entry.getName();
-            this.date = date;
-            this.size = size;
-
-        }
-    }
-
-    public ZipEntry getEntry() {
-        return entry;
-    }
-
-    public boolean isDirectory() {
-        return directory;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public long getSize() {
-        return size;
-    }
-
-    public long getTime() {
-        return date;
-    }
-
-    @Override
-    public int describeContents() {
-        return 0;
-    }
-
-    public void writeToParcel(Parcel p1, int p2) {
-        p1.writeString(name);
-        p1.writeLong(size);
-        p1.writeLong(date);
-        p1.writeInt(isDirectory() ? 1 : 0);
-    }
-
-    public static final Parcelable.Creator<ZipObj> CREATOR =
-            new Parcelable.Creator<ZipObj>() {
-                public ZipObj createFromParcel(Parcel in) {
-                    return new ZipObj(in);
-                }
-
-                public ZipObj[] newArray(int size) {
-                    return new ZipObj[size];
-                }
-            };
-
-    public ZipObj(Parcel im) {
-        name = im.readString();
-        size = im.readLong();
-        date = im.readLong();
-        int i = im.readInt();
-        directory = i != 0;
-        entry = new ZipEntry(name);
-    }
-
-}
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/GeneralDialogCreation.java b/app/src/main/java/com/amaze/filemanager/ui/dialogs/GeneralDialogCreation.java
index 48444d970..412fd3d34 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/dialogs/GeneralDialogCreation.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/GeneralDialogCreation.java
@@ -1,8 +1,6 @@
 package com.amaze.filemanager.ui.dialogs;
 
-import android.app.Activity;
 import android.content.Context;
-import android.content.DialogInterface;
 import android.content.Intent;
 import android.content.SharedPreferences;
 import android.graphics.Color;
@@ -12,7 +10,6 @@ import android.net.Uri;
 import android.os.AsyncTask;
 import android.os.Build;
 import android.preference.PreferenceManager;
-import android.support.annotation.NonNull;
 import android.support.annotation.RequiresApi;
 import android.support.v7.widget.AppCompatButton;
 import android.support.v7.widget.AppCompatEditText;
@@ -31,29 +28,30 @@ import com.afollestad.materialdialogs.DialogAction;
 import com.afollestad.materialdialogs.MaterialDialog;
 import com.afollestad.materialdialogs.Theme;
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.activities.BaseActivity;
 import com.amaze.filemanager.activities.MainActivity;
+import com.amaze.filemanager.activities.superclasses.BasicActivity;
+import com.amaze.filemanager.activities.superclasses.ThemedActivity;
 import com.amaze.filemanager.adapters.HiddenAdapter;
-import com.amaze.filemanager.exceptions.CryptException;
-import com.amaze.filemanager.exceptions.RootNotPermittedException;
-import com.amaze.filemanager.filesystem.BaseFile;
-import com.amaze.filemanager.filesystem.HFile;
+import com.amaze.filemanager.asynchronous.asynctasks.CountItemsOrAndSizeTask;
+import com.amaze.filemanager.asynchronous.asynctasks.GenerateHashesTask;
+import com.amaze.filemanager.asynchronous.asynctasks.LoadFolderSpaceDataTask;
+import com.amaze.filemanager.exceptions.ShellNotRunningException;
+import com.amaze.filemanager.filesystem.HybridFile;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.RootHelper;
-import com.amaze.filemanager.fragments.AppsList;
+import com.amaze.filemanager.fragments.AppsListFragment;
 import com.amaze.filemanager.fragments.MainFragment;
-import com.amaze.filemanager.fragments.preference_fragments.Preffrag;
-import com.amaze.filemanager.services.asynctasks.CountItemsOrAndSize;
-import com.amaze.filemanager.services.asynctasks.GenerateHashes;
-import com.amaze.filemanager.services.asynctasks.LoadFolderSpaceData;
-import com.amaze.filemanager.ui.LayoutElement;
+import com.amaze.filemanager.fragments.preference_fragments.PrefFrag;
+import com.amaze.filemanager.ui.LayoutElementParcelable;
 import com.amaze.filemanager.utils.DataUtils;
 import com.amaze.filemanager.utils.FingerprintHandler;
 import com.amaze.filemanager.utils.OpenMode;
+import com.amaze.filemanager.utils.RootUtils;
 import com.amaze.filemanager.utils.Utils;
 import com.amaze.filemanager.utils.color.ColorUsage;
 import com.amaze.filemanager.utils.files.CryptUtil;
 import com.amaze.filemanager.utils.files.EncryptDecryptUtils;
-import com.amaze.filemanager.utils.files.Futils;
+import com.amaze.filemanager.utils.files.FileUtils;
 import com.amaze.filemanager.utils.theme.AppTheme;
 import com.github.mikephil.charting.charts.PieChart;
 import com.github.mikephil.charting.components.Legend;
@@ -66,25 +64,15 @@ import com.github.mikephil.charting.utils.ViewPortHandler;
 
 import java.io.File;
 import java.io.IOException;
-import java.security.InvalidAlgorithmParameterException;
-import java.security.InvalidKeyException;
-import java.security.KeyStoreException;
-import java.security.NoSuchAlgorithmException;
-import java.security.NoSuchProviderException;
-import java.security.UnrecoverableEntryException;
-import java.security.cert.CertificateException;
+import java.lang.ref.WeakReference;
+import java.security.GeneralSecurityException;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
-import javax.crypto.BadPaddingException;
-import javax.crypto.IllegalBlockSizeException;
-import javax.crypto.NoSuchPaddingException;
-
-import eu.chainfire.libsuperuser.Shell;
-
-import static com.amaze.filemanager.utils.files.Futils.toHFileArray;
+import static android.os.Build.VERSION_CODES.M;
+import static com.amaze.filemanager.utils.files.FileUtils.toHybridFileArrayList;
 
 /**
  * Here are a lot of function that create material dialogs
@@ -95,53 +83,52 @@ import static com.amaze.filemanager.utils.files.Futils.toHFileArray;
 
 public class GeneralDialogCreation {
 
-    public static MaterialDialog showBasicDialog(Activity m, String fabskin, AppTheme appTheme, String[] texts) {
+    public static MaterialDialog showBasicDialog(BasicActivity m, String[] texts) {
+        int accentColor = m.getColorPreference().getColor(ColorUsage.ACCENT);
         MaterialDialog.Builder a = new MaterialDialog.Builder(m)
                 .content(texts[0])
-                .widgetColor(Color.parseColor(fabskin))
-                .theme(appTheme.getMaterialDialogTheme())
+                .widgetColor(accentColor)
+                .theme(m.getAppTheme().getMaterialDialogTheme())
                 .title(texts[1])
                 .positiveText(texts[2])
-                .positiveColor(Color.parseColor(fabskin))
+                .positiveColor(accentColor)
                 .negativeText(texts[3])
-                .negativeColor(Color.parseColor(fabskin));
+                .negativeColor(accentColor);
         if (texts[4] != (null)) {
-            a.neutralText(texts[4])
-                    .neutralColor(Color.parseColor(fabskin));
+            a.neutralText(texts[4]).neutralColor(accentColor);
         }
         return a.build();
     }
 
     public static MaterialDialog showNameDialog(final MainActivity m, String[] texts) {
+        int accentColor = m.getColorPreference().getColor(ColorUsage.ACCENT);
         MaterialDialog.Builder a = new MaterialDialog.Builder(m);
-        a.input(texts[0], texts[1], false, new
-                MaterialDialog.InputCallback() {
-                    @Override
-                    public void onInput(MaterialDialog materialDialog, CharSequence charSequence) {
-
-                    }
-                });
-        a.widgetColor(Color.parseColor(BaseActivity.accentSkin));
+        a.input(texts[0], texts[1], false,
+                (materialDialog, charSequence) -> {});
+        a.widgetColor(accentColor);
 
         a.theme(m.getAppTheme().getMaterialDialogTheme());
         a.title(texts[2]);
+
         a.positiveText(texts[3]);
-        a.positiveColor(Color.parseColor(BaseActivity.accentSkin));
-        a.neutralText(texts[4]);
-        if (texts[5] != (null)) {
+
+        if(texts[4] != null) {
+            a.neutralText(texts[4]);
+        }
+
+        if (texts[5] != null) {
             a.negativeText(texts[5]);
-            a.negativeColor(Color.parseColor(BaseActivity.accentSkin));
+            a.negativeColor(accentColor);
         }
-        MaterialDialog dialog = a.build();
-        return dialog;
+        return a.build();
     }
 
     @SuppressWarnings("ConstantConditions")
-    public static void deleteFilesDialog(final Context c, final ArrayList<LayoutElement> layoutElements,
-                                         final MainActivity mainActivity, final List<LayoutElement> positions,
+    public static void deleteFilesDialog(final Context c, final ArrayList<LayoutElementParcelable> layoutElements,
+                                         final MainActivity mainActivity, final List<LayoutElementParcelable> positions,
                                          AppTheme appTheme) {
 
-        final ArrayList<BaseFile> itemsToDelete = new ArrayList<>();
+        final ArrayList<HybridFileParcelable> itemsToDelete = new ArrayList<>();
         int accentColor = mainActivity.getColorPreference().getColor(ColorUsage.ACCENT);
 
         // Build dialog with custom view layout and accent color.
@@ -153,12 +140,9 @@ public class GeneralDialogCreation {
                 .positiveText(c.getString(R.string.delete).toUpperCase())
                 .positiveColor(accentColor)
                 .negativeColor(accentColor)
-                .onPositive(new MaterialDialog.SingleButtonCallback() {
-                    @Override
-                    public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
-                        Toast.makeText(c, c.getString(R.string.deleting), Toast.LENGTH_SHORT).show();
-                        mainActivity.mainActivityHelper.deleteFiles(itemsToDelete);
-                    }
+                .onPositive((dialog1, which) -> {
+                    Toast.makeText(c, c.getString(R.string.deleting), Toast.LENGTH_SHORT).show();
+                    mainActivity.mainActivityHelper.deleteFiles(itemsToDelete);
                 })
                 .build();
 
@@ -192,7 +176,7 @@ public class GeneralDialogCreation {
             protected Void doInBackground(Void... params) {
 
                 for (int i = 0; i < positions.size(); i++) {
-                    final LayoutElement layoutElement = positions.get(i);
+                    final LayoutElementParcelable layoutElement = positions.get(i);
                     itemsToDelete.add(layoutElement.generateBaseFile());
 
                     // Build list of directories to delete.
@@ -315,20 +299,20 @@ public class GeneralDialogCreation {
         dialog.show();
     }
 
-    public static void showPropertiesDialogWithPermissions(BaseFile baseFile, final String permissions,
-                                                           BaseActivity activity, boolean isRoot, AppTheme appTheme) {
+    public static void showPropertiesDialogWithPermissions(HybridFileParcelable baseFile, final String permissions,
+                                                           ThemedActivity activity, boolean isRoot, AppTheme appTheme) {
         showPropertiesDialog(baseFile, permissions, activity, isRoot, appTheme, true, false);
     }
 
-    public static void showPropertiesDialogWithoutPermissions(final BaseFile f, BaseActivity activity, AppTheme appTheme) {
+    public static void showPropertiesDialogWithoutPermissions(final HybridFileParcelable f, ThemedActivity activity, AppTheme appTheme) {
         showPropertiesDialog(f, null, activity, false, appTheme, false, false);
     }
-    public static void showPropertiesDialogForStorage(final BaseFile f, BaseActivity activity, AppTheme appTheme) {
+    public static void showPropertiesDialogForStorage(final HybridFileParcelable f, ThemedActivity activity, AppTheme appTheme) {
         showPropertiesDialog(f, null, activity, false, appTheme, false, true);
     }
 
-    private static void showPropertiesDialog(final BaseFile baseFile, final String permissions,
-                                             BaseActivity base, boolean isRoot, AppTheme appTheme,
+    private static void showPropertiesDialog(final HybridFileParcelable baseFile, final String permissions,
+                                             ThemedActivity base, boolean isRoot, AppTheme appTheme,
                                              boolean showPermissions, boolean forStorage) {
         final ExecutorService executor = Executors.newFixedThreadPool(3);
         final Context c = base.getApplicationContext();
@@ -376,49 +360,37 @@ public class GeneralDialogCreation {
             LinearLayout mDateLinearLayout = (LinearLayout) v.findViewById(R.id.properties_dialog_date);
 
             // setting click listeners for long press
-            mNameLinearLayout.setOnLongClickListener(new View.OnLongClickListener() {
-                @Override
-                public boolean onLongClick(View v) {
-                    Futils.copyToClipboard(c, name);
-                    Toast.makeText(c, c.getResources().getString(R.string.name) + " " +
-                            c.getResources().getString(R.string.properties_copied_clipboard), Toast.LENGTH_SHORT).show();
-                    return false;
-                }
+            mNameLinearLayout.setOnLongClickListener(v1 -> {
+                FileUtils.copyToClipboard(c, name);
+                Toast.makeText(c, c.getResources().getString(R.string.name) + " " +
+                        c.getResources().getString(R.string.properties_copied_clipboard), Toast.LENGTH_SHORT).show();
+                return false;
             });
-            mLocationLinearLayout.setOnLongClickListener(new View.OnLongClickListener() {
-                @Override
-                public boolean onLongClick(View v) {
-                    Futils.copyToClipboard(c, parent);
-                    Toast.makeText(c, c.getResources().getString(R.string.location) + " " +
-                            c.getResources().getString(R.string.properties_copied_clipboard), Toast.LENGTH_SHORT).show();
-                    return false;
-                }
+            mLocationLinearLayout.setOnLongClickListener(v12 -> {
+                FileUtils.copyToClipboard(c, parent);
+                Toast.makeText(c, c.getResources().getString(R.string.location) + " " +
+                        c.getResources().getString(R.string.properties_copied_clipboard), Toast.LENGTH_SHORT).show();
+                return false;
             });
-            mSizeLinearLayout.setOnLongClickListener(new View.OnLongClickListener() {
-                @Override
-                public boolean onLongClick(View v) {
-                    Futils.copyToClipboard(c, items);
-                    Toast.makeText(c, c.getResources().getString(R.string.size) + " " +
-                            c.getResources().getString(R.string.properties_copied_clipboard), Toast.LENGTH_SHORT).show();
-                    return false;
-                }
+            mSizeLinearLayout.setOnLongClickListener(v13 -> {
+                FileUtils.copyToClipboard(c, items);
+                Toast.makeText(c, c.getResources().getString(R.string.size) + " " +
+                        c.getResources().getString(R.string.properties_copied_clipboard), Toast.LENGTH_SHORT).show();
+                return false;
             });
-            mDateLinearLayout.setOnLongClickListener(new View.OnLongClickListener() {
-                @Override
-                public boolean onLongClick(View v) {
-                    Futils.copyToClipboard(c, date);
-                    Toast.makeText(c, c.getResources().getString(R.string.date) + " " +
-                            c.getResources().getString(R.string.properties_copied_clipboard), Toast.LENGTH_SHORT).show();
-                    return false;
-                }
+            mDateLinearLayout.setOnLongClickListener(v14 -> {
+                FileUtils.copyToClipboard(c, date);
+                Toast.makeText(c, c.getResources().getString(R.string.date) + " " +
+                        c.getResources().getString(R.string.properties_copied_clipboard), Toast.LENGTH_SHORT).show();
+                return false;
             });
         }
 
-        CountItemsOrAndSize countItemsOrAndSize = new CountItemsOrAndSize(c, itemsText, baseFile, forStorage);
-        countItemsOrAndSize.executeOnExecutor(executor);
+        CountItemsOrAndSizeTask countItemsOrAndSizeTask = new CountItemsOrAndSizeTask(c, itemsText, baseFile, forStorage);
+        countItemsOrAndSizeTask.executeOnExecutor(executor);
 
 
-        GenerateHashes hashGen = new GenerateHashes(baseFile, c, v);
+        GenerateHashesTask hashGen = new GenerateHashesTask(baseFile, c, v);
         hashGen.executeOnExecutor(executor);
 
         /*Chart creation and data loading*/ {
@@ -472,8 +444,8 @@ public class GeneralDialogCreation {
                 chart.setCenterText(new SpannableString(c.getString(R.string.total) + "\n" + totalSpaceFormatted));
                 chart.setData(pieData);
             } else {
-                LoadFolderSpaceData loadFolderSpaceData = new LoadFolderSpaceData(c, appTheme, chart, baseFile);
-                loadFolderSpaceData.executeOnExecutor(executor);
+                LoadFolderSpaceDataTask loadFolderSpaceDataTask = new LoadFolderSpaceDataTask(c, appTheme, chart, baseFile);
+                loadFolderSpaceDataTask.executeOnExecutor(executor);
             }
 
             chart.invalidate();
@@ -488,18 +460,15 @@ public class GeneralDialogCreation {
             final View button = v.findViewById(R.id.set);
             if (isRoot && permissions.length() > 6) {
                 appCompatButton.setVisibility(View.VISIBLE);
-                appCompatButton.setOnClickListener(new View.OnClickListener() {
-                    @Override
-                    public void onClick(View v) {
-                        if (permissionsTable.getVisibility() == View.GONE) {
-                            permissionsTable.setVisibility(View.VISIBLE);
-                            button.setVisibility(View.VISIBLE);
-                            setPermissionsDialog(permissionsTable, button, baseFile, permissions, c,
-                                    main);
-                        } else {
-                            button.setVisibility(View.GONE);
-                            permissionsTable.setVisibility(View.GONE);
-                        }
+                appCompatButton.setOnClickListener(v15 -> {
+                    if (permissionsTable.getVisibility() == View.GONE) {
+                        permissionsTable.setVisibility(View.VISIBLE);
+                        button.setVisibility(View.VISIBLE);
+                        setPermissionsDialog(permissionsTable, button, baseFile, permissions, c,
+                                main);
+                    } else {
+                        button.setVisibility(View.GONE);
+                        permissionsTable.setVisibility(View.GONE);
                     }
                 });
             }
@@ -508,12 +477,7 @@ public class GeneralDialogCreation {
         builder.customView(v, true);
         builder.positiveText(base.getResources().getString(R.string.ok));
         builder.positiveColor(accentColor);
-        builder.dismissListener(new DialogInterface.OnDismissListener() {
-            @Override
-            public void onDismiss(DialogInterface dialog) {
-                executor.shutdown();
-            }
-        });
+        builder.dismissListener(dialog -> executor.shutdown());
 
         MaterialDialog materialDialog = builder.build();
         materialDialog.show();
@@ -572,19 +536,9 @@ public class GeneralDialogCreation {
         builder.negativeText(mainActivity.getResources().getString(R.string.no));
         builder.negativeColor(accentColor);
 
-        builder.onPositive(new MaterialDialog.SingleButtonCallback() {
-            @Override
-            public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
-                mainActivity.deleteConnection(openMode);
-            }
-        });
+        builder.onPositive((dialog, which) -> mainActivity.deleteConnection(openMode));
 
-        builder.onNegative(new MaterialDialog.SingleButtonCallback() {
-            @Override
-            public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
-                dialog.cancel();
-            }
-        });
+        builder.onNegative((dialog, which) -> dialog.cancel());
 
         builder.show();
     }
@@ -603,34 +557,28 @@ public class GeneralDialogCreation {
         builder.positiveText(main.getResources().getString(R.string.warning_confirm));
         builder.positiveColor(accentColor);
 
-        builder.onPositive(new MaterialDialog.SingleButtonCallback() {
-            @Override
-            public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
-                try {
-                    encryptButtonCallbackInterface.onButtonPressed(intent);
-                } catch (Exception e) {
-                    e.printStackTrace();
-
-                    Toast.makeText(main.getActivity(),
-                            main.getResources().getString(R.string.crypt_encryption_fail),
-                            Toast.LENGTH_LONG).show();
-                }
+        builder.onPositive((dialog, which) -> {
+            try {
+                encryptButtonCallbackInterface.onButtonPressed(intent);
+            } catch (Exception e) {
+                e.printStackTrace();
+
+                Toast.makeText(main.getActivity(),
+                        main.getResources().getString(R.string.crypt_encryption_fail),
+                        Toast.LENGTH_LONG).show();
             }
         });
 
-        builder.onNegative(new MaterialDialog.SingleButtonCallback() {
-            @Override
-            public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
-                preferences.edit().putBoolean(Preffrag.PREFERENCE_CRYPT_WARNING_REMEMBER, true).apply();
-                try {
-                    encryptButtonCallbackInterface.onButtonPressed(intent);
-                } catch (Exception e) {
-                    e.printStackTrace();
-
-                    Toast.makeText(main.getActivity(),
-                            main.getResources().getString(R.string.crypt_encryption_fail),
-                            Toast.LENGTH_LONG).show();
-                }
+        builder.onNegative((dialog, which) -> {
+            preferences.edit().putBoolean(PrefFrag.PREFERENCE_CRYPT_WARNING_REMEMBER, true).apply();
+            try {
+                encryptButtonCallbackInterface.onButtonPressed(intent);
+            } catch (Exception e) {
+                e.printStackTrace();
+
+                Toast.makeText(main.getActivity(),
+                        main.getResources().getString(R.string.crypt_encryption_fail),
+                        Toast.LENGTH_LONG).show();
             }
         });
 
@@ -660,42 +608,32 @@ public class GeneralDialogCreation {
         builder.positiveColor(accentColor);
         builder.negativeColor(accentColor);
 
-        builder.onNegative(new MaterialDialog.SingleButtonCallback() {
-            @Override
-            public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
+        builder.onNegative((dialog, which) -> dialog.cancel());
+
+        builder.onPositive((dialog, which) -> {
+            if (TextUtils.isEmpty(passwordEditText.getText()) ||
+                    TextUtils.isEmpty(passwordConfirmEditText.getText())) {
                 dialog.cancel();
+                return;
             }
-        });
-
-        builder.onPositive(new MaterialDialog.SingleButtonCallback() {
 
-            @Override
-            public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
-
-                if (TextUtils.isEmpty(passwordEditText.getText()) ||
-                        TextUtils.isEmpty(passwordConfirmEditText.getText())) {
-                    dialog.cancel();
-                    return;
-                }
-
-                try {
-                    encryptButtonCallbackInterface.onButtonPressed(intent,
-                            passwordEditText.getText().toString());
-                } catch (Exception e) {
-                    e.printStackTrace();
-                    Toast.makeText(c, c.getString(R.string.crypt_encryption_fail), Toast.LENGTH_LONG).show();
-                }
+            try {
+                encryptButtonCallbackInterface.onButtonPressed(intent, passwordEditText.getText().toString());
+            } catch (Exception e) {
+                e.printStackTrace();
+                Toast.makeText(c, c.getString(R.string.crypt_encryption_fail), Toast.LENGTH_LONG).show();
             }
         });
 
         builder.show();
     }
 
-    @RequiresApi(api = Build.VERSION_CODES.M)
+    @RequiresApi(api = M)
     public static void showDecryptFingerprintDialog(final Context c, MainActivity main,
                                                     final Intent intent, AppTheme appTheme,
                                                     final EncryptDecryptUtils.DecryptButtonCallbackInterface
-                                                            decryptButtonCallbackInterface) throws CryptException {
+                                                            decryptButtonCallbackInterface)
+            throws GeneralSecurityException, IOException {
 
         int accentColor = main.getColorPreference().getColor(ColorUsage.ACCENT);
         MaterialDialog.Builder builder = new MaterialDialog.Builder(c);
@@ -711,12 +649,7 @@ public class GeneralDialogCreation {
         builder.theme(appTheme.getMaterialDialogTheme());
 
         final MaterialDialog dialog = builder.show();
-        cancelButton.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                dialog.cancel();
-            }
-        });
+        cancelButton.setOnClickListener(v -> dialog.cancel());
 
         FingerprintManager manager = (FingerprintManager) c.getSystemService(Context.FINGERPRINT_SERVICE);
         FingerprintManager.CryptoObject object = new
@@ -733,34 +666,20 @@ public class GeneralDialogCreation {
         int accentColor = main.getColorPreference().getColor(ColorUsage.ACCENT);
         MaterialDialog.Builder builder = new MaterialDialog.Builder(c);
         builder.title(c.getString(R.string.crypt_decrypt));
-        builder.input(c.getString(R.string.authenticate_password), "", false,
-                new MaterialDialog.InputCallback() {
-                    @Override
-                    public void onInput(@NonNull MaterialDialog dialog, CharSequence input) {
-                    }
-                });
+        builder.input(c.getString(R.string.authenticate_password), "", false, (dialog, input) -> {});
         builder.theme(appTheme.getMaterialDialogTheme());
         builder.positiveText(c.getString(R.string.ok));
         builder.negativeText(c.getString(R.string.cancel));
         builder.positiveColor(accentColor);
         builder.negativeColor(accentColor);
-        builder.onPositive(new MaterialDialog.SingleButtonCallback() {
-            @Override
-            public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
-
-                EditText editText = dialog.getInputEditText();
+        builder.onPositive((dialog, which) -> {
+            EditText editText = dialog.getInputEditText();
 
-                if (editText.getText().toString().equals(password))
-                    decryptButtonCallbackInterface.confirm(intent);
-                else decryptButtonCallbackInterface.failed();
-            }
-        });
-        builder.onNegative(new MaterialDialog.SingleButtonCallback() {
-            @Override
-            public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
-                dialog.cancel();
-            }
+            if (editText.getText().toString().equals(password))
+                decryptButtonCallbackInterface.confirm(intent);
+            else decryptButtonCallbackInterface.failed();
         });
+        builder.onNegative((dialog, which) -> dialog.cancel());
         builder.show();
     }
 
@@ -772,7 +691,7 @@ public class GeneralDialogCreation {
         b.build().show();
     }
 
-    public static void showPackageDialog(final File f, final MainActivity m) {
+    public static void showPackageDialog(final SharedPreferences sharedPrefs, final File f, final MainActivity m) {
         int accentColor = m.getColorPreference().getColor(ColorUsage.ACCENT);
         MaterialDialog.Builder mat = new MaterialDialog.Builder(m);
         mat.title(R.string.packageinstaller).content(R.string.pitext)
@@ -785,7 +704,8 @@ public class GeneralDialogCreation {
                 .callback(new MaterialDialog.ButtonCallback() {
                     @Override
                     public void onPositive(MaterialDialog materialDialog) {
-                        Futils.openunknown(f, m, false);
+                        boolean useNewStack = sharedPrefs.getBoolean(PrefFrag.PREFERENCE_TEXTEDITOR_NEWSTACK, false);
+                        FileUtils.openunknown(f, m, false, useNewStack);
                     }
 
                     @Override
@@ -833,30 +753,21 @@ public class GeneralDialogCreation {
         b.show();
     }
 
-    public static void showCompressDialog(final MainActivity m, final ArrayList<BaseFile> b, final String current) {
+    public static void showCompressDialog(final MainActivity m, final ArrayList<HybridFileParcelable> b, final String current) {
         int accentColor = m.getColorPreference().getColor(ColorUsage.ACCENT);
         MaterialDialog.Builder a = new MaterialDialog.Builder(m);
-        a.input(m.getResources().getString(R.string.enterzipname), ".zip", false, new
-                MaterialDialog.InputCallback() {
-                    @Override
-                    public void onInput(MaterialDialog materialDialog, CharSequence charSequence) {
-
-                    }
-                });
+        a.input(m.getResources().getString(R.string.enterzipname), ".zip", false, (materialDialog, charSequence) -> {});
         a.widgetColor(accentColor);
         a.theme(m.getAppTheme().getMaterialDialogTheme());
         a.title(m.getResources().getString(R.string.enterzipname));
         a.positiveText(R.string.create);
         a.positiveColor(accentColor);
-        a.onPositive(new MaterialDialog.SingleButtonCallback() {
-            @Override
-            public void onClick(MaterialDialog materialDialog, DialogAction dialogAction) {
-                if (materialDialog.getInputEditText().getText().toString().equals(".zip"))
-                    Toast.makeText(m, m.getResources().getString(R.string.no_name), Toast.LENGTH_SHORT).show();
-                else {
-                    String name = current + "/" + materialDialog.getInputEditText().getText().toString();
-                    m.mainActivityHelper.compressFiles(new File(name), b);
-                }
+        a.onPositive((materialDialog, dialogAction) -> {
+            if (materialDialog.getInputEditText().getText().toString().equals(".zip"))
+                Toast.makeText(m, m.getResources().getString(R.string.no_name), Toast.LENGTH_SHORT).show();
+            else {
+                String name = current + "/" + materialDialog.getInputEditText().getText().toString();
+                m.mainActivityHelper.compressFiles(new File(name), b);
             }
         });
         a.negativeText(m.getResources().getString(R.string.cancel));
@@ -867,12 +778,7 @@ public class GeneralDialogCreation {
         // place cursor at the starting of edit text by posting a runnable to edit text
         // this is done because in case android has not populated the edit text layouts yet, it'll
         // reset calls to selection if not posted in message queue
-        materialDialog.getInputEditText().post(new Runnable() {
-            @Override
-            public void run() {
-                materialDialog.getInputEditText().setSelection(0);
-            }
-        });
+        materialDialog.getInputEditText().post(() -> materialDialog.getInputEditText().setSelection(0));
     }
 
     public static void showSortDialog(final MainFragment m, AppTheme appTheme, final SharedPreferences sharedPref) {
@@ -881,74 +787,49 @@ public class GeneralDialogCreation {
         int current = Integer.parseInt(sharedPref.getString("sortby", "0"));
         MaterialDialog.Builder a = new MaterialDialog.Builder(m.getActivity());
         a.theme(appTheme.getMaterialDialogTheme());
-        a.items(sort).itemsCallbackSingleChoice(current > 3 ? current - 4 : current, new MaterialDialog.ListCallbackSingleChoice() {
-            @Override
-            public boolean onSelection(MaterialDialog dialog, View view, int which, CharSequence text) {
-
-                return true;
-            }
-        });
-
+        a.items(sort).itemsCallbackSingleChoice(current > 3 ? current - 4 : current,
+                (dialog, view, which, text) -> true);
         a.negativeText(R.string.ascending).positiveColor(accentColor);
         a.positiveText(R.string.descending).negativeColor(accentColor);
-        a.onNegative(new MaterialDialog.SingleButtonCallback() {
-            @Override
-            public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
-                sharedPref.edit().putString("sortby", "" + dialog.getSelectedIndex()).commit();
-                m.getSortModes();
-                m.updateList();
-                dialog.dismiss();
-            }
+        a.onNegative((dialog, which) -> {
+            sharedPref.edit().putString("sortby", "" + dialog.getSelectedIndex()).commit();
+            m.getSortModes();
+            m.updateList();
+            dialog.dismiss();
         });
 
-        a.onPositive(new MaterialDialog.SingleButtonCallback() {
-            @Override
-            public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
-                sharedPref.edit().putString("sortby", "" + (dialog.getSelectedIndex() + 4)).commit();
-                m.getSortModes();
-                m.updateList();
-                dialog.dismiss();
-            }
+        a.onPositive((dialog, which) -> {
+            sharedPref.edit().putString("sortby", "" + (dialog.getSelectedIndex() + 4)).commit();
+            m.getSortModes();
+            m.updateList();
+            dialog.dismiss();
         });
         a.title(R.string.sortby);
         a.build().show();
     }
 
-    public static void showSortDialog(final AppsList m, AppTheme appTheme) {
-        int accentColor = ((BaseActivity) m.getActivity()).getColorPreference().getColor(ColorUsage.ACCENT);
+    public static void showSortDialog(final AppsListFragment m, AppTheme appTheme) {
+        int accentColor = ((ThemedActivity) m.getActivity()).getColorPreference().getColor(ColorUsage.ACCENT);
         String[] sort = m.getResources().getStringArray(R.array.sortbyApps);
         int current = Integer.parseInt(m.Sp.getString("sortbyApps", "0"));
         MaterialDialog.Builder a = new MaterialDialog.Builder(m.getActivity());
         a.theme(appTheme.getMaterialDialogTheme());
-        a.items(sort).itemsCallbackSingleChoice(current > 2 ? current - 3 : current, new MaterialDialog.ListCallbackSingleChoice() {
-            @Override
-            public boolean onSelection(MaterialDialog dialog, View view, int which, CharSequence text) {
-
-                return true;
-            }
-        });
+        a.items(sort).itemsCallbackSingleChoice(current > 2 ? current - 3 : current,
+                (dialog, view, which, text) -> true);
         a.negativeText(R.string.ascending).positiveColor(accentColor);
         a.positiveText(R.string.descending).negativeColor(accentColor);
-        a.onNegative(new MaterialDialog.SingleButtonCallback() {
-            @Override
-            public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
-
-                m.Sp.edit().putString("sortbyApps", "" + dialog.getSelectedIndex()).commit();
-                m.getSortModes();
-                m.getLoaderManager().restartLoader(AppsList.ID_LOADER_APP_LIST, null, m);
-                dialog.dismiss();
-            }
+        a.onNegative((dialog, which) -> {
+            m.Sp.edit().putString("sortbyApps", "" + dialog.getSelectedIndex()).commit();
+            m.getSortModes();
+            m.getLoaderManager().restartLoader(AppsListFragment.ID_LOADER_APP_LIST, null, m);
+            dialog.dismiss();
         });
 
-        a.onPositive(new MaterialDialog.SingleButtonCallback() {
-            @Override
-            public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
-
-                m.Sp.edit().putString("sortbyApps", "" + (dialog.getSelectedIndex() + 3)).commit();
-                m.getSortModes();
-                m.getLoaderManager().restartLoader(AppsList.ID_LOADER_APP_LIST, null, m);
-                dialog.dismiss();
-            }
+        a.onPositive((dialog, which) -> {
+            m.Sp.edit().putString("sortbyApps", "" + (dialog.getSelectedIndex() + 3)).commit();
+            m.getSortModes();
+            m.getLoaderManager().restartLoader(AppsListFragment.ID_LOADER_APP_LIST, null, m);
+            dialog.dismiss();
         });
 
         a.title(R.string.sortby);
@@ -956,7 +837,8 @@ public class GeneralDialogCreation {
     }
 
 
-    public static void showHistoryDialog(final DataUtils dataUtils, Futils utils, final MainFragment m, AppTheme appTheme) {
+    public static void showHistoryDialog(final DataUtils dataUtils, SharedPreferences sharedPrefs,
+                                         final MainFragment m, AppTheme appTheme) {
         int accentColor = m.getMainActivity().getColorPreference().getColor(ColorUsage.ACCENT);
         final MaterialDialog.Builder a = new MaterialDialog.Builder(m.getActivity());
         a.positiveText(R.string.cancel);
@@ -964,17 +846,12 @@ public class GeneralDialogCreation {
         a.negativeText(R.string.clear);
         a.negativeColor(accentColor);
         a.title(R.string.history);
-        a.onNegative(new MaterialDialog.SingleButtonCallback() {
-            @Override
-            public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
-                dataUtils.clearHistory();
-            }
-        });
+        a.onNegative((dialog, which) -> dataUtils.clearHistory());
         a.theme(appTheme.getMaterialDialogTheme());
 
         a.autoDismiss(true);
-        HiddenAdapter adapter = new HiddenAdapter(m.getActivity(), m, utils, R.layout.bookmarkrow,
-                toHFileArray(dataUtils.getHistory()), null, true);
+        HiddenAdapter adapter = new HiddenAdapter(m.getActivity(), m, sharedPrefs,
+                toHybridFileArrayList(dataUtils.getHistory()), null, true);
         a.adapter(adapter, null);
 
         MaterialDialog x= a.build();
@@ -982,7 +859,8 @@ public class GeneralDialogCreation {
         x.show();
     }
 
-    public static void showHiddenDialog(DataUtils dataUtils, Futils utils, final MainFragment m, AppTheme appTheme) {
+    public static void showHiddenDialog(DataUtils dataUtils, SharedPreferences sharedPrefs,
+                                        final MainFragment m, AppTheme appTheme) {
         int accentColor = m.getMainActivity().getColorPreference().getColor(ColorUsage.ACCENT);
         final MaterialDialog.Builder a = new MaterialDialog.Builder(m.getActivity());
         a.positiveText(R.string.cancel);
@@ -990,8 +868,8 @@ public class GeneralDialogCreation {
         a.title(R.string.hiddenfiles);
         a.theme(appTheme.getMaterialDialogTheme());
         a.autoDismiss(true);
-        HiddenAdapter adapter = new HiddenAdapter(m.getActivity(), m, utils, R.layout.bookmarkrow,
-                toHFileArray(dataUtils.getHiddenfiles()), null, false);
+        HiddenAdapter adapter = new HiddenAdapter(m.getActivity(), m, sharedPrefs,
+                FileUtils.toHybridFileConcurrentRadixTree(dataUtils.getHiddenFiles()), null, false);
         a.adapter(adapter, null);
         a.dividerColor(Color.GRAY);
         MaterialDialog x= a.build();
@@ -1000,7 +878,7 @@ public class GeneralDialogCreation {
 
     }
 
-    public static void setPermissionsDialog(final View v, View but, final HFile file,
+    public static void setPermissionsDialog(final View v, View but, final HybridFile file,
                                      final String f, final Context context, final MainFragment mainFrag) {
         final CheckBox readown = (CheckBox) v.findViewById(R.id.creadown);
         final CheckBox readgroup = (CheckBox) v.findViewById(R.id.creadgroup);
@@ -1018,7 +896,7 @@ public class GeneralDialogCreation {
             Toast.makeText(context, R.string.not_allowed, Toast.LENGTH_SHORT).show();
             return;
         }
-        ArrayList<Boolean[]> arrayList = Futils.parse(perm);
+        ArrayList<Boolean[]> arrayList = FileUtils.parse(perm);
         Boolean[] read = arrayList.get(0);
         Boolean[] write = arrayList.get(1);
         final Boolean[] exe = arrayList.get(2);
@@ -1031,54 +909,65 @@ public class GeneralDialogCreation {
         exeown.setChecked(exe[0]);
         exegroup.setChecked(exe[1]);
         exeother.setChecked(exe[2]);
-        but.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                int a = 0, b = 0, c = 0;
-                if (readown.isChecked()) a = 4;
-                if (writeown.isChecked()) b = 2;
-                if (exeown.isChecked()) c = 1;
-                int owner = a + b + c;
-                int d = 0;
-                int e = 0;
-                int f = 0;
-                if (readgroup.isChecked()) d = 4;
-                if (writegroup.isChecked()) e = 2;
-                if (exegroup.isChecked()) f = 1;
-                int group = d + e + f;
-                int g = 0, h = 0, i = 0;
-                if (readother.isChecked()) g = 4;
-                if (writeother.isChecked()) h = 2;
-                if (exeother.isChecked()) i = 1;
-                int other = g + h + i;
-                String finalValue = owner + "" + group + "" + other;
-
-                String command = "chmod " + finalValue + " " + file.getPath();
-                if (file.isDirectory())
-                    command = "chmod -R " + finalValue + " \"" + file.getPath() + "\"";
-
-                try {
-                    RootHelper.runShellCommand(command, new Shell.OnCommandResultListener() {
-                        @Override
-                        public void onCommandResult(int commandCode, int exitCode, List<String> output) {
-                            if (exitCode < 0) {
-                                Toast.makeText(context, mainFrag.getString(R.string.operationunsuccesful),
-                                        Toast.LENGTH_LONG).show();
-                            } else {
-                                Toast.makeText(context,
-                                        mainFrag.getResources().getString(R.string.done), Toast.LENGTH_LONG).show();
-                            }
-                        }
-                    });
-                    mainFrag.updateList();
-                } catch (RootNotPermittedException e1) {
-                    Toast.makeText(context, mainFrag.getResources().getString(R.string.rootfailure),
-                            Toast.LENGTH_LONG).show();
-                    e1.printStackTrace();
-                }
-
+        but.setOnClickListener(v1 -> {
+            int perms = RootUtils.permissionsToOctalString(readown.isChecked(), writeown.isChecked(), exeown.isChecked(),
+                                                                    readgroup.isChecked(), writegroup.isChecked(), exegroup.isChecked(),
+                                                                    readother.isChecked(), writeother.isChecked(), exeother.isChecked());
+
+            String options =  !file.isDirectory(context)? "-R":"";
+            String command = String.format(RootUtils.CHMOD_COMMAND, options, perms, file.getPath());
+
+            try {
+                RootHelper.runShellCommand(command, (commandCode, exitCode, output) -> {
+                    if (exitCode < 0) {
+                        Toast.makeText(context, mainFrag.getString(R.string.operationunsuccesful),
+                                Toast.LENGTH_LONG).show();
+                    } else {
+                        Toast.makeText(context,
+                                mainFrag.getResources().getString(R.string.done), Toast.LENGTH_LONG).show();
+                    }
+                });
+                mainFrag.updateList();
+            } catch (ShellNotRunningException e1) {
+                Toast.makeText(context, mainFrag.getResources().getString(R.string.rootfailure),
+                        Toast.LENGTH_LONG).show();
+                e1.printStackTrace();
             }
+
+        });
+    }
+
+    public static void showChangePathsDialog(final WeakReference<MainActivity> m, final SharedPreferences prefs) {
+        final MaterialDialog.Builder a = new MaterialDialog.Builder(m.get());
+        a.input(null, m.get().getCurrentMainFragment().getCurrentPath(), false,
+                (dialog, charSequence) -> {
+                    boolean isAccessible = FileUtils.isPathAccesible(charSequence.toString(), prefs);
+                    dialog.getActionButton(DialogAction.POSITIVE).setEnabled(isAccessible);
+                });
+
+        a.alwaysCallInputCallback();
+
+        MainActivity mainActivity = m.get();
+
+        int accentColor = mainActivity.getColorPreference().getColor(ColorUsage.ACCENT);
+
+        a.widgetColor(accentColor);
+
+        a.theme(m.get().getAppTheme().getMaterialDialogTheme());
+        a.title(R.string.enterpath);
+
+        a.positiveText(R.string.go);
+        a.positiveColor(accentColor);
+
+        a.negativeText(R.string.cancel);
+        a.negativeColor(accentColor);
+
+        a.onPositive((dialog, which) -> {
+            m.get().getCurrentMainFragment().loadlist(dialog.getInputEditText().getText().toString(),
+                    false, OpenMode.UNKNOWN);
         });
+
+        a.show();
     }
 
 }
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/RenameBookmark.java b/app/src/main/java/com/amaze/filemanager/ui/dialogs/RenameBookmark.java
index 4376d2295..a0f7fe4d2 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/dialogs/RenameBookmark.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/RenameBookmark.java
@@ -4,10 +4,8 @@ import android.app.Dialog;
 import android.app.DialogFragment;
 import android.content.Context;
 import android.content.SharedPreferences;
-import android.graphics.Color;
 import android.os.Bundle;
 import android.preference.PreferenceManager;
-import android.support.annotation.NonNull;
 import android.support.design.widget.TextInputLayout;
 import android.support.v7.widget.AppCompatEditText;
 import android.text.Editable;
@@ -37,12 +35,12 @@ public class RenameBookmark extends DialogFragment {
     private int studiomode = 0;
     private DataUtils dataUtils = DataUtils.getInstance();
 
-    public static RenameBookmark getInstance(String name, String path, String fabskin) {
+    public static RenameBookmark getInstance(String name, String path, int accentColor) {
         RenameBookmark renameBookmark = new RenameBookmark();
         Bundle bundle = new Bundle();
         bundle.putString("title", name);
         bundle.putString("path", path);
-        bundle.putString("fabskin", fabskin);
+        bundle.putInt("accentColor", accentColor);
 
         renameBookmark.setArguments(bundle);
         return renameBookmark;
@@ -60,7 +58,7 @@ public class RenameBookmark extends DialogFragment {
             bookmarkCallback = (BookmarkCallback) getActivity();
         title = getArguments().getString("title");
         path = getArguments().getString("path");
-        String fabskin = getArguments().getString("fabskin");
+        int accentColor = getArguments().getInt("accentColor");
         SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(c);
 
         studiomode = sp.getInt("studio", 0);
@@ -69,9 +67,9 @@ public class RenameBookmark extends DialogFragment {
             String pa = path;
             MaterialDialog.Builder builder = new MaterialDialog.Builder(c);
             builder.title(R.string.renamebookmark);
-            builder.positiveColor(Color.parseColor(fabskin));
-            builder.negativeColor(Color.parseColor(fabskin));
-            builder.neutralColor(Color.parseColor(fabskin));
+            builder.positiveColor(accentColor);
+            builder.negativeColor(accentColor);
+            builder.neutralColor(accentColor);
             builder.positiveText(R.string.save);
             builder.neutralText(R.string.cancel);
             builder.negativeText(R.string.delete);
@@ -79,9 +77,9 @@ public class RenameBookmark extends DialogFragment {
             builder.autoDismiss(false);
             View v2 = getActivity().getLayoutInflater().inflate(R.layout.rename, null);
             builder.customView(v2, true);
-            final TextInputLayout t1 = (TextInputLayout) v2.findViewById(R.id.t1);
-            final TextInputLayout t2 = (TextInputLayout) v2.findViewById(R.id.t2);
-            final AppCompatEditText conName = (AppCompatEditText) v2.findViewById(R.id.editText4);
+            final TextInputLayout t1 = v2.findViewById(R.id.t1);
+            final TextInputLayout t2 = v2.findViewById(R.id.t2);
+            final AppCompatEditText conName = v2.findViewById(R.id.editText4);
             conName.setText(title);
             final String s1 = String.format(getString(R.string.cantbeempty), c.getResources().getString(R.string.name));
             final String s2 = String.format(getString(R.string.cantbeempty), c.getResources().getString(R.string.path));
@@ -93,7 +91,7 @@ public class RenameBookmark extends DialogFragment {
                     else t1.setError("");
                 }
             });
-            final AppCompatEditText ip = (AppCompatEditText) v2.findViewById(R.id.editText);
+            final AppCompatEditText ip = v2.findViewById(R.id.editText);
             if (studiomode != 0) {
                 if (path.startsWith("smb:/")) {
                     try {
@@ -121,57 +119,46 @@ public class RenameBookmark extends DialogFragment {
                 });
             } else t2.setVisibility(View.GONE);
             ip.setText(pa);
-            builder.onNeutral(new MaterialDialog.SingleButtonCallback() {
-                @Override
-                public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
-                    dialog.dismiss();
-                }
-            });
+            builder.onNeutral((dialog, which) -> dialog.dismiss());
 
             materialDialog = builder.build();
-            materialDialog.getActionButton(DialogAction.POSITIVE).setOnClickListener(new View.OnClickListener() {
-                @Override
-                public void onClick(View v) {
-                    String t = ip.getText().toString();
-                    String name = conName.getText().toString();
-                    if (studiomode != 0 && t.startsWith("smb://")) {
-                        try {
-                            URL a = new URL(t);
-                            String userinfo = a.getUserInfo();
-                            if (userinfo == null && user.length() > 0) {
-                                t = "smb://" + ((URLEncoder.encode(user, "UTF-8") + ":" + URLEncoder.encode(pass, "UTF-8") + "@")) + a.getHost() + a.getPath();
-                            }
-                        } catch (Exception e) {
-                            e.printStackTrace();
-                        }
-                    }
-                    int i = -1;
-                    if ((i = dataUtils.containsBooks(new String[]{title, path})) != -1) {
-                        if (!t.equals(title) && t.length() >= 1) {
-                            dataUtils.removeBook(i);
-                            dataUtils.addBook(new String[]{name, t});
-                            dataUtils.sortBook();
-                            if (bookmarkCallback != null) {
-                                bookmarkCallback.modify(path, title, t, name);
-                            }
+            materialDialog.getActionButton(DialogAction.POSITIVE).setOnClickListener(v -> {
+                String t = ip.getText().toString();
+                String name = conName.getText().toString();
+                if (studiomode != 0 && t.startsWith("smb://")) {
+                    try {
+                        URL a = new URL(t);
+                        String userinfo = a.getUserInfo();
+                        if (userinfo == null && user.length() > 0) {
+                            t = "smb://" + ((URLEncoder.encode(user, "UTF-8") + ":" + URLEncoder.encode(pass, "UTF-8") + "@")) + a.getHost() + a.getPath();
                         }
+                    } catch (Exception e) {
+                        e.printStackTrace();
                     }
-                    materialDialog.dismiss();
-
                 }
-            });
-            materialDialog.getActionButton(DialogAction.NEGATIVE).setOnClickListener(new View.OnClickListener() {
-                @Override
-                public void onClick(View v) {
-                    int i;
-                    if ((i = dataUtils.containsBooks(new String[]{title, path})) != -1) {
+                int i = -1;
+                if ((i = dataUtils.containsBooks(new String[]{title, path})) != -1) {
+                    if (!t.equals(title) && t.length() >= 1) {
                         dataUtils.removeBook(i);
+                        dataUtils.addBook(new String[]{name, t});
+                        dataUtils.sortBook();
                         if (bookmarkCallback != null) {
-                            bookmarkCallback.delete(title, path);
+                            bookmarkCallback.modify(path, title, t, name);
                         }
                     }
-                    materialDialog.dismiss();
                 }
+                materialDialog.dismiss();
+
+            });
+            materialDialog.getActionButton(DialogAction.NEGATIVE).setOnClickListener(v -> {
+                int i;
+                if ((i = dataUtils.containsBooks(new String[]{title, path})) != -1) {
+                    dataUtils.removeBook(i);
+                    if (bookmarkCallback != null) {
+                        bookmarkCallback.delete(title, path);
+                    }
+                }
+                materialDialog.dismiss();
             });
             return materialDialog;
         }
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/SmbConnectDialog.java b/app/src/main/java/com/amaze/filemanager/ui/dialogs/SmbConnectDialog.java
index e90aea4ad..f0cd8f1f3 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/dialogs/SmbConnectDialog.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/SmbConnectDialog.java
@@ -9,7 +9,6 @@ import android.graphics.Color;
 import android.os.Build;
 import android.os.Bundle;
 import android.preference.PreferenceManager;
-import android.support.annotation.NonNull;
 import android.support.design.widget.TextInputLayout;
 import android.support.v7.widget.AppCompatCheckBox;
 import android.support.v7.widget.AppCompatEditText;
@@ -19,28 +18,23 @@ import android.widget.EditText;
 import android.widget.TextView;
 import android.widget.Toast;
 
-import com.afollestad.materialdialogs.DialogAction;
 import com.afollestad.materialdialogs.MaterialDialog;
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.activities.BaseActivity;
-import com.amaze.filemanager.database.UtilsHandler;
-import com.amaze.filemanager.exceptions.CryptException;
-import com.amaze.filemanager.filesystem.HFile;
+import com.amaze.filemanager.activities.superclasses.ThemedActivity;
 import com.amaze.filemanager.utils.EditTextColorStateUtil;
-import com.amaze.filemanager.utils.OpenMode;
 import com.amaze.filemanager.utils.SimpleTextWatcher;
 import com.amaze.filemanager.utils.SmbUtil;
 import com.amaze.filemanager.utils.Utils;
 import com.amaze.filemanager.utils.color.ColorUsage;
-import com.amaze.filemanager.utils.files.CryptUtil;
 import com.amaze.filemanager.utils.provider.UtilitiesProviderInterface;
 
+import java.io.IOException;
 import java.io.UnsupportedEncodingException;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.net.URLDecoder;
 import java.net.URLEncoder;
-import java.util.ArrayList;
+import java.security.GeneralSecurityException;
 
 import jcifs.smb.SmbFile;
 
@@ -164,25 +158,19 @@ public class SmbConnectDialog extends DialogFragment {
         EditTextColorStateUtil.setTint(context, pass, accentColor);
 
         Utils.setTint(context, ch, accentColor);
-        help.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                int accentColor = ((BaseActivity) getActivity()).getColorPreference().getColor(ColorUsage.ACCENT);
-                GeneralDialogCreation.showSMBHelpDialog(context, accentColor);
-            }
+        help.setOnClickListener(v -> {
+            int accentColor1 = ((ThemedActivity) getActivity()).getColorPreference().getColor(ColorUsage.ACCENT);
+            GeneralDialogCreation.showSMBHelpDialog(context, accentColor1);
         });
 
-        ch.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                if (ch.isChecked()) {
-                    user.setEnabled(false);
-                    pass.setEnabled(false);
-                } else {
-                    user.setEnabled(true);
-                    pass.setEnabled(true);
+        ch.setOnClickListener(view -> {
+            if (ch.isChecked()) {
+                user.setEnabled(false);
+                pass.setEnabled(false);
+            } else {
+                user.setEnabled(true);
+                pass.setEnabled(true);
 
-                }
             }
         });
 
@@ -228,88 +216,76 @@ public class SmbConnectDialog extends DialogFragment {
         ba3.positiveText(R.string.create);
         if (edit) ba3.negativeText(R.string.delete);
         ba3.positiveColor(accentColor).negativeColor(accentColor).neutralColor(accentColor);
-        ba3.onPositive(new MaterialDialog.SingleButtonCallback() {
-            @Override
-            public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
-                String s[];
-                String ipa = ip.getText().toString();
-                String con_nam=conName.getText().toString();
-                String sDomain = domain.getText().toString();
-                String username = user.getText().toString();
-                TextInputLayout firstInvalidField  = null;
-                if(con_nam==null || con_nam.length()==0){
-                    connectionTIL.setError(emptyName);
-                    firstInvalidField = connectionTIL;
-                }
-                if(ipa==null || ipa.length()==0){
-                    ipTIL.setError(emptyAddress);
-                    if(firstInvalidField == null)
-                        firstInvalidField = ipTIL;
-                }
-                if(sDomain.contains(";"))
-                {
-                    domainTIL.setError(invalidDomain);
-                    if(firstInvalidField == null)
-                        firstInvalidField = domainTIL;
-                }
-                if(username.contains(":"))
-                {
-                    usernameTIL.setError(invalidUsername);
-                    if(firstInvalidField == null)
-                        firstInvalidField = usernameTIL;
-                }
-                if(firstInvalidField != null)
-                {
-                    firstInvalidField.requestFocus();
-                    return;
-                }
-                SmbFile smbFile;
-                String domaind = domain.getText().toString();
-                if (ch.isChecked())
-                    smbFile = createSMBPath(new String[]{ipa, "", "",domaind}, true);
-                else {
-                    String useraw = user.getText().toString();
-                    String useru = useraw.replaceAll(" ", "\\ ");
-                    String passp = pass.getText().toString();
-                    smbFile = createSMBPath(new String[]{ipa, useru, passp,domaind}, false);
-                }
+        ba3.onPositive((dialog, which) -> {
+            String s[];
+            String ipa = ip.getText().toString();
+            String con_nam=conName.getText().toString();
+            String sDomain = domain.getText().toString();
+            String username = user.getText().toString();
+            TextInputLayout firstInvalidField  = null;
+            if(con_nam==null || con_nam.length()==0){
+                connectionTIL.setError(emptyName);
+                firstInvalidField = connectionTIL;
+            }
+            if(ipa==null || ipa.length()==0){
+                ipTIL.setError(emptyAddress);
+                if(firstInvalidField == null)
+                    firstInvalidField = ipTIL;
+            }
+            if(sDomain.contains(";"))
+            {
+                domainTIL.setError(invalidDomain);
+                if(firstInvalidField == null)
+                    firstInvalidField = domainTIL;
+            }
+            if(username.contains(":"))
+            {
+                usernameTIL.setError(invalidUsername);
+                if(firstInvalidField == null)
+                    firstInvalidField = usernameTIL;
+            }
+            if(firstInvalidField != null)
+            {
+                firstInvalidField.requestFocus();
+                return;
+            }
+            SmbFile smbFile;
+            String domaind = domain.getText().toString();
+            if (ch.isChecked())
+                smbFile = createSMBPath(new String[]{ipa, "", "",domaind}, true);
+            else {
+                String useraw = user.getText().toString();
+                String useru = useraw.replaceAll(" ", "\\ ");
+                String passp = pass.getText().toString();
+                smbFile = createSMBPath(new String[]{ipa, useru, passp,domaind}, false);
+            }
 
-                if (smbFile == null)
-                    return;
+            if (smbFile == null)
+                return;
 
-                try {
-                    s = new String[]{conName.getText().toString(), SmbUtil.getSmbEncryptedPath(getActivity(),
+            try {
+                s = new String[]{conName.getText().toString(), SmbUtil.getSmbEncryptedPath(getActivity(),
                             smbFile.getPath())};
-                } catch (CryptException e) {
-                    e.printStackTrace();
-                    Toast.makeText(getActivity(), getResources().getString(R.string.error), Toast.LENGTH_LONG).show();
-                    return;
-                }
-
-                if(smbConnectionListener!=null) {
-                    // encrypted path means path with encrypted pass
-                    smbConnectionListener.addConnection(edit, s[0], smbFile.getPath(), s[1], name, path);
-                }
-                dismiss();
+            } catch (GeneralSecurityException | IOException e) {
+                e.printStackTrace();
+                Toast.makeText(getActivity(), getResources().getString(R.string.error), Toast.LENGTH_LONG).show();
+                return;
             }
-        });
-        ba3.onNegative(new MaterialDialog.SingleButtonCallback() {
-            @Override
-            public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
-
-                if(smbConnectionListener!=null){
-                    smbConnectionListener.deleteConnection(name, path);
-                }
 
-                dismiss();
+            if(smbConnectionListener!=null) {
+                // encrypted path means path with encrypted pass
+                smbConnectionListener.addConnection(edit, s[0], smbFile.getPath(), s[1], name, path);
             }
+            dismiss();
         });
-        ba3.onNeutral(new MaterialDialog.SingleButtonCallback() {
-            @Override
-            public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
-                dismiss();
+        ba3.onNegative((dialog, which) -> {
+            if(smbConnectionListener!=null){
+                smbConnectionListener.deleteConnection(name, path);
             }
+
+            dismiss();
         });
+        ba3.onNeutral((dialog, which) -> dismiss());
 
         return ba3.build();
     }
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/SmbSearchDialog.java b/app/src/main/java/com/amaze/filemanager/ui/dialogs/SmbSearchDialog.java
index 76ae82c70..febe3d71c 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/dialogs/SmbSearchDialog.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/SmbSearchDialog.java
@@ -6,24 +6,19 @@ import android.app.DialogFragment;
 import android.content.Context;
 import android.graphics.Color;
 import android.os.Bundle;
-import android.support.annotation.LayoutRes;
-import android.support.annotation.NonNull;
 import android.support.v7.widget.RecyclerView;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.ImageView;
-import android.widget.ProgressBar;
 import android.widget.TextView;
 import android.widget.Toast;
 
-import com.afollestad.materialdialogs.DialogAction;
 import com.afollestad.materialdialogs.MaterialDialog;
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.activities.BaseActivity;
 import com.amaze.filemanager.activities.MainActivity;
-import com.amaze.filemanager.adapters.RecyclerArrayAdapter;
-import com.amaze.filemanager.utils.Computer;
+import com.amaze.filemanager.activities.superclasses.ThemedActivity;
+import com.amaze.filemanager.utils.ComputerParcelable;
 import com.amaze.filemanager.utils.SubnetScanner;
 import com.amaze.filemanager.utils.color.ColorUsage;
 import com.amaze.filemanager.utils.provider.UtilitiesProviderInterface;
@@ -33,22 +28,22 @@ import java.util.ArrayList;
 import java.util.List;
 
 /**
- * Created by arpitkh996 on 16-01-2016.
+ * Created by arpitkh996 on 16-01-2016 edited by Emmanuel Messulam <emmanuelbendavid@gmail.com>
  */
 public class SmbSearchDialog extends DialogFragment {
     private UtilitiesProviderInterface utilsProvider;
 
-    listViewAdapter listViewAdapter;
-    ArrayList<Computer> computers = new ArrayList<>();
-    int accentColor;
-    SubnetScanner subnetScanner;
+    private ListViewAdapter listViewAdapter;
+    private ArrayList<ComputerParcelable> computers = new ArrayList<>();
+    private int accentColor;
+    private SubnetScanner subnetScanner;
 
     @Override
     public void onCreate(Bundle bundle) {
         super.onCreate(bundle);
         utilsProvider = (UtilitiesProviderInterface) getActivity();
 
-        accentColor = ((BaseActivity) getActivity()).getColorPreference().getColor(ColorUsage.ACCENT);
+        accentColor = ((ThemedActivity) getActivity()).getColorPreference().getColor(ColorUsage.ACCENT);
     }
 
     @Override
@@ -64,61 +59,49 @@ public class SmbSearchDialog extends DialogFragment {
         builder.title(R.string.searchingdevices);
         builder.negativeColor(accentColor);
         builder.negativeText(R.string.cancel);
-        builder.onNegative(new MaterialDialog.SingleButtonCallback() {
-            @Override
-            public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
-                if (subnetScanner != null)
-                    subnetScanner.interrupt();
-                dismiss();
-            }
+        builder.onNegative((dialog, which) -> {
+            if (subnetScanner != null)
+                subnetScanner.interrupt();
+            dismiss();
         });
-        builder.onPositive(new MaterialDialog.SingleButtonCallback() {
-            @Override
-            public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
-                if (subnetScanner != null)
-                    subnetScanner.interrupt();
-                if (getActivity() != null && getActivity() instanceof MainActivity) {
-                    dismiss();
-                    MainActivity mainActivity = (MainActivity) getActivity();
-                    mainActivity.showSMBDialog("", "", false);
-                }
+        builder.onPositive((dialog, which) -> {
+            if (subnetScanner != null)
+                subnetScanner.interrupt();
+            if (getActivity() != null && getActivity() instanceof MainActivity) {
+                dismiss();
+                MainActivity mainActivity = (MainActivity) getActivity();
+                mainActivity.showSMBDialog("", "", false);
             }
         });
         builder.positiveText(R.string.use_custom_ip);
         builder.positiveColor(accentColor);
-        computers.add(new Computer("-1", "-1"));
-        listViewAdapter = new listViewAdapter(getActivity(), R.layout.smb_computers_row, computers);
+        computers.add(new ComputerParcelable("-1", "-1"));
+        listViewAdapter = new ListViewAdapter(getActivity(), computers);
         subnetScanner = new SubnetScanner(getActivity());
         subnetScanner.setObserver(new SubnetScanner.ScanObserver() {
             @Override
-            public void computerFound(final Computer computer) {
+            public void computerFound(final ComputerParcelable computer) {
                 if (getActivity() != null)
-                    getActivity().runOnUiThread(new Runnable() {
-                        @Override
-                        public void run() {
-                            if (!computers.contains(computer))
-                                computers.add(computer);
-                            listViewAdapter.notifyDataSetChanged();
-                        }
+                    getActivity().runOnUiThread(() -> {
+                        if (!computers.contains(computer))
+                            computers.add(computer);
+                        listViewAdapter.notifyDataSetChanged();
                     });
             }
 
             @Override
             public void searchFinished() {
                 if (getActivity() != null) {
-                    getActivity().runOnUiThread(new Runnable() {
-                        @Override
-                        public void run() {
-                            if (computers.size() == 1) {
-                                dismiss();
-                                Toast.makeText(getActivity(), getResources().getString(R.string.nodevicefound), Toast.LENGTH_SHORT).show();
-                                MainActivity mainActivity = (MainActivity) getActivity();
-                                mainActivity.showSMBDialog("", "", false);
-                                return;
-                            }
-                            computers.remove(computers.size() - 1);
-                            listViewAdapter.notifyDataSetChanged();
+                    getActivity().runOnUiThread(() -> {
+                        if (computers.size() == 1) {
+                            dismiss();
+                            Toast.makeText(getActivity(), getResources().getString(R.string.nodevicefound), Toast.LENGTH_SHORT).show();
+                            MainActivity mainActivity = (MainActivity) getActivity();
+                            mainActivity.showSMBDialog("", "", false);
+                            return;
                         }
+                        computers.remove(computers.size() - 1);
+                        listViewAdapter.notifyDataSetChanged();
                     });
                 }
             }
@@ -129,95 +112,65 @@ public class SmbSearchDialog extends DialogFragment {
         return builder.build();
     }
 
-    private class listViewAdapter extends RecyclerArrayAdapter<Computer, listViewAdapter.ViewHolder> {
+    private class ListViewAdapter extends RecyclerView.Adapter<ElementViewHolder> {
         private static final int VIEW_PROGRESSBAR = 1;
         private static final int VIEW_ELEMENT = 2;
 
-        LayoutInflater mInflater;
-        Context context;
+        private ArrayList<ComputerParcelable> items;
+        private LayoutInflater mInflater;
+        private Context context;
 
-        public listViewAdapter(Context context, @LayoutRes int resource, List<Computer> objects) {
+        public ListViewAdapter(Context context, List<ComputerParcelable> objects) {
             this.context = context;
-            addAll(objects);
+            items = new ArrayList<>(objects);
             mInflater = (LayoutInflater) context
-                    .getSystemService(Activity.LAYOUT_INFLATER_SERVICE);
+                .getSystemService(Activity.LAYOUT_INFLATER_SERVICE);
         }
 
         @Override
-        public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+        public ElementViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+            View view;
             switch (viewType) {
                 case VIEW_PROGRESSBAR:
-                    ProgressBar progressBar = new ProgressBar(context, null, android.R.attr.progressBarStyle);
-                    progressBar.setIndeterminate(true);
-                    progressBar.setBackgroundDrawable(null);
-
-                    return new ViewHolder(progressBar);
+                    view = mInflater.inflate(R.layout.smb_progress_row, parent, false);
+                    return new ElementViewHolder(view);
                 default:
                 case VIEW_ELEMENT:
-                    View view = mInflater.inflate(R.layout.smb_computers_row, parent, false);
-
+                    view = mInflater.inflate(R.layout.smb_computers_row, parent, false);
                     return new ElementViewHolder(view);
             }
         }
 
         @Override
-        public void onBindViewHolder(ViewHolder holder, int position) {
-            holder.render(position, getItem(position));
-        }
-
-        class ViewHolder extends RecyclerView.ViewHolder {
-            ViewHolder(View itemView) {
-                super(itemView);
+        public void onBindViewHolder(ElementViewHolder holder, int position) {
+            int viewType = getItemViewType(position);
+            if (viewType == VIEW_PROGRESSBAR) {
+                return;
             }
 
-            public void render(final int p, Computer f) {
-
-            }
-        }
-
-        class ElementViewHolder extends ViewHolder {
-            private View rootView;
-
-            private ImageView image;
-            private TextView txtTitle;
-            private TextView txtDesc;
-
-            ElementViewHolder(View view) {
-                super(view);
+            ComputerParcelable f = items.get(position);
 
-                rootView = view;
-
-                txtTitle = (TextView) view.findViewById(R.id.firstline);
-                image = (ImageView) view.findViewById(R.id.icon);
-                txtDesc = (TextView) view.findViewById(R.id.secondLine);
-            }
+            holder.rootView.setOnClickListener(v -> {
+                if (subnetScanner != null)
+                    subnetScanner.interrupt();
+                if (getActivity() != null && getActivity() instanceof MainActivity) {
+                    dismiss();
+                    MainActivity mainActivity = (MainActivity) getActivity();
+                    mainActivity.showSMBDialog(listViewAdapter.items.get(position).name,
+                        listViewAdapter.items.get(position).addr, false);
+                }
+            });
 
-            @Override
-            public void render(final int p, Computer f) {
-                rootView.setOnClickListener(new View.OnClickListener() {
-                    @Override
-                    public void onClick(View v) {
-                        if (subnetScanner != null)
-                            subnetScanner.interrupt();
-                        if (getActivity() != null && getActivity() instanceof MainActivity) {
-                            dismiss();
-                            MainActivity mainActivity = (MainActivity) getActivity();
-                            mainActivity.showSMBDialog(listViewAdapter.getItem(p).name, listViewAdapter.getItem(p).addr, false);
-                        }
-                    }
-                });
-
-                txtTitle.setText(f.name);
-                image.setImageResource(R.drawable.ic_settings_remote_white_48dp);
-                if (utilsProvider.getAppTheme().equals(AppTheme.LIGHT))
-                    image.setColorFilter(Color.parseColor("#666666"));
-                txtDesc.setText(f.addr);
-            }
+            holder.txtTitle.setText(f.name);
+            holder.image.setImageResource(R.drawable.ic_settings_remote_white_48dp);
+            if (utilsProvider.getAppTheme().equals(AppTheme.LIGHT))
+                holder.image.setColorFilter(Color.parseColor("#666666"));
+            holder.txtDesc.setText(f.addr);
         }
 
         @Override
         public int getItemViewType(int position) {
-            Computer f = getItem(position);
+            ComputerParcelable f = items.get(position);
             if (f.addr.equals("-1")) {
                 return VIEW_PROGRESSBAR;
             } else {
@@ -225,6 +178,35 @@ public class SmbSearchDialog extends DialogFragment {
             }
         }
 
+        @Override
+        public long getItemId(int position) {
+            return position;
+        }
+
+        @Override
+        public int getItemCount() {
+            return items.size();
+        }
+
+    }
+
+    private static class ElementViewHolder extends RecyclerView.ViewHolder {
+        private View rootView;
+
+        private ImageView image;
+        private TextView txtTitle;
+        private TextView txtDesc;
+
+        ElementViewHolder(View view) {
+            super(view);
+
+            rootView = view;
+
+            txtTitle = (TextView) view.findViewById(R.id.firstline);
+            image = (ImageView) view.findViewById(R.id.icon);
+            txtDesc = (TextView) view.findViewById(R.id.secondLine);
+        }
+
     }
 
 }
\ No newline at end of file
diff --git a/app/src/main/java/com/amaze/filemanager/ui/icons/IconHolder.java b/app/src/main/java/com/amaze/filemanager/ui/icons/IconHolder.java
index 2cf86cc49..be9db792c 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/icons/IconHolder.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/icons/IconHolder.java
@@ -29,7 +29,6 @@ import android.graphics.BitmapFactory;
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
 import android.media.ThumbnailUtils;
-import android.os.Build;
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.Looper;
@@ -41,16 +40,16 @@ import android.widget.ImageView;
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.database.CloudHandler;
 import com.amaze.filemanager.utils.DataUtils;
-import com.amaze.filemanager.utils.cloud.CloudUtil;
 import com.amaze.filemanager.utils.OTGUtil;
 import com.amaze.filemanager.utils.OpenMode;
 import com.amaze.filemanager.utils.Utils;
+import com.amaze.filemanager.utils.cloud.CloudUtil;
 import com.cloudrail.si.interfaces.CloudStorage;
 
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.Map;
-import java.util.Objects;
 
 import jcifs.smb.SmbFileInputStream;
 
@@ -69,7 +68,7 @@ public class IconHolder {
     private final Map<String, Bitmap> mAppIcons;  // App based
     private DataUtils dataUtils = DataUtils.getInstance();
 
-    private Map<ImageView, String> mRequests;
+    private final Map<ImageView, String> mRequests;
 
     private final Context mContext;
     private final boolean mUseThumbs;
@@ -98,21 +97,19 @@ public class IconHolder {
         private synchronized void processResult(LoadResult result) {
             // Cache the new drawable
             final String filePath =(result.fso);
-            mAppIcons.put(filePath, result.result);
+
+            synchronized (mAppIcons) {
+
+                mAppIcons.put(filePath, result.result);
+            }
 
             // find the request for it
-            for (Map.Entry<ImageView, String> entry : mRequests.entrySet()) {
-                final ImageView imageView = entry.getKey();
-                final String fso = entry.getValue();
-                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
-                    if (Objects.equals(fso, result.fso)) {
-                        imageView.setImageBitmap(result.result);
-                        mRequests.remove(imageView);
-                        break;
-                    }
-                } else {
-                    if (fso.equals(result.fso)) {
+            synchronized (mRequests) {
+                for (Map.Entry<ImageView, String> entry : mRequests.entrySet()) {
+                    final ImageView imageView = entry.getKey();
+                    final String fso = entry.getValue();
 
+                    if (fso != null && fso.equals(result.fso)) {
                         imageView.setImageBitmap(result.result);
                         mRequests.remove(imageView);
                         break;
@@ -133,12 +130,12 @@ public class IconHolder {
         super();
         this.mContext = context;
         this.mUseThumbs = useThumbs;
-        this.mRequests = new HashMap<>();
+        this.mRequests = Collections.synchronizedMap(new HashMap<>());
         this.mIcons = new HashMap<>();
         this.mAppIcons = new LinkedHashMap<String, Bitmap>(MAX_CACHE, .75F, true) {
             private static final long serialVersionUID = 1L;
             @Override
-            protected boolean removeEldestEntry(Entry<String, Bitmap> eldest) {
+            protected boolean removeEldestEntry(Map.Entry<String, Bitmap> eldest) {
                 return size() > MAX_CACHE;
             }
         };
@@ -175,22 +172,18 @@ public class IconHolder {
             iconView.setImageBitmap(this.mAppIcons.get(filePath));
             return;
         }
-        new Thread(new Runnable() {
-            @Override
-            public void run() {
-
-                mHandler.removeMessages(MSG_DESTROY);
-                if (mWorkerThread == null || mWorkerHandler==null) {
-                    mWorkerThread = new HandlerThread("IconHolderLoader");
-                    mWorkerThread.start();
-                    mWorkerHandler = new WorkerHandler(mWorkerThread.getLooper());
-                }
+        new Thread(() -> {
+            mHandler.removeMessages(MSG_DESTROY);
+            if (mWorkerThread == null || mWorkerHandler==null) {
+                mWorkerThread = new HandlerThread("IconHolderLoader");
+                mWorkerThread.start();
+                mWorkerHandler = new WorkerHandler(mWorkerThread.getLooper());
+            }
 
-                mRequests.put(iconView, fso);
-                Message msg = mWorkerHandler.obtainMessage(MSG_LOAD, fso);
-                msg.sendToTarget();
+            mRequests.put(iconView, fso);
+            Message msg = mWorkerHandler.obtainMessage(MSG_LOAD, fso);
+            msg.sendToTarget();
 
-            }
         }).start();
     }
 
@@ -198,11 +191,13 @@ public class IconHolder {
      * Cancel loading of a drawable for a certain ImageView.
      */
     public void cancelLoad(ImageView view) {
-        String fso = mRequests.get(view);
-        if (fso != null && mWorkerHandler != null) {
-            mWorkerHandler.removeMessages(MSG_LOAD, fso);
+        synchronized (mRequests) {
+            String fso = mRequests.get(view);
+            if (fso != null && mWorkerHandler != null) {
+                mWorkerHandler.removeMessages(MSG_LOAD, fso);
+            }
+            mRequests.remove(view);
         }
-        mRequests.remove(view);
     }
 
     private class WorkerHandler extends Handler {
diff --git a/app/src/main/java/com/amaze/filemanager/ui/icons/IconUtils.java b/app/src/main/java/com/amaze/filemanager/ui/icons/IconUtils.java
deleted file mode 100644
index 5bd95634e..000000000
--- a/app/src/main/java/com/amaze/filemanager/ui/icons/IconUtils.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (C) 2014 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>
- *
- * This file is part of Amaze File Manager.
- *
- * Amaze File Manager is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.amaze.filemanager.ui.icons;
-
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.graphics.drawable.Drawable;
-
-import com.amaze.filemanager.R;
-import com.amaze.filemanager.utils.PreferenceUtils;
-
-public class IconUtils {
-    private int LIGHT = 0, DARK = 1, CURRENT, rand;
-    private Context c;
-
-    public IconUtils(SharedPreferences sharedPrefs, Context c) {
-        rand = Integer.parseInt(sharedPrefs.getString("theme", "0"));
-        CURRENT = rand==2 ? PreferenceUtils.hourOfDay() : rand;
-        this.c = c;
-    }
-
-    public Drawable getCopyDrawable() {
-        return c.getResources().getDrawable(R.drawable.ic_content_copy_white_36dp);
-    }
-
-    public Drawable getCutDrawable() {
-            return c.getResources().getDrawable(R.drawable.ic_content_cut_white_36dp);
-    }
-    public Drawable getRootDrawable() {
-        if (CURRENT == LIGHT)
-            return c.getResources().getDrawable(R.drawable.root);
-        else
-            return c.getResources().getDrawable(R.drawable.root);
-    }
-    public Drawable getSdDrawable() {
-        if (CURRENT == LIGHT)
-            return c.getResources().getDrawable(R.drawable.ic_sd_storage_white_56dp);
-        else
-            return c.getResources().getDrawable(R.drawable.ic_sd_storage_white_56dp);
-    }
-
-}
diff --git a/app/src/main/java/com/amaze/filemanager/ui/icons/Icons.java b/app/src/main/java/com/amaze/filemanager/ui/icons/Icons.java
index 4765261ee..5eff39855 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/icons/Icons.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/icons/Icons.java
@@ -20,9 +20,7 @@
 package com.amaze.filemanager.ui.icons;
 
 import android.content.res.Resources;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
 import android.util.SparseArray;
 
 import com.amaze.filemanager.R;
@@ -38,7 +36,7 @@ public class Icons {
 
     // construct a with an approximation of the capacity
     private static HashMap<String, Integer> sMimeIconIds = new HashMap<>(1 + (int)(114 / 0.75));
-    private static SparseArray<Bitmap> sMimeIcons = new SparseArray<>();
+    private static SparseArray<Drawable> sMimeIcons = new SparseArray<>();
 
     private static void add(String mimeType, int resId) {
         if (sMimeIconIds.put(mimeType, resId) != null) {
@@ -331,7 +329,7 @@ public class Icons {
         else return -1;
     }
 
-    public static BitmapDrawable loadMimeIcon(String path, boolean grid, final Resources res) {
+    public static Drawable loadMimeIcon(String path, boolean grid, final Resources res) {
         String mimeType = MimeTypes.getMimeType(new File(path));
         if (mimeType == null) {
             /* if(grid) return loadBitmapDrawableById(res, R.drawable.ic_doc_generic_am_grid);*/
@@ -396,12 +394,12 @@ public class Icons {
         return loadBitmapDrawableById(res, resId);
     }
 
-    private static BitmapDrawable loadBitmapDrawableById(Resources res, int resId) {
-        Bitmap bitmap = sMimeIcons.get(resId);
-        if (bitmap == null) {
-            bitmap = BitmapFactory.decodeResource(res, resId);
-            sMimeIcons.put(resId, bitmap);
+    private static Drawable loadBitmapDrawableById(Resources res, int resId) {
+        Drawable drawable = sMimeIcons.get(resId);
+        if (drawable == null) {
+            drawable = res.getDrawable(resId);
+            sMimeIcons.put(resId, drawable);
         }
-        return new BitmapDrawable(res, bitmap);
+        return drawable;
     }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/ui/notifications/FTPNotification.java b/app/src/main/java/com/amaze/filemanager/ui/notifications/FTPNotification.java
index e3893dd4d..ee92cfe3e 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/notifications/FTPNotification.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/notifications/FTPNotification.java
@@ -12,7 +12,7 @@ import android.preference.PreferenceManager;
 
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.MainActivity;
-import com.amaze.filemanager.services.ftpservice.FTPService;
+import com.amaze.filemanager.asynchronous.ftpservice.FTPService;
 
 import java.net.InetAddress;
 
@@ -27,7 +27,7 @@ public class FTPNotification extends BroadcastReceiver {
     public void onReceive(Context context, Intent intent) {
         switch(intent.getAction()){
             case FTPService.ACTION_STARTED:
-                createNotification(context);
+                createNotification(context, intent.getBooleanExtra(FTPService.TAG_STARTED_BY_TILE, false));
                 break;
             case FTPService.ACTION_STOPPED:
                 removeNotification(context);
@@ -36,7 +36,7 @@ public class FTPNotification extends BroadcastReceiver {
     }
 
     @SuppressWarnings("NewApi")
-    private void createNotification(Context context) {
+    private void createNotification(Context context, boolean noStopButton) {
 
         String notificationService = Context.NOTIFICATION_SERVICE;
         NotificationManager notificationManager = (NotificationManager) context.getSystemService(notificationService);
@@ -63,14 +63,7 @@ public class FTPNotification extends BroadcastReceiver {
         notificationIntent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_SINGLE_TOP);
         PendingIntent contentIntent = PendingIntent.getActivity(context, 0, notificationIntent, 0);
 
-        int stopIcon = android.R.drawable.ic_menu_close_clear_cancel;
-        CharSequence stopText = context.getResources().getString(R.string.ftp_notif_stop_server);
-        Intent stopIntent = new Intent(FTPService.ACTION_STOP_FTPSERVER);
-        PendingIntent stopPendingIntent = PendingIntent.getBroadcast(context, 0,
-                stopIntent, PendingIntent.FLAG_ONE_SHOT);
-
-
-        Notification.Builder notificationBuilder = new Notification.Builder(context)
+        Notification.Builder notificationBuilder = new Notification.Builder(context, NotificationConstants.CHANNEL_NORMAL_ID)
                 .setContentTitle(contentTitle)
                 .setContentText(contentText)
                 .setContentIntent(contentIntent)
@@ -79,15 +72,19 @@ public class FTPNotification extends BroadcastReceiver {
                 .setWhen(when)
                 .setOngoing(true);
 
-        Notification notification = null;
-
-
+        Notification notification;
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
             notificationBuilder.setVisibility(Notification.VISIBILITY_PUBLIC);
             notificationBuilder.setCategory(Notification.CATEGORY_SERVICE);
             notificationBuilder.setPriority(Notification.PRIORITY_MAX);
         }
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
+        if (!noStopButton && Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
+            int stopIcon = android.R.drawable.ic_menu_close_clear_cancel;
+            CharSequence stopText = context.getResources().getString(R.string.ftp_notif_stop_server);
+            Intent stopIntent = new Intent(FTPService.ACTION_STOP_FTPSERVER);
+            PendingIntent stopPendingIntent = PendingIntent.getBroadcast(context, 0,
+                    stopIntent, PendingIntent.FLAG_ONE_SHOT);
+
             notificationBuilder.addAction(stopIcon, stopText, stopPendingIntent);
             notificationBuilder.setShowWhen(false);
             notification = notificationBuilder.build();
diff --git a/app/src/main/java/com/amaze/filemanager/ui/notifications/NotificationConstants.java b/app/src/main/java/com/amaze/filemanager/ui/notifications/NotificationConstants.java
new file mode 100644
index 000000000..8166368e8
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/ui/notifications/NotificationConstants.java
@@ -0,0 +1,54 @@
+package com.amaze.filemanager.ui.notifications;
+
+import android.app.Notification;
+import android.app.NotificationChannel;
+import android.app.NotificationManager;
+import android.content.Context;
+import android.os.Build;
+import android.support.annotation.RequiresApi;
+import android.support.v4.app.NotificationCompat;
+
+import com.amaze.filemanager.R;
+
+/**
+ * @author Emmanuel
+ *         on 17/9/2017, at 13:34.
+ */
+
+public class NotificationConstants {
+
+    public static final String CHANNEL_NORMAL_ID = "normalChannel";
+
+    /**
+     * This creates a channel (API >= 26) or applies the correct metadata to a notification (API < 26)
+     */
+    public static void setMetadata(Context context, NotificationCompat.Builder notification) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+            createNormalChannel(context);
+        } else {
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+                notification.setCategory(Notification.CATEGORY_SERVICE);
+            }
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
+                notification.setPriority(Notification.PRIORITY_MIN);
+            }
+        }
+    }
+
+    /**
+     * You CANNOT call this from android < O.
+     * THis channel is set so it doesn't bother the user, with the lowest importance.
+     */
+    @RequiresApi(api = Build.VERSION_CODES.O)
+    private static void createNormalChannel(Context context) {
+        NotificationManager mNotificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
+        if(mNotificationManager.getNotificationChannel(CHANNEL_NORMAL_ID) == null) {
+            NotificationChannel mChannel = new NotificationChannel(CHANNEL_NORMAL_ID,
+                    context.getString(R.string.channelname_normal), NotificationManager.IMPORTANCE_MIN);
+            // Configure the notification channel.
+            mChannel.setDescription(context.getString(R.string.channeldescription_normal));
+            mNotificationManager.createNotificationChannel(mChannel);
+        }
+    }
+
+}
diff --git a/app/src/main/java/com/amaze/filemanager/ui/views/CustomNestedScrollView.java b/app/src/main/java/com/amaze/filemanager/ui/views/CustomNestedScrollView.java
deleted file mode 100644
index d13142ba2..000000000
--- a/app/src/main/java/com/amaze/filemanager/ui/views/CustomNestedScrollView.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package com.amaze.filemanager.ui.views;
-
-import android.content.Context;
-import android.support.v4.widget.NestedScrollView;
-import android.util.AttributeSet;
-import android.view.MotionEvent;
-
-/**
- * Created by vishal on 19/12/16.
- */
-
-public class CustomNestedScrollView extends NestedScrollView {
-
-    public CustomNestedScrollView(Context context, AttributeSet attrs, int defStyleAttr) {
-        super(context, attrs, defStyleAttr);
-    }
-
-    @Override
-    protected void onOverScrolled(int scrollX, int scrollY, boolean clampedX, boolean clampedY) {
-        super.onOverScrolled(scrollX, scrollY, clampedX, clampedY);
-    }
-
-    @Override
-    public boolean onInterceptTouchEvent(MotionEvent ev) {
-        return super.onInterceptTouchEvent(ev);
-    }
-}
diff --git a/app/src/main/java/com/amaze/filemanager/ui/views/CustomViewPager.java b/app/src/main/java/com/amaze/filemanager/ui/views/CustomViewPager.java
deleted file mode 100644
index 6606a9ec5..000000000
--- a/app/src/main/java/com/amaze/filemanager/ui/views/CustomViewPager.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package com.amaze.filemanager.ui.views;
-
-import android.content.Context;
-import android.graphics.Rect;
-import android.support.v4.view.ViewPager;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.view.MotionEvent;
-
-/**
- * Created by Arpit on 16-01-2015.
- */
-public class CustomViewPager extends ViewPager {
-
-    private boolean enabled;
-
-    public CustomViewPager(Context context, AttributeSet attrs) {
-        super(context, attrs);
-        this.enabled = true;
-    }
-
-    @Override
-    public boolean onTouchEvent(MotionEvent event) {
-        if (this.enabled) {
-            return super.onTouchEvent(event);
-        }
-
-        return false;
-    }
-
-    @Override
-    public boolean onInterceptTouchEvent(MotionEvent event) {
-        if (this.enabled) {
-            return super.onInterceptTouchEvent(event);
-        }
-
-        return false;
-    }
-
-    public void setPagingEnabled(boolean enabled) {
-        this.enabled = enabled;
-    } }
diff --git a/app/src/main/java/com/amaze/filemanager/ui/views/FastScroller.java b/app/src/main/java/com/amaze/filemanager/ui/views/FastScroller.java
index db500e798..22c291e24 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/views/FastScroller.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/views/FastScroller.java
@@ -67,7 +67,7 @@ public class FastScroller extends FrameLayout {
     private void initialise(@NonNull Context context) {
         setClipChildren(false);
         inflate(context, R.layout.fastscroller, this);
-        this.handle = (ImageView) findViewById(R.id.scroll_handle);
+        this.handle = findViewById(R.id.scroll_handle);
         this.bar = findViewById(R.id.scroll_bar);
         this.handle.setEnabled(true);
         setPressedHandleColor(Utils.getColor(getContext(), R.color.accent_blue));
diff --git a/app/src/main/java/com/amaze/filemanager/ui/views/SizeDrawable.java b/app/src/main/java/com/amaze/filemanager/ui/views/SizeDrawable.java
deleted file mode 100644
index c20538295..000000000
--- a/app/src/main/java/com/amaze/filemanager/ui/views/SizeDrawable.java
+++ /dev/null
@@ -1,105 +0,0 @@
-package com.amaze.filemanager.ui.views;
-
-import android.content.Context;
-import android.graphics.Canvas;
-import android.graphics.Paint;
-import android.graphics.RectF;
-import android.util.AttributeSet;
-import android.util.DisplayMetrics;
-import android.view.View;
-
-import com.amaze.filemanager.R;
-import com.amaze.filemanager.utils.Utils;
-
-/**
- * Created by Arpit on 30-07-2015.
- */
-public class SizeDrawable extends View {
-    Paint mPaint, mPaint1, mPaint2;
-    RectF rectF;
-    float startangle = -90, startangle1 = -90, startangle2 = -90,
-            angle = 0, angle1 = 0, angle2 = 0;
-
-
-    public SizeDrawable(Context context) {
-        super(context);
-    }
-
-    int twenty;
-
-    public SizeDrawable(Context context, AttributeSet attributeSet) {
-        super(context, attributeSet);
-        int strokeWidth = dpToPx(40);
-        rectF = new RectF(getLeft(), getTop(), getRight(), getBottom());
-        //rectF = new RectF(dpToPx(0), dpToPx(0), dpToPx(200), dpToPx(200));
-        mPaint = new Paint();
-        mPaint.setAntiAlias(true);
-        mPaint.setStyle(Paint.Style.FILL);
-        mPaint.setColor(Utils.getColor(context, R.color.accent_indigo));
-        // mPaint.setStrokeCap(Paint.Cap.BUTT);
-        mPaint.setStrokeWidth(strokeWidth);
-        mPaint1 = new Paint();
-        mPaint1.setAntiAlias(true);
-        mPaint1.setStyle(Paint.Style.FILL);
-        mPaint1.setColor(Utils.getColor(context, R.color.accent_red));
-        //  mPaint1.setStrokeCap(Paint.Cap.BUTT);
-        mPaint1.setStrokeWidth(strokeWidth);
-        mPaint2 = new Paint();
-        mPaint2.setAntiAlias(true);
-        mPaint2.setStyle(Paint.Style.FILL);
-        mPaint2.setColor(Utils.getColor(context, R.color.accent_green));
-        // mPaint2.setStrokeCap(Paint.Cap.BUTT);
-        mPaint2.setStrokeWidth(strokeWidth);
-        twenty = dpToPx(10);
-    }
-
-
-    DisplayMetrics displayMetrics;
-
-    public int dpToPx(int dp) {
-        if (displayMetrics == null) displayMetrics = getResources().getDisplayMetrics();
-        int px = Math.round(dp * (displayMetrics.xdpi / DisplayMetrics.DENSITY_DEFAULT));
-        return px;
-    }
-
-    @Override
-    protected void onDraw(Canvas canvas) {
-        super.onDraw(canvas);
-
-        // canvas.drawLine((getWidth() - twenty)-2,0,(getWidth() - twenty),0,mPaint1);
-        if (angle2 != 0)
-            canvas.drawLine(0, getHeight() - (getHeight() * angle1), 0, getHeight() - (getHeight() * angle2), mPaint2);
-        canvas.drawLine(0, getHeight(), 0, getHeight() - (getHeight() * angle), mPaint);
-        if (angle1 != 0)
-            canvas.drawLine(0, getHeight() - (getHeight() * angle), 0, getHeight() - (getHeight() * angle1), mPaint1);
-       /* Paint paint = new Paint();
-        paint.setColor(Color.WHITE);
-        paint.setStyle(Paint.Style.STROKE);
-        paint.setTextSize(20);
-        canvas.drawText(Math.round(angle * 100)+"%",(getWidth() - twenty)*angle/2, 25,paint);
-        if(angle1>0.20)canvas.drawText(Math.round((angle1-angle)*100)+"%",(getWidth() - twenty)*angle+(getWidth() - twenty)*(angle1-angle)/2, 25,paint);
-        if(angle2>0.20)canvas.drawText(Math.round((angle2-angle1)*100)+"%",(getWidth() - twenty)*angle1+(getWidth() - twenty)*(angle2-angle1)/2, 25,paint);
-
-
-        canvas.drawArc(rectF, startangle, angle, true, mPaint);
-        canvas.drawArc(rectF, startangle1, angle1, true, mPaint1);
-        canvas.drawArc(rectF, startangle2, angle2, true, mPaint2);
-*/
-    }
-
-    public void setAngle(float angle, float startangle) {
-        this.angle = angle;
-        this.startangle = startangle;
-    }
-
-    public void setAngle1(float angle, float startangle1) {
-        this.angle1 = angle;
-        this.startangle1 = startangle1;
-    }
-
-    public void setAngle2(float angle2, float startangle2) {
-        this.angle2 = angle2;
-        this.startangle2 = startangle2;
-    }
-
-}
diff --git a/app/src/main/java/com/amaze/filemanager/ui/views/ThemedImageView.java b/app/src/main/java/com/amaze/filemanager/ui/views/ThemedImageView.java
index c99a4381f..1bd8caeaf 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/views/ThemedImageView.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/views/ThemedImageView.java
@@ -6,7 +6,7 @@ import android.content.ContextWrapper;
 import android.graphics.Color;
 import android.util.AttributeSet;
 
-import com.amaze.filemanager.activities.BasicActivity;
+import com.amaze.filemanager.activities.superclasses.BasicActivity;
 import com.amaze.filemanager.utils.theme.AppTheme;
 
 /**
diff --git a/app/src/main/java/com/amaze/filemanager/ui/views/appbar/AppBar.java b/app/src/main/java/com/amaze/filemanager/ui/views/appbar/AppBar.java
new file mode 100644
index 000000000..a48c417ac
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/ui/views/appbar/AppBar.java
@@ -0,0 +1,75 @@
+package com.amaze.filemanager.ui.views.appbar;
+
+import android.content.SharedPreferences;
+import android.support.annotation.StringRes;
+import android.support.design.widget.AppBarLayout;
+import android.support.v7.widget.Toolbar;
+
+import com.amaze.filemanager.R;
+import com.amaze.filemanager.activities.MainActivity;
+
+import static android.os.Build.VERSION.SDK_INT;
+
+/**
+ * layout_appbar.xml contains the layout for AppBar and BottomBar
+ *
+ * This is a class containing containing methods to each section of the AppBar,
+ * creating the object loads the views.
+ *
+ * @author Emmanuel
+ *         on 2/8/2017, at 23:27.
+ */
+
+public class AppBar {
+
+    private int TOOLBAR_START_INSET;
+
+    private Toolbar toolbar;
+    private SearchView searchView;
+    private BottomBar bottomBar;
+
+    private AppBarLayout appbarLayout;
+
+    public AppBar(MainActivity a, SharedPreferences sharedPref, SearchView.SearchListener searchListener) {
+        toolbar = (Toolbar) a.findViewById(R.id.action_bar);
+        searchView = new SearchView(this, a, searchListener);
+        bottomBar = new BottomBar(this, a);
+
+        appbarLayout = (AppBarLayout) a.findViewById(R.id.lin);
+
+        if (SDK_INT >= 21) toolbar.setElevation(0);
+        /* For SearchView, see onCreateOptionsMenu(Menu menu)*/
+        TOOLBAR_START_INSET = toolbar.getContentInsetStart();
+
+        if (!sharedPref.getBoolean("intelliHideToolbar", true)) {
+            AppBarLayout.LayoutParams params = (AppBarLayout.LayoutParams) toolbar.getLayoutParams();
+            params.setScrollFlags(0);
+            appbarLayout.setExpanded(true, true);
+        }
+    }
+
+    public Toolbar getToolbar() {
+        return toolbar;
+    }
+
+    public SearchView getSearchView() {
+        return searchView;
+    }
+
+    public BottomBar getBottomBar() {
+        return bottomBar;
+    }
+
+    public AppBarLayout getAppbarLayout() {
+        return appbarLayout;
+    }
+
+    public void setTitle(String title) {
+        if (toolbar != null) toolbar.setTitle(title);
+    }
+
+    public void setTitle(@StringRes int title) {
+        if (toolbar != null) toolbar.setTitle(title);
+    }
+
+}
diff --git a/app/src/main/java/com/amaze/filemanager/ui/views/appbar/BottomBar.java b/app/src/main/java/com/amaze/filemanager/ui/views/appbar/BottomBar.java
new file mode 100644
index 000000000..26471b4ac
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/ui/views/appbar/BottomBar.java
@@ -0,0 +1,531 @@
+package com.amaze.filemanager.ui.views.appbar;
+
+import android.animation.Animator;
+import android.animation.AnimatorListenerAdapter;
+import android.graphics.Color;
+import android.graphics.drawable.Drawable;
+import android.os.CountDownTimer;
+import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.support.v4.app.Fragment;
+import android.view.GestureDetector;
+import android.view.Gravity;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.animation.Animation;
+import android.view.animation.AnimationUtils;
+import android.widget.Button;
+import android.widget.FrameLayout;
+import android.widget.HorizontalScrollView;
+import android.widget.ImageButton;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+import com.amaze.filemanager.R;
+import com.amaze.filemanager.activities.MainActivity;
+import com.amaze.filemanager.fragments.MainFragment;
+import com.amaze.filemanager.fragments.TabFragment;
+import com.amaze.filemanager.fragments.CompressedExplorerFragment;
+import com.amaze.filemanager.fragments.preference_fragments.PrefFrag;
+import com.amaze.filemanager.ui.dialogs.GeneralDialogCreation;
+import com.amaze.filemanager.utils.BottomBarButtonPath;
+import com.amaze.filemanager.utils.MainActivityHelper;
+import com.amaze.filemanager.utils.OpenMode;
+import com.amaze.filemanager.utils.Utils;
+import com.amaze.filemanager.utils.files.FileUtils;
+
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+
+/**
+ * layout_appbar.xml contains the layout for AppBar and BottomBar
+ *
+ * BottomBar, it lays under the toolbar, used to show data of what is being displayed in the MainFragment,
+ * for example directory, folder and file amounts, etc.
+ *
+ * @author Emmanuel
+ *         on 2/8/2017, at 23:31.
+ */
+
+public class BottomBar implements View.OnTouchListener{
+    private static final int PATH_ANIM_START_DELAY = 0;
+    private static final int PATH_ANIM_END_DELAY = 0;
+
+    private WeakReference<MainActivity> mainActivity;
+    private AppBar appbar;
+    private String newPath;
+
+    private FrameLayout frame;
+    private LinearLayout pathLayout;
+    private LinearLayout buttons;
+    private HorizontalScrollView scroll, pathScroll;
+    private TextView pathText, fullPathText, fullPathAnim;
+
+    private LinearLayout.LayoutParams buttonParams;
+    private ImageButton buttonRoot;
+    private ImageButton buttonStorage;
+    private ArrayList<ImageView> arrowButtons = new ArrayList<>();
+    private int lastUsedArrowButton = 0;
+    private ArrayList<Button> folderButtons = new ArrayList<>();
+    private int lastUsedFolderButton = 0;
+    private Drawable arrow;
+
+    private CountDownTimer timer;
+    private boolean allowChangePaths;
+    private GestureDetector gestureDetector;
+
+    public BottomBar(AppBar appbar, MainActivity a) {
+        mainActivity = new WeakReference<>(a);
+        this.appbar = appbar;
+
+        frame = a.findViewById(R.id.buttonbarframe);
+
+        scroll = a.findViewById(R.id.scroll);
+        buttons = a.findViewById(R.id.buttons);
+
+        pathLayout = a.findViewById(R.id.pathbar);
+        pathScroll = a.findViewById(R.id.scroll1);
+        fullPathText = a.findViewById(R.id.fullpath);
+        fullPathAnim = a.findViewById(R.id.fullpath_anim);
+
+        pathText = a.findViewById(R.id.pathname);
+
+        scroll.setSmoothScrollingEnabled(true);
+        pathScroll.setSmoothScrollingEnabled(true);
+
+        buttonParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
+        buttonParams.gravity = Gravity.CENTER_VERTICAL;
+
+        buttonRoot = new ImageButton(a);
+        buttonRoot.setBackgroundColor(Color.TRANSPARENT);
+        buttonRoot.setLayoutParams(buttonParams);
+
+        buttonStorage = new ImageButton(a);
+        buttonStorage.setImageDrawable(a.getResources().getDrawable(R.drawable.ic_sd_storage_white_56dp));
+        buttonStorage.setBackgroundColor(Color.TRANSPARENT);
+        buttonStorage.setLayoutParams(buttonParams);
+
+        arrow = mainActivity.get().getResources().getDrawable(R.drawable.abc_ic_ab_back_holo_dark);
+
+        timer = new CountDownTimer(5000, 1000) {
+            @Override
+            public void onTick(long l) {}
+
+            @Override
+            public void onFinish() {
+                FileUtils.crossfadeInverse(buttons, pathLayout);
+            }
+        };
+
+        allowChangePaths = mainActivity.get().getPrefs().getBoolean(PrefFrag.PREFERENCE_CHANGEPATHS, false);
+
+        gestureDetector = new GestureDetector(a.getApplicationContext(), new GestureDetector.SimpleOnGestureListener() {
+            @Override
+            public boolean onDown(MotionEvent e) {
+                return true;
+            }
+
+            @Override
+            public boolean onSingleTapConfirmed(MotionEvent e) {
+                Fragment fragmentAtFrame = mainActivity.get().getFragmentAtFrame();
+                if(fragmentAtFrame instanceof TabFragment) {
+                    MainFragment m = mainActivity.get().getCurrentMainFragment();
+                    if (m.openMode == OpenMode.FILE) {
+                        FileUtils.crossfade(buttons, pathLayout);
+                        timer.cancel();
+                        timer.start();
+                        showButtons(m);
+                    }
+                } else if (fragmentAtFrame instanceof CompressedExplorerFragment) {
+                    FileUtils.crossfade(buttons, pathLayout);
+                    timer.cancel();
+                    timer.start();
+                    showButtons((BottomBarButtonPath) fragmentAtFrame);
+                }
+                return false;
+            }
+
+            @Override
+            public void onLongPress(MotionEvent e) {
+                if(allowChangePaths &&
+                        (!mainActivity.get().getCurrentMainFragment().results || buttons.getVisibility() == View.VISIBLE)) {
+                    GeneralDialogCreation.showChangePathsDialog(mainActivity, mainActivity.get().getPrefs());
+                }
+            }
+        });
+    }
+
+    public void setClickListener() {// TODO: 15/8/2017 this is a horrible hack, if you see this, correct it
+        frame.setOnTouchListener(this);
+        scroll.setOnTouchListener(this);
+        buttons.setOnTouchListener(this);
+        pathLayout.setOnTouchListener(this);
+        pathScroll .setOnTouchListener(this);
+        fullPathText.setOnTouchListener(this);
+        pathText.setOnTouchListener(this);
+        scroll.setOnTouchListener(this);
+        pathScroll.setOnTouchListener(this);
+
+    }
+
+    public void resetClickListener() {
+        frame.setOnTouchListener(null);
+    }
+
+    public void setPathText(String text) {
+        pathText.setText(text);
+    }
+
+    public void setFullPathText(String text) {
+        fullPathText.setText(text);
+    }
+
+    public boolean areButtonsShowing() {
+        return buttons.getVisibility() == View.VISIBLE;
+    }
+
+    public void showButtons(final BottomBarButtonPath buttonPathInterface) {
+        final String path = buttonPathInterface.getPath();
+        if (buttons.getVisibility() == View.VISIBLE) {
+            lastUsedArrowButton = 0;
+            lastUsedFolderButton = 0;
+            buttons.removeAllViews();
+            buttons.setMinimumHeight(pathLayout.getHeight());
+
+            buttonRoot.setImageDrawable(mainActivity.get().getResources().getDrawable(buttonPathInterface.getRootDrawable()));
+            buttonRoot.setOnClickListener(new View.OnClickListener() {
+                public void onClick(View p1) {
+                    buttonPathInterface.changePath("/");
+                    timer.cancel();
+                    timer.start();
+                }
+            });
+
+            String[] names = FileUtils.getFolderNamesInPath(path);
+            final String[] paths = FileUtils.getPathsInPath(path);
+
+            View view = new View(mainActivity.get());
+            LinearLayout.LayoutParams params1 = new LinearLayout.LayoutParams(
+                    appbar.getToolbar().getContentInsetLeft(), LinearLayout.LayoutParams.WRAP_CONTENT);
+            view.setLayoutParams(params1);
+            buttons.addView(view);
+
+            for (int i = 0; i < names.length; i++) {
+                final int k = i;
+                if (paths[i].equals("/")) {
+                    buttons.addView(buttonRoot);
+                } else if (FileUtils.isStorage(paths[i])) {
+                    buttonStorage.setOnClickListener(new View.OnClickListener() {
+                        public void onClick(View p1) {
+                            buttonPathInterface.changePath(paths[k]);
+                            timer.cancel();
+                            timer.start();
+                        }
+                    });
+                    buttons.addView(buttonStorage);
+                } else {
+                    Button button = createFolderButton(names[i]);
+                    button.setOnClickListener(new View.OnClickListener() {
+                        public void onClick(View p1) {
+                            buttonPathInterface.changePath(paths[k]);
+                            timer.cancel();
+                            timer.start();
+                        }
+                    });
+                    buttons.addView(button);
+                }
+
+                if (names.length - i != 1) {
+                    buttons.addView(createArrow());
+                }
+            }
+
+            scroll.post(new Runnable() {
+                @Override
+                public void run() {
+                    sendScroll(scroll);
+                    sendScroll(pathScroll);
+                }
+            });
+
+            if (buttons.getVisibility() == View.VISIBLE) {
+                timer.cancel();
+                timer.start();
+            }
+        }
+    }
+
+    private ImageView createArrow() {
+        ImageView buttonArrow;
+
+        if(lastUsedArrowButton >= arrowButtons.size()) {
+            buttonArrow = new ImageView(mainActivity.get());
+            buttonArrow.setImageDrawable(arrow);
+            buttonArrow.setLayoutParams(buttonParams);
+            arrowButtons.add(buttonArrow);
+        } else {
+            buttonArrow = arrowButtons.get(lastUsedArrowButton);
+        }
+
+        lastUsedArrowButton++;
+
+        return buttonArrow;
+    }
+
+    private Button createFolderButton(String text) {
+        Button button;
+
+        if(lastUsedFolderButton >= folderButtons.size()) {
+            button = new Button(mainActivity.get());
+            button.setTextColor(Utils.getColor(mainActivity.get(), android.R.color.white));
+            button.setTextSize(13);
+            button.setLayoutParams(buttonParams);
+            button.setBackgroundResource(0);
+            folderButtons.add(button);
+        } else {
+            button = folderButtons.get(lastUsedFolderButton);
+        }
+
+        button.setText(text);
+
+        lastUsedFolderButton++;
+
+        return button;
+    }
+
+    public void updatePath(@NonNull final String news, boolean results, String query, OpenMode openmode,
+                           int folderCount, int fileCount, BottomBarButtonPath buttonPathInterface) {
+
+        if (news.length() == 0) return;
+
+        MainActivityHelper mainActivityHelper = mainActivity.get().mainActivityHelper;
+
+        switch (openmode) {
+            case SMB:
+                newPath = mainActivityHelper.parseSmbPath(news);
+                break;
+            case OTG:
+                newPath = mainActivityHelper.parseOTGPath(news);
+                break;
+            case CUSTOM:
+                newPath = mainActivityHelper.getIntegralNames(news);
+                break;
+            case DROPBOX:
+            case BOX:
+            case ONEDRIVE:
+            case GDRIVE:
+                newPath = mainActivityHelper.parseCloudPath(openmode, news);
+                break;
+            default:
+                newPath = news;
+        }
+
+        if (!results) {
+            pathText.setText(mainActivity.get().getString(R.string.folderfilecount, folderCount, fileCount));
+        } else {
+            fullPathText.setText(mainActivity.get().getString(R.string.searchresults, query));
+            pathText.setText("");
+            return;
+        }
+
+        final String oldPath = fullPathText.getText().toString();
+        if (oldPath.equals(newPath)) return;
+
+        if (!areButtonsShowing()) {
+            final Animation slideIn = AnimationUtils.loadAnimation(mainActivity.get(), R.anim.slide_in);
+            Animation slideOut = AnimationUtils.loadAnimation(mainActivity.get(), R.anim.slide_out);
+
+            if (newPath.length() > oldPath.length() && newPath.contains(oldPath) && oldPath.length() != 0) {
+                // navigate forward
+                fullPathAnim.setAnimation(slideIn);
+                fullPathAnim.animate().setListener(new AnimatorListenerAdapter() {
+                    @Override
+                    public void onAnimationEnd(Animator animation) {
+                        super.onAnimationEnd(animation);
+                        new Handler().postDelayed(new Runnable() {
+                            @Override
+                            public void run() {
+                                fullPathAnim.setVisibility(View.GONE);
+                                fullPathText.setText(newPath);
+                            }
+                        }, PATH_ANIM_END_DELAY);
+                    }
+
+                    @Override
+                    public void onAnimationStart(Animator animation) {
+                        super.onAnimationStart(animation);
+                        fullPathAnim.setVisibility(View.VISIBLE);
+                        fullPathAnim.setText(Utils.differenceStrings(oldPath, newPath));
+                        //fullPathText.setText(oldPath);
+
+                        scroll.post(new Runnable() {
+                            @Override
+                            public void run() {
+                                pathScroll.fullScroll(View.FOCUS_RIGHT);
+                            }
+                        });
+                    }
+
+                    @Override
+                    public void onAnimationCancel(Animator animation) {
+                        super.onAnimationCancel(animation);
+                        //onAnimationEnd(animation);
+                    }
+                }).setStartDelay(PATH_ANIM_START_DELAY).start();
+            } else if (newPath.length() < oldPath.length() && oldPath.contains(newPath)) {
+                // navigate backwards
+                fullPathAnim.setAnimation(slideOut);
+                fullPathAnim.animate().setListener(new AnimatorListenerAdapter() {
+                    @Override
+                    public void onAnimationEnd(Animator animation) {
+                        super.onAnimationEnd(animation);
+                        fullPathAnim.setVisibility(View.GONE);
+                        fullPathText.setText(newPath);
+
+                        scroll.post(new Runnable() {
+                            @Override
+                            public void run() {
+                                pathScroll.fullScroll(View.FOCUS_RIGHT);
+                            }
+                        });
+                    }
+
+                    @Override
+                    public void onAnimationStart(Animator animation) {
+                        super.onAnimationStart(animation);
+                        fullPathAnim.setVisibility(View.VISIBLE);
+                        fullPathAnim.setText(Utils.differenceStrings(newPath, oldPath));
+                        fullPathText.setText(newPath);
+
+                        scroll.post(new Runnable() {
+                            @Override
+                            public void run() {
+                                pathScroll.fullScroll(View.FOCUS_LEFT);
+                            }
+                        });
+                    }
+                }).setStartDelay(PATH_ANIM_START_DELAY).start();
+            } else if (oldPath.isEmpty()) {
+                // case when app starts
+                fullPathAnim.setAnimation(slideIn);
+                fullPathAnim.setText(newPath);
+                fullPathAnim.animate().setListener(new AnimatorListenerAdapter() {
+                    @Override
+                    public void onAnimationStart(Animator animation) {
+                        super.onAnimationStart(animation);
+                        fullPathAnim.setVisibility(View.VISIBLE);
+                        fullPathText.setText("");
+                        scroll.post(new Runnable() {
+                            @Override
+                            public void run() {
+                                pathScroll.fullScroll(View.FOCUS_RIGHT);
+                            }
+                        });
+                    }
+
+                    @Override
+                    public void onAnimationEnd(Animator animation) {
+                        super.onAnimationEnd(animation);
+                        new Handler().postDelayed(new Runnable() {
+                            @Override
+                            public void run() {
+                                fullPathAnim.setVisibility(View.GONE);
+                                fullPathText.setText(newPath);
+                            }
+                        }, PATH_ANIM_END_DELAY);
+                    }
+
+                    @Override
+                    public void onAnimationCancel(Animator animation) {
+                        super.onAnimationCancel(animation);
+                        //onAnimationEnd(animation);
+                    }
+                }).setStartDelay(PATH_ANIM_START_DELAY).start();
+            } else {
+                // completely different path
+                // first slide out of old path followed by slide in of new path
+                fullPathAnim.setAnimation(slideOut);
+                fullPathAnim.animate().setListener(new AnimatorListenerAdapter() {
+                    @Override
+                    public void onAnimationStart(Animator animator) {
+                        super.onAnimationStart(animator);
+                        fullPathAnim.setVisibility(View.VISIBLE);
+                        fullPathAnim.setText(oldPath);
+                        fullPathText.setText("");
+
+                        scroll.post(new Runnable() {
+                            @Override
+                            public void run() {
+                                pathScroll.fullScroll(View.FOCUS_LEFT);
+                            }
+                        });
+                    }
+
+                    @Override
+                    public void onAnimationEnd(Animator animator) {
+                        super.onAnimationEnd(animator);
+
+                        //fullPathAnim.setVisibility(View.GONE);
+                        fullPathAnim.setText(newPath);
+                        fullPathText.setText("");
+                        fullPathAnim.setAnimation(slideIn);
+
+                        fullPathAnim.animate().setListener(new AnimatorListenerAdapter() {
+                            @Override
+                            public void onAnimationEnd(Animator animation) {
+                                super.onAnimationEnd(animation);
+                                new Handler().postDelayed(new Runnable() {
+                                    @Override
+                                    public void run() {
+                                        fullPathAnim.setVisibility(View.GONE);
+                                        fullPathText.setText(newPath);
+                                    }
+                                }, PATH_ANIM_END_DELAY);
+                            }
+
+                            @Override
+                            public void onAnimationStart(Animator animation) {
+                                super.onAnimationStart(animation);
+                                // we should not be having anything here in path bar
+                                fullPathAnim.setVisibility(View.VISIBLE);
+                                fullPathText.setText("");
+                                scroll.post(new Runnable() {
+                                    @Override
+                                    public void run() {
+                                        pathScroll.fullScroll(View.FOCUS_RIGHT);
+                                    }
+                                });
+                            }
+                        }).start();
+                    }
+
+                    @Override
+                    public void onAnimationCancel(Animator animation) {
+                        super.onAnimationCancel(animation);
+                        //onAnimationEnd(animation);
+                    }
+                }).setStartDelay(PATH_ANIM_START_DELAY).start();
+            }
+        } else {
+            showButtons(buttonPathInterface);
+            fullPathText.setText(newPath);
+        }
+    }
+
+    private void sendScroll(final HorizontalScrollView scrollView) {
+        new Handler().postDelayed(new Runnable() {
+            @Override
+            public void run() {
+                scrollView.fullScroll(View.FOCUS_RIGHT);
+            }
+        }, 100);
+    }
+
+    @Override
+    public boolean onTouch(View v, MotionEvent event) {
+        return gestureDetector.onTouchEvent(event);
+    }
+
+}
diff --git a/app/src/main/java/com/amaze/filemanager/ui/views/appbar/SearchView.java b/app/src/main/java/com/amaze/filemanager/ui/views/appbar/SearchView.java
new file mode 100644
index 000000000..6ce9df3a5
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/ui/views/appbar/SearchView.java
@@ -0,0 +1,184 @@
+package com.amaze.filemanager.ui.views.appbar;
+
+import android.animation.Animator;
+import android.animation.ObjectAnimator;
+import android.content.Context;
+import android.support.v7.widget.AppCompatEditText;
+import android.view.KeyEvent;
+import android.view.View;
+import android.view.ViewAnimationUtils;
+import android.view.animation.AccelerateDecelerateInterpolator;
+import android.view.inputmethod.EditorInfo;
+import android.view.inputmethod.InputMethodManager;
+import android.widget.ImageView;
+import android.widget.RelativeLayout;
+import android.widget.TextView;
+
+import com.amaze.filemanager.R;
+import com.amaze.filemanager.activities.MainActivity;
+
+import java.lang.ref.WeakReference;
+
+import static android.content.Context.INPUT_METHOD_SERVICE;
+import static android.os.Build.VERSION.SDK_INT;
+
+/**
+ * SearchView, a simple view to search
+ *
+ * @author Emmanuel
+ *         on 2/8/2017, at 23:30.
+ */
+
+public class SearchView {
+
+    private WeakReference<MainActivity> mainActivity;
+    private AppBar appbar;
+
+    private RelativeLayout searchViewLayout;
+    private AppCompatEditText searchViewEditText;
+    private ImageView clearImageView;
+    private ImageView backImageView;
+
+    private boolean enabled = false;
+
+    public SearchView(final AppBar appbar, final MainActivity a, final SearchListener searchListener) {
+        mainActivity = new WeakReference<>(a);
+        this.appbar = appbar;
+
+        searchViewLayout = (RelativeLayout) a.findViewById(R.id.search_view);
+        searchViewEditText = (AppCompatEditText) a.findViewById(R.id.search_edit_text);
+        clearImageView = (ImageView) a.findViewById(R.id.search_close_btn);
+        backImageView = (ImageView) a.findViewById(R.id.img_view_back);
+
+        clearImageView.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                searchViewEditText.setText("");
+            }
+        });
+
+        backImageView.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                appbar.getSearchView().hideSearchView();
+            }
+        });
+
+        searchViewEditText.setOnEditorActionListener(new TextView.OnEditorActionListener() {
+            @Override
+            public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
+                if (actionId == EditorInfo.IME_ACTION_SEARCH) {
+                    searchListener.onSearch(searchViewEditText.getText().toString());
+                    appbar.getSearchView().hideSearchView();
+                    return true;
+                }
+                return false;
+            }
+        });
+
+        //searchViewEditText.setTextColor(Utils.getColor(this, android.R.color.black));
+        //searchViewEditText.setHintTextColor(Color.parseColor(ThemedActivity.accentSkin));
+    }
+
+    /**
+     * show search view with a circular reveal animation
+     */
+    public void revealSearchView() {
+        final int START_RADIUS = 16;
+        int endRadius = Math.max(appbar.getToolbar().getWidth(), appbar.getToolbar().getHeight());
+
+        Animator animator;
+        if (SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {
+            int[] searchCoords = new int[2];
+            View searchItem = appbar.getToolbar().findViewById(R.id.search);//It could change position, get it every time
+            searchViewEditText.setText("");
+            searchItem.getLocationOnScreen(searchCoords);
+            animator = ViewAnimationUtils.createCircularReveal(searchViewLayout,
+                    searchCoords[0] + 32, searchCoords[1] - 16, START_RADIUS, endRadius);
+        } else {
+            // TODO:ViewAnimationUtils.createCircularReveal
+            animator = ObjectAnimator.ofFloat(searchViewLayout, "alpha", 0f, 1f);
+        }
+
+        mainActivity.get().showSmokeScreen();
+
+        animator.setInterpolator(new AccelerateDecelerateInterpolator());
+        animator.setDuration(600);
+        searchViewLayout.setVisibility(View.VISIBLE);
+        animator.start();
+        animator.addListener(new Animator.AnimatorListener() {
+            @Override
+            public void onAnimationStart(Animator animation) {}
+
+            @Override
+            public void onAnimationEnd(Animator animation) {
+                searchViewEditText.requestFocus();
+                InputMethodManager imm = (InputMethodManager) mainActivity.get().getSystemService(Context.INPUT_METHOD_SERVICE);
+                imm.showSoftInput(searchViewEditText, InputMethodManager.SHOW_IMPLICIT);
+                enabled = true;
+            }
+
+            @Override
+            public void onAnimationCancel(Animator animation) {}
+
+            @Override
+            public void onAnimationRepeat(Animator animation) {}
+        });
+    }
+
+    /**
+     * hide search view with a circular reveal animation
+     */
+    public void hideSearchView() {
+        final int END_RADIUS = 16;
+        int startRadius = Math.max(searchViewLayout.getWidth(), searchViewLayout.getHeight());
+        Animator animator;
+        if (SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {
+            int[] searchCoords = new int[2];
+            View searchItem = appbar.getToolbar().findViewById(R.id.search);//It could change position, get it every time
+            searchViewEditText.setText("");
+            searchItem.getLocationOnScreen(searchCoords);
+            animator = ViewAnimationUtils.createCircularReveal(searchViewLayout,
+                    searchCoords[0] + 32, searchCoords[1] - 16, startRadius, END_RADIUS);
+        } else {
+            // TODO: ViewAnimationUtils.createCircularReveal
+            animator = ObjectAnimator.ofFloat(searchViewLayout, "alpha", 1f, 0f);
+        }
+
+        // removing background fade view
+        mainActivity.get().hideSmokeScreen();
+        animator.setInterpolator(new AccelerateDecelerateInterpolator());
+        animator.setDuration(600);
+        animator.start();
+        animator.addListener(new Animator.AnimatorListener() {
+            @Override
+            public void onAnimationStart(Animator animation) {}
+
+            @Override
+            public void onAnimationEnd(Animator animation) {
+                searchViewLayout.setVisibility(View.GONE);
+                enabled = false;
+                InputMethodManager inputMethodManager = (InputMethodManager) mainActivity.get().getSystemService(INPUT_METHOD_SERVICE);
+                inputMethodManager.hideSoftInputFromWindow(searchViewEditText.getWindowToken(), InputMethodManager.HIDE_IMPLICIT_ONLY);
+            }
+
+            @Override
+            public void onAnimationCancel(Animator animation) {}
+
+            @Override
+            public void onAnimationRepeat(Animator animation) {}
+        });
+    }
+
+    public boolean isEnabled() {
+        return enabled;
+    }
+
+    public boolean isShown() {
+        return searchViewLayout.isShown();
+    }
+
+    public interface SearchListener {
+        void onSearch(String queue);
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/ui/views/preference/EditIntPreference.java b/app/src/main/java/com/amaze/filemanager/ui/views/preference/EditIntPreference.java
deleted file mode 100644
index cff424e09..000000000
--- a/app/src/main/java/com/amaze/filemanager/ui/views/preference/EditIntPreference.java
+++ /dev/null
@@ -1,32 +0,0 @@
-package com.amaze.filemanager.ui.views.preference;
-
-import android.content.Context;
-import android.preference.EditTextPreference;
-
-/**
- * Created by rpiotaix on 17/11/16.
- */
-
-public class EditIntPreference extends EditTextPreference {
-    public EditIntPreference(Context context) {
-        super(context);
-    }
-
-//    public int getIntValue(){
-//
-//    }
-//
-//    public void setIntValue(int value){
-//
-//    }
-//
-//    @Override
-//    public void setText(String text) {
-//        setIntValue(Integer.parseInt(text));
-//    }
-//
-//    @Override
-//    public String getText() {
-//        return Integer.toString(getIntValue());
-//    }
-}
diff --git a/app/src/main/java/com/amaze/filemanager/ui/views/preference/PathSwitchPreference.java b/app/src/main/java/com/amaze/filemanager/ui/views/preference/PathSwitchPreference.java
index b69a6fcfa..eb8ce3366 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/views/preference/PathSwitchPreference.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/views/preference/PathSwitchPreference.java
@@ -3,10 +3,8 @@ package com.amaze.filemanager.ui.views.preference;
 import android.content.Context;
 import android.preference.Preference;
 import android.support.annotation.IdRes;
-import android.support.v7.app.AppCompatDelegate;
 import android.view.View;
 import android.view.ViewGroup;
-import android.widget.Switch;
 
 import com.amaze.filemanager.R;
 
@@ -28,7 +26,6 @@ public class PathSwitchPreference extends Preference {
     @Override
     protected View onCreateView(ViewGroup parent) {
         setWidgetLayoutResource(R.layout.namepathswitch_preference);
-        AppCompatDelegate.setCompatVectorFromResourcesEnabled(true);//selector in srcCompat isn't supported without this
         return super.onCreateView(parent);
     }
 
@@ -49,12 +46,9 @@ public class PathSwitchPreference extends Preference {
     private View.OnClickListener setListener(final View v, @IdRes int id, final int elem) {
         final PathSwitchPreference t = this;
 
-        View.OnClickListener l = new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                lastItemClicked = elem;
-                getOnPreferenceClickListener().onPreferenceClick(t);
-            }
+        View.OnClickListener l = view -> {
+            lastItemClicked = elem;
+            getOnPreferenceClickListener().onPreferenceClick(t);
         };
 
         v.findViewById(id).setOnClickListener(l);
diff --git a/app/src/main/java/com/amaze/filemanager/utils/BottomBarButtonPath.java b/app/src/main/java/com/amaze/filemanager/utils/BottomBarButtonPath.java
new file mode 100644
index 000000000..5e19951bf
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/utils/BottomBarButtonPath.java
@@ -0,0 +1,18 @@
+package com.amaze.filemanager.utils;
+
+import android.support.annotation.DrawableRes;
+
+/**
+ * This lets BottomBar be independent of the Fragment MainActivity is housing
+ *
+ * @author Emmanuel
+ *         on 20/8/2017, at 13:35.
+ */
+
+public interface BottomBarButtonPath {
+    void changePath(String path);
+
+    String getPath();
+
+    @DrawableRes int getRootDrawable();
+}
diff --git a/app/src/main/java/com/amaze/filemanager/utils/Computer.java b/app/src/main/java/com/amaze/filemanager/utils/ComputerParcelable.java
similarity index 55%
rename from app/src/main/java/com/amaze/filemanager/utils/Computer.java
rename to app/src/main/java/com/amaze/filemanager/utils/ComputerParcelable.java
index 260e142ec..0a096e536 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/Computer.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/ComputerParcelable.java
@@ -6,25 +6,25 @@ import android.os.Parcelable;
 /**
  * Created by arpitkh996 on 16-01-2016.
  */
-public class Computer implements Parcelable {
+public class ComputerParcelable implements Parcelable {
 
     public String addr;
     public String name;
 
-    public Computer(String str, String str2) {
+    public ComputerParcelable(String str, String str2) {
         this.name = str;
         this.addr = str2;
     }
 
-    public static final Creator<Computer> CREATOR = new Creator<Computer>() {
+    public static final Creator<ComputerParcelable> CREATOR = new Creator<ComputerParcelable>() {
         @Override
-        public Computer createFromParcel(Parcel in) {
-            return new Computer(in);
+        public ComputerParcelable createFromParcel(Parcel in) {
+            return new ComputerParcelable(in);
         }
 
         @Override
-        public Computer[] newArray(int size) {
-            return new Computer[size];
+        public ComputerParcelable[] newArray(int size) {
+            return new ComputerParcelable[size];
         }
     };
 
@@ -42,16 +42,16 @@ public class Computer implements Parcelable {
     }
 
     public boolean equals(Object obj) {
-        return obj instanceof Computer
-                && (this == obj || (this.name.equals(((Computer) obj).name)
-                && this.addr.equals(((Computer) obj).addr)));
+        return obj instanceof ComputerParcelable
+                && (this == obj || (this.name.equals(((ComputerParcelable) obj).name)
+                && this.addr.equals(((ComputerParcelable) obj).addr)));
     }
 
     public int hashCode() {
         return this.name.hashCode() + this.addr.hashCode();
     }
 
-    private Computer(Parcel parcel) {
+    private ComputerParcelable(Parcel parcel) {
         this.name = parcel.readString();
         this.addr = parcel.readString();
     }
diff --git a/app/src/main/java/com/amaze/filemanager/utils/DataPackage.java b/app/src/main/java/com/amaze/filemanager/utils/CopyDataParcelable.java
similarity index 80%
rename from app/src/main/java/com/amaze/filemanager/utils/DataPackage.java
rename to app/src/main/java/com/amaze/filemanager/utils/CopyDataParcelable.java
index 62f1c3d94..41de974dd 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/DataPackage.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/CopyDataParcelable.java
@@ -3,14 +3,17 @@ package com.amaze.filemanager.utils;
 import android.os.Parcel;
 import android.os.Parcelable;
 
+import com.amaze.filemanager.asynchronous.services.CopyService;
+import com.amaze.filemanager.fragments.ProcessViewerFragment;
+
 /**
  * Created by Arpit on 01-08-2015.
  *
- * Class stores the {@link com.amaze.filemanager.services.CopyService} progress variables.
+ * Class stores the {@link CopyService} progress variables.
  * This class also acts as a middle layer to communicate with
- * {@link com.amaze.filemanager.fragments.ProcessViewer}
+ * {@link ProcessViewerFragment}
  */
-public class DataPackage implements Parcelable {
+public class CopyDataParcelable implements Parcelable {
 
     // which file is being copied from total number of files
     int sourceProgress;
@@ -32,9 +35,9 @@ public class DataPackage implements Parcelable {
     // name of source file being copied
     String name;
 
-    public DataPackage(){}
+    public CopyDataParcelable(){}
 
-    protected DataPackage(Parcel in) {
+    protected CopyDataParcelable(Parcel in) {
         sourceProgress = in.readInt();
         byteProgress = in.readLong();
         sourceFiles = in.readInt();
@@ -45,15 +48,15 @@ public class DataPackage implements Parcelable {
         speedRaw = in.readInt();
     }
 
-    public static final Creator<DataPackage> CREATOR = new Creator<DataPackage>() {
+    public static final Creator<CopyDataParcelable> CREATOR = new Creator<CopyDataParcelable>() {
         @Override
-        public DataPackage createFromParcel(Parcel in) {
-            return new DataPackage(in);
+        public CopyDataParcelable createFromParcel(Parcel in) {
+            return new CopyDataParcelable(in);
         }
 
         @Override
-        public DataPackage[] newArray(int size) {
-            return new DataPackage[size];
+        public CopyDataParcelable[] newArray(int size) {
+            return new CopyDataParcelable[size];
         }
     };
 
diff --git a/app/src/main/java/com/amaze/filemanager/utils/DataUtils.java b/app/src/main/java/com/amaze/filemanager/utils/DataUtils.java
index f93de5056..07811dee0 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/DataUtils.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/DataUtils.java
@@ -1,15 +1,21 @@
 package com.amaze.filemanager.utils;
 
 import com.amaze.filemanager.ui.drawer.Item;
+import com.amaze.filemanager.utils.application.AppConfig;
 import com.cloudrail.si.interfaces.CloudStorage;
 import com.cloudrail.si.services.Box;
 import com.cloudrail.si.services.Dropbox;
 import com.cloudrail.si.services.GoogleDrive;
 import com.cloudrail.si.services.OneDrive;
+import com.googlecode.concurrenttrees.radix.ConcurrentRadixTree;
+import com.googlecode.concurrenttrees.radix.node.concrete.DefaultCharArrayNodeFactory;
+import com.googlecode.concurrenttrees.radix.node.concrete.voidvalue.VoidValue;
 
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.LinkedList;
 import java.util.List;
+import java.util.Stack;
 
 /**
  * Created by arpitkh996 on 20-01-2016.
@@ -23,11 +29,17 @@ public class DataUtils {
     public static final int DELETE = 0, COPY = 1, MOVE = 2, NEW_FOLDER = 3,
             RENAME = 4, NEW_FILE = 5, EXTRACT = 6, COMPRESS = 7;
 
-    private ArrayList<String> hiddenfiles = new ArrayList<>(), gridfiles = new ArrayList<>(),
-            listfiles = new ArrayList<>(), history = new ArrayList<>(), storages = new ArrayList<>();
+    private ConcurrentRadixTree<VoidValue> hiddenfiles = new ConcurrentRadixTree<>(new DefaultCharArrayNodeFactory());
+
+    private ArrayList<String> gridfiles = new ArrayList<>();
+    private ArrayList<String> listfiles = new ArrayList<>();
+    private LinkedList<String> history = new LinkedList<>();
+    private ArrayList<String> storages = new ArrayList<>();
 
     private ArrayList<Item> list = new ArrayList<>();
-    private ArrayList<String[]> servers = new ArrayList<>(), books = new ArrayList<>();
+
+    private ArrayList<String[]> servers = new ArrayList<>();
+    private ArrayList<String[]> books = new ArrayList<>();
 
     private ArrayList<CloudStorage> accounts = new ArrayList<>(4);
 
@@ -104,10 +116,10 @@ public class DataUtils {
     }
 
     public void clear() {
-        hiddenfiles = new ArrayList<>();
+        hiddenfiles = new ConcurrentRadixTree<>(new DefaultCharArrayNodeFactory());
         gridfiles = new ArrayList<>();
         listfiles = new ArrayList<>();
-        history = new ArrayList<>();
+        history.clear();
         storages = new ArrayList<>();
         servers = new ArrayList<>();
         books = new ArrayList<>();
@@ -203,13 +215,7 @@ public class DataUtils {
             books.add(i);
         }
         if (refreshdrawer && dataChangeListener != null) {
-            AppConfig.runInBackground(new Runnable() {
-                @Override
-                public void run() {
-
-                    dataChangeListener.onBookAdded(i, true);
-                }
-            });
+            AppConfig.runInBackground(() -> dataChangeListener.onBookAdded(i, true));
         }
     }
 
@@ -225,16 +231,10 @@ public class DataUtils {
 
         synchronized (hiddenfiles) {
 
-            hiddenfiles.add(i);
+            hiddenfiles.put(i, VoidValue.SINGLETON);
         }
         if (dataChangeListener != null) {
-            AppConfig.runInBackground(new Runnable() {
-                @Override
-                public void run() {
-
-                    dataChangeListener.onHiddenFileAdded(i);
-                }
-            });
+            AppConfig.runInBackground(() -> dataChangeListener.onHiddenFileAdded(i));
         }
     }
 
@@ -245,34 +245,23 @@ public class DataUtils {
             hiddenfiles.remove(i);
         }
         if (dataChangeListener != null) {
-            AppConfig.runInBackground(new Runnable() {
-                @Override
-                public void run() {
-
-                    dataChangeListener.onHiddenFileRemoved(i);
-                }
-            });
+            AppConfig.runInBackground(() -> dataChangeListener.onHiddenFileRemoved(i));
         }
     }
 
-    public ArrayList<String> getHistory() {
+    public void setHistory(LinkedList<String> s) {
+        history.clear();
+        history.addAll(s);
+    }
+
+    public LinkedList<String> getHistory() {
         return history;
     }
 
     public void addHistoryFile(final String i) {
-
-        synchronized (history) {
-
-            history.add(i);
-        }
+        history.push(i);
         if (dataChangeListener != null) {
-            AppConfig.runInBackground(new Runnable() {
-                @Override
-                public void run() {
-
-                    dataChangeListener.onHistoryAdded(i);
-                }
-            });
+            AppConfig.runInBackground(() -> dataChangeListener.onHistoryAdded(i));
         }
     }
 
@@ -333,13 +322,16 @@ public class DataUtils {
         return null;
     }
 
-    public ArrayList<String> getHiddenfiles() {
+    public boolean isFileHidden(String path) {
+        return getHiddenFiles().getValueForExactKey(path) != null;
+    }
+
+    public ConcurrentRadixTree<VoidValue> getHiddenFiles() {
         return hiddenfiles;
     }
 
-    public synchronized void setHiddenfiles(ArrayList<String> hiddenfiles) {
-        if (hiddenfiles != null)
-            this.hiddenfiles = hiddenfiles;
+    public synchronized void setHiddenFiles(ConcurrentRadixTree<VoidValue> hiddenfiles) {
+        if (hiddenfiles != null) this.hiddenfiles = hiddenfiles;
     }
 
     public ArrayList<String> getGridFiles() {
@@ -361,7 +353,7 @@ public class DataUtils {
     }
 
     public void clearHistory() {
-        history = new ArrayList<>();
+        history.clear();
         if (dataChangeListener != null) {
             AppConfig.runInBackground(new Runnable() {
                 @Override
diff --git a/app/src/main/java/com/amaze/filemanager/utils/GenericFileProvider.java b/app/src/main/java/com/amaze/filemanager/utils/GenericFileProvider.java
new file mode 100644
index 000000000..62be507d8
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/utils/GenericFileProvider.java
@@ -0,0 +1,15 @@
+package com.amaze.filemanager.utils;
+
+import android.support.v4.content.FileProvider;
+
+/**
+ * Created by Vishal on 20-08-2017.
+ *
+ * Empty class to denote a custom file provider
+ */
+
+public class GenericFileProvider extends FileProvider {
+
+    public static final String PROVIDER_NAME = "com.amaze.filemanager.FILE_PROVIDER";
+
+}
diff --git a/app/src/main/java/com/amaze/filemanager/utils/ImmutableEntry.java b/app/src/main/java/com/amaze/filemanager/utils/ImmutableEntry.java
new file mode 100644
index 000000000..db57003c0
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/utils/ImmutableEntry.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2008 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amaze.filemanager.utils;
+
+import android.support.annotation.Nullable;
+
+import java.util.Map;
+
+/**
+ * From: https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableEntry.java
+ * Author: Guava
+ */
+public class ImmutableEntry<K, V> implements Map.Entry<K, V> {
+    private final K key;
+    private final V value;
+
+    public ImmutableEntry(@Nullable K key, @Nullable V value) {
+        this.key = key;
+        this.value = value;
+    }
+
+    @Nullable
+    @Override
+    public final K getKey() {
+        return key;
+    }
+
+    @Nullable
+    @Override
+    public final V getValue() {
+        return value;
+    }
+
+    @Override
+    public final V setValue(V value) {
+        throw new UnsupportedOperationException();
+    }
+
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/amaze/filemanager/utils/InterestingConfigChange.java b/app/src/main/java/com/amaze/filemanager/utils/InterestingConfigChange.java
index e5e76e8b6..28fd03757 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/InterestingConfigChange.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/InterestingConfigChange.java
@@ -21,20 +21,12 @@ public class InterestingConfigChange {
     /**
      * Check for any config change between various callbacks to this method.
      * Make sure to recycle after done
-     * @param resources
-     * @return
      */
     public static boolean isConfigChanged(Resources resources) {
         int changedFieldsMask = lastConfiguration.updateFrom(resources.getConfiguration());
-        boolean densityChanged = lastDensity!=resources.getDisplayMetrics().densityDpi;
-
-        if (densityChanged || (changedFieldsMask &
-                (ActivityInfo.CONFIG_SCREEN_LAYOUT | ActivityInfo.CONFIG_UI_MODE | ActivityInfo.CONFIG_LOCALE)) != 0) {
-            // we have density changed from last time we came here
-            return true;
-        }
-
-        return false;
+        boolean densityChanged = lastDensity != resources.getDisplayMetrics().densityDpi;
+        int mode = ActivityInfo.CONFIG_SCREEN_LAYOUT | ActivityInfo.CONFIG_UI_MODE | ActivityInfo.CONFIG_LOCALE;
+        return densityChanged || (changedFieldsMask & mode) != 0;
     }
 
     /**
diff --git a/app/src/main/java/com/amaze/filemanager/utils/Logger.java b/app/src/main/java/com/amaze/filemanager/utils/Logger.java
deleted file mode 100644
index cb6456751..000000000
--- a/app/src/main/java/com/amaze/filemanager/utils/Logger.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package com.amaze.filemanager.utils;
-
-import android.content.Context;
-
-import java.io.BufferedWriter;
-import java.io.File;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.io.StringWriter;
-
-/**
- * Created by arpitkh996 on 13-01-2016.
- */
-public class Logger {
-
-    public static void log(final Exception s, final String s1, Context context) {
-        if (context == null) return;
-        final File f = new File(context.getExternalFilesDir("internal"), "log.txt");
-        new Thread(new Runnable() {
-            @Override
-            public void run() {
-                FileWriter output = null;
-                try {
-                    StringWriter sw = new StringWriter();
-                    PrintWriter pw = new PrintWriter(sw);
-                    if (s != null)
-                        s.printStackTrace(pw);
-                    output = new FileWriter(f.getPath());
-                    BufferedWriter writer = new BufferedWriter(output);
-                    writer.write(s1 + "\n");
-                    writer.write(sw.toString());
-                    writer.close();
-                    output.close();
-                } catch (IOException e) {
-                }
-            }
-        }).start();
-    }
-}
diff --git a/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java b/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java
index 7f367e607..0308f9fc7 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java
@@ -1,18 +1,15 @@
 package com.amaze.filemanager.utils;
 
-import android.Manifest;
 import android.app.Activity;
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.graphics.Color;
+import android.content.SharedPreferences;
 import android.os.AsyncTask;
 import android.os.Build;
 import android.os.Bundle;
 import android.support.annotation.StringRes;
 import android.support.design.widget.BottomSheetDialogFragment;
-import android.support.v4.app.ActivityCompat;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentManager;
 import android.util.Log;
@@ -25,26 +22,26 @@ import android.widget.Toast;
 import com.afollestad.materialdialogs.DialogAction;
 import com.afollestad.materialdialogs.MaterialDialog;
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.activities.BaseActivity;
 import com.amaze.filemanager.activities.MainActivity;
+import com.amaze.filemanager.activities.superclasses.ThemedActivity;
+import com.amaze.filemanager.asynchronous.asynctasks.DeleteTask;
+import com.amaze.filemanager.asynchronous.services.ZipService;
 import com.amaze.filemanager.database.CloudHandler;
 import com.amaze.filemanager.database.CryptHandler;
 import com.amaze.filemanager.database.models.EncryptedEntry;
-import com.amaze.filemanager.filesystem.BaseFile;
 import com.amaze.filemanager.filesystem.FileUtil;
-import com.amaze.filemanager.filesystem.HFile;
+import com.amaze.filemanager.filesystem.HybridFile;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.Operations;
+import com.amaze.filemanager.filesystem.compressed.CompressedHelper;
+import com.amaze.filemanager.filesystem.compressed.CompressedInterface;
 import com.amaze.filemanager.fragments.CloudSheetFragment;
 import com.amaze.filemanager.fragments.MainFragment;
 import com.amaze.filemanager.fragments.SearchWorkerFragment;
 import com.amaze.filemanager.fragments.TabFragment;
-import com.amaze.filemanager.services.DeleteTask;
-import com.amaze.filemanager.services.ExtractService;
-import com.amaze.filemanager.services.ZipTask;
 import com.amaze.filemanager.ui.dialogs.GeneralDialogCreation;
+import com.amaze.filemanager.utils.color.ColorUsage;
 import com.amaze.filemanager.utils.files.CryptUtil;
-import com.amaze.filemanager.utils.files.Futils;
-import com.amaze.filemanager.utils.provider.UtilitiesProviderInterface;
 
 import java.io.File;
 import java.util.ArrayList;
@@ -57,8 +54,8 @@ public class MainActivityHelper {
     public static final int NEW_FOLDER = 0, NEW_FILE = 1, NEW_SMB = 2, NEW_CLOUD = 3;
 
     private MainActivity mainActivity;
-    private Futils utils;
     private DataUtils dataUtils = DataUtils.getInstance();
+    private int accentColor;
 
     /*
      * A static string which saves the last searched query. Used to retain search task after
@@ -68,19 +65,18 @@ public class MainActivityHelper {
 
     public MainActivityHelper(MainActivity mainActivity) {
         this.mainActivity = mainActivity;
-        this.utils = mainActivity.getFutils();
+        accentColor = mainActivity.getColorPreference().getColor(ColorUsage.ACCENT);
     }
 
-    public void showFailedOperationDialog(ArrayList<BaseFile> failedOps, boolean move,
-                                          Context contextc) {
+    public void showFailedOperationDialog(ArrayList<HybridFileParcelable> failedOps, boolean move, Context contextc) {
         MaterialDialog.Builder mat=new MaterialDialog.Builder(contextc);
         mat.title(contextc.getString(R.string.operationunsuccesful));
         mat.theme(mainActivity.getAppTheme().getMaterialDialogTheme());
-        mat.positiveColor(Color.parseColor(BaseActivity.accentSkin));
+        mat.positiveColor(accentColor);
         mat.positiveText(R.string.cancel);
         String content = contextc.getResources().getString(R.string.operation_fail_following);
         int k=1;
-        for(BaseFile s:failedOps){
+        for(HybridFileParcelable s:failedOps){
             content=content+ "\n" + (k) + ". " + s.getName();
             k++;
         }
@@ -117,13 +113,10 @@ public class MainActivityHelper {
      * @param ma       {@link MainFragment} current fragment
      */
     void mkdir(final OpenMode openMode, final String path, final MainFragment ma) {
-        mk(R.string.newfolder, new OnClickMaterialListener() {
-            @Override
-            public void onClick(MaterialDialog materialDialog) {
-                String a = materialDialog.getInputEditText().getText().toString();
-                mkDir(new HFile(openMode, path + "/" + a), ma);
-                materialDialog.dismiss();
-            }
+        mk(R.string.newfolder, materialDialog -> {
+            String a = materialDialog.getInputEditText().getText().toString();
+            mkDir(new HybridFile(openMode, path + "/" + a), ma);
+            materialDialog.dismiss();
         });
     }
 
@@ -135,13 +128,10 @@ public class MainActivityHelper {
      * @param ma       {@link MainFragment} current fragment
      */
     void mkfile(final OpenMode openMode, final String path, final MainFragment ma) {
-        mk(R.string.newfile, new OnClickMaterialListener() {
-            @Override
-            public void onClick(MaterialDialog materialDialog) {
-                String a = materialDialog.getInputEditText().getText().toString();
-                mkFile(new HFile(openMode, path + "/" + a), ma);
-                materialDialog.dismiss();
-            }
+        mk(R.string.newfile, materialDialog -> {
+            String a = materialDialog.getInputEditText().getText().toString();
+            mkFile(new HybridFile(openMode, path + "/" + a), ma);
+            materialDialog.dismiss();
         });
     }
 
@@ -154,12 +144,7 @@ public class MainActivityHelper {
                         mainActivity.getResources().getString(R.string.cancel),
                         null});
 
-        materialDialog.getActionButton(DialogAction.POSITIVE).setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                l.onClick(materialDialog);
-            }
-        });
+        materialDialog.getActionButton(DialogAction.POSITIVE).setOnClickListener(v -> l.onClick(materialDialog));
         materialDialog.show();
     }
 
@@ -168,7 +153,7 @@ public class MainActivityHelper {
     }
 
     public void add(int pos) {
-        final MainFragment ma = (MainFragment) ((TabFragment) mainActivity.getSupportFragmentManager().findFragmentById(R.id.content_frame)).getTab();
+        final MainFragment ma = (MainFragment) ((TabFragment) mainActivity.getSupportFragmentManager().findFragmentById(R.id.content_frame)).getCurrentTabFragment();
         final String path = ma.getCurrentPath();
 
         switch (pos) {
@@ -227,8 +212,8 @@ public class MainActivityHelper {
         ((ImageView) view.findViewById(R.id.icon)).setImageResource(R.drawable.sd_operate_step);
         x.positiveText(R.string.open);
         x.negativeText(R.string.cancel);
-        x.positiveColor(Color.parseColor(BaseActivity.accentSkin));
-        x.negativeColor(Color.parseColor(BaseActivity.accentSkin));
+        x.positiveColor(accentColor);
+        x.negativeColor(accentColor);
         x.callback(new MaterialDialog.ButtonCallback() {
             @Override
             public void onPositive(MaterialDialog materialDialog) {
@@ -254,82 +239,69 @@ public class MainActivityHelper {
         final Toast toast=Toast.makeText(context, context.getString(R.string.renaming),
                 Toast.LENGTH_SHORT);
         toast.show();
-        Operations.rename(new HFile(mode, oldPath), new HFile(mode, newPath), rootmode, context, new Operations.ErrorCallBack() {
+        Operations.rename(new HybridFile(mode, oldPath), new HybridFile(mode, newPath), rootmode, context, new Operations.ErrorCallBack() {
             @Override
-            public void exists(HFile file) {
-                context.runOnUiThread(new Runnable() {
-                    @Override
-                    public void run() {
-                        if (toast != null) toast.cancel();
-                        Toast.makeText(mainActivity, context.getString(R.string.fileexist),
-                                Toast.LENGTH_SHORT).show();
-                    }
+            public void exists(HybridFile file) {
+                context.runOnUiThread(() -> {
+                    if (toast != null) toast.cancel();
+                    Toast.makeText(mainActivity, context.getString(R.string.fileexist),
+                            Toast.LENGTH_SHORT).show();
                 });
             }
 
             @Override
-            public void launchSAF(HFile file) {
+            public void launchSAF(HybridFile file) {
 
             }
 
             @Override
-            public void launchSAF(final HFile file, final HFile file1) {
-                context.runOnUiThread(new Runnable() {
-                    @Override
-                    public void run() {
-                        if (toast != null) toast.cancel();
-                        mainActivity.oppathe = file.getPath();
-                        mainActivity.oppathe1 = file1.getPath();
-                        mainActivity.operation = DataUtils.RENAME;
-                        guideDialogForLEXA(mainActivity.oppathe1);
-                    }
+            public void launchSAF(final HybridFile file, final HybridFile file1) {
+                context.runOnUiThread(() -> {
+                    if (toast != null) toast.cancel();
+                    mainActivity.oppathe = file.getPath();
+                    mainActivity.oppathe1 = file1.getPath();
+                    mainActivity.operation = DataUtils.RENAME;
+                    guideDialogForLEXA(mainActivity.oppathe1);
                 });
             }
 
             @Override
-            public void done(HFile hFile, final boolean b) {
-                context.runOnUiThread(new Runnable() {
-                    @Override
-                    public void run() {
-                        if (b) {
-                            Intent intent = new Intent("loadlist");
-                            mainActivity.sendBroadcast(intent);
-
-                            // update the database entry to reflect rename for encrypted file
-                            if (oldPath.endsWith(CryptUtil.CRYPT_EXTENSION)) {
-
-                                try {
-
-                                    CryptHandler cryptHandler = new CryptHandler(context);
-                                    EncryptedEntry oldEntry = cryptHandler.findEntry(oldPath);
-                                    EncryptedEntry newEntry = new EncryptedEntry();
-                                    newEntry.setId(oldEntry.getId());
-                                    newEntry.setPassword(oldEntry.getPassword());
-                                    newEntry.setPath(newPath);
-                                    cryptHandler.updateEntry(oldEntry, newEntry);
-                                } catch (Exception e) {
-                                    e.printStackTrace();
-                                    // couldn't change the entry, leave it alone
-                                }
+            public void done(final HybridFile hFile, final boolean b) {
+                context.runOnUiThread(() -> {
+                    if (b) {
+                        Intent intent = new Intent(MainActivity.KEY_INTENT_LOAD_LIST);
+
+                        intent.putExtra(MainActivity.KEY_INTENT_LOAD_LIST_FILE, hFile.getParent(context));
+                        mainActivity.sendBroadcast(intent);
+
+                        // update the database entry to reflect rename for encrypted file
+                        if (oldPath.endsWith(CryptUtil.CRYPT_EXTENSION)) {
+                            try {
+
+                                CryptHandler cryptHandler = new CryptHandler(context);
+                                EncryptedEntry oldEntry = cryptHandler.findEntry(oldPath);
+                                EncryptedEntry newEntry = new EncryptedEntry();
+                                newEntry.setId(oldEntry.getId());
+                                newEntry.setPassword(oldEntry.getPassword());
+                                newEntry.setPath(newPath);
+                                cryptHandler.updateEntry(oldEntry, newEntry);
+                            } catch (Exception e) {
+                                e.printStackTrace();
+                                // couldn't change the entry, leave it alone
                             }
-                        } else
-                            Toast.makeText(context, context.getString(R.string.operationunsuccesful),
-                                    Toast.LENGTH_SHORT).show();
-
-                    }
+                        }
+                    } else
+                        Toast.makeText(context, context.getString(R.string.operationunsuccesful),
+                                Toast.LENGTH_SHORT).show();
                 });
             }
 
             @Override
-            public void invalidName(final HFile file) {
-                context.runOnUiThread(new Runnable() {
-                    @Override
-                    public void run() {
-
-                        if (toast != null) toast.cancel();
-                        Toast.makeText(context, context.getString(R.string.invalid_name) + ": "
-                                + file.getName(), Toast.LENGTH_LONG).show();
-                    }
+            public void invalidName(final HybridFile file) {
+                context.runOnUiThread(() -> {
+                    if (toast != null) toast.cancel();
+                    Toast.makeText(context, context.getString(R.string.invalid_name) + ": "
+                            + file.getName(), Toast.LENGTH_LONG).show();
                 });
             }
         });
@@ -375,167 +347,141 @@ public class MainActivityHelper {
      * Helper method to start Compress service
      *
      * @param file the new compressed file
-     * @param baseFiles list of {@link BaseFile} to be compressed
+     * @param baseFiles list of {@link HybridFileParcelable} to be compressed
      */
-    public void compressFiles(File file, ArrayList<BaseFile> baseFiles) {
+    public void compressFiles(File file, ArrayList<HybridFileParcelable> baseFiles) {
         int mode = checkFolder(file.getParentFile(), mainActivity);
         if (mode == 2) {
             mainActivity.oppathe = (file.getPath());
             mainActivity.operation = DataUtils.COMPRESS;
             mainActivity.oparrayList = baseFiles;
         } else if (mode == 1) {
-            Intent intent2 = new Intent(mainActivity, ZipTask.class);
-            intent2.putExtra(ZipTask.KEY_COMPRESS_PATH, file.getPath());
-            intent2.putExtra(ZipTask.KEY_COMPRESS_FILES, baseFiles);
+            Intent intent2 = new Intent(mainActivity, ZipService.class);
+            intent2.putExtra(ZipService.KEY_COMPRESS_PATH, file.getPath());
+            intent2.putExtra(ZipService.KEY_COMPRESS_FILES, baseFiles);
             ServiceWatcherUtil.runService(mainActivity, intent2);
         } else Toast.makeText(mainActivity, R.string.not_allowed, Toast.LENGTH_SHORT).show();
     }
 
 
-    public void mkFile(final HFile path, final MainFragment ma) {
+    public void mkFile(final HybridFile path, final MainFragment ma) {
         final Toast toast = Toast.makeText(ma.getActivity(), ma.getString(R.string.creatingfile),
                 Toast.LENGTH_SHORT);
         toast.show();
-        Operations.mkfile(path, ma.getActivity(), BaseActivity.rootMode, new Operations.ErrorCallBack() {
+        Operations.mkfile(path, ma.getActivity(), ThemedActivity.rootMode, new Operations.ErrorCallBack() {
             @Override
-            public void exists(final HFile file) {
-                ma.getActivity().runOnUiThread(new Runnable() {
-                    @Override
-                    public void run() {
-                        if (toast != null) toast.cancel();
-                        Toast.makeText(mainActivity, mainActivity.getString(R.string.fileexist),
-                                Toast.LENGTH_SHORT).show();
-                        if (ma != null && ma.getActivity() != null) {
-                            // retry with dialog prompted again
-                            mkfile(file.getMode(), file.getParent(), ma);
-                        }
-
+            public void exists(final HybridFile file) {
+                ma.getActivity().runOnUiThread(() -> {
+                    if (toast != null) toast.cancel();
+                    Toast.makeText(mainActivity, mainActivity.getString(R.string.fileexist),
+                            Toast.LENGTH_SHORT).show();
+                    if (ma != null && ma.getActivity() != null) {
+                        // retry with dialog prompted again
+                        mkfile(file.getMode(), file.getParent(), ma);
                     }
+
                 });
             }
 
             @Override
-            public void launchSAF(HFile file) {
-
-                ma.getActivity().runOnUiThread(new Runnable() {
-                    @Override
-                    public void run() {
-                        if (toast != null) toast.cancel();
-                        mainActivity.oppathe = path.getPath();
-                        mainActivity.operation = DataUtils.NEW_FILE;
-                        guideDialogForLEXA(mainActivity.oppathe);
-                    }
+            public void launchSAF(HybridFile file) {
+
+                ma.getActivity().runOnUiThread(() -> {
+                    if (toast != null) toast.cancel();
+                    mainActivity.oppathe = path.getPath();
+                    mainActivity.operation = DataUtils.NEW_FILE;
+                    guideDialogForLEXA(mainActivity.oppathe);
                 });
 
             }
 
             @Override
-            public void launchSAF(HFile file, HFile file1) {
+            public void launchSAF(HybridFile file, HybridFile file1) {
 
             }
 
             @Override
-            public void done(HFile hFile, final boolean b) {
-                ma.getActivity().runOnUiThread(new Runnable() {
-                    @Override
-                    public void run() {
-
-                        if (b) {
-                            ma.updateList();
-                        } else
-                            Toast.makeText(ma.getActivity(), ma.getString(R.string.operationunsuccesful),
-                                    Toast.LENGTH_SHORT).show();
-
+            public void done(HybridFile hFile, final boolean b) {
+                ma.getActivity().runOnUiThread(() -> {
+                    if (b) {
+                        ma.updateList();
+                    } else {
+                        Toast.makeText(ma.getActivity(), ma.getString(R.string.operationunsuccesful),
+                                Toast.LENGTH_SHORT).show();
                     }
                 });
             }
 
             @Override
-            public void invalidName(final HFile file) {
-                ma.getActivity().runOnUiThread(new Runnable() {
-                    @Override
-                    public void run() {
-
-                        if (toast != null) toast.cancel();
-                        Toast.makeText(ma.getActivity(), ma.getString(R.string.invalid_name)
-                                + ": " + file.getName(), Toast.LENGTH_LONG).show();
-                    }
+            public void invalidName(final HybridFile file) {
+                ma.getActivity().runOnUiThread(() -> {
+                    if (toast != null) toast.cancel();
+                    Toast.makeText(ma.getActivity(), ma.getString(R.string.invalid_name)
+                            + ": " + file.getName(), Toast.LENGTH_LONG).show();
                 });
             }
         });
     }
 
-    public void mkDir(final HFile path, final MainFragment ma) {
+    public void mkDir(final HybridFile path, final MainFragment ma) {
         final Toast toast = Toast.makeText(ma.getActivity(), ma.getString(R.string.creatingfolder),
                 Toast.LENGTH_SHORT);
         toast.show();
-        Operations.mkdir(path, ma.getActivity(), BaseActivity.rootMode, new Operations.ErrorCallBack() {
+        Operations.mkdir(path, ma.getActivity(), ThemedActivity.rootMode, new Operations.ErrorCallBack() {
             @Override
-            public void exists(final HFile file) {
-                ma.getActivity().runOnUiThread(new Runnable() {
-                    @Override
-                    public void run() {
-                        if (toast != null) toast.cancel();
-                        Toast.makeText(mainActivity, mainActivity.getString(R.string.fileexist),
-                                Toast.LENGTH_SHORT).show();
-                        if (ma != null && ma.getActivity() != null) {
-                            // retry with dialog prompted again
-                            mkdir(file.getMode(), file.getParent(), ma);
-                        }
+            public void exists(final HybridFile file) {
+                ma.getActivity().runOnUiThread(() -> {
+                    if (toast != null) toast.cancel();
+                    Toast.makeText(mainActivity, mainActivity.getString(R.string.fileexist),
+                            Toast.LENGTH_SHORT).show();
+                    if (ma != null && ma.getActivity() != null) {
+                        // retry with dialog prompted again
+                        mkdir(file.getMode(), file.getParent(), ma);
                     }
                 });
             }
 
             @Override
-            public void launchSAF(HFile file) {
+            public void launchSAF(HybridFile file) {
                 if (toast != null) toast.cancel();
-                ma.getActivity().runOnUiThread(new Runnable() {
-                    @Override
-                    public void run() {
-                        mainActivity.oppathe = path.getPath();
-                        mainActivity.operation = DataUtils.NEW_FOLDER;
-                        guideDialogForLEXA(mainActivity.oppathe);
-                    }
+                ma.getActivity().runOnUiThread(() -> {
+                    mainActivity.oppathe = path.getPath();
+                    mainActivity.operation = DataUtils.NEW_FOLDER;
+                    guideDialogForLEXA(mainActivity.oppathe);
                 });
 
             }
 
             @Override
-            public void launchSAF(HFile file, HFile file1) {
+            public void launchSAF(HybridFile file, HybridFile file1) {
 
             }
 
             @Override
-            public void done(HFile hFile, final boolean b) {
-                ma.getActivity().runOnUiThread(new Runnable() {
-                    @Override
-                    public void run() {
-
-                        if (b) {
-                            ma.updateList();
-                        } else
-                            Toast.makeText(ma.getActivity(), ma.getString(R.string.operationunsuccesful),
-                                    Toast.LENGTH_SHORT).show();
+            public void done(HybridFile hFile, final boolean b) {
+                ma.getActivity().runOnUiThread(() -> {
+                    if (b) {
+                        ma.updateList();
+                    } else {
+                        Toast.makeText(ma.getActivity(), ma.getString(R.string.operationunsuccesful),
+                                Toast.LENGTH_SHORT).show();
                     }
                 });
             }
 
             @Override
-            public void invalidName(final HFile file) {
-                ma.getActivity().runOnUiThread(new Runnable() {
-                    @Override
-                    public void run() {
-
-                        if (toast != null) toast.cancel();
-                        Toast.makeText(ma.getActivity(), ma.getString(R.string.invalid_name)
-                                + ": " + file.getName(), Toast.LENGTH_LONG).show();
-                    }
+            public void invalidName(final HybridFile file) {
+                ma.getActivity().runOnUiThread(() -> {
+
+                    if (toast != null) toast.cancel();
+                    Toast.makeText(ma.getActivity(), ma.getString(R.string.invalid_name)
+                            + ": " + file.getName(), Toast.LENGTH_LONG).show();
                 });
             }
         });
     }
 
-    public void deleteFiles(ArrayList<BaseFile> files) {
+    public void deleteFiles(ArrayList<HybridFileParcelable> files) {
         if (files == null || files.size() == 0) return;
         if (files.get(0).isSmb()) {
             new DeleteTask(null, mainActivity).execute((files));
@@ -556,9 +502,8 @@ public class MainActivityHelper {
             mainActivity.oppathe = (file.getPath());
             mainActivity.operation = DataUtils.EXTRACT;
         } else if (mode == 1) {
-            Intent intent = new Intent(mainActivity, ExtractService.class);
-            intent.putExtra(ExtractService.KEY_PATH_ZIP, file.getPath());
-            ServiceWatcherUtil.runService(mainActivity, intent);
+            CompressedInterface compressedInterface = CompressedHelper.getCompressedInterfaceInstance(mainActivity, file);
+            compressedInterface.decompress(null);
         } else Toast.makeText(mainActivity, R.string.not_allowed, Toast.LENGTH_SHORT).show();
     }
 
@@ -615,17 +560,17 @@ public class MainActivityHelper {
      *
      * @param query the text query entered the by user
      */
-    public void search(String query) {
-        TabFragment tabFragment = mainActivity.getFragment();
+    public void search(SharedPreferences sharedPrefs, String query) {
+        TabFragment tabFragment = mainActivity.getTabFragment();
         if (tabFragment == null) return;
-        final MainFragment ma = (MainFragment) tabFragment.getTab();
+        final MainFragment ma = (MainFragment) tabFragment.getCurrentTabFragment();
         final String fpath = ma.getCurrentPath();
 
         /*SearchTask task = new SearchTask(ma.searchHelper, ma, query);
                 task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, fpath);*/
         //ma.searchTask = task;
         SEARCH_TEXT = query;
-        mainActivity.mainFragment = (MainFragment) mainActivity.getFragment().getTab();
+        mainActivity.mainFragment = (MainFragment) mainActivity.getTabFragment().getCurrentTabFragment();
         FragmentManager fm = mainActivity.getSupportFragmentManager();
         SearchWorkerFragment fragment =
                 (SearchWorkerFragment) fm.findFragmentByTag(MainActivity.TAG_ASYNC_HELPER);
@@ -637,9 +582,9 @@ public class MainActivityHelper {
             fm.beginTransaction().remove(fragment).commit();
         }
 
-        addSearchFragment(fm, new SearchWorkerFragment(), fpath, query, ma.openMode, BaseActivity.rootMode,
-                mainActivity.sharedPref.getBoolean(SearchWorkerFragment.KEY_REGEX, false),
-                mainActivity.sharedPref.getBoolean(SearchWorkerFragment.KEY_REGEX_MATCHES, false));
+        addSearchFragment(fm, new SearchWorkerFragment(), fpath, query, ma.openMode, ThemedActivity.rootMode,
+                sharedPrefs.getBoolean(SearchWorkerFragment.KEY_REGEX, false),
+                sharedPrefs.getBoolean(SearchWorkerFragment.KEY_REGEX_MATCHES, false));
     }
 
     /**
@@ -677,60 +622,8 @@ public class MainActivityHelper {
      * @param file
      * @return
      */
-    public static boolean isNewDirectoryRecursive(HFile file) {
+    public static boolean isNewDirectoryRecursive(HybridFile file) {
         return file.getName().equals(file.getParentName());
     }
 
-
-
-    public static boolean checkAccountsPermission(Context context) {
-        // Verify that all required contact permissions have been granted.
-        if (ActivityCompat.checkSelfPermission(context, Manifest.permission.GET_ACCOUNTS)
-                != PackageManager.PERMISSION_GRANTED || ActivityCompat.checkSelfPermission(context, Manifest.permission.INTERNET)
-                != PackageManager.PERMISSION_GRANTED) {
-            return false;
-        }
-        return true;
-    }
-
-    public static void requestAccountsPermission(final Activity activity) {
-        final String[] PERMISSIONS = {Manifest.permission.GET_ACCOUNTS,
-                Manifest.permission.INTERNET};
-        if (ActivityCompat.shouldShowRequestPermissionRationale(activity,
-                Manifest.permission.GET_ACCOUNTS) || ActivityCompat.shouldShowRequestPermissionRationale(activity,
-                Manifest.permission.INTERNET)) {
-            // Provide an additional rationale to the user if the permission was not granted
-            // and the user would benefit from additional context for the use of the permission.
-            // For example, if the request has been denied previously.
-
-            String fab_skin = (BaseActivity.accentSkin);
-            final MaterialDialog materialDialog = GeneralDialogCreation.showBasicDialog(activity, fab_skin,
-                    ((UtilitiesProviderInterface) activity).getAppTheme(),
-                    new String[] {
-                            activity.getResources().getString(R.string.grantgplus),
-                            activity.getResources().getString(R.string.grantper),
-                            activity.getResources().getString(R.string.grant),
-                            activity.getResources().getString(R.string.cancel), null
-                    });
-            materialDialog.getActionButton(DialogAction.POSITIVE).setOnClickListener(new View.OnClickListener() {
-                @Override
-                public void onClick(View v) {
-                    ActivityCompat.requestPermissions(activity,PERMISSIONS, 66);
-                    materialDialog.dismiss();
-                }
-            });
-            materialDialog.getActionButton(DialogAction.NEGATIVE).setOnClickListener(new View.OnClickListener() {
-                @Override
-                public void onClick(View v) {
-                    activity.finish();
-                }
-            });
-            materialDialog.setCancelable(false);
-            materialDialog.show();
-
-        } else {
-            // Contact permissions have not been granted yet. Request them directly.
-            ActivityCompat.requestPermissions(activity, PERMISSIONS, 66);
-        }
-    }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/utils/MapEntry.java b/app/src/main/java/com/amaze/filemanager/utils/MapEntry.java
index 3aa07b35c..08424c860 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/MapEntry.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/MapEntry.java
@@ -1,64 +1,19 @@
 package com.amaze.filemanager.utils;
 
-import java.util.LinkedHashMap;
-
 /**
- * Created by Vishal on 21/12/15.
+ * Created by Vishal on 21/12/15 edited by Emmanuel Messulam <emmanuelbendavid@gmail.com>
  * A helper class which provides data structure of key/value pair
+ *
+ * typedef ImmutableEntry<ImmutableEntry<Integer, Integer>, Integer> MapEntry
  */
-public class MapEntry implements LinkedHashMap.Entry {
-
-    private KeyMapEntry key;
-    private Integer value;
+public class MapEntry extends ImmutableEntry<ImmutableEntry<Integer, Integer>, Integer> {
 
     /**
      * Constructor to provide values to the pair
-     * @param key object of {@link KeyMapEntry} which is another key/value pair
+     * @param key object of {@link ImmutableEntry} which is another key/value pair
      * @param value integer object in the pair
      */
-    public MapEntry(KeyMapEntry key, Integer value) {
-        this.key = key;
-        this.value = value;
-    }
-    @Override
-    public Object getKey() {
-        return this.key;
-    }
-
-    @Override
-    public Object getValue() {
-        return this.value;
-    }
-
-    @Override
-    public Object setValue(Object object) {
-        // use constructor
-        return null;
-    }
-
-    public static class KeyMapEntry implements LinkedHashMap.Entry {
-
-        private Integer key, value;
-
-        public KeyMapEntry(Integer key, Integer value) {
-            this.key = key;
-            this.value = value;
-        }
-
-        @Override
-        public Object getKey() {
-            return this.key;
-        }
-
-        @Override
-        public Object getValue() {
-            return this.value;
-        }
-
-        @Override
-        public Object setValue(Object object) {
-            // use constructor
-            return null;
-        }
+    public MapEntry(ImmutableEntry<Integer, Integer> key, Integer value) {
+        super(key, value);
     }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/utils/OTGUtil.java b/app/src/main/java/com/amaze/filemanager/utils/OTGUtil.java
index b72c3439c..2de138a36 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/OTGUtil.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/OTGUtil.java
@@ -8,7 +8,7 @@ import android.support.v4.provider.DocumentFile;
 import android.util.Log;
 
 import com.amaze.filemanager.activities.MainActivity;
-import com.amaze.filemanager.filesystem.BaseFile;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.RootHelper;
 
 import java.util.ArrayList;
@@ -21,7 +21,6 @@ public class OTGUtil {
 
     public static final String PREFIX_OTG = "otg:/";
 
-
     /**
      * Returns an array of list of files at a specific path in OTG
      *
@@ -29,53 +28,57 @@ public class OTGUtil {
      *                Independent of URI (or mount point) for the OTG
      * @param context context for loading
      * @return an array of list of files at the path
+     * @deprecated use getDocumentFiles()
      */
-    public static ArrayList<BaseFile> getDocumentFilesList(String path, Context context) {
+    public static ArrayList<HybridFileParcelable> getDocumentFilesList(String path, Context context) {
+        final ArrayList<HybridFileParcelable> files = new ArrayList<>();
+        getDocumentFiles(path, context, files::add);
+        return files;
+    }
+
+    /**
+     * Get the files at a specific path in OTG
+     *
+     * @param path    the path to the directory tree, starts with prefix 'otg:/'
+     *                Independent of URI (or mount point) for the OTG
+     * @param context context for loading
+     * @return an array of list of files at the path
+     */
+    public static void getDocumentFiles(String path, Context context, OnFileFound fileFound) {
         SharedPreferences manager = PreferenceManager.getDefaultSharedPreferences(context);
         String rootUriString = manager.getString(MainActivity.KEY_PREF_OTG, null);
         DocumentFile rootUri = DocumentFile.fromTreeUri(context, Uri.parse(rootUriString));
-        ArrayList<BaseFile> files = new ArrayList<>();
 
         String[] parts = path.split("/");
-        for (int i = 0; i < parts.length; i++) {
-
+        for (String part : parts) {
             // first omit 'otg:/' before iterating through DocumentFile
             if (path.equals(OTGUtil.PREFIX_OTG + "/")) break;
-            if (parts[i].equals("otg:") || parts[i].equals("")) continue;
-            Log.d(context.getClass().getSimpleName(), "Currently at: " + parts[i]);
+            if (part.equals("otg:") || part.equals("")) continue;
+
             // iterating through the required path to find the end point
-            rootUri = rootUri.findFile(parts[i]);
+            rootUri = rootUri.findFile(part);
         }
 
-        Log.d(context.getClass().getSimpleName(), "Found URI for: " + rootUri.getName());
         // we have the end point DocumentFile, list the files inside it and return
         for (DocumentFile file : rootUri.listFiles()) {
-            try {
-                if (file.exists()) {
-                    long size = 0;
-                    if (!file.isDirectory()) size = file.length();
-                    Log.d(context.getClass().getSimpleName(), "Found file: " + file.getName());
-                    BaseFile baseFile = new BaseFile(path + "/" + file.getName(),
-                            RootHelper.parseDocumentFilePermission(file), file.lastModified(), size, file.isDirectory());
-                    baseFile.setName(file.getName());
-                    baseFile.setMode(OpenMode.OTG);
-                    files.add(baseFile);
-                }
-            } catch (Exception e) {
+            if (file.exists()) {
+                long size = 0;
+                if (!file.isDirectory()) size = file.length();
+                Log.d(context.getClass().getSimpleName(), "Found file: " + file.getName());
+                HybridFileParcelable baseFile = new HybridFileParcelable(path + "/" + file.getName(),
+                        RootHelper.parseDocumentFilePermission(file), file.lastModified(), size, file.isDirectory());
+                baseFile.setName(file.getName());
+                baseFile.setMode(OpenMode.OTG);
+                fileFound.onFileFound(baseFile);
             }
         }
-
-        return files;
     }
 
     /**
      * Traverse to a specified path in OTG
      *
-     * @param path
-     * @param context
      * @param createRecursive flag used to determine whether to create new file while traversing to path,
      *                        in case path is not present. Notably useful in opening an output stream.
-     * @return
      */
     public static DocumentFile getDocumentFile(String path, Context context, boolean createRecursive) {
         SharedPreferences manager = PreferenceManager.getDefaultSharedPreferences(context);
@@ -85,22 +88,18 @@ public class OTGUtil {
         DocumentFile rootUri = DocumentFile.fromTreeUri(context, Uri.parse(rootUriString));
 
         String[] parts = path.split("/");
-        for (int i = 0; i < parts.length; i++) {
-
+        for (String part : parts) {
             if (path.equals("otg:/")) break;
-            if (parts[i].equals("otg:") || parts[i].equals("")) continue;
-            Log.d(context.getClass().getSimpleName(), "Currently at: " + parts[i]);
-            // iterating through the required path to find the end point
+            if (part.equals("otg:") || part.equals("")) continue;
 
-            DocumentFile nextDocument = rootUri.findFile(parts[i]);
-            if (createRecursive) {
-                if (nextDocument == null || !nextDocument.exists()) {
-                    nextDocument = rootUri.createFile(parts[i].substring(parts[i].lastIndexOf(".")), parts[i]);
-                    Log.d(context.getClass().getSimpleName(), "NOT FOUND! File created: " + parts[i]);
-                }
+            // iterating through the required path to find the end point
+            DocumentFile nextDocument = rootUri.findFile(part);
+            if (createRecursive && (nextDocument == null || !nextDocument.exists())) {
+                nextDocument = rootUri.createFile(part.substring(part.lastIndexOf(".")), part);
             }
             rootUri = nextDocument;
         }
+
         return rootUri;
     }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/utils/OnAsyncTaskFinished.java b/app/src/main/java/com/amaze/filemanager/utils/OnAsyncTaskFinished.java
new file mode 100644
index 000000000..b47256b31
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/utils/OnAsyncTaskFinished.java
@@ -0,0 +1,10 @@
+package com.amaze.filemanager.utils;
+
+/**
+ * @author Emmanuel
+ *         on 14/9/2017, at 21:00.
+ */
+
+public interface OnAsyncTaskFinished<T> {
+    void onAsyncTaskFinished(T data);
+}
diff --git a/app/src/main/java/com/amaze/filemanager/utils/OnFileFound.java b/app/src/main/java/com/amaze/filemanager/utils/OnFileFound.java
new file mode 100644
index 000000000..ecc213586
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/utils/OnFileFound.java
@@ -0,0 +1,14 @@
+package com.amaze.filemanager.utils;
+
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
+
+/**
+ * This allows the caller of a function to know when a file has ben found and deal with it ASAP
+ *
+ * @author Emmanuel
+ *         on 21/9/2017, at 15:23.
+ */
+
+public interface OnFileFound {
+    void onFileFound(HybridFileParcelable file);
+}
diff --git a/app/src/main/java/com/amaze/filemanager/utils/PreferenceUtils.java b/app/src/main/java/com/amaze/filemanager/utils/PreferenceUtils.java
index f4e7df77e..6a88eee2e 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/PreferenceUtils.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/PreferenceUtils.java
@@ -1,15 +1,11 @@
 package com.amaze.filemanager.utils;
 
-import android.content.SharedPreferences;
 import android.graphics.Color;
 
-import java.util.Calendar;
-
 /**
  * Created by Vishal on 12-05-2015.
  */
 public class PreferenceUtils {
-    private static int primary = -1, accent = -1, folder = -1, primaryTwo = -1;
 
     public static final String KEY_PRIMARY_TWO = "skin_two";
     public static final String KEY_PRIMARY = "skin";
@@ -25,43 +21,22 @@ public class PreferenceUtils {
     public static final int DEFAULT_CURRENT_TAB = 1;
 
     public static int getStatusColor(String skin) {
-        return darker(Color.parseColor(skin),0.6f);
+        return darker(Color.parseColor(skin));
     }
 
     public static int getStatusColor(int skin) {
-        return darker(skin,0.6f);
+        return darker(skin);
     }
 
-    public static int darker (int color, float factor) {
+    private static int darker(int color) {
         int a = Color.alpha(color);
-        int r = Color.red( color );
-        int g = Color.green( color );
-        int b = Color.blue( color );
-
-        return Color.argb( a,
-                Math.max( (int)(r * factor), 0 ),
-                Math.max( (int)(g * factor), 0 ),
-                Math.max( (int)(b * factor), 0 ) );
-    }
-
-    /**
-     * Get primary color of second tab from preferences
-     * @return the color position in color array; from the preferences
-     */
-    public static int getPrimaryTwoColor(SharedPreferences Sp) {
-        return primaryTwo==-1 ? Sp.getInt(KEY_PRIMARY_TWO, DEFAULT_PRIMARY) : null;
-    }
-
-    public static int getFolderColor(SharedPreferences Sp){
-        if(folder==DEFAULT_ICON) {
-            int icon = Sp.getInt(KEY_ICON_SKIN, DEFAULT_ICON);
-            folder = icon == DEFAULT_ICON ? Sp.getInt(KEY_ACCENT, DEFAULT_ACCENT) : icon;
-        }
-        return folder;
-    }
+        int r = Color.red(color);
+        int g = Color.green(color);
+        int b = Color.blue(color);
 
-    public static void reset(){
-        primary=accent=folder=primaryTwo=-1;
+        return Color.argb(a, Math.max((int) (r * 0.6f), 0),
+                Math.max((int) (g * 0.6f), 0),
+                Math.max((int) (b * 0.6f), 0));
     }
 
     public static final String LICENCE_TERMS = "<html><body>" +
@@ -300,13 +275,4 @@ public class PreferenceUtils {
             "<br><br></code></p>" +
             "</body></html>";
 
-    @Deprecated
-    public static int hourOfDay() {
-        Calendar calendar = Calendar.getInstance();
-        int hour = calendar.get(Calendar.HOUR_OF_DAY);
-        if (hour <= 6 || hour >= 18) {
-            return 1;
-        } else
-            return 0;
-    }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/utils/ProgressHandler.java b/app/src/main/java/com/amaze/filemanager/utils/ProgressHandler.java
index 044a6d3f3..03db39a23 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/ProgressHandler.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/ProgressHandler.java
@@ -1,12 +1,14 @@
 package com.amaze.filemanager.utils;
 
+import com.amaze.filemanager.fragments.ProcessViewerFragment;
+
 /**
  * Created by arpitkh96 on 18/8/16.
  *
  * Base class to handle progress of services operation
  * Utilized for generation of notification,
- * talking to {@link com.amaze.filemanager.fragments.ProcessViewer} through
- * {@link com.amaze.filemanager.utils.DataPackage}
+ * talking to {@link ProcessViewerFragment} through
+ * {@link CopyDataParcelable}
  *
  */
 public class ProgressHandler {
diff --git a/app/src/main/java/com/amaze/filemanager/utils/RootUtils.java b/app/src/main/java/com/amaze/filemanager/utils/RootUtils.java
index 2684f9c5a..47118f4d4 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/RootUtils.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/RootUtils.java
@@ -4,14 +4,20 @@ package com.amaze.filemanager.utils;
  * Created by arpitkh996 on 25-01-2016.
  */
 
-import com.amaze.filemanager.exceptions.RootNotPermittedException;
+import com.amaze.filemanager.exceptions.ShellNotRunningException;
 import com.amaze.filemanager.filesystem.RootHelper;
 
 import java.util.ArrayList;
 import java.util.regex.Pattern;
 
 public class RootUtils {
+    public static final int CHMOD_READ = 4, CHMOD_WRITE = 2, CHMOD_EXECUTE = 1;
     public static final String DATA_APP_DIR = "/data/app";
+    /**
+     * This is the chmod command, it should be used with String.format().
+     * String.format(CHMOD_COMMAND, options, permsOctalInt, path);
+     */
+    public static final String CHMOD_COMMAND = "chmod %s %o \"%s\"";
     private static final String LS = "ls -lAnH \"%\" --color=never";
     private static final String LSDIR = "ls -land \"%\" --color=never";
     public static final String SYSTEM_APP_DIR = "/system/app";
@@ -21,55 +27,15 @@ public class RootUtils {
         mLsPattern = Pattern.compile(".[rwxsStT-]{9}\\s+.*");
     }
 
-    public static boolean isValid(String str) {
-        return mLsPattern.matcher(str).matches();
-    }
-
-    public static boolean isUnixVirtualDirectory(String str) {
-        return str.startsWith("/proc") || str.startsWith("/sys");
-    }
-
-    /**
-     * Get a shell based listing
-     * Context is superuser level shell
-     * @param str
-     * @return
-     */
-    public static ArrayList<String> getDirListingSu(String str) throws RootNotPermittedException {
-        ArrayList<String> arrayLis=RootHelper.runShellCommand(LS.replace("%", str));
-        return arrayLis;
-    }
-
-    /**
-     * Change permissions (owner/group/others) of a specified path
-     * @param path
-     * @param octalNotation octal notation of permission
-     * @throws RootNotPermittedException
-     */
-    public static void chmod(String path, int octalNotation) throws RootNotPermittedException {
-
-        String mountPoint = mountFileSystemRW(path);
-
-        String command = "chmod %d \"%s\"";
-
-        RootHelper.runShellCommand(String.format(command, octalNotation, path));
-
-        if (mountPoint!=null) {
-            // we mounted the filesystem as rw, let's mount it back to ro
-            mountFileSystemRO(mountPoint);
-        }
-    }
-
-
     /**
      * Mount filesystem associated with path for writable access (rw)
      * Since we don't have the root of filesystem to remount, we need to parse output of
      * # mount command.
+     *
      * @param path the path on which action to perform
      * @return String the root of mount point that was ro, and mounted to rw; null otherwise
-     * @throws RootNotPermittedException
      */
-    private static String mountFileSystemRW(String path) throws RootNotPermittedException {
+    private static String mountFileSystemRW(String path) throws ShellNotRunningException {
         String command = "mount";
         ArrayList<String> output = RootHelper.runShellCommand(command);
         String mountPoint = "", types = null;
@@ -87,8 +53,7 @@ public class RootUtils {
             }
         }
 
-        if (!mountPoint.equals("") && types!=null) {
-
+        if (!mountPoint.equals("") && types != null) {
             // we have the mountpoint, check for mount options if already rw
             if (types.contains("rw")) {
                 // already a rw filesystem return
@@ -98,7 +63,7 @@ public class RootUtils {
                 String mountCommand = "mount -o rw,remount " + mountPoint;
                 ArrayList<String> mountOutput = RootHelper.runShellCommand(mountCommand);
 
-                if (mountOutput.size()!=0) {
+                if (mountOutput.size() != 0) {
                     // command failed, and we got a reason echo'ed
                     return null;
                 } else return mountPoint;
@@ -109,28 +74,24 @@ public class RootUtils {
 
     /**
      * Mount path for read-only access (ro)
+     *
      * @param path the root of device/filesystem to be mounted as ro
-     * @throws RootNotPermittedException
      */
-    private static void mountFileSystemRO(String path) throws RootNotPermittedException {
+    private static void mountFileSystemRO(String path) throws ShellNotRunningException {
         String command = "umount -r \"" + path + "\"";
         RootHelper.runShellCommand(command);
     }
 
     /**
      * Copies file using root
-     * @param source
-     * @param destination
-     * @throws RootNotPermittedException
      */
-    public static void copy(String source, String destination) throws RootNotPermittedException {
-
+    public static void copy(String source, String destination) throws ShellNotRunningException {
         // remounting destination as rw
         String mountPoint = mountFileSystemRW(destination);
 
         RootHelper.runShellCommand("cp \"" + source + "\" \"" + destination + "\"");
 
-        if (mountPoint!=null) {
+        if (mountPoint != null) {
             // we mounted the filesystem as rw, let's mount it back to ro
             mountFileSystemRO(mountPoint);
         }
@@ -138,16 +99,16 @@ public class RootUtils {
 
     /**
      * Creates an empty directory using root
+     *
      * @param path path to new directory
      * @param name name of directory
-     * @throws RootNotPermittedException
      */
-    public static void mkDir(String path, String name) throws RootNotPermittedException {
+    public static void mkDir(String path, String name) throws ShellNotRunningException {
 
         String mountPoint = mountFileSystemRW(path);
 
         RootHelper.runShellCommand("mkdir \"" + path + "/" + name + "\"");
-        if (mountPoint!=null) {
+        if (mountPoint != null) {
             // we mounted the filesystem as rw, let's mount it back to ro
             mountFileSystemRO(mountPoint);
         }
@@ -155,28 +116,24 @@ public class RootUtils {
 
     /**
      * Creates an empty file using root
+     *
      * @param path path to new file
-     * @throws RootNotPermittedException
      */
-    public static void mkFile(String path) throws RootNotPermittedException {
-
+    public static void mkFile(String path) throws ShellNotRunningException {
         String mountPoint = mountFileSystemRW(path);
 
-        RootHelper.runShellCommand("touch \"" + path +"\"");
-        if (mountPoint!=null) {
+        RootHelper.runShellCommand("touch \"" + path + "\"");
+        if (mountPoint != null) {
             // we mounted the filesystem as rw, let's mount it back to ro
             mountFileSystemRO(mountPoint);
         }
     }
 
-
     /**
      * Returns file permissions in octal notation
      * Method requires busybox
-     * @param path
-     * @return
      */
-    private static int getFilePermissions(String path) throws RootNotPermittedException {
+    private static int getFilePermissions(String path) throws ShellNotRunningException {
         String line = RootHelper.runShellCommand("stat -c  %a \"" + path + "\"").get(0);
 
         return Integer.valueOf(line);
@@ -184,45 +141,32 @@ public class RootUtils {
 
     /**
      * Recursively removes a path with it's contents (if any)
-     * @param path
+     *
      * @return boolean whether file was deleted or not
-     * @throws RootNotPermittedException
      */
-    public static boolean delete(String path) throws RootNotPermittedException {
-
+    public static boolean delete(String path) throws ShellNotRunningException {
         String mountPoint = mountFileSystemRW(path);
-
         ArrayList<String> result = RootHelper.runShellCommand("rm -rf \"" + path + "\"");
 
-        if (mountPoint!=null) {
+        if (mountPoint != null) {
             // we mounted the filesystem as rw, let's mount it back to ro
             mountFileSystemRO(mountPoint);
         }
 
-        return result.size()!=0;
+        return result.size() != 0;
     }
 
-    /*public static boolean isBusyboxAvailable() throws RootNotPermittedException {
-        ArrayList<String> output = RootHelper.runShellCommand("busybox");
-        return output.size()!=0;
-    }*/
-
     /**
      * Moves file using root
-     * @param path
-     * @param destination
-     * @throws RootNotPermittedException
      */
-    public static void move(String path, String destination)
-            throws RootNotPermittedException {
-
+    public static void move(String path, String destination) throws ShellNotRunningException {
         // remounting destination as rw
         String mountPoint = mountFileSystemRW(destination);
 
         //mountOwnerRW(mountPath);
         RootHelper.runShellCommand("mv \"" + path + "\" \"" + destination + "\"");
 
-        if (mountPoint!=null) {
+        if (mountPoint != null) {
             // we mounted the filesystem as rw, let's mount it back to ro
             mountFileSystemRO(mountPoint);
         }
@@ -230,74 +174,48 @@ public class RootUtils {
 
     /**
      * Renames file using root
+     *
      * @param oldPath path to file before rename
      * @param newPath path to file after rename
-     * @throws RootNotPermittedException
      * @return if rename was successful or not
      */
-    public static boolean rename(String oldPath, String newPath)
-            throws RootNotPermittedException {
-
+    public static boolean rename(String oldPath, String newPath) throws ShellNotRunningException {
         String mountPoint = mountFileSystemRW(oldPath);
-
         ArrayList<String> output = RootHelper.runShellCommand("mv \"" + oldPath + "\" \"" + newPath + "\"");
 
-        if (mountPoint!=null) {
+        if (mountPoint != null) {
             // we mounted the filesystem as rw, let's mount it back to ro
             mountFileSystemRO(mountPoint);
         }
 
-        return output.size()==0;
+        return output.size() == 0;
     }
 
     public static void cat(String sourcePath, String destinationPath)
-            throws RootNotPermittedException {
+            throws ShellNotRunningException {
 
         String mountPoint = mountFileSystemRW(destinationPath);
 
         RootHelper.runShellCommand("cat \"" + sourcePath + "\" > \"" + destinationPath + "\"");
-        if (mountPoint!=null) {
+        if (mountPoint != null) {
             // we mounted the filesystem as rw, let's mount it back to ro
             mountFileSystemRO(mountPoint);
         }
     }
 
-    public static String parsePermission(String permLine) {
-        int owner = 0;
-        int READ = 4;
-        int WRITE = 2;
-        int EXECUTE = 1;
-        if (permLine.charAt(1) == 'r') {
-            owner += READ;
-        }
-        if (permLine.charAt(2) == 'w') {
-            owner += WRITE;
-        }
-        if (permLine.charAt(3) == 'x') {
-            owner += EXECUTE;
-        }
-        int group = 0;
-        if (permLine.charAt(4) == 'r') {
-            group += READ;
-        }
-        if (permLine.charAt(5) == 'w') {
-            group += WRITE;
-        }
-        if (permLine.charAt(6) == 'x') {
-            group += EXECUTE;
-        }
-        int world = 0;
-        if (permLine.charAt(7) == 'r') {
-            world += READ;
-        }
-        if (permLine.charAt(8) == 'w') {
-            world += WRITE;
-        }
-        if (permLine.charAt(9) == 'x') {
-            world += EXECUTE;
-        }
-        String finalValue = owner + "" + group + "" + world;
-        return finalValue;
+    /**
+     * This converts from a set of booleans to OCTAL permissions notations.
+     * For use with {@link RootUtils.CHMOD_COMMAND}
+     * (true, false, false,  true, true, false,  false, false, true) => 0461
+     */
+    public static int permissionsToOctalString(boolean ur, boolean uw, boolean ux,
+                                                  boolean gr, boolean gw, boolean gx,
+                                                  boolean or, boolean ow, boolean ox) {
+        int u = ((ur?CHMOD_READ:0) | (uw?CHMOD_WRITE:0) | (ux?CHMOD_EXECUTE:0)) << 6;
+        int g = ((gr?CHMOD_READ:0) | (gw?CHMOD_WRITE:0) | (gx?CHMOD_EXECUTE:0)) << 3;
+        int o = (or?CHMOD_READ:0) | (ow?CHMOD_WRITE:0) | (ox?CHMOD_EXECUTE:0);
+        return u | g | o;
     }
+
 }
 
diff --git a/app/src/main/java/com/amaze/filemanager/utils/ServiceWatcherUtil.java b/app/src/main/java/com/amaze/filemanager/utils/ServiceWatcherUtil.java
index 91ca2f42a..a1e573560 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/ServiceWatcherUtil.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/ServiceWatcherUtil.java
@@ -16,6 +16,7 @@ import android.os.HandlerThread;
 import android.support.v4.app.NotificationCompat;
 
 import com.amaze.filemanager.R;
+import com.amaze.filemanager.ui.notifications.NotificationConstants;
 
 import java.util.ArrayList;
 
@@ -157,12 +158,14 @@ public class ServiceWatcherUtil {
         final Handler handler = new Handler(waitingThread.getLooper());
         final NotificationManager notificationManager = (NotificationManager)
                 context.getSystemService(Context.NOTIFICATION_SERVICE);
-        final NotificationCompat.Builder mBuilder=new NotificationCompat.Builder(context);
-        mBuilder.setContentTitle(context.getString(R.string.waiting_title));
-        mBuilder.setContentText(context.getString(R.string.waiting_content));
-        mBuilder.setAutoCancel(false);
-        mBuilder.setSmallIcon(R.drawable.ic_all_inclusive_white_36dp);
-        mBuilder.setProgress(0, 0, true);
+        final NotificationCompat.Builder mBuilder=new NotificationCompat.Builder(context, NotificationConstants.CHANNEL_NORMAL_ID)
+                .setContentTitle(context.getString(R.string.waiting_title))
+                .setContentText(context.getString(R.string.waiting_content))
+                .setAutoCancel(false)
+                .setSmallIcon(R.drawable.ic_all_inclusive_white_36dp)
+                .setProgress(0, 0, true);
+
+        NotificationConstants.setMetadata(context, mBuilder);
 
         Runnable runnable = new Runnable() {
             @Override
diff --git a/app/src/main/java/com/amaze/filemanager/utils/SmbStreamer/StreamServer.java b/app/src/main/java/com/amaze/filemanager/utils/SmbStreamer/StreamServer.java
index 555fb729e..262d5344d 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/SmbStreamer/StreamServer.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/SmbStreamer/StreamServer.java
@@ -18,7 +18,6 @@ import java.io.OutputStream;
 import java.io.PrintWriter;
 import java.net.ServerSocket;
 import java.net.Socket;
-import java.net.URLEncoder;
 import java.util.Date;
 import java.util.Enumeration;
 import java.util.Locale;
@@ -92,44 +91,16 @@ public abstract class StreamServer {
      * HTTP response.
      * Return one of these from serve().
      */
-    public class Response
-    {
-        /**
-         * Default constructor: response = HTTP_OK, data = mime = 'null'
-         */
-        public Response()
-        {
-            this.status = HTTP_OK;
-        }
-
+    public class Response {
         /**
          * Basic constructor.
          */
-        public Response( String status, String mimeType, StreamSource data )
-        {
+        public Response( String status, String mimeType, StreamSource data ) {
             this.status = status;
             this.mimeType = mimeType;
             this.data = data;
         }
 
-        /**
-         * Convenience method that makes an InputStream out of
-         * given text.
-         */
-        //              public Response( String status, String mimeType, String txt )
-        //              {
-        //                      this.status = status;
-        //                      this.mimeType = mimeType;
-        //                      try
-        //                      {
-        //                              this.data = new ByteArrayInputStream( txt.getBytes("UTF-8"));
-        //                      }
-        //                      catch ( java.io.UnsupportedEncodingException uee )
-        //                      {
-        //                              uee.printStackTrace();
-        //                      }
-        //              }
-
         /**
          * Adds given line to the header.
          */
@@ -193,167 +164,71 @@ public abstract class StreamServer {
      */
 
     //private HTTPSession session;
-    public StreamServer( int port, File wwwroot ) throws IOException
-    {
+    public StreamServer( int port, File wwwroot ) throws IOException {
         myTcpPort = port;
         this.myRootDir = wwwroot;
         myServerSocket = new ServerSocket( myTcpPort );
-        myThread = new Thread( new Runnable()
-        {
-            public void run()
-            {
-                try
-                {
-                    while( true ){
-                        //                                                      if(session!=null){
-                        //                                                              session.interrupt();
-                        //                                                              try {
-                        //                                                                      session.join();
-                        //                                                              } catch (InterruptedException e) {
-                        //                                                                      e.printStackTrace();
-                        //                                                              }
-                        //                                                      }
-                        Socket accept = myServerSocket.accept();
-                        new HTTPSession(accept);
-                    }
+        myThread = new Thread(() -> {
+            try {
+                while (true) {
+                    Socket accept = myServerSocket.accept();
+                    new HTTPSession(accept);
                 }
-                catch ( IOException ioe )
-                {}
+            } catch (IOException ioe) {
             }
         });
         myThread.setDaemon( true );
         myThread.start();
     }
 
-    public StreamServer( File wwwroot ) throws IOException
-    {
-        this.myRootDir = wwwroot;
-        myServerSocket = new ServerSocket( myTcpPort );
-        myThread = new Thread( new Runnable()
-        {
-            public void run()
-            {
-                try
-                {
-                    while( true ){
-                        //                                                      if(session!=null){
-                        //                                                              session.interrupt();
-                        //                                                              try {
-                        //                                                                      session.join();
-                        //                                                              } catch (InterruptedException e) {
-                        //                                                                      e.printStackTrace();
-                        //                                                              }
-                        //                                                      }
-                        Socket accept = myServerSocket.accept();
-                        new HTTPSession(accept);
-                    }
-                }
-                catch ( IOException ioe )
-                {}
-            }
-        });
-        myThread.setDaemon( true );
-        myThread.start();
-    }
 
     /**
      * Stops the server.
      */
-    public void stop()
-    {
-        try
-        {
+    public void stop() {
+        try {
             myServerSocket.close();
             myThread.join();
+        } catch (IOException | InterruptedException e) {
         }
-        catch ( IOException ioe ) {}
-        catch ( InterruptedException e ) {}
     }
 
-    //
-    //      /**
-    //       * Starts as a standalone file server and waits for Enter.
-    //       */
-    //      public static void main( String[] args )
-    //      {
-    //              System.out.println( "NanoHTTPD 1.24 (C) 2001,2005-2011 Jarno Elonen and (C) 2010 Konstantinos Togias\n" +
-    //                                                      "(Command line options: [-p port] [-d root-dir] [--licence])\n" );
-    //
-    //              // Defaults
-    //              int port = 80;
-    //              File wwwroot = new File(".").getAbsoluteFile();
-    //
-    //              // Show licence if requested
-    //              for ( int i=0; i<args.length; ++i )
-    //              if(args[i].equalsIgnoreCase("-p"))
-    //                      port = Integer.parseInt( args[i+1] );
-    //              else if(args[i].equalsIgnoreCase("-d"))
-    //                      wwwroot = new File( args[i+1] ).getAbsoluteFile();
-    //              else if ( args[i].toLowerCase().endsWith( "licence" ))
-    //              {
-    //                      System.out.println( LICENCE + "\n" );
-    //                      break;
-    //              }
-    //
-    //              try
-    //              {
-    //                      new NanoHTTPD( port, wwwroot );
-    //              }
-    //              catch( IOException ioe )
-    //              {
-    //                      System.err.println( "Couldn't start server:\n" + ioe );
-    //                      System.exit( -1 );
-    //              }
-    //
-    //              System.out.println( "Now serving files in port " + port + " from \"" + wwwroot + "\"" );
-    //              System.out.println( "Hit Enter to stop.\n" );
-    //
-    //              try { System.in.read(); } catch( Throwable t ) {}
-    //      }
-
     /**
      * Handles one session, i.e. parses the HTTP request
      * and returns the response.
      */
-    private class HTTPSession implements Runnable
-    {
+    private class HTTPSession implements Runnable {
         private InputStream is;
         private final Socket socket;
 
-        public HTTPSession( Socket s )
-        {
+        public HTTPSession(Socket s) {
             socket = s;
             //mySocket = s;
-            Thread t = new Thread( this );
-            t.setDaemon( true );
+            Thread t = new Thread(this);
+            t.setDaemon(true);
             t.start();
         }
 
-        public void run()
-        {
-            try{
+        public void run() {
+            try {
                 //openInputStream();
                 handleResponse(socket);
-            }finally {
-                if(is!=null) {
-                    try{
+            } finally {
+                if (is != null) {
+                    try {
                         is.close();
                         socket.close();
-                    }catch(IOException e){
+                    } catch (IOException e) {
                         e.printStackTrace();
                     }
                 }
             }
         }
 
-//              private void openInputStream() throws IOException {
-//                      is = socket.getInputStream();
-//              }
-
         private void handleResponse(Socket socket) {
             try {
                 is = socket.getInputStream();
-                if ( is == null) return;
+                if (is == null) return;
 
                 // Read the first 8192 bytes.
                 // The full header should fit in here.
@@ -365,7 +240,7 @@ public abstract class StreamServer {
 
                 // Create a BufferedReader for parsing the header.
                 ByteArrayInputStream hbis = new ByteArrayInputStream(buf, 0, rlen);
-                BufferedReader hin = new BufferedReader( new InputStreamReader( hbis , "utf-8"));
+                BufferedReader hin = new BufferedReader(new InputStreamReader(hbis, "utf-8"));
                 Properties pre = new Properties();
                 Properties parms = new Properties();
                 Properties header = new Properties();
@@ -374,25 +249,25 @@ public abstract class StreamServer {
                 // Decode the header into parms and header java properties
                 decodeHeader(hin, pre, parms, header);
                 Log.d("Explorer", pre.toString());
-                Log.d("Explorer", "Params: "+parms.toString());
-                Log.d("Explorer", "Header: "+header.toString());
+                Log.d("Explorer", "Params: " + parms.toString());
+                Log.d("Explorer", "Header: " + header.toString());
                 String method = pre.getProperty("method");
                 String uri = pre.getProperty("uri");
 
                 long size = 0x7FFFFFFFFFFFFFFFL;
                 String contentLength = header.getProperty("content-length");
-                if (contentLength != null)
-                {
-                    try { size = Integer.parseInt(contentLength); }
-                    catch (NumberFormatException ex) {}
+                if (contentLength != null) {
+                    try {
+                        size = Integer.parseInt(contentLength);
+                    } catch (NumberFormatException ex) {
+                    }
                 }
 
                 // We are looking for the byte separating header from body.
                 // It must be the last byte of the first two sequential new lines.
                 int splitbyte = 0;
                 boolean sbfound = false;
-                while (splitbyte < rlen)
-                {
+                while (splitbyte < rlen) {
                     if (buf[splitbyte] == '\r' && buf[++splitbyte] == '\n' && buf[++splitbyte] == '\r' && buf[++splitbyte] == '\n') {
                         sbfound = true;
                         break;
@@ -403,7 +278,7 @@ public abstract class StreamServer {
 
                 // Write the part of body already read to ByteArrayOutputStream f
                 ByteArrayOutputStream f = new ByteArrayOutputStream();
-                if (splitbyte < rlen) f.write(buf, splitbyte, rlen-splitbyte);
+                if (splitbyte < rlen) f.write(buf, splitbyte, rlen - splitbyte);
 
                 // While Firefox sends on the first read all the data fitting
                 // our buffer, Chrome and Opera sends only the headers even if
@@ -412,14 +287,13 @@ public abstract class StreamServer {
                 // have reached the end of the data to be sent or we should
                 // expect the first byte of the body at the next read.
                 if (splitbyte < rlen)
-                    size -= rlen - splitbyte +1;
+                    size -= rlen - splitbyte + 1;
                 else if (!sbfound || size == 0x7FFFFFFFFFFFFFFFL)
                     size = 0;
 
                 // Now read all the body and write it to f
                 buf = new byte[512];
-                while ( rlen >= 0 && size > 0 )
-                {
+                while (rlen >= 0 && size > 0) {
                     rlen = is.read(buf, 0, 512);
                     size -= rlen;
                     if (rlen > 0)
@@ -427,75 +301,65 @@ public abstract class StreamServer {
                 }
 
                 // Get the raw body as a byte []
-                byte [] fbuf = f.toByteArray();
+                byte[] fbuf = f.toByteArray();
 
                 // Create a BufferedReader for easily reading it as string.
                 ByteArrayInputStream bin = new ByteArrayInputStream(fbuf);
-                BufferedReader in = new BufferedReader( new InputStreamReader(bin));
+                BufferedReader in = new BufferedReader(new InputStreamReader(bin));
 
                 // If the method is POST, there may be parameters
                 // in data section, too, read it:
-                if ( method.equalsIgnoreCase( "POST" ))
-                {
+                if (method.equalsIgnoreCase("POST")) {
                     String contentType = "";
                     String contentTypeHeader = header.getProperty("content-type");
-                    StringTokenizer st = new StringTokenizer( contentTypeHeader , "; " );
-                    if ( st.hasMoreTokens()) {
+                    StringTokenizer st = new StringTokenizer(contentTypeHeader, "; ");
+                    if (st.hasMoreTokens()) {
                         contentType = st.nextToken();
                     }
 
-                    if (contentType.equalsIgnoreCase("multipart/form-data"))
-                    {
+                    if (contentType.equalsIgnoreCase("multipart/form-data")) {
                         // Handle multipart/form-data
-                        if ( !st.hasMoreTokens())
-                            sendError(socket, HTTP_BADREQUEST, "BAD REQUEST: Content type is multipart/form-data but boundary missing. Usage: GET /example/file.html" );
+                        if (!st.hasMoreTokens())
+                            sendError(socket, HTTP_BADREQUEST, "BAD REQUEST: Content type is multipart/form-data but boundary missing. Usage: GET /example/file.html");
                         String boundaryExp = st.nextToken();
-                        st = new StringTokenizer( boundaryExp , "=" );
+                        st = new StringTokenizer(boundaryExp, "=");
                         if (st.countTokens() != 2)
-                            sendError(socket, HTTP_BADREQUEST, "BAD REQUEST: Content type is multipart/form-data but boundary syntax error. Usage: GET /example/file.html" );
+                            sendError(socket, HTTP_BADREQUEST, "BAD REQUEST: Content type is multipart/form-data but boundary syntax error. Usage: GET /example/file.html");
                         st.nextToken();
                         String boundary = st.nextToken();
 
                         decodeMultipartData(boundary, fbuf, in, parms, files);
-                    }
-                    else
-                    {
+                    } else {
                         // Handle application/x-www-form-urlencoded
                         String postLine = "";
                         char pbuf[] = new char[512];
                         int read = in.read(pbuf);
-                        while ( read >= 0 && !postLine.endsWith("\r\n") )
-                        {
+                        while (read >= 0 && !postLine.endsWith("\r\n")) {
                             postLine += String.valueOf(pbuf, 0, read);
                             read = in.read(pbuf);
-                            if(Thread.interrupted()){
+                            if (Thread.interrupted()) {
                                 throw new InterruptedException();
                             }
                         }
                         postLine = postLine.trim();
-                        decodeParms( postLine, parms );
+                        decodeParms(postLine, parms);
                     }
                 }
 
                 // Ok, now do the serve()
-                Response r = serve( uri, method, header, parms, files );
-                if ( r == null )
-                    sendError(socket, HTTP_INTERNALERROR, "SERVER INTERNAL ERROR: Serve() returned a null response." );
+                Response r = serve(uri, method, header, parms, files);
+                if (r == null)
+                    sendError(socket, HTTP_INTERNALERROR, "SERVER INTERNAL ERROR: Serve() returned a null response.");
                 else
-                    sendResponse(socket, r.status, r.mimeType, r.header, r.data );
+                    sendResponse(socket, r.status, r.mimeType, r.header, r.data);
 
                 in.close();
-            }
-            catch ( IOException ioe )
-            {
-                try
-                {
+            } catch (IOException ioe) {
+                try {
                     sendError(socket, HTTP_INTERNALERROR, "SERVER INTERNAL ERROR: IOException: " + ioe.getMessage());
+                } catch (Throwable t) {
                 }
-                catch ( Throwable t ) {}
-            }
-            catch ( InterruptedException ie )
-            {
+            } catch (InterruptedException ie) {
                 // Thrown by sendError, ignore and exit the thread.
             }
 
@@ -505,54 +369,47 @@ public abstract class StreamServer {
          * Decodes the sent headers and loads the data into
          * java Properties' key - value pairs
          **/
-        private  void decodeHeader(BufferedReader in, Properties pre, Properties parms, Properties header)
-                throws InterruptedException
-        {
+        private void decodeHeader(BufferedReader in, Properties pre, Properties parms, Properties header)
+                throws InterruptedException {
             try {
                 // Read the request line
                 String inLine = in.readLine();
                 if (inLine == null) return;
-                StringTokenizer st = new StringTokenizer( inLine );
-                if ( !st.hasMoreTokens())
-                    sendError(socket, HTTP_BADREQUEST, "BAD REQUEST: Syntax error. Usage: GET /example/file.html" );
+                StringTokenizer st = new StringTokenizer(inLine);
+                if (!st.hasMoreTokens())
+                    sendError(socket, HTTP_BADREQUEST, "BAD REQUEST: Syntax error. Usage: GET /example/file.html");
 
                 String method = st.nextToken();
                 pre.put("method", method);
 
-                if ( !st.hasMoreTokens())
-                    sendError(socket, HTTP_BADREQUEST, "BAD REQUEST: Missing URI. Usage: GET /example/file.html" );
+                if (!st.hasMoreTokens())
+                    sendError(socket, HTTP_BADREQUEST, "BAD REQUEST: Missing URI. Usage: GET /example/file.html");
 
                 String uri = st.nextToken();
 
                 // Decode parameters from the URI
-                int qmi = uri.indexOf( '?' );
-                if ( qmi >= 0 )
-                {
-                    decodeParms( uri.substring( qmi+1 ), parms );
-                    uri = decodePercent( uri.substring( 0, qmi ));
-                }
-                else uri = Uri.decode(uri);//decodePercent(uri);
+                int qmi = uri.indexOf('?');
+                if (qmi >= 0) {
+                    decodeParms(uri.substring(qmi + 1), parms);
+                    uri = decodePercent(uri.substring(0, qmi));
+                } else uri = Uri.decode(uri);//decodePercent(uri);
 
                 // If there's another token, it's protocol version,
                 // followed by HTTP headers. Ignore version but parse headers.
                 // NOTE: this now forces header names lowercase since they are
                 // case insensitive and vary by client.
-                if ( st.hasMoreTokens())
-                {
+                if (st.hasMoreTokens()) {
                     String line = in.readLine();
-                    while ( line != null && line.trim().length() > 0 )
-                    {
-                        int p = line.indexOf( ':' );
-                        if ( p >= 0 )
-                            header.put( line.substring(0,p).trim().toLowerCase(), line.substring(p+1).trim());
+                    while (line != null && line.trim().length() > 0) {
+                        int p = line.indexOf(':');
+                        if (p >= 0)
+                            header.put(line.substring(0, p).trim().toLowerCase(), line.substring(p + 1).trim());
                         line = in.readLine();
                     }
                 }
 
                 pre.put("uri", uri);
-            }
-            catch ( IOException ioe )
-            {
+            } catch (IOException ioe) {
                 sendError(socket, HTTP_INTERNALERROR, "SERVER INTERNAL ERROR: IOException: " + ioe.getMessage());
             }
         }
@@ -562,70 +419,59 @@ public abstract class StreamServer {
          * into java Properties' key - value pairs.
          **/
         private void decodeMultipartData(String boundary, byte[] fbuf, BufferedReader in, Properties parms, Properties files)
-                throws InterruptedException
-        {
-            try
-            {
-                int[] bpositions = getBoundaryPositions(fbuf,boundary.getBytes());
+                throws InterruptedException {
+            try {
+                int[] bpositions = getBoundaryPositions(fbuf, boundary.getBytes());
                 int boundarycount = 1;
                 String mpline = in.readLine();
-                while ( mpline != null )
-                {
+                while (mpline != null) {
                     if (mpline.indexOf(boundary) == -1)
-                        sendError(socket, HTTP_BADREQUEST, "BAD REQUEST: Content type is multipart/form-data but next chunk does not start with boundary. Usage: GET /example/file.html" );
+                        sendError(socket, HTTP_BADREQUEST, "BAD REQUEST: Content type is multipart/form-data but next chunk does not start with boundary. Usage: GET /example/file.html");
                     boundarycount++;
                     Properties item = new Properties();
                     mpline = in.readLine();
-                    while (mpline != null && mpline.trim().length() > 0)
-                    {
-                        int p = mpline.indexOf( ':' );
+                    while (mpline != null && mpline.trim().length() > 0) {
+                        int p = mpline.indexOf(':');
                         if (p != -1)
-                            item.put( mpline.substring(0,p).trim().toLowerCase(), mpline.substring(p+1).trim());
+                            item.put(mpline.substring(0, p).trim().toLowerCase(), mpline.substring(p + 1).trim());
                         mpline = in.readLine();
                     }
-                    if (mpline != null)
-                    {
+                    if (mpline != null) {
                         String contentDisposition = item.getProperty("content-disposition");
-                        if (contentDisposition == null)
-                        {
-                            sendError(socket, HTTP_BADREQUEST, "BAD REQUEST: Content type is multipart/form-data but no content-disposition info found. Usage: GET /example/file.html" );
+                        if (contentDisposition == null) {
+                            sendError(socket, HTTP_BADREQUEST, "BAD REQUEST: Content type is multipart/form-data but no content-disposition info found. Usage: GET /example/file.html");
                         }
-                        StringTokenizer st = new StringTokenizer( contentDisposition , "; " );
+                        StringTokenizer st = new StringTokenizer(contentDisposition, "; ");
                         Properties disposition = new Properties();
-                        while ( st.hasMoreTokens())
-                        {
+                        while (st.hasMoreTokens()) {
                             String token = st.nextToken();
-                            int p = token.indexOf( '=' );
-                            if (p!=-1)
-                                disposition.put( token.substring(0,p).trim().toLowerCase(), token.substring(p+1).trim());
+                            int p = token.indexOf('=');
+                            if (p != -1)
+                                disposition.put(token.substring(0, p).trim().toLowerCase(), token.substring(p + 1).trim());
                         }
                         String pname = disposition.getProperty("name");
-                        pname = pname.substring(1,pname.length()-1);
+                        pname = pname.substring(1, pname.length() - 1);
 
                         String value = "";
                         if (item.getProperty("content-type") == null) {
-                            while (mpline != null && mpline.indexOf(boundary) == -1)
-                            {
+                            while (mpline != null && mpline.indexOf(boundary) == -1) {
                                 mpline = in.readLine();
-                                if ( mpline != null)
-                                {
+                                if (mpline != null) {
                                     int d = mpline.indexOf(boundary);
                                     if (d == -1)
-                                        value+=mpline;
+                                        value += mpline;
                                     else
-                                        value+=mpline.substring(0,d-2);
+                                        value += mpline.substring(0, d - 2);
                                 }
                             }
-                        }
-                        else
-                        {
-                            if (boundarycount> bpositions.length)
-                                sendError(socket, HTTP_INTERNALERROR, "Error processing request" );
-                            int offset = stripMultipartHeaders(fbuf, bpositions[boundarycount-2]);
-                            String path = saveTmpFile(fbuf, offset, bpositions[boundarycount-1]-offset-4);
+                        } else {
+                            if (boundarycount > bpositions.length)
+                                sendError(socket, HTTP_INTERNALERROR, "Error processing request");
+                            int offset = stripMultipartHeaders(fbuf, bpositions[boundarycount - 2]);
+                            String path = saveTmpFile(fbuf, offset, bpositions[boundarycount - 1] - offset - 4);
                             files.put(pname, path);
                             value = disposition.getProperty("filename");
-                            value = value.substring(1,value.length()-1);
+                            value = value.substring(1, value.length() - 1);
                             do {
                                 mpline = in.readLine();
                             } while (mpline != null && mpline.indexOf(boundary) == -1);
@@ -633,9 +479,7 @@ public abstract class StreamServer {
                         parms.put(pname, value);
                     }
                 }
-            }
-            catch ( IOException ioe )
-            {
+            } catch (IOException ioe) {
                 sendError(socket, HTTP_INTERNALERROR, "SERVER INTERNAL ERROR: IOException: " + ioe.getMessage());
             }
         }
@@ -643,35 +487,28 @@ public abstract class StreamServer {
         /**
          * Find the byte positions where multipart boundaries start.
          **/
-        public int[] getBoundaryPositions(byte[] b, byte[] boundary)
-        {
+        public int[] getBoundaryPositions(byte[] b, byte[] boundary) {
             int matchcount = 0;
             int matchbyte = -1;
             Vector matchbytes = new Vector();
-            for (int i=0; i<b.length; i++)
-            {
-                if (b[i] == boundary[matchcount])
-                {
+            for (int i = 0; i < b.length; i++) {
+                if (b[i] == boundary[matchcount]) {
                     if (matchcount == 0)
                         matchbyte = i;
                     matchcount++;
-                    if (matchcount==boundary.length)
-                    {
+                    if (matchcount == boundary.length) {
                         matchbytes.addElement(matchbyte);
                         matchcount = 0;
                         matchbyte = -1;
                     }
-                }
-                else
-                {
+                } else {
                     i -= matchcount;
                     matchcount = 0;
                     matchbyte = -1;
                 }
             }
             int[] ret = new int[matchbytes.size()];
-            for (int i=0; i < ret.length; i++)
-            {
+            for (int i = 0; i < ret.length; i++) {
                 ret[i] = (Integer) matchbytes.elementAt(i);
             }
             return ret;
@@ -682,11 +519,9 @@ public abstract class StreamServer {
          * to a temporary file.
          * The full path to the saved file is returned.
          **/
-        private String saveTmpFile(byte[] b, int offset, int len)
-        {
+        private String saveTmpFile(byte[] b, int offset, int len) {
             String path = "";
-            if (len > 0)
-            {
+            if (len > 0) {
                 String tmpdir = System.getProperty("java.io.tmpdir");
                 try {
                     File temp = File.createTempFile("NanoHTTPD", "", new File(tmpdir));
@@ -706,48 +541,40 @@ public abstract class StreamServer {
          * It returns the offset separating multipart file headers
          * from the file's data.
          **/
-        private int stripMultipartHeaders(byte[] b, int offset)
-        {
+        private int stripMultipartHeaders(byte[] b, int offset) {
             int i = 0;
-            for (i=offset; i<b.length; i++)
-            {
+            for (i = offset; i < b.length; i++) {
                 if (b[i] == '\r' && b[++i] == '\n' && b[++i] == '\r' && b[++i] == '\n')
                     break;
             }
-            return i+1;
+            return i + 1;
         }
 
         /**
          * Decodes the percent encoding scheme. <br/>
          * For example: "an+example%20string" -> "an example string"
          */
-        private String decodePercent( String str ) throws InterruptedException
-        {
-            try
-            {
+        private String decodePercent(String str) throws InterruptedException {
+            try {
                 StringBuffer sb = new StringBuffer();
-                for( int i=0; i<str.length(); i++ )
-                {
-                    char c = str.charAt( i );
-                    switch ( c )
-                    {
+                for (int i = 0; i < str.length(); i++) {
+                    char c = str.charAt(i);
+                    switch (c) {
                         case '+':
-                            sb.append( ' ' );
+                            sb.append(' ');
                             break;
                         case '%':
-                            sb.append((char)Integer.parseInt( str.substring(i+1,i+3), 16 ));
+                            sb.append((char) Integer.parseInt(str.substring(i + 1, i + 3), 16));
                             i += 2;
                             break;
                         default:
-                            sb.append( c );
+                            sb.append(c);
                             break;
                     }
                 }
                 return sb.toString();
-            }
-            catch( Exception e )
-            {
-                sendError(socket, HTTP_BADREQUEST, "BAD REQUEST: Bad percent-encoding." );
+            } catch (Exception e) {
+                sendError(socket, HTTP_BADREQUEST, "BAD REQUEST: Bad percent-encoding.");
                 return null;
             }
         }
@@ -759,20 +586,18 @@ public abstract class StreamServer {
          * identical keys due to the simplicity of Properties -- if you need multiples,
          * you might want to replace the Properties with a Hashtable of Vectors or such.
          */
-        private void decodeParms( String parms, Properties p )
-                throws InterruptedException
-        {
-            if ( parms == null )
+        private void decodeParms(String parms, Properties p)
+                throws InterruptedException {
+            if (parms == null)
                 return;
 
-            StringTokenizer st = new StringTokenizer( parms, "&" );
-            while ( st.hasMoreTokens())
-            {
+            StringTokenizer st = new StringTokenizer(parms, "&");
+            while (st.hasMoreTokens()) {
                 String e = st.nextToken();
-                int sep = e.indexOf( '=' );
-                if ( sep >= 0 )
-                    p.put( decodePercent( e.substring( 0, sep )).trim(),
-                            decodePercent( e.substring( sep+1 )));
+                int sep = e.indexOf('=');
+                if (sep >= 0)
+                    p.put(decodePercent(e.substring(0, sep)).trim(),
+                            decodePercent(e.substring(sep + 1)));
             }
         }
 
@@ -780,8 +605,7 @@ public abstract class StreamServer {
          * Returns an error message as a HTTP response and
          * throws InterruptedException to stop further request processing.
          */
-        private void sendError(Socket socket, String status, String msg ) throws InterruptedException
-        {
+        private void sendError(Socket socket, String status, String msg) throws InterruptedException {
             sendResponse(socket, status, MIME_PLAINTEXT, null, null);
             throw new InterruptedException();
         }
@@ -789,32 +613,28 @@ public abstract class StreamServer {
         /**
          * Sends given response to the socket.
          */
-        private void sendResponse(Socket socket, String status, String mime, Properties header, StreamSource data )
-        {
-            try
-            {
-                if ( status == null )
-                    throw new Error( "sendResponse(): Status can't be null." );
+        private void sendResponse(Socket socket, String status, String mime, Properties header, StreamSource data) {
+            try {
+                if (status == null)
+                    throw new Error("sendResponse(): Status can't be null.");
 
                 OutputStream out = socket.getOutputStream();
-                PrintWriter pw = new PrintWriter( out );
+                PrintWriter pw = new PrintWriter(out);
                 pw.print("HTTP/1.0 " + status + " \r\n");
 
 
-                if ( mime != null )
+                if (mime != null)
                     pw.print("Content-Type: " + mime + "\r\n");
 
-                if ( header == null || header.getProperty( "Date" ) == null )
-                    pw.print( "Date: " + gmtFrmt.format( new Date()) + "\r\n");
+                if (header == null || header.getProperty("Date") == null)
+                    pw.print("Date: " + gmtFrmt.format(new Date()) + "\r\n");
 
-                if ( header != null )
-                {
+                if (header != null) {
                     Enumeration e = header.keys();
-                    while ( e.hasMoreElements())
-                    {
-                        String key = (String)e.nextElement();
-                        String value = header.getProperty( key );
-                        pw.print( key + ": " + value + "\r\n");
+                    while (e.hasMoreElements()) {
+                        String key = (String) e.nextElement();
+                        String value = header.getProperty(key);
+                        pw.print(key + ": " + value + "\r\n");
                     }
                 }
 
@@ -822,56 +642,29 @@ public abstract class StreamServer {
                 pw.flush();
 
 
-                if ( data != null )
-                {
+                if (data != null) {
                     //long pending = data.available();      // This is to support partial sends, see serveFile()
                     data.open();
                     byte[] buff = new byte[8192];
                     int read = 0;
-                    while ((read = data.read(buff))>0){
+                    while ((read = data.read(buff)) > 0) {
                         //if(SolidExplorer.LOG)Log.d("Explorer", "Read: "+ read +", pending: "+ data.available());
-                        out.write( buff, 0, read );
+                        out.write(buff, 0, read);
                     }
                 }
                 out.flush();
                 out.close();
-                if ( data != null )
+                if (data != null)
                     data.close();
 
-            }
-            catch( IOException ioe )
-            {
+            } catch (IOException ioe) {
                 // Couldn't write? No can do.
-                try { socket.close(); } catch( Throwable t ) {}
-            }
-        }
-
-        //private Socket mySocket;
-    }
-
-    /**
-     * URL-encodes everything between "/"-characters.
-     * Encodes spaces as '%20' instead of '+'.
-     */
-    private String encodeUri( String uri )
-    {
-        String newUri = "";
-        StringTokenizer st = new StringTokenizer( uri, "/ ", true );
-        while ( st.hasMoreTokens())
-        {
-            String tok = st.nextToken();
-            if ( tok.equals( "/" ))
-                newUri += "/";
-            else if ( tok.equals( " " ))
-                newUri += "%20";
-            else
-            {
-                newUri += URLEncoder.encode( tok );
-                // For Java 1.4 you'll want to use this instead:
-                // try { newUri += URLEncoder.encode( tok, "UTF-8" ); } catch ( java.io.UnsupportedEncodingException uee ) {}
+                try {
+                    socket.close();
+                } catch (Throwable t) {
+                }
             }
         }
-        return newUri;
     }
 
     private int myTcpPort;
@@ -879,244 +672,12 @@ public abstract class StreamServer {
     private Thread myThread;
     private File myRootDir;
 
-    // ==================================================
-    // File server code
-    // ==================================================
-
-    //      /**
-    //       * Serves file from homeDir and its' subdirectories (only).
-    //       * Uses only URI, ignores all headers and HTTP parameters.
-    //       */
-    //      public Response serveFile( String uri, Properties header, File homeDir,
-    //                                                         boolean allowDirectoryListing )
-    //      {
-    //              Response res = null;
-    //
-    //              // Make sure we won't die of an exception later
-    //              if ( !homeDir.isDirectory())
-    //                      res = new Response( HTTP_INTERNALERROR, MIME_PLAINTEXT,
-    //                              "INTERNAL ERRROR: serveFile(): given homeDir is not a directory." );
-    //
-    //              if ( res == null )
-    //              {
-    //                      // Remove URL arguments
-    //                      uri = uri.trim().replace( File.separatorChar, '/' );
-    //                      if ( uri.indexOf( '?' ) >= 0 )
-    //                              uri = uri.substring(0, uri.indexOf( '?' ));
-    //
-    //                      // Prohibit getting out of current directory
-    //                      if ( uri.startsWith( ".." ) || uri.endsWith( ".." ) || uri.indexOf( "../" ) >= 0 )
-    //                              res = new Response( HTTP_FORBIDDEN, MIME_PLAINTEXT,
-    //                                      "FORBIDDEN: Won't serve ../ for security reasons." );
-    //              }
-    //
-    //              File f = new File( homeDir, uri );
-    //              if ( res == null && !f.exists())
-    //                      res = new Response( HTTP_NOTFOUND, MIME_PLAINTEXT,
-    //                              "Error 404, file not found." );
-    //
-    //              // List the directory, if necessary
-    //              if ( res == null && f.isDirectory())
-    //              {
-    //                      // Browsers get confused without '/' after the
-    //                      // directory, send a redirect.
-    //                      if ( !uri.endsWith( "/" ))
-    //                      {
-    //                              uri += "/";
-    //                              res = new Response( HTTP_REDIRECT, MIME_HTML,
-    //                                      "<html><body>Redirected: <a href=\"" + uri + "\">" +
-    //                                      uri + "</a></body></html>");
-    //                              res.addHeader( "Location", uri );
-    //                      }
-    //
-    //                      if ( res == null )
-    //                      {
-    //                              // First try index.html and index.htm
-    //                              if ( new File( f, "index.html" ).exists())
-    //                                      f = new File( homeDir, uri + "/index.html" );
-    //                              else if ( new File( f, "index.htm" ).exists())
-    //                                      f = new File( homeDir, uri + "/index.htm" );
-    //                              // No index file, list the directory if it is readable
-    //                              else if ( allowDirectoryListing && f.canRead() )
-    //                              {
-    //                                      String[] files = f.list();
-    //                                      String msg = "<html><body><h1>Directory " + uri + "</h1><br/>";
-    //
-    //                                      if ( uri.length() > 1 )
-    //                                      {
-    //                                              String u = uri.substring( 0, uri.length()-1 );
-    //                                              int slash = u.lastIndexOf( '/' );
-    //                                              if ( slash >= 0 && slash  < u.length())
-    //                                                      msg += "<b><a href=\"" + uri.substring(0, slash+1) + "\">..</a></b><br/>";
-    //                                      }
-    //
-    //                                      if (files!=null)
-    //                                      {
-    //                                              for ( int i=0; i<files.length; ++i )
-    //                                              {
-    //                                                      File curFile = new File( f, files[i] );
-    //                                                      boolean dir = curFile.isDirectory();
-    //                                                      if ( dir )
-    //                                                      {
-    //                                                              msg += "<b>";
-    //                                                              files[i] += "/";
-    //                                                      }
-    //
-    //                                                      msg += "<a href=\"" + encodeUri( uri + files[i] ) + "\">" +
-    //                                                                files[i] + "</a>";
-    //
-    //                                                      // Show file size
-    //                                                      if ( curFile.isFile())
-    //                                                      {
-    //                                                              long len = curFile.length();
-    //                                                              msg += " &nbsp;<font size=2>(";
-    //                                                              if ( len < 1024 )
-    //                                                                      msg += len + " bytes";
-    //                                                              else if ( len < 1024 * 1024 )
-    //                                                                      msg += len/1024 + "." + (len%1024/10%100) + " KB";
-    //                                                              else
-    //                                                                      msg += len/(1024*1024) + "." + len%(1024*1024)/10%100 + " MB";
-    //
-    //                                                              msg += ")</font>";
-    //                                                      }
-    //                                                      msg += "<br/>";
-    //                                                      if ( dir ) msg += "</b>";
-    //                                              }
-    //                                      }
-    //                                      msg += "</body></html>";
-    //                                      res = new Response( HTTP_OK, MIME_HTML, msg );
-    //                              }
-    //                              else
-    //                              {
-    //                                      res = new Response( HTTP_FORBIDDEN, MIME_PLAINTEXT,
-    //                                              "FORBIDDEN: No directory listing." );
-    //                              }
-    //                      }
-    //              }
-    //
-    //              try
-    //              {
-    //                      if ( res == null )
-    //                      {
-    //                              // Get MIME type from file name extension, if possible
-    //                              String mime = null;
-    //                              int dot = f.getCanonicalPath().lastIndexOf( '.' );
-    //                              if ( dot >= 0 )
-    //                                      mime = (String)theMimeTypes.get( f.getCanonicalPath().substring( dot + 1 ).toLowerCase());
-    //                              if ( mime == null )
-    //                                      mime = MIME_DEFAULT_BINARY;
-    //
-    //                              // Calculate etag
-    //                              String etag = Integer.toHexString((f.getAbsolutePath() + f.lastModified() + "" + f.length()).hashCode());
-    //
-    //                              // Support (simple) skipping:
-    //                              long startFrom = 0;
-    //                              long endAt = -1;
-    //                              String range = header.getProperty( "range" );
-    //                              if ( range != null )
-    //                              {
-    //                                      if ( range.startsWith( "bytes=" ))
-    //                                      {
-    //                                              range = range.substring( "bytes=".length());
-    //                                              int minus = range.indexOf( '-' );
-    //                                              try {
-    //                                                      if ( minus > 0 )
-    //                                                      {
-    //                                                              startFrom = Long.parseLong( range.substring( 0, minus ));
-    //                                                              endAt = Long.parseLong( range.substring( minus+1 ));
-    //                                                      }
-    //                                              }
-    //                                              catch ( NumberFormatException nfe ) {}
-    //                                      }
-    //                              }
-    //
-    //                              // Change return code and add Content-Range header when skipping is requested
-    //                              long fileLen = f.length();
-    //                              if (range != null && startFrom >= 0)
-    //                              {
-    //                                      if ( startFrom >= fileLen)
-    //                                      {
-    //                                              res = new Response( HTTP_RANGE_NOT_SATISFIABLE, MIME_PLAINTEXT, "" );
-    //                                              res.addHeader( "Content-Range", "bytes 0-0/" + fileLen);
-    //                                              res.addHeader( "ETag", etag);
-    //                                      }
-    //                                      else
-    //                                      {
-    //                                              if ( endAt < 0 )
-    //                                                      endAt = fileLen-1;
-    //                                              long newLen = endAt - startFrom + 1;
-    //                                              if ( newLen < 0 ) newLen = 0;
-    //
-    //                                              final long dataLen = newLen;
-    //                                              FileInputStream fis = new FileInputStream( f ) {
-    //                                                      public int available() throws IOException { return (int)dataLen; }
-    //                                              };
-    //                                              fis.skip( startFrom );
-    //
-    //                                              res = new Response( HTTP_PARTIALCONTENT, mime, fis );
-    //                                              res.addHeader( "Content-Length", "" + dataLen);
-    //                                              res.addHeader( "Content-Range", "bytes " + startFrom + "-" + endAt + "/" + fileLen);
-    //                                              res.addHeader( "ETag", etag);
-    //                                      }
-    //                              }
-    //                              else
-    //                              {
-    //                                      res = new Response( HTTP_OK, mime, new FileInputStream( f ));
-    //                                      res.addHeader( "Content-Length", "" + fileLen);
-    //                                      res.addHeader( "ETag", etag);
-    //                              }
-    //                      }
-    //              }
-    //              catch( IOException ioe )
-    //              {
-    //                      res = new Response( HTTP_FORBIDDEN, MIME_PLAINTEXT, "FORBIDDEN: Reading file failed." );
-    //              }
-    //
-    //              res.addHeader( "Accept-Ranges", "bytes"); // Announce that the file server accepts partial content requestes
-    //              return res;
-    //      }
-
-    //      /**
-    //       * Hashtable mapping (String)FILENAME_EXTENSION -> (String)MIME_TYPE
-    //       */
-    //      private static Hashtable theMimeTypes = new Hashtable();
-    //      static
-    //      {
-    //              StringTokenizer st = new StringTokenizer(
-    //                      "css            text/css "+
-    //                      "htm            text/html "+
-    //                      "html           text/html "+
-    //                      "xml            text/xml "+
-    //                      "txt            text/plain "+
-    //                      "asc            text/plain "+
-    //                      "gif            image/gif "+
-    //                      "jpg            image/jpeg "+
-    //                      "jpeg           image/jpeg "+
-    //                      "png            image/png "+
-    //                      "mp3            audio/mpeg "+
-    //                      "m3u            audio/mpeg-url " +
-    //                      "mp4            video/mp4 " +
-    //                      "ogv            video/ogg " +
-    //                      "flv            video/x-flv " +
-    //                      "mov            video/quicktime " +
-    //                      "swf            application/x-shockwave-flash " +
-    //                      "js                     application/javascript "+
-    //                      "pdf            application/pdf "+
-    //                      "doc            application/msword "+
-    //                      "ogg            application/x-ogg "+
-    //                      "zip            application/octet-stream "+
-    //                      "exe            application/octet-stream "+
-    //                      "class          application/octet-stream " );
-    //              while ( st.hasMoreTokens())
-    //                      theMimeTypes.put( st.nextToken(), st.nextToken());
-    //      }
-
     /**
      * GMT date formatter
      */
     private static java.text.SimpleDateFormat gmtFrmt;
-    static
-    {
+
+    static {
         gmtFrmt = new java.text.SimpleDateFormat( "E, d MMM yyyy HH:mm:ss 'GMT'", Locale.US);
         gmtFrmt.setTimeZone(TimeZone.getTimeZone("GMT"));
     }
diff --git a/app/src/main/java/com/amaze/filemanager/utils/SmbUtil.java b/app/src/main/java/com/amaze/filemanager/utils/SmbUtil.java
index 1b2083675..4db67aa29 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/SmbUtil.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/SmbUtil.java
@@ -3,9 +3,11 @@ package com.amaze.filemanager.utils;
 import android.content.Context;
 import android.text.TextUtils;
 
-import com.amaze.filemanager.exceptions.CryptException;
 import com.amaze.filemanager.utils.files.CryptUtil;
 
+import java.io.IOException;
+import java.security.GeneralSecurityException;
+
 /**
  * Created by Vishal on 30-05-2017.
  *
@@ -16,24 +18,20 @@ public class SmbUtil {
 
     /**
      * Parse path to decrypt smb password
-     * @return
      */
-    public static String getSmbDecryptedPath(Context context, String path) throws CryptException {
-
+    public static String getSmbDecryptedPath(Context context, String path) throws GeneralSecurityException, IOException {
         if (!(path.contains(":") && path.contains("@"))) {
             // smb path doesn't have any credentials
             return path;
         }
 
-        StringBuffer buffer = new StringBuffer();
+        StringBuilder buffer = new StringBuilder();
 
         buffer.append(path.substring(0, path.indexOf(":", 4)+1));
         String encryptedPassword = path.substring(path.indexOf(":", 4)+1, path.lastIndexOf("@"));
 
         if (!TextUtils.isEmpty(encryptedPassword)) {
-
             String decryptedPassword = CryptUtil.decryptPassword(context, encryptedPassword);
-
             buffer.append(decryptedPassword);
         }
         buffer.append(path.substring(path.lastIndexOf("@"), path.length()));
@@ -43,25 +41,19 @@ public class SmbUtil {
 
     /**
      * Parse path to encrypt smb password
-     * @param context
-     * @param path
-     * @return
      */
-    public static String getSmbEncryptedPath(Context context, String path) throws CryptException {
-
+    public static String getSmbEncryptedPath(Context context, String path) throws GeneralSecurityException, IOException  {
         if (!(path.contains(":") && path.contains("@"))) {
             // smb path doesn't have any credentials
             return path;
         }
 
-        StringBuffer buffer = new StringBuffer();
+        StringBuilder buffer = new StringBuilder();
         buffer.append(path.substring(0, path.indexOf(":", 4)+1));
         String decryptedPassword = path.substring(path.indexOf(":", 4)+1, path.lastIndexOf("@"));
 
         if (!TextUtils.isEmpty(decryptedPassword)) {
-
             String encryptPassword =  CryptUtil.encryptPassword(context, decryptedPassword);
-
             buffer.append(encryptPassword);
         }
         buffer.append(path.substring(path.lastIndexOf("@"), path.length()));
diff --git a/app/src/main/java/com/amaze/filemanager/utils/SubnetScanner.java b/app/src/main/java/com/amaze/filemanager/utils/SubnetScanner.java
index 71b34a6fc..6d469c4d4 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/SubnetScanner.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/SubnetScanner.java
@@ -25,38 +25,39 @@ import jcifs.netbios.NbtAddress;
 import jcifs.smb.SmbFile;
 
 public class SubnetScanner extends Thread {
-    public static final int RETRY_COUNT = 5;
+
+    private static final int RETRY_COUNT = 5;
+
     private Thread bdThread;
     private final Object mLock;
-    private List<Computer> mResults;
+    private List<ComputerParcelable> mResults;
     private ScanObserver observer;
-    ExecutorService pool;
-    private List<Future<Computer>> tasks;
+    private ExecutorService pool;
+    private List<Future<ComputerParcelable>> tasks;
+    private Context context;
 
     public interface ScanObserver {
-        void computerFound(Computer computer);
+        void computerFound(ComputerParcelable computer);
 
         void searchFinished();
     }
 
-
-
-    class Task implements Callable<Computer> {
+    class Task implements Callable<ComputerParcelable> {
         String addr;
 
         public Task(String str) {
             this.addr = str;
         }
 
-        public Computer call() throws Exception {
+        public ComputerParcelable call() throws Exception {
             try {
                 NbtAddress[] allByAddress = NbtAddress.getAllByAddress(this.addr);
                 if (allByAddress == null || allByAddress.length <= 0) {
-                    return new Computer(null, this.addr);
+                    return new ComputerParcelable(null, this.addr);
                 }
-                return new Computer(allByAddress[0].getHostName(), this.addr);
+                return new ComputerParcelable(allByAddress[0].getHostName(), this.addr);
             } catch (UnknownHostException e) {
-                return new Computer(null, this.addr);
+                return new ComputerParcelable(null, this.addr);
             }
         }
     }
@@ -65,24 +66,24 @@ public class SubnetScanner extends Thread {
         configure();
     }
 
-    public static void configure() {
+    private static void configure() {
         Config.setProperty("jcifs.resolveOrder", "BCAST");
         Config.setProperty("jcifs.smb.client.responseTimeout", "30000");
         Config.setProperty("jcifs.netbios.retryTimeout", "5000");
         Config.setProperty("jcifs.netbios.cachePolicy", "-1");
     }
-    Context context;
+
     public SubnetScanner(Context context) {
-        this.context=context;
-        this.mLock = new Object();
-        this.tasks = new ArrayList(260);
-        this.pool = Executors.newFixedThreadPool(60);
-        this.mResults = new ArrayList();
+        this.context = context;
+        mLock = new Object();
+        tasks = new ArrayList<>(260);
+        pool = Executors.newFixedThreadPool(60);
+        mResults = new ArrayList<>();
     }
 
-
     public void run() {
-        int ipAddress = ((WifiManager) context.getSystemService(Context.WIFI_SERVICE)).getConnectionInfo().getIpAddress();
+        int ipAddress = ((WifiManager) context.getApplicationContext().getSystemService(Context.WIFI_SERVICE))
+                .getConnectionInfo().getIpAddress();
         if (ipAddress != 0) {
             tryWithBroadcast();
             String formatIpAddress = Formatter.formatIpAddress(ipAddress);
@@ -101,22 +102,17 @@ public class SubnetScanner extends Thread {
                     while (i < size) {
                         if (!isInterrupted()) {
                             try {
-                                Computer computer = (Computer) ((Future) this.tasks.get(i)).get(1, TimeUnit.MILLISECONDS);
+                                ComputerParcelable computer = (ComputerParcelable) ((Future) this.tasks.get(i)).get(1, TimeUnit.MILLISECONDS);
                                 this.tasks.remove(i);
                                 size--;
                                 if (computer.name != null) {
-                                    //SELog.d("SMB host found at ", computer.addr);
                                     onFound(computer);
-                                } else {
-                                    //SELog.d("No SMB host found at ", computer.addr);
                                 }
                                 ipAddress = size;
                             } catch (InterruptedException e) {
                                 return;
                             } catch (ExecutionException e2) {
-                                Throwable th = e2;
                                 ipAddress = size;
-                              //  SELog.w(th);
                             } catch (TimeoutException e3) {
                                 ipAddress = size;
                             }
@@ -153,14 +149,15 @@ public class SubnetScanner extends Thread {
                         SmbFile[] listFiles = smbFile.listFiles();
                         for (SmbFile smbFile2 : listFiles) {
                             SmbFile[] listFiles2 = smbFile2.listFiles();
-                            for (int i2 = 0; i2 < listFiles2.length; i2++) {
+                            for (SmbFile files : listFiles2) {
                                 try {
-                                    String substring = listFiles2[i2].getName().substring(0, listFiles2[i2].getName().length() - 1);
+                                    String substring = files.getName().substring(0, files.getName().length() - 1);
                                     UniAddress byName = UniAddress.getByName(substring);
                                     if (byName != null) {
-                                        SubnetScanner.this.onFound(new Computer(substring, byName.getHostAddress()));
+                                        SubnetScanner.this.onFound(new ComputerParcelable(substring, byName.getHostAddress()));
                                     }
                                 } catch (Throwable e) {
+
                                 }
                             }
                         }
@@ -173,8 +170,8 @@ public class SubnetScanner extends Thread {
         this.bdThread.start();
     }
 
-    void onFound(Computer computer) {
-        this.mResults.add(computer);
+    private void onFound(ComputerParcelable computer) {
+        mResults.add(computer);
         synchronized (this.mLock) {
             if (this.observer != null) {
                 this.observer.computerFound(computer);
@@ -193,12 +190,12 @@ public class SubnetScanner extends Thread {
         try {
             this.pool.shutdownNow();
         } catch (Throwable th) {
-
+            
         }
     }
 
-    public List<Computer> getResults() {
-        return new ArrayList(this.mResults);
+    public List<ComputerParcelable> getResults() {
+        return new ArrayList<>(this.mResults);
     }
 
 }
diff --git a/app/src/main/java/com/amaze/filemanager/utils/TinyDB.java b/app/src/main/java/com/amaze/filemanager/utils/TinyDB.java
index 33eff597e..eed500df1 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/TinyDB.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/TinyDB.java
@@ -23,13 +23,11 @@ package com.amaze.filemanager.utils;
 import android.content.SharedPreferences;
 import android.text.TextUtils;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-
-//import com.google.gson.Gson;
-
+/**
+ * Extract from: https://github.com/kcochibili/TinyDB--Android-Shared-Preferences-Turbo
+ * Author: https://github.com/kcochibili
+ */
 public class TinyDB {
-
     /*
      *  The "" character is not a comma, it is the SINGLE LOW-9 QUOTATION MARK. U-201A
      *  + U-2017 + U-201A are used for separating the items in a list.
@@ -63,69 +61,4 @@ public class TinyDB {
         return newArray;
     }
 
-    /**
-     * Get parsed ArrayList of T from SharedPreferences at 'key'
-     * @param key SharedPreferences key
-     * @return ArrayList of T
-     */
-    public static <T> ArrayList<T> getList(SharedPreferences preferences, Class<T> klazz, String key,
-                                           ArrayList<T> defaultValue) {
-        String pref = preferences.getString(key, "");
-
-        if(pref.equals("")) {
-            return defaultValue;
-        }
-
-        String[] myList = TextUtils.split(pref, DIVIDER);
-        ArrayList<String> arrayToList = new ArrayList<>(Arrays.asList(myList));
-        ArrayList<T> newList = new ArrayList<>();
-
-        for (String item : arrayToList)
-            newList.add(valueOf(klazz, item));
-
-        return newList;
-    }
-
-    // Put methods
-
-    /**
-     * Put ArrayList of T into SharedPreferences with 'key' and save
-     * @param key SharedPreferences key
-     */
-    public static <T> void putList(SharedPreferences preferences, String key, ArrayList<T> list) {
-        checkForNullKey(key);
-        Object[] myList = list.toArray();
-        preferences.edit().putString(key, TextUtils.join(DIVIDER, myList)).apply();
-    }
-
-    /**
-     * null keys would corrupt the shared pref file and make them unreadable this is a preventive measure
-     * @param key the pref key
-     */
-    private static void checkForNullKey(String key){
-        if (key == null){
-            throw new NullPointerException();
-        }
-    }
-
-    private static <T> T valueOf(Class<T> klazz, String arg) {
-        Exception cause = null;
-
-        if(klazz != String.class) {
-            T ret = null;
-            try {
-                ret = klazz.cast(klazz.getDeclaredMethod("valueOf", String.class).invoke(null, arg));
-            } catch (Exception e) {
-                cause = e;
-            }
-
-            if (cause == null) {
-                return ret;
-            } else {
-                throw new IllegalArgumentException(cause);
-            }
-        } else {
-            return (T) arg;//Is string but String.valueOf(String) doesn't exist
-        }
-    }
 }
\ No newline at end of file
diff --git a/app/src/main/java/com/amaze/filemanager/utils/Utils.java b/app/src/main/java/com/amaze/filemanager/utils/Utils.java
index 15f0c340a..497129303 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/Utils.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/Utils.java
@@ -1,9 +1,12 @@
 package com.amaze.filemanager.utils;
 
 import android.content.Context;
+import android.content.pm.ActivityInfo;
 import android.content.res.ColorStateList;
+import android.content.res.Configuration;
 import android.graphics.BitmapFactory;
 import android.graphics.drawable.Drawable;
+import android.net.Uri;
 import android.os.Build;
 import android.support.annotation.ColorRes;
 import android.support.v4.content.ContextCompat;
@@ -11,8 +14,11 @@ import android.support.v4.graphics.drawable.DrawableCompat;
 import android.util.DisplayMetrics;
 import android.view.View;
 import android.widget.CheckBox;
+import android.widget.Toast;
 
 import com.amaze.filemanager.R;
+import com.amaze.filemanager.activities.MainActivity;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
 
 import java.io.File;
 import java.text.SimpleDateFormat;
@@ -26,8 +32,14 @@ import java.text.SimpleDateFormat;
 
 public class Utils {
 
+    private static final int INDEX_NOT_FOUND = -1;
     private static final SimpleDateFormat DATE_NO_MINUTES = new SimpleDateFormat("MMM dd, yyyy");
     private static final SimpleDateFormat DATE_WITH_MINUTES = new SimpleDateFormat("MMM dd yyyy | KK:mm a");
+    private static final String INPUT_INTENT_BLACKLIST_COLON = ";";
+    private static final String INPUT_INTENT_BLACKLIST_PIPE = "\\|";
+    private static final String INPUT_INTENT_BLACKLIST_AMP = "&&";
+    private static final String INPUT_INTENT_BLACKLIST_DOTS = "\\.\\.\\.";
+
 
     //methods for fastscroller
     public static float clamp(float min, float max, float value) {
@@ -35,12 +47,6 @@ public class Utils {
         return Math.min(minimum, max);
     }
 
-    /**
-     * TODO
-     *
-     * @param view
-     * @return
-     */
     public static float getViewRawY(View view) {
         int[] location = new int[2];
         location[0] = 0;
@@ -65,10 +71,6 @@ public class Utils {
         }
     }
 
-    public String getDate(File f) {
-        return getDate(f.lastModified());
-    }
-
     public static String getDate(long f) {
         return DATE_WITH_MINUTES.format(f);
     }
@@ -80,14 +82,6 @@ public class Utils {
         return date;
     }
 
-    /**
-     * TODO
-     *
-     * @param options
-     * @param reqWidth
-     * @param reqHeight
-     * @return
-     */
     public static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) {
         // Raw height and width of image
         final int height = options.outHeight;
@@ -110,14 +104,9 @@ public class Utils {
         return inSampleSize;
     }
 
-    public boolean isAtleastKitkat() {
-        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;
-    }
-
     /**
      * Gets color
      *
-     * @param c     Context
      * @param color the resource id for the color
      * @return the color
      */
@@ -129,9 +118,123 @@ public class Utils {
         }
     }
 
-    public static int dpToPx(int dp, Context c) {
+    public static int dpToPx(Context c, int dp) {
         DisplayMetrics displayMetrics = c.getResources().getDisplayMetrics();
         return Math.round(dp * (displayMetrics.xdpi / DisplayMetrics.DENSITY_DEFAULT));
     }
 
+    /**
+     *   Compares two Strings, and returns the portion where they differ.  (More precisely,
+     *   return the remainder of the second String, starting from where it's different from the first.)
+     *
+     *   For example, difference("i am a machine", "i am a robot") -> "robot".
+     *
+     *   StringUtils.difference(null, null) = null
+     *   StringUtils.difference("", "") = ""
+     *   StringUtils.difference("", "abc") = "abc"
+     *   StringUtils.difference("abc", "") = ""
+     *   StringUtils.difference("abc", "abc") = ""
+     *   StringUtils.difference("ab", "abxyz") = "xyz"
+     *   StringUtils.difference("abcde", "abxyz") = "xyz"
+     *   StringUtils.difference("abcde", "xyz") = "xyz"
+     *
+     *  @param str1 - the first String, may be null
+     *  @param str2 - the second String, may be null
+     *  @return the portion of str2 where it differs from str1; returns the empty String if they are equal
+     *
+     *  Stolen from Apache's StringUtils
+     *  (https://commons.apache.org/proper/commons-lang/javadocs/api-2.6/org/apache/commons/lang/StringUtils.html#difference(java.lang.String,%20java.lang.String))
+     */
+    public static String differenceStrings(String str1, String str2) {
+        if (str1 == null) return str2;
+        if (str2 == null) return str1;
+
+        int at = indexOfDifferenceStrings(str1, str2);
+
+        if (at == INDEX_NOT_FOUND) return "";
+
+        return str2.substring(at);
+    }
+
+    private static int indexOfDifferenceStrings(CharSequence cs1, CharSequence cs2) {
+        if (cs1 == cs2) return INDEX_NOT_FOUND;
+        if (cs1 == null || cs2 == null) return 0;
+
+        int i;
+        for (i = 0; i < cs1.length() && i < cs2.length(); ++i) {
+            if (cs1.charAt(i) != cs2.charAt(i)) break;
+        }
+
+        if (i < cs2.length() || i < cs1.length()) return i;
+
+        return INDEX_NOT_FOUND;
+    }
+
+    /**
+     * Force disables screen rotation. Useful when we're temporarily in activity because of external intent,
+     * and don't have to really deal much with filesystem.
+     */
+    public static void disableScreenRotation(MainActivity mainActivity) {
+        int screenOrientation = mainActivity.getResources().getConfiguration().orientation;
+
+        if (screenOrientation == Configuration.ORIENTATION_LANDSCAPE) {
+            mainActivity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
+        } else if (screenOrientation == Configuration.ORIENTATION_PORTRAIT) {
+            mainActivity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+        }
+    }
+
+    /**
+     * Sanitizes input from external application to avoid any attempt of command injection
+     */
+    public static String sanitizeInput(String input) {
+        // iterate through input and keep sanitizing until it's fully injection proof
+        String sanitizedInput;
+        String sanitizedInputTemp = input;
+        
+        while (true) {
+            sanitizedInput = sanitizeInputOnce(sanitizedInputTemp);
+            if (sanitizedInput.equals(sanitizedInputTemp)) break;
+            sanitizedInputTemp = sanitizedInput;
+        }
+
+        return sanitizedInput;
+    }
+
+    private static String sanitizeInputOnce(String input) {
+        return input.replaceAll(INPUT_INTENT_BLACKLIST_PIPE, "").
+                replaceAll(INPUT_INTENT_BLACKLIST_AMP, "").
+                replaceAll(INPUT_INTENT_BLACKLIST_DOTS, "").
+                replaceAll(INPUT_INTENT_BLACKLIST_COLON, "");
+    }
+
+    /**
+     * Returns uri associated to specific basefile
+     */
+    public static Uri getUriForBaseFile(Context context, HybridFileParcelable baseFile) {
+        switch (baseFile.getMode()) {
+            case FILE:
+            case ROOT:
+                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
+
+                    return GenericFileProvider.getUriForFile(context, GenericFileProvider.PROVIDER_NAME,
+                            new File(baseFile.getPath()));
+                } else {
+                    return Uri.fromFile(new File(baseFile.getPath()));
+                }
+            case OTG:
+                return OTGUtil.getDocumentFile(baseFile.getPath(), context, true).getUri();
+            case SMB:
+            case DROPBOX:
+            case GDRIVE:
+            case ONEDRIVE:
+            case BOX:
+                Toast.makeText(context, context.getResources().getString(R.string.smb_launch_error),
+                        Toast.LENGTH_LONG).show();
+                return null;
+            default:
+                return null;
+        }
+    }
+
 }
diff --git a/app/src/main/java/com/amaze/filemanager/utils/AppConfig.java b/app/src/main/java/com/amaze/filemanager/utils/application/AppConfig.java
similarity index 91%
rename from app/src/main/java/com/amaze/filemanager/utils/AppConfig.java
rename to app/src/main/java/com/amaze/filemanager/utils/application/AppConfig.java
index 06d10594d..e6c9d7b08 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/AppConfig.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/application/AppConfig.java
@@ -1,4 +1,4 @@
-package com.amaze.filemanager.utils;
+package com.amaze.filemanager.utils.application;
 
 import android.app.Application;
 import android.content.Context;
@@ -6,10 +6,13 @@ import android.os.AsyncTask;
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.StrictMode;
+import android.support.v7.app.AppCompatDelegate;
 import android.text.TextUtils;
 import android.widget.Toast;
 
+
 import com.amaze.filemanager.database.UtilsHandler;
+import com.amaze.filemanager.utils.LruBitmapCache;
 import com.amaze.filemanager.utils.provider.UtilitiesProvider;
 import com.amaze.filemanager.utils.provider.UtilitiesProviderInterface;
 import com.android.volley.Request;
@@ -18,10 +21,10 @@ import com.android.volley.toolbox.ImageLoader;
 import com.android.volley.toolbox.Volley;
 
 /**
- * Created by vishal on 7/12/16.
+ * Created by vishal on 7/12/16 edited by Emmanuel Messulam<emmanuelbendavid@gmail.com>
  */
 
-public class AppConfig extends Application {
+public class AppConfig extends LeakCanaryApplication {
 
     public static final String TAG = AppConfig.class.getSimpleName();
 
@@ -44,6 +47,7 @@ public class AppConfig extends Application {
     @Override
     public void onCreate() {
         super.onCreate();
+        AppCompatDelegate.setCompatVectorFromResourcesEnabled(true);//selector in srcCompat isn't supported without this
         mInstance = this;
 
         utilsProvider = new UtilitiesProvider(this);
@@ -148,11 +152,8 @@ public class AppConfig extends Application {
             final Context c = context;
             final String m = message;
 
-            ((AppConfig) context).runInApplicationThread(new Runnable() {
-                @Override
-                public void run() {
-                    Toast.makeText(c, m, Toast.LENGTH_LONG).show();
-                }
+            ((AppConfig) context).runInApplicationThread(() -> {
+                Toast.makeText(c, m, Toast.LENGTH_LONG).show();
             });
         }
     }
diff --git a/app/src/main/java/com/amaze/filemanager/utils/application/LeakCanaryApplication.java b/app/src/main/java/com/amaze/filemanager/utils/application/LeakCanaryApplication.java
new file mode 100644
index 000000000..4eab1a1ee
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/utils/application/LeakCanaryApplication.java
@@ -0,0 +1,25 @@
+package com.amaze.filemanager.utils.application;
+
+import android.app.Application;
+
+import com.squareup.leakcanary.LeakCanary;
+
+/**
+ * @author Emmanuel
+ *         on 28/8/2017, at 18:12.
+ */
+
+public class LeakCanaryApplication extends Application {
+
+    @Override
+    public void onCreate() {
+        super.onCreate();/*
+        if (LeakCanary.isInAnalyzerProcess(this)) {
+            // This process is dedicated to LeakCanary for heap analysis.
+            // You should not init your app in this process.
+            return;
+        }
+        LeakCanary.install(this);*/
+    }
+
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/amaze/filemanager/utils/broadcast_receiver/PackageReceiver.java b/app/src/main/java/com/amaze/filemanager/utils/broadcast_receiver/PackageReceiver.java
index 39fe32bd8..ce32fe533 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/broadcast_receiver/PackageReceiver.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/broadcast_receiver/PackageReceiver.java
@@ -5,7 +5,7 @@ import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 
-import com.amaze.filemanager.services.asynctasks.AppListLoader;
+import com.amaze.filemanager.asynchronous.loaders.AppListLoader;
 
 /**
  * Created by vishal on 23/2/17.
diff --git a/app/src/main/java/com/amaze/filemanager/utils/cloud/CloudStreamServer.java b/app/src/main/java/com/amaze/filemanager/utils/cloud/CloudStreamServer.java
index 271f89b42..6b041d326 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/cloud/CloudStreamServer.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/cloud/CloudStreamServer.java
@@ -197,27 +197,23 @@ public abstract class CloudStreamServer {
         myTcpPort = port;
         this.myRootDir = wwwroot;
         myServerSocket = new ServerSocket( myTcpPort );
-        myThread = new Thread( new Runnable()
-        {
-            public void run()
-            {
-                try
-                {
-                    while( true ){
-                        //                                                      if(session!=null){
-                        //                                                              session.interrupt();
-                        //                                                              try {
-                        //                                                                      session.join();
-                        //                                                              } catch (InterruptedException e) {
-                        //                                                                      e.printStackTrace();
-                        //                                                              }
-                        //                                                      }
-                        Socket accept = myServerSocket.accept();
-                        new HTTPSession(accept);
-                    }
+        myThread = new Thread(() -> {
+            try {
+                while (true) {
+                    /*
+                    if(session!=null){
+                        session.interrupt();
+                          try {
+                            session.join();
+                          } catch (InterruptedException e) {
+                                e.printStackTrace();
+                          }
+                      }
+                    */
+                    Socket accept = myServerSocket.accept();
+                    new HTTPSession(accept);
                 }
-                catch ( IOException ioe )
-                {}
+            } catch (IOException ioe) {
             }
         });
         myThread.setDaemon( true );
@@ -228,27 +224,23 @@ public abstract class CloudStreamServer {
     {
         this.myRootDir = wwwroot;
         myServerSocket = new ServerSocket( myTcpPort );
-        myThread = new Thread( new Runnable()
-        {
-            public void run()
-            {
-                try
-                {
-                    while( true ){
-                        //                                                      if(session!=null){
-                        //                                                              session.interrupt();
-                        //                                                              try {
-                        //                                                                      session.join();
-                        //                                                              } catch (InterruptedException e) {
-                        //                                                                      e.printStackTrace();
-                        //                                                              }
-                        //                                                      }
-                        Socket accept = myServerSocket.accept();
-                        new HTTPSession(accept);
-                    }
+        myThread = new Thread(() -> {
+            try {
+                while (true) {
+                    /*
+                      if(session!=null){
+                              session.interrupt();
+                              try {
+                                      session.join();
+                              } catch (InterruptedException e) {
+                                      e.printStackTrace();
+                              }
+                      }
+                    */
+                    Socket accept = myServerSocket.accept();
+                    new HTTPSession(accept);
                 }
-                catch ( IOException ioe )
-                {}
+            } catch (IOException ioe) {
             }
         });
         myThread.setDaemon( true );
diff --git a/app/src/main/java/com/amaze/filemanager/utils/cloud/CloudUtil.java b/app/src/main/java/com/amaze/filemanager/utils/cloud/CloudUtil.java
index d753f15be..ffcc2fd9d 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/cloud/CloudUtil.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/cloud/CloudUtil.java
@@ -7,16 +7,16 @@ import android.content.pm.PackageManager;
 import android.content.pm.ResolveInfo;
 import android.net.Uri;
 import android.os.AsyncTask;
-import android.util.Log;
 import android.widget.Toast;
 
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.MainActivity;
 import com.amaze.filemanager.database.CloudHandler;
 import com.amaze.filemanager.exceptions.CloudPluginException;
-import com.amaze.filemanager.filesystem.BaseFile;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.ui.icons.MimeTypes;
 import com.amaze.filemanager.utils.DataUtils;
+import com.amaze.filemanager.utils.OnFileFound;
 import com.amaze.filemanager.utils.OpenMode;
 import com.cloudrail.si.interfaces.CloudStorage;
 import com.cloudrail.si.types.CloudMetaData;
@@ -33,30 +33,40 @@ import java.util.List;
 
 public class CloudUtil {
 
-    public static ArrayList<BaseFile> listFiles(String path, CloudStorage cloudStorage, OpenMode openMode)
-            throws CloudPluginException {
-
-        ArrayList<BaseFile> baseFiles = new ArrayList<>();
+    /**
+     * @deprecated use getCloudFiles()
+     */
+    public static ArrayList<HybridFileParcelable> listFiles(String path, CloudStorage cloudStorage,
+                                                            OpenMode openMode) throws CloudPluginException {
+        final ArrayList<HybridFileParcelable> baseFiles = new ArrayList<>();
+        getCloudFiles(path, cloudStorage, openMode, new OnFileFound() {
+            @Override
+            public void onFileFound(HybridFileParcelable file) {
+                baseFiles.add(file);
+            }
+        });
+        return baseFiles;
+    }
 
+    public static void getCloudFiles(String path, CloudStorage cloudStorage, OpenMode openMode,
+                                     OnFileFound fileFoundCallback) throws CloudPluginException {
         String strippedPath = stripPath(openMode, path);
-
         try {
-
             for (CloudMetaData cloudMetaData : cloudStorage.getChildren(strippedPath)) {
-
-                BaseFile baseFile = new BaseFile(path + "/" + cloudMetaData.getName(),
-                        "", (cloudMetaData.getModifiedAt() == null)
-                        ? 0l : cloudMetaData.getModifiedAt(), cloudMetaData.getSize(),
+                HybridFileParcelable baseFile = new HybridFileParcelable(
+                        path + "/" + cloudMetaData.getName(),
+                        "",
+                        (cloudMetaData.getModifiedAt() == null) ? 0l : cloudMetaData.getModifiedAt(),
+                        cloudMetaData.getSize(),
                         cloudMetaData.getFolder());
                 baseFile.setName(cloudMetaData.getName());
                 baseFile.setMode(openMode);
-                baseFiles.add(baseFile);
+                fileFoundCallback.onFileFound(baseFile);
             }
         } catch (Exception e) {
             e.printStackTrace();
             throw new CloudPluginException();
         }
-        return baseFiles;
     }
 
     /**
@@ -109,39 +119,33 @@ public class CloudUtil {
         return strippedPath;
     }
 
-    public static void launchCloud(final BaseFile baseFile, final OpenMode serviceType, final Activity activity) {
+    public static void launchCloud(final HybridFileParcelable baseFile, final OpenMode serviceType, final Activity activity) {
         final CloudStreamer streamer = CloudStreamer.getInstance();
 
-        new Thread(new Runnable() {
-            @Override
-            public void run() {
-                try {
-
-                    streamer.setStreamSrc(baseFile.getInputStream(activity), baseFile.getName(), baseFile.length(activity));
-                    activity.runOnUiThread(new Runnable() {
-                        public void run() {
-                            try {
-                                File file = new File(Uri.parse(CloudUtil.stripPath(serviceType, baseFile.getPath())).getPath());
-                                Uri uri = Uri.parse(CloudStreamer.URL + Uri.fromFile(file).getEncodedPath());
-                                Intent i = new Intent(Intent.ACTION_VIEW);
-                                i.setDataAndType(uri, MimeTypes.getMimeType(file));
-                                PackageManager packageManager = activity.getPackageManager();
-                                List<ResolveInfo> resInfos = packageManager.queryIntentActivities(i, 0);
-                                if (resInfos != null && resInfos.size() > 0)
-                                    activity.startActivity(i);
-                                else
-                                    Toast.makeText(activity,
-                                            activity.getResources().getString(R.string.smb_launch_error),
-                                            Toast.LENGTH_SHORT).show();
-                            } catch (ActivityNotFoundException e) {
-                                e.printStackTrace();
-                            }
-                        }
-                    });
-                } catch (Exception e) {
-
-                    e.printStackTrace();
-                }
+        new Thread(() -> {
+            try {
+                streamer.setStreamSrc(baseFile.getInputStream(activity), baseFile.getName(), baseFile.length(activity));
+                activity.runOnUiThread(() -> {
+                    try {
+                        File file = new File(Uri.parse(CloudUtil.stripPath(serviceType, baseFile.getPath())).getPath());
+                        Uri uri = Uri.parse(CloudStreamer.URL + Uri.fromFile(file).getEncodedPath());
+                        Intent i = new Intent(Intent.ACTION_VIEW);
+                        i.setDataAndType(uri, MimeTypes.getMimeType(file));
+                        PackageManager packageManager = activity.getPackageManager();
+                        List<ResolveInfo> resInfos = packageManager.queryIntentActivities(i, 0);
+                        if (resInfos != null && resInfos.size() > 0)
+                            activity.startActivity(i);
+                        else
+                            Toast.makeText(activity,
+                                    activity.getResources().getString(R.string.smb_launch_error),
+                                    Toast.LENGTH_SHORT).show();
+                    } catch (ActivityNotFoundException e) {
+                        e.printStackTrace();
+                    }
+                });
+            } catch (Exception e) {
+
+                e.printStackTrace();
             }
         }).start();
     }
diff --git a/app/src/main/java/com/amaze/filemanager/utils/files/CryptUtil.java b/app/src/main/java/com/amaze/filemanager/utils/files/CryptUtil.java
index 32f8defa1..5764d1e32 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/files/CryptUtil.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/files/CryptUtil.java
@@ -9,14 +9,11 @@ import android.security.keystore.KeyGenParameterSpec;
 import android.security.keystore.KeyProperties;
 import android.support.annotation.RequiresApi;
 import android.util.Base64;
-import android.util.Log;
 
-import com.amaze.filemanager.activities.MainActivity;
-import com.amaze.filemanager.exceptions.CryptException;
-import com.amaze.filemanager.filesystem.BaseFile;
 import com.amaze.filemanager.filesystem.FileUtil;
-import com.amaze.filemanager.filesystem.HFile;
-import com.amaze.filemanager.utils.AppConfig;
+import com.amaze.filemanager.filesystem.HybridFile;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
+import com.amaze.filemanager.fragments.preference_fragments.PrefFrag;
 import com.amaze.filemanager.utils.OpenMode;
 import com.amaze.filemanager.utils.ProgressHandler;
 import com.amaze.filemanager.utils.ServiceWatcherUtil;
@@ -27,8 +24,8 @@ import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.math.BigInteger;
+import java.security.GeneralSecurityException;
 import java.security.InvalidAlgorithmParameterException;
-import java.security.InvalidKeyException;
 import java.security.Key;
 import java.security.KeyPairGenerator;
 import java.security.KeyStore;
@@ -36,19 +33,15 @@ import java.security.KeyStoreException;
 import java.security.NoSuchAlgorithmException;
 import java.security.NoSuchProviderException;
 import java.security.SecureRandom;
-import java.security.UnrecoverableEntryException;
 import java.security.UnrecoverableKeyException;
 import java.security.cert.CertificateException;
 import java.util.ArrayList;
 import java.util.Calendar;
 
-import javax.crypto.BadPaddingException;
 import javax.crypto.Cipher;
 import javax.crypto.CipherInputStream;
 import javax.crypto.CipherOutputStream;
-import javax.crypto.IllegalBlockSizeException;
 import javax.crypto.KeyGenerator;
-import javax.crypto.NoSuchPaddingException;
 import javax.crypto.spec.GCMParameterSpec;
 import javax.crypto.spec.IvParameterSpec;
 import javax.crypto.spec.SecretKeySpec;
@@ -66,8 +59,8 @@ import javax.security.auth.x500.X500Principal;
  * The service then calls the constructor which fires up the subsequent encryption/decryption process.
  *
  * We differentiate between already encrypted files from <i>new ones</i> by encrypting the plaintext
- * {@link com.amaze.filemanager.fragments.preference_fragments.Preffrag#ENCRYPT_PASSWORD_MASTER}
- * and {@link com.amaze.filemanager.fragments.preference_fragments.Preffrag#ENCRYPT_PASSWORD_FINGERPRINT}
+ * {@link PrefFrag#ENCRYPT_PASSWORD_MASTER}
+ * and {@link PrefFrag#ENCRYPT_PASSWORD_FINGERPRINT}
  * against the path in database. At the time of decryption, we check for these values
  * and either retrieve master password from preferences or fire up the fingerprint sensor authentication.
  *
@@ -93,7 +86,7 @@ public class CryptUtil {
     public static final String CRYPT_EXTENSION = ".aze";
 
     private ProgressHandler progressHandler;
-    private ArrayList<HFile> failedOps;
+    private ArrayList<HybridFile> failedOps;
 
     /**
      * Constructor will start encryption process serially. Make sure to call with background thread.
@@ -107,22 +100,15 @@ public class CryptUtil {
      * @param context
      * @param sourceFile the file to encrypt
      */
-    public CryptUtil(Context context, BaseFile sourceFile, ProgressHandler progressHandler,
-                     ArrayList<HFile> failedOps) throws CryptException {
+    public CryptUtil(Context context, HybridFileParcelable sourceFile, ProgressHandler progressHandler,
+                     ArrayList<HybridFile> failedOps) throws GeneralSecurityException, IOException {
 
         this.progressHandler = progressHandler;
         this.failedOps = failedOps;
 
         // target encrypted file
-        HFile hFile = new HFile(sourceFile.getMode(), sourceFile.getParent(context));
-
-        try {
-
-            encrypt(context, sourceFile, hFile);
-        } catch (Exception e) {
-            e.printStackTrace();
-            throw new CryptException();
-        }
+        HybridFile hFile = new HybridFile(sourceFile.getMode(), sourceFile.getParent(context));
+        encrypt(context, sourceFile, hFile);
     }
 
     /**
@@ -138,26 +124,20 @@ public class CryptUtil {
      * @param targetPath the directory in which file is to be decrypted
      *                   the source's parent in normal case
      */
-    public CryptUtil(Context context, BaseFile baseFile, String targetPath,
-                     ProgressHandler progressHandler, ArrayList<HFile> failedOps) throws CryptException {
+    public CryptUtil(Context context, HybridFileParcelable baseFile, String targetPath,
+                     ProgressHandler progressHandler, ArrayList<HybridFile> failedOps) throws GeneralSecurityException, IOException {
 
         this.progressHandler = progressHandler;
         this.failedOps = failedOps;
 
-        HFile targetDirectory = new HFile(OpenMode.FILE, targetPath);
+        HybridFile targetDirectory = new HybridFile(OpenMode.FILE, targetPath);
         if (!targetPath.equals(context.getExternalCacheDir())) {
 
             // same file system as of base file
             targetDirectory.setMode(baseFile.getMode());
         }
 
-        try {
-
-            decrypt(context, baseFile, targetDirectory);
-        } catch (Exception e) {
-            e.printStackTrace();
-            throw new CryptException();
-        }
+        decrypt(context, baseFile, targetDirectory);
     }
 
     /**
@@ -165,32 +145,23 @@ public class CryptUtil {
      * @param context
      * @param sourceFile        the source file to decrypt
      * @param targetDirectory   the target directory inside which we're going to decrypt
-     * @throws IOException
-     * @throws CertificateException
-     * @throws NoSuchAlgorithmException
-     * @throws UnrecoverableEntryException
-     * @throws InvalidKeyException
-     * @throws InvalidAlgorithmParameterException
-     * @throws NoSuchPaddingException
-     * @throws NoSuchProviderException
-     * @throws BadPaddingException
-     * @throws KeyStoreException
-     * @throws IllegalBlockSizeException
      */
-    private void decrypt(Context context, BaseFile sourceFile, HFile targetDirectory) throws IOException,
-            CertificateException, NoSuchAlgorithmException, UnrecoverableEntryException,
-            InvalidKeyException, InvalidAlgorithmParameterException, NoSuchPaddingException,
-            NoSuchProviderException, BadPaddingException, KeyStoreException, IllegalBlockSizeException {
+    private void decrypt(final Context context, HybridFileParcelable sourceFile, HybridFile targetDirectory)
+            throws GeneralSecurityException, IOException {
 
         if (sourceFile.isDirectory()) {
 
-            HFile hFile = new HFile(targetDirectory.getMode(), targetDirectory.getPath(),
+            final HybridFile hFile = new HybridFile(targetDirectory.getMode(), targetDirectory.getPath(),
                     sourceFile.getName().replace(CRYPT_EXTENSION, ""), sourceFile.isDirectory());
             FileUtil.mkdirs(context, hFile);
 
-            for (BaseFile baseFile : sourceFile.listFiles(context, sourceFile.isRoot())) {
-                decrypt(context, baseFile, hFile);
-            }
+            sourceFile.forEachChildrenFile(context, sourceFile.isRoot(), file -> {
+                try {
+                    decrypt(context, file, hFile);
+                } catch (IOException | GeneralSecurityException e) {
+                    throw new IllegalStateException(e); //throw unchecked exception, no throws needed
+                }
+            });
         } else {
 
             if (!sourceFile.getPath().endsWith(CRYPT_EXTENSION)) {
@@ -201,7 +172,7 @@ public class CryptUtil {
             BufferedInputStream inputStream = new BufferedInputStream(sourceFile.getInputStream(context),
                     GenericCopyUtil.DEFAULT_BUFFER_SIZE);
 
-            HFile targetFile = new HFile(targetDirectory.getMode(),
+            HybridFile targetFile = new HybridFile(targetDirectory.getMode(),
                     targetDirectory.getPath(), sourceFile.getName().replace(CRYPT_EXTENSION, ""),
                     sourceFile.isDirectory());
 
@@ -225,34 +196,25 @@ public class CryptUtil {
      * @param context
      * @param sourceFile        the source file to encrypt
      * @param targetDirectory   the target directory in which we're going to encrypt
-     * @throws IOException
-     * @throws CertificateException
-     * @throws NoSuchAlgorithmException
-     * @throws UnrecoverableEntryException
-     * @throws InvalidKeyException
-     * @throws InvalidAlgorithmParameterException
-     * @throws NoSuchPaddingException
-     * @throws NoSuchProviderException
-     * @throws BadPaddingException
-     * @throws KeyStoreException
-     * @throws IllegalBlockSizeException
      */
-    private void encrypt(Context context, BaseFile sourceFile, HFile targetDirectory) throws IOException,
-            CertificateException, NoSuchAlgorithmException, UnrecoverableEntryException,
-            InvalidKeyException, InvalidAlgorithmParameterException, NoSuchPaddingException,
-            NoSuchProviderException, BadPaddingException, KeyStoreException, IllegalBlockSizeException {
+    private void encrypt(final Context context, HybridFileParcelable sourceFile, HybridFile targetDirectory)
+            throws GeneralSecurityException, IOException {
 
         if (sourceFile.isDirectory()) {
 
             // succeed #CRYPT_EXTENSION at end of directory/file name
-            HFile hFile = new HFile(targetDirectory.getMode(),
+            final HybridFile hFile = new HybridFile(targetDirectory.getMode(),
                     targetDirectory.getPath(), sourceFile.getName() + CRYPT_EXTENSION,
                     sourceFile.isDirectory());
             FileUtil.mkdirs(context, hFile);
 
-            for (BaseFile baseFile : sourceFile.listFiles(context, sourceFile.isRoot())) {
-                encrypt(context, baseFile, hFile);
-            }
+            sourceFile.forEachChildrenFile(context, sourceFile.isRoot(), file -> {
+                try {
+                    encrypt(context, file, hFile);
+                } catch (IOException | GeneralSecurityException e) {
+                    throw new IllegalStateException(e);//throw unchecked exception, no throws needed
+                }
+            });
         } else {
 
             if (sourceFile.getName().endsWith(CRYPT_EXTENSION)) {
@@ -264,7 +226,7 @@ public class CryptUtil {
                     GenericCopyUtil.DEFAULT_BUFFER_SIZE);
 
             // succeed #CRYPT_EXTENSION at end of directory/file name
-            HFile targetFile = new HFile(targetDirectory.getMode(),
+            HybridFile targetFile = new HybridFile(targetDirectory.getMode(),
                     targetDirectory.getPath(), sourceFile.getName() + CRYPT_EXTENSION,
                     sourceFile.isDirectory());
 
@@ -285,26 +247,10 @@ public class CryptUtil {
 
     /**
      * Helper method to encrypt plain text password
-     * @param plainTextPassword
-     * @return
-     * @throws CertificateException
-     * @throws NoSuchAlgorithmException
-     * @throws KeyStoreException
-     * @throws NoSuchProviderException
-     * @throws InvalidAlgorithmParameterException
-     * @throws IOException
-     * @throws NoSuchPaddingException
-     * @throws UnrecoverableKeyException
-     * @throws InvalidKeyException
-     * @throws BadPaddingException
-     * @throws IllegalBlockSizeException
      */
     @RequiresApi(api = Build.VERSION_CODES.M)
     private static String aesEncryptPassword(String plainTextPassword)
-            throws CertificateException, NoSuchAlgorithmException, KeyStoreException,
-            NoSuchProviderException, InvalidAlgorithmParameterException, IOException,
-            NoSuchPaddingException, UnrecoverableKeyException, InvalidKeyException,
-            BadPaddingException, IllegalBlockSizeException {
+            throws GeneralSecurityException, IOException {
 
         Cipher cipher = Cipher.getInstance(ALGO_AES);
         GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(128, IV.getBytes());
@@ -316,26 +262,9 @@ public class CryptUtil {
 
     /**
      * Helper method to decrypt cipher text password
-     * @param cipherPassword
-     * @return
-     * @throws NoSuchPaddingException
-     * @throws NoSuchAlgorithmException
-     * @throws CertificateException
-     * @throws UnrecoverableKeyException
-     * @throws KeyStoreException
-     * @throws NoSuchProviderException
-     * @throws InvalidAlgorithmParameterException
-     * @throws IOException
-     * @throws InvalidKeyException
-     * @throws BadPaddingException
-     * @throws IllegalBlockSizeException
      */
     @RequiresApi(api = Build.VERSION_CODES.M)
-    private static String aesDecryptPassword(String cipherPassword) throws NoSuchPaddingException,
-            NoSuchAlgorithmException, CertificateException,
-            UnrecoverableKeyException, KeyStoreException, NoSuchProviderException,
-            InvalidAlgorithmParameterException, IOException, InvalidKeyException,
-            BadPaddingException, IllegalBlockSizeException {
+    private static String aesDecryptPassword(String cipherPassword) throws GeneralSecurityException, IOException {
 
         Cipher cipher = Cipher.getInstance(ALGO_AES);
         GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(128, IV.getBytes());
@@ -349,24 +278,10 @@ public class CryptUtil {
      * Helper method to encrypt a file
      * @param inputStream stream associated with the file to be encrypted
      * @param outputStream stream associated with new output encrypted file
-     * @throws CertificateException
-     * @throws NoSuchAlgorithmException
-     * @throws KeyStoreException
-     * @throws NoSuchProviderException
-     * @throws InvalidAlgorithmParameterException
-     * @throws IOException
-     * @throws NoSuchPaddingException
-     * @throws UnrecoverableKeyException
-     * @throws InvalidKeyException
-     * @throws BadPaddingException
-     * @throws IllegalBlockSizeException
      */
     @RequiresApi(api = Build.VERSION_CODES.M)
     private static void aesEncrypt(BufferedInputStream inputStream, BufferedOutputStream outputStream)
-            throws CertificateException, NoSuchAlgorithmException, KeyStoreException,
-            NoSuchProviderException, InvalidAlgorithmParameterException, IOException,
-            NoSuchPaddingException, UnrecoverableKeyException, InvalidKeyException,
-            BadPaddingException, IllegalBlockSizeException {
+            throws GeneralSecurityException, IOException {
 
         Cipher cipher = Cipher.getInstance(ALGO_AES);
 
@@ -398,24 +313,10 @@ public class CryptUtil {
      * Helper method to decrypt file
      * @param inputStream stream associated with encrypted file
      * @param outputStream stream associated with new output decrypted file
-     * @throws NoSuchPaddingException
-     * @throws NoSuchAlgorithmException
-     * @throws CertificateException
-     * @throws UnrecoverableKeyException
-     * @throws KeyStoreException
-     * @throws NoSuchProviderException
-     * @throws InvalidAlgorithmParameterException
-     * @throws IOException
-     * @throws InvalidKeyException
-     * @throws BadPaddingException
-     * @throws IllegalBlockSizeException
      */
     @RequiresApi(api = Build.VERSION_CODES.M)
     private static void aesDecrypt(BufferedInputStream inputStream, BufferedOutputStream outputStream)
-            throws NoSuchPaddingException, NoSuchAlgorithmException, CertificateException,
-            UnrecoverableKeyException, KeyStoreException, NoSuchProviderException,
-            InvalidAlgorithmParameterException, IOException, InvalidKeyException,
-            BadPaddingException, IllegalBlockSizeException {
+            throws GeneralSecurityException, IOException {
 
         Cipher cipher = Cipher.getInstance(ALGO_AES);
         GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(128, IV.getBytes());
@@ -454,10 +355,7 @@ public class CryptUtil {
      * @throws UnrecoverableKeyException
      */
     @RequiresApi(api = Build.VERSION_CODES.M)
-    private static Key getSecretKey() throws KeyStoreException, CertificateException,
-            NoSuchAlgorithmException, IOException, NoSuchProviderException,
-            InvalidAlgorithmParameterException,
-            UnrecoverableKeyException {
+    private static Key getSecretKey() throws GeneralSecurityException, IOException {
 
         KeyStore keyStore = KeyStore.getInstance(KEY_STORE_ANDROID);
         keyStore.load(null);
@@ -480,10 +378,7 @@ public class CryptUtil {
 
     @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
     private static void rsaEncrypt(Context context, BufferedInputStream inputStream, BufferedOutputStream outputStream)
-            throws NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException,
-            CertificateException, BadPaddingException, InvalidAlgorithmParameterException,
-            KeyStoreException, UnrecoverableEntryException, IllegalBlockSizeException,
-            InvalidKeyException, IOException {
+            throws GeneralSecurityException, IOException {
 
         Cipher cipher = Cipher.getInstance(ALGO_AES, "BC");
         RSAKeygen keygen = new RSAKeygen(context);
@@ -512,10 +407,7 @@ public class CryptUtil {
 
     @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
     private static void rsaDecrypt(Context context, BufferedInputStream inputStream,
-                                   BufferedOutputStream outputStream) throws NoSuchPaddingException,
-            NoSuchAlgorithmException, NoSuchProviderException, CertificateException,
-            BadPaddingException, InvalidAlgorithmParameterException, KeyStoreException,
-            UnrecoverableEntryException, IllegalBlockSizeException, InvalidKeyException, IOException {
+                                   BufferedOutputStream outputStream) throws GeneralSecurityException, IOException {
 
         Cipher cipher = Cipher.getInstance(ALGO_AES, "BC");
         RSAKeygen keygen = new RSAKeygen(context);
@@ -543,11 +435,7 @@ public class CryptUtil {
     }
 
     @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
-    private static String rsaEncryptPassword(Context context, String password) throws
-            NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException,
-            CertificateException, BadPaddingException, InvalidAlgorithmParameterException,
-            KeyStoreException, UnrecoverableEntryException, IllegalBlockSizeException,
-            InvalidKeyException, IOException {
+    private static String rsaEncryptPassword(Context context, String password) throws GeneralSecurityException, IOException {
 
         Cipher cipher = Cipher.getInstance(ALGO_AES, "BC");
         RSAKeygen keygen = new RSAKeygen(context);
@@ -559,10 +447,7 @@ public class CryptUtil {
     }
 
     @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
-    private static String rsaDecryptPassword(Context context, String cipherText) throws NoSuchPaddingException,
-            NoSuchAlgorithmException, NoSuchProviderException, CertificateException, BadPaddingException,
-            InvalidAlgorithmParameterException, KeyStoreException, UnrecoverableEntryException,
-            IllegalBlockSizeException, InvalidKeyException, IOException {
+    private static String rsaDecryptPassword(Context context, String cipherText) throws GeneralSecurityException, IOException {
 
         Cipher cipher = Cipher.getInstance(ALGO_AES, "BC");
         RSAKeygen keygen = new RSAKeygen(context);
@@ -579,84 +464,44 @@ public class CryptUtil {
      * @param plainText
      * @return
      */
-    public static String encryptPassword(Context context, String plainText) throws CryptException {
-
-        try {
+    public static String encryptPassword(Context context, String plainText) throws GeneralSecurityException, IOException {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
 
-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-
-                return CryptUtil.aesEncryptPassword(plainText);
-            } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            return CryptUtil.aesEncryptPassword(plainText);
+        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
 
-                return CryptUtil.rsaEncryptPassword(context, plainText);
-            } else return plainText;
-        } catch (Exception e) {
-            e.printStackTrace();
-            throw new CryptException();
-        }
+            return CryptUtil.rsaEncryptPassword(context, plainText);
+        } else return plainText;
     }
 
     /**
      * Method handles decryption of cipher text on various APIs
-     * @param context
-     * @param cipherText
-     * @return
      */
-    public static String decryptPassword(Context context, String cipherText) throws CryptException {
-
-        try {
-
-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-
-                return CryptUtil.aesDecryptPassword(cipherText);
-            } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
-
-                return CryptUtil.rsaDecryptPassword(context, cipherText);
-            } else return cipherText;
-        } catch (Exception e) {
-            e.printStackTrace();
-            throw new CryptException();
-        }
+    public static String decryptPassword(Context context, String cipherText) throws GeneralSecurityException, IOException {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+            return CryptUtil.aesDecryptPassword(cipherText);
+        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            return CryptUtil.rsaDecryptPassword(context, cipherText);
+        } else return cipherText;
     }
 
     /**
      * Method initializes a Cipher to be used by {@link android.hardware.fingerprint.FingerprintManager}
-     * @param context
-     * @return
-     * @throws NoSuchPaddingException
-     * @throws NoSuchAlgorithmException
-     * @throws CertificateException
-     * @throws UnrecoverableEntryException
-     * @throws KeyStoreException
-     * @throws NoSuchProviderException
-     * @throws InvalidAlgorithmParameterException
-     * @throws IOException
-     * @throws InvalidKeyException
-     * @throws BadPaddingException
-     * @throws IllegalBlockSizeException
      */
-    public static Cipher initCipher(Context context) throws CryptException {
-
-        try {
-
-            Cipher cipher = null;
-
-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-
-                cipher = Cipher.getInstance(ALGO_AES);
-                GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(128, IV.getBytes());
-                cipher.init(Cipher.ENCRYPT_MODE, getSecretKey(), gcmParameterSpec);
-            } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
-                cipher = Cipher.getInstance(ALGO_AES, "BC");
-                RSAKeygen keygen = new RSAKeygen(context);
-
-                cipher.init(Cipher.ENCRYPT_MODE, keygen.getSecretKey());
-            }
-            return cipher;
-        } catch (Exception e) {
-            e.printStackTrace();
-            throw new CryptException();
+    public static Cipher initCipher(Context context) throws GeneralSecurityException, IOException {
+        Cipher cipher = null;
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+            cipher = Cipher.getInstance(ALGO_AES);
+            GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(128, IV.getBytes());
+            cipher.init(Cipher.ENCRYPT_MODE, getSecretKey(), gcmParameterSpec);
+        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            cipher = Cipher.getInstance(ALGO_AES, "BC");
+            RSAKeygen keygen = new RSAKeygen(context);
+
+            cipher.init(Cipher.ENCRYPT_MODE, keygen.getSecretKey());
         }
+        return cipher;
     }
 
     /**
@@ -674,45 +519,16 @@ public class CryptUtil {
             try {
                 generateKeyPair(context);
                 setKeyPreference();
-            } catch (KeyStoreException e) {
-                e.printStackTrace();
-            } catch (CertificateException e) {
-                e.printStackTrace();
-            } catch (NoSuchAlgorithmException e) {
-                e.printStackTrace();
-            } catch (IOException e) {
-                e.printStackTrace();
-            } catch (NoSuchProviderException e) {
-                e.printStackTrace();
-            } catch (InvalidAlgorithmParameterException e) {
-                e.printStackTrace();
-            } catch (NoSuchPaddingException e) {
-                e.printStackTrace();
-            } catch (InvalidKeyException e) {
-                e.printStackTrace();
-            } catch (UnrecoverableEntryException e) {
-                e.printStackTrace();
-            } catch (IllegalBlockSizeException e) {
-                e.printStackTrace();
-            } catch (BadPaddingException e) {
+            } catch (GeneralSecurityException | IOException e) {
                 e.printStackTrace();
             }
         }
 
         /**
          * Generates a RSA public/private key pair to encrypt AES key
-         * @param context
-         * @throws KeyStoreException
-         * @throws CertificateException
-         * @throws NoSuchAlgorithmException
-         * @throws IOException
-         * @throws NoSuchProviderException
-         * @throws InvalidAlgorithmParameterException
          */
         @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
-        private void generateKeyPair(Context context) throws KeyStoreException,
-                CertificateException, NoSuchAlgorithmException, IOException, NoSuchProviderException,
-                InvalidAlgorithmParameterException {
+        private void generateKeyPair(Context context) throws GeneralSecurityException, IOException {
 
             KeyStore keyStore = KeyStore.getInstance(KEY_STORE_ANDROID);
             keyStore.load(null);
@@ -741,10 +557,7 @@ public class CryptUtil {
         /**
          * Encrypts AES key and set into preference
          */
-        private void setKeyPreference() throws IOException, CertificateException,
-                NoSuchAlgorithmException, InvalidKeyException, UnrecoverableEntryException,
-                NoSuchPaddingException, NoSuchProviderException, BadPaddingException,
-                KeyStoreException, IllegalBlockSizeException {
+        private void setKeyPreference() throws GeneralSecurityException, IOException {
 
             SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(context);
             String encodedAesKey = preferences.getString(PREFERENCE_KEY, null);
@@ -764,12 +577,8 @@ public class CryptUtil {
 
         /**
          * Encrypts randomly generated AES key using RSA public key
-         * @param secretKey
-         * @return
          */
-        private byte[] encryptAESKey(byte[] secretKey) throws KeyStoreException,
-                UnrecoverableEntryException, NoSuchAlgorithmException, IOException,
-                CertificateException, NoSuchProviderException, NoSuchPaddingException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
+        private byte[] encryptAESKey(byte[] secretKey) throws GeneralSecurityException, IOException {
 
             KeyStore keyStore = KeyStore.getInstance(KEY_STORE_ANDROID);
             keyStore.load(null);
@@ -788,23 +597,9 @@ public class CryptUtil {
 
         /**
          * Decodes encrypted AES key from preference and decrypts using RSA private key
-         * @return
-         * @throws CertificateException
-         * @throws NoSuchPaddingException
-         * @throws InvalidKeyException
-         * @throws NoSuchAlgorithmException
-         * @throws KeyStoreException
-         * @throws NoSuchProviderException
-         * @throws UnrecoverableEntryException
-         * @throws IOException
-         * @throws InvalidAlgorithmParameterException
-         * @throws BadPaddingException
-         * @throws IllegalBlockSizeException
          */
         @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
-        private Key getSecretKey() throws CertificateException, NoSuchPaddingException, InvalidKeyException,
-                NoSuchAlgorithmException, KeyStoreException, NoSuchProviderException, UnrecoverableEntryException,
-                IOException, InvalidAlgorithmParameterException, BadPaddingException, IllegalBlockSizeException {
+        private Key getSecretKey() throws GeneralSecurityException, IOException {
 
             SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(context);
             String encodedString = preferences.getString(PREFERENCE_KEY, null);
@@ -820,20 +615,8 @@ public class CryptUtil {
 
         /**
          * Decrypts AES decoded key from preference using RSA private key
-         * @param encodedBytes
-         * @return
-         * @throws KeyStoreException
-         * @throws CertificateException
-         * @throws NoSuchAlgorithmException
-         * @throws IOException
-         * @throws UnrecoverableEntryException
-         * @throws NoSuchProviderException
-         * @throws NoSuchPaddingException
-         * @throws InvalidKeyException
          */
-        private byte[] decryptAESKey(byte[] encodedBytes) throws KeyStoreException, CertificateException, NoSuchAlgorithmException,
-                IOException, UnrecoverableEntryException, NoSuchProviderException, NoSuchPaddingException,
-                InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
+        private byte[] decryptAESKey(byte[] encodedBytes) throws GeneralSecurityException, IOException {
 
             KeyStore keyStore = KeyStore.getInstance(KEY_STORE_ANDROID);
             keyStore.load(null);
diff --git a/app/src/main/java/com/amaze/filemanager/utils/files/EncryptDecryptUtils.java b/app/src/main/java/com/amaze/filemanager/utils/files/EncryptDecryptUtils.java
index c458f5c8a..3165583d1 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/files/EncryptDecryptUtils.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/files/EncryptDecryptUtils.java
@@ -5,23 +5,24 @@ import android.content.Intent;
 import android.content.SharedPreferences;
 import android.os.Build;
 import android.preference.PreferenceManager;
-import android.util.Log;
 import android.widget.Toast;
 
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.MainActivity;
 import com.amaze.filemanager.database.CryptHandler;
 import com.amaze.filemanager.database.models.EncryptedEntry;
-import com.amaze.filemanager.exceptions.CryptException;
-import com.amaze.filemanager.filesystem.BaseFile;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.fragments.MainFragment;
-import com.amaze.filemanager.fragments.preference_fragments.Preffrag;
-import com.amaze.filemanager.services.EncryptService;
+import com.amaze.filemanager.fragments.preference_fragments.PrefFrag;
+import com.amaze.filemanager.asynchronous.services.EncryptService;
 import com.amaze.filemanager.ui.dialogs.GeneralDialogCreation;
 import com.amaze.filemanager.utils.OpenMode;
 import com.amaze.filemanager.utils.ServiceWatcherUtil;
 import com.amaze.filemanager.utils.provider.UtilitiesProviderInterface;
 
+import java.io.IOException;
+import java.security.GeneralSecurityException;
+
 /**
  * Provides useful interfaces and methods for encryption/decryption
  *
@@ -31,6 +32,7 @@ import com.amaze.filemanager.utils.provider.UtilitiesProviderInterface;
 
 public class EncryptDecryptUtils {
 
+    public static final String DECRYPT_BROADCAST = "decrypt_broadcast";
     /**
      * Queries database to map path and password.
      * Starts the encryption process after database query
@@ -51,8 +53,9 @@ public class EncryptDecryptUtils {
 
 
     public static void decryptFile(Context c, final MainActivity mainActivity, final MainFragment main, OpenMode openMode,
-                                   BaseFile sourceFile, String decryptPath,
-                                   UtilitiesProviderInterface utilsProvider) {
+                                   HybridFileParcelable sourceFile, String decryptPath,
+                                   UtilitiesProviderInterface utilsProvider,
+                                   boolean broadcastResult) {
 
         Intent decryptIntent = new Intent(main.getContext(), EncryptService.class);
         decryptIntent.putExtra(EncryptService.TAG_OPEN_MODE, openMode.ordinal());
@@ -60,13 +63,14 @@ public class EncryptDecryptUtils {
                 EncryptService.CryptEnum.DECRYPT.ordinal());
         decryptIntent.putExtra(EncryptService.TAG_SOURCE, sourceFile);
         decryptIntent.putExtra(EncryptService.TAG_DECRYPT_PATH, decryptPath);
+        decryptIntent.putExtra(EncryptService.TAG_BROADCAST_RESULT, broadcastResult);
         SharedPreferences preferences1 = PreferenceManager.getDefaultSharedPreferences(main.getContext());
 
-        EncryptedEntry encryptedEntry = null;
+        EncryptedEntry encryptedEntry;
 
         try {
             encryptedEntry = findEncryptedEntry(main.getContext(), sourceFile.getPath());
-        } catch (CryptException e) {
+        } catch (GeneralSecurityException | IOException e) {
             e.printStackTrace();
 
             // we couldn't find any entry in database or lost the key to decipher
@@ -87,34 +91,35 @@ public class EncryptDecryptUtils {
                     }
                 };
 
+        if (encryptedEntry == null) {
+            // couldn't find the matching path in database, we lost the password
+
+            Toast.makeText(main.getContext(), main.getActivity().getResources().getString(R.string.crypt_decryption_fail), Toast.LENGTH_LONG).show();
+            return;
+        }
+
         switch (encryptedEntry.getPassword()) {
-            case Preffrag.ENCRYPT_PASSWORD_FINGERPRINT:
+            case PrefFrag.ENCRYPT_PASSWORD_FINGERPRINT:
                 try {
                     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                         GeneralDialogCreation.showDecryptFingerprintDialog(c,
                                 mainActivity, decryptIntent, utilsProvider.getAppTheme(), decryptButtonCallbackInterface);
-                    } else throw new CryptException();
-                } catch (CryptException e) {
+                    } else throw new IllegalStateException("API < M!");
+                } catch (GeneralSecurityException | IOException | IllegalStateException e) {
                     e.printStackTrace();
 
-                    Toast.makeText(main.getContext(),
-                            main.getResources().getString(R.string.crypt_decryption_fail),
-                            Toast.LENGTH_LONG).show();
+                    Toast.makeText(main.getContext(), main.getResources().getString(R.string.crypt_decryption_fail), Toast.LENGTH_LONG).show();
                 }
                 break;
-            case Preffrag.ENCRYPT_PASSWORD_MASTER:
+            case PrefFrag.ENCRYPT_PASSWORD_MASTER:
                 try {
                     GeneralDialogCreation.showDecryptDialog(c,
                             mainActivity, decryptIntent, utilsProvider.getAppTheme(),
-                            CryptUtil.decryptPassword(c, preferences1.getString(Preffrag.PREFERENCE_CRYPT_MASTER_PASSWORD,
-                                    Preffrag.PREFERENCE_CRYPT_MASTER_PASSWORD_DEFAULT)), decryptButtonCallbackInterface);
-                } catch (CryptException e) {
+                            CryptUtil.decryptPassword(c, preferences1.getString(PrefFrag.PREFERENCE_CRYPT_MASTER_PASSWORD,
+                                    PrefFrag.PREFERENCE_CRYPT_MASTER_PASSWORD_DEFAULT)), decryptButtonCallbackInterface);
+                } catch (GeneralSecurityException | IOException e) {
                     e.printStackTrace();
-
-
-                    Toast.makeText(main.getContext(),
-                            main.getResources().getString(R.string.crypt_decryption_fail),
-                            Toast.LENGTH_LONG).show();
+                    Toast.makeText(main.getContext(), main.getResources().getString(R.string.crypt_decryption_fail), Toast.LENGTH_LONG).show();
                 }
                 break;
             default:
@@ -131,7 +136,7 @@ public class EncryptDecryptUtils {
      * @param path the path to match with
      * @return the entry
      */
-    private static EncryptedEntry findEncryptedEntry(Context context, String path) throws CryptException {
+    private static EncryptedEntry findEncryptedEntry(Context context, String path) throws GeneralSecurityException, IOException {
 
         CryptHandler handler = new CryptHandler(context);
 
diff --git a/app/src/main/java/com/amaze/filemanager/utils/files/FileListSorter.java b/app/src/main/java/com/amaze/filemanager/utils/files/FileListSorter.java
index 41f7d2324..4f38db915 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/files/FileListSorter.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/files/FileListSorter.java
@@ -19,11 +19,11 @@
 
 package com.amaze.filemanager.utils.files;
 
-import com.amaze.filemanager.ui.LayoutElement;
+import com.amaze.filemanager.ui.LayoutElementParcelable;
 
 import java.util.Comparator;
 
-public class FileListSorter implements Comparator<LayoutElement> {
+public class FileListSorter implements Comparator<LayoutElementParcelable> {
 
     private int dirsOnTop = 0;
     private int asc = 1;
@@ -35,7 +35,7 @@ public class FileListSorter implements Comparator<LayoutElement> {
         this.sort = sort;
     }
 
-    private boolean isDirectory(LayoutElement path) {
+    private boolean isDirectory(LayoutElementParcelable path) {
         return path.isDirectory();
     }
 
@@ -47,7 +47,7 @@ public class FileListSorter implements Comparator<LayoutElement> {
      * @return
      */
     @Override
-    public int compare(LayoutElement file1, LayoutElement file2) {
+    public int compare(LayoutElementParcelable file1, LayoutElementParcelable file2) {
 
         /*File f1;
 
diff --git a/app/src/main/java/com/amaze/filemanager/utils/files/Futils.java b/app/src/main/java/com/amaze/filemanager/utils/files/FileUtils.java
similarity index 57%
rename from app/src/main/java/com/amaze/filemanager/utils/files/Futils.java
rename to app/src/main/java/com/amaze/filemanager/utils/files/FileUtils.java
index 973be8b02..3ae8b7fef 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/files/Futils.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/files/FileUtils.java
@@ -31,63 +31,60 @@ import android.content.SharedPreferences;
 import android.content.pm.PackageManager;
 import android.content.pm.ResolveInfo;
 import android.database.Cursor;
-import android.graphics.drawable.BitmapDrawable;
 import android.media.MediaScannerConnection;
 import android.net.Uri;
 import android.os.AsyncTask;
 import android.os.Build;
-import android.os.Bundle;
 import android.os.CountDownTimer;
 import android.preference.PreferenceManager;
 import android.provider.BaseColumns;
 import android.provider.MediaStore;
 import android.support.v4.provider.DocumentFile;
 import android.text.TextUtils;
+import android.util.Log;
 import android.view.View;
 import android.widget.Toast;
 
 import com.afollestad.materialdialogs.MaterialDialog;
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.activities.DbViewer;
+import com.amaze.filemanager.activities.DatabaseViewerActivity;
 import com.amaze.filemanager.activities.MainActivity;
-import com.amaze.filemanager.filesystem.BaseFile;
-import com.amaze.filemanager.filesystem.HFile;
-import com.amaze.filemanager.ui.LayoutElement;
+import com.amaze.filemanager.filesystem.HybridFile;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
+import com.amaze.filemanager.fragments.preference_fragments.PrefFrag;
 import com.amaze.filemanager.ui.dialogs.GeneralDialogCreation;
 import com.amaze.filemanager.ui.icons.Icons;
 import com.amaze.filemanager.ui.icons.MimeTypes;
-import com.amaze.filemanager.utils.AppConfig;
+
 import com.amaze.filemanager.utils.DataUtils;
 import com.amaze.filemanager.utils.OTGUtil;
+import com.amaze.filemanager.utils.OnFileFound;
 import com.amaze.filemanager.utils.OnProgressUpdate;
 import com.amaze.filemanager.utils.OpenMode;
+import com.amaze.filemanager.utils.application.AppConfig;
 import com.amaze.filemanager.utils.cloud.CloudUtil;
 import com.amaze.filemanager.utils.share.ShareTask;
 import com.amaze.filemanager.utils.theme.AppTheme;
 import com.cloudrail.si.interfaces.CloudStorage;
 import com.cloudrail.si.types.CloudMetaData;
+import com.googlecode.concurrenttrees.radix.ConcurrentRadixTree;
+import com.googlecode.concurrenttrees.radix.node.concrete.voidvalue.VoidValue;
 
 import java.io.File;
 import java.text.ParsePosition;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.Date;
+import java.util.LinkedList;
+import java.util.concurrent.atomic.AtomicLong;
 
 import jcifs.smb.SmbFile;
 
 /**
  * Functions that deal with files
  */
-public class Futils {
-
-    public static final int READ = 4;
-    public static final int WRITE = 2;
-    public static final int EXECUTE = 1;
-    private Toast studioCount;
-    private DataUtils dataUtils = DataUtils.getInstance();
-
-    public Futils() {
-    }
+public class FileUtils {
 
     public static long folderSize(File directory, OnProgressUpdate<Long> updateState) {
         long length = 0;
@@ -107,7 +104,7 @@ public class Futils {
         return length;
     }
 
-    public static long folderSize(HFile directory, OnProgressUpdate<Long> updateState) {
+    public static long folderSize(HybridFile directory, OnProgressUpdate<Long> updateState) {
         if(directory.isSftp())
             return directory.folderSize(AppConfig.getInstance());
         else
@@ -150,22 +147,29 @@ public class Futils {
     /**
      * Helper method to get size of an otg folder
      */
-    public static long folderSize(String path, Context context) {
-        return getTotalBytes(OTGUtil.getDocumentFilesList(path, context), context);
+    public static long otgFolderSize(String path, final Context context) {
+        final AtomicLong totalBytes = new AtomicLong(0);
+        OTGUtil.getDocumentFiles(path, context, new OnFileFound() {
+            @Override
+            public void onFileFound(HybridFileParcelable file) {
+                totalBytes.addAndGet(getBaseFileSize(file, context));
+            }
+        });
+        return totalBytes.longValue();
     }
 
     /**
      * Helper method to calculate source files size
      */
-    public static long getTotalBytes(ArrayList<BaseFile> files, Context context) {
+    public static long getTotalBytes(ArrayList<HybridFileParcelable> files, Context context) {
         long totalBytes = 0L;
-        for (BaseFile file : files) {
+        for (HybridFileParcelable file : files) {
             totalBytes += getBaseFileSize(file, context);
         }
         return totalBytes;
     }
 
-    private static long getBaseFileSize(BaseFile baseFile, Context context) {
+    private static long getBaseFileSize(HybridFileParcelable baseFile, Context context) {
         if (baseFile.isDirectory(context)) {
             return baseFile.folderSize(context);
         } else {
@@ -175,22 +179,26 @@ public class Futils {
 
     public static void scanFile(String path, Context c) {
         System.out.println(path + " " + Build.VERSION.SDK_INT);
-        if (Build.VERSION.SDK_INT >= 19) {
-            MediaScannerConnection.scanFile(c, new String[]{path}, null, new MediaScannerConnection.OnScanCompletedListener() {
 
-                @Override
-                public void onScanCompleted(String path, Uri uri) {
+        Uri contentUri = Uri.fromFile(new File(path));
+        Intent mediaScanIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, contentUri);
+        c.sendBroadcast(mediaScanIntent);
+    }
 
-                }
-            });
-        } else {
-            Uri contentUri = Uri.fromFile(new File(path));
-            Intent mediaScanIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, contentUri);
-            c.sendBroadcast(mediaScanIntent);
-        }
+    /**
+     * Starts a media scanner to let file system know changes done to files
+     */
+    public static void scanFile(final Context context, final MediaScannerConnection mediaScannerConnection, final String[] paths) {
+
+        Log.d("SCAN started", paths[0]);
+
+        AppConfig.runInBackground(() -> {
+                mediaScannerConnection.connect();
+                mediaScannerConnection.scanFile(context, paths, null, null);
+        });
     }
 
-    public void crossfade(View buttons,final View pathbar) {
+    public static void crossfade(View buttons,final View pathbar) {
         // Set the content view to 0% opacity but visible, so that it is visible
         // (but fully transparent) during the animation.
         buttons.setAlpha(0f);
@@ -217,7 +225,7 @@ public class Futils {
         // participate in layout passes, etc.)
     }
 
-    public void revealShow(final View view, boolean reveal) {
+    public static void revealShow(final View view, boolean reveal) {
         if (reveal) {
             ObjectAnimator animator = ObjectAnimator.ofFloat(view, View.ALPHA, 0f, 1f);
             animator.setDuration(300); //ms
@@ -242,7 +250,7 @@ public class Futils {
         }
     }
 
-    public void crossfadeInverse(final View buttons,final View pathbar) {
+    public static void crossfadeInverse(final View buttons,final View pathbar) {
         // Set the content view to 0% opacity but visible, so that it is visible
         // (but fully transparent) during the animation.
 
@@ -269,17 +277,13 @@ public class Futils {
         // participate in layout passes, etc.)
     }
 
-    public void shareFiles(ArrayList<File> a, Activity c,int theme,int fab_skin) {
-        shareFiles(a,c, AppTheme.fromIndex(theme), fab_skin);
-    }
-
-    public void shareCloudFile(String path, final OpenMode openMode, final Context context) {
+    public static void shareCloudFile(String path, final OpenMode openMode, final Context context) {
         new AsyncTask<String, Void, String>() {
 
             @Override
             protected String doInBackground(String... params) {
                 String shareFilePath = params[0];
-                CloudStorage cloudStorage = dataUtils.getAccount(openMode);
+                CloudStorage cloudStorage = DataUtils.getInstance().getAccount(openMode);
                 return cloudStorage.createShareLink(CloudUtil.stripPath(openMode, shareFilePath));
             }
 
@@ -287,20 +291,21 @@ public class Futils {
             protected void onPostExecute(String s) {
                 super.onPostExecute(s);
 
-                Futils.copyToClipboard(context, s);
+                FileUtils.copyToClipboard(context, s);
                 Toast.makeText(context,
                         context.getResources().getString(R.string.cloud_share_copied), Toast.LENGTH_LONG).show();
             }
         }.execute(path);
     }
 
-    public void shareFiles(ArrayList<File> a, Activity c,AppTheme appTheme,int fab_skin) {
+    public static void shareFiles(ArrayList<File> a, Activity c,AppTheme appTheme,int fab_skin) {
+
         ArrayList<Uri> uris = new ArrayList<>();
         boolean b = true;
         for (File f : a) {
             uris.add(Uri.fromFile(f));
         }
-        System.out.println("uri done");
+
         String mime = MimeTypes.getMimeType(a.get(0));
         if (a.size() > 1)
             for (File f : a) {
@@ -320,57 +325,88 @@ public class Futils {
     }
 
     public static float readableFileSizeFloat(long size) {
-        if (size <= 0)
-            return 0;
-        float digitGroups = (float) (size / (1024*1024));
-        return digitGroups;
+        if (size <= 0) return 0;
+        return (float) (size / (1024*1024));
     }
 
-    public static void openunknown(File f, Context c, boolean forcechooser) {
-        Intent intent = new Intent();
-        intent.setAction(android.content.Intent.ACTION_VIEW);
+    /**
+     * Open a file not supported by Amaze
+     * @param f the file
+     * @param c
+     * @param forcechooser force the chooser to show up even when set default by user
+     */
+    public static void openunknown(File f, Context c, boolean forcechooser, boolean useNewStack) {
+        Intent chooserIntent = new Intent();
+        chooserIntent.setAction(Intent.ACTION_VIEW);
 
         String type = MimeTypes.getMimeType(f);
-        if(type!=null && type.trim().length()!=0 && !type.equals("*/*"))
-        {
-            Uri uri=fileToContentUri(c, f);
-            if(uri==null)uri=Uri.fromFile(f);
-            intent.setDataAndType(uri, type);
-        Intent startintent;
-        if (forcechooser) startintent=Intent.createChooser(intent, c.getResources().getString(R.string.openwith));
-        else startintent=intent;
-        try {
-            c.startActivity(startintent);
-        } catch (ActivityNotFoundException e) {
-            e.printStackTrace();
-        Toast.makeText(c,R.string.noappfound,Toast.LENGTH_SHORT).show();
-        openWith(f,c);
-        }}else{openWith(f, c);}
+        if (type != null && type.trim().length() != 0 && !type.equals("*/*")) {
+            Uri uri = fileToContentUri(c, f);
+            if (uri == null) uri = Uri.fromFile(f);
+            chooserIntent.setDataAndType(uri, type);
+
+            Intent activityIntent;
+            if (forcechooser) {
+                if(useNewStack) applyNewDocFlag(chooserIntent);
+                activityIntent = Intent.createChooser(chooserIntent, c.getResources().getString(R.string.openwith));
+            } else {
+                activityIntent = chooserIntent;
+                if(useNewStack) applyNewDocFlag(activityIntent);
+            }
 
+            try {
+                c.startActivity(activityIntent);
+            } catch (ActivityNotFoundException e) {
+                e.printStackTrace();
+                Toast.makeText(c, R.string.noappfound, Toast.LENGTH_SHORT).show();
+                openWith(f, c, useNewStack);
+            }
+        } else {
+            // failed to load mime type
+            openWith(f, c, useNewStack);
+        }
     }
 
-    public void openunknown(DocumentFile f, Context c, boolean forcechooser) {
-        Intent intent = new Intent();
-        intent.setAction(Intent.ACTION_VIEW);
-        intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
+    /**
+     * Open file from OTG
+     */
+    public static void openunknown(DocumentFile f, Context c, boolean forcechooser, boolean useNewStack) {
+        Intent chooserIntent = new Intent();
+        chooserIntent.setAction(Intent.ACTION_VIEW);
+        chooserIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
 
         String type = f.getType();
-        if(type!=null && type.trim().length()!=0 && !type.equals("*/*")) {
-            intent.setDataAndType(f.getUri(), type);
-            Intent startintent;
-            if (forcechooser) startintent=Intent.createChooser(intent, c.getResources().getString(R.string.openwith));
-            else startintent=intent;
+        if (type != null && type.trim().length() != 0 && !type.equals("*/*")) {
+            chooserIntent.setDataAndType(f.getUri(), type);
+            Intent activityIntent;
+            if (forcechooser) {
+                if(useNewStack) applyNewDocFlag(chooserIntent);
+                activityIntent = Intent.createChooser(chooserIntent, c.getResources().getString(R.string.openwith));
+            } else {
+                activityIntent = chooserIntent;
+                if(useNewStack) applyNewDocFlag(chooserIntent);
+            }
+
             try {
-                c.startActivity(startintent);
+                c.startActivity(activityIntent);
             } catch (ActivityNotFoundException e) {
                 e.printStackTrace();
-                Toast.makeText(c,R.string.noappfound,Toast.LENGTH_SHORT).show();
-                openWith(f,c);
+                Toast.makeText(c, R.string.noappfound, Toast.LENGTH_SHORT).show();
+                openWith(f, c, useNewStack);
             }
         } else {
-            openWith(f, c);
+            openWith(f, c, useNewStack);
         }
+    }
 
+    private static void applyNewDocFlag(Intent i) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            i.addFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT);
+        } else {
+
+            i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME
+                | Intent.FLAG_ACTIVITY_RETAIN_IN_RECENTS);
+        }
     }
 
     private static final String INTERNAL_VOLUME = "internal";
@@ -460,45 +496,46 @@ public class Futils {
         return null;
     }
 
-    public static void openWith(final File f,final Context c) {
+    /**
+     * Method supports showing a UI to ask user to open a file without any extension/mime
+     */
+    public static void openWith(final File f, final Context c, final boolean useNewStack) {
         MaterialDialog.Builder a=new MaterialDialog.Builder(c);
         a.title(c.getResources().getString(R.string.openas));
         String[] items=new String[]{c.getResources().getString(R.string.text),c.getResources().getString(R.string.image),c.getResources().getString(R.string.video),c.getResources().getString(R.string.audio),c.getResources().getString(R.string.database),c.getResources().getString(R.string.other)};
 
-        a.items(items).itemsCallback(new MaterialDialog.ListCallback() {
-            @Override
-            public void onSelection(MaterialDialog materialDialog, View view, int i, CharSequence charSequence) {
-                Uri uri = fileToContentUri(c, f);
-                if (uri == null) uri = Uri.fromFile(f);
-                Intent intent = new Intent();
-                intent.setAction(android.content.Intent.ACTION_VIEW);
-                switch (i) {
-                    case 0:
-                        intent.setDataAndType(uri, "text/*");
-                        break;
-                    case 1:
-                        intent.setDataAndType(uri, "image/*");
-                        break;
-                    case 2:
-                        intent.setDataAndType(uri, "video/*");
-                        break;
-                    case 3:
-                        intent.setDataAndType(uri, "audio/*");
-                        break;
-                    case 4:
-                        intent = new Intent(c, DbViewer.class);
-                        intent.putExtra("path", f.getPath());
-                        break;
-                    case 5:
-                        intent.setDataAndType(uri, "*/*");
-                        break;
-                }
-                try {
-                    c.startActivity(intent);
-                } catch (Exception e) {
-                    Toast.makeText(c, R.string.noappfound, Toast.LENGTH_SHORT).show();
-                    openWith(f, c);
-                }
+        a.items(items).itemsCallback((materialDialog, view, i, charSequence) -> {
+            Uri uri = fileToContentUri(c, f);
+            if (uri == null) uri = Uri.fromFile(f);
+            Intent intent = new Intent();
+            intent.setAction(Intent.ACTION_VIEW);
+            switch (i) {
+                case 0:
+                    if(useNewStack) applyNewDocFlag(intent);
+                    intent.setDataAndType(uri, "text/*");
+                    break;
+                case 1:
+                    intent.setDataAndType(uri, "image/*");
+                    break;
+                case 2:
+                    intent.setDataAndType(uri, "video/*");
+                    break;
+                case 3:
+                    intent.setDataAndType(uri, "audio/*");
+                    break;
+                case 4:
+                    intent = new Intent(c, DatabaseViewerActivity.class);
+                    intent.putExtra("path", f.getPath());
+                    break;
+                case 5:
+                    intent.setDataAndType(uri, "*/*");
+                    break;
+            }
+            try {
+                c.startActivity(intent);
+            } catch (Exception e) {
+                Toast.makeText(c, R.string.noappfound, Toast.LENGTH_SHORT).show();
+                openWith(f, c, useNewStack);
             }
         });
         try {
@@ -508,61 +545,52 @@ public class Futils {
         }
     }
 
-    public void openWith(final DocumentFile f,final Context c) {
-        MaterialDialog.Builder a=new MaterialDialog.Builder(c);
+    public static void openWith(final DocumentFile f, final Context c, final boolean useNewStack) {
+        MaterialDialog.Builder a = new MaterialDialog.Builder(c);
         a.title(c.getResources().getString(R.string.openas));
-        String[] items=new String[]{c.getResources().getString(R.string.text),c.getResources().getString(R.string.image),c.getResources().getString(R.string.video),c.getResources().getString(R.string.audio),c.getResources().getString(R.string.database),c.getResources().getString(R.string.other)};
+        String[] items = new String[]{c.getResources().getString(R.string.text), c.getResources().getString(R.string.image), c.getResources().getString(R.string.video), c.getResources().getString(R.string.audio), c.getResources().getString(R.string.database), c.getResources().getString(R.string.other)};
 
-        a.items(items).itemsCallback(new MaterialDialog.ListCallback() {
-            @Override
-            public void onSelection(MaterialDialog materialDialog, View view, int i, CharSequence charSequence) {
-
-                Intent intent = new Intent();
-                intent.setAction(android.content.Intent.ACTION_VIEW);
-                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
-                switch (i) {
-                    case 0:
-                        intent.setDataAndType(f.getUri(), "text/*");
-                        break;
-                    case 1:
-                        intent.setDataAndType(f.getUri(), "image/*");
-                        break;
-                    case 2:
-                        intent.setDataAndType(f.getUri(), "video/*");
-                        break;
-                    case 3:
-                        intent.setDataAndType(f.getUri(), "audio/*");
-                        break;
-                    case 4:
-                        intent = new Intent(c, DbViewer.class);
-                        intent.putExtra("path", f.getUri());
-                        break;
-                    case 5:
-                        intent.setDataAndType(f.getUri(), "*/*");
-                        break;
-                }
-                try {
-                    c.startActivity(intent);
-                } catch (Exception e) {
-                    Toast.makeText(c, R.string.noappfound, Toast.LENGTH_SHORT).show();
-                    openWith(f, c);
-                }
+        a.items(items).itemsCallback((materialDialog, view, i, charSequence) -> {
+            Intent intent = new Intent();
+            intent.setAction(Intent.ACTION_VIEW);
+            intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
+            switch (i) {
+                case 0:
+                    if(useNewStack) applyNewDocFlag(intent);
+                    intent.setDataAndType(f.getUri(), "text/*");
+                    break;
+                case 1:
+                    intent.setDataAndType(f.getUri(), "image/*");
+                    break;
+                case 2:
+                    intent.setDataAndType(f.getUri(), "video/*");
+                    break;
+                case 3:
+                    intent.setDataAndType(f.getUri(), "audio/*");
+                    break;
+                case 4:
+                    intent = new Intent(c, DatabaseViewerActivity.class);
+                    intent.putExtra("path", f.getUri());
+                    break;
+                case 5:
+                    intent.setDataAndType(f.getUri(), "*/*");
+                    break;
+            }
+            try {
+                c.startActivity(intent);
+            } catch (Exception e) {
+                Toast.makeText(c, R.string.noappfound, Toast.LENGTH_SHORT).show();
+                openWith(f, c, useNewStack);
             }
         });
-        try {
-            a.build().show();
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
+
+        a.build().show();
     }
 
     /**
      * Method determines if there is something to go back to
-     * @param currentFile
-     * @param context
-     * @return
      */
-    public boolean canGoBack(Context context, HFile currentFile) {
+    public static boolean canGoBack(Context context, HybridFile currentFile) {
         switch (currentFile.getMode()) {
 
             // we're on main thread and can't list the cloud files
@@ -574,93 +602,11 @@ public class Futils {
             case SFTP:
                 return true;
             default:
-                HFile parentFile = new HFile(currentFile.getMode(), currentFile.getParent(context));
-                ArrayList<BaseFile> parentFiles = parentFile.listFiles(context, currentFile.isRoot());
-                if (parentFiles == null) return false;
-                else return true;
+                return true;// TODO: 29/9/2017 there might be nothing to go back to (check parent)
         }
     }
 
-    public static long[] getSpaces(HFile hFile, Context context, final OnProgressUpdate<Long[]> updateState) {
-        /*if(hFile.isSmb()) {
-            if (hFile.isDirectory(context)) {
-
-            }
-            return new long[]{-1, -1, -1};
-        } else if (hFile.isDropBoxFile()) {
-            CloudStorage cloudStorageDropbox = dataUtils.getAccount(OpenMode.DROPBOX);
-            CloudMetaData fileMetaDataDropbox = cloudStorageDropbox.getMetadata(CloudUtil.stripPath(OpenMode.DROPBOX,
-                    hFile.getPath()));
-
-            return new long[]{cloudStorageDropbox.getAllocation().getTotal(),
-                    (cloudStorageDropbox.getAllocation().getTotal() - cloudStorageDropbox.getAllocation().getUsed()),
-                    folderSizeCloud(OpenMode.DROPBOX, fileMetaDataDropbox)
-            };
-        } else if (hFile.isBoxFile()) {
-            CloudStorage cloudStorageBox = dataUtils.getAccount(OpenMode.BOX);
-            CloudMetaData fileMetaDataBox = cloudStorageBox.getMetadata(CloudUtil.stripPath(OpenMode.BOX,
-                    hFile.getPath()));
-
-            return new long[]{cloudStorageBox.getAllocation().getTotal(),
-                    (cloudStorageBox.getAllocation().getTotal() - cloudStorageBox.getAllocation().getUsed()),
-                    folderSizeCloud(OpenMode.BOX, fileMetaDataBox)
-            };
-        } else if (hFile.isGoogleDriveFile()) {
-            CloudStorage cloudStorageGDrive = dataUtils.getAccount(OpenMode.GDRIVE);
-
-            CloudMetaData fileMetaDataGDrive = cloudStorageGDrive.getMetadata(CloudUtil.stripPath(OpenMode.GDRIVE,
-                    hFile.getPath()));
-
-            return new long[]{cloudStorageGDrive.getAllocation().getTotal(),
-                    (cloudStorageGDrive.getAllocation().getTotal() - cloudStorageGDrive.getAllocation().getUsed()),
-                    folderSizeCloud(OpenMode.GDRIVE, fileMetaDataGDrive)
-            };
-        } else if (hFile.isOneDriveFile()) {
-            CloudStorage cloudStorageOneDrive = dataUtils.getAccount(OpenMode.ONEDRIVE);
-
-            CloudMetaData fileMetaDataOneDrive = cloudStorageOneDrive.getMetadata(CloudUtil.stripPath(OpenMode.ONEDRIVE,
-                    hFile.getPath()));
-            return new long[]{cloudStorageOneDrive.getAllocation().getTotal(),
-                    (cloudStorageOneDrive.getAllocation().getTotal() - cloudStorageOneDrive.getAllocation().getUsed()),
-                    folderSizeCloud(OpenMode.ONEDRIVE, fileMetaDataOneDrive)
-            };
-        } else if (!hFile.isOtgFile() && !hFile.isCustomPath()
-                && !android.util.Patterns.EMAIL_ADDRESS.matcher(hFile.getPath()).matches()) {
-            try {
-                File file = new File(hFile.getPath());
-                final long totalSpace = file.getTotalSpace(),
-                        freeSpace = file.getFreeSpace(),
-                        folderSize = folderSize(hFile,
-                                new OnProgressUpdate<Long>() {
-                                    @Override
-                                    public void onUpdate(Long data) {
-                                        if(updateState != null)
-                                            updateState.onUpdate(new Long[] {totalSpace, freeSpace, data});
-                                    }
-                                });
-
-                final long totalSpace = hFile.length(context);
-                final long freeSpace = hFile.getUsableSpace();
-                long folderSize = 0l;
-
-                if (hFile.isDirectory(context)) {
-                    folderSize = folderSize(new File(hFile.getPath()),
-                            new OnProgressUpdate<Long>() {
-                                @Override
-                                public void onUpdate(Long data) {
-                                    if(updateState != null)
-                                        updateState.onUpdate(new Long[] {totalSpace, freeSpace, data});
-                                }
-                    });
-                }
-                return new long[] {totalSpace, freeSpace, folderSize};
-            } catch (Exception e) {
-                return new long[]{-1, -1, -1};
-            }
-        } else {
-            return new long[]{-1, -1, -1};
-        }*/
-
+    public static long[] getSpaces(HybridFile hFile, Context context, final OnProgressUpdate<Long[]> updateState) {
         long totalSpace = hFile.getTotal(context);
         long freeSpace = hFile.getUsableSpace();
         long fileSize = 0l;
@@ -686,49 +632,37 @@ public class Futils {
         }
     }
 
-    public Bundle getPaths(String path, Context c) {
-        ArrayList<String> names = new ArrayList<>();
+    public static String[] getFolderNamesInPath(String path) {
+        if(!path.endsWith("/")) path += "/";
+        return ("root" + path).split("/");
+    }
+
+    public static String[] getPathsInPath(String path) {
+        if(path.endsWith("/")) path = path.substring(0, path.length()-1);
+
         ArrayList<String> paths = new ArrayList<>();
-        Bundle b = new Bundle();
-        while (path.contains("/")) {
 
+        while (path.length() > 0) {
             paths.add(path);
-            names.add(path.substring(1 + path.lastIndexOf("/"), path.length()));
             path = path.substring(0, path.lastIndexOf("/"));
         }
-        names.remove("");
-        paths.remove("/");
-        names.add("root");
-        paths.add("/");
-        // Toast.makeText(c,paths.get(0)+"\n"+paths.get(1)+"\n"+paths.get(2),Toast.LENGTH_LONG).show();
-        b.putStringArrayList("names", names);
-        b.putStringArrayList("paths", paths);
-        return b;
-    }
 
-    public boolean deletedirectory(File f){
-        boolean b=true;
-        for(File file:f.listFiles()){
-            boolean c;
-            if(file.isDirectory()){c=deletedirectory(file);}
-            else {c=file.delete();}
-            if(!c)b=false;
+        paths.add("/");
+        Collections.reverse(paths);
 
-        }if(b)b=f.delete();
-        return b;
+        return paths.toArray(new String[paths.size()]);
     }
 
     public static boolean canListFiles(File f) {
-        try {
-            return f.canRead() && f.isDirectory();
-        } catch (Exception e) {
-            return false;
-        }
+        return f.canRead() && f.isDirectory();
     }
 
-    public void openFile(final File f, final MainActivity m) {
+    public static void openFile(final File f, final MainActivity m, SharedPreferences sharedPrefs) {
+        boolean useNewStack = sharedPrefs.getBoolean(PrefFrag.PREFERENCE_TEXTEDITOR_NEWSTACK, false);
         boolean defaultHandler = isSelfDefault(f, m);
         SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(m);
+        final Toast[] studioCount = {null};
+
         if (defaultHandler && f.getName().toLowerCase().endsWith(".zip") ||
                 f.getName().toLowerCase().endsWith(".jar") ||
                 f.getName().toLowerCase().endsWith(".rar")||
@@ -736,9 +670,9 @@ public class Futils {
                 f.getName().toLowerCase().endsWith(".tar.gz")) {
             GeneralDialogCreation.showArchiveDialog(f, m);
         } else if(f.getName().toLowerCase().endsWith(".apk")) {
-            GeneralDialogCreation.showPackageDialog(f, m);
+            GeneralDialogCreation.showPackageDialog(sharedPrefs, f, m);
         } else if (defaultHandler && f.getName().toLowerCase().endsWith(".db")) {
-            Intent intent = new Intent(m, DbViewer.class);
+            Intent intent = new Intent(m, DatabaseViewerActivity.class);
             intent.putExtra("path", f.getPath());
             m.startActivity(intent);
         }  else if (Icons.isAudio(f.getPath())) {
@@ -754,19 +688,19 @@ public class Futils {
                     @Override
                     public void onTick(long millisUntilFinished) {
                         int sec = (int)millisUntilFinished/1000;
-                        if (studioCount!=null)
-                            studioCount.cancel();
-                        studioCount = Toast.makeText(m, sec + "", Toast.LENGTH_LONG);
-                        studioCount.show();
+                        if (studioCount[0] !=null)
+                            studioCount[0].cancel();
+                        studioCount[0] = Toast.makeText(m, sec + "", Toast.LENGTH_LONG);
+                        studioCount[0].show();
                     }
 
                     @Override
                     public void onFinish() {
-                        if (studioCount!=null)
-                            studioCount.cancel();
-                        studioCount = Toast.makeText(m, m.getString(R.string.opening),
+                        if (studioCount[0] !=null)
+                            studioCount[0].cancel();
+                        studioCount[0] = Toast.makeText(m, m.getString(R.string.opening),
                                 Toast.LENGTH_LONG);
-                        studioCount.show();
+                        studioCount[0].show();
                         m.startActivity(intent);
                     }
                 }.start();
@@ -774,15 +708,15 @@ public class Futils {
                 m.startActivity(intent);
         } else {
             try {
-                openunknown(f, m, false);
+                openunknown(f, m, false, useNewStack);
             } catch (Exception e) {
                 Toast.makeText(m, m.getResources().getString(R.string.noappfound),Toast.LENGTH_LONG).show();
-                openWith(f, m);
+                openWith(f, m, useNewStack);
             }
         }
     }
 
-    private boolean isSelfDefault(File f, Context c){
+    private static boolean isSelfDefault(File f, Context c){
         Intent intent = new Intent();
         intent.setAction(android.content.Intent.ACTION_VIEW);
         intent.setDataAndType(Uri.fromFile(f), MimeTypes.getMimeType(f));
@@ -793,13 +727,16 @@ public class Futils {
         return s.equals("com.amaze.filemanager") || rii == null;
     }
 
-    public void openFile(final DocumentFile f, final MainActivity m) {
-        //SharedPreferences sharedPref = PreferenceManager.getDefaultSharedPreferences(m);
+    /**
+     * Support file opening for {@link DocumentFile} (eg. OTG)
+     */
+    public static void openFile(final DocumentFile f, final MainActivity m, SharedPreferences sharedPrefs) {
+        boolean useNewStack = sharedPrefs.getBoolean(PrefFrag.PREFERENCE_TEXTEDITOR_NEWSTACK, false);
         try {
-            openunknown(f, m, false);
+            openunknown(f, m, false, useNewStack);
         } catch (Exception e) {
             Toast.makeText(m, m.getResources().getString(R.string.noappfound),Toast.LENGTH_LONG).show();
-            openWith(f, m);
+            openWith(f, m, useNewStack);
         }
 
         // not supporting inbuilt activities for now
@@ -812,7 +749,7 @@ public class Futils {
         } else if(f.getName().toLowerCase().endsWith(".apk")) {
             //showPackageDialog(f, m);
         } else if (f.getName().toLowerCase().endsWith(".db")) {
-            Intent intent = new Intent(m, DbViewer.class);
+            Intent intent = new Intent(m, DatabaseViewerActivity.class);
             intent.putExtra("path", f.getUri());
             intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
             m.startActivity(intent);
@@ -856,21 +793,20 @@ public class Futils {
         }*/
     }
 
-    /**
-     *
-     * @deprecated use new LayoutElement()
-     */
-    public static LayoutElement newElement(BitmapDrawable i, String d, String permissions, String symlink,
-                                    String size, long longSize, boolean directorybool, boolean b,
-                                    String date) {
-        return new LayoutElement(i, new File(d).getName(), d, permissions, symlink,
-                size, longSize, b, date, directorybool);
+    public static ArrayList<HybridFile> toHybridFileConcurrentRadixTree(ConcurrentRadixTree<VoidValue> a) {
+        ArrayList<HybridFile> b = new ArrayList<>();
+        for (CharSequence o : a.getKeysStartingWith("")) {
+            HybridFile hFile = new HybridFile(OpenMode.UNKNOWN, o.toString());
+            hFile.generateMode(null);
+            b.add(hFile);
+        }
+        return b;
     }
 
-    public static ArrayList<HFile> toHFileArray(ArrayList<String> a) {
-        ArrayList<HFile> b = new ArrayList<>();
-        for (int i = 0; i < a.size(); i++) {
-            HFile hFile=new HFile(OpenMode.UNKNOWN,a.get(i));
+    public static ArrayList<HybridFile> toHybridFileArrayList(LinkedList<String> a) {
+        ArrayList<HybridFile> b = new ArrayList<>();
+        for (String s : a) {
+            HybridFile hFile = new HybridFile(OpenMode.UNKNOWN, s);
             hFile.generateMode(null);
             b.add(hFile);
         }
@@ -880,15 +816,17 @@ public class Futils {
     /**
      * We're parsing a line returned from a stdout of shell.
      * @param line must be the line returned from a 'ls' command
-     * @return
      */
-    public static BaseFile parseName(String line) {
+    public static HybridFileParcelable parseName(String line) {
         boolean linked = false;
-        String name = "", link = "", size = "-1", date = "";
+        StringBuilder name = new StringBuilder();
+        StringBuilder link = new StringBuilder();
+        String size = "-1";
+        String date = "";
         String[] array = line.split(" ");
         if(array.length<6)return null;
-        for (int i = 0; i < array.length; i++) {
-            if (array[i].contains("->") && array[0].startsWith("l")) {
+        for (String anArray : array) {
+            if (anArray.contains("->") && array[0].startsWith("l")) {
                 linked = true;
             }
         }
@@ -898,17 +836,17 @@ public class Futils {
             size = array[p - 2];}
         if (!linked) {
             for (int i = p + 1; i < array.length; i++) {
-                name = name + " " + array[i];
+                name.append(" ").append(array[i]);
             }
-            name = name.trim();
+            name = new StringBuilder(name.toString().trim());
         } else {
             int q = getLinkPosition(array);
             for (int i = p + 1; i < q; i++) {
-                name = name + " " + array[i];
+                name.append(" ").append(array[i]);
             }
-            name = name.trim();
+            name = new StringBuilder(name.toString().trim());
             for (int i = q + 1; i < array.length; i++) {
-                link = link + " " + array[i];
+                link.append(" ").append(array[i]);
             }
         }
         long Size = (size==null || size.trim().length()==0)?-1:Long.parseLong(size);
@@ -916,12 +854,12 @@ public class Futils {
             ParsePosition pos = new ParsePosition(0);
             SimpleDateFormat simpledateformat = new SimpleDateFormat("yyyy-MM-dd | HH:mm");
             Date stringDate = simpledateformat.parse(date, pos);
-            BaseFile baseFile=new BaseFile(name,array[0],stringDate.getTime(),Size,true);
-            baseFile.setLink(link);
+            HybridFileParcelable baseFile=new HybridFileParcelable(name.toString(),array[0],stringDate.getTime(),Size,true);
+            baseFile.setLink(link.toString());
             return baseFile;
         }else {
-            BaseFile baseFile= new BaseFile(name,array[0],new File("/").lastModified(),Size,true);
-            baseFile.setLink(link);
+            HybridFileParcelable baseFile= new HybridFileParcelable(name.toString(),array[0],new File("/").lastModified(),Size,true);
+            baseFile.setLink(link.toString());
             return baseFile;
         }
     }
@@ -941,53 +879,46 @@ public class Futils {
     }
 
     public static ArrayList<Boolean[]> parse(String permLine) {
-        ArrayList<Boolean[]> arrayList= new ArrayList<>();
-        Boolean[] read=new Boolean[]{false,false,false};
-        Boolean[] write=new Boolean[]{false,false,false};
-        Boolean[] execute=new Boolean[]{false,false,false};
-        int owner = 0;// TODO: 17/5/2017 many variables are unused
-        if (permLine.charAt(1) == 'r') {
-            owner += READ;
-            read[0]=true;
-        }
-        if (permLine.charAt(2) == 'w') {
-            owner += WRITE;
-            write[0]=true;
-        }
-        if (permLine.charAt(3) == 'x') {
-            owner += EXECUTE;
-            execute[0]=true;
-        }
-        int group = 0;
-        if (permLine.charAt(4) == 'r') {
-            group += READ;
-            read[1]=true;
-        }
-        if (permLine.charAt(5) == 'w') {
-            group += WRITE;
-            write[1]=true;
-        }
-        if (permLine.charAt(6) == 'x') {
-            group += EXECUTE;
-            execute[1]=true;
-        }
-        int world = 0;
-        if (permLine.charAt(7) == 'r') {
-            world += READ;
-            read[2]=true;
-        }
-        if (permLine.charAt(8) == 'w') {
-            world += WRITE;
-            write[2]=true;
-        }
-        if (permLine.charAt(9) == 'x') {
-            world += EXECUTE;
-            execute[2]=true;
-        }
+        ArrayList<Boolean[]> arrayList= new ArrayList<>(3);
+        Boolean[] read =new Boolean[]{permLine.charAt(1) == 'r',
+                permLine.charAt(4) == 'r',
+                permLine.charAt(7) == 'r'};
+
+        Boolean[] write=new Boolean[]{permLine.charAt(2) == 'w',
+                permLine.charAt(5) == 'w',
+                permLine.charAt(8) == 'w'};
+
+        Boolean[] execute=new Boolean[]{permLine.charAt(3) == 'x',
+                permLine.charAt(6) == 'x',
+                permLine.charAt(9) == 'x'};
+
         arrayList.add(read);
         arrayList.add(write);
         arrayList.add(execute);
         return arrayList;
     }
 
+    public static boolean isStorage(String path) {
+        for (String s : DataUtils.getInstance().getStorages())
+            if (s.equals(path)) return true;
+        return false;
+    }
+
+    public static boolean isPathAccesible(String dir, SharedPreferences pref) {
+        File f = new File(dir);
+        boolean showIfHidden = pref.getBoolean(PrefFrag.PREFERENCE_SHOW_HIDDENFILES, false),
+                isDirSelfOrParent = dir.endsWith("/.") || dir.endsWith("/.."),
+                showIfRoot = pref.getBoolean(PrefFrag.PREFERENCE_ROOTMODE, false);
+
+        return f.exists() && f.isDirectory()
+                && (!f.isHidden() || (showIfHidden && !isDirSelfOrParent))
+                && (!isRoot(dir) || showIfRoot);
+
+        // TODO: 2/5/2017 use another system that doesn't create new object
+    }
+
+    public static boolean isRoot(String dir) {// TODO: 5/5/2017 hardcoding root might lead to problems down the line
+        return !dir.contains(OTGUtil.PREFIX_OTG) && !dir.startsWith("/storage");
+    }
+
 }
diff --git a/app/src/main/java/com/amaze/filemanager/utils/files/GenericCopyUtil.java b/app/src/main/java/com/amaze/filemanager/utils/files/GenericCopyUtil.java
index 8633d0cd7..fe77c55ed 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/files/GenericCopyUtil.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/files/GenericCopyUtil.java
@@ -6,11 +6,10 @@ import android.support.v4.provider.DocumentFile;
 import android.util.Log;
 
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.filesystem.BaseFile;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.FileUtil;
-import com.amaze.filemanager.filesystem.HFile;
-import com.amaze.filemanager.filesystem.RootHelper;
-import com.amaze.filemanager.utils.AppConfig;
+import com.amaze.filemanager.utils.application.AppConfig;
+import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.utils.DataUtils;
 import com.amaze.filemanager.utils.OTGUtil;
 import com.amaze.filemanager.utils.OpenMode;
@@ -39,8 +38,8 @@ import java.nio.channels.ReadableByteChannel;
 
 public class GenericCopyUtil {
 
-    private BaseFile mSourceFile;
-    private HFile mTargetFile;
+    private HybridFileParcelable mSourceFile;
+    private HybridFile mTargetFile;
     private Context mContext;   // context needed to find the DocumentFile in otg/sd card
     private DataUtils dataUtils = DataUtils.getInstance();
     public static final String PATH_FILE_DESCRIPTOR = "/proc/self/fd/";
@@ -81,8 +80,6 @@ public class GenericCopyUtil {
                 bufferedInputStream = new BufferedInputStream(contentResolver
                         .openInputStream(documentSourceFile.getUri()), DEFAULT_BUFFER_SIZE);
             } else if (mSourceFile.isSmb()) {
-
-                // source is in smb
                 bufferedInputStream = new BufferedInputStream(mSourceFile.getInputStream(), DEFAULT_BUFFER_SIZE);
             } else if (mSourceFile.isSftp()) {
                 bufferedInputStream = new BufferedInputStream(mSourceFile.getInputStream(mContext), DEFAULT_BUFFER_SIZE);
@@ -91,7 +88,7 @@ public class GenericCopyUtil {
                 CloudStorage cloudStorageDropbox = dataUtils.getAccount(OpenMode.DROPBOX);
                 bufferedInputStream = new BufferedInputStream(cloudStorageDropbox
                         .download(CloudUtil.stripPath(OpenMode.DROPBOX,
-                        mSourceFile.getPath())));
+                                mSourceFile.getPath())));
             } else if (mSourceFile.isBoxFile()) {
 
                 CloudStorage cloudStorageBox = dataUtils.getAccount(OpenMode.BOX);
@@ -278,7 +275,7 @@ public class GenericCopyUtil {
      * @param sourceFile the source file, which is to be copied
      * @param targetFile the target file
      */
-    public void copy(BaseFile sourceFile, HFile targetFile) throws IOException {
+    public void copy(HybridFileParcelable sourceFile, HybridFile targetFile) throws IOException {
 
         this.mSourceFile = sourceFile;
         this.mTargetFile = targetFile;
diff --git a/app/src/main/java/com/amaze/filemanager/utils/provider/UtilitiesProvider.java b/app/src/main/java/com/amaze/filemanager/utils/provider/UtilitiesProvider.java
index 812ec595f..1716bf2d9 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/provider/UtilitiesProvider.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/provider/UtilitiesProvider.java
@@ -4,32 +4,23 @@ import android.content.Context;
 import android.content.SharedPreferences;
 import android.preference.PreferenceManager;
 
-import com.amaze.filemanager.utils.files.Futils;
 import com.amaze.filemanager.utils.color.ColorPreference;
 import com.amaze.filemanager.utils.theme.AppTheme;
-import com.amaze.filemanager.utils.theme.AppThemeManagerInterface;
-import com.amaze.filemanager.utils.theme.PreferencesAppThemeManager;
+import com.amaze.filemanager.utils.theme.AppThemeManager;
 
 /**
  * Created by piotaixr on 16/01/17.
  */
 
 public class UtilitiesProvider implements UtilitiesProviderInterface {
-    private Futils futils;
     private ColorPreference colorPreference;
-    private AppThemeManagerInterface appThemeManager;
+    private AppThemeManager appThemeManager;
 
     public UtilitiesProvider(Context context) {
         SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context);
-        futils = new Futils();
 
         colorPreference = ColorPreference.loadFromPreferences(context, sharedPreferences);
-        appThemeManager = new PreferencesAppThemeManager(sharedPreferences);
-    }
-
-    @Override
-    public Futils getFutils() {
-        return futils;
+        appThemeManager = new AppThemeManager(sharedPreferences);
     }
 
     @Override
@@ -43,7 +34,7 @@ public class UtilitiesProvider implements UtilitiesProviderInterface {
     }
 
     @Override
-    public AppThemeManagerInterface getThemeManager() {
+    public AppThemeManager getThemeManager() {
         return appThemeManager;
     }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/utils/provider/UtilitiesProviderInterface.java b/app/src/main/java/com/amaze/filemanager/utils/provider/UtilitiesProviderInterface.java
index 84828e046..cf4ada618 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/provider/UtilitiesProviderInterface.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/provider/UtilitiesProviderInterface.java
@@ -1,19 +1,16 @@
 package com.amaze.filemanager.utils.provider;
 
-import com.amaze.filemanager.utils.files.Futils;
 import com.amaze.filemanager.utils.color.ColorPreference;
 import com.amaze.filemanager.utils.theme.AppTheme;
-import com.amaze.filemanager.utils.theme.AppThemeManagerInterface;
+import com.amaze.filemanager.utils.theme.AppThemeManager;
 
 /**
  * Created by Rmi Piotaix <remi.piotaix@gmail.com> on 2016-10-17.
  */
 public interface UtilitiesProviderInterface {
-    Futils getFutils();
-
     ColorPreference getColorPreference();
 
     AppTheme getAppTheme();
 
-    AppThemeManagerInterface getThemeManager();
+    AppThemeManager getThemeManager();
 }
diff --git a/app/src/main/java/com/amaze/filemanager/utils/share/ShareAdapter.java b/app/src/main/java/com/amaze/filemanager/utils/share/ShareAdapter.java
index 485c2fa4b..8c4bf1061 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/share/ShareAdapter.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/share/ShareAdapter.java
@@ -12,15 +12,16 @@ import android.widget.TextView;
 
 import com.afollestad.materialdialogs.MaterialDialog;
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.adapters.RecyclerArrayAdapter;
 
 import java.util.ArrayList;
 
 /**
- * Created by Arpit on 01-07-2015.
+ * Created by Arpit on 01-07-2015 edited by Emmanuel Messulam <emmanuelbendavid@gmail.com>
  */
 
-class ShareAdapter extends RecyclerArrayAdapter<Intent, ShareAdapter.ViewHolder> {
+class ShareAdapter extends RecyclerView.Adapter<ShareAdapter.ViewHolder> {
+
+    private ArrayList<Intent> items;
     private MaterialDialog dialog;
     private ArrayList<String> labels;
     private ArrayList<Drawable> drawables;
@@ -32,7 +33,7 @@ class ShareAdapter extends RecyclerArrayAdapter<Intent, ShareAdapter.ViewHolder>
 
     ShareAdapter(Context context, ArrayList<Intent> intents, ArrayList<String> labels,
                         ArrayList<Drawable> arrayList1) {
-        addAll(intents);
+        items = new ArrayList<>(intents);
         this.context = context;
         this.labels = labels;
         this.drawables = arrayList1;
@@ -70,14 +71,21 @@ class ShareAdapter extends RecyclerArrayAdapter<Intent, ShareAdapter.ViewHolder>
                 imageView.setImageDrawable(drawables.get(position));
             textView.setVisibility(View.VISIBLE);
             textView.setText(labels.get(position));
-            rootView.setOnClickListener(new View.OnClickListener() {
-                @Override
-                public void onClick(View v) {
-                    if (dialog != null && dialog.isShowing()) dialog.dismiss();
-                    context.startActivity(getItem(position));
-                }
+            rootView.setOnClickListener(v -> {
+                if (dialog != null && dialog.isShowing()) dialog.dismiss();
+                context.startActivity(items.get(position));
             });
         }
     }
 
+    @Override
+    public long getItemId(int position) {
+        return position;
+    }
+
+    @Override
+    public int getItemCount() {
+        return items.size();
+    }
+
 }
diff --git a/app/src/main/java/com/amaze/filemanager/utils/theme/AppTheme.java b/app/src/main/java/com/amaze/filemanager/utils/theme/AppTheme.java
index 448c8d3d2..27d04c762 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/theme/AppTheme.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/theme/AppTheme.java
@@ -8,28 +8,27 @@ import java.util.Calendar;
  * This enum represents the theme of the app (LIGHT or DARK)
  */
 public enum AppTheme {
-    LIGHT(0, Theme.LIGHT),
-    DARK(1, Theme.DARK);
+    LIGHT(0),
+    DARK(1),
+    TIMED(2);
 
     public static final int LIGHT_INDEX = 0;
     public static final int DARK_INDEX = 1;
     public static final int TIME_INDEX = 2;
 
     private int id;
-    private Theme materialDialogTheme;
 
-    AppTheme(int id, Theme materialDialogTheme) {
+    AppTheme(int id) {
         this.id = id;
-        this.materialDialogTheme = materialDialogTheme;
     }
 
     /**
-     * Returns the correct AppTheme. If index == TIME_INDEX, current time is used to select the theme.
+     * Returns the correct AppTheme. If index == TIME_INDEX, TIMED is returned.
      *
      * @param index The theme index
      * @return The AppTheme for the given index
      */
-    public static AppTheme fromIndex(int index) {
+    public static AppTheme getTheme(int index) {
         switch (index) {
             default:
             case LIGHT_INDEX:
@@ -37,21 +36,50 @@ public enum AppTheme {
             case DARK_INDEX:
                 return DARK;
             case TIME_INDEX:
-                Calendar calendar = Calendar.getInstance();
-                int hour = calendar.get(Calendar.HOUR_OF_DAY);
+                return TIMED;
+        }
+    }
+
+    /**
+     * @return The Theme enum to provide to {@link com.afollestad.materialdialogs.MaterialDialog.Builder}
+     */
+    public Theme getMaterialDialogTheme() {
+        switch (id) {
+            default:
+            case LIGHT_INDEX:
+                return Theme.LIGHT;
+            case DARK_INDEX:
+                return Theme.DARK;
+            case TIME_INDEX:
+                int hour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY);
                 if (hour <= 6 || hour >= 18) {
-                    return DARK;
+                    return Theme.DARK;
                 } else {
-                    return LIGHT;
+                    return Theme.LIGHT;
                 }
         }
     }
 
     /**
-     * @return The Theme enum to provide to {@link com.afollestad.materialdialogs.MaterialDialog.Builder}
+     * Returns the correct AppTheme. If index == TIME_INDEX, current time is used to select the theme.
+     *
+     * @return The AppTheme for the given index
      */
-    public Theme getMaterialDialogTheme() {
-        return materialDialogTheme;
+    public AppTheme getSimpleTheme() {
+        switch (id) {
+            default:
+            case LIGHT_INDEX:
+                return LIGHT;
+            case DARK_INDEX:
+                return DARK;
+            case TIME_INDEX:
+                int hour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY);
+                if (hour <= 6 || hour >= 18) {
+                    return DARK;
+                } else {
+                    return LIGHT;
+                }
+        }
     }
 
     public int getId() {
diff --git a/app/src/main/java/com/amaze/filemanager/utils/theme/AppThemeManager.java b/app/src/main/java/com/amaze/filemanager/utils/theme/AppThemeManager.java
new file mode 100644
index 000000000..cbeb9bea1
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/utils/theme/AppThemeManager.java
@@ -0,0 +1,37 @@
+package com.amaze.filemanager.utils.theme;
+
+import android.content.SharedPreferences;
+
+/**
+ * Saves and restores the AppTheme
+ */
+public class AppThemeManager {
+    private SharedPreferences preferences;
+    private AppTheme appTheme;
+
+    public AppThemeManager(SharedPreferences preferences) {
+        this.preferences = preferences;
+        String themeId = preferences.getString("theme", "0");
+        appTheme = AppTheme.getTheme(Integer.parseInt(themeId)).getSimpleTheme();
+    }
+
+    /**
+     * @return The current Application theme
+     */
+    public AppTheme getAppTheme() {
+        return appTheme.getSimpleTheme();
+    }
+
+    /**
+     * Change the current theme of the application. The change is saved.
+     *
+     * @param appTheme The new theme
+     * @return The theme manager.
+     */
+    public AppThemeManager setAppTheme(AppTheme appTheme) {
+        this.appTheme = appTheme;
+        preferences.edit().putString("theme", Integer.toString(appTheme.getId())).apply();
+        return this;
+    }
+
+}
diff --git a/app/src/main/java/com/amaze/filemanager/utils/theme/AppThemeManagerInterface.java b/app/src/main/java/com/amaze/filemanager/utils/theme/AppThemeManagerInterface.java
deleted file mode 100644
index 74e079679..000000000
--- a/app/src/main/java/com/amaze/filemanager/utils/theme/AppThemeManagerInterface.java
+++ /dev/null
@@ -1,29 +0,0 @@
-package com.amaze.filemanager.utils.theme;
-
-/**
- * Describes how to change and retrieve the current application theme. {@see AppTheme}
- */
-public interface AppThemeManagerInterface {
-    /**
-     *
-     * @return The current Application theme
-     */
-    AppTheme getAppTheme();
-
-    /**
-     * Change the current theme of the application.
-     *
-     * The change is only done in memory and not saved. Restarting the application will reset to the previously saved AppTheme.
-     *
-     * @param appTheme The new theme
-     * @return The theme manager.
-     */
-    AppThemeManagerInterface setAppTheme(AppTheme appTheme);
-
-    /**
-     * Persists the current value of AppTheme so that it will be reloaded the next time the application starts from scratch.
-     *
-     * @return The theme manager.
-     */
-    AppThemeManagerInterface save();
-}
diff --git a/app/src/main/java/com/amaze/filemanager/utils/theme/PreferencesAppThemeManager.java b/app/src/main/java/com/amaze/filemanager/utils/theme/PreferencesAppThemeManager.java
deleted file mode 100644
index 237163cca..000000000
--- a/app/src/main/java/com/amaze/filemanager/utils/theme/PreferencesAppThemeManager.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package com.amaze.filemanager.utils.theme;
-
-import android.content.SharedPreferences;
-
-/**
- * Implements {@link AppThemeManagerInterface} by saving the theme preference via the {@link SharedPreferences} object given at initialization.
- * If an error occurs while loading the theme preference from the {@link SharedPreferences} object, LIGHT is the default.
- */
-public class PreferencesAppThemeManager implements AppThemeManagerInterface {
-    private SharedPreferences preferences;
-    private AppTheme appTheme;
-
-    public PreferencesAppThemeManager(SharedPreferences preferences) {
-
-        this.preferences = preferences;
-        appTheme = loadFromPreferences(preferences);
-    }
-
-    private AppTheme loadFromPreferences(SharedPreferences preferences) {
-        try {
-            String themeId = preferences.getString("theme", "0");
-            switch (themeId) {
-                case "0":
-                case "1":
-                case "2":
-                    return AppTheme.fromIndex(Integer.parseInt(themeId));
-                default:
-                    return AppTheme.LIGHT;
-            }
-        } catch (ClassCastException ex) {
-            return AppTheme.LIGHT;
-        }
-    }
-
-    @Override
-    public AppTheme getAppTheme() {
-        return appTheme;
-    }
-
-    @Override
-    public AppThemeManagerInterface setAppTheme(AppTheme appTheme) {
-        this.appTheme = appTheme;
-
-        return this;
-    }
-
-    @Override
-    public AppThemeManagerInterface save() {
-        preferences.edit()
-                   .putString("theme", Integer.toString(appTheme.getId()))
-                   .apply();
-
-        return this;
-    }
-}
diff --git a/app/src/play/java/com/amaze/filemanager/activities/MainActivity.java b/app/src/play/java/com/amaze/filemanager/activities/MainActivity.java
index fa79109c0..f2d43fb63 100644
--- a/app/src/play/java/com/amaze/filemanager/activities/MainActivity.java
+++ b/app/src/play/java/com/amaze/filemanager/activities/MainActivity.java
@@ -20,20 +20,14 @@
 
 package com.amaze.filemanager.activities;
 
-import android.animation.Animator;
-import android.animation.AnimatorListenerAdapter;
-import android.animation.ObjectAnimator;
 import android.app.Activity;
 import android.app.ActivityManager;
 import android.content.BroadcastReceiver;
-import android.content.ComponentName;
 import android.content.ContentResolver;
 import android.content.ContentUris;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
-import android.content.IntentSender;
-import android.content.ServiceConnection;
 import android.content.pm.PackageManager;
 import android.content.res.Configuration;
 import android.database.Cursor;
@@ -41,22 +35,22 @@ import android.graphics.Color;
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable;
+import android.graphics.drawable.VectorDrawable;
 import android.hardware.usb.UsbManager;
 import android.media.RingtoneManager;
 import android.net.Uri;
 import android.os.AsyncTask;
 import android.os.Build;
 import android.os.Bundle;
-import android.os.CountDownTimer;
 import android.os.Environment;
 import android.os.Handler;
 import android.os.HandlerThread;
-import android.os.IBinder;
 import android.service.quicksettings.TileService;
 import android.support.annotation.NonNull;
 import android.support.design.widget.AppBarLayout;
 import android.support.design.widget.CoordinatorLayout;
 import android.support.design.widget.Snackbar;
+import android.support.graphics.drawable.VectorDrawableCompat;
 import android.support.v4.app.ActionBarDrawerToggle;
 import android.support.v4.app.ActivityCompat.OnRequestPermissionsResultCallback;
 import android.support.v4.app.Fragment;
@@ -66,30 +60,17 @@ import android.support.v4.content.ContextCompat;
 import android.support.v4.content.CursorLoader;
 import android.support.v4.content.Loader;
 import android.support.v4.widget.DrawerLayout;
-import android.support.v7.widget.AppCompatEditText;
-import android.support.v7.widget.Toolbar;
 import android.text.TextUtils;
-import android.util.DisplayMetrics;
-import android.util.Log;
-import android.view.Gravity;
 import android.view.KeyEvent;
 import android.view.Menu;
 import android.view.MenuInflater;
 import android.view.MenuItem;
 import android.view.View;
-import android.view.ViewAnimationUtils;
 import android.view.ViewGroup;
 import android.view.Window;
 import android.view.WindowManager;
-import android.view.animation.AccelerateDecelerateInterpolator;
-import android.view.animation.Animation;
-import android.view.animation.AnimationUtils;
 import android.view.animation.DecelerateInterpolator;
-import android.view.inputmethod.InputMethodManager;
-import android.widget.Button;
 import android.widget.FrameLayout;
-import android.widget.HorizontalScrollView;
-import android.widget.ImageButton;
 import android.widget.ImageView;
 import android.widget.LinearLayout;
 import android.widget.ListView;
@@ -100,7 +81,12 @@ import android.widget.Toast;
 import com.afollestad.materialdialogs.DialogAction;
 import com.afollestad.materialdialogs.MaterialDialog;
 import com.amaze.filemanager.R;
+import com.amaze.filemanager.activities.superclasses.ThemedActivity;
 import com.amaze.filemanager.adapters.DrawerAdapter;
+import com.amaze.filemanager.asynchronous.asynctasks.DeleteTask;
+import com.amaze.filemanager.asynchronous.asynctasks.MoveFiles;
+import com.amaze.filemanager.asynchronous.asynctasks.PrepareCopyTask;
+import com.amaze.filemanager.asynchronous.services.CopyService;
 import com.amaze.filemanager.database.CloudContract;
 import com.amaze.filemanager.database.CloudHandler;
 import com.amaze.filemanager.database.CryptHandler;
@@ -109,26 +95,21 @@ import com.amaze.filemanager.database.UtilsHandler;
 import com.amaze.filemanager.database.models.CloudEntry;
 import com.amaze.filemanager.database.models.Tab;
 import com.amaze.filemanager.exceptions.CloudPluginException;
-import com.amaze.filemanager.filesystem.BaseFile;
 import com.amaze.filemanager.filesystem.FileUtil;
-import com.amaze.filemanager.filesystem.HFile;
+import com.amaze.filemanager.filesystem.HybridFile;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
+import com.amaze.filemanager.filesystem.PasteHelper;
 import com.amaze.filemanager.filesystem.RootHelper;
-import com.amaze.filemanager.fragments.AppsList;
+import com.amaze.filemanager.fragments.AppsListFragment;
 import com.amaze.filemanager.fragments.CloudSheetFragment;
 import com.amaze.filemanager.fragments.CloudSheetFragment.CloudConnectionCallbacks;
+import com.amaze.filemanager.fragments.CompressedExplorerFragment;
 import com.amaze.filemanager.fragments.FTPServerFragment;
 import com.amaze.filemanager.fragments.MainFragment;
-import com.amaze.filemanager.fragments.ProcessViewer;
+import com.amaze.filemanager.fragments.ProcessViewerFragment;
 import com.amaze.filemanager.fragments.SearchWorkerFragment;
 import com.amaze.filemanager.fragments.TabFragment;
-import com.amaze.filemanager.fragments.ZipViewer;
-import com.amaze.filemanager.fragments.preference_fragments.FoldersPref;
 import com.amaze.filemanager.fragments.preference_fragments.QuickAccessPref;
-import com.amaze.filemanager.services.CopyService;
-import com.amaze.filemanager.services.DeleteTask;
-import com.amaze.filemanager.services.EncryptService;
-import com.amaze.filemanager.services.asynctasks.CopyFileCheck;
-import com.amaze.filemanager.services.asynctasks.MoveFiles;
 import com.amaze.filemanager.services.ssh.SshConnectionPool;
 import com.amaze.filemanager.ui.dialogs.GeneralDialogCreation;
 import com.amaze.filemanager.ui.dialogs.RenameBookmark;
@@ -139,10 +120,8 @@ import com.amaze.filemanager.ui.dialogs.SmbConnectDialog.SmbConnectionListener;
 import com.amaze.filemanager.ui.drawer.EntryItem;
 import com.amaze.filemanager.ui.drawer.Item;
 import com.amaze.filemanager.ui.drawer.SectionItem;
-import com.amaze.filemanager.ui.icons.IconUtils;
-import com.amaze.filemanager.ui.views.RoundedImageView;
 import com.amaze.filemanager.ui.views.ScrimInsetsRelativeLayout;
-import com.amaze.filemanager.utils.AppConfig;
+import com.amaze.filemanager.ui.views.appbar.AppBar;
 import com.amaze.filemanager.utils.BookSorter;
 import com.amaze.filemanager.utils.DataUtils;
 import com.amaze.filemanager.utils.DataUtils.DataChangeListener;
@@ -153,8 +132,9 @@ import com.amaze.filemanager.utils.PreferenceUtils;
 import com.amaze.filemanager.utils.ServiceWatcherUtil;
 import com.amaze.filemanager.utils.TinyDB;
 import com.amaze.filemanager.utils.Utils;
+import com.amaze.filemanager.utils.application.AppConfig;
 import com.amaze.filemanager.utils.color.ColorUsage;
-import com.amaze.filemanager.utils.files.Futils;
+import com.amaze.filemanager.utils.files.FileUtils;
 import com.amaze.filemanager.utils.theme.AppTheme;
 import com.android.volley.VolleyError;
 import com.android.volley.toolbox.ImageLoader;
@@ -168,29 +148,22 @@ import com.cloudrail.si.services.GoogleDrive;
 import com.cloudrail.si.services.OneDrive;
 import com.github.clans.fab.FloatingActionButton;
 import com.github.clans.fab.FloatingActionMenu;
-import com.google.android.gms.common.ConnectionResult;
-import com.google.android.gms.common.api.GoogleApiClient;
-import com.google.android.gms.plus.Plus;
-import com.google.android.gms.plus.model.people.Person;
 import com.readystatesoftware.systembartint.SystemBarTintManager;
 
 import java.io.File;
-import java.net.MalformedURLException;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.regex.Pattern;
 
 import eu.chainfire.libsuperuser.Shell;
-import jcifs.smb.SmbFile;
 
 import static android.os.Build.VERSION.SDK_INT;
-import static com.amaze.filemanager.fragments.preference_fragments.Preffrag.PREFERENCE_SHOW_SIDEBAR_FOLDERS;
-import static com.amaze.filemanager.fragments.preference_fragments.Preffrag.PREFERENCE_SHOW_SIDEBAR_QUICKACCESSES;
+import static com.amaze.filemanager.fragments.preference_fragments.PrefFrag.PREFERENCE_SHOW_SIDEBAR_FOLDERS;
+import static com.amaze.filemanager.fragments.preference_fragments.PrefFrag.PREFERENCE_SHOW_SIDEBAR_QUICKACCESSES;
 
-public class MainActivity extends BaseActivity implements
-        GoogleApiClient.ConnectionCallbacks,
-        GoogleApiClient.OnConnectionFailedListener, OnRequestPermissionsResultCallback,
+public class MainActivity extends ThemedActivity implements OnRequestPermissionsResultCallback,
         SmbConnectionListener, DataChangeListener, BookmarkCallback,
         SearchWorkerFragment.HelperCallbacks, CloudConnectionCallbacks,
         LoaderManager.LoaderCallbacks<Cursor> {
@@ -198,21 +171,16 @@ public class MainActivity extends BaseActivity implements
     public static final Pattern DIR_SEPARATOR = Pattern.compile("/");
     public static final String TAG_ASYNC_HELPER = "async_helper";
 
-    /* Request code used to invoke sign in user interactions. */
-    static final int RC_SIGN_IN = 0;
-
     private DataUtils dataUtils = DataUtils.getInstance();
 
     public DrawerLayout mDrawerLayout;
     public ListView mDrawerList;
     public ScrimInsetsRelativeLayout mDrawerLinear;
     public String path = "", launchPath;
-    public ArrayList<BaseFile> COPY_PATH = null, MOVE_PATH = null;
     public FrameLayout frameLayout;
     public boolean mReturnIntent = false;
     public boolean useGridView, openzip = false;
     public boolean mRingtonePickerIntent = false, colourednavigation = false;
-    public Toolbar toolbar;
     public int skinStatusBar;
 
     public volatile int storage_count = 0; // number of storage available (internal/external/otg etc)
@@ -226,8 +194,8 @@ public class MainActivity extends BaseActivity implements
     public MainActivityHelper mainActivityHelper;
 
     public int operation = -1;
-    public ArrayList<BaseFile> oparrayList;
-    public ArrayList<ArrayList<BaseFile>> oparrayListList;
+    public ArrayList<HybridFileParcelable> oparrayList;
+    public ArrayList<ArrayList<HybridFileParcelable>> oparrayListList;
 
     // oppathe - the path at which certain operation needs to be performed
     // oppathe1 - the new path which user wants to create/modify
@@ -236,16 +204,20 @@ public class MainActivity extends BaseActivity implements
     public ArrayList<String> oppatheList;
     public RelativeLayout drawerHeaderParent;
 
+    /**
+     * @deprecated use getCurrentMainFragment()
+     */
     public MainFragment mainFragment;
 
     public static final String KEY_PREF_OTG = "uri_usb_otg";
 
+    public static final String PASTEHELPER_BUNDLE = "pasteHelper";
+
     private static final int image_selector_request_code = 31;
 
+    private AppBar appbar;
     //private HistoryManager history, grid;
-    private Futils utils;
     private MainActivity mainActivity = this;
-    private IconUtils util;
     private Context con = this;
     private String zippath;
     private FragmentTransaction pending_fragmentTransaction;
@@ -258,41 +230,23 @@ public class MainActivity extends BaseActivity implements
     private Toast toast = null;
     private ActionBarDrawerToggle mDrawerToggle;
     private Intent intent;
-    private GoogleApiClient mGoogleApiClient;
     private View drawerHeaderLayout;
     private View drawerHeaderView, indicator_layout;
-    private RoundedImageView drawerProfilePic;
     private ImageLoader mImageLoader;
 
-    private TextView mGoogleName, mGoogleId;
-    private LinearLayout buttons;
-    private HorizontalScrollView scroll, scroll1;
-    private CountDownTimer timer;
-    private IconUtils icons;
     private TabHandler tabHandler;
-    // Check for user interaction for Google+ api only once
-    private boolean mGoogleApiKey = false;
     /* A flag indicating that a PendingIntent is in progress and prevents
    * us from starting further intents.
    */
-    private boolean mIntentInProgress, showHidden = false;
+    private boolean showHidden = false;
     private AsyncTask<Void, Void, Boolean> cloudSyncTask;
 
-    // string builder object variables for pathBar animations
-    private StringBuffer newPathBuilder, oldPathBuilder;
     private AppBarLayout appBarLayout;
 
-    private static final int PATH_ANIM_START_DELAY = 0;
-    private static final int PATH_ANIM_END_DELAY = 0;
-
     //TODO make var names meaningful
     private static final int SELECT_MINUS_2 = -2, NO_VALUE = -1, SELECT_0 = 0, SELECT_102 = 102;
     private int selectedStorage;
 
-    private int TOOLBAR_START_INSET;
-    private RelativeLayout searchViewLayout;
-    private AppCompatEditText searchViewEditText;
-    private int[] searchCoords = new int[2];
     private CoordinatorLayout mScreenLayout;
     private View fabBgView;
     private UtilsHandler utilsHandler;
@@ -306,25 +260,43 @@ public class MainActivity extends BaseActivity implements
     public static final String TAG_INTENT_FILTER_GENERAL = "general_communications";
     public static final String ARGS_KEY_LOADER = "loader_cloud_args_service";
 
+    /**
+     * Broadcast which will be fired after every file operation, will denote list loading
+     * Registered by {@link MainFragment}
+     */
+    public static final String KEY_INTENT_LOAD_LIST = "loadlist";
+
+    /**
+     * Extras carried by the list loading intent
+     * Contains path of parent directory in which operation took place, so that we can run
+     * media scanner on it
+     */
+    public static final String KEY_INTENT_LOAD_LIST_FILE = "loadlist_file";
+
+    /**
+     * Mime type in intent that apps need to pass when trying to open file manager from a specific directory
+     * Should be clubbed with {@link Intent#ACTION_VIEW} and send in path to open in intent data field
+     */
+    public static final String ARGS_INTENT_ACTION_VIEW_MIME_FOLDER = "resource/folder";
+
     private static final String CLOUD_AUTHENTICATOR_GDRIVE = "android.intent.category.BROWSABLE";
     private static final String CLOUD_AUTHENTICATOR_REDIRECT_URI = "com.amaze.filemanager:/oauth2redirect";
 
     // the current visible tab, either 0 or 1
     public static int currentTab;
 
-    public static boolean isSearchViewEnabled = false;
     public static Shell.Interactive shellInteractive;
     public static Handler handler;
 
     private static HandlerThread handlerThread;
-    public boolean isEncryptOpen = false;       // do we have to open a file when service is begin destroyed
-    public BaseFile encryptBaseFile;            // the cached base file which we're to open, delete it later
 
     private static final int REQUEST_CODE_CLOUD_LIST_KEYS = 5463;
     private static final int REQUEST_CODE_CLOUD_LIST_KEY = 5472;
 
     private static final String KEY_PREFERENCE_BOOKMARKS_ADDED = "books_added";
 
+    private PasteHelper pasteHelper;
+
     /**
      * Called when the activity is first created.
      */
@@ -335,80 +307,104 @@ public class MainActivity extends BaseActivity implements
         initializeInteractiveShell();
 
         dataUtils.registerOnDataChangedListener(this);
-
+        
         AppConfig.setActivityContext(con);
 
         setContentView(R.layout.main_toolbar);
+        appbar = new AppBar(this, getPrefs(), queue -> {
+            if(!queue.isEmpty()) {
+                mainActivityHelper.search(getPrefs(), queue);
+            }
+        });
         initialiseViews();
         tabHandler = new TabHandler(this);
         utilsHandler = AppConfig.getInstance().getUtilsHandler();
         cloudHandler = new CloudHandler(this);
 
         mImageLoader = AppConfig.getInstance().getImageLoader();
-        utils = getFutils();
         mainActivityHelper = new MainActivityHelper(this);
         initialiseFab();
 
-        // initialize g+ api client as per preferences
-        if (sharedPref.getBoolean("plus_pic", false)) {
-            mGoogleApiClient = new GoogleApiClient.Builder(this)
-                    .addConnectionCallbacks(this)
-                    .addOnConnectionFailedListener(this)
-                    .addApi(Plus.API)
-                    .addScope(Plus.SCOPE_PLUS_LOGIN)
-                    .build();
-        }
-
         if (CloudSheetFragment.isCloudProviderAvailable(this)) {
 
             getSupportLoaderManager().initLoader(REQUEST_CODE_CLOUD_LIST_KEYS, null, this);
         }
 
-        util = new IconUtils(sharedPref, this);
-        icons = new IconUtils(sharedPref, this);
-
-        timer = new CountDownTimer(5000, 1000) {
-            @Override
-            public void onTick(long l) {
-            }
-
-            @Override
-            public void onFinish() {
-                utils.crossfadeInverse(buttons, pathbar);
-            }
-        };
         path = getIntent().getStringExtra("path");
         openProcesses = getIntent().getBooleanExtra(KEY_INTENT_PROCESS_VIEWER, false);
-        try {
-            intent = getIntent();
-            if (intent.getStringArrayListExtra(TAG_INTENT_FILTER_FAILED_OPS) != null) {
-                ArrayList<BaseFile> failedOps = intent.getParcelableArrayListExtra(TAG_INTENT_FILTER_FAILED_OPS);
-                if (failedOps != null) {
-                    mainActivityHelper.showFailedOperationDialog(failedOps, intent.getBooleanExtra("move", false), this);
-                }
+        intent = getIntent();
+
+        String actionIntent = intent.getAction();
+        String typeIntent = intent.getType();
+        if (intent.getStringArrayListExtra(TAG_INTENT_FILTER_FAILED_OPS) != null) {
+            ArrayList<HybridFileParcelable> failedOps = intent.getParcelableArrayListExtra(TAG_INTENT_FILTER_FAILED_OPS);
+            if (failedOps != null) {
+                mainActivityHelper.showFailedOperationDialog(failedOps, intent.getBooleanExtra("move", false), this);
             }
-            if (intent.getAction() != null) {
-                if (intent.getAction().equals(Intent.ACTION_GET_CONTENT)) {
-
-                    // file picker intent
-                    mReturnIntent = true;
-                    Toast.makeText(this, getString(R.string.pick_a_file), Toast.LENGTH_LONG).show();
-                } else if (intent.getAction().equals(RingtoneManager.ACTION_RINGTONE_PICKER)) {
-                    // ringtone picker intent
-                    mReturnIntent = true;
-                    mRingtonePickerIntent = true;
-                    Toast.makeText(this, getString(R.string.pick_a_file), Toast.LENGTH_LONG).show();
-                } else if (intent.getAction().equals(Intent.ACTION_VIEW)) {
-
-                    // zip viewer intent
-                    Uri uri = intent.getData();
+        }
+        if (actionIntent != null) {
+            if (actionIntent.equals(Intent.ACTION_GET_CONTENT)) {
+
+                // file picker intent
+                mReturnIntent = true;
+                Toast.makeText(this, getString(R.string.pick_a_file), Toast.LENGTH_LONG).show();
+
+                // disable screen rotation just for convenience purpose
+                // TODO: Support screen rotation when picking file
+                Utils.disableScreenRotation(this);
+            } else if (actionIntent.equals(RingtoneManager.ACTION_RINGTONE_PICKER)) {
+                // ringtone picker intent
+                mReturnIntent = true;
+                mRingtonePickerIntent = true;
+                Toast.makeText(this, getString(R.string.pick_a_file), Toast.LENGTH_LONG).show();
+
+                // disable screen rotation just for convenience purpose
+                // TODO: Support screen rotation when picking file
+                Utils.disableScreenRotation(this);
+            } else if (actionIntent.equals(Intent.ACTION_VIEW)) {
+
+                // zip viewer intent
+                Uri uri = intent.getData();
+                String type = intent.getType();
+
+                if (type != null && type.equals(ARGS_INTENT_ACTION_VIEW_MIME_FOLDER)) {
+                    // support for syncting or intents from external apps that
+                    // need to start file manager from a specific path
+
+                    if (uri != null) {
+
+                        path = Utils.sanitizeInput(uri.getPath());
+                    } else {
+                        // no data field, open home for the tab in later processing
+                        path = null;
+                    }
+                } else {
+                    // we don't have folder resource mime type set, supposed to be zip/rar
                     openzip = true;
-                    zippath = uri.toString();
+                    zippath = Utils.sanitizeInput(uri.toString());
                 }
-            }
-        } catch (Exception e) {
 
-            e.printStackTrace();
+            } else if (actionIntent.equals(Intent.ACTION_SEND) && typeIntent != null) {
+                // save a single file to filesystem
+
+                Uri uri = intent.getParcelableExtra(Intent.EXTRA_STREAM);
+                ArrayList<Uri> uris = new ArrayList<>();
+                uris.add(uri);
+                initFabToSave(uris);
+
+                // disable screen rotation just for convenience purpose
+                // TODO: Support screen rotation when saving a file
+                Utils.disableScreenRotation(this);
+            } else if (actionIntent.equals(Intent.ACTION_SEND_MULTIPLE) && typeIntent != null) {
+                // save multiple files to filesystem
+
+                ArrayList<Uri> arrayList = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);
+                initFabToSave(arrayList);
+
+                // disable screen rotation just for convenience purpose
+                // TODO: Support screen rotation when saving a file
+                Utils.disableScreenRotation(this);
+            }
         }
 
         if (savedInstanceState != null) {
@@ -455,7 +451,7 @@ public class MainActivity extends BaseActivity implements
             getSupportActionBar().setHomeButtonEnabled(true);
             mDrawerToggle.syncState();
         }
-        /*((ImageButton) findViewById(R.id.drawer_buttton)).setOnClickListener(new ImageView.OnClickListener() {
+        /*findViewById(R.id.drawer_buttton).setOnClickListener(new ImageView.OnClickListener() {
             @Override
             public void onClick(View view) {
                 if (mDrawerLayout.isDrawerOpen(mDrawerLinear)) {
@@ -468,7 +464,7 @@ public class MainActivity extends BaseActivity implements
             mDrawerToggle.setHomeAsUpIndicator(R.drawable.ic_drawer_l);
         }
         //recents header color implementation
-        if (SDK_INT >= 21) {
+        if (SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
             ActivityManager.TaskDescription taskDescription = new ActivityManager.TaskDescription("Amaze",
                     ((BitmapDrawable) getResources().getDrawable(R.mipmap.ic_launcher)).getBitmap(),
                     getColorPreference().getColor(ColorUsage.getPrimary(MainActivity.currentTab)));
@@ -477,19 +473,21 @@ public class MainActivity extends BaseActivity implements
 
 
 
-        if (!sharedPref.getBoolean(KEY_PREFERENCE_BOOKMARKS_ADDED, false)) {
+        if (!getPrefs().getBoolean(KEY_PREFERENCE_BOOKMARKS_ADDED, false)) {
             utilsHandler.addCommonBookmarks();
-            sharedPref.edit().putBoolean(KEY_PREFERENCE_BOOKMARKS_ADDED, true).commit();
+            getPrefs().edit().putBoolean(KEY_PREFERENCE_BOOKMARKS_ADDED, true).commit();
         }
 
         AppConfig.runInBackground(new AppConfig.CustomAsyncCallbacks() {
             @Override
             public <E> E doInBackground() {
 
-                dataUtils.setHiddenfiles(utilsHandler.getHiddenList());
+                dataUtils.setHiddenFiles(utilsHandler.getHiddenFilesConcurrentRadixTree());
+                dataUtils.setHistory(utilsHandler.getHistoryLinkedList());
                 dataUtils.setGridfiles(utilsHandler.getGridViewList());
                 dataUtils.setListfiles(utilsHandler.getListViewList());
                 dataUtils.setBooks(utilsHandler.getBookmarksList());
+                
                 ArrayList<String[]> servers = new ArrayList<String[]>();
                 servers.addAll(utilsHandler.getSmbList());
                 servers.addAll(utilsHandler.getSftpList());
@@ -505,8 +503,8 @@ public class MainActivity extends BaseActivity implements
 
                 if (savedInstanceState == null) {
                     if (openProcesses) {
-                        android.support.v4.app.FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
-                        transaction.replace(R.id.content_frame, new ProcessViewer(), KEY_INTENT_PROCESS_VIEWER);
+                        FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
+                        transaction.replace(R.id.content_frame, new ProcessViewerFragment(), KEY_INTENT_PROCESS_VIEWER);
                         //transaction.addToBackStack(null);
                         selectedStorage = SELECT_102;
                         openProcesses = false;
@@ -518,31 +516,30 @@ public class MainActivity extends BaseActivity implements
                             intent.getAction().equals(TileService.ACTION_QS_TILE_PREFERENCES)) {
                         // tile preferences, open ftp fragment
 
-                        android.support.v4.app.FragmentTransaction transaction2 = getSupportFragmentManager().beginTransaction();
+                        FragmentTransaction transaction2 = getSupportFragmentManager().beginTransaction();
                         transaction2.replace(R.id.content_frame, new FTPServerFragment());
-                        findViewById(R.id.lin).animate().translationY(0).setInterpolator(new DecelerateInterpolator(2)).start();
+                        appBarLayout.animate().translationY(0).setInterpolator(new DecelerateInterpolator(2)).start();
 
                         selectedStorage = SELECT_MINUS_2;
                         adapter.toggleChecked(false);
                         transaction2.commit();
                     } else {
                         if (path != null && path.length() > 0) {
-                            HFile file = new HFile(OpenMode.UNKNOWN, path);
+                            HybridFile file = new HybridFile(OpenMode.UNKNOWN, path);
                             file.generateMode(MainActivity.this);
                             if (file.isDirectory(MainActivity.this))
                                 goToMain(path);
                             else {
-                                goToMain("");
-                                utils.openFile(new File(path), MainActivity.this);
+                                goToMain(null);
+                                FileUtils.openFile(new File(path), MainActivity.this, getPrefs());
                             }
                         } else {
-                            goToMain("");
+                            goToMain(null);
 
                         }
                     }
                 } else {
-                    COPY_PATH = savedInstanceState.getParcelableArrayList("COPY_PATH");
-                    MOVE_PATH = savedInstanceState.getParcelableArrayList("MOVE_PATH");
+                    pasteHelper = savedInstanceState.getParcelable(PASTEHELPER_BUNDLE);
                     oppathe = savedInstanceState.getString("oppathe");
                     oppathe1 = savedInstanceState.getString("oppathe1");
                     oparrayList = savedInstanceState.getParcelableArrayList("oparrayList");
@@ -571,6 +568,43 @@ public class MainActivity extends BaseActivity implements
         });
     }
 
+    /**
+     * Initializes the floating action button to act as to save data from an external intent
+     */
+    private void initFabToSave(final ArrayList<Uri> uris) {
+
+        floatingActionButton.setVisibility(View.VISIBLE);
+
+        Drawable drawable = getResources().getDrawable(R.drawable.ic_file_download_black_24dp);
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+
+            if (drawable instanceof VectorDrawable) {
+
+                VectorDrawable vectorDrawable = (VectorDrawable) drawable;
+                vectorDrawable.setTint(getResources().getColor(android.R.color.white));
+
+                floatingActionButton.getMenuIconView().setImageDrawable(vectorDrawable);
+            }
+        } else {
+
+            if (drawable instanceof VectorDrawableCompat) {
+
+                VectorDrawableCompat vectorDrawableCompat = (VectorDrawableCompat) drawable;
+                vectorDrawableCompat.setTint(getResources().getColor(android.R.color.white));
+
+                floatingActionButton.getMenuIconView().setImageDrawable(vectorDrawableCompat);
+            }
+        }
+
+
+        floatingActionButton.setOnMenuButtonClickListener(v -> {
+            FileUtil.writeUriToStorage(MainActivity.this, uris, getContentResolver(), getCurrentMainFragment().getCurrentPath());
+            Toast.makeText(MainActivity.this, getResources().getString(R.string.saving), Toast.LENGTH_LONG).show();
+            finish();
+        });
+    }
+
     /**
      * Initializes an interactive shell, which will stay throughout the app lifecycle
      * The shell is associated with a handler thread which maintain the message queue from the
@@ -578,7 +612,7 @@ public class MainActivity extends BaseActivity implements
      * of possible deadlock situation and the asynchronous behaviour of LibSuperSU
      */
     private void initializeInteractiveShell() {
-        // only one looper can be associated to a thread. So we're making sure not to create new
+        // only one looper can be associated to a thread. So we are making sure not to create new
         // handler threads every time the code relaunch.
         if (rootMode) {
             handlerThread = new HandlerThread("handler");
@@ -593,7 +627,7 @@ public class MainActivity extends BaseActivity implements
                     closeInteractiveShell();
                     sharedPref.edit().putBoolean(PreferenceUtils.KEY_ROOT, false).apply();
                 }
-            } catch (RootNotPermittedException e) {
+            } catch (ShellNotRunningException e) {
                 e.printStackTrace();
                 sharedPref.edit().putBoolean(PreferenceUtils.KEY_ROOT, false).apply();
             }*/
@@ -663,11 +697,11 @@ public class MainActivity extends BaseActivity implements
             String strings[] = FileUtil.getExtSdCardPathsForActivity(this);
             for (String s : strings) {
                 File f = new File(s);
-                if (!rv.contains(s) && Futils.canListFiles(f))
+                if (!rv.contains(s) && FileUtils.canListFiles(f))
                     rv.add(s);
             }
         }
-        if (BaseActivity.rootMode)
+        if (ThemedActivity.rootMode)
             rv.add("/");
         File usb = getUsbDrive();
         if (usb != null && !rv.contains(usb.getPath())) rv.add(usb.getPath());
@@ -687,13 +721,13 @@ public class MainActivity extends BaseActivity implements
         if (usbManager.getDeviceList().size()!=0) {
             // we need to set this every time as there is no way to know that whether USB device was
             // disconnected after closing the app and another one was connected
-            // in that case the uri will obviously change
-            // other wise we could persist the uri even after reopening the app by not writing
+            // in that case the URI will obviously change
+            // other wise we could persist the URI even after reopening the app by not writing
             // this preference when it's not null
-            sharedPref.edit().putString(KEY_PREF_OTG, VALUE_PREF_OTG_NULL).apply();
+            getPrefs().edit().putString(KEY_PREF_OTG, VALUE_PREF_OTG_NULL).apply();
             return true;
         } else {
-            sharedPref.edit().putString(KEY_PREF_OTG, null).apply();
+            getPrefs().edit().putString(KEY_PREF_OTG, null).apply();
             return false;
         }
     }
@@ -710,64 +744,57 @@ public class MainActivity extends BaseActivity implements
     }
 
     void onbackpressed() {
-        try {
-            Fragment fragment = getSupportFragmentManager().findFragmentById(R.id.content_frame);
-            String name = fragment.getClass().getName();
-            if (searchViewLayout.isShown()) {
-                // hide search view if visible, with an animation
-                hideSearchView();
-            } else if (name.contains("TabFragment")) {
-                if (floatingActionButton.isOpened()) {
-                    floatingActionButton.close(true);
-                } else {
-                    TabFragment tabFragment = ((TabFragment) getSupportFragmentManager().findFragmentById(R.id.content_frame));
-                    Fragment fragment1 = tabFragment.getTab();
-                    MainFragment mainFrag = (MainFragment) fragment1;
-                    mainFrag.goBack();
-                }
-            } else if (name.contains("ZipViewer")) {
-                ZipViewer zipViewer = (ZipViewer) getSupportFragmentManager().findFragmentById(R.id.content_frame);
-                if (zipViewer.mActionMode == null) {
-                    if (zipViewer.canGoBack()) {
-                        zipViewer.goBack();
-                    } else if (openzip) {
-                        openzip = false;
-                        finish();
-                    } else {
-                        FragmentTransaction fragmentTransaction = getSupportFragmentManager().beginTransaction();
-                        fragmentTransaction.setCustomAnimations(R.anim.slide_out_bottom, R.anim.slide_out_bottom);
-                        fragmentTransaction.remove(zipViewer);
-                        fragmentTransaction.commit();
-                        supportInvalidateOptionsMenu();
-                        floatingActionButton.setVisibility(View.VISIBLE);
-                        floatingActionButton.showMenuButton(true);
-                    }
+        Fragment fragment = getFragmentAtFrame();
+        if (getAppbar().getSearchView().isShown()) {
+            // hide search view if visible, with an animation
+            getAppbar().getSearchView().hideSearchView();
+        } else if (fragment instanceof TabFragment) {
+            if (floatingActionButton.isOpened()) {
+                floatingActionButton.close(true);
+            } else {
+                getCurrentMainFragment().goBack();
+            }
+        } else if (fragment instanceof CompressedExplorerFragment) {
+            CompressedExplorerFragment compressedExplorerFragment = (CompressedExplorerFragment)  getFragmentAtFrame();
+            if (compressedExplorerFragment.mActionMode == null) {
+                if (compressedExplorerFragment.canGoBack()) {
+                    compressedExplorerFragment.goBack();
+                } else if (openzip) {
+                    openzip = false;
+                    finish();
                 } else {
-                    zipViewer.mActionMode.finish();
+                    FragmentTransaction fragmentTransaction = getSupportFragmentManager().beginTransaction();
+                    fragmentTransaction.setCustomAnimations(R.anim.slide_out_bottom, R.anim.slide_out_bottom);
+                    fragmentTransaction.remove(compressedExplorerFragment);
+                    fragmentTransaction.commit();
+                    supportInvalidateOptionsMenu();
+                    floatingActionButton.setVisibility(View.VISIBLE);
+                    floatingActionButton.showMenuButton(true);
                 }
-            } else if (name.contains("FTPServerFragment")) {
-                //returning back from FTP server
-                if (path != null && path.length() > 0) {
-                    HFile file = new HFile(OpenMode.UNKNOWN, path);
-                    file.generateMode(this);
-                    if (file.isDirectory(this))
-                        goToMain(path);
-                    else {
-                        goToMain("");
-                        utils.openFile(new File(path), this);
-                    }
-                } else {
-                    goToMain("");
+            } else {
+                compressedExplorerFragment.mActionMode.finish();
+            }
+        } else if (fragment instanceof FTPServerFragment) {
+            //returning back from FTP server
+            if (path != null && path.length() > 0) {
+                HybridFile file = new HybridFile(OpenMode.UNKNOWN, path);
+                file.generateMode(this);
+                if (file.isDirectory(this))
+                    goToMain(path);
+                else {
+                    goToMain(null);
+                    FileUtils.openFile(new File(path), this, getPrefs());
                 }
-            } else
-                goToMain("");
-        } catch (ClassCastException e) {
-            goToMain("");
+            } else {
+                goToMain(null);
+            }
+        } else {
+            goToMain(null);
         }
     }
 
     public void invalidatePasteButton(MenuItem paste) {
-        if (MOVE_PATH != null || COPY_PATH != null) {
+        if (pasteHelper != null) {
             paste.setVisible(true);
         } else {
             paste.setVisible(false);
@@ -778,17 +805,14 @@ public class MainActivity extends BaseActivity implements
         if (backPressedToExitOnce) {
             SshConnectionPool.getInstance().expungeAllConnections();
             finish();
-            if (BaseActivity.rootMode) {
+            if (ThemedActivity.rootMode) {
                 // TODO close all shells
             }
         } else {
             this.backPressedToExitOnce = true;
             showToast(getString(R.string.pressagain));
-            new Handler().postDelayed(new Runnable() {
-                @Override
-                public void run() {
-                    backPressedToExitOnce = false;
-                }
+            new Handler().postDelayed(() -> {
+                backPressedToExitOnce = false;
             }, 2000);
         }
     }
@@ -848,7 +872,7 @@ public class MainActivity extends BaseActivity implements
         selectedStorage = SELECT_0;
         transaction.addToBackStack("tabt" + 1);
         transaction.commitAllowingStateLoss();
-        setActionBarTitle(null);
+        appbar.setTitle(null);
         floatingActionButton.setVisibility(View.VISIBLE);
         floatingActionButton.showMenuButton(true);
         if (openzip && zippath != null) {
@@ -888,7 +912,7 @@ public class MainActivity extends BaseActivity implements
                 adapter.toggleChecked(selectedStorage);
 
                 if (((EntryItem) directoryItems.get(i)).getPath().contains(OTGUtil.PREFIX_OTG) &&
-                        sharedPref.getString(KEY_PREF_OTG, null).equals(VALUE_PREF_OTG_NULL)) {
+                        getPrefs().getString(KEY_PREF_OTG, null).equals(VALUE_PREF_OTG_NULL)) {
                     // we've not gotten otg path yet
                     // start system request for storage access framework
                     Toast.makeText(getApplicationContext(),
@@ -933,26 +957,14 @@ public class MainActivity extends BaseActivity implements
         return super.onCreateOptionsMenu(menu);
     }
 
-    public void setActionBarTitle(String title) {
-        if (toolbar != null)
-            toolbar.setTitle(title);
-    }
-
     @Override
     public boolean onPrepareOptionsMenu(Menu menu) {
         MenuItem s = menu.findItem(R.id.view);
         MenuItem search = menu.findItem(R.id.search);
         MenuItem paste = menu.findItem(R.id.paste);
-        String fragmentName;
-        Fragment fragment;
-        try {
-            fragment = getSupportFragmentManager().findFragmentById(R.id.content_frame);
-            fragmentName = fragment.getClass().getName();
-        } catch (Exception e) {
-            return true;
-        }
-        if (fragmentName.contains("TabFragment")) {
-            setActionBarTitle("Amaze");
+        Fragment fragment = getFragmentAtFrame();
+        if (fragment instanceof TabFragment) {
+            appbar.setTitle(R.string.appbar_name);
             if (useGridView) {
                 s.setTitle(getResources().getString(R.string.gridview));
             } else {
@@ -960,14 +972,15 @@ public class MainActivity extends BaseActivity implements
             }
             try {
                 TabFragment tabFragment = (TabFragment) fragment;
-                MainFragment ma = ((MainFragment) tabFragment.getTab());
+                MainFragment ma = getCurrentMainFragment();
                 if (ma.IS_LIST) s.setTitle(R.string.gridview);
                 else s.setTitle(R.string.listview);
-                updatePath(ma.getCurrentPath(), ma.results, ma.openMode, ma.folder_count, ma.file_count);
+                appbar.getBottomBar().updatePath(ma.getCurrentPath(), ma.results,
+                        MainActivityHelper.SEARCH_TEXT, ma.openMode, ma.folder_count, ma.file_count, ma);
             } catch (Exception e) {}
 
-            initiatebbar();
-            if (SDK_INT >= 21) toolbar.setElevation(0);
+            appbar.getBottomBar().setClickListener();
+
             invalidatePasteButton(paste);
             search.setVisible(true);
             if (indicator_layout != null) indicator_layout.setVisibility(View.VISIBLE);
@@ -981,8 +994,8 @@ public class MainActivity extends BaseActivity implements
             menu.findItem(R.id.extract).setVisible(false);
             invalidatePasteButton(menu.findItem(R.id.paste));
             findViewById(R.id.buttonbarframe).setVisibility(View.VISIBLE);
-        } else if (fragmentName.contains("AppsList") || fragmentName.contains("ProcessViewer") ||
-                fragmentName.contains(FTPServerFragment.class.getName())) {
+        } else if (fragment instanceof AppsListFragment || fragment instanceof ProcessViewerFragment
+                || fragment instanceof FTPServerFragment) {
             appBarLayout.setExpanded(true);
             menu.findItem(R.id.sethome).setVisible(false);
             if (indicator_layout != null) indicator_layout.setVisibility(View.GONE);
@@ -991,28 +1004,20 @@ public class MainActivity extends BaseActivity implements
             menu.findItem(R.id.home).setVisible(false);
             menu.findItem(R.id.history).setVisible(false);
             menu.findItem(R.id.extract).setVisible(false);
-            if (fragmentName.contains("ProcessViewer")) menu.findItem(R.id.sort).setVisible(false);
-            else {
+            if (fragment instanceof ProcessViewerFragment) {
+                menu.findItem(R.id.sort).setVisible(false);
+            } else {
                 menu.findItem(R.id.dsort).setVisible(false);
                 menu.findItem(R.id.sortby).setVisible(false);
             }
             menu.findItem(R.id.hiddenitems).setVisible(false);
             menu.findItem(R.id.view).setVisible(false);
             menu.findItem(R.id.paste).setVisible(false);
-        } else if (fragmentName.contains("ZipViewer")) {
+        } else if (fragment instanceof CompressedExplorerFragment) {
+            appbar.setTitle(R.string.appbar_name);
             menu.findItem(R.id.sethome).setVisible(false);
             if (indicator_layout != null) indicator_layout.setVisibility(View.GONE);
-            TextView textView = (TextView) mainActivity.pathbar.findViewById(R.id.fullpath);
-            pathbar.setOnClickListener(new View.OnClickListener() {
-                @Override
-                public void onClick(View view) {
-                }
-            });
-            textView.setOnClickListener(new View.OnClickListener() {
-                @Override
-                public void onClick(View view) {
-                }
-            });
+            getAppbar().getBottomBar().resetClickListener();
             menu.findItem(R.id.search).setVisible(false);
             menu.findItem(R.id.home).setVisible(false);
             menu.findItem(R.id.history).setVisible(false);
@@ -1055,12 +1060,7 @@ public class MainActivity extends BaseActivity implements
             return true;
         }
         // Handle action buttons
-        MainFragment ma = null;
-        try {
-            TabFragment tabFragment = getFragment();
-            if (tabFragment != null)
-                ma = (MainFragment) tabFragment.getTab();
-        } catch (Exception e) {}
+        MainFragment ma = getCurrentMainFragment();
 
         switch (item.getItemId()) {
             case R.id.home:
@@ -1069,7 +1069,7 @@ public class MainActivity extends BaseActivity implements
                 break;
             case R.id.history:
                 if (ma != null)
-                    GeneralDialogCreation.showHistoryDialog(dataUtils, utils, ma, getAppTheme());
+                    GeneralDialogCreation.showHistoryDialog(dataUtils, getPrefs(), ma, getAppTheme());
                 break;
             case R.id.sethome:
                 if (ma == null) return super.onOptionsItemSelected(item);
@@ -1078,16 +1078,13 @@ public class MainActivity extends BaseActivity implements
                     Toast.makeText(mainActivity, R.string.not_allowed, Toast.LENGTH_SHORT).show();
                     break;
                 }
-                final MaterialDialog dialog = GeneralDialogCreation.showBasicDialog(mainActivity, BaseActivity.accentSkin, getAppTheme(),
+                final MaterialDialog dialog = GeneralDialogCreation.showBasicDialog(mainActivity,
                         new String[]{getResources().getString(R.string.questionset),
                                 getResources().getString(R.string.setashome), getResources().getString(R.string.yes), getResources().getString(R.string.no), null});
-                dialog.getActionButton(DialogAction.POSITIVE).setOnClickListener(new View.OnClickListener() {
-                    @Override
-                    public void onClick(View v) {
-                        main.home = main.getCurrentPath();
-                        updatePaths(main.no);
-                        dialog.dismiss();
-                    }
+                dialog.getActionButton(DialogAction.POSITIVE).setOnClickListener((v) -> {
+                    main.home = main.getCurrentPath();
+                    updatePaths(main.no);
+                    dialog.dismiss();
                 });
                 dialog.show();
                 break;
@@ -1095,13 +1092,14 @@ public class MainActivity extends BaseActivity implements
                 finish();
                 break;
             case R.id.sort:
-                Fragment fragment = getDFragment();
-                if (fragment.getClass().getName().contains("AppsList"))
-                    GeneralDialogCreation.showSortDialog((AppsList) fragment, getAppTheme());
+                Fragment fragment = getFragmentAtFrame();
+                if (fragment instanceof AppsListFragment) {
+                    GeneralDialogCreation.showSortDialog((AppsListFragment) fragment, getAppTheme());
+                }
                 break;
             case R.id.sortby:
                 if (ma != null)
-                    GeneralDialogCreation.showSortDialog(ma, getAppTheme(), sharedPref);
+                    GeneralDialogCreation.showSortDialog(ma, getAppTheme(), getPrefs());
                 break;
             case R.id.dsort:
                 if (ma == null) return super.onOptionsItemSelected(item);
@@ -1109,24 +1107,21 @@ public class MainActivity extends BaseActivity implements
                 MaterialDialog.Builder builder = new MaterialDialog.Builder(mainActivity);
                 builder.theme(getAppTheme().getMaterialDialogTheme());
                 builder.title(R.string.directorysort);
-                int current = Integer.parseInt(sharedPref.getString("dirontop", "0"));
+                int current = Integer.parseInt(getPrefs().getString("dirontop", "0"));
 
                 final MainFragment mainFrag = ma;
 
-                builder.items(sort).itemsCallbackSingleChoice(current, new MaterialDialog.ListCallbackSingleChoice() {
-                    @Override
-                    public boolean onSelection(MaterialDialog dialog, View view, int which, CharSequence text) {
-                        sharedPref.edit().putString("dirontop", "" + which).commit();
-                        mainFrag.getSortModes();
-                        mainFrag.updateList();
-                        dialog.dismiss();
-                        return true;
-                    }
+                builder.items(sort).itemsCallbackSingleChoice(current, (dialog1, view, which, text) -> {
+                    getPrefs().edit().putString("dirontop", "" + which).commit();
+                    mainFrag.getSortModes();
+                    mainFrag.updateList();
+                    dialog1.dismiss();
+                    return true;
                 });
                 builder.build().show();
                 break;
             case R.id.hiddenitems:
-                GeneralDialogCreation.showHiddenDialog(dataUtils, utils, ma, getAppTheme());
+                GeneralDialogCreation.showHiddenDialog(dataUtils, getPrefs(), ma, getAppTheme());
                 break;
             case R.id.view:
                 final MainFragment mainFragment = ma;
@@ -1134,20 +1129,14 @@ public class MainActivity extends BaseActivity implements
                     if (dataUtils.getListfiles().contains(ma.getCurrentPath())) {
                         dataUtils.getListfiles().remove(ma.getCurrentPath());
 
-                        AppConfig.runInBackground(new Runnable() {
-                            @Override
-                            public void run() {
-                                utilsHandler.removeListViewPath(mainFragment.getCurrentPath());
-                            }
+                        AppConfig.runInBackground(() -> {
+                            utilsHandler.removeListViewPath(mainFragment.getCurrentPath());
                         });
                         //grid.removePath(ma.CURRENT_PATH, DataUtils.LIST);
                     }
 
-                    AppConfig.runInBackground(new Runnable() {
-                        @Override
-                        public void run() {
-                            utilsHandler.addGridView(mainFragment.getCurrentPath());
-                        }
+                    AppConfig.runInBackground(() -> {
+                        utilsHandler.addGridView(mainFragment.getCurrentPath());
                     });
                     //grid.addPath(null, ma.CURRENT_PATH, DataUtils.GRID, 0);
                     dataUtils.getGridFiles().add(ma.getCurrentPath());
@@ -1156,19 +1145,13 @@ public class MainActivity extends BaseActivity implements
                         dataUtils.getGridFiles().remove(ma.getCurrentPath());
                         //grid.removePath(ma.CURRENT_PATH, DataUtils.GRID);
 
-                        AppConfig.runInBackground(new Runnable() {
-                            @Override
-                            public void run() {
-                                utilsHandler.removeGridViewPath(mainFragment.getCurrentPath());
-                            }
+                        AppConfig.runInBackground(() -> {
+                            utilsHandler.removeGridViewPath(mainFragment.getCurrentPath());
                         });
                     }
 
-                    AppConfig.runInBackground(new Runnable() {
-                        @Override
-                        public void run() {
-                            utilsHandler.addListView(mainFragment.getCurrentPath());
-                        }
+                    AppConfig.runInBackground(() -> {
+                        utilsHandler.addListView(mainFragment.getCurrentPath());
                     });
                     //grid.addPath(null, ma.CURRENT_PATH, DataUtils.LIST, 0);
                     dataUtils.getListfiles().add(ma.getCurrentPath());
@@ -1177,111 +1160,26 @@ public class MainActivity extends BaseActivity implements
                 break;
             case R.id.paste:
                 String path = ma.getCurrentPath();
-                ArrayList<BaseFile> arrayList = COPY_PATH != null? COPY_PATH:MOVE_PATH;
-                boolean move = MOVE_PATH != null;
-                new CopyFileCheck(ma, path, move, mainActivity, BaseActivity.rootMode)
+                ArrayList<HybridFileParcelable> arrayList = new ArrayList<>(Arrays.asList(pasteHelper.paths));
+                boolean move = pasteHelper.operation == PasteHelper.OPERATION_CUT;
+                new PrepareCopyTask(ma, path, move, mainActivity, ThemedActivity.rootMode)
                         .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, arrayList);
-                COPY_PATH = null;
-                MOVE_PATH = null;
+                pasteHelper = null;
                 invalidatePasteButton(item);
                 break;
             case R.id.extract:
-                Fragment fragment1 = getSupportFragmentManager().findFragmentById(R.id.content_frame);
-                if (fragment1.getClass().getName().contains("ZipViewer"))
-                    mainActivityHelper.extractFile(((ZipViewer) fragment1).f);
+                Fragment fragment1 = getFragmentAtFrame();
+                if (fragment1 instanceof CompressedExplorerFragment) {
+                    mainActivityHelper.extractFile(((CompressedExplorerFragment) fragment1).compressedFile);
+                }
                 break;
             case R.id.search:
-                View searchItem = toolbar.findViewById(R.id.search);
-                searchViewEditText.setText("");
-                searchItem.getLocationOnScreen(searchCoords);
-                revealSearchView();
+                getAppbar().getSearchView().revealSearchView();
                 break;
         }
         return super.onOptionsItemSelected(item);
     }
 
-    /**
-     * show search view with a circular reveal animation
-     */
-    void revealSearchView() {
-        final int START_RADIUS = 16;
-        int endRadius = Math.max(toolbar.getWidth(), toolbar.getHeight());
-
-        Animator animator;
-        if (SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {
-            animator = ViewAnimationUtils.createCircularReveal(searchViewLayout,
-                    searchCoords[0] + 32, searchCoords[1] - 16, START_RADIUS, endRadius);
-        } else {
-            // TODO:ViewAnimationUtils.createCircularReveal
-            animator = ObjectAnimator.ofFloat(searchViewLayout, "alpha", 0f, 1f);
-        }
-
-        utils.revealShow(fabBgView, true);
-
-        animator.setInterpolator(new AccelerateDecelerateInterpolator());
-        animator.setDuration(600);
-        searchViewLayout.setVisibility(View.VISIBLE);
-        animator.start();
-        animator.addListener(new Animator.AnimatorListener() {
-            @Override
-            public void onAnimationStart(Animator animation) {}
-
-            @Override
-            public void onAnimationEnd(Animator animation) {
-                searchViewEditText.requestFocus();
-                InputMethodManager imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
-                imm.showSoftInput(searchViewEditText, InputMethodManager.SHOW_IMPLICIT);
-                isSearchViewEnabled = true;
-            }
-
-            @Override
-            public void onAnimationCancel(Animator animation) {}
-
-            @Override
-            public void onAnimationRepeat(Animator animation) {}
-        });
-    }
-
-    /**
-     * hide search view with a circular reveal animation
-     */
-    public void hideSearchView() {
-        final int END_RADIUS = 16;
-        int startRadius = Math.max(searchViewLayout.getWidth(), searchViewLayout.getHeight());
-        Animator animator;
-        if (SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {
-            animator = ViewAnimationUtils.createCircularReveal(searchViewLayout,
-                    searchCoords[0] + 32, searchCoords[1] - 16, startRadius, END_RADIUS);
-        } else {
-            // TODO: ViewAnimationUtils.createCircularReveal
-            animator = ObjectAnimator.ofFloat(searchViewLayout, "alpha", 1f, 0f);
-        }
-
-        // removing background fade view
-        utils.revealShow(fabBgView, false);
-        animator.setInterpolator(new AccelerateDecelerateInterpolator());
-        animator.setDuration(600);
-        animator.start();
-        animator.addListener(new Animator.AnimatorListener() {
-            @Override
-            public void onAnimationStart(Animator animation) {}
-
-            @Override
-            public void onAnimationEnd(Animator animation) {
-                searchViewLayout.setVisibility(View.GONE);
-                isSearchViewEnabled = false;
-                InputMethodManager inputMethodManager = (InputMethodManager) getSystemService(INPUT_METHOD_SERVICE);
-                inputMethodManager.hideSoftInputFromWindow(searchViewEditText.getWindowToken(), InputMethodManager.HIDE_IMPLICIT_ONLY);
-            }
-
-            @Override
-            public void onAnimationCancel(Animator animation) {}
-
-            @Override
-            public void onAnimationRepeat(Animator animation) {}
-        });
-    }
-
     /*@Override
     public void onRestoreInstanceState(Bundle savedInstanceState){
         COPY_PATH=savedInstanceState.getStringArrayList("COPY_PATH");
@@ -1313,10 +1211,10 @@ public class MainActivity extends BaseActivity implements
         super.onSaveInstanceState(outState);
         if (selectedStorage != NO_VALUE)
             outState.putInt("selectitem", selectedStorage);
-        if (COPY_PATH != null)
-            outState.putParcelableArrayList("COPY_PATH", COPY_PATH);
-        if (MOVE_PATH != null)
-            outState.putParcelableArrayList("MOVE_PATH", MOVE_PATH);
+        if(pasteHelper != null) {
+            outState.putParcelable(PASTEHELPER_BUNDLE, pasteHelper);
+        }
+
         if (oppathe != null) {
             outState.putString("oppathe", oppathe);
             outState.putString("oppathe1", oppathe1);
@@ -1334,9 +1232,6 @@ public class MainActivity extends BaseActivity implements
         unregisterReceiver(mainActivityHelper.mNotificationReceiver);
         unregisterReceiver(receiver2);
 
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT)
-            unbindService(mEncryptServiceConnection);
-
         if (SDK_INT >= Build.VERSION_CODES.KITKAT) {
             unregisterReceiver(mOtgReceiver);
         }
@@ -1365,56 +1260,8 @@ public class MainActivity extends BaseActivity implements
             otgFilter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);
             registerReceiver(mOtgReceiver, otgFilter);
         }
-
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
-            // let's register encryption service to know when we've decrypted
-            Intent encryptIntent = new Intent(this, EncryptService.class);
-            bindService(encryptIntent, mEncryptServiceConnection, 0);
-
-            if (!isEncryptOpen && encryptBaseFile != null) {
-                // we've opened the file and are ready to delete it
-                // don't move this to ondestroy as we'll be getting destroyed and starting
-                // an async task just before it is not a good idea
-                ArrayList<BaseFile> baseFiles = new ArrayList<>();
-                baseFiles.add(encryptBaseFile);
-                new DeleteTask(getContentResolver(), this).execute(baseFiles);
-            }
-        }
     }
 
-    ServiceConnection mEncryptServiceConnection = new ServiceConnection() {
-        @Override
-        public void onServiceConnected(ComponentName name, IBinder service) {
-
-        }
-
-        @Override
-        public void onServiceDisconnected(ComponentName name) {
-
-            if (isEncryptOpen && encryptBaseFile != null) {
-                if (mainFragment != null) {
-                    switch (mainFragment.openMode) {
-                        case OTG:
-                            getFutils().openFile(OTGUtil.getDocumentFile(encryptBaseFile.getPath(),
-                                    MainActivity.this, false), MainActivity.this);
-                            break;
-                        case SMB:
-                            try {
-                                MainFragment.launchSMB(new SmbFile(encryptBaseFile.getPath()),
-                                        encryptBaseFile.getSize(), MainActivity.this);
-                            } catch (MalformedURLException e) {
-                                e.printStackTrace();
-                            }
-                        default:
-                            getFutils().openFile(new File(encryptBaseFile.getPath()), MainActivity.this);
-                    }
-                } else
-                    getFutils().openFile(new File(encryptBaseFile.getPath()), MainActivity.this);
-                isEncryptOpen = false;
-            }
-        }
-    };
-
     /**
      * Receiver to check if a USB device is connected at the runtime of application
      * If device is not connected at runtime (i.e. it was connected when the app was closed)
@@ -1425,12 +1272,12 @@ public class MainActivity extends BaseActivity implements
         @Override
         public void onReceive(Context context, Intent intent) {
             if (intent.getAction().equals(UsbManager.ACTION_USB_DEVICE_ATTACHED)) {
-                sharedPref.edit().putString(KEY_PREF_OTG, VALUE_PREF_OTG_NULL).apply();
+                getPrefs().edit().putString(KEY_PREF_OTG, VALUE_PREF_OTG_NULL).apply();
                 refreshDrawer();
             } else if (intent.getAction().equals(UsbManager.ACTION_USB_DEVICE_DETACHED)) {
-                sharedPref.edit().putString(KEY_PREF_OTG, null).apply();
+                getPrefs().edit().putString(KEY_PREF_OTG, null).apply();
                 refreshDrawer();
-                goToMain("");
+                goToMain(null);
             }
         }
     };
@@ -1439,7 +1286,7 @@ public class MainActivity extends BaseActivity implements
     public boolean onKeyDown(int keyCode, KeyEvent event) {
         if (keyCode == KeyEvent.KEYCODE_MENU) {
             /*
-            ImageView ib = (ImageView) findViewById(R.id.action_overflow);
+            ImageView ib = findViewById(R.id.action_overflow);
             if (ib.getVisibility() == View.VISIBLE) {
                 ib.performClick();
             }
@@ -1464,7 +1311,7 @@ public class MainActivity extends BaseActivity implements
 
         CryptHandler cryptHandler = new CryptHandler(this);
         cryptHandler.close();
-
+        
         SshConnectionPool.getInstance().expungeAllConnections();
 
         /*if (mainFragment!=null)
@@ -1486,18 +1333,18 @@ public class MainActivity extends BaseActivity implements
     }
 
     public void updatePaths(int pos) {
-        TabFragment tabFragment = getFragment();
+        TabFragment tabFragment = getTabFragment();
         if (tabFragment != null)
             tabFragment.updatepaths(pos);
     }
 
     public void openZip(String path) {
-        findViewById(R.id.lin).animate().translationY(0).setInterpolator(new DecelerateInterpolator(2)).start();
+        appBarLayout.animate().translationY(0).setInterpolator(new DecelerateInterpolator(2)).start();
         FragmentTransaction fragmentTransaction = getSupportFragmentManager().beginTransaction();
         fragmentTransaction.setCustomAnimations(R.anim.slide_in_top, R.anim.slide_in_bottom);
-        Fragment zipFragment = new ZipViewer();
+        Fragment zipFragment = new CompressedExplorerFragment();
         Bundle bundle = new Bundle();
-        bundle.putString("path", path);
+        bundle.putString(CompressedExplorerFragment.KEY_PATH, path);
         zipFragment.setArguments(bundle);
         fragmentTransaction.add(R.id.content_frame, zipFragment);
         fragmentTransaction.commitAllowingStateLoss();
@@ -1507,19 +1354,27 @@ public class MainActivity extends BaseActivity implements
         openZip(path);
     }
 
-    public TabFragment getFragment() {
-        Fragment fragment = getDFragment();
+    public MainFragment getCurrentMainFragment() {
+        TabFragment tab = getTabFragment();
+
+        if(tab != null && tab.getCurrentTabFragment() instanceof MainFragment) {
+            return (MainFragment) tab.getCurrentTabFragment();
+        } else return null;
+    }
+
+    public TabFragment getTabFragment() {
+        Fragment fragment = getFragmentAtFrame();
 
-        if (fragment == null || !(fragment instanceof TabFragment)) return null;
+        if (!(fragment instanceof TabFragment)) return null;
         else return (TabFragment) fragment;
     }
 
-    public Fragment getDFragment() {
+    public Fragment getFragmentAtFrame() {
         return getSupportFragmentManager().findFragmentById(R.id.content_frame);
     }
 
     public void setPagingEnabled(boolean b) {
-        getFragment().mViewPager.setPagingEnabled(b);
+        getTabFragment().mViewPager.setPagingEnabled(b);
     }
 
     public File getUsbDrive() {
@@ -1533,7 +1388,7 @@ public class MainActivity extends BaseActivity implements
 
         parent = new File("/mnt/sdcard/usbStorage");
         if (parent.exists() && parent.canExecute())
-            return (parent);
+            return parent;
         parent = new File("/mnt/sdcard/usb_storage");
         if (parent.exists() && parent.canExecute())
             return parent;
@@ -1549,17 +1404,17 @@ public class MainActivity extends BaseActivity implements
         for (String file : storageDirectories) {
             File f = new File(file);
             String name;
-            Drawable icon1 = ContextCompat.getDrawable(MainActivity.this, R.drawable.ic_sd_storage_white_56dp);
+            Drawable icon1 = ContextCompat.getDrawable(this, R.drawable.ic_sd_storage_white_56dp);
             if ("/storage/emulated/legacy".equals(file) || "/storage/emulated/0".equals(file)) {
                 name = getResources().getString(R.string.storage);
             } else if ("/storage/sdcard1".equals(file)) {
                 name = getResources().getString(R.string.extstorage);
             } else if ("/".equals(file)) {
                 name = getResources().getString(R.string.rootdirectory);
-                icon1 = ContextCompat.getDrawable(MainActivity.this, R.drawable.ic_drawer_root_white);
+                icon1 = ContextCompat.getDrawable(this, R.drawable.ic_drawer_root_white);
             } else if (file.contains(OTGUtil.PREFIX_OTG)) {
                 name = "OTG";
-                icon1 = ContextCompat.getDrawable(MainActivity.this, R.drawable.ic_usb_white_48dp);
+                icon1 = ContextCompat.getDrawable(this, R.drawable.ic_usb_white_48dp);
             } else name = f.getName();
             if (!f.isDirectory() || f.canExecute()) {
                 storage_count++;
@@ -1572,11 +1427,10 @@ public class MainActivity extends BaseActivity implements
         if (dataUtils.getServers().size() > 0) {
             Collections.sort(dataUtils.getServers(), new BookSorter());
             synchronized (dataUtils.getServers()) {
-
                 for (String[] file : dataUtils.getServers()) {
                     sectionItems.add(new EntryItem(file[0], file[1], ContextCompat.getDrawable(MainActivity.this,
-                            (file[1].startsWith("ssh://")) ? R.drawable.ic_linux_grey600_24dp
-                                    : R.drawable.ic_settings_remote_white_48dp)));
+                            (file[1].startsWith(SshConnectionPool.SSH_URI_PREFIX)) ?
+                                    R.drawable.ic_linux_grey600_24dp : R.drawable.ic_settings_remote_white_48dp)));
                 }
             }
             sectionItems.add(new SectionItem());
@@ -1584,15 +1438,13 @@ public class MainActivity extends BaseActivity implements
 
         ArrayList<String[]> accountAuthenticationList = new ArrayList<>();
 
-        if (CloudSheetFragment.isCloudProviderAvailable(MainActivity.this)) {
-
+        if (CloudSheetFragment.isCloudProviderAvailable(this)) {
             for (CloudStorage cloudStorage : dataUtils.getAccounts()) {
-
                 if (cloudStorage instanceof Dropbox) {
 
                     sectionItems.add(new EntryItem(CloudHandler.CLOUD_NAME_DROPBOX,
                             CloudHandler.CLOUD_PREFIX_DROPBOX + "/",
-                            ContextCompat.getDrawable(MainActivity.this, R.drawable.ic_dropbox_white_24dp)));
+                            ContextCompat.getDrawable(this, R.drawable.ic_dropbox_white_24dp)));
 
                     accountAuthenticationList.add(new String[] {
                             CloudHandler.CLOUD_NAME_DROPBOX,
@@ -1602,7 +1454,7 @@ public class MainActivity extends BaseActivity implements
 
                     sectionItems.add(new EntryItem(CloudHandler.CLOUD_NAME_BOX,
                             CloudHandler.CLOUD_PREFIX_BOX + "/",
-                            ContextCompat.getDrawable(MainActivity.this, R.drawable.ic_box_white_24dp)));
+                            ContextCompat.getDrawable(this, R.drawable.ic_box_white_24dp)));
 
                     accountAuthenticationList.add(new String[] {
                             CloudHandler.CLOUD_NAME_BOX,
@@ -1612,7 +1464,7 @@ public class MainActivity extends BaseActivity implements
 
                     sectionItems.add(new EntryItem(CloudHandler.CLOUD_NAME_ONE_DRIVE,
                             CloudHandler.CLOUD_PREFIX_ONE_DRIVE + "/",
-                            ContextCompat.getDrawable(MainActivity.this, R.drawable.ic_onedrive_white_24dp)));
+                            ContextCompat.getDrawable(this, R.drawable.ic_onedrive_white_24dp)));
 
                     accountAuthenticationList.add(new String[] {
                             CloudHandler.CLOUD_NAME_ONE_DRIVE,
@@ -1622,7 +1474,7 @@ public class MainActivity extends BaseActivity implements
 
                     sectionItems.add(new EntryItem(CloudHandler.CLOUD_NAME_GOOGLE_DRIVE,
                             CloudHandler.CLOUD_PREFIX_GOOGLE_DRIVE + "/",
-                            ContextCompat.getDrawable(MainActivity.this, R.drawable.ic_google_drive_white_24dp)));
+                            ContextCompat.getDrawable(this, R.drawable.ic_google_drive_white_24dp)));
 
                     accountAuthenticationList.add(new String[] {
                             CloudHandler.CLOUD_NAME_GOOGLE_DRIVE,
@@ -1636,199 +1488,67 @@ public class MainActivity extends BaseActivity implements
                 sectionItems.add(new SectionItem());
         }
 
-        if (sharedPref.getBoolean(PREFERENCE_SHOW_SIDEBAR_FOLDERS, true)) {
+        if (getPrefs().getBoolean(PREFERENCE_SHOW_SIDEBAR_FOLDERS, true)) {
             if (dataUtils.getBooks().size() > 0) {
 
                 Collections.sort(dataUtils.getBooks(), new BookSorter());
 
                 synchronized (dataUtils.getBooks()) {
-
                     for (String[] file : dataUtils.getBooks()) {
                         sectionItems.add(new EntryItem(file[0], file[1],
-                                ContextCompat.getDrawable(MainActivity.this, R.drawable.folder_fab)));
+                                ContextCompat.getDrawable(this, R.drawable.folder_fab)));
                     }
                 }
                 sectionItems.add(new SectionItem());
             }
         }
 
-        Boolean[] quickAccessPref = TinyDB.getBooleanArray(sharedPref, QuickAccessPref.KEY,
+        Boolean[] quickAccessPref = TinyDB.getBooleanArray(getPrefs(), QuickAccessPref.KEY,
                 QuickAccessPref.DEFAULT);
 
-        if (sharedPref.getBoolean(PREFERENCE_SHOW_SIDEBAR_QUICKACCESSES, true)) {
+        if (getPrefs().getBoolean(PREFERENCE_SHOW_SIDEBAR_QUICKACCESSES, true)) {
             if (quickAccessPref[0])
                 sectionItems.add(new EntryItem(getResources().getString(R.string.quick), "5",
-                        ContextCompat.getDrawable(MainActivity.this, R.drawable.ic_star_white_18dp)));
+                        ContextCompat.getDrawable(this, R.drawable.ic_star_white_18dp)));
             if (quickAccessPref[1])
                 sectionItems.add(new EntryItem(getResources().getString(R.string.recent), "6",
-                        ContextCompat.getDrawable(MainActivity.this, R.drawable.ic_history_white_48dp)));
+                        ContextCompat.getDrawable(this, R.drawable.ic_history_white_48dp)));
             if (quickAccessPref[2])
                 sectionItems.add(new EntryItem(getResources().getString(R.string.images), "0",
-                        ContextCompat.getDrawable(MainActivity.this, R.drawable.ic_doc_image)));
+                        ContextCompat.getDrawable(this, R.drawable.ic_doc_image)));
             if (quickAccessPref[3])
                 sectionItems.add(new EntryItem(getResources().getString(R.string.videos), "1",
-                        ContextCompat.getDrawable(MainActivity.this, R.drawable.ic_doc_video_am)));
+                        ContextCompat.getDrawable(this, R.drawable.ic_doc_video_am)));
             if (quickAccessPref[4])
                 sectionItems.add(new EntryItem(getResources().getString(R.string.audio), "2",
-                        ContextCompat.getDrawable(MainActivity.this, R.drawable.ic_doc_audio_am)));
+                        ContextCompat.getDrawable(this, R.drawable.ic_doc_audio_am)));
             if (quickAccessPref[5])
                 sectionItems.add(new EntryItem(getResources().getString(R.string.documents), "3",
-                        ContextCompat.getDrawable(MainActivity.this, R.drawable.ic_doc_doc_am)));
+                        ContextCompat.getDrawable(this, R.drawable.ic_doc_doc_am)));
             if (quickAccessPref[6])
                 sectionItems.add(new EntryItem(getResources().getString(R.string.apks), "4",
-                        ContextCompat.getDrawable(MainActivity.this, R.drawable.ic_doc_apk_grid)));
+                        ContextCompat.getDrawable(this, R.drawable.ic_doc_apk_grid)));
         } else {
             sectionItems.remove(sectionItems.size() - 1); //Deletes last divider
         }
 
         dataUtils.setList(sectionItems);
 
-        adapter = new DrawerAdapter(MainActivity.this, MainActivity.this, sectionItems,
-                MainActivity.this, sharedPref);
+        adapter = new DrawerAdapter(this, this, sectionItems, this, getPrefs());
         mDrawerList.setAdapter(adapter);
     }
 
-    @Override
-    protected void onStart() {
-        super.onStart();
-
-        // check if user enabled g+ api from preferences
-        if (mGoogleApiClient != null)
-            mGoogleApiClient.connect();
-    }
-
-    @Override
-    protected void onStop() {
-        super.onStop();
-
-        if (mGoogleApiClient != null && mGoogleApiClient.isConnected())
-            mGoogleApiClient.disconnect();
-    }
-
-    @Override
-    public void onConnected(Bundle bundle) {
-        if (Plus.PeopleApi.getCurrentPerson(mGoogleApiClient) != null) {
-            Person currentPerson = Plus.PeopleApi.getCurrentPerson(mGoogleApiClient);
-            String accountName = Plus.AccountApi.getAccountName(mGoogleApiClient);
-            Person.Image personImage;
-            Person.Cover.CoverPhoto personCover;
-
-            try {
-                personImage = currentPerson.getImage();
-                personCover = currentPerson.getCover().getCoverPhoto();
-            } catch (Exception e) {
-
-                personCover = null;
-                personImage = null;
-            }
-
-            if (personCover != null && personImage != null) {
-                String imgUrl = personImage.getUrl();
-
-                // getting full size image
-                StringBuilder stringBuilder = new StringBuilder();
-                stringBuilder.append(imgUrl);
-                stringBuilder.delete(imgUrl.length() - 6, imgUrl.length());
-                Log.d("G+", stringBuilder.toString());
-                mGoogleName.setText(currentPerson.getDisplayName());
-                mGoogleId.setText(accountName);
-                // setting cover pic
-                mImageLoader.get(personCover.getUrl(), new ImageLoader.ImageListener() {
-                    @Override
-                    public void onResponse(ImageLoader.ImageContainer response, boolean isImmediate) {
-                        drawerHeaderParent.setBackgroundColor(Color.parseColor("#ffffff"));
-                        if (SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
-                            drawerHeaderView.setBackground(new BitmapDrawable(response.getBitmap()));
-                        } else
-                            drawerHeaderView.setBackgroundDrawable(new BitmapDrawable(response.getBitmap()));
-                    }
-
-                    @Override
-                    public void onErrorResponse(VolleyError error) {
-                        Toast.makeText(MainActivity.this, getString(R.string.no_cover_photo),
-                                Toast.LENGTH_LONG).show();
-                    }
-                });
-
-                // setting profile pic
-                mImageLoader.get(stringBuilder.toString(), new ImageLoader.ImageListener() {
-                    @Override
-                    public void onResponse(ImageLoader.ImageContainer response, boolean isImmediate) {
-                        drawerProfilePic.setImageBitmap(response.getBitmap());
-                        drawerProfilePic.setVisibility(View.VISIBLE);
-                    }
-
-                    @Override
-                    public void onErrorResponse(VolleyError error) {
-                        Toast.makeText(MainActivity.this, getString(R.string.no_profile_pic),
-                                Toast.LENGTH_LONG).show();
-                    }
-                });
-            } else {
-                Toast.makeText(this, getResources().getText(R.string.no_cover_photo), Toast.LENGTH_SHORT).show();
-                drawerHeaderView.setBackgroundResource(R.drawable.amaze_header);
-                drawerHeaderParent.setBackgroundColor(getColorPreference().getColor(ColorUsage.getPrimary(MainActivity.currentTab)));
-            }
-        }
-    }
-
-    @Override
-    public void onConnectionSuspended(int i) {
-        Log.d("G+", "Connection suspended");
-        new Thread(new Runnable() {
-            @Override
-            public void run() {
-                if (mGoogleApiClient != null)
-                    mGoogleApiClient.connect();
-            }
-        }).run();
-    }
-
-    public void onConnectionFailed(final ConnectionResult result) {
-        Log.d("G+", "Connection failed" + result.getErrorCode() + result.getErrorCode());
-        if (!mIntentInProgress && result.hasResolution()) {
-            new Thread(new Runnable() {
-                @Override
-                public void run() {
-                    try {
-                        mIntentInProgress = true;
-                        startIntentSenderForResult(result.getResolution().getIntentSender(),
-                                RC_SIGN_IN, null, 0, 0, 0);
-                    } catch (IntentSender.SendIntentException e) {
-                        // The intent was canceled before it was sent.  Return to the default
-                        // state and attempt to connect to get an updated ConnectionResult.
-                        mIntentInProgress = false;
-                        if (mGoogleApiClient != null) {
-
-                            mGoogleApiClient.connect();
-                        }
-                    }
-                }
-            }).run();
-        }
+    public AppBar getAppbar() {
+        return appbar;
     }
 
     protected void onActivityResult(int requestCode, int responseCode, Intent intent) {
-        if (requestCode == RC_SIGN_IN && !mGoogleApiKey && mGoogleApiClient != null) {
-            new Thread(new Runnable() {
-                @Override
-                public void run() {
-                    mIntentInProgress = false;
-                    mGoogleApiKey = true;
-                    // !mGoogleApiClient.isConnecting
-                    if (mGoogleApiClient.isConnecting()) {
-                        mGoogleApiClient.connect();
-                    } else
-                        mGoogleApiClient.disconnect();
-
-                }
-            }).run();
-        } else if (requestCode == image_selector_request_code) {
-            if (sharedPref != null && intent != null && intent.getData() != null) {
-                if (SDK_INT >= 19)
+        if (requestCode == image_selector_request_code) {
+            if (getPrefs() != null && intent != null && intent.getData() != null) {
+                if (SDK_INT >= Build.VERSION_CODES.KITKAT)
                     getContentResolver().takePersistableUriPermission(intent.getData(),
                             Intent.FLAG_GRANT_READ_URI_PERMISSION);
-                sharedPref.edit().putString("drawer_header_path", intent.getData().toString()).commit();
+                getPrefs().edit().putString("drawer_header_path", intent.getData().toString()).commit();
                 setDrawerHeaderBackground();
             }
         } else if (requestCode == 3) {
@@ -1837,7 +1557,7 @@ public class MainActivity extends BaseActivity implements
                 // Get Uri from Storage Access Framework.
                 treeUri = intent.getData();
                 // Persist URI - this is required for verification of writability.
-                if (treeUri != null) sharedPref.edit().putString("URI", treeUri.toString()).commit();
+                if (treeUri != null) getPrefs().edit().putString("URI", treeUri.toString()).commit();
             } else {
                 // If not confirmed SAF, or if still not writable, then revert settings.
                 /* DialogUtil.displayError(getActivity(), R.string.message_dialog_cannot_write_to_folder_saf, false, currentFolder);
@@ -1867,8 +1587,9 @@ public class MainActivity extends BaseActivity implements
                         oppathe = "";
                     }
                     for (int i = 0; i < oparrayListList.size(); i++) {
+                        ArrayList<HybridFileParcelable> sourceList = oparrayListList.get(i);
                         Intent intent1 = new Intent(con, CopyService.class);
-                        intent1.putExtra(CopyService.TAG_COPY_SOURCES, oparrayList.get(i));
+                        intent1.putExtra(CopyService.TAG_COPY_SOURCES, sourceList);
                         intent1.putExtra(CopyService.TAG_COPY_TARGET, oppatheList.get(i));
                         ServiceWatcherUtil.runService(this, intent1);
                     }
@@ -1884,22 +1605,22 @@ public class MainActivity extends BaseActivity implements
                         oppathe = "";
                     }
 
-                    new MoveFiles(oparrayListList, ((MainFragment) getFragment().getTab()),
-                            getFragment().getTab().getActivity(), OpenMode.FILE)
+                    new MoveFiles(oparrayListList, getCurrentMainFragment(),
+                            getCurrentMainFragment().getActivity(), OpenMode.FILE)
                             .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, oppatheList);
                     break;
                 case DataUtils.NEW_FOLDER://mkdir
-                    MainFragment ma1 = ((MainFragment) getFragment().getTab());
-                    mainActivityHelper.mkDir(RootHelper.generateBaseFile(new File(oppathe), true), ma1);
+                    mainActivityHelper.mkDir(RootHelper.generateBaseFile(new File(oppathe), true),
+                            getCurrentMainFragment());
                     break;
                 case DataUtils.RENAME:
-                    MainFragment ma2 = ((MainFragment) getFragment().getTab());
-                    mainActivityHelper.rename(ma2.openMode, (oppathe), (oppathe1), mainActivity, BaseActivity.rootMode);
-                    ma2.updateList();
+                    MainFragment ma = getCurrentMainFragment();
+                    mainActivityHelper.rename(ma.openMode, (oppathe),
+                            (oppathe1), mainActivity, ThemedActivity.rootMode);
+                    ma.updateList();
                     break;
                 case DataUtils.NEW_FILE:
-                    MainFragment ma3 = ((MainFragment) getFragment().getTab());
-                    mainActivityHelper.mkFile(new HFile(OpenMode.FILE, oppathe), ma3);
+                    mainActivityHelper.mkFile(new HybridFile(OpenMode.FILE, oppathe), getCurrentMainFragment());
 
                     break;
                 case DataUtils.EXTRACT:
@@ -1911,7 +1632,7 @@ public class MainActivity extends BaseActivity implements
             operation = -1;
         } else if (requestCode == REQUEST_CODE_SAF && responseCode == Activity.RESULT_OK) {
             // otg access
-            sharedPref.edit().putString(KEY_PREF_OTG, intent.getData().toString()).apply();
+            getPrefs().edit().putString(KEY_PREF_OTG, intent.getData().toString()).apply();
 
             if (!isDrawerLocked) mDrawerLayout.closeDrawer(mDrawerLinear);
             else onDrawerClosed();
@@ -1921,193 +1642,48 @@ public class MainActivity extends BaseActivity implements
         }
     }
 
-    public void bbar(final MainFragment mainFrag) {
-        final String path = mainFrag.getCurrentPath();
-        try {
-            buttons.removeAllViews();
-            buttons.setMinimumHeight(pathbar.getHeight());
-            Drawable arrow = getResources().getDrawable(R.drawable.abc_ic_ab_back_holo_dark);
-            Bundle bundle = utils.getPaths(path, this);
-            ArrayList<String> names = bundle.getStringArrayList("names");
-            ArrayList<String> rnames = bundle.getStringArrayList("names");
-            Collections.reverse(rnames);
-
-            ArrayList<String> paths = bundle.getStringArrayList("paths");
-            final ArrayList<String> rpaths = bundle.getStringArrayList("paths");
-            Collections.reverse(rpaths);
-
-            View view = new View(this);
-            LinearLayout.LayoutParams params1 = new LinearLayout.LayoutParams(
-                    toolbar.getContentInsetLeft(), LinearLayout.LayoutParams.WRAP_CONTENT);
-            view.setLayoutParams(params1);
-            buttons.addView(view);
-            for (int i = 0; i < names.size(); i++) {
-                final int k = i;
-                ImageView v = new ImageView(this);
-                v.setImageDrawable(arrow);
-                LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(
-                        LinearLayout.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
-                params.gravity = Gravity.CENTER_VERTICAL;
-                v.setLayoutParams(params);
-                final int index = i;
-                if (rpaths.get(i).equals("/")) {
-                    ImageButton ib = new ImageButton(this);
-                    ib.setImageDrawable(icons.getRootDrawable());
-                    ib.setBackgroundColor(Color.TRANSPARENT);
-                    ib.setOnClickListener(new View.OnClickListener() {
-
-                        public void onClick(View p1) {
-                            mainFrag.loadlist(("/"), false, mainFrag.openMode);
-                            timer.cancel();
-                            timer.start();
-                        }
-                    });
-                    ib.setLayoutParams(params);
-                    buttons.addView(ib);
-                    if (names.size() - i != 1)
-                        buttons.addView(v);
-                } else if (isStorage(rpaths.get(i))) {
-                    ImageButton ib = new ImageButton(this);
-                    ib.setImageDrawable(icons.getSdDrawable());
-                    ib.setBackgroundColor(Color.TRANSPARENT);
-                    ib.setOnClickListener(new View.OnClickListener() {
-
-                        public void onClick(View p1) {
-                            mainFrag.loadlist((rpaths.get(k)), false, mainFrag.openMode);
-                            timer.cancel();
-                            timer.start();
-                        }
-                    });
-                    ib.setLayoutParams(params);
-                    buttons.addView(ib);
-                    if (names.size() - i != 1)
-                        buttons.addView(v);
-                } else {
-                    Button b = new Button(this);
-                    b.setText(rnames.get(index));
-                    b.setTextColor(Utils.getColor(this, android.R.color.white));
-                    b.setTextSize(13);
-                    b.setLayoutParams(params);
-                    b.setBackgroundResource(0);
-                    b.setOnClickListener(new Button.OnClickListener() {
-
-                        public void onClick(View p1) {
-                            mainFrag.loadlist((rpaths.get(k)), false, mainFrag.openMode);
-                            mainFrag.loadlist((rpaths.get(k)), false, mainFrag.openMode);
-                            timer.cancel();
-                            timer.start();
-                        }
-                    });
-                    b.setOnLongClickListener(new View.OnLongClickListener() {
-                        @Override
-                        public boolean onLongClick(View view) {
-
-                            File file1 = new File(rpaths.get(index));
-                            copyToClipboard(MainActivity.this, file1.getPath());
-                            Toast.makeText(MainActivity.this, getResources().getString(R.string.pathcopied), Toast.LENGTH_SHORT).show();
-                            return false;
-                        }
-                    });
-
-                    buttons.addView(b);
-                    if (names.size() - i != 1)
-                        buttons.addView(v);
-                }
-            }
-
-            scroll.post(new Runnable() {
-                @Override
-                public void run() {
-                    sendScroll(scroll);
-                    sendScroll(scroll1);
-                }
-            });
-
-            if (buttons.getVisibility() == View.VISIBLE) {
-                timer.cancel();
-                timer.start();
-            }
-        } catch (Exception e) {
-            e.printStackTrace();
-            Log.d("BBar", "button view not available");
-        }
-    }
-
-    boolean isStorage(String path) {
-        for (String s : dataUtils.getStorages())
-            if (s.equals(path)) return true;
-        return false;
-    }
-
-    void sendScroll(final HorizontalScrollView scrollView) {
-        final Handler handler = new Handler();
-        new Thread(new Runnable() {
-            @Override
-            public void run() {
-                try {
-                    Thread.sleep(100);
-                } catch (InterruptedException e) {}
-                handler.post(new Runnable() {
-                    @Override
-                    public void run() {
-                        scrollView.fullScroll(View.FOCUS_RIGHT);
-                    }
-                });
-            }
-        }).start();
-    }
-
     void initialisePreferences() {
-        hidemode = sharedPref.getInt("hidemode", 0);
-        showHidden = sharedPref.getBoolean("showHidden", false);
-        useGridView = sharedPref.getBoolean("view", true);
-        currentTab = sharedPref.getInt(PreferenceUtils.KEY_CURRENT_TAB, PreferenceUtils.DEFAULT_CURRENT_TAB);
+        hidemode = getPrefs().getInt("hidemode", 0);
+        showHidden = getPrefs().getBoolean("showHidden", false);
+        useGridView = getPrefs().getBoolean("view", true);
+        currentTab = getPrefs().getInt(PreferenceUtils.KEY_CURRENT_TAB, PreferenceUtils.DEFAULT_CURRENT_TAB);
         skinStatusBar = (PreferenceUtils.getStatusColor(getColorPreference().getColorAsString(ColorUsage.getPrimary(MainActivity.currentTab))));
-        colourednavigation = sharedPref.getBoolean("colorednavigation", false);
+        colourednavigation = getPrefs().getBoolean("colorednavigation", false);
     }
 
     void initialiseViews() {
-        appBarLayout = (AppBarLayout) findViewById(R.id.lin);
+        appBarLayout = getAppbar().getAppbarLayout();
 
-        mScreenLayout = (CoordinatorLayout) findViewById(R.id.main_frame);
-        buttonBarFrame = (FrameLayout) findViewById(R.id.buttonbarframe);
+        mScreenLayout = findViewById(R.id.main_frame);
+        buttonBarFrame = findViewById(R.id.buttonbarframe);
 
         //buttonBarFrame.setBackgroundColor(Color.parseColor(currentTab==1 ? skinTwo : skin));
         drawerHeaderLayout = getLayoutInflater().inflate(R.layout.drawerheader, null);
         drawerHeaderParent = (RelativeLayout) drawerHeaderLayout.findViewById(R.id.drawer_header_parent);
         drawerHeaderView = drawerHeaderLayout.findViewById(R.id.drawer_header);
-        drawerHeaderView.setOnLongClickListener(new View.OnLongClickListener() {
-            @Override
-            public boolean onLongClick(View v) {
-                Intent intent;
-                if (SDK_INT < 19) {
-                    intent = new Intent();
-                    intent.setAction(Intent.ACTION_GET_CONTENT);
-                } else {
-                    intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);
+        drawerHeaderView.setOnLongClickListener(v -> {
+            Intent intent1;
+            if (SDK_INT < Build.VERSION_CODES.KITKAT) {
+                intent1 = new Intent();
+                intent1.setAction(Intent.ACTION_GET_CONTENT);
+            } else {
+                intent1 = new Intent(Intent.ACTION_OPEN_DOCUMENT);
 
-                }
-                intent.addCategory(Intent.CATEGORY_OPENABLE);
-                intent.setType("image/*");
-                startActivityForResult(intent, image_selector_request_code);
-                return false;
             }
+            intent1.addCategory(Intent.CATEGORY_OPENABLE);
+            intent1.setType("image/*");
+            startActivityForResult(intent1, image_selector_request_code);
+            return false;
         });
-        drawerProfilePic = (RoundedImageView) drawerHeaderLayout.findViewById(R.id.profile_pic);
-        mGoogleName = (TextView) drawerHeaderLayout.findViewById(R.id.account_header_drawer_name);
-        mGoogleId = (TextView) drawerHeaderLayout.findViewById(R.id.account_header_drawer_email);
-        toolbar = (Toolbar) findViewById(R.id.action_bar);
-        /* For SearchView, see onCreateOptionsMenu(Menu menu)*/
-        TOOLBAR_START_INSET = toolbar.getContentInsetStart();
-        setSupportActionBar(toolbar);
-        frameLayout = (FrameLayout) findViewById(R.id.content_frame);
+        setSupportActionBar(getAppbar().getToolbar());
+        frameLayout = findViewById(R.id.content_frame);
         indicator_layout = findViewById(R.id.indicator_layout);
-        mDrawerLinear = (ScrimInsetsRelativeLayout) findViewById(R.id.left_drawer);
+        mDrawerLinear = findViewById(R.id.left_drawer);
         if (getAppTheme().equals(AppTheme.DARK)) mDrawerLinear.setBackgroundColor(Utils.getColor(this, R.color.holo_dark_background));
         else mDrawerLinear.setBackgroundColor(Color.WHITE);
-        mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);
+        mDrawerLayout = findViewById(R.id.drawer_layout);
         //mDrawerLayout.setStatusBarBackgroundColor(Color.parseColor((currentTab==1 ? skinTwo : skin)));
-        mDrawerList = (ListView) findViewById(R.id.menu_drawer);
+        mDrawerList = findViewById(R.id.menu_drawer);
         drawerHeaderView.setBackgroundResource(R.drawable.amaze_header);
         //drawerHeaderParent.setBackgroundColor(Color.parseColor((currentTab==1 ? skinTwo : skin)));
         if (findViewById(R.id.tab_frame) != null) {
@@ -2128,21 +1704,12 @@ public class MainActivity extends BaseActivity implements
             fabBgView.setBackgroundResource(R.drawable.fab_shadow_dark);
         }
 
-        fabBgView.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                floatingActionButton.close(true);
-                if (isSearchViewEnabled) hideSearchView();
-            }
+        fabBgView.setOnClickListener(view -> {
+            floatingActionButton.close(true);
+            if (getAppbar().getSearchView().isEnabled()) getAppbar().getSearchView().hideSearchView();
         });
 
-        pathbar = (LinearLayout) findViewById(R.id.pathbar);
-        buttons = (LinearLayout) findViewById(R.id.buttons);
-        scroll = (HorizontalScrollView) findViewById(R.id.scroll);
-        scroll1 = (HorizontalScrollView) findViewById(R.id.scroll1);
-        scroll.setSmoothScrollingEnabled(true);
-        scroll1.setSmoothScrollingEnabled(true);
-        ImageView divider = (ImageView) findViewById(R.id.divider1);
+        ImageView divider = findViewById(R.id.divider1);
         if (getAppTheme().equals(AppTheme.LIGHT))
             divider.setImageResource(R.color.divider);
         else
@@ -2155,14 +1722,10 @@ public class MainActivity extends BaseActivity implements
             ((ImageView) settingsButton.findViewById(R.id.settingicon)).setImageResource(R.drawable.ic_settings_white_48dp);
             ((TextView) settingsButton.findViewById(R.id.settingtext)).setTextColor(Utils.getColor(this, android.R.color.white));
         }
-        settingsButton.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                Intent in = new Intent(MainActivity.this, PreferencesActivity.class);
-                startActivity(in);
-                finish();
-            }
-
+        settingsButton.setOnClickListener(v -> {
+            Intent in = new Intent(MainActivity.this, PreferencesActivity.class);
+            startActivity(in);
+            finish();
         });
         View appButton = findViewById(R.id.appbutton);
         if (getAppTheme().equals(AppTheme.DARK)) {
@@ -2170,18 +1733,15 @@ public class MainActivity extends BaseActivity implements
             ((ImageView) appButton.findViewById(R.id.appicon)).setImageResource(R.drawable.ic_doc_apk_white);
             ((TextView) appButton.findViewById(R.id.apptext)).setTextColor(Utils.getColor(this, android.R.color.white));
         }
-        appButton.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                android.support.v4.app.FragmentTransaction transaction2 = getSupportFragmentManager().beginTransaction();
-                transaction2.replace(R.id.content_frame, new AppsList());
-                findViewById(R.id.lin).animate().translationY(0).setInterpolator(new DecelerateInterpolator(2)).start();
-                pending_fragmentTransaction = transaction2;
-                if (!isDrawerLocked) mDrawerLayout.closeDrawer(mDrawerLinear);
-                else onDrawerClosed();
-                selectedStorage = SELECT_MINUS_2;
-                adapter.toggleChecked(false);
-            }
+        appButton.setOnClickListener(v -> {
+            FragmentTransaction transaction2 = getSupportFragmentManager().beginTransaction();
+            transaction2.replace(R.id.content_frame, new AppsListFragment());
+            appBarLayout.animate().translationY(0).setInterpolator(new DecelerateInterpolator(2)).start();
+            pending_fragmentTransaction = transaction2;
+            if (!isDrawerLocked) mDrawerLayout.closeDrawer(mDrawerLinear);
+            else onDrawerClosed();
+            selectedStorage = SELECT_MINUS_2;
+            adapter.toggleChecked(false);
         });
 
         View ftpButton = findViewById(R.id.ftpbutton);
@@ -2190,31 +1750,27 @@ public class MainActivity extends BaseActivity implements
             ((ImageView) ftpButton.findViewById(R.id.ftpicon)).setImageResource(R.drawable.ic_ftp_dark);
             ((TextView) ftpButton.findViewById(R.id.ftptext)).setTextColor(Utils.getColor(this, android.R.color.white));
         }
-        ftpButton.setOnClickListener(new View.OnClickListener() {
-
-            @Override
-            public void onClick(View v) {
-                android.support.v4.app.FragmentTransaction transaction2 = getSupportFragmentManager().beginTransaction();
-                transaction2.replace(R.id.content_frame, new FTPServerFragment());
-                findViewById(R.id.lin).animate().translationY(0).setInterpolator(new DecelerateInterpolator(2)).start();
-                pending_fragmentTransaction = transaction2;
-                if (!isDrawerLocked) mDrawerLayout.closeDrawer(mDrawerLinear);
-                else onDrawerClosed();
-                selectedStorage = SELECT_MINUS_2;
-                adapter.toggleChecked(false);
-            }
+        ftpButton.setOnClickListener(v -> {
+            FragmentTransaction transaction2 = getSupportFragmentManager().beginTransaction();
+            transaction2.replace(R.id.content_frame, new FTPServerFragment());
+            appBarLayout.animate().translationY(0).setInterpolator(new DecelerateInterpolator(2)).start();
+            pending_fragmentTransaction = transaction2;
+            if (!isDrawerLocked) mDrawerLayout.closeDrawer(mDrawerLinear);
+            else onDrawerClosed();
+            selectedStorage = SELECT_MINUS_2;
+            adapter.toggleChecked(false);
         });
         //getSupportActionBar().setBackgroundDrawable(new ColorDrawable(Color.parseColor((currentTab==1 ? skinTwo : skin))));
 
         // status bar0
-        if (SDK_INT == 20 || SDK_INT == 19) {
+        if (SDK_INT == Build.VERSION_CODES.KITKAT_WATCH || SDK_INT == Build.VERSION_CODES.KITKAT) {
             SystemBarTintManager tintManager = new SystemBarTintManager(this);
             tintManager.setStatusBarTintEnabled(true);
             //tintManager.setStatusBarTintColor(Color.parseColor((currentTab==1 ? skinTwo : skin)));
             FrameLayout.MarginLayoutParams p = (ViewGroup.MarginLayoutParams) findViewById(R.id.drawer_layout).getLayoutParams();
             SystemBarTintManager.SystemBarConfig config = tintManager.getConfig();
             if (!isDrawerLocked) p.setMargins(0, config.getStatusBarHeight(), 0, 0);
-        } else if (SDK_INT >= 21) {
+        } else if (SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
             Window window = getWindow();
             window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
             //window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
@@ -2224,38 +1780,6 @@ public class MainActivity extends BaseActivity implements
             if (colourednavigation)
                 window.setNavigationBarColor(skinStatusBar);
         }
-
-        searchViewLayout = (RelativeLayout) findViewById(R.id.search_view);
-        searchViewEditText = (AppCompatEditText) findViewById(R.id.search_edit_text);
-        ImageView clear = (ImageView) findViewById(R.id.search_close_btn);
-        clear.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                searchViewEditText.setText("");
-            }
-        });
-        findViewById(R.id.img_view_back).setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                hideSearchView();
-            }
-        });
-        searchViewEditText.setOnKeyListener(new TextView.OnKeyListener() {
-            @Override
-            public boolean onKey(View v, int keyCode, KeyEvent event) {
-                // If the event is a key-down event on the "enter" button
-                if ((event.getAction() == KeyEvent.ACTION_DOWN)) {
-                    // Perform action on key press
-                    mainActivityHelper.search(searchViewEditText.getText().toString());
-                    hideSearchView();
-                    return true;
-                }
-                return false;
-            }
-        });
-
-        //    searchViewEditText.setTextColor(Utils.getColor(this, android.R.color.black));
-        //     searchViewEditText.setHintTextColor(Color.parseColor(BaseActivity.accentSkin));
     }
 
     /**
@@ -2279,7 +1803,7 @@ public class MainActivity extends BaseActivity implements
             if (colourednavigation)
                 mainActivity.getWindow().setNavigationBarColor(PreferenceUtils
                         .getStatusColor(colorDrawable.getColor()));
-        } else if (SDK_INT == 20 || SDK_INT == 19) {
+        } else if (SDK_INT == Build.VERSION_CODES.KITKAT_WATCH || SDK_INT == Build.VERSION_CODES.KITKAT) {
 
             // for kitkat devices, the status bar color
             SystemBarTintManager tintManager = new SystemBarTintManager(this);
@@ -2289,325 +1813,41 @@ public class MainActivity extends BaseActivity implements
     }
 
     void initialiseFab() {
-        String folder_skin = getColorPreference().getColorAsString(ColorUsage.ICON_SKIN);
-        int fabSkinPressed = PreferenceUtils.getStatusColor(BaseActivity.accentSkin);
-        int folderskin = Color.parseColor(folder_skin);
-        int fabskinpressed = (PreferenceUtils.getStatusColor(folder_skin));
-        floatingActionButton = (FloatingActionMenu) findViewById(R.id.menu);
-        floatingActionButton.setMenuButtonColorNormal(Color.parseColor(BaseActivity.accentSkin));
-        floatingActionButton.setMenuButtonColorPressed(fabSkinPressed);
-
-        floatingActionButton.setOnMenuToggleListener(new FloatingActionMenu.OnMenuToggleListener() {
-            @Override
-            public void onMenuToggle(boolean b) {
-                if (b) utils.revealShow(fabBgView, true);
-                else utils.revealShow(fabBgView, false);
-            }
-        });
+        int colorAccent = getColorPreference().getColor(ColorUsage.ACCENT);
+        int iconSkin = getColorPreference().getColor(ColorUsage.ICON_SKIN);
 
-        FloatingActionButton fabNewFolder = (FloatingActionButton) findViewById(R.id.menu_new_folder);
-        fabNewFolder.setColorNormal(folderskin);
-        fabNewFolder.setColorPressed(fabskinpressed);
-        fabNewFolder.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
+        floatingActionButton = findViewById(R.id.menu);
+        floatingActionButton.setMenuButtonColorNormal(colorAccent);
+        floatingActionButton.setMenuButtonColorPressed(colorAccent);
 
-                mainActivityHelper.add(MainActivityHelper.NEW_FOLDER);
-                //utils.revealShow(fabBgView, false);
-                floatingActionButton.close(true);
-            }
-        });
-        FloatingActionButton fabNewFile = (FloatingActionButton) findViewById(R.id.menu_new_file);
-        fabNewFile.setColorNormal(folderskin);
-        fabNewFile.setColorPressed(fabskinpressed);
-        fabNewFile.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                mainActivityHelper.add(MainActivityHelper.NEW_FILE);
-                //utils.revealShow(fabBgView, false);
-                floatingActionButton.close(true);
-            }
+        floatingActionButton.setOnMenuToggleListener(b -> {
+            if (b) FileUtils.revealShow(fabBgView, true);
+            else FileUtils.revealShow(fabBgView, false);
         });
-        final FloatingActionButton floatingActionButton3 = (FloatingActionButton) findViewById(R.id.menu_new_cloud);
-        floatingActionButton3.setColorNormal(folderskin);
-        floatingActionButton3.setColorPressed(fabskinpressed);
-        floatingActionButton3.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                mainActivityHelper.add(MainActivityHelper.NEW_CLOUD);
-                //utils.revealShow(fabBgView, false);
-                floatingActionButton.close(true);
-            }
-        });
-    }
 
-    public void updatePath(@NonNull final String news, boolean results, OpenMode openmode,
-                           int folder_count, int file_count) {
-
-        if (news.length() == 0) return;
-
-        switch (openmode) {
-            case SFTP:
-                newPath = mainActivityHelper.parseSftpPath(news);
-                break;
-            case SMB:
-                newPath = mainActivityHelper.parseSmbPath(news);
-                break;
-            case OTG:
-                newPath = mainActivityHelper.parseOTGPath(news);
-                break;
-            case CUSTOM:
-                newPath = mainActivityHelper.getIntegralNames(news);
-                break;
-            case DROPBOX:
-            case BOX:
-            case ONEDRIVE:
-            case GDRIVE:
-                newPath = mainActivityHelper.parseCloudPath(openmode, news);
-                break;
-            default:
-                newPath = news;
-        }
-
-        final TextView bapath = (TextView) pathbar.findViewById(R.id.fullpath);
-        final TextView animPath = (TextView) pathbar.findViewById(R.id.fullpath_anim);
-        TextView textView = (TextView) pathbar.findViewById(R.id.pathname);
-        if (!results) {
-            textView.setText(folder_count + " " + getResources().getString(R.string.folders) + "" +
-                    " " + file_count + " " + getResources().getString(R.string.files));
-        } else {
-            bapath.setText(R.string.searchresults);
-            textView.setText(R.string.empty);
-            return;
-        }
-        final String oldPath = bapath.getText().toString();
-        if (oldPath.equals(newPath)) return;
-
-        // implement animation while setting text
-        newPathBuilder = new StringBuffer().append(newPath);
-        oldPathBuilder = new StringBuffer().append(oldPath);
-
-        final Animation slideIn = AnimationUtils.loadAnimation(this, R.anim.slide_in);
-        Animation slideOut = AnimationUtils.loadAnimation(this, R.anim.slide_out);
-
-        if (newPath.length() > oldPath.length() &&
-                newPathBuilder.delete(oldPath.length(), newPath.length()).toString().equals(oldPath) &&
-                oldPath.length() != 0) {
-
-            // navigate forward
-            newPathBuilder.delete(0, newPathBuilder.length());
-            newPathBuilder.append(newPath);
-            newPathBuilder.delete(0, oldPath.length());
-            animPath.setAnimation(slideIn);
-            animPath.animate().setListener(new AnimatorListenerAdapter() {
-                @Override
-                public void onAnimationEnd(Animator animation) {
-                    super.onAnimationEnd(animation);
-                    new Handler().postDelayed(new Runnable() {
-                        @Override
-                        public void run() {
-
-                            animPath.setVisibility(View.GONE);
-                            bapath.setText(newPath);
-                        }
-                    }, PATH_ANIM_END_DELAY);
-                }
-
-                @Override
-                public void onAnimationStart(Animator animation) {
-                    super.onAnimationStart(animation);
-                    animPath.setVisibility(View.VISIBLE);
-                    animPath.setText(newPathBuilder.toString());
-                    //bapath.setText(oldPath);
-
-                    scroll.post(new Runnable() {
-                        @Override
-                        public void run() {
-                            scroll1.fullScroll(View.FOCUS_RIGHT);
-                        }
-                    });
-                }
-
-                @Override
-                public void onAnimationCancel(Animator animation) {
-                    super.onAnimationCancel(animation);
-                    //onAnimationEnd(animation);
-                }
-            }).setStartDelay(PATH_ANIM_START_DELAY).start();
-        } else if (newPath.length() < oldPath.length() &&
-                oldPathBuilder.delete(newPath.length(), oldPath.length()).toString().equals(newPath)) {
-
-            // navigate backwards
-            oldPathBuilder.delete(0, oldPathBuilder.length());
-            oldPathBuilder.append(oldPath);
-            oldPathBuilder.delete(0, newPath.length());
-            animPath.setAnimation(slideOut);
-            animPath.animate().setListener(new AnimatorListenerAdapter() {
-                @Override
-                public void onAnimationEnd(Animator animation) {
-                    super.onAnimationEnd(animation);
-                    animPath.setVisibility(View.GONE);
-                    bapath.setText(newPath);
-
-                    scroll.post(new Runnable() {
-                        @Override
-                        public void run() {
-                            scroll1.fullScroll(View.FOCUS_RIGHT);
-                        }
-                    });
-                }
-
-                @Override
-                public void onAnimationStart(Animator animation) {
-                    super.onAnimationStart(animation);
-                    animPath.setVisibility(View.VISIBLE);
-                    animPath.setText(oldPathBuilder.toString());
-                    bapath.setText(newPath);
-
-                    scroll.post(new Runnable() {
-                        @Override
-                        public void run() {
-                            scroll1.fullScroll(View.FOCUS_LEFT);
-                        }
-                    });
-                }
-            }).setStartDelay(PATH_ANIM_START_DELAY).start();
-        } else if (oldPath.isEmpty()) {
-
-            // case when app starts
-            animPath.setAnimation(slideIn);
-            animPath.setText(newPath);
-            animPath.animate().setListener(new AnimatorListenerAdapter() {
-                @Override
-                public void onAnimationStart(Animator animation) {
-                    super.onAnimationStart(animation);
-                    animPath.setVisibility(View.VISIBLE);
-                    bapath.setText("");
-                    scroll.post(new Runnable() {
-                        @Override
-                        public void run() {
-                            scroll1.fullScroll(View.FOCUS_RIGHT);
-                        }
-                    });
-                }
-
-                @Override
-                public void onAnimationEnd(Animator animation) {
-                    super.onAnimationEnd(animation);
-                    new Handler().postDelayed(new Runnable() {
-                        @Override
-                        public void run() {
-                            animPath.setVisibility(View.GONE);
-                            bapath.setText(newPath);
-                        }
-                    }, PATH_ANIM_END_DELAY);
-                }
-
-                @Override
-                public void onAnimationCancel(Animator animation) {
-                    super.onAnimationCancel(animation);
-                    //onAnimationEnd(animation);
-                }
-            }).setStartDelay(PATH_ANIM_START_DELAY).start();
-        } else {
-            // completely different path
-            // first slide out of old path followed by slide in of new path
-            animPath.setAnimation(slideOut);
-            animPath.animate().setListener(new AnimatorListenerAdapter() {
-                @Override
-                public void onAnimationStart(Animator animator) {
-                    super.onAnimationStart(animator);
-                    animPath.setVisibility(View.VISIBLE);
-                    animPath.setText(oldPath);
-                    bapath.setText("");
-
-                    scroll.post(new Runnable() {
-                        @Override
-                        public void run() {
-                            scroll1.fullScroll(View.FOCUS_LEFT);
-                        }
-                    });
-                }
-
-                @Override
-                public void onAnimationEnd(Animator animator) {
-                    super.onAnimationEnd(animator);
-
-                    //animPath.setVisibility(View.GONE);
-                    animPath.setText(newPath);
-                    bapath.setText("");
-                    animPath.setAnimation(slideIn);
-
-                    animPath.animate().setListener(new AnimatorListenerAdapter() {
-                        @Override
-                        public void onAnimationEnd(Animator animation) {
-                            super.onAnimationEnd(animation);
-                            new Handler().postDelayed(new Runnable() {
-                                @Override
-                                public void run() {
-                                    animPath.setVisibility(View.GONE);
-                                    bapath.setText(newPath);
-                                }
-                            }, PATH_ANIM_END_DELAY);
-                        }
-
-                        @Override
-                        public void onAnimationStart(Animator animation) {
-                            super.onAnimationStart(animation);
-                            // we should not be having anything here in path bar
-                            animPath.setVisibility(View.VISIBLE);
-                            bapath.setText("");
-                            scroll.post(new Runnable() {
-                                @Override
-                                public void run() {
-                                    scroll1.fullScroll(View.FOCUS_RIGHT);
-                                }
-                            });
-                        }
-                    }).start();
-                }
-
-                @Override
-                public void onAnimationCancel(Animator animation) {
-                    super.onAnimationCancel(animation);
-                    //onAnimationEnd(animation);
-                }
-            }).setStartDelay(PATH_ANIM_START_DELAY).start();
-        }
-    }
-
-    public int dpToPx(double dp) {
-        DisplayMetrics displayMetrics = getResources().getDisplayMetrics();
-        return Math.round(Math.round(dp * (displayMetrics.xdpi / DisplayMetrics.DENSITY_DEFAULT)));
-    }
-
-    public void initiatebbar() {
-        final View pathbar = findViewById(R.id.pathbar);
-        TextView textView = (TextView) findViewById(R.id.fullpath);
-
-        pathbar.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                MainFragment m = ((MainFragment) getFragment().getTab());
-                if (m.openMode == OpenMode.FILE) {
-                    bbar(m);
-                    utils.crossfade(buttons, pathbar);
-                    timer.cancel();
-                    timer.start();
-                }
-            }
+        FloatingActionButton fabNewFolder = findViewById(R.id.menu_new_folder);
+        fabNewFolder.setColorNormal(iconSkin);
+        fabNewFolder.setColorPressed(iconSkin);
+        fabNewFolder.setOnClickListener(view -> {
+            mainActivityHelper.add(MainActivityHelper.NEW_FOLDER);
+            //utils.revealShow(fabBgView, false);
+            floatingActionButton.close(true);
         });
-        textView.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                MainFragment m = ((MainFragment) getFragment().getTab());
-                if (m.openMode == OpenMode.FILE) {
-                    bbar(m);
-                    utils.crossfade(buttons, pathbar);
-                    timer.cancel();
-                    timer.start();
-                }
-            }
+        FloatingActionButton fabNewFile = findViewById(R.id.menu_new_file);
+        fabNewFile.setColorNormal(iconSkin);
+        fabNewFile.setColorPressed(iconSkin);
+        fabNewFile.setOnClickListener(view -> {
+            mainActivityHelper.add(MainActivityHelper.NEW_FILE);
+            //utils.revealShow(fabBgView, false);
+            floatingActionButton.close(true);
+        });
+        final FloatingActionButton floatingActionButton3 = findViewById(R.id.menu_new_cloud);
+        floatingActionButton3.setColorNormal(iconSkin);
+        floatingActionButton3.setColorPressed(iconSkin);
+        floatingActionButton3.setOnClickListener(view -> {
+            mainActivityHelper.add(MainActivityHelper.NEW_CLOUD);
+            //utils.revealShow(fabBgView, false);
+            floatingActionButton.close(true);
         });
     }
 
@@ -2637,7 +1877,7 @@ public class MainActivity extends BaseActivity implements
 
     public void renameBookmark(final String title, final String path) {
         if (dataUtils.containsBooks(new String[]{title, path}) != -1) {
-            RenameBookmark renameBookmark = RenameBookmark.getInstance(title, path, BaseActivity.accentSkin);
+            RenameBookmark renameBookmark = RenameBookmark.getInstance(title, path, getColorPreference().getColor(ColorUsage.ACCENT));
             if (renameBookmark != null)
                 renameBookmark.show(getFragmentManager(), "renamedialog");
         }
@@ -2650,30 +1890,34 @@ public class MainActivity extends BaseActivity implements
         }
 
         if (pendingPath != null) {
-            try {
-                HFile hFile = new HFile(OpenMode.UNKNOWN, pendingPath);
-                hFile.generateMode(this);
-                if (hFile.isSimpleFile()) {
-                    utils.openFile(new File(pendingPath), mainActivity);
-                    pendingPath = null;
-                    return;
-                }
-                TabFragment m = getFragment();
-                if (m == null) {
-                    goToMain(pendingPath);
-                    return;
-                }
-                MainFragment mainFrag = ((MainFragment) m.getTab());
-                if (mainFrag != null) mainFrag.loadlist(pendingPath, false, OpenMode.UNKNOWN);
-            } catch (ClassCastException e) {
-                selectedStorage = NO_VALUE;
-                goToMain("");
+            HybridFile hFile = new HybridFile(OpenMode.UNKNOWN, pendingPath);
+            hFile.generateMode(this);
+            if (hFile.isSimpleFile()) {
+                FileUtils.openFile(new File(pendingPath), mainActivity, getPrefs());
+                pendingPath = null;
+                return;
+            }
+
+            MainFragment mainFrag = getCurrentMainFragment();
+            if (mainFrag != null) {
+                mainFrag.loadlist(pendingPath, false, OpenMode.UNKNOWN);
+            } else {
+                goToMain(pendingPath);
+                return;
             }
             pendingPath = null;
         }
         supportInvalidateOptionsMenu();
     }
 
+    public PasteHelper getPaste() {
+        return pasteHelper;
+    }
+
+    public void setPaste(PasteHelper p) {
+        pasteHelper = p;
+        supportInvalidateOptionsMenu();
+    }
 
     @Override
     public void onNewIntent(Intent i) {
@@ -2682,14 +1926,13 @@ public class MainActivity extends BaseActivity implements
 
         if (path != null) {
             if (new File(path).isDirectory()) {
-                Fragment f = getDFragment();
-                if ((f.getClass().getName().contains("TabFragment"))) {
-                    MainFragment m = ((MainFragment) getFragment().getTab());
-                    m.loadlist(path, false, OpenMode.FILE);
+                MainFragment ma = getCurrentMainFragment();
+                if (ma != null) {
+                    ma.loadlist(path, false, OpenMode.FILE);
                 } else goToMain(path);
-            } else utils.openFile(new File(path), mainActivity);
+            } else FileUtils.openFile(new File(path), mainActivity, getPrefs());
         } else if (i.getStringArrayListExtra(TAG_INTENT_FILTER_FAILED_OPS) != null) {
-            ArrayList<BaseFile> failedOps = i.getParcelableArrayListExtra(TAG_INTENT_FILTER_FAILED_OPS);
+            ArrayList<HybridFileParcelable> failedOps = i.getParcelableArrayListExtra(TAG_INTENT_FILTER_FAILED_OPS);
             if (failedOps != null) {
                 mainActivityHelper.showFailedOperationDialog(failedOps, i.getBooleanExtra("move", false), this);
             }
@@ -2700,7 +1943,7 @@ public class MainActivity extends BaseActivity implements
 
         } else if ((openProcesses = i.getBooleanExtra(KEY_INTENT_PROCESS_VIEWER, false))) {
             FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
-            transaction.replace(R.id.content_frame, new ProcessViewer(), KEY_INTENT_PROCESS_VIEWER);
+            transaction.replace(R.id.content_frame, new ProcessViewerFragment(), KEY_INTENT_PROCESS_VIEWER);
             //   transaction.addToBackStack(null);
             selectedStorage = SELECT_102;
             openProcesses = false;
@@ -2727,12 +1970,12 @@ public class MainActivity extends BaseActivity implements
 
             if (SDK_INT >= Build.VERSION_CODES.KITKAT) {
                 if (intent.getAction().equals(UsbManager.ACTION_USB_DEVICE_ATTACHED)) {
-                    if (sharedPref.getString(KEY_PREF_OTG, null) == null) {
-                        sharedPref.edit().putString(KEY_PREF_OTG, VALUE_PREF_OTG_NULL).apply();
+                    if (getPrefs().getString(KEY_PREF_OTG, null) == null) {
+                        getPrefs().edit().putString(KEY_PREF_OTG, VALUE_PREF_OTG_NULL).apply();
                         refreshDrawer();
                     }
                 } else if (intent.getAction().equals(UsbManager.ACTION_USB_DEVICE_DETACHED)) {
-                    sharedPref.edit().putString(KEY_PREF_OTG, null).apply();
+                    getPrefs().edit().putString(KEY_PREF_OTG, null).apply();
                     refreshDrawer();
                 }
             }
@@ -2740,36 +1983,31 @@ public class MainActivity extends BaseActivity implements
     }
 
     void setDrawerHeaderBackground() {
-        new Thread(new Runnable() {
-            public void run() {
-                if (sharedPref.getBoolean("plus_pic", false)) return;
-                String path = sharedPref.getString("drawer_header_path", null);
-                if (path == null) return;
-                try {
-                    final ImageView headerImageView = new ImageView(MainActivity.this);
-                    headerImageView.setImageDrawable(drawerHeaderParent.getBackground());
-                    mImageLoader.get(path, new ImageLoader.ImageListener() {
-                        @Override
-                        public void onResponse(ImageLoader.ImageContainer response, boolean isImmediate) {
-                            headerImageView.setImageBitmap(response.getBitmap());
-                            drawerHeaderView.setBackgroundResource(R.drawable.amaze_header_2);
-                        }
-
-                        @Override
-                        public void onErrorResponse(VolleyError error) {}
-                    });
-                } catch (Exception e) {
-                    e.printStackTrace();
+        String path1 = getPrefs().getString("drawer_header_path", null);
+        if (path1 == null) return;
+        try {
+            final ImageView headerImageView = new ImageView(MainActivity.this);
+            headerImageView.setImageDrawable(drawerHeaderParent.getBackground());
+            mImageLoader.get(path1, new ImageLoader.ImageListener() {
+                @Override
+                public void onResponse(ImageLoader.ImageContainer response, boolean isImmediate) {
+                    headerImageView.setImageBitmap(response.getBitmap());
+                    drawerHeaderView.setBackgroundResource(R.drawable.amaze_header_2);
                 }
-            }
-        }).run();
+
+                @Override
+                public void onErrorResponse(VolleyError error) {}
+            });
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
     }
 
     private BroadcastReceiver receiver2 = new BroadcastReceiver() {
         @Override
         public void onReceive(Context context, Intent i) {
             if (i.getStringArrayListExtra(TAG_INTENT_FILTER_FAILED_OPS) != null) {
-                ArrayList<BaseFile> failedOps = i.getParcelableArrayListExtra(TAG_INTENT_FILTER_FAILED_OPS);
+                ArrayList<HybridFileParcelable> failedOps = i.getParcelableArrayListExtra(TAG_INTENT_FILTER_FAILED_OPS);
                 if (failedOps != null) {
                     mainActivityHelper.showFailedOperationDialog(failedOps, i.getBooleanExtra("move", false), mainActivity);
                 }
@@ -2784,8 +2022,8 @@ public class MainActivity extends BaseActivity implements
         if (requestCode == 77) {
             if (grantResults.length == 1 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                 refreshDrawer();
-                TabFragment tabFragment = getFragment();
-                boolean b = sharedPref.getBoolean("needtosethome", true);
+                TabFragment tabFragment = getTabFragment();
+                boolean b = getPrefs().getBoolean("needtosethome", true);
                 //reset home and current paths according to new storages
                 if (b) {
                     tabHandler.clear();
@@ -2799,21 +2037,21 @@ public class MainActivity extends BaseActivity implements
                     } else
                         tabHandler.addTab(new Tab(2, "", ((EntryItem) dataUtils.getList().get(1)).getPath(), "/"));
                     if (tabFragment != null) {
-                        Fragment main = tabFragment.getTab(0);
+                        Fragment main = tabFragment.getFragmentAtIndex(0);
                         if (main != null)
                             ((MainFragment) main).updateTabWithDb(tabHandler.findTab(1));
-                        Fragment main1 = tabFragment.getTab(1);
+                        Fragment main1 = tabFragment.getFragmentAtIndex(1);
                         if (main1 != null)
                             ((MainFragment) main1).updateTabWithDb(tabHandler.findTab(2));
                     }
-                    sharedPref.edit().putBoolean("needtosethome", false).commit();
+                    getPrefs().edit().putBoolean("needtosethome", false).commit();
                 } else {
                     //just refresh list
                     if (tabFragment != null) {
-                        Fragment main = tabFragment.getTab(0);
+                        Fragment main = tabFragment.getFragmentAtIndex(0);
                         if (main != null)
                             ((MainFragment) main).updateList();
-                        Fragment main1 = tabFragment.getTab(1);
+                        Fragment main1 = tabFragment.getFragmentAtIndex(1);
                         if (main1 != null)
                             ((MainFragment) main1).updateList();
                     }
@@ -2848,7 +2086,6 @@ public class MainActivity extends BaseActivity implements
         }
         SftpConnectDialog sftpConnectDialog = new SftpConnectDialog();
         Uri uri = Uri.parse(path);
-//        Log.d("DEBUG.showSftpDialog", uri.getUserInfo() + ", " + uri.getHost() + ", " + uri.getPort());
         String userinfo = uri.getUserInfo();
         Bundle bundle = new Bundle();
         bundle.putString("name", name);
@@ -2870,6 +2107,18 @@ public class MainActivity extends BaseActivity implements
         sftpConnectDialog.show(getFragmentManager(), "sftpdialog");
     }
 
+    /**
+     * Shows a view that goes from white at it's lowest part to transparent a the top.
+     * It covers the fragment.
+     */
+    public void showSmokeScreen() {
+        FileUtils.revealShow(fabBgView, true);
+    }
+
+    public void hideSmokeScreen() {
+        FileUtils.revealShow(fabBgView, false);
+    }
+
     @Override
     public void addConnection(boolean edit, final String name, final String path, final String encryptedPath,
                               final String oldname, final String oldPath) {
@@ -2880,21 +2129,12 @@ public class MainActivity extends BaseActivity implements
                 dataUtils.addServer(s);
                 refreshDrawer();
 
-                AppConfig.runInBackground(new Runnable() {
-                    @Override
-                    public void run() {
-                        utilsHandler.addSmb(name, encryptedPath);
-                    }
+                AppConfig.runInBackground(() -> {
+                    utilsHandler.addSmb(name, encryptedPath);
                 });
                 //grid.addPath(name, encryptedPath, DataUtils.SMB, 1);
-                TabFragment fragment = getFragment();
-                if (fragment != null) {
-                    Fragment fragment1 = fragment.getTab();
-                    if (fragment1 != null) {
-                        final MainFragment ma = (MainFragment) fragment1;
-                        ma.loadlist(path, false, OpenMode.UNKNOWN);
-                    }
-                }
+                MainFragment ma = getCurrentMainFragment();
+                if (ma != null) getCurrentMainFragment().loadlist(path, false, OpenMode.UNKNOWN);
             } else {
                 Snackbar.make(frameLayout, getResources().getString(R.string.connection_exists), Snackbar.LENGTH_SHORT).show();
             }
@@ -2903,11 +2143,8 @@ public class MainActivity extends BaseActivity implements
             if (i != -1) {
                 dataUtils.removeServer(i);
 
-                AppConfig.runInBackground(new Runnable() {
-                    @Override
-                    public void run() {
-                        utilsHandler.renameSMB(oldname, oldPath, name, path);
-                    }
+                AppConfig.runInBackground(() -> {
+                    utilsHandler.renameSMB(oldname, oldPath, name, path);
                 });
                 //mainActivity.grid.removePath(oldname, oldPath, DataUtils.SMB);
             }
@@ -2925,11 +2162,8 @@ public class MainActivity extends BaseActivity implements
         if (i != -1) {
             dataUtils.removeServer(i);
 
-            AppConfig.runInBackground(new Runnable() {
-                @Override
-                public void run() {
-                    utilsHandler.removeSmbPath(name, path);
-                }
+            AppConfig.runInBackground(() -> {
+                utilsHandler.removeSmbPath(name, path);
             });
             //grid.removePath(name, path, DataUtils.SMB);
             refreshDrawer();
@@ -2997,14 +2231,13 @@ public class MainActivity extends BaseActivity implements
     }
 
     @Override
-    public void onProgressUpdate(BaseFile val , String query) {
+    public void onProgressUpdate(HybridFileParcelable val , String query) {
         mainFragment.addSearchResult(val,query);
     }
 
     @Override
     public void onCancelled() {
-        mainFragment.createViews(mainFragment.getLayoutElements(), false, mainFragment.getCurrentPath(),
-                mainFragment.openMode, false, !mainFragment.IS_LIST);
+        mainFragment.reloadListElements(false, false, !mainFragment.IS_LIST);
         mainFragment.mSwipeRefreshLayout.setRefreshing(false);
     }
 
@@ -3044,13 +2277,7 @@ public class MainActivity extends BaseActivity implements
         cloudHandler.clear(service);
         dataUtils.removeAccount(service);
 
-        runOnUiThread(new Runnable() {
-            @Override
-            public void run() {
-
-                refreshDrawer();
-            }
-        });
+        runOnUiThread(this::refreshDrawer);
     }
 
     @Override
