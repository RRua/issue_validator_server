Issue;Category;Android-Specific;Chimera;Adoctor;DAAP;Lint;PMD;Ecoandroid;Leafactor;Paprika;Droidlens;xAL;Detectable in Kotlin;Explanation;Sample;Expected fix;File Extensions;Severity;Example_1;Example_2;Possible Void;Plausible Occurance Scenario;;;;;;;;;;;;
SlowForLoop;Runtime;Yes;;✅;✅;;;;;;;;;The standard version of the for loop is slower than the for-each loop. Therefore, Android developers should always use an enhanced version of the loop to improve the efﬁciency of the app.;;Replace standard for loops with enhanced for-each loops whenever possible. This improves performance and efficiency by avoiding unnecessary index calculations and direct array manipulations.;*.java, *.kt;Warning;SlowForLoop1.txt;SlowForLoop2.txt;;A developer is processing a collection of user notifications in an Android app. The task involves iterating through an ArrayList of notification objects to filter out expired ones before displaying them to the user. The developer needs to access each element sequentially to check timestamps and update the UI accordingly;;;;adoctor;uses org.eclipse.jdt ast parser, does not supports kotlin;;;;;;;
DrawAllocation;Runtime;Yes;;;;✅;;;✅;✅;✅;;✅;You should avoid allocating objects during a drawing or layout operation. These are called frequently, so a smooth UI can be interrupted by garbage collection pauses caused by the object allocations. The way this is generally handled is to allocate the needed objects up front and to reuse them for each drawing operation. Some methods allocate memory on your behalf (such as Bitmap.create), and these should be handled in the same way.;https://googlesamples.github.io/android-custom-lint-rules/checks/DrawAllocation.md.html;Avoid allocating new objects during drawing or layout operations (e.g onDraw methods). Instead, preallocate objects before drawing and reuse them. Methods like Bitmap.create() should also follow this approach to prevent frequent garbage collection and UI lag. Examples of such methods: android.view.View, android.view.ViewGroup.dispatchDraw, android.graphics.drawable.Drawable.draw, android.view.View.invalidate, android.view.View.postInvalidate, android.view.View.onDrawForeground, android.view.View.onMeasure, android.view.ViewGroup.onLayout, android.view.View.layout, android.view.View.onSizeChanged, ;*.java, *.kt;Warning;DrawAllocation1.txt;DrawAllocation2.txt;;A developer is implementing a custom view that displays real-time data visualization. The onDraw() method needs to render multiple shapes and paths based on incoming sensor data. The rendering involves creating Paint objects, Rect objects, and other drawing primitives to represent the visualization elements;;;;daap;uses com.github.javaparser.ast, does not support kotlin;;;;;;;
Recycle;Memory;Yes;;;;✅;;;✅;;;;✅;Many resources, such as TypedArrays, VelocityTrackers, etc., should be recycled (with a recycle() call) after use. This lint check looks for missing recycle() calls.;https://googlesamples.github.io/android-custom-lint-rules/checks/Recycle.md.html;Always call .recycle() on resources such as TypedArray, VelocityTracker, and others after use. This prevents memory leaks and ensures efficient resource management.;*.java, *.kt;Warning;Recycle1.txt;Recycle2.txt;;A developer is implementing a custom theme for UI components using TypedArray. The task involves reading custom attributes from XML styles, applying them to various views in a layout, and then handling the TypedArray resource after extracting all the needed values;;;;chimera; com.android.tools.lint.detector.api.Detector.JavaPsiScanner does not support kotlin, but newer versions of Kotlin UAST support;;;;;;;
WakeLock;Energy;Yes;;✅;✅;✅;;✅;✅;;;;✅;Failing to release a wakelock properly can keep the Android device in a high power mode (which reduces battery life). There are several causes of this, such as releasing the wake lock in onDestroy() instead of in onPause(), failing to call release() in all possible code paths after an acquire(), and so on.NOTE: If you are using the lock just to keep the screen on, you should strongly consider using FLAG_KEEP_SCREEN_ON instead. This window flag will be correctly managed by the platform as the user moves between applications and doesn't require a special permission. ;https://googlesamples.github.io/android-custom-lint-rules/checks/Wakelock.md.html;Ensure wake locks are released properly in onPause() instead of onDestroy(), and always include a release() call in all possible code paths. If keeping the screen on is the only goal, use FLAG_KEEP_SCREEN_ON instead, as it is managed automatically by the platform.;*.java, *.kt;Warning;WakeLock1.txt;WakeLock2.txt;;A developer is building a music player service that needs to continue playback when the screen is off. The task involves acquiring a WakeLock in the service that handles audio playback to prevent the CPU from sleeping while music is playing,;;;;lint ;usa lint, suports kt;;;;;;;
WakelockTimeout;Energy;Yes;;;;✅;;;;;;;✅;Wakelocks have two acquire methods: one with a timeout, and one without. You should generally always use the one with a timeout. A typical timeout is 10 minutes. If the task takes longer than it is critical that it happens (i.e. can't use JobScheduler) then maybe they should consider a foreground service instead (which is a stronger run guarantee and lets the user know something long/important is happening).;https://googlesamples.github.io/android-custom-lint-rules/checks/WakelockTimeout.md.html; Always use the wake lock acquire method that includes a timeout. A typical timeout is 10 minutes. If longer execution is needed, consider using a foreground service instead, which ensures the task completes while informing the user.;*.java, *.kt;Warning;WakelockTimeout1.txt;WakelockTimeout2.txt;;;;;;;;;;;;;;
ViewHolder;Runtime;Yes;;;;✅;;;✅;;;;✅;"When implementing a view Adapter, you should avoid unconditionally inflating a new layout; if an available item is passed in for reuse, you should try to use that one instead. This helps make for example ListView scrolling much smoother.";https://googlesamples.github.io/android-custom-lint-rules/checks/ViewHolder.md.html;: In RecyclerView.Adapter and similar adapters, reuse existing views instead of inflating new ones each time. Implement the ViewHolder pattern to improve scrolling performance and reduce unnecessary object creation.;*.java, *.kt;Warning;ViewHolder1.txt;ViewHolder2.txt;;A developer is creating a scrollable feed of social media posts using a RecyclerView. The task involves displaying a list of post objects to view items that display user avatars, post content, and interaction buttons as the user scrolls through the timeline.;;;;pmd;supports kotlin but offers lacks rule for performance ;;;;;;;
ObsoleteLayoutParam;Runtime;Yes;;;;✅;;;✅;;;;✅;The given layout_param is not defined for the given layout, meaning it has no effect. This usually happens when you change the parent layout or move view code around without updating the layout params. This will cause useless attribute processing at runtime, and is misleading for others reading the layout so the parameter should be removed.;https://googlesamples.github.io/android-custom-lint-rules/checks/ObsoleteLayoutParam.md.html;Edit the XML file and delete the obsolete parameter that has no effect;*.xml;Warning;ObsoleteLayoutParam1.txt;ObsoleteLayoutParam2.txt;;A developer is developing a UI layout and needs to use a LinearLayout. It has to align the views inside the layout(Buttons, TextViews and Images) with each other and with the parent element.;;;;ecoandroid;no;;;;;;;
BLOBClass;Runtime;No;;;;;;;;✅;✅;;;Blob Class (BLOB) - OO: A Blob class, also know as God class, is a class with a large number of attributes and/or methods [17]. The Blob class handles a lot of responsibilities compared to other classes. Attributes and methods of this class are related to different concepts and processes, implying a very low cohesion. Blob classes are also often associated with numerous data classes. Blob classes are hard to maintain and increase the difﬁculty to modify the software. In PAPRIKA, classes are identiﬁed as Blob classes whenever the metrics numbers_of_attributes, number_of_methods and lack_of_cohesion_in_methods are very high.;; Refactor the large class by splitting it into multiple smaller, cohesive classes with clear responsibilities. Use Single Responsibility Principle (SRP) to ensure each class focuses on a single task. Extract related attributes and methods into separate, more maintainable classes.;*.java, *.kt;Warning;BLOBClass1.txt;BLOBClass2.txt;;A developer is creating the main activity for a messaging application. The task involves handling user authentication, message composition, contact management, media attachment processing, and notification preferences all within a class that serves as the central controller for the application's functionality;;;;;;;;;;;;
SwissArmyKnife;Runtime;No;;;;;;;;✅;✅;;;A Swiss army knife is a class with numerous interface signatures, resulting in a very complex class interface designed to handle a wide diversity obstractions. This type of class is hard to understand and to maintain because of the resulting complexity. A SAK is detected by Paprika when a class implements a large number of interfaces.;;Reduce the number of interfaces a class implements. If multiple interfaces are needed, consider breaking them into smaller, more specialized interfaces (Interface Segregation Principle). This makes the class easier to understand and maintain.;*.java, *.kt;Warning;SwissArmyKnife1.txt;SwissArmyKnife2.txt;;A developer is building a network utility class for an Android application. The task involves creating a component that implements multiple interfaces to handle different aspects of connectivity, including download management, caching, authentication, encryption, and error handling across the entire application;;;;;;;;;;;;
Longmethod;Runtime;No;;;;;;;;✅;✅;;;Long methods are implemented with much more lines of code than other methods. They are often very complex, and thus hard to understand and main-tain. These methods can be split into smaller methodstofixtheproblem[21]. Paprika iden- tifies a long method when the number of instructions for one method is very high.;;Break long methods into multiple smaller methods, each performing a specific task. Use method extraction to improve readability and maintainability. Follow the Single Responsibility Principle (SRP) to avoid excessive complexity in a single method.;*.java, *.kt;Warning;Longmethod1.txt;Longmethod2.txt;;A developer needs to implement a data synchronization feature that processes local data, compares it with server data, resolves conflicts, updates the database, and refreshes the UI. Access to this feature should be provided by a single method;;;;;;;;;;;;
ComplexClass;Runtime;No;;;;;;;;✅;✅;;;A complex class is a class containing complex methods. Again, these classes are hard to understandand maintain and need to be refactored [21]. The class complexity is calculated by summing the internal methods complexities. The complexity of a method can be calculated using McCabe’s Cyclomatic Complexity [27].;;educe the internal complexity of the class by simplifying complex methods. Use Cyclomatic Complexity (McCabe's metric) as a guide to refactor methods into smaller, well-defined methods. Apply design patterns like Strategy or Factory to delegate responsibilities.;*.java, *.kt;Warning;ComplexClass1.txt;ComplexClass2.txt;;A developer is creating a custom camera implementation that handles camera initialization, preview rendering, photo capture, video recording, image processing, and various camera settings. The class should deal with complex decision trees, nested conditions, and multiple execution paths to handle different device capabilities and user interactions.;;;;;;;;;;;;
InternalGetterSetter;Runtime;No;✅;✅;✅;✅;;;;✅;✅;;n/a?;"On Android, fields should be accessed directly within a class to increase performance. The usage of an internal getter or a setter con- verts into a virtual invoke, which makes the operation three times slower than a direct access . NOTE: As of Android 2.3 (Gingerbread), this optimization is performed automatically by Dalvik, so there is no need to change your code; this is only relevant if you are targeting older versions of Android.";;This issue is obsolete for Android versions 2.3 (Gingerbread) and above since the Dalvik runtime optimizes direct field access. If targeting very old versions, access fields directly within the class instead of using getters and setters to improve performance.;*.java, *.kt;Useless;InternalGetterSetter1.txt;InternalGetterSetter2.txt;;A developer is building a data model class for a user profile that contains various attributes like name, email, and preferences. Within the class's internal methods, they access class fields.;;;;;;;;;;;;
MemberIgnoringMethod;Runtime;No;✅;✅;✅;;;;;✅;✅;;;On Android, when a method does not access an object attribute, it is recommended to use a static method. The static method invocations are about 15%–20% faster than a dynamic invocation.;;Non-static methods that do not access any internal properties of the class should be made static in order to increase their efficiency;*.java, *.kt;Warning;MemberIgnoringMethod1.txt;MemberIgnoringMethod2.txt;;A developer is implementing utility functions in a Java Class. One method performs string formatting for display purposes, another validates input patterns, and a third calculates statistical methods over the data provided as input ;;;;;;;;;;;;
NoLowMemoryResolver;Memory;Yes;;✅;✅;;;;;✅;✅;✅;✅;When the Android system is running low on memory, the system calls the method onLowMemory() of running activities, which are supposed to trim their memory usage. If this method is not implemented by the activity, the Android system kills the process in order to free memory, and can cause an abnormal termination of programs ;;Implement the onLowMemory() and onTrimMemory(int level) methods in Activity and Application classes to handle low-memory situations. Free unnecessary resources, clear caches, and optimize memory usage to prevent unexpected app termination.;*.java, *.kt;Warning;NoLowMemoryResolver1.txt;NoLowMemoryResolver2.txt;; developer is creating an image gallery application that loads and caches multiple high-resolution images. The application implements Activity and Fragment lifecycle methods to load and show the gallery and individual photos;;;;;;;;;;;;
LeakingInnerClass;Memory;No;;✅;✅;✅;;;;✅;✅;;;In Java, non-static inner and anonymous classes are holding a reference to the outer class, whereas static inner classes are not. This could provoke a memory leak in Android systems;;Convert non-static inner classes to static inner classes or use WeakReference to avoid memory leaks. If an inner class requires access to the outer class, use a WeakReference<OuterClass> instead of a direct reference.;*.java, *.kt;Warning;LeakingInnerClass1.txt;LeakingInnerClass2.txt;;A developer is implementing a long-running background task that processes data and needs to update the UI when complete. Inside an Activity, they need to handle the background work.;;;;;;;;;;;;
UnsuitedLRUCacheSize;Memory;Yes;;;;;;;;;✅;;;in Android, a cache can be used to store frequently used objects with the Least Recently Used (LRU) API. The code smell occurs when the LRU is initialized without checking the available memory via the getMemoryClass() method. The available memory may vary considerably according to the device so it is necessary to adapt the cache size to the available memory;;When initializing an LRUCache, set its size dynamically based on available memory using ActivityManager.getMemoryClass(). This ensures the cache size adapts to different device specifications, preventing excessive memory usage.;*.java, *.kt;Warning;UnsuitedLRUCacheSize1.txt;UnsuitedLRUCacheSize2.txt;;A developer is building a news reader application that caches article images to improve scrolling performance, which suggest the need to use an LRU cache.;;;;;;;;;;;;
HashmapUsage;Memory;Yes;✅;✅;✅;✅;;;;✅;✅;;✅;the usage of HashMap is inadvisable when managing small sets in Android. Using HashMaps entails the auto-boxing process where primitive types are converted into generic objects. The issue is that generic objects are much larger than primitive types, 16 and 4 bytes, respectively. Therefore, the framework recommends using the SparseArray data structure that is more memory-eﬃcient;https://googlesamples.github.io/android-custom-lint-rules/checks/UseSparseArrays.md.html;Replace HashMap<Integer, Object> with SparseArray<T>, SparseIntArray, or SparseBooleanArray when working with primitive integer keys. This avoids auto-boxing and significantly reduces memory consumption.;*.java, *.kt;Warning;HashmapUsage1.txt;HashmapUsage2.txt;;A developer is implementing a feature to store and retrieve configuration settings with integer keys on memory;;;;;;;;;;;;
Overdraw;Energy;yes;;;;✅;;;;;;;;"If you set a background drawable on a root view, then you should use a custom theme where the theme background is null. Otherwise, the theme background will be painted first, only to have your custom background completely cover it; this is called “overdraw”. NOTE: This detector relies on figuring out which layouts are associated with which activities based on scanning the Java code, and it's currently doing that using an inexact pattern matching algorithm. Therefore, it can incorrectly conclude which activity the layout is associated with and then wrongly complain that a background-theme is hidden. If you want your custom background on multiple pages, then you should consider making a custom theme with your custom background and just using that theme instead of a root element background. Of course it's possible that your custom drawable is translucent and you want it to be mixed with the background. However, you will get better performance if you pre-mix the background with your drawable and use that resulting image or color as a custom theme background instead.";;Remove unnecessary background layers in XML or Java code. If setting a custom background on a root view, use a theme with a transparent background instead of layering multiple backgrounds. Pre-mix translucent backgrounds with images for better performance.;*.xml;Warning;Overdraw1.txt;Overdraw2.txt;; A developer is designing a custom list item layout for a RecyclerView. The layout includes a root FrameLayout, a CardView and an inner LinearLayout with background color. ;;;;;;;;;;;;
UIOverdraw;Energy;Yes;;;✅;✅;;;;✅;✅;;✅;a UI Overdraw is a situation where a pixel of the screen is drawn many times in the same frame. This happens when the UI design consists of unneeded overlapping layers, e.g., hidden backgrounds. To avoid such situations, the canvas.quickreject() API should be used to define the view boundaries that are drawable;;"Optimize layout design by removing overlapping UI layers. Use canvas.quickReject() to define drawable boundaries and prevent unnecessary rendering. Enable ""Show GPU Overdraw"" in Developer Options to detect excessive overdraw.";*.java, *.kt;Warning;UIOverdraw1.txt;UIOverdraw2.txt;;A developer is creating a custom view that draws a complex visualization with multiple layers of graphics. The implementation should draw all elements for every frame.;;;;;;;;;;;;
InvalidatewithoutRect;Runtime;Yes;;;;;;;;✅;✅;✅;;refers to a code smell that arises when rect to be redrawn is not specified while invalidating the view;; When calling invalidate(), specify a bounding rectangle (invalidate(Rect) or invalidate(left, top, right, bottom)) to redraw only the affected area instead of the entire view, improving performance.;*.java, *.kt;Warning;InvalidatewithoutRect1.txt;InvalidatewithoutRect2.txt;;A developer is implementing a custom view that displays real-time data visualization. When new data arrives, the view needs to be redrawn to reflect changes and evaluate when only a small section has changed.;;;;;;;;;;;;
UnsupportedHardwareAcceleration;Runtime;Yes;;;;;;;;✅;✅;✅;;On Android, most of the drawing operations are executed in the GPU. Rare drawing operations that are executed in the CPU, e.g., drawPath method in android.graphics.Canvas, should be avoided to reduce CPU load;;Avoid CPU-bound drawing operations like Canvas.drawPath() in performance-critical areas. Instead, use hardware-accelerated alternatives like ShapeDrawable, VectorDrawable, or OpenGL ES for complex graphics.;*.java, *.kt;Warning;UnsupportedHardwareAcceleration1.txt;UnsupportedHardwareAcceleration2.txt;;A developer is creating a custom drawing application that allows users to draw freehand paths;;;;;;;;;;;;
HeavyAsyncTask;Runtime;Yes;;;;;;;;✅;✅;✅;;refers to a code smell that arises when heavy operations are carried out inside an Async Task. Heavy operation is considered to be any operation that has computational complexity of greater than 10 (McConnel S. Code Complete).;;Offload heavy computations (e.g., complex loops, large database operations) from AsyncTask.doInBackground() to background worker threads using Executors, Coroutines, or WorkManager.;*.java, *.kt;Warning;HeavyAsyncTask1.txt;HeavyAsyncTask2.txt;;A developer is implementing an image processing feature that applies complex filters to photos and perform this task on the background;;;;;;;;;;;;
HeavyServiceStart;Energy;Yes;;;;;;;;✅;✅;✅;;refers to a code smell that arises when heavy operations are carried out inside a Service;;void running long or computationally expensive tasks inside Service. Use JobScheduler, WorkManager, or foreground services for long-running operations.;*.java, *.kt;Warning;HeavyServiceStart1.txt;HeavyServiceStart2.txt;;A developer is creating a music player service that needs to load and process audio files. He should build a service that should allow to populate the app by decoding audio files, building playlists, and initializing audio effects when the service starts.;;;;;;;;;;;;
HeavyBroadcastReceiver;Energy;Yes;;;;;;;;✅;✅;✅;;refers to a code smell that arises when heavy operations are carried out inside a onRecieve() function of Broadcast Receiver;;Keep onReceive() lightweight. Offload heavy processing to a background thread using IntentService, WorkManager, or JobIntentService. Avoid long-running computations in broadcast receivers to prevent ANRs.;*.java, *.kt;Warning;HeavyBroadcastReceiver1.txt;HeavyBroadcastReceiver2.txt;;A developer is implementing a broadcast receiver that responds to system events like connectivity changes. It should allow to perform network operations to check server status, update local databases, and synchronize data.;;;;;;;;;;;;
BitmapFormatUsage;Memory;Yes;;;;;;;;✅;;✅(divergent);;Bitmap Format Usage is a code smell that arises when images are represented as Bitmaps which is memory intensive function.;;optimize bitmap usage by using vector drawables (VectorDrawable) or WebP format instead of Bitmap. When using bitmaps, compress them using BitmapFactory.Options.inSampleSize and avoid loading full-resolution images unnecessarily.;*.java, *.kt;Warning;BitmapFormatUsage1.txt;BitmapFormatUsage2.txt;;A developer is building a photo gallery application that displays multiple high-resolution images. They should load images as Bitmap objects ;;;;;;;;;;;;
UnclosedCloseable;Memory;Yes;;✅;✅;;;;;;;;;A class that implements the java.io.Closeable interface is supposed to invoke the close method to release resources that an object is holding.;;Always close resources (like files, streams, or database cursors) by calling close() in a finally block or using Java’s try-with-resources;*.java, *.kt;Warning;UnclosedCloseable1.txt;UnclosedCloseable2.txt;;A developer is implementing a feature to read configuration data from a file.  A InputStream should be used to read the file contents ;;;;;;;;;;;;
CameraLeak;Energy;Yes;✅;;;;;✅;;;;✅;✅;android.hardware.Camera - Keeping the camera active without using it;;Always release the camera when it is no longer needed by calling camera.release() in onPause() or onDestroy(). Consider using Camera2API, which provides a more lifecycle-aware approach.;*.java, *.kt;Warning;CameraLeak1.txt;CameraLeak2.txt;;A developer is implementing a QR code scanner feature that uses the device camera. When the user navigates to the scanner screen, it should open the camera;;;;;;;;;;;;
MediaLeak;Energy;Yes;✅;;;;;✅;;;;✅;✅;Keeping the media recorder active without using it;;Always stop and release the MediaRecorder when finished recording using stop() and release() methods;*.java, *.kt;Warning;MediaLeak1.txt;MediaLeak2.txt;;A developer is creating a video recording feature that uses MediaRecorder, which should enable to start and top a video recording.;;;;;;;;;;;;
LeakingThread;Memory;No;;✅;✅;✅?;;;;;;✅;✅;In Android programming a thread is a garbage collector (GC) root. The GC does not collect the root bjects and, therefore, if a thread is not adequately stopped it can remain in memory for all the execution of the application, causing an abuse of the memory of the app. If an Activity starts a thread and does not stop it this is considered a design ﬂaw [18]. ADOCTOR detects this smell if a method of an Activity class starts a thread without stopping it through the stop method.;;Ensure that threads started within an Activity are properly stopped when the activity is destroyed. Use Thread.interrupt() or switch to HandlerThread, ExecutorService, or Kotlin Coroutines for better lifecycle management.;*.java, *.kt;Warning;LeakingThread1.txt;LeakingThread2.txt;;A developer is implementing a background task that periodically refreshes data from a network source. He needs to create a Thread in an Activity's onCreate() method to perform this task;;;;;;;;;;;;
LeakingHandler;Memory;No;;;✅?;✅;;;;;;✅;✅;"Since this Handler is declared as an inner class, it may prevent the outer class from being garbage collected. If the Handler is using a Looper or MessageQueue for a thread other than the main thread, then there is no issue. If the Handler is using the Looper or MessageQueue of the main thread, you need to fix your Handler declaration, as follows: Declare the Handler as a static class; In the outer class, instantiate a WeakReference to the outer class and pass this object to your Handler when you instantiate the Handler; Make all references to members of the outer class using the WeakReference object.";https://googlesamples.github.io/android-custom-lint-rules/checks/HandlerLeak.md.html;Declare handlers as static inner classes to prevent memory leaks. Use a WeakReference to reference the outer class;*.java, *.kt;Warning;LeakingHandler1.txt;LeakingHandler2.txt;;A developer is implementing a long-running background task that needs to update the UI periodically. He needs to create a Handler to post messages to the main thread;;;;;;;;;;;;
DataTransmissionWithoutCompression;Energy;No;;✅;;;;✅;;;;✅;✅;The smell arises when a method transmits a ﬁle over a network infrastructure without compressing it, causing an overhead of communication [18]. ADOCTOR detects the smell if a method performs an Http request involving an instance of the class File without using a compression library such as ZLIB2 or the APACHE HTTP CLIENT3.;;Compress files before transmitting over a network using Zlib, Gzip, or Apache HttpClient to reduce bandwidth usage;*.java, *.kt;Warning;DataTransmissionWithoutCompression1.txt;DataTransmissionWithoutCompression2.txt;;A developer is building a file-sharing feature that allows users to upload large files to a server. The upload functionality should use an HttpURLConnection;;;;;;;;;;;;
VacuousBackgroundService;Energy;Yes;;;;;;;;;;✅* many false positives?;✅;refers to an energy bug that arises when a service consumes resources in the background. Hence, a service should be stopped before the application goes to background in onStop method;;Stop services when the app goes into the background by calling stopSelf() in onStop(). Prefer JobScheduler, WorkManager, or Foreground Services only when necessary.;*.java, *.kt;Warning;VacuousBackgroundService1.txt;VacuousBackgroundService2.txt;;A developer needs to create a service to perform periodic data synchronization;;;;;;;;;;;;
LifecycleContainment;Energy;Yes;✅;;;;;;;;;✅;✅;refers to a code smell that arises when a listener is registered but not unregistered from activity;;Always unregister listeners in onPause() or onDestroy();*.java, *.kt;Warning;LifecycleContainment1.txt;LifecycleContainment2.txt;;A developer is implementing location tracking in an activity. The activity should create a LocationListener when created in order to receive location updates;;;;;;;;;;;;
EarlyResourceBinding;Energy;Yes;;;;;;;;;;✅;✅;refers to code smell that arises when heavy resources such as database connections, Camera, Media Player and Location Manager are initialized before they need to be used;;Delay initializing heavy resources (e.g., Camera, MediaPlayer, LocationManager, Database) until they are actually needed instead of initializing them early in onCreate().;*.java, *.kt;Warning;EarlyResourceBinding1.txt;EarlyResourceBinding2.txt;;A developer is creating a camera app. He should use the camera object in the main activity;;;;;;;;;;;;
ImmortalityBug;Energy;Yes;;;;;;;;;;✅* (does not check for foreground service);✅;refers to an energy bug that arises when an application re-spawns when it is not opened by the user. To detect this issues, calls to start a foreground operation like activity are removed from background operations like Services;; Prevent apps from restarting unnecessarily by removing auto-restart logic in background services. Avoid using START_STICKY unless necessary and ensure proper foreground service management.;*.java, *.kt;Warning;ImmortalityBug1.txt;ImmortalityBug2.txt;;A developer is implementing a background service for data syncing;;;;;;;;;;;;
RigidAlarmManager;Energy;Yes;;✅;✅;;;;;;;;;The AlarmManager class allows to execute operations at speciﬁc moments. Obviously, an Alarm Manager-triggered operation wakes- up the phone, possibly threatening the energy and memory efﬁciency of the app. It is recommended to use the AlarmManager.setInexactRepeating method, which ensures that the system is able to bundle several updates together [18]. Therefore, a code smell is identiﬁed by our detector if a class using an instance of AlarmManager does not deﬁne the method setInexactRepeating.;;Use setInexactRepeating() instead of setRepeating() to allow Android to batch operations and reduce power usage;*.java, *.kt;Warning;RigidAlarmManager1.txt;RigidAlarmManager2.txt;;A developer is creating a weather app that needs to update forecast data periodically. He decided to use AlarmManager;;;;;;;;;;;;
InefficientSQLQuery;Energy;Yes;;✅;;;;;;;;;;In Android, the use of a SQL query is discouraged as it introduces overhead, while other solutions should be preferred (e.g., using webservices) [18]. If a method deﬁnes a JDBC connection and sends an SQL query to a remote server, the smell is identiﬁed.;; Avoid direct SQL queries when possible. Prefer Room Database, SQLite with indexing, or Web services instead of raw SQL queries to minimize performance overhead.;*.java, *.kt;Warning;InefficientSQLQuery1.txt;InefficientSQLQuery2.txt;;A developer is implementing a feature to fetch user data from a remote database;;;;;;;;;;;;
DebuggableRelease;Energy;Yes;;✅;✅;;;;;;;;;In Android, the attribute android:debuggable of the AndroidManifest ﬁle is set during the development for debugging an app. Leaving the attribute true when the app is released is a major security threat since every external app can have full access to the source code. In this case, the detector simply parses the AndroidManifest ﬁle looking for the android:debuggable properties. If it is explicitly set to true, the smell is detected.;;"Ensure android:debuggable=""false"" in the AndroidManifest.xml file for release builds.";*.xml;Warning;DebuggableRelease1.txt;DebuggableRelease2.txt;; A developer needs to submit its app to the Google Play Store after making it debuggable ;;;;;;;;;;;;
InefficientDataFormatAndParser;Runtime;Yes;;✅;✅;;;;;;;;;When analyzing XML or JSON ﬁles, the use of TreeParser slows down the app, and thus it should be avoided and replaced with other more efﬁcient parsers (e.g.,StreamParser) [18]. In this case, ADOCTOR identiﬁes the smell by evaluating whether a method uses the TreeParser class.;; Replace Tree-based parsers (e.g., DocumentBuilder for XML, JSONObject for JSON) with stream-based parsers (XmlPullParser, JsonReader) for better performance.;*.java, *.kt;Warning;InefficientDataFormatAndParser1.txt;InefficientDataFormatAndParser2.txt;;A developer need to implement a feature to parse large XML configuration files in their app.;;;;;;;;;;;;
MemoizationChance;Runtime;No;✅;;;;;;;;;;;Methods that work as simple functions are good targets to exploit memoization for performance enhancement;;Implement memoization to cache function results, avoiding redundant computations;*.java, *.kt;Warning;MemoizationChance1.txt;MemoizationChance2.txt;;A developer is implementing a utility method that calculates the Fibonacci sequence for a specific position. The method uses a recursive approach that repeatedly calculates the same values for overlapping subproblems. This computation-heavy method is called multiple times with the same inputs during the application's lifecycle,;;;;;;;;;;;;
DynamicWaitTime;Energy;No;;;;;;✅;;;;;;This inspection identifies cases where the wait time between attempts to access a resource is constant. In those cases, the constant is changed to a dynamic value that grows with the number of attempts. It also considers the values used to put threads to sleep. <br>;;Implement exponential backoff instead of using constant wait times;*.java, *.kt;Warning;DynamicWaitTime1.txt;DynamicWaitTime2.txt;;A developer is creating a feature that polls a remote server for data availability. The implementation should try to get the data in several attempts before giving up and wait a while after each retry;;;;;;;;;;;;
InfoWarningFCM;Energy;Yes;;;;;;✅;;;;;; This inspection identifies cases where the method android.app.AlarmManager.setRepeating is used and adds a <i>TODO</i> to the source code to remind developers that it would be preferable to implement push notifications, rather than using a possible polling system. <br>;;Replace AlarmManager.setRepeating() (polling) with Firebase Cloud Messaging (FCM) for push notifications;*.java, *.kt;Warning;InfoWarningFCM1.txt;InfoWarningFCM2.txt;;A developer is implementing a notification system that needs to periodically check for updates from a server. ;;;;;;;;;;;;
PassiveProviderLocation;Energy;;;;;;;✅;;;;;; This inspection switches to a <i>LocationManager.PASSIVE_PROVIDER</i> when invoking the method <i>requestLocationUpdates</i> from the class <i>android.location.LocationManager;; Use LocationManager.PASSIVE_PROVIDER when location updates are needed but don’t require GPS;*.java, *.kt;Warning;PassiveProviderLocation1.txt;PassiveProviderLocation2.txt;;A developer is building a fitness tracking app that needs location updates just to display the current weather on the user area.;;;;;;;;;;;;
SSLSessionCaching;Energy;;;;;;;✅;;;;;;    This inspection applies the energy pattern https://tqrg.github.io/energy-patterns/#/patterns/Cache by attempting to increase the cache size of an SSL Session.    It identifies cases where the cache size is not already set to a specific value and removes any default ;;Increase SSL session cache size for better performance;*.java, *.kt;Warning;SSLSessionCaching1.txt;SSLSessionCaching2.txt;;A developer is implementing secure network communication in their app. THe app requires establishing HTTPS connections to their server all the time. ;;;;;;;;;;;;
URLCaching;Energy;;;;;;;✅;;;;;;This inspection identifies cases where no changes occur since the last update from an URL connection. It adds a <i>TODO</i> to the source code to remind developers that there is an opportunity to apply the energy pattern https://tqrg.github.io/energy-patterns/#/patterns/Cache;;Implement HTTP caching using HttpURLConnection;*.java, *.kt;Warning;URLCaching1.txt;URLCaching2.txt;;A developer is creating a news feed that fetches content from a remote server. Their implementation should use a HttpURLConnection for each refresh;;;;;;;;;;;;
CheckLayoutSize;Energy;Yes;;;;;;✅;;;;;;  This inspection ensures that a layout is not drawn when its measurements are zero.   This is specific to the usage of the class android.view.SurfaceHolder.;;Ensure layouts are not drawn if their measurements are zero when using android.view.SurfaceHolder;*.java, *.kt;Warning;CheckLayoutSize1.txt;CheckLayoutSize2.txt;;A developer is implementing a custom SurfaceView for rendering graphics.;;;;;;;;;;;;
CheckMetadata;Energy;;;;;;;✅;;;;;; This inspection identifies cases where a simple cache mechanism can be added in the method onReceive of subclasses of android.content.BroadcastReceiver. In those cases, the source code is refactored so that changes in the    values retrieved from the intent parameter are checked before processing the information received.<br>;; Implement a simple caching mechanism in onReceive() of BroadcastReceiver to avoid redundant processing.;*.java, *.kt;Warning;CheckMetadata1.txt;CheckMetadata2.txt;;A developer is implementing a BroadcastReceiver that processes system events. In the onReceive() method, the app should process incoming intents and broadcast notifications ;;;;;;;;;;;;
CheckNetwork;Energy;No;;;;;;✅;;;;;;  This inspection identifies cases where a network connection exists before processing a request. This is only activated when subclasses of android.app.IntentService are used. <br>;; Ensure network availability before processing requests in IntentService.;*.java, *.kt;Warning;CheckNetwork1.txt;CheckNetwork2.txt;;A developer is creating an IntentService that needs to download data from a server. The service should  make network requests to obtain the data;;;;;;;;;;;;
DirtyRendering;Energy;Yes;;;;;;✅;;;;;;This inspection switches the rendering mode to <i>GLSurfaceView.RENDERMODE_WHEN_DIRTY;;Switch to lazy rendering using GLSurfaceView.RENDERMODE_WHEN_DIRTY.;*.java, *.kt;Warning;DirtyRendering1.txt;DirtyRendering2.txt;;A developer is implementing a custom OpenGL ES view for a game that displays relatively static content with occasional updates. ;;;;;;;;;;;;
ExcessiveLoopCallsDetector;Runtime;No;✅;;;;;;;;;;;Calling methods inside loops, either in the loop condition or in the body, is  usually a good optimization target;;Avoid method calls inside loops when possible by precomputing values outside the loop.;*.java, *.kt;Warning;ExcessiveLoopCallsDetector1.txt;ExcessiveLoopCallsDetector2.txt;;A developer is implementing a task scheduler that needs to repeatedly execute a method at fixed intervals. They create a Handler and post a Runnable that calls updateStatus() inside a loop,;;;;;;;;;;;;
NestedWeight;Runtime;Yes;;;✅;✅;;;;;;;✅;Layout weights require a widget to be measured twice. When a LinearLayout with non-zero weights is nested inside another LinearLayout with non-zero weights, then the number of measurements increase exponentially.;https://googlesamples.github.io/android-custom-lint-rules/checks/NestedWeights.md.html;Avoid nested LinearLayouts with weights by using ConstraintLayout or RelativeLayout instead.;*.xml;Warning;NestedWeight1.txt;NestedWeight2.txt;;"A developer is creating a complex layout for a messaging app interface. They use a LinearLayout with layout_weight to divide the screen between a ListView for messages (weight=""1"") and a bottom section for input. Within that bottom section, they create another LinearLayout with some more buttons.";;;;;;;;;;;;
ConfigChanges;;;;✅;✅;;;;;;;;;In Android applications, it is considered a code smell if attribute android:configChanges is defined in Manifest file. This phenomenon leads to memory leaks;;Avoid handling android:configChanges in the AndroidManifest.xml and instead handle config changes properly in onSaveInstanceState().;*.xml;Warning;ConfigChanges1.txt;ConfigChanges2.txt;;A developer is building an app that needs to maintain its UI state during screen rotations on its Activities.;;;;;;;;;;;;
DroppedData;Runtime;No;;;✅;;;;;;;;;on Android applications, the data filled by user in any Activity or fragment may be lost if the focused screen is interrupted. Data should be saved and restored using overridable methods on SaveInstanceState and on RestoreInstanceState;; Preserve user data using onSaveInstanceState() and onRestoreInstanceState().;*.java, *.kt;Warning;DroppedData1.txt;DroppedData2.txt;;A developer is creating a form for user registration within an activity. They need to implement input fields for name, email, and other details.;;;;;;;;;;;;
CollectionOfBitmaps;Memory;Yes;;;✅;;;;;;;;;The collection of bitmaps is a resource intensive process and should be avoided;;"Avoid loading multiple bitmaps in memory; use bitmap pooling or LruCache.";*.java, *.kt;Warning;CollectionOfBitmaps1.txt;CollectionOfBitmaps2.txt;;A developer is implementing an image gallery that displays multiple high-resolution photos. They should store Bitmap objects in memory.;;;;;;;;;;;;
CollectionOfViews;Memory;Yes;;;✅;;;;;;;;;The collection of views is a resource intensive process in Android applications and should be avoided;;Do not store views in collections;*.java, *.kt;Warning;CollectionOfViews1.txt;CollectionOfViews2.txt;;A developer is creating a custom ViewGroup that needs to manage multiple child views and to track them across all the application, that has multive activities;;;;;;;;;;;;
StaticBitmap;Memory;Yes;;;✅;✅;;;;;;;✅;Bitmaps are heavy objects and should be dealt with proper case otherwise it can lead to memory leaks.;;"Do not store bitmaps in static fields; use caching mechanisms like LruCache instead.";*.java, *.kt;Warning;StaticBitmap1.txt;StaticBitmap2.txt;;A developer is implementing an app that displays a company logo throughout different activities, manipulated via a Bitmap object;;;;;;;;;;;;
StaticContext;Memory;Yes;;;✅;✅;;;;;;;✅;In Android applications, declaring field of type Context leads to memory leak as it is never collected by garbage collector of JVM;;In Android applications, declaring field of type Context leads to memory leak as it is never colllected by garbage collector of JVM;*.java, *.kt;Warning;StaticContext1.txt;StaticContext2.txt;;A developer wants easy access to application resources from any class;;;;;;;;;;;;
StaticView;Memory;Yes;;;✅;✅;;;;;;;✅;Holding static reference of any view type object is a resource (memory) intensive process;;Avoid keeping static references to View objects to prevent memory leaks.;*.java, *.kt;Warning;StaticView1.txt;StaticView2.txt;;A developer is implementing a button that appears in multiple activities and wants to avoid recreating it;;;;;;;;;;;;
StaticFieldLeak;Memory;No;;;;✅;;;;;;;✅;A static field will leak contexts. Non-static inner classes have an implicit reference to their outer class. If that outer class is for example a Fragment or Activity, then this reference means that the long-running handler/loader/task will hold a reference to the activity which prevents it from getting garbage collected. Similarly, direct field references to activities and fragments from these longer running instances can cause leaks. ViewModel classes should never point to Views or non-application Contexts.;https://googlesamples.github.io/android-custom-lint-rules/checks/StaticFieldLeak.md.html;Avoid static references to Activities, Fragments, and Views. If needed, use WeakReference.;*.java, *.kt;Warning;StaticFieldLeak1.txt;StaticFieldLeak2.txt;;A developer is implementing a background task to download and process data in an Android activity ;;;;;;;;;;;;
UselessStringValueOf;;No;;;;;✅;;;;;;;"No need to call String.valueOf to append to a string; just use the valueOf() argument directly.";https://pmd.github.io/pmd/pmd_rules_java_performance.html#uselessstringvalueof;Just use the valueOf() argument directly to concatenate Strings;*.java, *.kt;Warning;UselessStringValueOf1.txt;UselessStringValueOf2.txt;;A developer is implementing a text formatting utility that builds custom strings by concatening string literals with numbers.;;;;;;;;;;;;
AppendCharacterWithChar;Runtime;No;;;;;✅;;;;;;;Avoid concatenating characters as strings in StringBuffer/StringBuilder.append methods.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html#appendcharacterwithchar;"oid concatenating characters using StringBuffer.append() or StringBuilder.append() with characters. use instead: StringBuffer sb = new StringBuffer();sb.append('a');";*.java, *.kt;Warning;AppendCharacterWithChar1.txt;AppendCharacterWithChar2.txt;;A developer is implementing a text formatting utility that builds custom strings character by character. They create a StringBuilder to construct the output and to append individual characters.;;;;;;;;;;;;
AvoidArrayLoops;Runtime;No;;;;;✅;;;;;;;Instead of manually copying data between two arrays, use the more efficient Arrays.copyOf or System.arraycopy method instead.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html#avoidarrayloops;Use System.arraycopy() or Arrays.copyOf() instead of looping through arrays.;*.java, *.kt;Warning;AvoidArrayLoops1.txt;AvoidArrayLoops2.txt;;A developer is creating an image processing feature that needs to make a copy of pixel data from one array to another. ;;;;;;;;;;;;
AvoidCalendarDateCreation;Runtime;No;;;;;✅;;;;;;;java.util.Calendar is a heavyweight object and expensive to create. It should only be used, if calendar calculations are needed.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html#avoidcalendardatecreation;Use new Date(), Java 8+ java.time.LocalDateTime.now() or ZonedDateTime.now().;*.java, *.kt;Warning;AvoidCalendarDateCreation1.txt;AvoidCalendarDateCreation2.txt;;A developer is building a scheduling app that frequently needs to check if events fall on specific days. ;;;;;;;;;;;;
AvoidFileStream;Memory;No;;;;;✅;;;;;;;The FileInputStream and FileOutputStream classes contains a finalizer method which will cause garbage collection pauses. See JDK-8080225 for details. The FileReader and FileWriter constructors instantiate FileInputStream and FileOutputStream, again causing garbage collection issues while finalizer methods are called. Use Files.newInputStream(Paths.get(fileName)) instead of new FileInputStream(fileName). Use Files.newOutputStream(Paths.get(fileName)) instead of new FileOutputStream(fileName). Use Files.newBufferedReader(Paths.get(fileName)) instead of new FileReader(fileName). Use Files.newBufferedWriter(Paths.get(fileName)) instead of new FileWriter(fileName). Please note, that the java.nio API does not throw a FileNotFoundException anymore, instead it throws a NoSuchFileException. If your code dealt explicitly with a FileNotFoundException, then this needs to be adjusted. Both exceptions are subclasses of IOException, so catching that one covers both.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html#avoidfilestream;Use Files.newInputStream(Paths.get(fileName)) instead of new FileInputStream(fileName). Use Files.newOutputStream(Paths.get(fileName)) instead of new FileOutputStream(fileName). Use Files.newBufferedReader(Paths.get(fileName)) instead of new FileReader(fileName). Use Files.newBufferedWriter(Paths.get(fileName)) instead of new FileWriter(fileName). ;*.java, *.kt;Warning;AvoidFileStream1.txt;AvoidFileStream2.txt;;A developer needs to implement a log file reader that processes application logs;;;;;;;;;;;;
AvoidInstantiatingObjectsInLoops;Runtime;No;;;;;✅;;;;;;;Don’t create instances of already existing BigInteger (BigInteger.ZERO, BigInteger.ONE), for Java 1.5 onwards, BigInteger.TEN and BigDecimal (BigDecimal.ZERO, BigDecimal.ONE, BigDecimal.TEN) and for Java 9 onwards BigInteger.TWO.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html#avoidfilestream;Avoid creating new objects inside loops if they can be reused outside the loop.;*.java, *.kt;Warning;AvoidInstantiatingObjectsInLoops1.txt;AvoidInstantiatingObjectsInLoops2.txt;;A developer is processing a list of user transactions in a loop. For each transaction, they need to use a DateFormatter object to format the transaction date;;;;;;;;;;;;
BigIntegerInstantiation;Memory;No;;;;;✅;;;;;;;;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html#avoidfilestream;Use existing BigInteger constants (BigInteger.ZERO, BigInteger.ONE, etc.) instead of instantiating new BigInteger objects.;*.java, *.kt;Warning;BigIntegerInstantiation1.txt;BigIntegerInstantiation2.txt;;A developer is implementing a calculator feature that works with precise decimal values. They need to use BigInteger values;;;;;;;;;;;;
ConsecutiveAppendsShouldReuse;Runtime;No;;;;;✅;;;;;;;Consecutive calls to StringBuffer/StringBuilder .append should be chained, reusing the target object. This can improve the performance by producing a smaller bytecode, reducing overhead and improving inlining.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Chain consecutive StringBuilder.append() or StringBuffer.append() calls to reduce bytecode size and improve performance.;*.java, *.kt;Warning;ConsecutiveAppendsShouldReuse1.txt;ConsecutiveAppendsShouldReuse2.txt;;A developer is building a string construction utility that generates complex formatted text from several class fields.;;;;;;;;;;;;
ConsecutiveLiteralAppends;Runtime;No;;;;;✅;;;;;;;Consecutively calling StringBuffer/StringBuilder.append(…) with literals should be avoided.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Avoid appending literals consecutively in StringBuilder. Instead, append once or use string concatenation if necessary.;*.java, *.kt;Warning;ConsecutiveLiteralAppends1.txt;ConsecutiveLiteralAppends2.txt;;A developer is creating an email template generator and needs to build a string using string literals.;;;;;;;;;;;;
InefficientEmptyStringCheck;Runtime;No;;;;;✅;;;;;;;String.trim().length() == 0 (or String.trim().isEmpty() for the same reason) is an inefficient way to check if a String is really blank;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html; Consider creating a static function that loops through a string, checking Character.isWhitespace() on each character and returning false if a non-whitespace character is found. Or using Apache’s StringUtils#isBlank (in commons-lang), Spring’s StringUtils#hasText (in the Spring framework) or Google’s CharMatcher#whitespace (in Guava) ;*.java, *.kt;Warning;InefficientEmptyStringCheck1.txt;InefficientEmptyStringCheck2.txt;;A developer is validating user input in a form. They check if a text field is empty after trimming by using inputText.trim().length() == 0, which creates an unnecessary intermediate String object, instead of using the more efficient inputText.isEmpty() or checking the length before trimming.;;;;;;;;;;;;
InefficientStringBuffering;Runtime;No;;;;;✅;;;;;;;Avoid concatenating non-literals in a StringBuffer constructor or append() since intermediate buffers will need to be be created and destroyed by the JVM.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Avoid concatenating non-literals in a StringBuffer constructor or append() since intermediate buffers will need to be be created and destroyed by the JVM.;*.java, *.kt;Warning;InefficientStringBuffering1.txt;InefficientStringBuffering2.txt;;A developer is building a dynamic query generator for a database. They need to create a StringBuilder that contains a select statement to be performed over a table whose name is contained on a class field;;;;;;;;;;;;
InsufficientStringBufferDeclaration;Runtime;No;;;;;✅;;;;;;;Failing to pre-size a StringBuffer or StringBuilder properly could cause it to re-size many times during runtime.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Pre-size the StringBuffer or StringBuilder when the expected size is known.;*.java, *.kt;Warning;InsufficientStringBufferDeclaration1.txt;InsufficientStringBufferDeclaration2.txt;;A developer is implementing a log formatting utility that concatenates various pieces of information. They need to create a StringBuffer and then append multiple string elements including timestamps, log levels, class names, and lengthy message content.;;;;;;;;;;;;
OptimizableToArrayCall;Runtime;No;;;;;✅;;;;;;;Calls to a collection’s toArray(E[]) method should specify a target array of zero size. This allows the JVM to optimize the memory allocation and copying as much as possible.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;When using toArray(), specify a zero-length array as an argument to allow for optimized memory allocation.;*.java, *.kt;Warning;OptimizableToArrayCall1.txt;OptimizableToArrayCall2.txt;;A developer is implementing a feature to convert a collection of user preferences to an array for processing. It is required to use the toArray() method on an ArrayList;;;;;;;;;;;;
RedundantFieldInitializer;Runtime;No;;;;;✅;;;;;;;Java will initialize fields with known default values so any explicit initialization of those same defaults is redundant and results in a larger class file (approximately three additional bytecode instructions per field).;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Remove redundant field initializations where default values are already provided by Java.;*.java, *.kt;Warning;RedundantFieldInitializer1.txt;RedundantFieldInitializer2.txt;;A developer is creating a data model class with dozens of fields of primitive  types to store user profile information;;;;;;;;;;;;
StringInstantiation;Runtime;No;;;;;✅;;;;;;;"Avoid instantiating String objects; this is usually unnecessary since they are immutable and can be safely shared.";https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;"Avoid instantiating String objects; this is usually unnecessary since they are immutable and canbe safely shared.";*.java, *.kt;Warning;StringInstantiation1.txt;StringInstantiation2.txt;;A developer is implementing a text processing utility that needs to work with string constants.;;;;;;;;;;;;
StringToString;Runtime;No;;;;;✅;;;;;;;"Avoid calling toString() on objects already known to be string instances; this is unnecessary.";https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Avoid instantiating new String objects when not necessary. Use string literals directly.;*.java, *.kt;Warning;StringToString1.txt;StringToString2.txt;;A developer is building a string concatenation utility that combines various data types received as input. Namely, some of the inputs are Strings;;;;;;;;;;;;
TooFewBranchesForSwitch;Runtime;No;;;;;✅;;;;;;;Switch statements are intended to be used to support complex branching behaviour. Using a switch for only a few cases is ill-advised, since switches are not as easy to understand as if-else statements. In these cases use the if-else statement to increase code readability.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;If a switch statement has too few cases, consider using an if-else statement for clarity and performance.;*.java, *.kt;Warning;TooFewBranchesForSwitch1.txt;TooFewBranchesForSwitch2.txt;;A developer is implementing a feature to handle different user account types. They need to handle logic to deal with only two cases;;;;;;;;;;;;
UseArrayListInsteadOfVector;Runtime;No;;;;;✅;;;;;;;ArrayList is a much better Collection implementation than Vector if thread-safe operation is not required.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html; Use ArrayList instead of Vector for non-thread-safe collection needs as ArrayList is more efficient.;*.java, *.kt;Warning;UseArrayListInsteadOfVector1.txt;UseArrayListInsteadOfVector2.txt;;A developer is implementing a collection to store user notification objects in a single-threaded environment. ;;;;;;;;;;;;
UseArraysAsList;Runtime;No;;;;;✅;;;;;;;The java.util.Arrays class has a asList() method that should be used when you want to create a new List from an array of objects. It is faster than executing a loop to copy all the elements of the array one by one.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Use Arrays.asList() to convert an array to a list, which is faster than manually iterating over the array.;*.java, *.kt;Warning;UseArraysAsList1.txt;UseArraysAsList2.txt;;A developer is converting an array of search results to a List for further processing.;;;;;;;;;;;;
UseIndexOfChar;Runtime;No;;;;;✅;;;;;;;"Use String.indexOf(char) when checking for the index of a single character; it executes faster.";https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Use String.indexOf(char) instead of manually checking the index of a character.;*.java, *.kt;Warning;UseIndexOfChar1.txt;UseIndexOfChar2.txt;;A developer is implementing a text parser that needs to find the position of specific characters in a string. ;;;;;;;;;;;;
UseIOStreamsWithApacheCommonsFileItem;Runtime;No;;;;;✅;;;;;;;Problem: Use of FileItem.get() and FileItem.getString() could exhaust memory since they load the entire file into memory.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Avoid using FileItem.get() and FileItem.getString() for large files. Use IO streams for better memory efficiency.;*.java, *.kt;Warning;UseIOStreamsWithApacheCommonsFileItem1.txt;UseIOStreamsWithApacheCommonsFileItem2.txt;;A developer is implementing a file upload feature using Apache Commons FileUpload. ;;;;;;;;;;;;
UseStringBufferForStringAppends;Runtime;No;;;;;✅;;;;;;;The use of the ‘+=’ operator for appending strings causes the JVM to create and use an internal StringBuffer. If a non-trivial number of these concatenations are being used then the explicit use of a StringBuilder or threadsafe StringBuffer is recommended to avoid this.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Use StringBuffer or StringBuilder explicitly for string concatenations in loops to avoid creating too many intermediate objects.;*.java, *.kt;Warning;UseStringBufferForStringAppends1.txt;UseStringBufferForStringAppends2.txt;;A developer is implementing a logging utility that needs to concatenate multiple pieces of information into a single log message. They need to do it on a loop;;;;;;;;;;;;
UseStringBufferLength;Runtime;No;;;;;✅;;;;;;;"Use StringBuffer.length() to determine StringBuffer length rather than using StringBuffer.toString().equals("""") or StringBuffer.toString().length() == ";https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;"Use StringBuffer.length() to determine StringBuffer length rather than using StringBuffer.toString().equals("""") or StringBuffer.toString().length() ==";*.java, *.kt;Warning;UseStringBufferLength1.txt;UseStringBufferLength2.txt;;A developer is creating a text input validation function that needs to check if a user's input contained in a StringBuffer is empty ;;;;;;;;;;;;
AddEmptyString;Runtime;No;;;;;✅;;;;;;;The conversion of literals to strings by concatenating them with empty strings is inefficient. It is much better to use one of the type-specific toString() methods instead or String.valueOf().;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;"String s = """" + 123;                / inefficient String  /\n t = Integer.toString(456);   // preferred approach";*.java, *.kt;Warning;AddEmptyString1.txt;AddEmptyString2.txt;;A developer is formatting numeric data for display. They need to convert each one of  several integers and doubles contained in class fields to a string;;;;;;;;;;;;
UselessParent;Runtime;Yes;;;;✅;;;;;;;✅;A layout with children that has no siblings, is not a scrollview or a root layout, and does not have a background, can be removed and have its children moved directly into the parent for a flatter and more efficient layout hierarchy.;https://googlesamples.github.io/android-custom-lint-rules/checks/UselessParent.md.html;A layout that has no siblings, is not a ScrollView or root layout, and has no background can be removed. Its children can be directly placed into the parent layout for a more efficient and flatter hierarchy.;*.xml;Warning;UselessParent1.txt;UselessParent2.txt;;A developer is creating a custom list item layout for a RecyclerView;;;;;;;;;;;;
UselessLeaf;Runtime;Yes;;;;✅;;;;;;;✅;A layout that has no children or no background can often be removed (since it is invisible) for a flatter and more efficient layout hierarchy.;https://googlesamples.github.io/android-custom-lint-rules/checks/UselessLeaf.md.html; A layout with no children or background can be removed to simplify the view hierarchy and improve performance.;*.xml;Warning;UselessLeaf1.txt;UselessLeaf2.txt;;A developer is refactoring a complex layout and that used several FrameLayouts that was previously used as a container.;;;;;;;;;;;;
AnimatorKeep;Runtime;Yes;;;;✅;;;;;;;✅;When you use property animators, properties can be accessed via reflection. Those methods should be annotated with @Keep to ensure that during release builds, the methods are not potentially treated as unused and removed, or treated as internal only and get renamed to something shorter. This check will also flag other potential reflection problems it encounters, such as a missing property, wrong argument types, etc.;https://googlesamples.github.io/android-custom-lint-rules/checks/AnimatorKeep.md.html;When using property animators, annotate the methods with @Keep to prevent them from being removed or renamed during release builds. This ensures that reflection-based access to properties works correctly.;*.java, *.kt;Warning;AnimatorKeep1.txt;AnimatorKeep2.txt;;A developer is implementing custom property animations for a view. They need to create methods to get and set custom properties;;;;;;;;;;;;
ObsoleteSdkInt;Runtime;Yes;;;;✅;;;;;;;✅;This check flags version checks that are not necessary, because the minSdkVersion (or surrounding known API level) is already at least as high as the version checked for. Similarly, it also looks for resources in -vNN folders, such as values-v14 where the version qualifier is less than or equal to the minSdkVersion, where the contents should be merged into the best folder.;https://googlesamples.github.io/android-custom-lint-rules/checks/ObsoleteSdkInt.md.html;Remove unnecessary SDK version checks when the minSdkVersion is already sufficient. If version-specific resources are available (e.g., values-v14), merge them into the appropriate folders based on the minSdkVersion.;*.java, *.kt;Warning;ObsoleteSdkInt1.txt;ObsoleteSdkInt2.txt;;A developer is updating an older app to target a newer Android version adn they need to avoid cases where the sdk version is lower than a certain deprecated version ;;;;;;;;;;;;
DuplicateDivider;Runtime;Yes;;;;✅;;;;;;;✅;Older versions of the RecyclerView library did not include a divider decorator, but one was provided as a sample in the support demos. This divider class has been widely copy/pasted into various projects. In recent versions of the support library, the divider decorator is now included, so you can replace custom copies with the “built-in” version, android.support.v7.widget.DividerItemDecoration.;https://googlesamples.github.io/android-custom-lint-rules/checks/DuplicateDivider.md.html;Replace custom divider decorators with the built-in DividerItemDecoration from the RecyclerView library, as it provides an optimized implementation for adding dividers.;*.java, *.kt;Warning;DuplicateDivider1.txt;DuplicateDivider2.txt;;A developer is implementing a list with dividers between items using RecyclerView.;;;;;;;;;;;;
UseValueOf;Runtime;Yes;;;;✅;✅;;;;;;✅;You should not call the constructor for wrapper classes directly, such asnew Integer(42). Instead, call the valueOf factory method, such as Integer.valueOf(42). This will typically use less memory because common integers such as 0 and 1 will share a single instance.;https://googlesamples.github.io/android-custom-lint-rules/checks/UseValueOf.md.html;You should not call the constructor for wrapper classes directly, such asnew Integer(42). Instead, call the valueOf factory method, such as Integer.valueOf(42). This will typically use less memory because common integers such as 0 and 1 will share a single instance.;*.java, *.kt;Warning;UseValueOf1.txt;UseValueOf2.txt;;A developer is parsing user input and converting it to Integer objects.;;;;;;;;;;;;
UnpackedNativeCode;Runtime;Yes;;;;✅;;;;;;;✅;"You can enable it by adding --enable UnpackedNativeCode This app loads native libraries using System.loadLibrary(). Consider adding android:extractNativeLibs=""false"" to the <application> tag in AndroidManifest.xml. Starting with Android 6.0, this will make installation faster, the app will take up less space on the device and updates will have smaller download sizes.";https://googlesamples.github.io/android-custom-lint-rules/checks/UnpackedNativeCode.md.html;"If you're loading native libraries via System.loadLibrary(), consider setting android:extractNativeLibs=""false"" in the AndroidManifest.xml to make installations faster, reduce app size, and make updates smaller.";*.xml;Warning;UnpackedNativeCode1.txt;UnpackedNativeCode2.txt;;A developer has to  integrate a native library into an Android app. the library should be importerd using System.loadLibrary() ;;;;;;;;;;;;
UnusedResources;Runtime;Yes;;;;✅;;;;;;;✅;Unused resources make applications larger and slow down builds. The unused resource check can ignore tests. If you want to include resources that are only referenced from tests, consider packaging them in a test source set instead. You can include test sources in the unused resource check by setting the system property lint.unused-resources.include-tests =true, and to exclude them (usually for performance reasons), use lint.unused-resources.exclude-tests =true. ,;https://googlesamples.github.io/android-custom-lint-rules/checks/UnusedResources.md.html;emove unused resources from your project to reduce its size and speed up builds. Consider packaging resources used only in tests separately in a test source set. Example: Use lint.unused-resources.exclude-tests=true to exclude test resources from the check.;*.java, *.kt, *.xml;Warning;UnusedResources1.txt;UnusedResources2.txt;;A developer is cleaning up their Android application before release. They have accumulated numerous layout files, drawables, and string resources during development and prototyping phases.  These unused resources remain in the project, increasing the APK size and slowing down build times.;;;;;;;;;;;;
UnusedIds;Runtime;Yes;;;;✅;;;;;;;✅;This resource id definition appears not to be needed since it is not referenced from anywhere. Having id definitions, even if unused, is not necessarily a bad idea since they make working on layouts and menus easier, so there is not a strong reason to delete these. The unused resource check can ignore tests. If you want to include resources that are only referenced from tests, consider packaging them in a test source set instead. You can include test sources in the unused resource check by setting the system property lint.unused-resources.include-tests =true, and to exclude them (usually for performance reasons), use lint.unused-resources.exclude-tests =true.;https://googlesamples.github.io/android-custom-lint-rules/checks/UnusedIds.md.html;Remove unused resource IDs, but keep in mind that they can help in the future during development. However, if you're sure they're not needed, you can delete them for a cleaner codebase.;*.java, *.kt, *.xml;Warning;UnusedIds1.txt;UnusedIds2.txt;;A developer is working on a complex UI layout where they defined multiple view IDs in anticipation of needing them for event handlers. As the development progressed, some of these views were removed or redesigned, leaving their ID definitions in the layout files without any references to them in the code. ;;;;;;;;;;;;
InefficientWeight;Runtime;Yes;;;;✅;;;;;;;✅;When only a single widget in a LinearLayout defines a weight, it is more efficient to assign a width/height of 0dp to it since it will absorb all the remaining space anyway. With a declared width/height of 0dp it does not have to measure its own size first.;https://googlesamples.github.io/android-custom-lint-rules/checks/InefficientWeight.md.html;If only one widget in a LinearLayout has a weight, you should assign it a width or height of 0dp to make layout calculations more efficient.;*.xml;Warning;InefficientWeight1.txt;InefficientWeight2.txt;;A developer is creating a layout where a button needs to take up all remaining space in a horizontal LinearLayout after a fixed-width TextView.;;;;;;;;;;;;
DisableBaselineAlignment;Runtime;Yes;;;;✅;;;;;;;✅;When a LinearLayout is used to distribute the space proportionally between nested layouts, the baseline alignment property should be turned off to make the layout computation faster.;https://googlesamples.github.io/android-custom-lint-rules/checks/DisableBaselineAlignment.md.html;When using LinearLayout to distribute space, turn off the baseline alignment property to speed up layout computation.;*.xml;Warning;DisableBaselineAlignment1.txt;DisableBaselineAlignment2.txt;;A developer is implementing a complex screen layout using nested LinearLayouts with weights to distribute space proportionally. ;;;;;;;;;;;;
MergeRootFrame;Runtime;Yes;;;;✅;;;;;;;✅;If a <framelayout> is the root of a layout and does not provide background or padding etc, it can often be replaced with a <merge> tag which is slightly more efficient. Note that this depends on context, so make sure you understand how the <merge> tag works before proceeding.;https://googlesamples.github.io/android-custom-lint-rules/checks/MergeRootFrame.md.html;If a FrameLayout is the root layout and does not provide background, padding, etc., it can be replaced with a merge tag to improve efficiency.;*.xml;Warning;MergeRootFrame1.txt;MergeRootFrame2.txt;;A developer is creating a reusable layout component. This layout doesn't provide any background, padding, or other styling. ;;;;;;;;;;;;
DevModeObsolete;Runtime;Yes;;;;✅;;;;;;;✅;In the past, our documentation recommended creating a dev product flavor with has a minSdkVersion of 21, in order to enable multidexing to speed up builds significantly during development. That workaround is no longer necessary, and it has some serious downsides, such as breaking API access checking (since the true minSdkVersion is no longer known). In recent versions of the IDE and the Gradle plugin, the IDE automatically passes the API level of the connected device used for deployment, and if that device is at least API 21, then multidexing is automatically turned on, meaning that you get the same speed benefits as the dev product flavor but without the downsides.;https://googlesamples.github.io/android-custom-lint-rules/checks/DevModeObsolete.md.html;The workaround of creating a dev product flavor with minSdkVersion 21 to enable multidexing is no longer necessary. Multidexing is now handled automatically if the connected device runs API 21 or higher. Simply ensure you're using the appropriate Gradle configuration without the dev flavor workaround.;*.gradle;Warning;DevModeObsolete1.txt;DevModeObsolete2.txt;;"A developer is trying to speed up development builds by creating a separate ""dev"" product flavor";;;;;;;;;;;;
LifecycleAnnotationProcessorWithJava8;Runtime;Yes;;;;✅;;;;;;;✅;"For faster incremental build, switch to the Lifecycle Java 8 API with these steps: First replace annotationProcessor ""androidx.lifecycle:lifecycle-compiler:*version*"" kapt ""androidx.lifecycle:lifecycle-compiler:*version*"" with implementation ""androidx.lifecycle:lifecycle-common-java8:*version*"" Then remove any OnLifecycleEvent annotations from Observer classes and make them implement the DefaultLifecycleObserver interface.";https://googlesamples.github.io/android-custom-lint-rules/checks/LifecycleAnnotationProcessorWithJava8.md.html;"For faster incremental builds, switch to the Lifecycle Java 8 API by replacing annotationProcessor ""androidx.lifecycle:lifecycle-compiler"" with implementation ""androidx.lifecycle:lifecycle-common-java8"". Also, remove any OnLifecycleEvent annotations and use DefaultLifecycleObserver.";*.java, *.kt;Warning;LifecycleAnnotationProcessorWithJava81.txt;LifecycleAnnotationProcessorWithJava82.txt;;A developer is implementing lifecycle-aware components in their application using Java 8. ;;;;;;;;;;;;
AnnotationProcessorOnCompilePath;Runtime;Yes;;;;✅;;;;;;;✅;This dependency is identified as an annotation processor. Consider adding it to the processor path using annotationProcessor instead of including it to the compile path.;https://googlesamples.github.io/android-custom-lint-rules/checks/AnnotationProcessorOnCompilePath.md.html; If an annotation processor is included in the compile classpath, move it to the annotationProcessor path instead to optimize the build process.;*.gradle;Warning;AnnotationProcessorOnCompilePath1.txt;AnnotationProcessorOnCompilePath2.txt;;A developer is adding an annotation processor library (like Dagger or Butterknife) to their project's dependencies;;;;;;;;;;;;
LogConditional;Runtime;Yes;;;;✅;;;;;;;✅;The BuildConfig class provides a constant, DEBUG, which indicates whether the code is being built in release mode or in debug mode. In release mode, you typically want to strip out all the logging calls. Since the compiler will automatically remove all code which is inside a if (false) check, surrounding your logging calls with a check for BuildConfig.DEBUG is a good idea. If you really intend for the logging to be present in release mode, you can suppress this warning with a @SuppressLint annotation for the intentional logging calls.;https://googlesamples.github.io/android-custom-lint-rules/checks/LogConditional.md.html;Wrap log statements in a check for BuildConfig.DEBUG to ensure logging is only active in debug builds and automatically removed from release builds.;*.java, *.kt;Warning;LogConditional1.txt;LogConditional2.txt;;A developer is implementing logging throughout their application for debugging purposes only;;;;;;;;;;;;
WearableBindListener;Runtime;Yes;;;;✅;;;;;;;✅;BIND_LISTENER receives all Android Wear events whether the application needs them or not. This can be inefficient and cause applications to wake up unnecessarily. With Google Play Services 8.2.0 or later it is recommended to use a more efficient combination of manifest listeners and api-based live listeners filtered by action, path and/or path prefix.;https://googlesamples.github.io/android-custom-lint-rules/checks/WearableBindListener.md.html;For Android Wear apps, avoid using the BIND_LISTENER unless necessary, as it can cause inefficiency by waking the app unnecessarily. Use manifest listeners and API-based live listeners instead.;*.xml;Fatal;WearableBindListener1.txt;WearableBindListener2.txt;;A developer is creating a Wear OS application to receive Android Wear events;;;;;;;;;;;;
UsableSpace;Memory;Yes;;;;✅;;;;;;;✅;When you need to allocate disk space for large files, consider using the new allocateBytes(FileDescriptor, long) API, which will automatically clear cached files belonging to other apps (as needed) to meet your request. When deciding if the device has enough disk space to hold your new data, call getAllocatableBytes(UUID) instead of using getUsableSpace(), since the former will consider any cached data that the system is willing to clear on your behalf.Note that these methods require API level 26. If your app is running on older devices, you will probably need to use both APIs, conditionally switching on Build.VERSION.SDK_INT. Lint only looks in the same compilation unit to see if you are already using both APIs, so if it warns even though you are already using the new API, consider moving the calls to the same file or suppressing the warning.;https://googlesamples.github.io/android-custom-lint-rules/checks/UsableSpace.md.html;When allocating disk space for large files, use allocateBytes(FileDescriptor, long) (API level 26+) to clear other app’s cached files if needed. Use getAllocatableBytes(UUID) for checking space availability instead of getUsableSpace().;*.java, *.kt;Warning;UsableSpace1.txt;UsableSpace2.txt;;A developer is implementing a file download manager that needs to check if there's enough space before downloading large media files.;;;;;;;;;;;;
VectorPath;Runtime;Yes;;;;✅;;;;;;;✅;Using long vector paths is bad for performance. There are several ways to make the pathData shorter:Using less precision, Removing some minor details, Using the Android Studio vector conversion tool, Rasterizing the image (converting to PNG);https://googlesamples.github.io/android-custom-lint-rules/checks/VectorPath.md.html;void using long vector paths as they negatively affect performance. You can reduce path data by: Reducing precision, Removing minor details, Using Android Studio's vector conversion tool, Rasterizing the image to PNG (if vector paths are not necessary).;*.java, *.kt, *.xml;Warning;VectorPath1.txt;VectorPath2.txt;;A developer is converting a complex logo from SVG to Android vector drawable format.;;;;;;;;;;;;
UnusedNamespace;Runtime;Yes;;;;✅;;;;;;;✅;Unused namespace declarations take up space and require processing that is not necessary.;https://googlesamples.github.io/android-custom-lint-rules/checks/UnusedNamespace.md.html; Remove unused namespace declarations from your XML files as they take up unnecessary space and require additional processing.;*.java, *.kt, *.xml;Warning;UnusedNamespace1.txt;UnusedNamespace2.txt;;A developer is creating an XML layout file for a new screen in their Android application. When setting up the layout, they include multiple namespace declarations at the root level (such as xmlns:app, xmlns:tools, and xmlns:custom) to access various attributes.;;;;;;;;;;;;
RedundantNamespace;Runtime;Yes;;;;✅;;;;;;;✅;In Android XML documents, only specify the namespace on the root/document element. Namespace declarations elsewhere in the document are typically accidental leftovers from copy/pasting XML from other files or documentation.;https://googlesamples.github.io/android-custom-lint-rules/checks/RedundantNamespace.md.html; Only specify the namespace on the root element of your XML document. Other redundant namespace declarations are typically accidental leftovers from copying/pasting XML code.;*.xml;Warning;RedundantNamespace1.txt;RedundantNamespace2.txt;;"A developer is creating a custom layout by copying elements from various XML files. They inadvertently include namespace declarations (xmlns:android=""http://schemas.android.com/apk/res/android"") on multiple elements within the same document, not just on the root element.";;;;;;;;;;;;
ViewTag;Memory;Yes;;;;✅;;;;;;;✅;Prior to Android 4.0, the implementation of View.setTag(int, Object) would store the objects in a static map, where the values were strongly referenced. This means that if the object contains any references pointing back to the context, the context (which points to pretty much everything else) will leak. If you pass a view, the view provides a reference to the context that created it. Similarly, view holders typically contain a view, and cursors are sometimes also associated with views.;https://googlesamples.github.io/android-custom-lint-rules/checks/ViewTag.md.html;Avoid using View.setTag(int, Object) before Android 4.0 as it could cause memory leaks due to static map references. This can result in the context being leaked if the tag holds a reference back to the context.;*.java, *.kt;Warning;ViewTag1.txt;ViewTag2.txt;;A developer is implementing a ListView with complex items and needs to store references to views for the ViewHolder pattern.;;;;;;;;;;;;
TooManyViews;Runtime;Yes;;;;✅;;;;;;;✅;Using too many views in a single layout is bad for performance. Consider using compound drawables or other tricks for reducing the number of views in this layout.The maximum view count defaults to 80 but can be configured with the environment variable ANDROID_LINT_MAX_VIEW_COUNT.;https://googlesamples.github.io/android-custom-lint-rules/checks/TooManyViews.md.html;Limit the number of views in a single layout. Too many views degrade performance. Consider combining elements using compound drawables or optimizing your layout structure. Example: If you have too many views, try using CompoundDrawables or a flatter layout.;*.xml;Warning;TooManyViews1.txt;TooManyViews2.txt;;A developer is designing a complex settings screen with numerous options. They need create to create a layout with almost 100 individual view elements;;;;;;;;;;;;
TooDeepLayout;Runtime;Yes;;;;✅;;;;;;;✅;Layouts with too much nesting is bad for performance. Consider using a flatter layout (such as RelativeLayout or GridLayout).The default maximum depth is 10 but can be configured with the environment variable ANDROID_LINT_MAX_DEPTH.;https://googlesamples.github.io/android-custom-lint-rules/checks/TooDeepLayout.md.html;Excessively nested layouts impact performance. Consider flattening the layout structure or using more efficient layouts like RelativeLayout or GridLayout.Example: If your layout has more than 10 nested views, consider restructuring it for better performance.;*.xml;Warning;TooDeepLayout1.txt;TooDeepLayout2.txt;;A developer is creating a UI with multiple nested layouts to achieve a specific visual arrangement. ;;;;;;;;;;;;
UseCompoundDrawables;Runtime;Yes;;;;✅;;;;;;;✅;A LinearLayout which contains an ImageView and a TextView can be more efficiently handled as a compound drawable (a single TextView, using the drawableTop, drawableLeft, drawableRight and/or drawableBottom attributes to draw one or more images adjacent to the text).;https://googlesamples.github.io/android-custom-lint-rules/checks/UseCompoundDrawables.md.html;Combine ImageView and TextView using drawableLeft, drawableTop, drawableRight, or drawableBottom attributes to improve performance instead of adding multiple views.;*.xml;Warning;UseCompoundDrawables1.txt;UseCompoundDrawables2.txt;;A developer is creating list items that display an icon next to text. ;;;;;;;;;;;;
UseOfBundledGooglePlayServices;Memory;Yes;;;;✅;;;;;;;✅;Google Play services SDK's can be selectively included, which enables a smaller APK size. Consider declaring dependencies on individual Google Play services SDK's. If you are using Firebase API's(https://firebase.google.com/docs/android/setup), Android Studio's Tools → Firebase assistant window can automatically add just the dependencies needed for each feature.;https://googlesamples.github.io/android-custom-lint-rules/checks/UseOfBundledGooglePlayServices.md.html;Declare dependencies of individual Google Play services SDK's;*.gradle;Warning;UseOfBundledGooglePlayServices1.txt;UseOfBundledGooglePlayServices2.txt;;A developer has to add Google Play Services to their app ;;;;;;;;;;;;
StringFormatTrivial;Runtime;Yes;;;;✅;;;;;;;✅;Every call to String.format creates a new Formatter instance, which will decrease the performance of your app. String.format should only be used when necessary—if the formatted string contains only trivial conversions (e.g. b, s, c) and there are no translation concerns, it will be more efficient to replace them and concatenate with +.;https://googlesamples.github.io/android-custom-lint-rules/checks/StringFormatTrivial.md.html;void using String.format for trivial string formatting as it creates a new Formatter instance, which reduces performance. Instead, concatenate strings where no translation is needed.;*.java, *.kt;Warning;StringFormatTrivial1.txt;StringFormatTrivial2.txt;;A developer is building strings for logging or display.;;;;;;;;;;;;
AssertionSideEffect;Runtime;Yes;;;;✅;;;;;;;✅;There's a lint quickfix to perform this conversion in the Eclipse plugin.;https://googlesamples.github.io/android-custom-lint-rules/checks/AssertionSideEffect.md.html;Make sure assertions do not have side effects in your code as they could cause unnecessary computation in release builds. This could lead to wasted work.;*.java, *.kt;Warning;AssertionSideEffect1.txt;AssertionSideEffect2.txt;;A developer is implementing input validation for a heavy financial calculation. it requires performing assertions to verify that input values are within expected range.;;;;;;;;;;;;
DuplicateStrings;Runtime;Yes;;;;✅;;;;;;;✅;Duplicate strings can make applications larger unnecessarily. This lint check looks for duplicate strings, including differences for strings where the only difference is in capitalization. Title casing and all uppercase can all be adjusted in the layout or in code.;https://googlesamples.github.io/android-custom-lint-rules/checks/DuplicateStrings.md.html;duplicate strings (including those differing only by case). These increase the size of the application unnecessarily.;*.xml;Warning;DuplicateStrings1.txt;DuplicateStrings2.txt;;A developer is localizing their application and has to define multiple similar strings in the strings.xml resource file;;;;;;;;;;;;
ExpensiveAssertion;Runtime;Yes;;;;✅;;;;;;;✅;In Kotlin, assertions are not handled the same way as from the Java programming language. In particular, they're just implemented as a library call, and inside the library call the error is only thrown if assertions are enabled.This means that the arguments to the assert call will always be evaluated. If you're doing any computation in the expression being asserted, that computation will unconditionally be performed whether or not assertions are turned on. This typically turns into wasted work in release builds. This check looks for cases where the assertion condition is nontrivial, e.g. it is performing method calls or doing more work than simple comparisons on local variables or fields.;https://googlesamples.github.io/android-custom-lint-rules/checks/ExpensiveAssertion.md.html;n Kotlin, assertions are implemented as library calls, meaning computations in the assert statement are always evaluated regardless of whether assertions are enabled. Avoid performing expensive computations within assertions.;*.java, *.kt;Warning;ExpensiveAssertion1.txt;ExpensiveAssertion2.txt;;A developer is using Kotlin to implement data validation in a processing pipeline. He need to write an assertion that calls a complex validation method;;;;;;;;;;;;
LaunchActivityFromNotification;Runtime;Yes;;;;✅;;;;;;;✅;Notifications should only launch activities — that's what users expect (and has been the guidance in both the Android SDK and Material Design documentation for a while).;https://googlesamples.github.io/android-custom-lint-rules/checks/LaunchActivityFromNotification.md.html;Notifications should launch activities, as that is what users expect. Avoid launching services or other components from notifications.;*.java, *.kt;Warning;LaunchActivityFromNotification1.txt;LaunchActivityFromNotification2.txt;;A developer is implementing a notification system for their messaging app. When a new message arrives a certain operation needs to start an operation that might need to trigger a background task;;;;;;;;;;;;
NotificationTrampoline;Runtime;Yes;;;;✅;;;;;;;✅;A Service or a BroadcastReceiver should not be used as an intermediate, because this can lead to significant performance problems, and as a result, this will not be allowed in Android 12.;https://googlesamples.github.io/android-custom-lint-rules/checks/NotificationTrampoline.md.html;Avoid using a Service or BroadcastReceiver as an intermediary for launching activities from notifications, as this can cause performance issues. This behavior will be disallowed starting from Android 12.;*.java, *.kt;Error;NotificationTrampoline1.txt;NotificationTrampoline2.txt;;A developer is building a notification feature that needs to perform some background work before showing UI.;;;;;;;;;;;;
AutoboxingStateCreation;Runtime;No;;;;✅;;;;;;;✅;Calling mutableStateOf<t>() when T is either backed by a primitive type on the JVM or is a value class results in a state implementation that requires all state values to be boxed. This usually causes an additional allocation for each state write, and adds some additional work to auto-unbox values when reading the value of the state. Instead, prefer to use a specialized primitive state implementation for Int, Long, Float, and Double when the state does not need to track null values and does not override the default SnapshotMutationPolicy. See mutableIntStateOf(), mutableLongStateOf(), mutableFloatStateOf(), and mutableDoubleStateOf() for more information.;https://googlesamples.github.io/android-custom-lint-rules/checks/AutoboxingStateCreation.md.html;Use mutableIntStateOf(), mutableLongStateOf(), etc. instead of mutableStateOf() for primitives.;*.java, *.kt;Warning;AutoboxingStateCreation1.txt;AutoboxingStateCreation2.txt;;A developer is implementing a Jetpack Compose UI that needs to track an integer counter. ;;;;;;;;;;;;
AutoboxingStateValueProperty;Runtime;No;;;;✅;;;;;;;✅;Avoid using the generic value property when using a specialized State type. Reading or writing to the state's generic value property will result in an unnecessary autoboxing operation. Prefer the specialized value property (e.g. intValue for MutableIntState), or use property delegation to avoid unnecessary allocations.;https://googlesamples.github.io/android-custom-lint-rules/checks/AutoboxingStateValueProperty.md.html;Use .intValue, .longValue, etc., instead of .value when using specialized state types.;*.java, *.kt;Warning;AutoboxingStateValueProperty1.txt;AutoboxingStateValueProperty2.txt;;A developer is working with a specialized MutableIntState in Jetpack Compose. It is required to access the state value;;;;;;;;;;;;
FrequentlyChangedStateReadInComposition;Runtime;Yes;;;;✅;;;;;;;✅;This property is observable and is updated after every scroll or remeasure. If you use it in the composable function directly, it will be recomposed on every change, causing potential performance issues including infinity recomposition loops. Prefer wrapping it with derivedStateOf to use calculation based on this property in composition or collect changes inside LaunchedEffect instead.;https://googlesamples.github.io/android-custom-lint-rules/checks/FrequentlyChangedStateReadInComposition.md.html;Wrap frequently updated state in derivedStateOf to reduce recompositions.;*.java, *.kt;Warning;FrequentlyChangedStateReadInComposition1.txt;FrequentlyChangedStateReadInComposition2.txt;;"A developer is implementing a scrollable list in Jetpack Compose. It it required to implement composable function to show a ""scroll to top"" button";;;;;;;;;;;;
KaptUsageInsteadOfKsp;Runtime;Yes;;;;✅;;;;;;;✅;KSP is a more efficient replacement for kapt. For libraries that support both, KSP should be used to improve build times.;https://googlesamples.github.io/android-custom-lint-rules/checks/KaptUsageInsteadOfKsp.md.html;Switch to KSP for annotation processing if supported.;*.gradle;Warning;KaptUsageInsteadOfKsp1.txt;KaptUsageInsteadOfKsp2.txt;;A developer is setting up dependency injection with Dagger Hilt in their project. They need to configure the build.gradle file to use annotation processing;;;;;;;;;;;;
NotifyDataSetChanged;Runtime;Yes;;;;✅;;;;;;;✅;The RecyclerView adapter's onNotifyDataSetChanged method does not specify what about the data set has changed, forcing any observers to assume that all existing items and structure may no longer be valid. LayoutManagers will be forced to fully rebind and relayout all visible views.;https://googlesamples.github.io/android-custom-lint-rules/checks/NotifyDataSetChanged.md.html;Use specific update methods (notifyItemInserted(), notifyItemRemoved()) or DiffUtil;*.java, *.kt;Warning;NotifyDataSetChanged1.txt;NotifyDataSetChanged2.txt;;A developer is implementing a dynamic list with RecyclerView that updates when new data arrives. ;;;;;;;;;;;;
UnnecessaryArrayInit;Runtime;No;;;;✅;;;;;;;✅;When constructing an array in Kotlin, you don't need to pass a lambda to set the initial value if it's identical to the default or if you're going to overwrite all the values without reading them anyway.;https://googlesamples.github.io/android-custom-lint-rules/checks/UnnecessaryArrayInit.md.html;don't  explicitly inititialize an array with zeroed values if not needed. Example: val startPoints = remember { IntArray(4) { 0 } };*.java, *.kt;Warning;UnnecessaryArrayInit1.txt;UnnecessaryArrayInit2.txt;;A developer is creating an array to store temporary calculation results in Kotlin. ;;;;;;;;;;;;
SyntheticAccessor;Runtime;No;;;;✅;;;;;;;✅;A private inner class which is accessed from the outer class will force the compiler to insert a synthetic accessor. this means that you are causing extra overhead. This is not important in small projects, but is important for large apps running up against the 64K method handle limit, and especially for libraries where you want to make sure your library is as small as possible for the cases where your library is used in an app running up against the 64K limit.;https://googlesamples.github.io/android-custom-lint-rules/checks/SyntheticAccessor.md.html;Change the modifier of the class, method or field to protected or public;*.java, *.kt;Warning;SyntheticAccessor1.txt;SyntheticAccessor2.txt;;A developer is creating a inner class that needs to access fields or methods from the outer class;;;;;;;;;;;;
UseOfNonLambdaOffsetOverload;Runtime;No;;;;✅;;;;;;;✅;Modifier.offset() is recommended to be used with static arguments only to avoid unnecessary recompositions. Modifier.offset{ } is preferred in the cases where the arguments are backed by a State.;https://googlesamples.github.io/android-custom-lint-rules/checks/UseOfNonLambdaOffsetOverload.md.html;Use Modifier.offset {} instead of Modifier.offset(x, y) for state-backed offsets.;*.java, *.kt;Warning;UseOfNonLambdaOffsetOverload1.txt;UseOfNonLambdaOffsetOverload2.txt;;A developer is implementing an animated UI element in Jetpack Compose that changes position based on user interaction.;;;;;;;;;;;;
